{"1":[],"2":[],"3":[],"4":[],"5":[],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[],"13":[],"14":[],"15":[],"16":[],"17":[],"18":[],"19":[],"20":[],"21":[],"22":[],"23":[],"24":[],"25":[],"26":[],"27":[],"28":[],"29":[],"30":[],"31":[],"32":[],"33":[],"34":[],"35":[],"36":[],"37":[],"38":[],"39":[],"40":[],"41":[],"42":[],"43":[],"44":[],"45":[],"46":[],"47":[],"48":[],"49":[],"50":[],"51":[],"52":[],"53":[],"54":[],"55":[],"56":[],"57":[],"58":[],"59":[],"60":[],"61":[],"62":[],"63":[],"64":[],"65":[],"66":[],"67":[],"68":[],"69":[],"70":[],"71":[],"72":[],"73":[],"74":[],"75":[],"76":[],"77":[],"78":[],"79":[],"80":[],"81":[],"82":[],"83":[],"84":[],"85":[],"86":[],"87":[],"88":[],"89":[],"90":[],"91":[],"839781960":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"954545647":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1589210514","body":"js code\n```\n\nvar addToArrayForm = function (num, k) {\n  let i = num.length - 1;\n  let res = [];\n  let carry = 0;\n  while (i >= 0 || k !== 0) {\n    const a = i >= 0 ? num[i] : 0;\n    const b = k !== 0 ? k % 10 : 0;\n    k = Math.floor(k / 10);\n    const sum = a + b + carry;\n    res.push(sum % 10);\n    carry = sum >= 10 ? 1 : 0;\n    i--;\n  }\n  if (carry) res.push(carry);\n  return res.reverse();\n};\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1589256739","body":"jscode 二次遍历正向反向\n```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n  let firstIndex = s.indexOf(c)\n  let lastIndex = s.lastIndexOf(c);\n  const len = s.length;\n  const firstArr = [];\n  const res = [];\n  for (let i = 0; i < len; i++) {\n    const cur = s[i];\n    if (cur === c) {\n      firstIndex = i;\n      firstArr.push(0)\n    } else {\n      firstArr.push(Math.abs(i - firstIndex))\n    }\n  }\n  for (let i = len - 1; i >= 0; i--) {\n    const cur = s[i];\n    if (cur === c) {\n      lastIndex = i;\n      res.push(0)\n    } else {\n      res.push(Math.min(Math.abs(i - lastIndex), firstArr[i]))\n    }\n  }\n\n  return res.reverse()\n};\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1589288451","body":"jscode 模拟题\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.stack = [];\n  this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.stack.length === this.maxSize) return;\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  if (this.stack.length === 0) return -1;\n  return this.stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  const len = this.stack.length;\n  const maxLen = len < k ? len : k;\n  for (let i = 0; i < maxLen; i++) {\n    this.stack[i] = this.stack[i] + val\n  }\n};\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589369012","body":"jscode 维护变量\n```\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  let res = \"\";\n  let temp = [];\n  let count = 0;\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    const cur = s[i];\n    console.log(temp)\n    if (Number.isInteger(Number(cur))) {\n      count = Number(count + cur);\n    } else if (cur === \"[\") {\n      temp.push([res, count])\n      res = \"\";\n      count = 0;\n      continue;\n    } else if (cur === \"]\") {\n      const [str, count] = temp.pop();\n      const val = res.repeat(count);\n      res = str + val;\n      continue;\n    } else {\n      res += cur\n    }\n  }\n  return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590359832","body":"jscode 栈模拟：也就是可以使用push和pop方法\n```\nvar MyQueue = function () {\n  this.stack = [];\n  this.help = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  if (!this.help.length) {\n    while (this.stack.length) {\n      this.help.push(this.stack.pop());\n    }\n  }\n  return this.help.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  if (!this.help.length) {\n    while (this.stack.length) {\n      this.help.push(this.stack.pop());\n    }\n  }\n  return this.help[this.help.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return this.stack.length === 0 && this.help.length === 0\n};\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594156691","body":"```\nvar rotateRight = function (head, k) {\n  if (k === 0 || !head || !head.next) return head\n  let len = 1;\n  let temp = head;\n  while (temp && temp.next) {\n    temp = temp.next;\n    len++\n  }\n  temp.next = head; // 将链表形成环\n  temp = head;\n  // 找到最后一个节点断开即可\n  let last = len - k % len - 1;\n  while (last) {\n    temp = temp.next;\n    last--;\n  }\n  const first = temp.next;\n  temp.next = null;\n  return first\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1619371931","body":"迭代和递归\n```js\nvar swapPairs = function (head) {\n  if (!head) return head\n  const dummy = new ListNode(null);\n  dummy.next = head;\n  let temp = dummy;\n  while (temp && temp.next && temp.next.next) {\n    const one = temp.next;\n    const two = temp.next.next;\n    temp.next = two;\n    one.next = two.next;\n    two.next = one;\n    temp = one;\n  }\n  return dummy.next;\n};\n\nvar swapPairs = function (head) {\n  if (!head) return head\n  const dummy = new ListNode(null);\n  dummy.next = head;\n  let temp = dummy;\n  const dfs = (root) => {\n    if (!root && !root.next && !root.next.next) return\n    const one = root.next;\n    const two = root.next.next;\n    root.next = two;\n    one.next = two.next;\n    two.next = one;\n    dfs(one)\n  }\n  dfs(temp)\n  return dummy.next;\n};\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1600475878","body":"```\nvar sortedListToBST = function (head) {\n  if (!head) return head;\n  let temp = head;\n  const arr = []\n  while (temp) {\n    arr.push(temp.val);\n    temp = temp.next;\n  }\n\n  function bfs(start, end) {\n    if (start > end) return null;\n    const middle = Math.floor((start + end) / 2);\n    const val = arr[middle];\n    const root = new TreeNode(val);\n    root.left = bfs(start, middle - 1);\n    root.right = bfs(middle + 1, end);\n    return root\n  }\n\n  return bfs(0, arr.length - 1)\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1600404036","body":"```\nvar getIntersectionNode = function (headA, headB) {\n  let a = headA,\n    b = headB;\n  while (a != b) {\n    a = a === null ? headB : a.next;\n    b = b === null ? headA : b.next;\n  }\n  return a;\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1600342522","body":"用set记录访问\n```\nvar detectCycle = function (head) {\n  if (!head) return head;\n  let temp = new ListNode(null);\n  temp.next = head;\n  const set = new Set();\n  while (temp) {\n    if (set.has(temp)) {\n      return temp;\n    } else {\n      set.add(temp);\n      temp = temp.next;\n    }\n  }\n  return null\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600273596","body":"jscode 模拟\n```\nclass ListNode {\n  constructor(key, val) {\n    this.val = val;\n    this.key = key;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n  this.capacity = capacity;\n  this.map = new Map();\n  this.count = 0;\n  this.dummyHead = new ListNode(null, null);\n  this.dummyTail = new ListNode(null, null);\n  this.dummyHead.next = this.dummyTail;\n  this.dummyTail.prev = this.dummyHead;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n  // 如果有直接返回，并且更新位置\n  if (this.map.has(key)) {\n    const node = this.map.get(key);\n    // 更新位置\n    this.moveToHead(node);\n    return node.val;\n  } else {\n    return -1;\n  }\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n\n  // 如果没有达到缓存数目，则直接添加到头部\n  const node = this.map.get(key);\n  if (node) {\n    // 如果已经存在了，则更新值&&移动到头部\n    node.val = value;\n    this.moveToHead(node);\n  } else {\n    // 需要判断容量是否达到上限\n    if (this.count === this.capacity) {\n      this.removeLRUItem();\n    }\n    const newNode = new ListNode(key, value);\n    this.map.set(key, newNode);\n    // 新结点插入到头部\n    this.addToHead(newNode);\n    this.count++\n  }\n};\n\n\nLRUCache.prototype.moveToHead = function (node) {\n  // 先删除节点\n  this.removeFromList(node);\n  // 再添加到头节点\n  this.addToHead(node);\n}\n\nLRUCache.prototype.removeFromList = function (node) {\n  const prev = node.prev;\n  const next = node.next;\n  prev.next = next;\n  next.prev = prev;\n}\n\nLRUCache.prototype.addToHead = function (node) {\n  node.prev = this.dummyHead;\n  node.next = this.dummyHead.next;\n  this.dummyHead.next.prev = node;\n  this.dummyHead.next = node;\n}\n\nLRUCache.prototype.removeLRUItem = function () {\n  let tail = this.popTail();\n  this.map.delete(tail.key);\n  this.count--;\n}\n\nLRUCache.prototype.popTail = function () {\n  let tail = this.dummyTail.prev;\n  this.removeFromList(tail);\n  return tail;\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1606756855","body":"递归和dfs\n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n  if (!root) return 0;\n  return Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1)\n};\n\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n  if (!root) return 0;\n  const queue = [root];\n  let deep = 0;\n  while (queue.length) {\n    let size = queue.length;\n    deep++;\n    while (size > 0) {\n      const cur = queue.shift();\n      if (cur.left) queue.push(cur.left);\n      if (cur.right) queue.push(cur.right);\n      size--\n    }\n  }\n  return deep;\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1606840302","body":"递归和bfs\n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function (p, q) {\n  if ((p === null && q !== null) || (p !== null && q === null)) return false;\n  if (p === null && q === null) return true;\n  if (p.val !== q.val) return false;\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function (p, q) {\n  if (p && q && p.val !== q.val) return false;\n  let a = cal(p, []);\n  let b = cal(q, []);\n\n  function cal(root, arr) {\n    if (!root) return [];\n    const queue = [root];\n    while (queue.length) {\n      const cur = queue.shift();\n      if (cur.left) {\n        queue.push(cur.left)\n        arr.push(cur.left.val)\n      } else {\n        arr.push(undefined)\n      }\n      if (cur.right) {\n        queue.push(cur.right)\n        arr.push(cur.right.val)\n      } else {\n        arr.push(undefined)\n      }\n    }\n    return arr;\n  }\n  return a.join(\",\") === b.join(\",\")\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1606884554","body":"bfs和dfs\n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nfunction sumNumbers(root) {\n  let sum = 0;\n  function dfs(root, cur) {\n    if (!root) {\n      return;\n    }\n    let curSum = cur * 10 + root.val;\n    if (!root.left && !root.right) {\n      sum += curSum;\n      return;\n    }\n    dfs(root.left, curSum);\n    dfs(root.right, curSum);\n  }\n  dfs(root, 0);\n  return sum;\n}\n\n// bfs\nvar sumNumbers = function (root) {\n  if (!root) return 0;\n  let queue = [root];\n  let sum = 0;\n  while (queue.length) {\n    const cur = queue.shift();\n    if (cur.left) {\n      cur.left.val = 10 * cur.val + cur.left.val;\n      queue.push(cur.left)\n    }\n    if (cur.right) {\n      cur.right.val = 10 * cur.val + cur.right.val;\n      queue.push(cur.right)\n    }\n    if (!cur.left && !cur.right) {\n      sum += cur.val;\n    }\n  }\n  return sum;\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1607062695","body":"bfs 和 dfs\n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function (root) {\n  if (!root) return root;\n  const queue = [root];\n  let val = root.val;\n  while (queue.length) {\n    let len = queue.length;\n    while (len) {\n      const cur = queue.shift();\n      if (cur.right) {\n        queue.push(cur.right);\n        val = cur.right.val;\n      }\n      if (cur.left) {\n        queue.push(cur.left);\n        val = cur.left.val;\n      }\n      len--;\n    }\n  }\n  return val\n};\n\n\n\nvar findBottomLeftValue = function (root) {\n  let res = root.val;\n  let maxDeep = -1;\n  function helper(root, depth) {\n    if (!root) return;\n    if (depth >= maxDeep) {\n      res = root.val;\n      maxDeep = depth;\n    }\n    helper(root.right, depth + 1)\n    helper(root.left, depth + 1)\n  }\n  helper(root, 0)\n  return res;\n};\n\n\n```","onTime":false},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616681016","body":"```js\nvar findSubstring = function (s, words) {\n  const len = words[0]?.length || 0;\n  const map = {};\n  const res = [];\n  //   哈希表，记录单词出现次数\n  for (let word of words) {\n    map[word] = (map[word] || 0) + 1;\n  }\n  console.log(map)\n\n  //   遍历所有字串\n  for (let i = 0; i < s.length; i++) {\n    const cache = { ...map };\n    for (let j = 0; j < words.length; j++) {\n      // 由于 words 的单词长度相同，因此 i+j*len 就是下一个 parts 的起点\n      //   由于每个 parts 的长度也是固定的 words[0]\n      const curSub = s.substr(i + j * len, len);\n      if (!cache[curSub]) {\n        //   对应不上，意味着此种方法分割不正确，尝试下一种\n        break;\n      } else {\n        //   找到一个做解法\n        cache[curSub]--;\n        // 如果到末尾都没有发现不正确，那么我们就得到了一种可行解\n        if (j === words.length - 1) {\n          res.push(i);\n        }\n      }\n    }\n  }\n  return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1617729660","body":"```js\nvar floorMod = function (a, b) {\n  return ((a % b) + b) % b;\n};\nfunction minSubarray(nums, k) {\n  var map = new Map();\n  map.set(0, -1);\n  var res = nums.length;\n  var target = 0;\n  var currSum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    target += nums[i];\n  }\n  target = target % k;\n  if (target === 0) return 0;\n  for (let i = 0; i < nums.length; i++) {\n    currSum = (nums[i] + currSum) % k;\n    console.log(currSum, target)\n\n    // var prevSum = floorMod(currSum - target, k);\n    if (map.has(currSum)) {\n      res = Math.min(res, i - map.get(currSum));\n    }\n    map.set(currSum, i);\n  }\n  return res === nums.length ? -1 : res;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1619353062","body":"easy!\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n  if (!head) return head\n  let slow = fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return slow;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1627609783","body":"暴力和双子针写法\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function (nums) {\n  let len = nums.length;\n  if (len === 0 || len === 1) return nums.length;\n  if (len === 2 && nums[0] !== nums[1]) return 2;\n  let left = 0;\n  let right = 1;\n  while (right < len) {\n    const letVal = nums[left];\n    const rightVal = nums[right];\n    if (letVal === rightVal) {\n      nums.splice(right, 1);\n      len--\n    } else {\n      left++;\n      right++;\n    }\n  }\n  return nums.length;\n};\n\n\nvar removeDuplicates = function (nums) {\n  const len = nums.length;\n  if (len === 0 || len === 1) return nums.length;\n  if (len === 2 && nums[0] !== nums[1]) return 2;\n  let left = 0;\n  let right = 1;\n  while (right < len) {\n    const letVal = nums[left];\n    const rightVal = nums[right];\n    if (letVal === rightVal) {\n      right++\n    } else {\n      left++\n      nums[left] = rightVal;\n    }\n  }\n  return left + 1;\n};\n\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1635201617","body":"```js\nvar searchInsert = function (nums, target) {\n  const len = nums.length;\n  let left = 0;\n  let right = len - 1;\n  while (left <= right) {\n    const middle = Math.floor((right - left) / 2) + left;\n    if (target === nums[middle]) {\n      return middle;\n      break;\n    }\n    if (target < nums[middle]) {\n      right = middle - 1;\n    } else {\n      left = middle + 1;\n    }\n  }\n  return left;\n};\n\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627606320","body":"```js\nconst possibleBipartition = (N, dislikes) => {\n  let graph = [...Array(N + 1)].map(() => Array()), // 动态创建二维数组\n    colors = Array(N + 1).fill(-1);\n\n  // build the undirected graph\n  for (const d of dislikes) {\n    graph[d[0]].push(d[1]);\n    graph[d[1]].push(d[0]);\n  }\n\n  const dfs = (cur, color = 0) => {\n    colors[cur] = color;\n    for (const nxt of graph[cur]) {\n      if (colors[nxt] !== -1 && colors[nxt] === color) return false; // conflict\n      if (colors[nxt] === -1 && !dfs(nxt, color ^ 1)) return false;\n    }\n    return true;\n  };\n\n  for (let i = 0; i < N; ++i) if (colors[i] === -1 && !dfs(i, 0)) return false;\n\n  return true;\n};\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1635193851","body":"```js\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function (moves) {\n  let horizontal = 0;\n  let vertical = 0;\n  for (let i = 0; i < moves.length; i++) {\n    const move = moves[i];\n    if (move === \"L\") {\n      horizontal -= 1;\n    } else if (move === \"R\") {\n      horizontal += 1;\n    } else if (move === \"U\") {\n      vertical += 1;\n    } else {\n      vertical -= 1;\n    }\n  }\n  if (horizontal === 0 && vertical === 0) return true;\n  return false;\n};\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635220422","body":"```js\nclass Solution:\n    def minCharacters(self, A: str, B: str) -> int:\n        counter_A = [0] * 26\n        counter_B = [0] * 26\n        for a in A:\n            counter_A[ord(a) - ord('a')] += 1\n        for b in B:\n            counter_B[ord(b) - ord('a')] += 1\n        ans = len(A) + len(B)\n        for i in range(26):\n            ans = min(ans, len(A) + len(B) - counter_A[i] - counter_B[i])\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_A[j]\n            for j in range(i):\n                t += counter_B[j]\n            ans = min(ans, t)\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_B[j]\n            for j in range(i):\n                t += counter_A[j]\n            ans = min(ans, t)\n        return ans\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1640492426","body":"```\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        tb, res = [], 0\n        for n in reversed(nums) :\n            res += bisect.bisect_left(tb, n)\n            n2 = 2*n\n            idx = bisect.bisect_left(tb, n2)\n            tb.insert(idx, n2)\n        return res\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1541732340":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"michaelxi3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585523282","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n \n\n示例 1：\n\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n \n\n提示：\n\n1 <= num.length <= 104\n0 <= num[i] <= 9\nnum 不包含任何前导零，除了零本身\n1 <= k <= 104\n```\n\n## 前置知识\n\n- 数组\n\n## 公司\n\n- 暂无\n\n## 思路\nWe iterate over num and k, performing the addition digit by digit, and storing the result in the result list. The carry is calculated by dividing the sum by 10. After the addition loop, we reverse the result list and return it.\n## 关键点\n\n-  Reverse the list before return the result\n- k % 10 as result digit, k /10 as carry\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        int i = num.length - 1;\n\n        while(i >= 0 || k > 0) {\n            if(i >= 0) {\n                k += num[i--];\n            }\n            result.add(k % 10);\n            k /= 10;\n        }\n\n        Collections.reverse(result);\n        return result;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585708899","body":"``` JavaScript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    let n = num.length;\r\n    for(let i = n -1; i >= 0; i--)\r\n    {\r\n        let sum = num[i] + k%10;\r\n        k = Math.floor(k/10);\r\n        if(sum>=10)\r\n        {\r\n            k++;\r\n            sum = sum -10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for(;k>0;k = Math.floor(k/10))\r\n    {\r\n        res.push(k%10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586219133","body":"```JavaScript\nvar shortestToChar = function(s, c) {\n    let res = Array(s.length);\n\n    //贪心法\n    //先从左到右遍历\n    for(let i = 0 ;i <s.length ; i++)\n    {\n        if(s[i] === c)\n        {\n            res[i] = i;\n        }else{\n            //void 0 == undefined)，如果\n            res[i] = (res[i-1] === void 0 ? Infinity : res[i-1]);\n        }\n    }\n    //从右往左遍历\n    for(let i = s.length -1; i>= 0;i--)\n    {\n        \n        if(res[i] === Infinity || res[i+1] - i < i- res[i])\n        {\n            res[i] = res[i+1];\n        }\n    }\n    for(let i = 0 ;i <res.length ; i++){\n        res[i] = Math.abs(res[i] - i);\n    }\n    return res;\n};\n```\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587517873","body":"```JavaScript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    //用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\n    this.max = maxSize;\r\n    this.stack = [];\r\n\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    //如果栈还未增长到 maxSize ，就将 x 添加到栈顶\r\n    if(this.stack.length < this.max)\r\n    {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    //弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1\r\n   var res = this.stack.pop();\r\n   return res == null ? -1 : res;\r\n   \r\n\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i = 0 ; i < this.stack.length;i++)\r\n    {\r\n        if(i <k)\r\n        {\r\n            this.stack[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591520076","body":"```JavaScript\n// 使用两个数组的栈方法（push, pop） 实现队列\n/**\n* Initialize your data structure here.\n*/\nvar MyQueue = function() {\n   this.stackIn = [];\n   this.stackOut = [];\n};\n\n/**\n* Push element x to the back of queue. \n* @param {number} x\n* @return {void}\n*/\nMyQueue.prototype.push = function(x) {\n   this.stackIn.push(x);\n};\n\n/**\n* Removes the element from in front of queue and returns that element.\n* @return {number}\n*/\nMyQueue.prototype.pop = function() {\n   const size = this.stackOut.length;\n   if(size) {\n       return this.stackOut.pop();\n   }\n   while(this.stackIn.length) {\n       this.stackOut.push(this.stackIn.pop());\n   }\n   return this.stackOut.pop();\n};\n\n/**\n* Get the front element.\n* @return {number}\n*/\nMyQueue.prototype.peek = function() {\n   const x = this.pop();\n   this.stackOut.push(x);\n   return x;\n};\n\n/**\n* Returns whether the queue is empty.\n* @return {boolean}\n*/\nMyQueue.prototype.empty = function() {\n   return !this.stackIn.length && !this.stackOut.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594803610","body":"#### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n```\n#### 复杂度分析\n- 时间复杂度: $O(N)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595787794","body":"### 解题思路\n1. 设置虚拟节点，定义pre指针，指向当前虚拟节点\n2. 当pre.next以及pre.next.next指针均不为空时，开始交换\n3. 令cur指针指向pre.next；next指针指向pre.next.next\n4. 交换过程如下：\n- pre.next = next\n- cur.next = next.next\n- next.next = cur\n- pre = cur\n\n### 代码实现\njavaScript\n\n```\nvar swapPairs = function(head) {\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    let pre = dummyNode;\n    while(pre.next && pre.next.next) {\n        const cur = pre.next;\n        const next = pre.next.next;\n        pre.next = next;\n        cur.next = next.next;\n        next.next = cur;\n        pre = cur;\n    }\n    return dummyNode.next;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$, N为链表中节点数目\n- 空间复杂度 $O(1)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1597358146","body":"### 解题思路：\n1. 使用pA、pB两个指针分别指向A、B两个链表，两个指针以相同的速率向后移动\n2. 当pA指针移动到了A链接的末尾、令指针pA指向B链表的头部\n3. 当pB指针移动到了A链接的末尾、令指针pB指向A链表的头部\n4. 当pA、pB指针相遇时即为两个指针相遇的起点，否则两个指针不相交\n\n```\nvar getIntersectionNode = function(headA, headB) {\n    let pA = headA;\n    let pB = headB;\n    while (pA != pB) {\n        pA = pA === null ? headB : pA.next;\n        pB = pB === null ? headA : pB.next;\n    }\n    return pA;\n};\n```\n### 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度 O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600913335","body":"### 解题思路\n    采用哈希表,保证get操作在O(1)时间复杂度内完成，\n    构建双向链表，保证put操作在O(1)时间复杂度内完成\n### 代码实现\n> javaScript\n\n```\nvar LinkedList = function(key, val) {\n    this.key = key;\n    this.val = val;\n    this.prev = null;\n    this.next = null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.size = 0;\n    this.cache = new Map();\n    // 构建虚拟节点\n    this.dummyHead = new LinkedList();\n    this.dummyTail = new LinkedList();\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (!this.cache.has(key)) {\n        return -1;\n    }\n    const node = this.cache.get(key);\n    // 将节点移动至链表头部\n    this.removeNode(node);\n    this.appendToHead(node);\n    return node.val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 判断关键字key是否存在于缓存中\n    const node = this.cache.get(key);\n    if (node) {\n        // 更新关键字的值\n        node.val = value;\n        this.cache.set(key, node);\n        // 将关键字移动至链表头部\n        this.removeNode(node);\n        this.appendToHead(node);\n    } else {\n        // 当缓存容量达到上限时\n        if (this.size === this.capacity) {\n            // 删除最久未使用的\n            this.removeTailNode();\n        }\n        // 创建新节点\n        const newNode = new LinkedList(key, value);\n        this.cache.set(key, newNode)\n        this.appendToHead(newNode);\n        this.size ++;\n    }\n};\n\nLRUCache.prototype.removeNode = function(node) {\n    let preNode = node.prev;\n    let nextNode = node.next;\n    preNode.next = nextNode;\n    nextNode.prev = preNode;\n}\n\nLRUCache.prototype.appendToHead = function(node) {\n    let head = this.dummyHead.next;\n    this.dummyHead.next = node;\n    node.prev = this.dummyHead;\n    node.next = head;\n    head.prev = node;\n}\n\nLRUCache.prototype.removeTailNode = function() {\n    this.size --;\n    let tailNode = this.dummyTail.prev;\n    this.cache.delete(tailNode.key);\n    this.removeNode(tailNode);\n}\n```\n### 复杂度分析\n- 时间复杂度：$O(1)$ \n- 空间复杂度：$O(capacity)$","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1606083092","body":"### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n  if(!root) return null;\n  const queue = [root]\n  let mostLeft = null;\n  while(queue.length > 0){\n    let curLevelSize = queue.length\n    mostLeft = queue[0]\n    for(let i = 0; i < curLevelSize; i++){\n      const curNode = queue.shift();\n      curNode.left && queue.push(curNode.left)\n      curNode.right&& queue.push(curNode.right)\n    }\n  }\n  return mostLeft.val\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为二叉树的节点\n- 空间复杂度 $O(N)$ N为二叉树的节点","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607669012","body":"### 解题思路\n> DFS（递归）\n\n### 代码实现\n> javaScript\n\n```\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nconst serialize = (root) => {\n  if (root == null) {                  // 遍历到 null 节点\n    return 'X';\n  } \n  const left = serialize(root.left);   // 左子树的序列化结果\n  const right = serialize(root.right); // 右子树的序列化结果\n  return root.val + ',' + left + ','+ right; // 按  根,左,右  拼接字符串\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  const list = data.split(',');   // split成数组\n\n  const buildTree = (list) => {   // 基于list构建当前子树\n    const rootVal = list.shift(); // 弹出首项，获取它的“数据”\n    if (rootVal == \"X\") {         // 是X，返回null节点\n      return null;\n    }\n    const root = new TreeNode(rootVal); // 不是X，则创建节点\n    root.left = buildTree(list);        // 递归构建左子树\n    root.right = buildTree(list);       // 递归构建右子树\n    return root;                        // 返回当前构建好的root\n  };\n\n  return buildTree(list);\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1609588064","body":"### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n  if(!root) return root\n  const result = []\n  const obj = new Map();\n  // [node, rowVal, colVal]\n  const queue = [[root,0, 0]]\n\n  while(queue.length){\n    const [node, row, col] = queue.shift()\n    obj.set(col, (obj.get(col) || []).concat([[node.val, row]]))\n    node.left && queue.push([node.left, row + 1, col - 1 ])\n    node.right && queue.push([node.right, row + 1 , col + 1 ])\n  }\n\n  // sort\n  let sortedKeys = [...obj.keys()].sort((a,b) => a - b)\n\n  for(const key of sortedKeys){\n    let temp = obj.get(key)\n    temp = temp.sort((a,b) => {\n      if(a[1] != b[1]){\n        return a[1] - b[1]\n      }\n      return a[0] - b[0]\n    })\n    result.push(temp.map((item) => item[0]))\n  }\n  return result;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(NlogN)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1611550782","body":"### 解题思路\n> 哈希表\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const hashMap = new Map();\n    for(let i = 0; i < nums.length; i++){\n      if (hashMap.has(target - nums[i])) {\n        return [hashMap.get(target - nums[i]), i]\n      } else {\n        hashMap.set(nums[i], i)\n      }\n    }\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ \n- 空间复杂度 $O(N)$ ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1613320650","body":"### 解题思路\n> 桶排序\n\n### 代码实现\n> javaScript\n\n```\nlet topKFrequent = function(nums, k) {\n    let map = new Map(), arr = [...new Set(nums)]\n    nums.map((num) => {\n        if(map.has(num)) map.set(num, map.get(num)+1)\n        else map.set(num, 1)\n    })\n    \n    // 如果元素数量小于等于 k\n    if(map.size <= k) {\n        return [...map.keys()]\n    }\n    \n    return bucketSort(map, k)\n};\n\n// 桶排序\nlet bucketSort = (map, k) => {\n    let arr = [], res = []\n    map.forEach((value, key) => {\n        // 利用出现频率作为下标，将数据分配到各个桶中\n        if(!arr[value]) {\n            arr[value] = [key]\n        } else {\n            arr[value].push(key)\n        }\n    })\n    // 倒序遍历获取出现频率最大的前k个数\n    for(let i = arr.length - 1;i >= 0 && res.length < k;i--){\n        if(arr[i]) {\n            res.push(...arr[i])\n        }\n\t}\n\treturn res\n}\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1620227499","body":"#### 解题思路\n> 双指针\n\n#### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n  let slow = (fast = head);\n  while (slow && fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  return slow;\n};\n```\n#### 复杂度分析\n- 时间复杂度: $O(N)$\n\n- 空间复杂度: $O(1)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627758159","body":"### 解题思路\n> DFS\n\n### 代码实现\n> JavaScript\n\n```\nvar possibleBipartition = function(n, dislikes) {\n    const dfs = (curnode, nowcolor, color, g) => {\n        color[curnode] = nowcolor;\n        for (const nextnode of g[curnode]) {\n            if (color[nextnode] !== 0 && color[nextnode] === color[curnode]) {\n                return false;\n            }\n            if (color[nextnode] === 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    const color = new Array(n + 1).fill(0);\n    const g = new Array(n + 1).fill(0);\n    for (let i = 0; i <= n; ++i) {\n        g[i] = [];\n    }\n    for (const p of dislikes) {\n        g[p[0]].push(p[1]);\n        g[p[1]].push(p[0]);\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (color[i] === 0 && !dfs(i, 1, color, g)) {\n            return false;\n        }\n    }\n    return true;\n};\n```\n### 复杂度分析\n- 时间复杂$:$O(n+m)$\n\n- 空间复杂度: $O(n+m)$","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1636795855","body":"#### 解题思路\n> 快速排序\n\n#### 代码实现\n```\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortArray = function(nums) {\n    function quickSort(nums, left = 0, right = nums.length - 1) {\n        if(right >= 1) {\n            let index = partition(nums, left, right);\n            if(left < index - 1) {\n                quickSort(nums, left, index - 1);\n            }\n\n            if(right > index) {\n                quickSort(nums, index, right);\n            }\n        }\n    }\n\n    function partition(nums, left, right) {\n        let pivot = nums[Math.floor(left + (right - left) / 2)];\n        while(left <= right) {\n            while(nums[left] < pivot) {\n                left++;\n            }\n\n            while(nums[right] > pivot) {\n                right--;\n            }\n\n            if(left <= right) {\n                [nums[left], nums[right]] = [nums[right], nums[left]];\n                left++;\n                right--;\n            }\n        }\n        return left;\n    }\n    quickSort(nums);\n    return nums;\n};\n```\n#### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(1)$","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/45#issuecomment-1646607497","body":"\n##### 代码实现\n```\nvar maxVowels = function(s, k) {\n  let vowel = 'aeiou', len = s.length, count = 0, max = 0, i = 0;\n  \n  for (; i < k; i++) {\n    let curr = s.charAt(i);\n    if (vowel.indexOf(curr) !== -1) count++;\n  }\n  max = Math.max(max, count);\n  \n  for (; i < len; i++) {\n    let curr = s.charAt(i),\n        last = s.charAt(i - k);\n    if (vowel.indexOf(curr) !== -1) count++;\n    if (vowel.indexOf(last) !== -1) count--;\n    max = Math.max(count, max);\n  }\n  \n  return max;\n};\n\n```\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/52#issuecomment-1656725524","body":"### 解题思路\n> DFS\n1. 从陆地出发，遍历该陆地所在的岛屿\n-   从隶属于该岛屿的某一块陆地出发，向四个方向递归地进行DFS\n- 每次递归对下标进行判断，以区域的边界作为递归边界\n- 将已访问过的陆地置为0，以保证每块陆地只访问一次\n- 递归地返回整块岛屿陆地面积\n2. 找出所有岛屿的最大值\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxAreaOfIsland = function(grid) {\n    let x = grid.length;\n    let y = grid[0].length;\n    let max = 0;\n    // 遍历二维数组\n    for (let i = 0; i < x; i ++) {\n       for (let j = 0; j < y; j ++) {\n           if (grid[i][j] === 1) {\n               max = Math.max(max, areaOfIsland(grid, i, j, x, y));\n           }\n       } \n    }\n    return max;\n};\n\nvar areaOfIsland = function(grid, i, j, x, y) {\n    // 判断边界条件\n    if(i < 0 || i >= x || j < 0 || j >= y || grid[i][j] === 0) {\n        return 0\n    }\n    let ans = 1;\n    // 将遍历过的岛屿标记为0\n    grid[i][j] = 0;\n    // 遍历岛屿四周\n    ans += areaOfIsland(grid, i + 1, j, x, y);\n    ans += areaOfIsland(grid, i - 1, j, x, y);\n    ans += areaOfIsland(grid, i, j + 1, x, y);\n    ans += areaOfIsland(grid, i, j - 1, x, y);\n    return ans;\n}\n```\n### 复杂度分析\n- 时间复杂度 $O(R * C )$, 其中R为二维数组行数，C位列数\n- 空间复杂度 $O(R * C )$, 其中R为二维数组行数，C位列数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593006668","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        ans = 0\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        for a,b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b:\n                ans += 1 \n        return ans\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1606415028","body":"```\r\nfunc (this *Codec) serialize(root *TreeNode) string {\r\n\tif root == nil {\r\n\t\treturn \"#\"\r\n\t}\r\n\treturn strconv.Itoa(root.Val) + \",\" + this.serialize(root.Left) + \",\" + this.serialize(root.Right)\r\n}\r\n\r\n\r\nfunc dfs(valsPtr *[]string) *TreeNode {\r\n\tval := (*valsPtr)[0]\r\n\t*valsPtr = (*valsPtr)[1:]\r\n\tif val == \"#\" {\r\n\t\treturn nil\r\n\t}\r\n\tvalInt, _ := strconv.Atoi(val)\r\n\tnode := &TreeNode{Val: valInt}\r\n\tnode.Left = dfs(valsPtr)\r\n\tnode.Right = dfs(valsPtr)\r\n\treturn node\r\n}\r\n\r\nfunc (this *Codec) deserialize(data string) *TreeNode {\r\n\tvals := strings.Split(data, \",\")\r\n\treturn dfs(&vals)\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1608696621","body":"```\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\ntype Node struct {\n\tRow   int\n\tValue int\n}\n\n// NodeMap: { [col]: [val1, val2] }\ntype NodeMap map[int][]Node\n\nfunc (nodeMap NodeMap) GetResult() [][]int {\n\tkeys := make([]int, 0, len(nodeMap))\n\tresult := make([][]int, 0, len(nodeMap))\n\n\tfor k := range nodeMap {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Ints(keys)\n\tfor _, k := range keys {\n\t\tvar list []int\n\t\tnodeList := nodeMap[k]\n\t\tsort.Slice(nodeList, func(i, j int) bool {\n\t\t\tif nodeList[i].Row < nodeList[j].Row {\n\t\t\t\treturn true\n\t\t\t} else if nodeList[i].Row > nodeList[j].Row {\n\t\t\t\treturn false\n\t\t\t} else if nodeList[i].Value < nodeList[j].Value {\n\t\t\t\treturn true\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\t\t})\n\t\tfor _, n := range nodeList {\n\t\t\tlist = append(list, n.Value)\n\t\t}\n\t\tresult = append(result, list)\n\t}\n\treturn result\n}\n\nfunc traverTree(node *TreeNode, row, col int, nodeMap NodeMap) {\n\t// 递归结束条件，如果节点不存在则返回\n\tif node == nil {\n\t\treturn\n\t}\n\t// 将当前 node 信息添加进 nodeMap 中\n\tif v, ok := nodeMap[col]; !ok {\n\t\tnodeMap[col] = []Node{Node{Row: row, Value: node.Val}}\n\t} else {\n\t\tnodeMap[col] = append(v, Node{Row: row, Value: node.Val})\n\t}\n\ttraverTree(node.Left, row+1, col-1, nodeMap)\n\ttraverTree(node.Right, row+1, col+1, nodeMap)\n}\n\nfunc verticalTraversal(root *TreeNode) [][]int {\n\tnodeMap := NodeMap{}\n\ttraverTree(root, 0, 0, nodeMap)\n\treturn nodeMap.GetResult()\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1610428906","body":"```\r\nfunc twoSum(nums []int, target int) []int {\r\n    // m = { value: index }\r\n    m := make(map[int]int)\r\n    for i, v := range nums {\r\n        if index, ok := m[target - v]; !ok {\r\n            m[v] = i\r\n        } else {\r\n            return []int{index, i}\r\n        }\r\n    }\r\n    return []int{}\r\n}\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1619355760","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc middleNode(head *ListNode) *ListNode {\r\n    slow, fast := head, head\r\n    for fast != nil && fast.Next != nil {\r\n        slow = slow.Next\r\n        fast = fast.Next.Next\r\n    }\r\n    return slow\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1629987587","body":"```\r\nfunc judgeCircle(moves string) bool {\r\n    x, y := 0, 0\r\n\tfor _, v := range moves {\r\n\t\tif v == 'L' {\r\n\t\t\tx--\r\n\t\t} else if v == 'R' {\r\n\t\t\tx++\r\n\t\t} else if v == 'U' {\r\n\t\t\ty++\r\n\t\t} else if v == 'D' {\r\n\t\t\ty--\r\n\t\t}\r\n\t}\r\n\treturn x == 0 && y == 0\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1639574352","body":"```\r\nfunc reversePairs(nums []int) int {\r\n    var res int\r\n    mergeSort(nums, &res)\r\n    return res\r\n}\r\nfunc mergeSort(nums []int, res *int) []int {\r\n    if len(nums) <= 1 {\r\n        return nums\r\n    }\r\n    var mergedArray []int\r\n    array1 := nums[:(len(nums) - 1) / 2 + 1]\r\n    array2 := nums[(len(nums) - 1) / 2 + 1:]\r\n    sortArray1 := mergeSort(array1, res)\r\n    sortArray2 := mergeSort(array2, res)\r\n    for i := 0; i < len(sortArray1); i++ {\r\n        m, n := 0, len(sortArray2) - 1\r\n        for m < n {\r\n            mid := m + (n - m) / 2\r\n            if sortArray1[i] <= 2 * sortArray2[mid] {\r\n                n = mid\r\n            } else {\r\n                m = mid + 1\r\n            }\r\n        }\r\n        if sortArray1[i] > 2 * sortArray2[m] {\r\n            m += 1\r\n        }\r\n        *res += m\r\n    }\r\n    for i, j := 0, 0; i < len(sortArray1) || j < len(sortArray2); {\r\n        if i >= len(sortArray1) {\r\n            mergedArray = append(mergedArray, sortArray2[j])\r\n            j++\r\n        } else if j >= len(sortArray2) {\r\n            mergedArray = append(mergedArray, sortArray1[i])\r\n            i++\r\n        } else if sortArray1[i] <= sortArray2[j] {\r\n            mergedArray = append(mergedArray, sortArray1[i])\r\n            i++\r\n        } else {\r\n            mergedArray = append(mergedArray, sortArray2[j])\r\n            j++\r\n        }\r\n    }\r\n    return mergedArray\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/48#issuecomment-1648985943","body":"```\r\nfunc minWindow(s string, t string) string {\r\n\tvar res string\r\n\tcnt := math.MaxInt32\r\n\thashMap := make(map[byte]int)\r\n\tl := 0\r\n\tr := 0\r\n\tfor i := 0; i < len(t); i++ {\r\n\t\thashMap[t[i]]++\r\n\t}\r\n\tfor r < len(s) {\r\n\t\thashMap[s[r]]--\r\n\t\tfor check(hashMap) {\r\n\t\t\tif r-l+1 < cnt {\r\n\t\t\t\tcnt = r - l + 1\r\n\t\t\t\tres = s[l : r+1]\r\n\t\t\t}\r\n\t\t\thashMap[s[l]]++\r\n\t\t\tl++\r\n\t\t}\r\n\t\tr++\r\n\t}\r\n\treturn res\r\n}\r\n\r\nfunc check(hashMap map[byte]int) bool {\r\n\tfor _, v := range hashMap {\r\n\t\tif v > 0 {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/55#issuecomment-1659508074","body":"```\r\n/**\r\n * Definition for a binary tree node.\r\n * type TreeNode struct {\r\n *     Val int\r\n *     Left *TreeNode\r\n *     Right *TreeNode\r\n * }\r\n */\r\ntype Node struct {\r\n\tRow   int\r\n\tValue int\r\n}\r\n\r\n// NodeMap: { [col]: [val1, val2] }\r\ntype NodeMap map[int][]Node\r\n\r\nfunc (nodeMap NodeMap) GetResult() [][]int {\r\n\tkeys := make([]int, 0, len(nodeMap))\r\n\tresult := make([][]int, 0, len(nodeMap))\r\n\r\n\tfor k := range nodeMap {\r\n\t\tkeys = append(keys, k)\r\n\t}\r\n\tsort.Ints(keys)\r\n\tfor _, k := range keys {\r\n\t\tvar list []int\r\n\t\tnodeList := nodeMap[k]\r\n\t\tsort.Slice(nodeList, func(i, j int) bool {\r\n\t\t\tif nodeList[i].Row < nodeList[j].Row {\r\n\t\t\t\treturn true\r\n\t\t\t} else if nodeList[i].Row > nodeList[j].Row {\r\n\t\t\t\treturn false\r\n\t\t\t} else if nodeList[i].Value < nodeList[j].Value {\r\n\t\t\t\treturn true\r\n\t\t\t} else {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t})\r\n\t\tfor _, n := range nodeList {\r\n\t\t\tlist = append(list, n.Value)\r\n\t\t}\r\n\t\tresult = append(result, list)\r\n\t}\r\n\treturn result\r\n}\r\n\r\nfunc traverTree(node *TreeNode, row, col int, nodeMap NodeMap) {\r\n\t// 递归结束条件，如果节点不存在则返回\r\n\tif node == nil {\r\n\t\treturn\r\n\t}\r\n\t// 将当前 node 信息添加进 nodeMap 中\r\n\tif v, ok := nodeMap[col]; !ok {\r\n\t\tnodeMap[col] = []Node{Node{Row: row, Value: node.Val}}\r\n\t} else {\r\n\t\tnodeMap[col] = append(v, Node{Row: row, Value: node.Val})\r\n\t}\r\n\ttraverTree(node.Left, row+1, col-1, nodeMap)\r\n\ttraverTree(node.Right, row+1, col+1, nodeMap)\r\n}\r\n\r\nfunc verticalTraversal(root *TreeNode) [][]int {\r\n\tnodeMap := NodeMap{}\r\n\ttraverTree(root, 0, 0, nodeMap)\r\n\treturn nodeMap.GetResult()\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/59#issuecomment-1666505794","body":"```\r\nfunc longestCommonSubsequence(text1 string, text2 string) int {\r\n\tdp := make([][]int, len(text1)+1)\r\n\tfor i := 0; i < len(text1)+1; i++ {\r\n\t\tdp[i] = make([]int, len(text2)+1)\r\n\t}\r\n\r\n\tfor i := 1; i < len(text1)+1; i++ {\r\n\t\tfor j := 1; j < len(text2)+1; j++ {\r\n\t\t\tif text1[i-1] == text2[j-1] {\r\n\t\t\t\tdp[i][j] = dp[i-1][j-1] + 1\r\n\t\t\t} else {\r\n\t\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1])\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn dp[len(text1)][len(text2)]\r\n}\r\n\r\nfunc max(a int, b int) int {\r\n\tif a < b {\r\n\t\treturn b\r\n\t}\r\n\treturn a\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnvsd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yueza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cusanity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay-xzj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyue-ma":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589546181","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598638576","body":"```\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"steven72574":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowangcoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james0608":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaneyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"azl397985856":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengfengfengwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bulingbulingbuling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585709907","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        int carry = 0;\n        for (int i = n - 1; i >= 0 || k > 0 || carry > 0; i--) {\n            int sum = carry;\n            if (i >= 0) {\n                sum += num[i];\n            }\n            if (k > 0) {\n                sum += k % 10;\n                k /= 10;\n            }\n            res.add(sum % 10);\n            carry = sum / 10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586174187","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [float('inf')] * len(s)\n        prev = float('-inf')\n\n        # Forward pass\n        for i in range(len(s)):\n            if s[i] == c:\n                prev = i\n            res[i] = i - prev\n\n        prev = float('inf')\n \n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                prev = i\n            res[i] = min(res[i], prev - i)\n\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587533002","body":"class CustomStack {\n\n    int[] stack;\n    int maxSize;\n    int top;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.stack = new int[maxSize];\n        this.top = 0;\n    }\n\n    public void push(int x) {\n        if (top < maxSize) {\n            stack[top++] = x;\n        }\n    }\n\n    public int pop() {\n        if (top > 0) {\n            return stack[--top];\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < stack.length; i++) {\n            stack[i] += val;\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589333282","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        def dfs(start):\n            rstr=rcnt=[]\n            while start<len(s):\n                if s[start].isnumeric():\n                    rcnt+=s[start]\n                elif s[start]=='[':\n                    start,tstr=dfs(start+1)\n                    rstr=rstr+tstr*int(rcnt)\n                    rcnt=''#清空重复的数字\n                elif s[start]==']':\n                    return start,rstr\n                else:\n                    rstr+=s[start]\n                start+=1\n            return rstr\n        return dfs(0)#递归的入口","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591488338","body":"class MyQueue:\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n        self.front = None\n\n    def push(self, x: int) -> None:\n        if not self.s1: self.front = x\n        self.s1.append(x)\n\n    def pop(self) -> int:\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            self.front = None\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        if self.s2: \n            return self.s2[-1]\n        return self.front\n\n    def empty(self) -> bool:\n        if not self.s1 and not self.s2:\n            return True\n        return False","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593131130","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        cnt = Counter()\n        res = 0\n\n        for x, y in zip(arr, sorted):\n            cnt[x] += 1\n            if cnt[x] == 0:\n                del cnt[x]\n            cnt[y] -= 1\n            if cnt[y] == 0:\n                del cnt[y]\n            if len(cnt) == 0:\n                res += 1\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594811055","body":"function rotateRight(head: ListNode | null, k: number): ListNode | null {\n  if (head === null) {\n    return null;\n  }\n  let count = 1,\n    tail = head;\n  while (tail.next !== null) {\n    count++;\n    tail = tail.next;\n  }\n  k = k % count;\n  if (k === 0) {\n    return head;\n  }\n  let newTail = head;\n  for (let i = 0; i < count - k - 1; i++) {\n    newTail = newTail.next!;\n  }\n  const newHead = newTail.next!;\n  tail.next = head;\n  newTail.next = null;\n  return newHead;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595722184","body":"class Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode pre = new ListNode(0);\n        pre.next = head;\n        ListNode temp = pre;\n        while(temp.next != null && temp.next.next != null) {\n            ListNode start = temp.next;\n            ListNode end = temp.next.next;\n            temp.next = end;\n            start.next = end.next;\n            end.next = start;\n            temp = start;\n        }\n        return pre.next;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596177298","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n\n        // 找到链表的中间节点\n        ListNode slow = head, fast = head.next.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        TreeNode root = new TreeNode(slow.next.val);\n\n        ListNode rightHead = slow.next.next;\n        slow.next = null;\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(rightHead);\n\n        return root;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1597380067","body":"public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<>();\n        ListNode temp = headA;\n        while(temp != null){\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while(temp != null){\n            if(visited.contains(temp)){\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598773931","body":"class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        while(head) {\n            if(!less<ListNode *>()(head, head->next)) {\n                return head->next;\n            }\n            head = head->next;\n        }\n        return nullptr;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600765397","body":"from collections import OrderedDict\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.maxsize=capacity\n        self.LRUCache=OrderedDict()\n\n\n    def get(self, key: int) -> int:\n        if key in self.LRUCache:\n            self.LRUCache.move_to_end(key)\n        return self.LRUCache.get(key,-1)\n\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.LRUCache:\n            del self.LRUCache[key]\n        self.LRUCache[key]=value\n        if len(self.LRUCache)>self.maxsize:\n            self.LRUCache.popitem(last=False)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602828064","body":"function maxDepth(root: TreeNode | null): number {\n  if(!root) return 0;\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604319741","body":"class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n       if(p==nullptr&&q==nullptr) return true;\n       if(p==nullptr||q==nullptr) return false;\n       \n       return (p->val==q->val)&&isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605577195","body":"class Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(node: TreeNode, current_sum: int) -> int:\n            if not node:\n                return 0\n\n            current_sum = current_sum * 10 + node.val\n\n            if not node.left and not node.right:\n                return current_sum\n\n            left_sum = dfs(node.left, current_sum)\n            right_sum = dfs(node.right, current_sum)\n\n            return left_sum + right_sum\n\n        return dfs(root, 0)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eden-ye":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingtrains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"starorbiting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo-xiaoxiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"passengersa":[null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598724504","body":"\n思路：\n定义快指针 fast 和慢指针 slow，初始时都指向链表头节点。\n快指针每次向后移动2个节点，慢指针每次向后移动1个节点，直到快指针或者慢指针到达链表尾部。\n如果链表无环，则返回null。\n如果链表有环，则快指针和慢指针必定会在环内相遇。\n当快指针和慢指针相遇时，将快指针重新指向链表头节点，然后快指针和慢指针都每次向后移动1个节点，直到它们再次相遇，相遇的节点即为环的入口节点。\n代码：\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n\nvar detectCycle = function(head) {\n    let slow = head, fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            fast = head;\n            while (fast !== slow) {\n                fast = fast.next;\n                slow = slow.next;\n            }\n            return fast;\n        }\n    }\n    return null;\n};\n复杂度分析\n时间复杂度：O(N)，其中 N 为链表的长度。\n空间复杂度：O(1)，使用快慢指针，未占用其它空间\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1606050878","body":"let queue = [root];\n  let leftmostVal = root.val; // 记录第一层的值\n  while (queue.length) {\n    let size = queue.length;\n    for (let i = 0; i < size; i++) {\n      let node = queue.shift();\n      if (i === 0) {           // 第一个节点\n        leftmostVal = node.val;\n      }\n      if (node.left) {\n        queue.push(node.left);\n      }\n      if (node.right) {\n        queue.push(node.right);\n      }\n    }\n  }\n  return leftmostVal;","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614527232","body":"代码：\n\nvar numberOfBoomerangs = function(points) {\n  let result = 0;\t\n  for (let i = 0; i < points.length - 2; i++) {\t\n    for (let j = i + 1; j < points.length - 1; j++) {\t\n      for (let k = j + 1; k < points.length; k++) {\t\n        result += judge(points[i], points[j], points[k]);\t\n      }\t\n    }\t\n  }\t\n  return result;\n};\n\nconst dist = (i, j) => {\t\n  return (i[0] - j[0]) * (i[0] - j[0]) + (i[1] - j[1]) * (i[1] - j[1]);\t\n};\t\nconst judge = (i, j, k) => {\t\n  let count = 0;\t\n  if (dist(i, j) == dist(i, k)) {\t\n    count += 2;\t\n  }\t\n  if (dist(j, i) == dist(j, k)) {\t\n    count += 2;\t\n  }\t\n  if (dist(k, i) == dist(k, j)) {\t\n    count += 2;\t\n  }\t\n  return count;\t\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1620350865","body":"代码：\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n let fast = head;\n  let slow = head;\n\n  while (fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n\n  return slow;\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1629213877","body":"function sortItems(\r\nn: number,\r\nm: number,\r\ngroup: number[],\r\nbeforeItems: number[][]\r\n): number[] {\r\n\r\nfor (let i = 0; i < group.length; i++) {\r\nif (group[i] == -1) {\r\ngroup[i] = m;\r\nm++;\r\n}\r\n}\r\n\r\nconst groupAdj: number[][] = Array(m)\r\n.fill(undefined)\r\n.map(() => Array());\r\nconst itemAdj: number[][] = Array(n)\r\n.fill(undefined)\r\n.map(() => Array());\r\n\r\nlet groupInDegree: number[] = Array(m).fill(0);\r\nlet itemInDegree: number[] = Array(n).fill(0);\r\n\r\nfor (let i = 0; i < group.length; i++) {\r\nlet curGroup = group[i];\r\nfor (let beforeItem of beforeItems[i]) {\r\nlet beforeGroup = group[beforeItem];\r\nif (beforeGroup != curGroup) {\r\ngroupAdj[beforeGroup].push(curGroup);\r\ngroupInDegree[curGroup]++;\r\n}\r\n}\r\n}\r\nfor (let i = 0; i < n; i++) {\r\nfor (let item of beforeItems[i]) {\r\nitemAdj[item].push(i);\r\nitemInDegree[i]++;\r\n}\r\n}\r\n\r\nlet groupResult: number[] = topoLogicalSort(groupAdj, groupInDegree, m);\r\nif (groupResult.length == 0) {\r\nreturn [];\r\n}\r\nlet itemResult = topoLogicalSort(itemAdj, itemInDegree, n);\r\nif (itemResult.length == 0) {\r\nreturn [];\r\n}\r\nlet group2Items: Map<number, number[]> = new Map();\r\nfor (let item of itemResult) {\r\nlet key = group[item];\r\nif (group2Items.has(key)) {\r\ngroup2Items.get(group[item]).push(item);\r\n} else {\r\ngroup2Items.set(key, [item]);\r\n}\r\n}\r\n\r\nlet result: number[] = Array();\r\nfor (let group of groupResult) {\r\nlet items = group2Items.get(group) ?? [];\r\nresult = result.concat(items);\r\n}\r\nreturn result;\r\n}\r\n\r\nfunction topoLogicalSort(\r\nadj: number[][],\r\ninDegree: number[],\r\nn: number\r\n): number[] {\r\nlet result: number[] = [];\r\nlet queue: number[] = [];\r\nfor (let i = 0; i < n; i++) {\r\nif (inDegree[i] == 0) {\r\nqueue.push(i);\r\n}\r\n}\r\nwhile (queue.length != 0) {\r\nlet front = queue.shift();\r\nresult.push(front);\r\nfor (let successor of adj[front]) {\r\ninDegree[successor]--;\r\nif (inDegree[successor] == 0) {\r\nqueue.push(successor);\r\n}\r\n}\r\n}\r\nif (result.length == n) {\r\nreturn result;\r\n}\r\nreturn [];","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637112738","body":"js 代码\n\nvar mySqrt = function(x) {\n let left = 0;\n  let right = x;\n  let result = -1;\n\n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n    if (mid * mid === x) {\n      return mid;\n    } else if (mid * mid < x) {\n      result = mid;\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  return result;\n};\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/45#issuecomment-1646472342","body":"代码\nvar maxVowels = function(s, k) {\n  const vowels = new Set(['a', 'e', 'i', 'o', 'u']);\n  let maxCount = 0;\n  let currentCount = 0;\n\n  // 初始化长度为k的第一个子字符串中的元音字母数\n  for (let i = 0; i < k; i++) {\n    if (vowels.has(s[i])) {\n      currentCount++;\n    }\n  }\n  maxCount = currentCount;\n\n  // 滑动窗口，依次计算每个长度为k的子字符串中的元音字母数\n  for (let i = k; i < s.length; i++) {\n    if (vowels.has(s[i - k])) {\n      currentCount--;\n    }\n    if (vowels.has(s[i])) {\n      currentCount++;\n    }\n    maxCount = Math.max(maxCount, currentCount);\n  }\n\n  return maxCount;\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/50#issuecomment-1653472136","body":"代码：\nvar readBinaryWatch = function(turnedOn) {\n var result = [];\n    for (var hour = 0; hour < 12; hour++) {\n        for (var minute = 0; minute < 60; minute++) {\n            if (countBits(hour) + countBits(minute) === turnedOn) {\n                result.push(hour + \":\" + (minute < 10 ? \"0\" + minute : minute));\n            }\n        }\n    }\n    return result;\n};\n\n\nfunction countBits(num) {\n    var count = 0;\n    while (num > 0) {\n        count += num & 1;\n        num >>= 1;\n    }\n    return count;\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/56#issuecomment-1662250264","body":"ar minCostClimbingStairs = function(cost) {\nconst n = cost.length;\n  const dp = new Array(n);\n\n  dp[0] = cost[0];\n  dp[1] = cost[1];\n\n  for (let i = 2; i < n; i++) {\n    dp[i] = Math.min(dp[i-1] + cost[i], dp[i-2] + cost[i]);\n  }\n\n  return Math.min(dp[n-1], dp[n-2]);\n};\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/61#issuecomment-1667983228","body":"class Solution {\n    int[][] dirs = new int[][]{{-1,-2},{-1,2},{1,-2},{1,2},{-2,1},{-2,-1},{2,1},{2,-1}};\n    public double knightProbability(int n, int k, int row, int column) {\n        double[][][] f = new double[n][n][k + 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                f[i][j][0] = 1;\n            }\n        }\n        for (int p = 1; p <= k; p++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int[] d : dirs) {\n                        int nx = i + d[0], ny = j + d[1];\n                        if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\n                        f[i][j][p] += f[nx][ny][p - 1] / 8;\n                    }\n                }\n            }\n        }\n        return f[row][column][k];\n    }\n}\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/65#issuecomment-1674796079","body":"代码：\nvar coinChange = function(coins, amount) {\ncoins.sort((a,b) => a-b);\n  if (amount === 0) return 0;\n  if (amount < coins[0]) return -1;\n  let ans = 999999;\n  d(amount, coins.length - 1, 0, coins);\n  function d(num, index, len, coins) { \n    if (num === 0) { \n      ans = Math.min(ans, len);\n      return;\n    };\n    if (index < 0) return;\n    for (let k=Math.floor(num / coins[index]); k >=0 && k + len < ans; k--) { \n        d(num - coins[index] * k, index - 1, len + k, coins);\n    }\n  }\n  return ans === 999999 ? -1 : ans;\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/70#issuecomment-1680734062","body":"代码：\nvar numTrees = function(n) {\n    const d = [1,1];\n\n    for (let i=2; i<=n; i++) {\n        d[i] = 0;\n        for (let j=0; j<=i-1; j++) {\n            d[i] += d[j] * d[i-1-j];\n        }\n    }\n\n    return d[n];\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/75#issuecomment-1686498653","body":"代码：\nvar Trie = function() {\nthis.startIndex = 'a'.charCodeAt();\n    this.root = new TreeNode();\n};\n\n/** \n * @param {string} word\n * @return {void}\n */\nTrie.prototype.insert = function(word) {\nlet p = this.root;\n    for (let i=0; i<word.length; i++) {\n        let index = word[i].charCodeAt() - this.startIndex;\n        if (!p.list[index]) {\n            let newNode = new TreeNode();\n            p.list[index] = newNode;\n        }\n        p = p.list[index];\n    }\n    p.type = 'leaf';\n    p.word = word;\n};\n\n/** \n * @param {string} word\n * @return {boolean}\n */\nTrie.prototype.search = function(word) {\nlet p = this.root;\n    for (let i=0; i<word.length; i++) {\n        p = p.list[word[i].charCodeAt() - this.startIndex];\n        if (!p && i<word.length-1) return false;\n    }\n\n    if (p && p.type === 'leaf' && p.word === word) return true;\n    return false;\n};\n\n/** \n * @param {string} prefix\n * @return {boolean}\n */\nTrie.prototype.startsWith = function(prefix) {\n let p = this.root;\n    for (let i=0; i<prefix.length; i++) {\n        p = p.list[prefix[i].charCodeAt() - this.startIndex];\n        if (!p) return false;\n    }\n    return true;\n};\n\nfunction TreeNode() {\n    this.type = 'branch';\n    this.list = [];\n    this.word = '';\n}\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/82#issuecomment-1695784169","body":"代码：\n/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function(candidates, target) {\n   candidates.sort((a,b) => a-b); // 先对数组进行排序，方便剪枝\n    let combination = [];\n    let path = [];\n    const len = candidates.length, minNum = candidates[0];\n    getCombination(candidates, target, 0, path); // 递归函数\n    \n    function getCombination(candidates, target, start, path){\n        if(target == 0) return combination.push(path.slice()); // 找到组合，返回到解集之中\n        if(target < minNum) return;\n        for(let i = start; i < len; i++){ \n            path.push(candidates[i]);\n            // 对 i节点进行递归，注意 target要减少噢\n            getCombination(candidates, target-candidates[i], i, path); \n            path.pop(); \n        }\n    }\n    return combination;\n\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/87#issuecomment-1703837208","body":"代码：\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nfunction findKthLargest(list, k) {\n    // 整个流程就是上浮 下沉\n    let heapSize = list.length;\n \n    function buildMaxHeap() {\n        for (let i = Math.floor(heapSize / 2) - 1; i >= 0; i--) {\n            console.log(i)\n            maxHeapify(i, heapSize)\n        }\n    }\n    // 自左向右 自上而下 \n    function maxHeapify(i, heapSize) {\n        let l = i*2+1;\n        let r = i*2+2\n        let largest = i;\n        if (l < heapSize && list[l] > list[largest]) {\n            largest = l\n        }\n        if (r < heapSize && list[r] > list[largest]) {\n            largest = r\n        }\n        if (largest!==i) {\n            [list[i], list[largest]] = [list[largest], list[i]];\n           maxHeapify(largest,heapSize)\n        }\n    }\n    buildMaxHeap();\n    // 进行下沉 大顶堆是最大元素下沉到末尾\n    for (let i = list.length - 1; i >= list.length - k + 1; i--) {\n        [list[i], list[0]] = [list[0], list[i]];\n        heapSize-- // 下沉后的元素不参与到大顶堆的调整\n        // 重新调整大顶堆\n        maxHeapify(0, heapSize);\n    }\n    return list[0]\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/91#issuecomment-1708237218","body":"代码：\n/**\n * @param {number[][]} matrix\n * @param {number} k\n * @return {number}\n */\nvar kthSmallest = function(matrix, k) {\nvar nums = [];\n     var temp = 0;\n     for (var i = 0; i < matrix.length; i++) {\n         for (var j = 0; j < matrix[i].length; j++) {\n             nums.push(matrix[i][j])\n         }\n     }\n \n     for (var i = 0; i < nums.length; i++) {\n         for (var j = i + 1; j < nums.length; j++) {\n             if (nums[i] > nums[j]) {\n                 temp = nums[i];\n                 nums[i] = nums[j];\n                 nums[j] = temp\n             }\n         }\n     }\n     console.log(nums)\n     return (nums[k - 1])\n};","onTime":true},null,null],"shellylcooper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testplm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tom-zhouch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skylarxu214":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taihui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huaxueguakele":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yang-chenyu104":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mlking15":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"-3":[],"cyonline":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jetery":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"klspta":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bookyue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jancerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"buer1121":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ceramickitten":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gg925407590":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alyenor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggohem":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dark-volute":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ronething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmastella":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dd2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayloveless":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuexi001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abby-xu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsw9818":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaomingshixiaotang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snmyj":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585453770","body":"```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> b,ans;\n          while(k>0){\n               b.push_back(k%10);\n               k/=10;\n          }\n        reverse(b.begin(),b.end());\n        int d=0;\n        for(int i=num.size()-1,j=b.size()-1;i>=0&&j>=0;i--,j--){\n               int add=num[i]+b[j]+d;\n               ans.push_back(add%10);\n                d=add/10;\n               if(i==0) {\n                   j--;\n                   while(j>=0){\n                       int add1=b[j]+d;  \n                       ans.push_back((b[j]+d)%10);\n                       d=add1/10;\n                       j--;\n                    }\n                     if(d!=0) ans.push_back(d);\n               }\n                if(j==0) {\n                   i--;\n                   while(i>=0){\n                       int add1=num[i]+d;  \n                       ans.push_back((num[i]+d)%10);\n                       d=add1/10;\n                       i--;\n                    }\n                     if(d!=0) ans.push_back(d);\n               }\n             \n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n```\nt：o(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586058751","body":"```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> pos,ans;\n       for(int i=0;i<s.length();i++){\n           if(s[i]==c) pos.push_back(i);\n       }\n       for(int i=0;i<s.length();i++){\n           if(s[i]==c) ans.push_back(0);\n           else{\n               int min=INT_MAX;\n               for(int j=0;j<pos.size();j++){\n                  if(abs(pos[j]-i)<min) min=abs(pos[j]-i);\n               }\n               ans.push_back(min);\n           }\n       }\n       return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586534532","body":"````\nclass CustomStack {\npublic:\n    int maxs=0;\n    vector<int> ss;\n    CustomStack(int maxSize) {\n       maxs=maxSize;\n    }\n    \n    void push(int x) {\n      if(ss.size()<maxs) ss.push_back(x);\n    }\n    \n    int pop() {\n       if(ss.size()==0) return -1;\n       int res=ss.back();\n         ss.pop_back();\n       return res;\n       \n    }\n    \n    void increment(int k, int val) {\n       if(ss.size()==0) return;\n        for(int i=0;i<k;i++){\n            if(i==ss.size()-1){\n                ss[i]+=val;\n                break;\n            }\n            ss[i]+=val;\n        }\n    }\n};\n````\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1588540916","body":"```\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<char> ss;\n        string obj,ans=\"\";\n        int cnt,bit;\n        for(int i=0;i<s.size();i++){\n            if(s[i]==']'){\n               obj=\"\";\n               cnt=0;\n               bit=1;\n               while(ss.top()!='['){\n                    obj+=ss.top();\n                    ss.pop();\n               }\n               reverse(obj.begin(),obj.end());\n            \n               ss.pop();\n              \n               while(!ss.empty()&&ss.top()>='0'&&ss.top()<='9'){\n                   cnt+=(ss.top()-'0')*bit;\n                   bit*=10;\n                   ss.pop();\n\n               }\n\n             \n               for(int i=0;i<cnt;i++){\n                   for(auto &x:obj) ss.push(x);\n               }\n\n            \n               \n            }\n            else ss.push(s[i]);\n        }\n\n        while(!ss.empty()) {\n            ans+=ss.top();\n            ss.pop();\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n```\nT(o(k*n)) k是括号中字符数的平均个数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590828947","body":"```\nclass MyQueue {\npublic:\n   stack<int> s1,s2;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n      if(!s1.empty()) s1.push(x);\n      else s2.push(x);\n    }\n    \n    int pop() {\n       if(s1.empty()) {\n           while(!s2.empty()){\n               s1.push(s2.top());\n               s2.pop();\n           }\n       \n       int ans=s1.top();\n       s1.pop();\n       return ans;}\n       else{\n           while(!s1.empty()){\n               s2.push(s1.top());\n               s1.pop();\n           }\n       \n       int ans=s2.top();\n       s2.pop();\n       return ans;\n\n       }\n    }\n    \n    int peek() {\n        if(s1.empty()) {\n           while(!s2.empty()){\n               s1.push(s2.top());\n               s2.pop();\n           }\n    \n       return s1.top();\n       }\n       else{\n           while(!s1.empty()){\n               s2.push(s1.top());\n               s1.pop();\n           }\n       \n     \n       return s2.top();\n\n       }\n    }\n\n    \n    \n    bool empty() {\n           if(s1.empty()&&s2.empty()) return true;\n           else return false;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592687712","body":"```\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n       vector<int> brr(arr);\n       int cnt=0;\n       sort(brr.begin(),brr.end());\n       for(int i=0;i<arr.size();i++){\n           if(arr[i]!=brr[i]) {\n               for(int j=arr.size()-1;;j--){\n                   if(brr[i]==arr[j]){\n                           cnt++;\n                           i=j;\n                           break;\n                   }\n               }\n           }\n           else cnt++;\n       }\n        return cnt;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1593814530","body":"```\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n         ListNode *cur=head,*rear,*newh;\n         if(head==nullptr||k==0||head->next==nullptr) return head;\n\n         int cnt=0;\n         while(cur!=nullptr){\n             cnt++;\n            \n             cur=cur->next;\n         }\n         cur=head;\n         k=k%cnt;\n         if(k==0) return head;\n         int t=0;\n         while(1){\n             t++;\n             if(t==cnt-k){\n                 newh=cur->next;\n                 rear=cur;\n                 cur=cur->next;\n                 rear->next=nullptr;\n                 continue;\n            }\n             if(t==cnt){\n                 cur->next=head;\n                 break;\n             }\n             cur=cur->next;\n         }\n         \n\n         return newh;\n    }\n};\n\nt：o(n);\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595585258","body":"```\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n         if(head==nullptr||head->next==nullptr) return head;\n         int cnt;\n         ListNode *pre=new ListNode(-1),*cur=pre,*ptr1,*ptr2,*ptrnext;\n         pre->next=head;\n         while(cur->next!=nullptr&&cur->next->next!=nullptr){\n           ptr1=cur->next;\n           ptr2=cur->next->next;\n           if(ptr2->next!=nullptr) {ptrnext=ptr2->next;\n           cur->next=ptr2;\n            ptr1->next=ptrnext;\n           ptr2->next=ptr1;\n          \n           cur=ptr1;  }\n           else{\n             cur->next=ptr2;\n             ptr2->next=ptr1;\n             ptr1->next=nullptr;\n             break;\n           }\n           \n         }\n        return pre->next;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596102438","body":"```\nclass Solution {\n\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head,null);\n    }\n\n    public TreeNode buildTree(ListNode left,ListNode right){\n        if(left == right){\n            return null;\n        }\n        ListNode mid = getMid(left,right);\n        TreeNode root = new TreeNode();\n        root.val = mid.val;\n        root.left = buildTree(left,mid);\n        root.right = buildTree(mid.next,right);\n        return root;\n    }\n\n    public ListNode getMid(ListNode left,ListNode right){\n        ListNode slow = left;\n        ListNode fast = left;\n        while(fast != right && fast.next != right){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596718205","body":"```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<>();\n        ListNode temp = headA;\n        while(temp != null){\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while(temp != null){\n            if(visited.contains(temp)){\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1599016650","body":"```\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        \n        ListNode *f,*s,*prev;\n        prev=new ListNode(-1);\n        prev->next=head;\n        f=prev,s=prev;\n        while(1){\n               if(f->next==nullptr||f->next->next==nullptr) return nullptr;\n               else {\n                   f=f->next->next;\n                   s=s->next;\n               }\n               if(f==s){\n                   f==prev;\n                   break;\n               }\n        }\n        while(s!=f){\n            f=f->next;\n            s=s->next;\n           \n        }\n         return f;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600553324","body":"```\nclass LRUCache {\npublic:\n    int maxsize;\n    vector<int> vec;\n    unordered_map<int,int> qmap;\n    LRUCache(int capacity) {\n             maxsize=capacity;\n    }\n    \n    int get(int key) {\n           if(qmap.count(key)&&qmap[key]!=-1) {\n               vector<int>::iterator it=std::find(vec.begin(),vec.end(),key);\n               int pos=distance(vec.begin(),it);\n               vec.erase(vec.begin()+pos);\n               vec.push_back(key);\n               return qmap[key];\n            }\n           else return -1;\n    }\n    \n    void put(int key, int value) {\n           if(qmap.count(key)&&qmap[key]!=-1) {\n               qmap[key]=value;\n                vector<int>::iterator it=std::find(vec.begin(),vec.end(),key);\n               int pos=distance(vec.begin(),it);\n               vec.erase(vec.begin()+pos);\n               vec.push_back(key);\n           \n           }\n           else{\n               if(vec.size()<maxsize){\n                   qmap[key]=value;\n                   vec.push_back(key);\n               }\n               else{\n                   int front=vec[0];\n                   vec.erase(vec.begin());\n                   vec.push_back(key);\n                   qmap[front]=-1;\n                   qmap[key]=value;\n               }\n           }\n    }\n};\n \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602570893","body":"```\nint maxDepth(struct TreeNode* root){\n   if(root==NULL)\n   return 0;\n   else{\n       int m=maxDepth(root->left);\n       int n=maxDepth(root->right);\n       if(m>n)\n       return m+1;\n       else\n       return n+1;\n   }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604025176","body":"```\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n       if(p==nullptr&&q==nullptr) return true;\n       if(p==nullptr||q==nullptr) return false;\n       \n       return (p->val==q->val)&&isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605294227","body":"```\nclass Solution {\npublic:\n    \n    int dfs(TreeNode* root,int num){\n        if(root==nullptr) return 0;\n        int sum=10*num+root->val;\n        if(root->right==nullptr&&root->left==nullptr) return sum;\n    \n       \n        else return dfs(root->left,sum)+dfs(root->right,sum);\n        \n    }\n    int sumNumbers(TreeNode* root) {\n        return dfs(root,0);\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605919953","body":"```\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n            queue<TreeNode*> que;\n            que.push(root);\n            int obj;\n            while(!que.empty()){\n                int lenth=que.size();\n                int s=lenth;\n                \n                \n                while(lenth!=0){\n                   \n                    TreeNode *curnode=que.front();\n                    if(lenth==s)  obj=que.front()->val;\n                    que.pop();\n                    if(curnode->left)que.push(curnode->left);\n                    if(curnode->right)que.push(curnode->right);\n                    lenth--;\n\n                }\n\n            }\n\n        return obj;\n    }\n};\n```\nO(n),n为树节点个数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607020694","body":"```\nclass Codec {\npublic:\n \n    \n    string serialize(TreeNode* root) {\n        string str=\"\";\n        if(!root)return str;\n        search_pre(root,str);\n        return str;\n    }\n \n   \n    TreeNode* deserialize(string data) {\n        if(data.compare(\"\")==0)return nullptr;\n        TreeNode* head;\n        create_tree(head,data);\n        return head;\n    }\nprivate:\n   \n    void search_pre(TreeNode* root,string& str)\n    {\n        str+=to_string((long long)root->val);\n        str+=\",\";\n        if(root->left)search_pre(root->left,str);\n        else str+=\"null,\";\n        if(root->right)search_pre(root->right,str);\n        else str+=\"null,\";\n    }\n    \n    void create_tree(TreeNode*& root,string& str)\n    {\n        \n        int num=find_next_num(str);\n        if(num==INT_MIN)return;\n        root=new TreeNode(num);\n        create_tree(root->left,str);\n        create_tree(root->right,str);\n    }\n \n    int find_next_num(string& str)\n    {\n        int num=str.find(\",\");\n        string temp=str.substr(0,num);\n        str.erase(0,num+1);\n        if(temp.compare(\"null\")==0)return INT_MIN;//null return INT_MIN\n        else return stoi(temp);\n    }\n \n    \n    int stoi(string str)\n    {\n        bool negative=false;\n        if(str[0]=='-')\n        {\n            negative=true;\n            str.erase(0,1);\n        }\n        int n=str.length(),ans=0;\n        for(int i=0;i<n;++i)\n        {\n            ans+=(str[i]-'0')*(int)pow(10.0,n-i-1);\n        }\n        return negative?-ans:ans;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1609140594","body":"```\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes=new ArrayList<int[]>();\n        dfs(root,0,0,nodes);\n        Collections.sort(nodes,new Comparator<int[]>(){\n            public int compare(int[] a,int[] b){\n                if(a[0]!=b[0])\n                {return a[0]-b[0];}\n                else if(a[1]!=b[1]){\n                    return a[1]-b[1];\n                }\n                else {\n                    return a[2]-b[2];\n                }\n        }\n        });\n        List<List<Integer>> traversal=new ArrayList<List<Integer>>();\n        int col=Integer.MIN_VALUE;\n        int index=-1;\n        for(int[] node:nodes){\n            int curCol=node[0];\n            if(col!=curCol){\n                col=curCol;\n                traversal.add(new ArrayList<Integer>());\n                index++;\n            }\n            traversal.get(index).add(node[2]);\n        }\n        return traversal;\n\n    }\n    public void dfs(TreeNode node,int row,int col, List<int[]> nodes){\n        if(node==null)\n        return;\n        nodes.add(new int[]{col,row,node.val});\n        dfs(node.left,row+1,col-1,nodes);\n        dfs(node.right,row+1,col+1,nodes);\n    }\n}\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1610938076","body":"```\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> hashs;\n        vector<int> ret;\n        for(int i=0;i<nums.size();i++) {\n            \n            if(hashs.count(target-nums[i])) {\n                ret.push_back(i);\n                int j=hashs[target-nums[i]];\n                \n                ret.push_back(j);\n                \n            }\n            hashs[nums[i]]=i;\n         }\n        return ret;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1613146540","body":"```\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int,int> hash;\n        vector<vector<int>> res;\n        vector<int>ans;\n        for(auto &x:nums) hash[x]++;\n        for(auto &x:hash) res.push_back({x.first,x.second});\n        sort(res.begin(),res.end(),[](vector<int> &a,vector<int> &b){return a[1]>b[1];});\n        for(int i=0;i<=k-1;i++) ans.push_back(res[i][0]);\n        return ans;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614230335","body":"```\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int res=0;\n        for(int i=0;i<points.size();i++) {\n            unordered_map<int,int> m;\n            for(int j=0;j<points.size();j++) {\n                int dx=points[i][0]-points[j][0];\n                int dy=points[i][1]-points[j][1];\n                m[dx*dx+dy*dy]++;\n            }\n            for(auto i:m) {\n                res+=i.second*(i.second-1);\n            }\n        }\n        return res;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615873295","body":"```\nclass Solution {\npublic:\n    int maxAns=0;\n    int lengthOfLongestSubstring(string s) {\n        unordered_set<char>hash;\n        int left=0;\n        for(char i:s){\n            while(hash.find(i)!=hash.end()){\n                hash.erase(s[left]);\n                left++;\n            }\n            hash.insert(i);\n          \n            if(hash.size()>maxAns)maxAns=hash.size();\n        }\n        return maxAns;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616434730","body":"```\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        int l=words.size()*words[0].size();\n        unordered_map<string,int> hashs,hashscur;\n        for(string x:words) hashs[x]++;\n        for(int i=0;i<s.length()-l+1;i++){\n            string curtarget=s.substr(i,l);\n            hashscur.clear();\n            for(int j=0;j<words.size();j++){\n                string subcurtarget=curtarget.substr(j*words[0].size(),words[0].size());\n                if(hashs.count(subcurtarget)){\n                    hashscur[subcurtarget]++;\n                    if(hashscur[subcurtarget]>hashs[subcurtarget]) break;\n                }\n                else break;\n               \n                if(j==words.size()-1) res.emplace_back(i);\n            }\n\n        }\n        return res;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1617415532","body":"```\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        x = sum(nums) % p\n        if x == 0: return 0 \n\n        ans = n = len(nums)\n        s = 0\n        last = {s: -1}  \n        for i, v in enumerate(nums):\n            s += v\n            last[s % p] = i\n            j = last.get((s - x) % p, -n) \n            ans = min(ans, i - j)  \n        return ans if ans < n else -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1619394404","body":"```\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* cur=head;\n        int cnt=0;\n        while(cur!=NULL){\n            cnt++;\n            cur=cur->next;\n        }\n        cur=head;\n        cnt=ceil(cnt/2);\n        while(cnt!=0){\n            cnt--;\n            cur=cur->next;\n\n        }\n        return cur;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1621014941","body":"```\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n         int cnt=1;\n         for(int i=0;i<nums.size()-1;i++){\n             if(nums[i+1]!=nums[i]) cnt++;\n\n         }\n         int s=1;\n         for(int i=1;i<nums.size();i++){\n             if(nums[i]!=nums[i-1]) {\n                 nums[s]=nums[i];\n                 s++;\n             }\n         }\n         return cnt;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1623246006","body":"```\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n         int l=0,r=nums.size()-1;\n         int mid;\n         while(l<=r){\n             mid=(l+r)/2;\n             if(target>nums[mid]) l=mid+1;\n             else  r=mid-1;\n         }\n         return l;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1625374575","body":"```\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> ans;\n        priority_queue<pair<int,int>,vector<pair<int,int>>,less<>> pq;\n        for(int i=0;i<k;i++){\n            pq.push({nums[i],i});\n        }\n        ans.push_back(pq.top().first);\n        int r;\n        for(r=k;r<nums.size();r++){\n             pq.push({nums[r],r});\n             while(pq.top().second<=r-k) pq.pop();\n             \n             ans.push_back(pq.top().first);\n            \n            \n        }\n        \n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1626874594","body":"```\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n            unordered_map<int,int> hashs,hashs_judge;\n            vector<int> res;\n            if(trust.size()==0){ \n                if(n==1){ \n                    return 1;\n                }\n                return -1;\n            }\n            for(int i=0;i<trust.size();i++){\n                hashs[trust[i][0]]++;\n                hashs_judge[trust[i][1]]++;\n            }\n            for(auto x:hashs){\n               \n                    res.push_back(x.first);\n                \n            }\n            sort(res.begin(),res.end());\n            for(int i=0;i<res.size();i++){\n                \n                if(res[i]!=i+1) {\n                    if(hashs_judge[i+1]==n-1)\n                    return i+1;\n                    else return -1;\n                }\n                if(i==res.size()-1&&!hashs.count(n)) {\n                      if(hashs_judge[n]==n-1) return n;\n                      else return -1;\n                    }\n            }\n            return -1;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627740017","body":"```\nclass Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        \"\"\"\n        :type N: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \"\"\"\n\n        g = {}\n        for x, y in dislikes:\n            x -= 1\n            y -= 1\n            if x not in g:\n                g[x] = set()\n            if y not in g:\n                g[y] = set()\n            g[x].add(y)\n            g[y].add(x)\n\n        color = [None] * N\n        for x in range(N):\n            if color[x] is None:\n                color[x] = 0\n                if not self.dfs(x, 0, g, color):\n                    return False\n\n        return True\n\n    def dfs(self, x, now, g, color):\n        for y in g.get(x, set()):\n            if color[y] is None:\n                color[y] = 1 - now\n                if not self.dfs(y, 1 - now, g, color):\n                    return False\n            elif color[y] == color[x]:\n                return False\n        \n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1628229871","body":"```\nclass Solution {\npublic:\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        for(int i = 0; i < n; i++)\n        {\n            if(group[i] == -1)\n                group[i] = m++;\n        }\n        vector<vector<int>> itemgraph(n);\n        vector<vector<int>> groupgraph(m);\n        vector<int> itemIndegree(n, 0);\n        vector<int> groupIndegree(m, 0);\n        for(int i = 0; i < n; i++)\n        {\n            for(auto j : beforeItems[i])\n            {\n                itemgraph[j].push_back(i);\n                itemIndegree[i]++;\n                if(group[i] != group[j]) \n                {\t\n                    groupgraph[group[j]].push_back(group[i]);\n                    groupIndegree[group[i]]++;\n                }\n            }\n        }\n        vector<vector<int>> g_items(m);\n        \n        queue<int> q;\n        for(int i = 0; i < n; i++)\n            if(itemIndegree[i] == 0)\n                q.push(i);\n        int countItem = 0;\n        while(!q.empty())\n        {\n            int i = q.front();\n            q.pop();\n            countItem++;\n            g_items[group[i]].push_back(i);\n             for(auto j : itemgraph[i])\n            {\n                if(--itemIndegree[j]==0)\n                    q.push(j);\n            }\n        }\n        if(countItem != n)\n            return {};\n        vector<int> g_order;\n        for(int i = 0; i < m; i++)\n            if(groupIndegree[i] == 0)\n                q.push(i);\n        int countgroup = 0;\n        while(!q.empty())\n        {\n            int g = q.front();\n            q.pop();\n            countgroup++;\n            g_order.push_back(g);\n            for(auto j : groupgraph[g])\n            {\n                if(--groupIndegree[j]==0)\n                    q.push(j);\n            }\n        }\n        if(countgroup != m)\n            return {};\n        vector<int> ans(n);\n        int idx = 0;\n        for(auto g : g_order)\n        {\n            for(auto i : g_items[g])\n                ans[idx++] = i;\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1631025331","body":"```\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        return count(moves.begin(),moves.end(),'L')==count(moves.begin(),moves.end(),'R')&&count(moves.begin(),moves.end(),'U')==count(moves.begin(),moves.end(),'D');\n\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1632794982","body":"```\npublic:\n       \n    vector<int> getOrder(vector<vector<int>>& tasks) {\n         \n        vector<int> ans,order;\n        int n=tasks.size();\n        for(int i=0;i<n;i++){\n            order.push_back(i);\n        }\n        sort(order.begin(),order.end(),[&](int i,int j){return tasks[i][0]<tasks[j][0];});\n        priority_queue <pii,vector<pii>,greater<pii>> que;\n        int t=0;\n        for(int i=0;i<n;){\n            while(i<n&&tasks[order[i]][0]<=t){\n                que.push({tasks[order[i]][1],order[i]});\n                i++;\n            }\n            if(!que.empty()){\n                int prior=que.top().first,id=que.top().second;\n                que.pop();\n                ans.push_back(id);\n                t=max(t,tasks[id][0]);\n                t+=prior;\n\n            }\n            else t=tasks[order[i]][0];\n        }\n           while(!que.empty())\n        {\n            int id = que.top().second;\n            que.pop();\n            ans.push_back(id);\n        }\n         return ans;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1634497789","body":"```\nclass Solution {\npublic:\n    int numberOfRounds(string loginTime, string logoutTime) {\n            int start=stoi(loginTime.substr(0,2))*60+stoi(loginTime.substr(3,2));\n            int end=stoi(logoutTime.substr(0,2))*60+stoi(logoutTime.substr(3,2));\n            int cnt;\n            if(end>start) cnt=(end-end%15)/15-(start+(15-start%15))/15;\n            if(end<start) cnt=((1440-start)-(1440-start)%15)/15+(end-end%15)/15;\n            return cnt;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1636043323","body":"```\nclass Solution {\n    public int minCharacters(String a, String b) {\n        char [] ac = a.toCharArray(), bc = b.toCharArray();\n        int alen = a.length(), blen = b.length(), ans = alen + blen;\n        int [] c1 = new int[26], c2 = new int[26];\n        for (int i = 0; i < 26; i++) {\n            c1[i] = 0;\n            c2[i] = 0;\n        }\n        for (int i = 0; i < alen; i++)\n            c1[ac[i] - 'a']++;\n        for (int i = 0; i < blen; i++)\n            c2[bc[i] - 'a']++;\n        \n        int ans1 = alen - c1[0] + c2[0], ans2 = blen - c2[0] + c1[0];\n        for (int i = 1; i < 26; i++) {\n            ans = Math.min(ans, ans1);\n            ans = Math.min(ans, ans2);\n            ans1 = ans1 - c1[i] + c2[i];\n            ans2 = ans2 + c1[i] - c2[i];\n        }     \n        for (int i = 0; i < 26; i++)\n            ans = Math.min(ans, alen + blen - c1[i] - c2[i]);\n\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1636715982","body":"```\nclass Solution {\npublic:\n    int piv(vector<int>& nums, int l, int r) {\n        int a = nums[l], b = nums[(l+r)/2], c = nums[r];\n        if((a <= b && b <= c) || (c <= b && b <= a)) {\n            swap(nums[r], nums[(l+r)/2]);\n            return b;\n        }\n        if((b < a && a < c) || (c < a && a < b)) {\n            swap(nums[l], nums[r]);\n            return a;\n        }\n        return c;\n    }\n    void qsort(vector<int>& nums, int l, int r) {\n        if(l >= r) return;\n        int pivot = piv(nums, l, r);\n        cout<<l<<\",\"<<r<<\",\"<<pivot<<endl;\n        int less=l;\n        for(int i=l; i<r; i++) {\n            if(nums[i] < pivot) {\n                swap(nums[i], nums[less]);\n                less++;\n            }\n        }\n        int more = less;\n        for(int i=less; i<=r; i++) {\n            if(nums[i] == pivot) {\n                swap(nums[i], nums[more]);\n                more++;\n            }\n        }\n        qsort(nums, l, less-1);\n        qsort(nums, more, r);\n    }\n    vector<int> sortArray(vector<int>& nums) {\n        qsort(nums, 0, nums.size()-1);\n        // sort(nums.begin(), nums.end());\n        return nums;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637117567","body":"```\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        for(int i=1; i <= x / i;i++){\n           long t=i*i;\n            if(t>x)\n            return i-1;\n        }\n\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1638376181","body":"```\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        unsigned int low = 1, high = n, mid; \n        while(low < high) {\n            mid = low + ((high - low)>> 1);\n            if(isBadVersion(mid)) high = mid;\n            else low = mid + 1;    \n        }\n        return low;  \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1640388444","body":"```\nclass Solution {\npublic:\n    int reversePairs(vector<int>& nums) {\n        int left=0;\n        int right=nums.size()-1;\n        vector<int>temp(nums.size());\n        int res=0;\n        mergesort(nums,temp,left,right,res);\n        return res;\n    }\n\n    void mergesort(vector<int>&nums,vector<int>&temp,int left,int right,int &res){\n        if(left>=right){\n            return;\n        }\n        int mid=(left+right)/2;\n        mergesort(nums,temp,left,mid,res);//左排序\n        mergesort(nums,temp,mid+1,right,res);//右排序\n        int i=left;\n        int j=mid+1;\n        while(i<=mid&&j<=right){\n            if(nums[i]>(long)2*nums[j]){\n                res+=mid-i+1;//这一步统计的是左边序列的值可以实现翻转对的数量\n                j++;\n            }\n            else{\n                i++;\n            }\n        }\n        i=left;\n        j=mid+1;\n        int index=0;\n        while(i<=mid&&j<=right){//这里开始归并\n            if(nums[i]>nums[j]){\n                temp[index++]=nums[j++];\n            }\n            else{\n                temp[index++]=nums[i++];\n            }\n        }\n        while(i<=mid){\n            temp[index++]=nums[i++];\n        }\n        while(j<=right){\n            temp[index++]=nums[j++];\n        }\n        index=0;\n        while(left<=right){\n            nums[left++]=temp[index++];\n        }\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/42#issuecomment-1642345518","body":"```\nclass Solution {\n    public boolean rotateString(String s, String goal) {\n        int n = s.length();\n        List<Integer> var = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == goal.charAt(0)) var.add(i);\n        }\n        for (int i = 0; i < var.size(); i++) {\n            if (goal.equals(s.substring(var.get(i), s.length()) + s.substring(0, var.get(i)))) return true;\n        }\n        return false;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1644085497","body":"```\nclass Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n=nums.size(), l=0, r=nums[n-1]-nums[0];\n        while(l <= r){\n            int m=(l+r)/2, cnt=0;\n            for(int i=0,j=0;j<n;j++){\n                while(nums[j]-nums[i] > m)\n                    i++;\n                cnt += j-i;\n            }\n            if(cnt >= k)\n                r = m-1;\n            else\n                l = m+1;\n        }\n        return l;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/44#issuecomment-1645770896","body":"```\nclass Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        left, right = 0, n * n - 1\n        while left <= right:\n            mid = left + (right - left) / 2\n            if self.dfs([[False] * n for _ in range(n)], grid, mid, n, 0, 0):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n        \n    def dfs(self, visited, grid, mid, n, i, j):\n        visited[i][j] = True\n        if i == n - 1 and j == n - 1:\n            return True\n        directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n        for dir in directions:\n            x, y = i + dir[0], j + dir[1]\n            if x < 0 or x >= n or y < 0 or y >= n or visited[x][y] or max(mid, grid[i][j]) != max(mid, grid[x][y]):\n                continue\n            if self.dfs(visited, grid, mid, n, x, y):\n                return True\n        return False\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/45#issuecomment-1646614708","body":"\n```\nclass Solution {\n    public int maxVowels(String s, int k) {\n        int count = 0;\n        for (int i = 0; i < k; i++) {\n            char c = s.charAt(i);\n            if (helper(c)) {\n                count++;\n            }\n        }\n\n        int max = count;\n        for (int i = k; i < s.length(); i++) {\n            if (helper(s.charAt(i))) {\n                count++;\n            }\n            if (helper(s.charAt(i - k))) {\n                count--;\n            }\n            max = Math.max(max, count);\n        }\n        return max;\n    }\n\n    private boolean helper(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n}\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/47#issuecomment-1648162724","body":"```\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        if(p.size()>s.size()) return {};\n         vector<int> ret={};\n         unordered_map<char,int> m,temp;\n         for(auto x:p) m[x]++;\n         temp=m;\n         int cnt=0;\n         for(int i=0;i<=s.size()-p.size();i++){\n           if(temp.count(s[i])){\n               cnt++;\n               temp[s[i]]--;\n               for(int j=i+1;j<i+p.size()+1;j++){\n                   if(!temp.count(s[j])) break;\n                   if(temp.count(s[j])&&temp[s[j]]!=0){\n                       temp[s[j]]--;\n                       cnt++;\n                       continue;\n                   }\n                   if(temp[s[j]]==0) break;\n               }\n           }  \n           if(cnt==p.size()) ret.push_back(i);\n           temp=m;\n           cnt=0;\n         }\n         return ret;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/48#issuecomment-1650026681","body":"```\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        l, counter, N, ct = 0, Counter(), len(s), Counter(t)\n        k = 0\n        ret, ans = inf, \"\"\n        for r in range(N):\n            counter[s[r]] += 1\n            if s[r] in t and counter[s[r]] == ct[s[r]]:\n                k += 1\n            while k == len(ct):\n                if r - l + 1 < ret:\n                    ans = s[l:r+1]\n                ret = min(r - l + 1, ret)\n                counter[s[l]] -= 1\n                if s[l] in t and counter[s[l]] == ct[s[l]]-1:\n                    k -= 1\n                l += 1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/49#issuecomment-1652066910","body":"```\nclass Solution:\n    def solve(self, A, target):\n        if not A and not target: return 0\n        target = sum(A) - target\n        ans = len(A) + 1\n        i = t = 0\n\n        for j in range(len(A)):\n            t += A[j]\n            while i <= j and t > target:\n                t -= A[i]\n                i += 1\n            if t == target: ans = min(ans, len(A) - (j - i + 1))\n        return -1 if ans == len(A) + 1 else ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/50#issuecomment-1653820278","body":"```\nclass Solution {\npublic:\n    vector<string> readBinaryWatch(int turnedOn) {\n         vector<string> res;\n        for(int i=0;i<12;i++){\n            for(int j=0;j<60;j++){\n                if(__builtin_popcount(i)+__builtin_popcount(j)==turnedOn){\n                    string s={};\n                    s+=to_string(i)+\":\"+(j<10?\"0\":\"\")+to_string(j);\n                     res.push_back(s);\n                }\n            }\n        }\n        return res;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/51#issuecomment-1655916451","body":"```\nclass Solution {\npublic:\n    vector<int> column,ldiagonal,rdiagonal;\n    vector<vector<string>> result;\n    int ans=0;\n    void backtracking(int n,vector<string> mmap,int row){\n        if (row==n){ \n            result.push_back(mmap);\n            ans++;\n            return;\n        }\n\n        for (int j=0;j<n;++j){\n            if (column[j]==0&&ldiagonal[row+j]==0&&rdiagonal[row-j+n-1]==0){\n \n                mmap[row][j]='Q';\n                column[j]=1;\n                ldiagonal[row+j]=1;\n                rdiagonal[row-j+n-1]=1;\n                backtracking(n,mmap,row+1);\n  \n                rdiagonal[row-j+n-1]=0;\n                ldiagonal[row+j]=0;\n                column[j]=0;\n                mmap[row][j]='.';\n            }\n        }\n        return;\n    }\n     int totalNQueens(int n) {\n        vector<string> initial;\n        for (int i=0;i<n;++i){\n            string temp;\n            for (int j=0;j<n;++j){\n                temp.push_back('.');\n            }\n            initial.push_back(temp);\n        }\n        for (int i=0;i<18;++i){\n            column.push_back(0);\n            rdiagonal.push_back(0);\n            ldiagonal.push_back(0);\n        }\n\n        backtracking(n,initial,0);\n\n        return ans;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/52#issuecomment-1656764299","body":"```\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n\n        m,n = len(grid), len(grid[0])\n        ans = 0\n        def dfs(i,j):\n            if i < 0 or i >= m or j < 0 or j >= n: return 0\n            if grid[i][j] == 0: return 0\n            grid[i][j] = 0\n            top = dfs(i+1,j)\n            bottom = dfs(i-1,j)\n            left = dfs(i,j-1)\n            right = dfs(i,j+1)\n            return 1 + sum([top, bottom,left, right])\n\n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i,j))\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/53#issuecomment-1657206627","body":"```\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        queue = collections.deque((i, j) for i in range(n) for j in range(n) if grid[i][j])\n        if len(queue) == 0 or len(queue) == n * n:\n            return -1\n        else:\n            while queue:\n                i, j = queue.popleft()\n                for p, q in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                    x, y = i + p, j + q\n                    if 0 <= x < n and 0 <= y < n and not grid[x][y]:\n                        grid[x][y] = grid[i][j] + 1\n                        queue.append((x, y))\n            return grid[i][j] - 1\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/54#issuecomment-1658623448","body":"```\nclass Solution {\npublic:\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {\n        int sum=0;\n        vector<bool> candysigns(candies.size(),1);\n        vector<bool> boxsigns(candies.size(),1);\n        vector<int> getbox;\n        for(int i=0;i<initialBoxes.size();i++){\n            int m=initialBoxes[i];\n            boxsigns[m]=0;\n            if(status[m]==1) {\n                sum+=candies[m];\n                candysigns[m]=0;\n            }\n            if(keys[m].size()!=0){\n                for(int j=0;j<keys[m].size();m++){\n                    if(candysigns[j]!=0) {\n                         sum+=candies[j];\n                         candysigns[j]=0;\n                    }\n                }\n            }\n            if(containedBoxes[m].size()!=0){\n                for(int k=0;k<containedBoxes[m].size();k++){\n                getbox.push_back(containedBoxes[m][k]);\n                if(boxsigns[k]!=0) boxsigns[containedBoxes[m][k]]=1;\n            }\n        }\n        for(int i=0;i<boxsigns.size();i++){\n            if(boxsigns[i]==1){\n                if(candysigns[i]!=0) sum+=candies[i];\n            }\n        }\n        return sum;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/55#issuecomment-1660587844","body":"```\nclass Solution:\n    def solve(self, root):\n        q = collections.deque([(root, 0)])\n        d = {}\n        while q:\n            cur, pos = q.popleft()\n            if pos not in d:\n                d[pos] = cur.val\n            if cur.left:\n                q.append((cur.left, pos - 1))\n            if cur.right:\n                q.append((cur.right, pos + 1))\n        return list(map(lambda x:x[1], sorted(d.items(),key=lambda x: x[0])))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/56#issuecomment-1662421138","body":"```\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n       int n=cost.size();\n       vector<int> dp(n+1);\n       for(int i=2;i<n+1;i++){\n            dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1]);\n       }\n       return dp[n];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/57#issuecomment-1663763118","body":"```\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> dp(n);\n        if(nums.size()==1) return nums[0];\n        dp[0]=nums[0];\n        dp[1]=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);\n        }\n        return dp[n-1];\n    }\n}; \n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/59#issuecomment-1666453433","body":"```\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n    int m=text1.size(), n=text2.size();\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\n        for (int i=1; i<=m; i++) {\n            int c1=text1[i-1];\n            for (int j=1; j<=n; j++) {\n                char c2=text2[j-1];\n                if (c1==c2) {\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/60#issuecomment-1666722959","body":"```\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1] * n] + [[1] + [0] * (n - 1)] * (m - 1)\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/61#issuecomment-1667773444","body":"```\nclass Solution {\n    static int[][] dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};\n\n    public double knightProbability(int n, int k, int row, int column) {\n        double[][][] dp = new double[k + 1][n][n];\n        for (int step = 0; step <= k; step++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (step == 0) {\n                        dp[step][i][j] = 1;\n                    } else {\n                        for (int[] dir : dirs) {\n                            int ni = i + dir[0], nj = j + dir[1];\n                            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][row][column];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/62#issuecomment-1669278640","body":"```\nclass Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (desiredTotal <= maxChoosableInteger || desiredTotal == 0)\n\t\t\treturn true;\n        if (desiredTotal > ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2))\n\t\t\treturn false;\n\n\t\tif (1 + maxChoosableInteger < desiredTotal && desiredTotal < 2 * maxChoosableInteger)\n\t\t\treturn true;\n\t\tif (1 + maxChoosableInteger == desiredTotal && desiredTotal < 2 * maxChoosableInteger)\n\t\t\treturn false; \n\n\t\tif (desiredTotal % 2 == 0 && maxChoosableInteger % 2 == 0) {\n\t\t\treturn desiredTotal / maxChoosableInteger < 4 || desiredTotal == 100 && maxChoosableInteger == 16;\n\t\t} else {\n\t\t\treturn desiredTotal % 2 == 0 || maxChoosableInteger % 2 != 0 || desiredTotal / maxChoosableInteger < 5;\n\t\t}\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flipn9":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wabw1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqmmy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-pricity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sclihuiming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"amazeding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tzuikuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ringo1597":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brucezhang-utf-8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luanxing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moin-jer":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1589395915","body":"```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int add = 0;\n        num[num.length - 1] += k;\n        for(int i = num.length - 1; i >= 0; --i) {\n            num[i] = num[i] + add;\n            add = num[i] / 10;\n            list.add(num[i] % 10);\n        }\n        while (add != 0) {\n            list.add(add % 10);\n            add /= 10;\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1589411051","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int last = -2 * len;\n        int[] ans = new int[len];\n        Arrays.fill(ans, 2 * len);\n        for (int i = 0; i < len; ++i) {\n            if (s.charAt(i) == c) {\n                last = i;\n            }\n            ans[i] = Math.min(ans[i], i - last);\n        }\n        last = 2 * len;\n        for (int i = len - 1; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                last = i;\n            }\n            ans[i] = Math.min(ans[i], last - i);\n        }\n        return ans;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1589433725","body":"```java\nclass CustomStack {\n\n    int[] stack;\n    int[] add;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if (top != 0) {\n            add[top - 1] += add[top];\n        }\n        add[top] = 0;\n        --top;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        int n = Math.min(k - 1, top);\n        if (n >= 0) {\n            add[n] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589354004","body":"class Solution {\n    public String decodeString(String s) {\n        Deque<String> stack = new LinkedList<>();\n        char[] cs = s.toCharArray();\n        for (char c : cs) {\n            if (c != ']') {\n                stack.push(c + \"\");\n            } else {\n                String al = \"\";\n                while (!\"[\".equals(stack.peek())) {\n                    al = stack.pop() + al;\n                }\n                stack.pop();\n                String num = \"\";\n                while (!stack.isEmpty() && Character.isDigit((stack.peek()).toCharArray()[0])) {\n                    num = stack.pop() + num;\n                }\n                int n = Integer.parseInt(num);\n                String res = \"\";\n                for (int i = 0; i < n; ++i) {\n                    res += al;\n                }\n                stack.push(res);\n            }\n        }\n        String ans = \"\";\n        while (!stack.isEmpty()) {\n            ans = stack.pop() + ans;\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1616613220","body":"```java\nclass MyQueue {\n\n    Deque<Integer> stackin;\n    Deque<Integer> stackout;\n\n    public MyQueue() {\n        stackin = new LinkedList<>();\n        stackout = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        stackin.push(x);\n    }\n    \n    public int pop() {\n        if (stackout.isEmpty()) {\n            while (!stackin.isEmpty()) {\n                stackout.push(stackin.pop());\n            }\n        }\n        return stackout.pop();\n    }\n    \n    public int peek() {\n        if (stackout.isEmpty()) {\n            while (!stackin.isEmpty()) {\n                stackout.push(stackin.pop());\n            }\n        }\n        return stackout.peek();\n    }\n    \n    public boolean empty() {\n        return stackin.isEmpty() && stackout.isEmpty();\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1616680612","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<>();\n        for (int num : arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(head);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1616688178","body":"```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        int count = 0;\n        ListNode now = head;\n        while (now != null) {\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast.next != null) {\n            if (k-- <= 0) {\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1620284777","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode dump = new ListNode(-1, head);\n        ListNode pre = dump;\n        ListNode first = head;\n        ListNode second = head.next;\n        while (first != null) {\n            second = first.next;\n            if (second == null) {\n                break;\n            }\n            ListNode nextNode = second.next;\n            pre.next = second;\n            second.next = first;\n            first.next = nextNode;\n            pre = first;\n            first = nextNode;\n        }\n        return dump.next;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1627709805","body":"```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        return dfs(head, null);\n    }\n\n    private TreeNode dfs(ListNode head, ListNode tail) {\n        if (head == tail) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = dfs(head, slow);\n        root.right = dfs(slow.next, tail);\n        return root;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1597376662","body":"public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<>();\n        ListNode temp = headA;\n        while(temp != null){\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while(temp != null){\n            if(visited.contains(temp)){\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1627711109","body":"```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                fast = head;\n                while (slow != fast) {\n                    slow = slow.next;\n                    fast = fast.next;\n                }\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1627720812","body":"```java\nclass LRUCache {\n\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode() {}\n        public DLinkedNode(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    Map<Integer, DLinkedNode> cache;\n    int capacity;\n    int size;\n    private DLinkedNode head;\n    private DLinkedNode tail;\n\n    public LRUCache(int capacity) {\n        cache = new HashMap<>();\n        this.capacity = capacity;\n        this.size = 0;\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n\n            if (size > capacity) {\n                DLinkedNode removedTail = removedTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n\n    private void removedNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removedNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removedTail() {\n        DLinkedNode res = tail.prev;\n        removedNode(res);\n        return res;\n    }\n\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1605530899","body":"```java\nclass Solution {\n    int max = 0;\n    public int maxDepth(TreeNode root) {\n        dfs(root, 1);\n        return max;\n    }\n\n    public void dfs(TreeNode root, int depth) {\n        if (root == null) {\n            max = Math.max(max, depth - 1);\n            return;\n        }\n        dfs(root.left, depth + 1);\n        dfs(root.right, depth + 1);\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1605521218","body":"```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        if (p.val == q.val) {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n        return false;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605510232","body":"```java\nclass Solution {\n    int ans = 0;\n    public int sumNumbers(TreeNode root) {\n        dfs(root, \"\");\n        return ans;\n    }\n\n    public void dfs(TreeNode root, String pre) {\n        if (root == null) {\n            return;\n        }\n        pre += root.val;\n        if (root.left == null && root.right == null) {\n            ans += Integer.valueOf(pre);\n            return;\n        }\n        dfs(root.left, pre);\n        dfs(root.right, pre);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1627729696","body":"```java\nclass Solution {\n    int maxDepth = 0;\n    Map<Integer, Integer> map = new HashMap<>();\n    public int findBottomLeftValue(TreeNode root) {\n        dfs(root, 1);\n        return map.get(maxDepth);\n    }\n\n    private void dfs(TreeNode node, int level) {\n        if (node == null) {\n            return;\n        }\n        dfs(node.left, level + 1);\n        if (level > maxDepth && !map.containsKey(level)) {\n            map.put(level, node.val);\n            maxDepth = level;\n        }\n        dfs (node.right, level + 1);\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1627742016","body":"```java\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        Deque<TreeNode> queue = new LinkedList<>();\r\n        StringBuilder sb = new StringBuilder();\r\n        queue.offer(root);\r\n        while (!queue.isEmpty()) {\r\n            TreeNode node = queue.poll();\r\n            if (node == null) {\r\n                sb.append(\"null,\");\r\n            } else {\r\n                sb.append(node.val + \",\");\r\n                queue.offer(node.left);\r\n                queue.offer(node.right);\r\n            }\r\n        }\r\n        sb.deleteCharAt(sb.length() - 1);\r\n        return sb.toString();\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        String[] vals = data.split(\",\");\r\n        if (vals[0].equals(\"null\")) {\r\n            return null;\r\n        }\r\n        Deque<TreeNode> queue = new LinkedList<>();\r\n        TreeNode root = new TreeNode(Integer.valueOf(vals[0]));\r\n        queue.offer(root);\r\n        int index = 1;\r\n        while (!queue.isEmpty()) {\r\n            TreeNode node = queue.poll();\r\n\r\n            String leftVal = vals[index++];\r\n            if (!leftVal.equals(\"null\")) {\r\n                TreeNode leftNode = new TreeNode(Integer.valueOf(leftVal));\r\n                node.left = leftNode;\r\n                queue.offer(leftNode);\r\n            }\r\n\r\n            String rightVal = vals[index++];\r\n            if (!rightVal.equals(\"null\")) {\r\n                TreeNode rightNode = new TreeNode(Integer.valueOf(rightVal));\r\n                node.right = rightNode;\r\n                queue.offer(rightNode);\r\n            }\r\n        }\r\n        return root;\r\n    }\r\n}\r\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1629158200","body":"```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; ++i) {\n            int num = nums[i];\n            if (map.get(target - num) != null) {\n                return new int[]{map.get(target - num), i};\n            } else {\n                map.put(num, i);\n            }\n        }\n        return new int[]{};\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1629197335","body":"```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            int num = entry.getKey();\n            int count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] ret= new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1630710220","body":"```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        if (points == null || points.length <= 2) {\n            return 0;\n        }\n        int res = 0;\n        Map<Integer, Integer> equalCount = new HashMap<>();\n        // 固定第一个数\n        for (int i = 0; i < points.length; ++i) {\n            // 遍历所有数字，计算距离\n            for (int j = 0; j < points.length; ++j) {\n                int distance = getDistance(points[i], points[j]);\n                equalCount.put(distance, equalCount.getOrDefault(distance, 0) + 1);\n            }\n            // 对相同距离的点排列组合\n            for (int count : equalCount.values()) {\n                res += count * (count - 1);\n            }\n            equalCount.clear();\n        }\n        return res;\n    }\n\n    private int getDistance(int[] x, int[] y) {\n        int x1 = y[0] - x[0];\n        int y1 = y[1] - x[1];\n        return x1 * x1 + y1 * y1;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1630743361","body":"```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character> set = new HashSet<>();\n        int ans = 0;\n        int last = 0;\n        for (int i = 0; i < s.length(); ++i) {\n            char c = s.charAt(i);\n            if (set.contains(c)) {\n                ans = Math.max(ans, i - last);\n                while (s.charAt(last) != c) {\n                    set.remove(s.charAt(last));\n                    ++last;\n                }\n                set.remove(s.charAt(last));\n                ++last;\n            }\n            set.add(c);\n        }\n        ans = Math.max(ans, s.length() - last);\n        return ans;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616610995","body":"```java\nclass Solution {\n   public List<Integer> findSubstring(String s, String[] words) {\n        if (s == null || words == null || words.length == 0) {\n            return new ArrayList<>();\n        }\n\n        List<Integer> res = new ArrayList<>();\n        int n = words.length;\n        int m = words[0].length();\n        HashMap<String, Integer> map = new HashMap<>();\n\n        for (String str : words) {\n            map.put(str, map.getOrDefault(str, 0) + 1);\n        }\n\n        for (int i = 0; i <= s.length() - n * m; i++) {\n            HashMap<String, Integer> copy = new HashMap<>(map);\n            int k = n;\n            int j = i;\n            while (k > 0) {\n                String str = s.substring(j, j + m);\n                if (!copy.containsKey(str) || copy.get(str) < 1) {\n                    break;\n                }\n                copy.put(str, copy.get(str) - 1);\n                k--;\n                j += m;\n            }\n            if (k == 0) res.add(i);\n        }\n        return res;\n   }\n}\n``","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1620270932","body":"```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1630978385","body":"```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length <= 1) {\n            return nums.length;\n        }\n        int i = 0;\n        int j = 1;\n        while (j < nums.length) {\n            if (nums[i] != nums[j]) {\n                ++i;\n                nums[i] = nums[j];\n            }\n            ++j;\n        }\n        return i + 1;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1630985776","body":"```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int l = 0;\n        int r = nums.length - 1;\n        while (l <= r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] == target) {\n                return mid;\n            }\n            if (nums[mid] < target) {\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return l;\n    }\n}\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1627263607","body":"···java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n\n        int[] in_degree = new int[n+1];\n        int[] out_degree = new int[n+1];\n\n        for (int i = 0; i < trust.length; i++) {\n            out_degree[trust[i][0]] += 1;\n            in_degree[trust[i][1]] += 1;\n        }\n\n        for (int i = 1; i < n+1; i++) {\n            if (in_degree[i] == n-1 && out_degree[i] == 0) {\n                return i;\n            }\n        }\n\n        return -1;\n        \n    }\n}\n···","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1630690695","body":"```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0;\n        int y = 0;\n        for (int i = 0; i < moves.length(); ++i) {\n            if (moves.charAt(i) == 'R') {\n                ++x;\n            } else if (moves.charAt(i) == 'L') {\n                --x;\n            } else if (moves.charAt(i) == 'U') {\n                ++y;\n            } else if (moves.charAt(i) == 'D') {\n                --y;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1634409546","body":"```java\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        int n = tasks.length;\n        int[] ans = new int[n];\n        int[][] extTask = new int[n][3];\n        for (int i = 0; i < n; ++i) {\n            extTask[i][0] = i;\n            extTask[i][1] = tasks[i][0];\n            extTask[i][2] = tasks[i][1];\n        }\n        Arrays.sort(extTask, (a, b) -> a[1] - b[1]);\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[2] == b[2] ? a[0] - b[0] : a[2] - b[2]);\n        int time = 0;\n        int ai = 0;\n        int ti = 0;\n        while (ai < n) {\n            while (ti < n && extTask[ti][1] <= time) {\n                pq.offer(extTask[ti++]);\n            }\n            if (pq.isEmpty()) {\n                time = extTask[ti][1];\n                continue;\n            }\n            int[] bestFit = pq.poll();\n            ans[ai++] = bestFit[0];\n            time += bestFit[2];\n        }\n        return ans;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1634379755","body":"```java\nclass Solution {\n    public int numberOfRounds(String loginTime, String logoutTime) {\n        String[] inTime = loginTime.split(\":\");\n        String[] outTime = logoutTime.split(\":\");\n        int sh = Integer.valueOf(inTime[0]);\n        int sm = Integer.valueOf(inTime[1]);\n        int eh = Integer.valueOf(outTime[0]);\n        int em = Integer.valueOf(outTime[1]);\n        if (sh * 60 + sm > eh * 60 + em) {\n            eh += 24;    \n        }\n        if (0 < sm && sm <= 15) {\n            sm = 15;\n        } else if (15 < sm && sm <= 30) {\n            sm = 30;\n        } else if (30 < sm && sm <= 45) {\n            sm = 45;\n        } else if (45 < sm && sm <= 60) {\n            sm = 0;\n            sh += 1;\n        }\n        if (0 <= em && em < 15) {\n            em = 0;\n        } else if (15 <= em && em < 30) {\n            em = 15;\n        } else if (30 <= em && em < 45) {\n            em = 30;\n        } else if (45 <= em && em < 60) {\n            em = 45;\n        }\n        return Math.max(0,(eh * 60 + em - sh * 60 - sm) / 15);\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637030034","body":"```java\nclass Solution {\n    public int mySqrt(int x) {\n        if (x <= 1) {\n            return x;\n        }\n        int l = 1;\n        int r = 46340;\n        while (l <= r) {\n            int mid = (l + r) >>> 1;\n            if (mid * mid == x) {\n                return mid;\n            } else if (mid * mid > x) {\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return r;\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/45#issuecomment-1646596735","body":"```java\nclass Solution {\n    public int maxVowels(String s, int k) {\n        int n = s.length();\n        int vowel_count = 0;\n        for (int i = 0; i < k; ++i) {\n            vowel_count += isVowel(s.charAt(i));\n        }\n        int ans = vowel_count;\n        for (int i = k; i < n; ++i) {\n            vowel_count += isVowel(s.charAt(i)) - isVowel(s.charAt(i - k));\n            ans = Math.max(ans, vowel_count);\n        }\n        return ans;\n    }\n\n    public int isVowel(char ch) {\n        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ? 1 : 0;\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/51#issuecomment-1655527638","body":"```java\nclass Solution {\n    public int totalNQueens(int n) {\n        Set<Integer> columns = new HashSet<Integer>();\n        Set<Integer> diagonals1 = new HashSet<Integer>();\n        Set<Integer> diagonals2 = new HashSet<Integer>();\n        return backtrack(n, 0, columns, diagonals1, diagonals2);\n    }\n\n    public int backtrack(int n, int row, Set<Integer> columns, Set<Integer> diagonals1, Set<Integer> diagonals2) {\n        if (row == n) {\n            return 1;\n        } else {\n            int count = 0;\n            for (int i = 0; i < n; i++) {\n                if (columns.contains(i)) {\n                    continue;\n                }\n                int diagonal1 = row - i;\n                if (diagonals1.contains(diagonal1)) {\n                    continue;\n                }\n                int diagonal2 = row + i;\n                if (diagonals2.contains(diagonal2)) {\n                    continue;\n                }\n                columns.add(i);\n                diagonals1.add(diagonal1);\n                diagonals2.add(diagonal2);\n                count += backtrack(n, row + 1, columns, diagonals1, diagonals2);\n                columns.remove(i);\n                diagonals1.remove(diagonal1);\n                diagonals2.remove(diagonal2);\n            }\n            return count;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/57#issuecomment-1663099764","body":"```java\nclass Solution {\n    public int rob(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int length = nums.length;\n        if (length == 1) {\n            return nums[0];\n        }\n        int[] dp = new int[length];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n        for (int i = 2; i < length; i++) {\n            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n        }\n        return dp[length - 1];\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihua1997":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cuizezhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tiandao043":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"restlessbreeze":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1590787481","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int length = num.size();\r\n        int i;\r\n        for (i = 0; i < length && k > 0; i++)\r\n        {\r\n            int temp = num[length - 1 - i] + k % 10;\r\n            res.push_back(temp % 10);\r\n            k = k / 10 + temp / 10;\r\n        }\r\n        while (i < length)\r\n        {\r\n            res.push_back(num[length - 1 - i]);\r\n            i++;\r\n        }\r\n        while (k > 0)\r\n        {\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1590807119","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int length = s.length();\r\n        vector<int> res(length, length + 1);\r\n        int dis = length + 1;\r\n        for (int i = 0; i < length; i++)\r\n        {\r\n            if (s[i] == c)\r\n            {\r\n                res[i] = 0;\r\n                dis = 0;\r\n            }\r\n            else\r\n            {\r\n                dis++;\r\n                res[i] = min(res[i], dis);\r\n            }\r\n        }\r\n\r\n        dis = length + 1;\r\n        for (int i = length - 1; i >= 0; i--)\r\n        {\r\n            if (s[i] == c)\r\n            {\r\n                res[i] = 0;\r\n                dis = 0;\r\n            }\r\n            else\r\n            {\r\n                dis++;\r\n                res[i] = min(res[i], dis);\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1590870928","body":"### code\r\n```\r\nclass CustomStack {\r\nprivate:\r\n    vector<int> stk;\r\n    vector<int> va;\r\n    int top;\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        va.resize(maxSize);\r\n        top = 0;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top < stk.size())\r\n            stk[top++] = x;\r\n    }\r\n    \r\n    int pop() {\r\n        if (top > 0)\r\n        {\r\n            int res = stk[top - 1] + va[top - 1];\r\n            if (top > 1)\r\n                va[top - 2] += va[top - 1];\r\n            va[--top] = 0;\r\n            return res;\r\n        }\r\n        else\r\n        {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int l = k < top ? k : top;\r\n        if (l > 0)\r\n            va[l - 1] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1590889249","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    string str;\r\n    int ptr;\r\n\r\n    string getString()\r\n    {\r\n        if (ptr == str.length() || str[ptr] == ']')\r\n            return \"\";\r\n        string ret = \"\";\r\n        if (isdigit(str[ptr]))\r\n        {\r\n            int num = 0;\r\n            while (isdigit(str[ptr]))\r\n            {\r\n                num = num * 10 + (str[ptr++] - '0');\r\n            }\r\n            ptr++;\r\n            string temp = getString();\r\n            while (num--)\r\n            {\r\n                ret += temp;\r\n            }\r\n            ptr++;\r\n        }\r\n        else\r\n        {\r\n            ret += str[ptr++];\r\n        }\r\n        return ret + getString();\r\n    };\r\n\r\n    string decodeString(string s) {\r\n        str = s;\r\n        ptr = 0;\r\n        return getString();\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590901739","body":"### code\r\n```\r\nclass MyQueue {\r\npublic:\r\n    stack<int> stk1;\r\n    stack<int> stk2;\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        stk1.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        \r\n        if(stk2.empty())\r\n        {\r\n            while (!stk1.empty())\r\n            {\r\n                stk2.push(stk1.top());\r\n                stk1.pop();\r\n            }\r\n        }\r\n        int res = stk2.top();\r\n        stk2.pop();\r\n        return res;\r\n    }\r\n    \r\n    int peek() {\r\n        if(stk2.empty())\r\n        {\r\n            while (!stk1.empty())\r\n            {\r\n                stk2.push(stk1.top());\r\n                stk1.pop();\r\n            }\r\n        }\r\n        int res = stk2.top();\r\n        return res;\r\n    }\r\n    \r\n    bool empty() {\r\n        return stk1.empty() && stk2.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1596996502","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        vector<int> temp = arr;\r\n        sort(temp.begin(), temp.end());\r\n        unordered_map<int, int> cnt;\r\n        int res = 0;\r\n        for (int i = 0; i < arr.size(); i++)\r\n        {\r\n            int x = temp[i];\r\n            int y = arr[i];\r\n            cnt[x]++;\r\n            if (cnt[x] == 0)\r\n                cnt.erase(x);\r\n            cnt[y]--;\r\n            if (cnt[y] == 0)\r\n                cnt.erase(y);\r\n            if (cnt.size() == 0)\r\n                res++;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> stk;\r\n        for (int i = 0; i < arr.size(); i++)\r\n        {\r\n            if (stk.size() == 0 || arr[i] >= stk.top())\r\n            {\r\n                stk.push(arr[i]);\r\n            }\r\n            else\r\n            {\r\n                int num = stk.top();\r\n                stk.pop();\r\n                while (stk.size() != 0 && arr[i] < stk.top())\r\n                {\r\n                    stk.pop();\r\n                }\r\n                stk.push(num);\r\n            }\r\n        }\r\n        return stk.size();\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1596739939","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        ListNode* temp = head;\r\n        int num = 0;\r\n        while (temp)\r\n        {\r\n            num++;\r\n            temp = temp->next;\r\n        }\r\n        if (num == 0 || k == 0 || k % num == 0)\r\n            return head;\r\n        k %= num;\r\n        ListNode* f = head;\r\n        ListNode* s = head;\r\n        while (k--)\r\n        {\r\n            f = f->next;\r\n        }\r\n        while (f->next)\r\n        {\r\n            f = f->next;\r\n            s = s->next;\r\n        }\r\n        f->next = head;\r\n        f = s->next;\r\n        s->next = nullptr;\r\n        return f;\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595768355","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (!head || !head->next)\r\n            return head;\r\n        ListNode* temp1 = head;\r\n        ListNode* temp2 = head->next;\r\n        temp1->next = swapPairs(temp2->next);\r\n        temp2->next = temp1;\r\n        return temp2;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596722346","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head, ListNode* end) {\r\n        if (head == end)\r\n            return nullptr;\r\n        if (head->next == end)\r\n        {\r\n            TreeNode* temp = new TreeNode(head->val);\r\n            return temp;\r\n        }\r\n        ListNode* f = head;\r\n        ListNode* s = head;\r\n        while (f != end && f->next != end)\r\n        {\r\n            f = f->next->next;\r\n            s = s->next;\r\n        }\r\n        TreeNode* temp = new TreeNode(s->val);\r\n        temp->left = sortedListToBST(head, s);\r\n        temp->right = sortedListToBST(s->next, end);\r\n        return temp;\r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head)\r\n    {\r\n        return sortedListToBST(head, nullptr);\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596717806","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode* ta = headA;\r\n        ListNode* tb = headB;\r\n        while (ta != tb)\r\n        {\r\n            ta = ta == nullptr ? headB : ta->next;\r\n            tb = tb == nullptr ? headA : tb->next;\r\n            if (ta == nullptr && tb == nullptr)\r\n                break;\r\n        }\r\n        return ta;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598829375","body":"### code\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        if (!head || !head->next)\r\n            return nullptr;\r\n        ListNode* s = head;\r\n        ListNode* f = head;\r\n        while (f && f->next)\r\n        {\r\n            s = s->next;\r\n            f = f->next->next;\r\n            if (s == f)\r\n                break;\r\n        }\r\n        if (f == nullptr || f->next == nullptr)\r\n            return nullptr;\r\n        f = head;\r\n        while (f != s)\r\n        {\r\n            s = s->next;\r\n            f = f->next;\r\n        }\r\n        return f;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600826385","body":"### code\r\n```\r\nstruct bList\r\n{\r\n    int key;\r\n    int val;\r\n    bList* prev;\r\n    bList* next;\r\n    bList() : key(0), val(0), prev(nullptr), next(nullptr) {}\r\n    bList(int _key, int _val) : key(_key), val(_val), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\npublic:\r\n    int current;\r\n    int max;\r\n    unordered_map<int, bList*> um;\r\n    bList* start;\r\n    bList* end;\r\n    LRUCache(int capacity) {\r\n        max = capacity;\r\n        current = 0;\r\n        start = new bList();\r\n        end = new bList();\r\n        start->next = end;\r\n        end->prev = start;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (um.find(key) != um.end())\r\n        {\r\n            bList* temp = um[key];\r\n            temp->prev->next = temp->next;\r\n            temp->next->prev = temp->prev;\r\n\r\n            temp->next = start->next;\r\n            temp->prev = start;\r\n            start->next = temp;\r\n            temp->next->prev = temp;\r\n            return temp->val;\r\n        }\r\n        else\r\n        {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (um.find(key) != um.end())\r\n        {\r\n            bList* temp = um[key];\r\n            temp->prev->next = temp->next;\r\n            temp->next->prev = temp->prev;\r\n\r\n            temp->next = start->next;\r\n            temp->prev = start;\r\n            start->next = temp;\r\n            temp->next->prev = temp;\r\n            temp->val = value;\r\n        }\r\n        else\r\n        {\r\n            bList* temp = new bList(key, value);\r\n            temp->next = start->next;\r\n            temp->prev = start;\r\n            start->next = temp;\r\n            temp->next->prev = temp;\r\n            current++;\r\n            um[key] = temp;\r\n\r\n            if (current > max)\r\n            {\r\n                bList* temp = end->prev;\r\n                um.erase(temp->key);\r\n                temp->prev->next = temp->next;\r\n                temp->next->prev = temp->prev;\r\n                current--;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1603627802","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (!root)\r\n            return 0;\r\n        int left = maxDepth(root->left);\r\n        int right = maxDepth(root->right);\r\n        return 1 + max(left, right);\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1603629694","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (!p && !q)\r\n            return true;\r\n        if (!p && q)\r\n            return false;\r\n        if (p && !q)\r\n            return false;\r\n        if (p->val != q->val)\r\n            return false;\r\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605235602","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int res;\r\n\r\n    void traversal(TreeNode* root, int prev)\r\n    {\r\n        if (!root)\r\n            return;\r\n        if (!root->left && !root->right)\r\n        {\r\n            res += prev * 10 + root->val;\r\n            return;\r\n        }\r\n        traversal(root->left, prev * 10 + root->val);\r\n        traversal(root->right, prev * 10 + root->val);\r\n    }\r\n\r\n    int sumNumbers(TreeNode* root) {\r\n        res = 0;\r\n        traversal(root, 0);\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1606090943","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n        int res;\r\n        while (!q.empty())\r\n        {\r\n            TreeNode* temp = q.front();\r\n            q.pop();\r\n            res = temp->val;\r\n            if (temp->right)\r\n                q.push(temp->right);\r\n            if (temp->left)\r\n                q.push(temp->left);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1613240655","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    static bool cmp(pair<int, int>& m, pair<int, int>& n) {\r\n        return m.second > n.second;\r\n    }\r\n\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> occurrences;\r\n        for (auto& v : nums) {\r\n            occurrences[v]++;\r\n        }\r\n\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\r\n        for (auto& [num, count] : occurrences) {\r\n            if (q.size() == k) {\r\n                if (q.top().second < count) {\r\n                    q.pop();\r\n                    q.emplace(num, count);\r\n                }\r\n            } else {\r\n                q.emplace(num, count);\r\n            }\r\n        }\r\n        vector<int> ret;\r\n        while (!q.empty()) {\r\n            ret.emplace_back(q.top().first);\r\n            q.pop();\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615911515","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        int length = s.length();\r\n        int left = 0;\r\n        int right = 0;\r\n        int res = 0;\r\n        unordered_set<char> us;\r\n        while (right < length)\r\n        {\r\n            while (left < right && us.find(s[right]) != us.end())\r\n            {\r\n                us.erase(s[left]);\r\n                left++;\r\n            }\r\n            us.insert(s[right]);\r\n            right++;\r\n            res = max(res, right - left);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruikiwi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiminren":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saitochen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wtdcai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"albert556":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wuxiaoshawn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zrtch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuzhu096":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whoam-challenge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weisday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"syh-coder":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592683275","body":"var maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    a = arr[i];\r\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\r\n      const cur = stack[stack.length - 1];\r\n      while (stack && stack[stack.length - 1] > a) stack.pop();\r\n      stack.push(cur);\r\n    } else {\r\n      stack.push(a);\r\n    }\r\n  }\r\n  return stack.length;\r\n};\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaaller":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyrie96521":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cavecrypto":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cxgbro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erjian96":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585671273","body":"思路 从最后一位开始相加，每次记录进位。\r\n\r\ndef solution(num, k):\r\n\r\n        res = k\r\n        list_a = num\r\n        output = []\r\n        i = 0\r\n        while i < len(num):\r\n            sum = k + num[len(num)-i-1] \r\n            out = sum % 10\r\n            output.insert(0, out)\r\n            k = sum // 10\r\n            i=i+1\r\n        if k == 0:\r\n             return output\r\n        else: \r\n            while k != 0:\r\n                k_res = k % 10\r\n                k = k//10\r\n                output.insert(0, k_res)\r\n            return output","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586202564","body":"\r\ndef solution(s, c):\r\n\r\n    a = [i for i in range(len(s)) if c == s[i]]\r\n    print(a)\r\n    b = []\r\n\r\n    for i in a:\r\n\r\n        for x in range(len(s)):\r\n\r\n            b.append(min(abs(x-i),abs(len(s)-x-i)))\r\n            \r\n    return b","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587401837","body":"class CustomStack:\n\n    def __init__(self,maxSize:int):\n        self.stk=[]\n        self.maxSize=maxSize\n\n    def push(self,x:int)->None:\n        if len(self.stk) < self.maxSize:\n            self.stk.append(x)\n\n    def pop(self) -> int:\n        if self.stk:\n            return self.stk[-1]\n        else:\n            return -1\n        \n    def increment(self, k: int, val: int) -> None:\n        if k < len(self.stk):\n            for i in range(k, len(self.stk)):\n                self.stk[i] = self.stk[i] + val\n        else:\n            for i in range(len(self.stk)):\n                self.stk[i] = self.stk[i]+val","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-polarbear":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexno1no2":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585713471","body":"```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k:\n                num.insert(0,0)\n                i = 0\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586223593","body":"```\nclass Solution:\n     def shortestToChar(self, s: str, c: str) -> List[int]:\n         c_idx = [ i for i in range(len(s)) if s[i] == c ]\n         return [ min(abs( i - j )  for j in c_idx) for i in range(len(s)) ]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587558580","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1588624885","body":"```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = []\n        for item in s:\n            if item == ']':\n                strs = []\n                repeat = []\n                while res[-1] != '[':\n                    strs.insert(0,res.pop())\n                res.pop()\n                while res and res[-1].isdigit():\n                    repeat.insert(0,res.pop())\n                res.append(int(''.join(repeat))*''.join(strs))\n                continue \n            res.append(item)\n            \n        return ''.join(res)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591526703","body":"```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592455744","body":"```\n单调栈个数，其中单调栈中的每一个元素代表每一块中的最大值。\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        print(stack)\n        return len(stack)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594555249","body":"```\nclass Solution:\n    def rotateRight(self, head, k):\n        if not head or not head.next: \n            return head\n        # 求链表长度\n        _len = 0\n        cur = head\n        while cur:\n            _len += 1\n            cur = cur.next\n        # 对长度取模\n        k %= _len\n        if k == 0: \n            return head\n        # 快慢指针 让 fast 先向后走 k 步\n        fast, slow = head, head\n        while k:\n            fast = fast.next\n            k -= 1\n        # 继续往后走\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        # 新链表的头newHead，也就是倒数第 k 个节点\n        newHead = slow.next\n        # 将倒数第 k + 1 个节点 和 倒数第 k 个节点断开\n        slow.next = None\n        # 让最后一个节点指向原始链表的头\n        fast.next = head\n        return newHead\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595790968","body":"```\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        next = head.next\n        head.next = self.swapPairs(next.next)\n        next.next = head\n        return next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1595833676","body":"```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        slow , fast = head ,head\n        pre = ListNode(-1)\n        # newhead = TreeNode(-1)\n        while slow and fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        newhead = TreeNode(slow.val)\n        if pre:\n            pre.next = None\n        if slow == fast:\n            return newhead\n        newhead.left = self.sortedListToBST(head)\n        newhead.right = self.sortedListToBST(slow.next)\n\n\n        return newhead\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596684433","body":"```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        # p1 指向 A 链表头结点，p2 指向 B 链表头结点\n        p1, p2 = headA, headB\n        while p1 != p2:\n            # p1 走一步，如果走到 A 链表末尾，转到 B 链表\n            if p1 == None:\n                p1 = headB\n            else:\n                p1 = p1.next\n            # p2 走一步，如果走到 B 链表末尾，转到 A 链表\n            if p2 == None:\n                p2 = headA\n            else:\n                p2 = p2.next\n        return p1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598890191","body":"```\nclass Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not fast or not fast.next: \n                return # 没有环 会走到最后\n            fast, slow = fast.next.next, slow.next\n            if fast == slow:  # 环中第一次相遇\n                break\n\n        '''\n        设链表分为两段，环形入口前的一段为a，环形长度为b，链表总共有a + b ,设第一次相遇时fast走了f，slow走了s，则 f = 2s ，设f比s夺走了 nb（环形的倍数），则 f - s = nb，\n        则 s = nb ， f = 2nb；\n        假设指针从链表头部一直向前走k步，可以走到环形入口，则 k = a + mb（m=0,1,2，……），slow已经走了nb步，则slow再走a步就肯定可以走到环形入口  \n        '''\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600612054","body":"```\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, Capacity):\n        self.size = Capacity\n        self.cache = OrderedDict()\n\n    def get(self, key):\n        if key not in self.cache: \n            return -1\n        val = self.cache[key]\n        self.cache.move_to_end(key)\n        return val\n\n    def put(self, key, val):\n        if key in self.cache: \n            del self.cache[key]\n        self.cache[key] = val\n        if len(self.cache) > self.size:\n            self.cache.popitem(last=False)\n\n\n\n\n# class LRUCache:\n#     def __init__(self, capacity: int):\n#         self.capacity = capacity\n#         self.hashmap = {}\n#         # 新建两个节点 head 和 tail\n#         self.head = ListNode()\n#         self.tail = ListNode()\n#         # 初始化链表为 head <-> tail\n#         self.head.next = self.tail\n#         self.tail.prev = self.head\n\n#     # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法\n#     def move_node_to_tail(self, key):\n#             # 先将哈希表key指向的节点拎出来，为了简洁起名node\n#             #      hashmap[key]                               hashmap[key]\n#             #           |                                          |\n#             #           V              -->                         V\n#             # prev <-> node <-> next         pre <-> next   ...   node\n#             node = self.hashmap[key]\n#             node.prev.next = node.next\n#             node.next.prev = node.prev\n#             # 之后将node插入到尾节点前\n#             #                 hashmap[key]                 hashmap[key]\n#             #                      |                            |\n#             #                      V        -->                 V\n#             # prev <-> tail  ...  node                prev <-> node <-> tail\n#             node.prev = self.tail.prev\n#             node.next = self.tail\n#             self.tail.prev.next = node\n#             self.tail.prev = node\n\n#     def get(self, key: int) -> int:\n#         if key in self.hashmap:\n#             # 如果已经在链表中了久把它移到末尾（变成最新访问的）\n#             self.move_node_to_tail(key)\n#         res = self.hashmap.get(key, -1)\n#         if res == -1:\n#             return res\n#         else:\n#             return res.value\n\n#     def put(self, key: int, value: int) -> None:\n#         if key in self.hashmap:\n#             # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\n#             # 但是需要更新字典该值对应节点的value\n#             self.hashmap[key].value = value\n#             # 之后将该节点移到末尾\n#             self.move_node_to_tail(key)\n#         else:\n#             if len(self.hashmap) == self.capacity:\n#                 # 去掉哈希表对应项\n#                 self.hashmap.pop(self.head.next.key)\n#                 # 去掉最久没有被访问过的节点，即头节点之后的节点\n#                 self.head.next = self.head.next.next\n#                 self.head.next.prev = self.head\n#             # 如果不在的话就插入到尾节点前\n#             new = ListNode(key, value)\n#             self.hashmap[key] = new\n#             new.prev = self.tail.prev\n#             new.next = self.tail\n#             self.tail.prev.next = new\n#             self.tail.prev = new\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602553642","body":"```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        # 节点为空，高度为 0\n        if root == None:\n            return 0\n\n        # 递归计算左子树的最大深度\n        leftHeight = self.maxDepth(root.left)\n        # 递归计算右子树的最大深度\n        rightHeight = self.maxDepth(root.right)\n\n        # 二叉树的最大深度 = 子树的最大深度 + 1（1 是根节点）\n        return max(leftHeight, rightHeight) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604421108","body":"```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        else:\n            return p.val == q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605532533","body":"```\n# #递归左子树，回溯，递归右子树\n# class Solution:\n#     def sumNumbers(self, root: TreeNode) -> int:\n#         res = 0\n#         path = []\n#         def backtrace(root):\n#             nonlocal res\n#             # 空节点，返回\n#             if not root: return \n#             path.append(root.val)\n#             # 叶子节点，得到一个数并求和\n#             if not root.left and not root.right: \n#                 res += get_sum(path)\n#             # 左子树不空，递归调用左子树，调用完后弹出左子树节点后续再递归调用右子树\n#             if root.left: \n#                 backtrace(root.left)\n#                 path.pop()\n#             # 右子树不空\n#             if root.right: \n#                 backtrace(root.right)\n#                 path.pop()\n            \n\n#         def get_sum(arr):\n#             s = 0\n#             for i in range(len(arr)):\n#                 s = s * 10 + arr[i]\n#             return s\n\n#         backtrace(root)\n#         return res\n\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        self.res = 0\n        if root is None:\n            return 0\n        \n        self.dfs(root,root.val)\n        return self.res\n\n    def dfs(self,node,num):\n            if not node.left and not node.right:\n                self.res += num\n                return\n            if node.left:\n                self.dfs(node.left, num * 10 + node.left.val)\n            if node.right:\n                self.dfs(node.right, num * 10 + node.right.val)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605859686","body":"```\n# #广度优先搜索, 分层搜索，每层记录最左边的结点，最深一层记录的即所求结点\n# class Solution:\n#     def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n#         queue, ans = deque([root]), None\n#         while queue:\n#             ans = queue[0].val\n#             for _ in range(len(queue)):\n#                 node = queue.popleft()\n#                 if node.left:\n#                     queue.append(node.left)\n#                 if node.right:\n#                     queue.append(node.right)\n#         return ans\n\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node.right: \n                queue.append(node.right)\n            if node.left:\n                queue.append(node.left)\n        return node.val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1606579294","body":"```\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return 'None'\n        return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))\n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def dfs(dataList):\n            val = dataList.pop(0)\n            if val == 'None':\n                return None\n            root = TreeNode(int(val))\n            root.left = dfs(dataList)\n            root.right = dfs(dataList)\n            return root\n\n        dataList = data.split(',')\n        return dfs(dataList)\n\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1608971216","body":"```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n# # （列坐标，行坐标，值）\n# class Solution:\n#     def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n#         # BFS求坐标\n#         queue = collections.deque([[root, 0, 0]])\n#         hashmap = collections.defaultdict(list)\n        \n#         while queue:\n#             node, j, i = queue.popleft()\n#             hashmap[(j, i)].append(node.val)\n#             if node.left:\n#                 queue.append([node.left, j - 1, i + 1])\n#             if node.right:\n#                 queue.append([node.right, j + 1, i + 1])\n\n#         # 排序\n#         res, tmp= [], []\n#         j_flag = -1001\n#         for j, i in sorted(hashmap.keys()):\n\n#             if j != j_flag:\n#                 res.append(tmp)\n#                 tmp = []\n#                 j_flag = j\n#             tmp.extend(sorted(hashmap[(j, i)]))\n#         res.pop(0)\n#         res.append(tmp)\n#         return res\n\n\n#记录每一个列出现的所有数字(带行数)，按列排序，按行排序，按值排序即可。\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        hashmap = defaultdict(list)\n        def dfs(node, x, y):\n            if not node:\n                return\n            hashmap[y].append((x,node.val))\n            dfs(node.left, x+1, y-1)\n            dfs(node.right,x+1, y+1)\n        \n        dfs(root, 0, 0)\n        return [list(zip(*sorted(hashmap[i])))[1] for i in sorted(hashmap.keys())]\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1610984699","body":"```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        res = {}\n        for index,value in enumerate(nums):\n            if target - value in res:\n                return [index,res[target - value]]\n            else:\n                res[value] = index\n        return\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1612394123","body":"```\n# class Solution:\n#     def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n#         # 先统计各数字数目，然后找出数目的第k大数\n#         cnt = Counter(nums)\n#         l = list(cnt.values())\n\n#         # 小根堆\n#         def findKthLargest(nums, k):\n#             maxHeap = []\n#             for x in nums:\n#                 heapq.heappush(maxHeap, -x)\n#             for _ in range(k - 1):\n#                 heapq.heappop(maxHeap)\n#             return -maxHeap[0]\n\n#         ans = list()\n#         n = findKthLargest(l, k)\n#         for k, v in cnt.items():\n#             if v >= n:\n#                 ans.append(k)\n#         return ans\n\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dic = {}\n        for item in nums:\n            dic[item] = dic.get(item,0) + 1\n        \n        res = []\n        while k > 0:\n            tmp = 0\n            for num in dic:\n                if dic[num] > tmp:\n                    tmp = dic[num]\n                    cur = num\n            dic[cur] = -1\n            res.append(cur)\n            k -= 1\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614416178","body":"```\n# 思路\n# 1、用哈希表记录某个点到其他点的距离，并统计每个距离相同的点个数\n# 2、遍历哈希表，从距离相同的点中选2个，作为回旋镖的后两个点\n# 3、对每个点都执行1和2\n\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        for i in range(len(points)):\n            hashmap = collections.defaultdict(int)\n            for j in range(len(points)):\n                dx = points[i][0] - points[j][0]\n                dy = points[i][1] - points[j][1]\n                dis = dx * dx + dy * dy\n                hashmap[dis] += 1\n            for val in hashmap.values():\n                    res += val * (val - 1)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615887595","body":"```\n#滑动窗口\nclass Solution:\n\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        window = {}  # 用于记录窗口中各字符出现的次数\n        left, right = 0, 0  # 窗口的左右边界\n        res = 0  # 用于记录结果\n\n        while right < len(s):\n            c = s[right]\n            right += 1\n            window[c] = window.get(c, 0) + 1  # 更新窗口和字符的出现次数\n\n            # 判断窗口是否需要收缩\n            while window[c] > 1:\n                d = s[left]\n                left += 1\n                window[d] -= 1  # 更新窗口和字符的出现次数\n\n            res = max(res, right - left)  # 更新结果\n\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616639068","body":"```\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n        one_word_len = len(words[0])\n        all_words_len = len(words) * one_word_len\n        n = len(s)\n        words_counter = collections.Counter(words)\n        res = []\n        for i in range(0, n - all_words_len + 1):\n            tmp = s[i:i+all_words_len]\n            c_tmp = []\n            for j in range(0, all_words_len, one_word_len):\n                c_tmp.append(tmp[j:j+one_word_len])\n            if collections.Counter(c_tmp) == words_counter:\n                res.append(i)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1618723874","body":"```\n\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        x = sum(nums) % p\n        if x == 0: return 0  # 移除空子数组（这行可以不要）\n\n        ans = n = len(nums)\n        s = 0\n        last = {s: -1}  # 由于下面 i 是从 0 开始的，前缀和下标就要从 -1 开始了\n        for i, v in enumerate(nums):\n            s += v\n            last[s % p] = i\n            j = last.get((s - x) % p, -n)  # 如果不存在，-n 可以保证 i-j >= n\n            ans = min(ans, i - j)  # 改成手写 min 会再快一些\n        return ans if ans < n else -1\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1619648687","body":"```\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast ,slow = head , head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1621989119","body":"```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        slow, fast = 0, 1\n        while fast < len(nums):\n            if nums[fast] != nums[slow]:\n                slow = slow + 1\n                # 维护 nums[0..slow] 无重复\n                nums[slow] = nums[fast]\n            fast = fast + 1\n        return slow + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1623763258","body":"```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        if len(nums)<1:\n            return \n        left = 0\n        right = len(nums) \n        while left < right:\n            middle = left + (right - left)//2\n            if nums[middle] > target:\n                right = middle\n            elif nums[middle] == target:\n                return middle\n            else:\n                left = middle + 1\n        return left \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1625191138","body":"```\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        if not nums or not k:\n            return []\n        if len(nums) == 1:\n            return [nums[0]]\n\n        # 初始化队列和结果，队列存储数组的下标\n        queue = []\n        res = []\n\n        for i in range(len(nums)):\n            # 如果当前队列最左侧存储的下标等于 i-k 的值，代表目前队列已满，新元素需要进来，列表最左侧的下标出队列\n            if queue and queue[0] == i - k:\n                queue.pop(0)\n\n            # 对于新进入的元素，如果队列前面的数比它小，那么前面的都出队列\n            while queue and nums[queue[-1]] < nums[i]:\n                queue.pop()\n            # 新元素入队列\n            queue.append(i)\n\n            # 当前的大值加入到结果数组中\n            if i >= k-1:\n                res.append(nums[queue[0]])\n\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1627280013","body":"```\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        s, l = set(), [0] * n\n        for a, b in trust:\n            s.add(a)\n            l[b-1] += 1\n        for i in range(1, n + 1):\n            if i not in s and l[i - 1] == n - 1:\n                return i\n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627739657","body":"```\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        def dfs(i, c):\n            color[i] = c\n            for j in g[i]:\n                if color[j] == c:\n                    return False\n                if color[j] == 0 and not dfs(j, 3 - c):\n                    return False\n            return True\n\n        g = defaultdict(list)\n        color = [0] * n\n        for a, b in dislikes:\n            a, b = a - 1, b - 1\n            g[a].append(b)\n            g[b].append(a)\n        return all(c or dfs(i, 1) for i, c in enumerate(color))\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1629106296","body":"```\n抄答案没抄懂\nclass Solution:\n    def topological_sort(self,items,indegree,neighbors):\n        # 建立队列和访问顺序\n        queue = collections.deque()\n        res = []\n        \n        # 初始化队列\n        for item in items:\n            if not indegree[item]:\n                queue.append(item)\n                \n        if not queue: return []\n        \n        # BFS\n        while queue:\n            cur = queue.popleft()\n            res.append(cur)\n            \n            # 遍历邻居节点\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    queue.append(neighbor)\n                    \n        return res\n    \n    \n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for task in range(n):\n            if group[task] == -1:\n                group[task] = max_group_id\n                max_group_id += 1\n                \n        task_indegree = [0] * n    \n        group_indegree = [0] * max_group_id\n        task_neighbors = [[] for _ in range(n)]\n        group_neighbors = [[] for _ in range(max_group_id)]\n        group_to_tasks = [[] for _ in range(max_group_id)]\n        \n        for task in range(n):\n            group_to_tasks[group[task]].append(task)\n            \n            for prerequisite in beforeItems[task]:\n                \n                # 判断相关联的两个项目是否属于同一组\n                if group[prerequisite] != group[task]:\n                    \n                    # 不是同组，给小组建图\n                    group_indegree[group[task]] += 1\n                    group_neighbors[group[prerequisite]].append(group[task])\n                else:\n                    # 同组，给组内项目建图\n                    task_indegree[task] += 1\n                    task_neighbors[prerequisite].append(task)\n                    \n\n        res = []\n        \n        # 得到小组的访问顺序\n        group_queue = self.topological_sort([i for i in range(max_group_id)],group_indegree,group_neighbors)\n\n        if len(group_queue) != max_group_id: return []\n        \n        for group_id in group_queue:\n            # 得到每组项目的访问顺序\n            task_queue = self.topological_sort(group_to_tasks[group_id],task_indegree,task_neighbors)\n\n            if len(task_queue) != len(group_to_tasks[group_id]):\n                return []\n            res += task_queue\n                    \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1632790125","body":"```\r\nclass Solution:\r\n    def judgeCircle(self, moves: str) -> bool:\r\n        res = collections.Counter(moves)\r\n        return res.get(\"U\",0) == res.get(\"D\",0) and res.get(\"R\",0) == res.get(\"L\",0)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1632067779","body":"```\n# 解题思路\n# 任务按(开始时间，时长，下标)排序。\n# 如果当前队列没有任务，从任务表中弹出任务，更新时间。\n# 根据最新时间将 待选可执行的任务 压入队列中。\n# 如果当前队列有任务: 执行任务，更新时间；\n\n\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        n = len(tasks)\n        tasks = [(tasks[i][0], tasks[i][1], i) for i in range(n)]\n        tasks.sort()\n        ans = []\n        h = [] # 待执行列表\n        timestamp = 0 # 时间戳\n        ptr = 0 # 待加入待执行列表的最大序号\n        for i in range(n):\n            if not h:\n                timestamp = max(timestamp, tasks[ptr][0])\n            while ptr < n and tasks[ptr][0] <= timestamp:\n                heappush(h, (tasks[ptr][1], tasks[ptr][2]))\n                ptr += 1\n            top = heappop(h)\n            timestamp += top[0]\n            ans.append(top[1])\n\n        return ans\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1634462525","body":"```\n# 转换单位为分钟\n# 开始小于结束，跨天，+24h处理\n# 转换为单位为15分钟\n# 1 整点才开始， 故向上取整\n# 2 整点完成才算完成，故向下取整\n# 返回求差值\n\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        m1,m2 = self.toMinutes(loginTime), self.toMinutes(logoutTime)\n        if m1 > m2:\n            m2 += 24 * 60\n        ans = math.floor(m2 / 15) - math.ceil(m1 / 15)\n        if ans < 0:\n            ans = 0 \n        return ans\n\n\n    def toMinutes(self,time):\n        h, m = time.split(':')\n        return int(h) * 60 + int(m)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635971670","body":"```\n# 1、事先算好a和b里每个字母的counter \n# 2、如果要a的所有字母都变成小于“c”，b的所有字母都变成大于“c”，因为已经有counter了所以O(1)时间就能算出。 这样对26个字母过一遍选最小的就是“操作1”的解。 \n#同理可得操作2和操作3的解。\n\n\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        counter1,counter2=[0]*26,[0]*26\n        for c in a: counter1[ord(c)-ord('a')]+=1\n        for c in b: counter2[ord(c)-ord('a')]+=1\n        way1=min(sum(counter1[i:])+sum(counter2[:i]) for i in range(1,26))\n        way2=min(sum(counter2[i:])+sum(counter1[:i]) for i in range(1,26))\n        way3=min(len(a)+len(b)-counter1[i]-counter2[i] for i in range(26))\n        return min(way1,way2,way3)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1636793074","body":"```\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n\n        def maxHepify(arr, i, end):     # 大顶堆\n            j = 2*i + 1                 # j为i的左子节点【建堆时下标0表示堆顶】\n            while j <= end:             # 自上而下进行调整\n                if j+1 <= end and arr[j+1] > arr[j]:    # i的左右子节点分别为j和j+1\n                    j += 1                              # 取两者之间的较大者\n                \n                if arr[i] < arr[j]:             # 若i指示的元素小于其子节点中的较大者\n                    arr[i], arr[j] = arr[j], arr[i]     # 交换i和j的元素，并继续往下判断\n                    i = j                       # 往下走：i调整为其子节点j\n                    j = 2*i + 1                 # j调整为i的左子节点\n                else:                           # 否则，结束调整\n                    break\n        \n\n        n = len(nums)\n        \n        # 建堆【大顶堆】\n        for i in range(n//2-1, -1, -1):         # 从第一个非叶子节点n//2-1开始依次往上进行建堆的调整\n            maxHepify(nums, i, n-1)\n\n        # 排序：依次将堆顶元素（当前最大值）放置到尾部，并调整堆\n        for j in range(n-1, -1, -1):\n            nums[0], nums[j] = nums[j], nums[0]     # 堆顶元素（当前最大值）放置到尾部j\n            maxHepify(nums, 0, j-1)                 # j-1变成尾部，并从堆顶0开始调整堆\n        \n        return nums\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637118036","body":"```\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x <= 1:\n            return x\n        low, high = 1, x\n        while low <= high:\n            mid = low + (high - low) // 2\n            if mid < x / mid:\n                low = mid + 1\n            elif mid > x / mid:\n                high = mid - 1\n            else:\n                return mid\n        return high\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637594551","body":"```\n# The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -> bool:\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n\n        l, r = 1, n\n\n        while l < r:\n            mid = l + (r-l) // 2\n            if isBadVersion(mid):\n                r = mid\n            else:\n                l = mid + 1\n            \n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1640257808","body":"```\n# 抄答案\n# 反向思考：对于 nums 中的每一项 num，我们找前面出现过的大于 num * 2 的数。\n# 构造有序序列 d，然后在 d 上做二分。\n# 构建 d ：将 nums 中已经遍历过的数字全部放到 d 中即可。\nclass Solution:\n    def reversePairs(self, A):\n        d = []\n        ans = 0\n\n        for a in A:\n            i = bisect.bisect_right(d, a * 2)\n            ans += len(d) - i\n            bisect.insort(d, a)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/42#issuecomment-1642313939","body":"```\nclass Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n\n        \"\"\"存放每个房屋与加热器的最短距离\"\"\"\n        res = []\n        heaters.sort()\n        for c in houses:\n            \"\"\"二分查找\"\"\"\n            left = 0\n            right = len(heaters) - 1\n            while left < right:\n                mid = (left + right) >> 1\n                if heaters[mid] < c:\n                    left = mid + 1\n                else:\n                    right = mid\n            \"\"\"得出的 left 所指的加热器并不一定是离房屋 c 最近的一个，需要判断以下情况\"\"\"\n            if heaters[left] == c:\n                \"\"\"若找到的值等于 c ，则说明 c 房屋处放有一个加热器，c 房屋到加热器的最短距离为 0\"\"\"\n                res.append(0)\n\n            elif heaters[left] < c:\n                \"\"\"若该加热器的坐标值小于 c ，说明该加热器的坐标与 c 之间没有别的加热器\"\"\"\n                res.append(c - heaters[left])\n\n            elif left == 0:\n                \"\"\"\n                若left == 0 即二分查找的结果指向第一个加热器的坐标,说明 heaters[left] 坐标的房屋之前的位置\n                未放置加热器,直接相减就是到房屋 c 最近加热器的距离\n                \"\"\"\n                res.append(heaters[left] - c)\n                \n            else:\n                \"\"\"\n                若left不等于 0 ，说明 c 介于left和left-1之间，房屋到加热器的最短距离就是left和left - 1处\n                加热器与 c 差值的最小值.\n                \"\"\"\n                res.append(min(heaters[left] - c, c - heaters[left - 1]))\n                \n        return max(res)\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1644166342","body":"```\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        def get_count(dis):\n            cnt = l = 0\n            for r in range(len(nums)):\n                while nums[r] - nums[l] > dis:\n                    l += 1\n                cnt += r - l\n            return cnt\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left <= right:\n            mid = (left + right) // 2\n            if get_count(mid) < k:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/44#issuecomment-1657802146","body":"```\r\nclass Solution:\r\n    def swimInWater(self, grid: List[List[int]]) -> int:\r\n        res = 0\r\n        n = len(grid)\r\n        heap = [(grid[0][0],0,0)]\r\n        visited = set([(0,0)])\r\n        # 每次弹出堆顶（最小值），这个时候水流到这个位置，并引入它的相邻点进堆，\r\n        # 找下一个水能流到的位置，然后继续在堆中找最小值，这个时候水又流到了更新后的最小值所在位置的坐标\r\n        while heap:\r\n            height,x,y = heapq.heappop(heap)\r\n            res = max(res,height)\r\n            if x == n-1 and y == n-1:\r\n                return res\r\n            \r\n            for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)]:\r\n                new_x,new_y = x + dx,y + dy\r\n                if 0 <= new_x < n and 0 <= new_y < n and (new_x,new_y) not in visited:\r\n                    visited.add((new_x,new_y))\r\n                    heapq.heappush(heap,(grid[new_x][new_y],new_x,new_y))\r\n        \r\n        return -1\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/45#issuecomment-1646613191","body":"```\n# 先遍历前k个字符，记录元音字母个数cnt，并初始化返回值res = cnt\n# 继续遍历索引k开始的字符，如果索引i - k处（也就是滑动窗口外）的字符也是元音字符，cnt - 1\n# 如果当前字符为元音字符，cnt + 1，并且更新res\n\n\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        vowels = {'a', 'e', 'i', 'o', 'u'}\n        cnt = 0\n        for i in range(k):\n            if s[i] in vowels:\n                cnt += 1\n        res = cnt\n\n        for i in range(k, len(s)):\n            if s[i - k] in vowels:\n                cnt -= 1\n            if s[i] in vowels:\n                cnt += 1\n                res = max(res, cnt)\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/46#issuecomment-1646868594","body":"```\nclass Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        dp=[None]*(K+W)\n        s=0\n        for i in range(K,K+W):          # 填蓝色的格子\n            dp[i] = 1 if i<=N else 0\n            s+=dp[i]\n        for i in range(K-1,-1,-1):      # 填橘黄色格子\n            dp[i]=s/W\n            s=s-dp[i+W]+dp[i]\n        return dp[0]\n\n# https://leetcode.cn/problems/new-21-game/solutions/273085/huan-you-bi-zhe-geng-jian-dan-de-ti-jie-ma-tian-ge/\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/47#issuecomment-1648053429","body":"```\nfrom typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def findAnagrams(self,s: str, t: str) -> List[int]:\n        need, window = defaultdict(int), defaultdict(int)\n        for c in t:\n            need[c] += 1\n\n        left, right = 0, 0\n        valid = 0\n        res = []\n        while right < len(s):\n            c = s[right]\n            right += 1\n            # 进行窗口内数据的一系列更新\n            if c in need:\n                window[c] += 1\n                if window[c] == need[c]:\n                    valid += 1\n            # 判断左侧窗口是否要收缩\n            while right - left >= len(t):\n                # 当窗口符合条件时，把起始索引加入 res\n                if valid == len(need):\n                    res.append(left)\n                d = s[left]\n                left += 1\n                # 进行窗口内数据的一系列更新\n                if d in need:\n                    if window[d] == need[d]:\n                        valid -= 1\n                    window[d] -= 1\n\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/48#issuecomment-1650063162","body":"```\nfrom collections import defaultdict\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n\n        need, window = defaultdict(int), defaultdict(int)\n        for c in t:\n            need[c] += 1\n\n        left, right = 0, 0\n        valid = 0\n        # 记录最小覆盖子串的起始索引及长度\n        start, length = 0, float('inf')\n        while right < len(s):\n            # c 是将移入窗口的字符\n            c = s[right]\n            # 扩大窗口\n            right += 1\n            # 进行窗口内数据的一系列更新\n            if c in need:\n                window[c] += 1\n                if window[c] == need[c]:\n                    valid += 1\n\n            # 判断左侧窗口是否要收缩\n            while valid == len(need):\n                # 在这里更新最小覆盖子串\n                if right - left < length:\n                    start = left\n                    length = right - left\n\n                # d 是将移出窗口的字符\n                d = s[left]\n                # 缩小窗口\n                left += 1\n                # 进行窗口内数据的一系列更新\n                if d in need:\n                    if window[d] == need[d]:\n                        valid -= 1\n                    window[d] -= 1\n\n        # 返回最小覆盖子串\n        return \"\" if length == float('inf') else s[start:start + length]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/49#issuecomment-1652023224","body":"```\n抄别人的巧妙转换后的题解\n\nclass Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        if len(cardPoints) == k: \n            return sum(cardPoints)\n        # 逆向思维，按题中意思取左取右的最大值，反过来就是求中间连续子数组的和最小\n        # 由于要取 k 张牌，所以反过来就是在中间找连续的长度为 len(carPoints)-k 的子数组使其和最小，这以部分就是滑动窗口\n        res_opposite = sum(cardPoints[:len(cardPoints) - k])  # 变量存储滑窗的最小值，这里先按初始位置赋初值\n        current_sum = res_opposite  # current_sum记录当前滑窗总和\n        left_idx, right_idx = 0, len(cardPoints) - k - 1  # 设定滑窗边界\n        for _ in range(k):  # 滑窗将移动 k 次\n            left_idx += 1  # 更新滑窗左右边界\n            right_idx += 1\n            # 计算新位置滑窗内值的总和，减去滑窗原来的左边界，加上滑窗新的右边界\n            current_sum = current_sum - cardPoints[left_idx - 1] + cardPoints[right_idx]  \n            res_opposite = min(res_opposite, current_sum)  # 更新最小的滑窗范围内的和\n        return sum(cardPoints) - res_opposite\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/50#issuecomment-1653547982","body":"```\n'''\n总体思路\n在10个灯中选num个灯点亮，如果选择的灯所组成的时间已不合理（小时超过11，分钟超过59）就进行剪枝\n也就是从0到10先选一个灯亮，再选当前灯的后面的灯亮，再选后面的灯的后面的灯亮，一直到num个灯点满\n\n具体思路\n为了方便计算，分别设置了小时数组和分钟数组\n递归的四个参数分别代表：剩余需要点亮的灯数量，从索引index开始往后点亮灯，当前小时数，当前分钟数\n每次进入递归后，先判断当前小时数和分钟数是否符合要求，不符合直接return\nfor循环枚举点亮灯的情况，从index枚举到10，每次枚举，\n减少一个需要点亮的灯数量num - 1\n从当前已点亮的灯后面选取下一个要点亮的灯 i + 1\n在hour中增加当前点亮灯的小时数，如果i大于3，当前灯是分钟灯而不是小时灯，则加上0个小时\n在minute中增加当前点亮灯的分钟数，如果i没有大于3，当前灯是小时灯而不是分钟灯，则加上0分钟\n当剩余需要点亮的灯数量为0的时候，已枚举完一种情况，根据题目要求的格式加到res列表中\n返回res\n\n'''\nclass Solution:\n    def readBinaryWatch(self, num: int) -> List[str]:\n        hours = [1, 2, 4, 8, 0, 0, 0, 0, 0, 0]\n        minutes = [0, 0, 0, 0, 1, 2, 4, 8, 16, 32]\n        res = []\n        def backtrack(num, index, hour, minute):\n            if hour > 11 or minute > 59:\n                return\n            if num == 0:\n                res.append('%d:%02d' % (hour, minute))\n                return\n            for i in range(index, 10):\n                backtrack(num - 1, i + 1, hour + hours[i], minute + minutes[i])\n        \n        backtrack(num, 0, 0, 0)\n        return res\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/51#issuecomment-1655678235","body":"```\nclass Solution:\n    def __init__(self):\n        self.res = []\n\n    def totalNQueens(self, n: int) -> List[List[str]]:\n        board = [[\".\"] * n for _ in range(n)]\n        self.backtrack(board, 0)\n        return len(self.res)\n\n    def backtrack(self, board: List[List[str]], row: int) -> None:\n        if row == len(board):\n            self.res.append(1)\n            return\n      \n        n = len(board[row])\n        for col in range(n):\n            if not self.isValid(board, row, col):\n                continue\n            \n            board[row][col] = \"Q\"\n            self.backtrack(board, row + 1)\n            board[row][col] = \".\"\n\n    def isValid(self, board: List[List[str]], row: int, col: int) -> bool:\n        n = len(board)\n        # 检查列是否有皇后冲突\n        for i in range(n):\n            if board[i][col] == \"Q\":\n                return False\n        \n        # 检查右上方是否有皇后冲突\n        r, c = row - 1, col + 1\n        while r >= 0 and c < n:\n            if board[r][c] == \"Q\":\n                return False\n            r -= 1\n            c += 1\n    \n        # 检查左上方是否有皇后冲突\n        r, c = row - 1, col - 1\n        while r >= 0 and c >= 0:\n            if board[r][c] == \"Q\":\n                return False\n            r -= 1\n            c -= 1\n        \n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/52#issuecomment-1656693174","body":"```\n# 遍历二维数组，对于每块土地，去其前后左右找相邻土地，再去前后左右的土地找其前后左右的土地，直到周围没有土地\n# 对于每一块已找过的土地，为避免重复计算，将其置为0\n# 遍历所有的岛屿，然后取这些岛屿的最大面积res = max(res, dfs(i, j))\n\n\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        def dfs(i, j):\n            if 0 <= i < m and 0 <= j < n and grid[i][j]:\n                grid[i][j] = 0\n                return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1)\n            return 0\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    res = max(res, dfs(i, j))\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/53#issuecomment-1657931873","body":"```\r\n# 总体思路：\r\n\r\n# 从陆地开始去向海洋扩张会更方便，而不是从海洋去找陆地\r\n# 每次所有的陆地都向周围扩张一圈，把周围一圈的海洋变成陆地，并且距离 + 1，只要周围还有海洋就继续扩张\r\n\r\n# 具体思路\r\n\r\n# 把所有陆地格子入队\r\n# 处理只有陆地或者海洋的特殊情况，返回-1。\r\n# 遍历所有陆地节点的周围格子，若是海洋格子则入队，且距离distance + 1\r\n# 已遍历到的海洋格子置为1，避免重复计算\r\n# 继续遍历已在队列中的格子的周围格子，直到没有海洋格子为止，此时队列为空，循环结束，返回 distance\r\n\r\n\r\nclass Solution:\r\n    def maxDistance(self, grid: List[List[int]]) -> int:\r\n        # from collections import deque\r\n        N = len(grid)\r\n        distance = -1\r\n        q = deque([(i, j) for i in range(N) for j in range(N) if grid[i][j] == 1])\r\n        if len(q) == 0 or len(q) == N ** 2:\r\n            return distance\r\n        move = [(-1, 0), (1, 0), (0, -1), (0, 1)]\r\n        while len(q) > 0:\r\n            for _ in range(len(q)):\r\n                x, y = q.popleft()\r\n                for dx, dy in move:\r\n                    nx, ny = x + dx, y + dy\r\n                    if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] == 0:\r\n                        q.append((nx, ny))\r\n                        grid[nx][ny] = -1\r\n            distance += 1\r\n\r\n        return distance\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/54#issuecomment-1658157132","body":"```\n# 遇到盒子：\n#     1、将盒子放到盒子集合boxes\n#     2、将盒子集合中没有上锁的盒子入队列q。\n# 遇到钥匙：\n#     1、如果对应的盒子之前就已经在盒子集合中且之前没有解锁，则加入队列q\n#     2、将对应的盒子解锁（修改 status 数组）\nclass Solution:\n    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        boxes = set(initialBoxes)\n        q = [i for i in boxes if status[i]]\n        for i in q:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    q.append(j)\n            for j in keys[i]:\n                if status[j] == 0 and j in boxes:\n                    q.append(j)\n                status[j] = 1\n\n        return sum(candies[i] for i in q)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/55#issuecomment-1659626627","body":"```\n#记录每一个列出现的所有数字(带行数)，按列排序，按行排序，按值排序即可。\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        hashmap = defaultdict(list)\n        def dfs(node, x, y):\n            if not node:\n                return\n            hashmap[y].append((x,node.val))\n            dfs(node.left, x+1, y-1)\n            dfs(node.right,x+1, y+1)\n        \n        dfs(root, 0, 0)\n        return [list(zip(*sorted(hashmap[i])))[1] for i in sorted(hashmap.keys())]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/56#issuecomment-1662459693","body":"```\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        n = len(cost)\n        minCost = [0] * n\n        minCost[1] = min(cost[0], cost[1])\n        for i in range(2, n):\n            minCost[i] = min(minCost[i - 1] + cost[i], minCost[i - 2] + cost[i - 1])\n        return minCost[-1]\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/57#issuecomment-1663784036","body":"```\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n\n        # 子问题：\n        # f(k) = 偷 [0..k) 房间中的最大金额\n\n        # f(0) = 0\n        # f(1) = nums[0]\n        # f(k) = max{ rob(k-1), nums[k-1] + rob(k-2) }\n\n        N = len(nums)\n        dp = [0] * (N+1)\n        dp[0] = 0\n        dp[1] = nums[0]\n        for k in range(2, N+1):\n            dp[k] = max(dp[k-1], nums[k-1] + dp[k-2])\n        return dp[N]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/58#issuecomment-1665843365","body":"```\nclass Solution(object):\n    def findNumberOfLIS(self, nums):\n        import bisect\n        dp = []\n        tree = collections.defaultdict(list)\n        for i in nums:\n            idx = bisect.bisect_left(dp,i)\n            if idx == len(dp):\n                dp.append(i)\n            else:\n                dp[idx] = i\n            total = 0\n            for counter, last_num in tree[idx]:\n                if last_num < i:\n                    total += counter\n            tree[idx+1].append((max(1,total), i))\n        return sum(i[0] for i in tree[len(tree)-1])\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/59#issuecomment-1666531527","body":"```\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        M, N = len(text1), len(text2)\n        dp = [[0] * (N + 1) for _ in range(M + 1)]\n        for i in range(1, M + 1):\n            for j in range(1, N + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[M][N]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/60#issuecomment-1666852390","body":"```\n# 思路\n# 1.定义状态：不同路径的数量 dp[i][j]含义：到位置(i, j)一共有几条路径 \n# 2.初始化状态：初始化第一行和第一列，均为1 \n# 3.状态转移：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1] * n] + [[1] + [0] * (n - 1)] * (m - 1)\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/61#issuecomment-1667831735","body":"```\n# 思路\n# 1、定义状态：“马” 仍留在棋盘上的概率 dp[i][j]： 位置(i, j)有马的概率\n# 2、初始化状态：dp[r][c] = 1\n# 3、状态转移使用两个dp仓库，cur记录当前概率，nxt记录移动一次以后的概率 nxt[x][y] += cur[i][j] / 8 其中，(x, y) 是移动后位置， (i, j) 是移动前位置表示 (i, j) 有 1/8 的概率移动到 (x, y)\n# 4、返回当前所有位置的概率和\n\n\nclass Solution:\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\n        cur = [[0] * N for _ in range(N)]\n        cur[r][c] = 1\n        for _ in range(K):\n            nxt = [[0] * N for _ in range(N)]\n            for i in range(N):\n                for j in range(N):\n                    for x, y in ((i + 2, j + 1), (i + 2, j - 1), (i - 2, j + 1), (i - 2, j - 1), \n                                (i + 1, j + 2), (i - 1, j + 2), (i + 1, j - 2), (i - 1, j - 2)):\n                        if 0 <= x < N and 0 <= y < N:\n                            nxt[x][y] += cur[i][j] / 8\n            cur = nxt\n        return sum(map(sum, cur))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/62#issuecomment-1669864355","body":"```\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        # 剪枝1：如果 所有数加起来 不足，那么谁都不可能赢\n        if (maxChoosableInteger + 1) * maxChoosableInteger / 2 < desiredTotal:\n            return False\n        # 剪枝2：先手直接选 maxChoosableInteger稳赢\n        if maxChoosableInteger >= desiredTotal:\n            return True\n        \n        @cache # 记忆搜索，算过的状态直接用结果，不用再重复算\n        def dfs(cur, state): # cur：当前和，state位运算用来表示 数字们的使用状态\n            for i in range(1, maxChoosableInteger + 1): # 遍历 1 到 maxChoosableInteger 位置，找能让我赢的 数字 i\n                if not (1 << i) & state: # 如果 state中 i 位置是0，数字 i 没有被使用，那么接下来就用数字 i\n                    if cur + i >= desiredTotal or not dfs(cur + i, state | (1 << i)): # 两种赢，要么我到目的了，要么你在后面的回合不可能赢，注意 当前和 + i，以及 数字i 被使用了\n                        return True\n            return False\n        return dfs(0,0) # 初始状态，当前和为0，所有数字都没有被使用\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/63#issuecomment-1671226139","body":"```\n# 思路\n# 01背包问题------能不能装满容量为target的背包\n\n# 本题要求把数组分成两个等和的子集，相当于找到一个子集，其和为sum/2，这个sum/2就是target\n\n# 具体步骤如下：\n# 特例：如果sum为奇数，那一定找不到符合要求的子集，返回False。\n\n# dp[j]含义：有没有和为j的子集，有为True，没有为False。\n\n# 初始化dp数组：长度为target + 1，用于存储子集的和从0到target是否可能取到的情况。 比如和为0一定可以取到（也就是子集为空），那么dp[0] = True。\n\n# 接下来开始遍历nums数组，对遍历到的数nums[i]有两种操作，一个是选择这个数，一个是不选择这个数。 \n# －--不选择这个数：dp不变 \n# --－选择这个数：dp中已为True的情况再加上nums[i]也为True。比如dp[0]已经为True，那么dp[0 + nums[i]]也是True\n\n# 在做出选择之前，我们先逆序遍历子集的和从nums[i]到target的所有情况，判断当前数加入后，dp数组中哪些和的情况可以从False变成True。 \n# （为什么要逆序，是因为dp后面的和的情况是从前面的情况转移过来的，如果前面的情况因为当前nums[i]的加入变为了True，比如dp[0 + nums[i]]变成了True，那么因为一个数只能用一次，dp[0 + nums[i] + nums[i]]不可以从dp[0 + nums[i]]转移过来。如果非要正序遍历，必须要多一个数组用于存储之前的情况。而逆序遍历可以省掉这个数组）\n\n# dp[j] = dp[j] or dp[j - nums[i]]\n# 这行代码的意思是说，如果不选择当前数，那么和为j的情况保持不变，dp[j]仍然是dp[j]，原来是True就还是True，原来是False也还是False；\n# 如果选择当前数，那么如果j - nums[i]这种情况是True的话和为j的情况也会是True。比如和为0一定为True，只要 j - nums[i] == 0，那么dp[j]就变成了True。\n# dp[j]和dp[j-nums[i]]只要有一个为True，dp[j]就变成True，因此用or连接两者。\n# 最后就看dp[-1]是不是True，也就是dp[target]是不是True\n\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        sumAll = sum(nums)\n        if sumAll % 2:\n            return False\n        target = sumAll // 2\n\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for i in range(len(nums)):\n            for j in range(target, nums[i] - 1, -1):\n                dp[j] = dp[j] or dp[j - nums[i]]\n        return dp[-1]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/64#issuecomment-1673483332","body":"```\n# 思路\n# 01背包问题是选或者不选，但本题是必须选，是选+还是选-。先将本问题转换为01背包问题。 假设所有符号为+的元素和为x，符号为-的元素和的绝对值是y。 我们想要的 S = 正数和 - 负数和 = x - y 而已知x与y的和是数组总和：x + y = sum 可以求出 x = (S + sum) / 2 = target 也就是我们要从nums数组里选出几个数，令其和为target 于是就转化成了求容量为target的01背包问题 =>要装满容量为target的背包，有几种方案\n# 特例判断 如果S大于sum，不可能实现，返回0 如果x不是整数，也就是S + sum不是偶数，不可能实现，返回0\n# dp[j]代表的意义：填满容量为j的背包，有dp[j]种方法。因为填满容量为0的背包有且只有一种方法，所以dp[0] = 1\n# 状态转移：dp[j] = dp[j] + dp[j - num]， 当前填满容量为j的包的方法数 = 之前填满容量为j的包的方法数 + 之前填满容量为j - num的包的方法数 也就是当前数num的加入，可以把之前和为j - num的方法数加入进来。\n# 返回dp[-1]，也就是dp[target]\n\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\n        sumAll = sum(nums)\n        if S > sumAll or (S + sumAll) % 2:\n            return 0\n        target = (S + sumAll) // 2\n        if target < 0:\n            return 0\n\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = dp[j] + dp[j - num]\n        return dp[-1]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/65#issuecomment-1674895604","body":"```\n    def coinChange(self,coins: List[int], amount: int) -> int:\n        self.dp = [amount + 1] * (amount + 1)\n        # 数组大小为 amount+1，初始值也为 amount+1\n        self.dp[0] = 0\n        # base case\n        # 初始值为0\n        # 外层 for 循环在遍历所有状态的所有取值\n        for i in range(len(self.dp)):\n            # 内层 for 循环在求所有选择的最小值\n            for coin in coins:\n                # 子问题无解，跳过\n                if i - coin < 0:\n                    continue\n                self.dp[i] = min(self.dp[i], 1 + self.dp[i - coin]) \n                \n        # 如果结果是初始值，则表示没有找到解。\n        return -1 if self.dp[amount] == amount + 1 else self.dp[amount]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/66#issuecomment-1675972671","body":"```\n抄答案\n\n# dp[j] 代表装满容量为j的背包有几个硬币组合\n# 移位方程：dp[j] = dp[j] + dp[j - coin] 当前填满j容量的硬币组合数 = 之前填满j容量的硬币组合数 + 填满j - coin容量的硬币组合数和当前硬币硬币的加入，可以把j -硬币容量的组合数字加入输入 和01背包差不多，唯一的不同点在于硬币可以重复使用，一个逆序一个正序的区别\n# 返回dp[-1]，原来dp[金额]\n\n\n\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [1] + [0] * amount\n        for coin in coins:\n            for j in range(coin, amount + 1):\n                dp[j] += dp[j - coin]\n        return dp[-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/67#issuecomment-1676355387","body":"```\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        # 将胃口和饼干排序\n        g.sort()\n        s.sort()\n        \n        n = len(g) # 孩子的数量\n        m = len(s)  # 饼干的数量\n        \n        res = 0   # 记录结果\n        for i in range(m):\n            # 从胃口小的开始喂\n            if res < n and g[res] <= s[i]:\n                res += 1\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/68#issuecomment-1677540350","body":"```\n# 贪心思想：先留下右边界最小的区间，再去除重复区间\n\n# 根据区间右边界升序排列；\n# 维护right，代表已留下区间的最大右边界；\n# 遍历排序后的区间：\n# 如果当前区间的左边界 ≥ right，该区间可以留下，更新right\n# 如果当前区间的左边界 < right，该区间去除，更新结果res\n\n\nclass Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        if not intervals:\n            return 0\n        intervals.sort(key = lambda x : x[1])\n        res = 0\n        right = intervals[0][1]\n        for i in range(1, len(intervals)):\n            if intervals[i][0] < right:\n                res += 1\n            else:\n                right = intervals[i][1]\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/69#issuecomment-1679171116","body":"```\n# 初始化最远位置为0，然后遍历队列，如果当前位置能到达，并且当前位置+跳数>最远位置，就更新最远位置。最后比较最远位置和队列长度。\nclass Solution:\n    def canJump(self, nums) :\n        max_i = 0       #初始化当前能到达最远的位置\n        for i, jump in enumerate(nums):   #i为当前位置，jump是当前位置的跳数\n            if max_i>=i and i+jump>max_i:  #如果当前位置能到达，并且当前位置+跳数>最远位置  \n                max_i = i+jump  #更新最远能到达位置\n        return max_i>=i\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/70#issuecomment-1680572649","body":"```\n# 思路\n# 注意是二叉排序树，因此 如果选择 i 为根节点，那么左子树共有 i - 1 个节点，右子树共有 n - i 个节点\n\n# 1、dp[i]含义：i 个节点组成的二叉搜索树数量\n# 2、当只有0个节点时，此时只有空树这一种二叉树，dp[0]=1\n# 3、需要通过状态转移求得 dp[n]，分别选择1, 2, …, n为根节点，每种根节点对应的二叉树数量为其左子树数量乘以右子树数量\n#     dp[n]=dp[0]∗dp[n−1]+dp[1]∗dp[n−2]+…+dp[n−1]∗dp[0]\n# 4、因此需要两层循环计算 dp[n]，外层循环遍历节点个数从1到n的所有情况，内层循环计算每种根节点对应的二叉树数量并求和。转移方程如下：\n# dp[i]+=dp[j]∗dp[i−j−1]\n# 5、最后返回dp[−1]，即dp[n]\n\n\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [1] + [0] * n\n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1]\n        return dp[-1]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/71#issuecomment-1682473124","body":"```\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        def mergeTwoLists(l1, l2):\n            dummy = ListNode()\n            current = dummy\n\n            while l1 and l2:\n                if l1.val < l2.val:\n                    current.next = l1\n                    l1 = l1.next\n                else:\n                    current.next = l2\n                    l2 = l2.next\n                current = current.next\n\n            if l1:\n                current.next = l1\n            if l2:\n                current.next = l2\n\n            return dummy.next\n\n        def mergeSortLists(lists, left, right):\n            if left == right:\n                return lists[left]\n            mid = left + (right - left) // 2\n            left_list = mergeSortLists(lists, left, mid)\n            right_list = mergeSortLists(lists, mid + 1, right)\n            return mergeTwoLists(left_list, right_list)\n\n        if not lists:\n            return None\n\n        return mergeSortLists(lists, 0, len(lists) - 1)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/72#issuecomment-1683912150","body":"```\n抄作业\n# 将问题分解为子问题并进行递归求解。\n# 具体来说，dp(n) 函数返回一个漂亮数组，长度为 n。它首先处理基本情况 n == 1，返回一个只包含元素 1 的数组。然后，通过递归调用 dp(n - n // 2) 和 dp(n // 2)，分别生成奇数部分和偶数部分，并将它们组合起来形成漂亮数组。\n\n# 由于使用了缓存装饰器 @lru_cache(None)，已经计算过的 dp(n) 将会被缓存，避免重复计算，从而提高性能。\n\n# 最终，return dp(N) 返回了长度为 N 的漂亮数组。\n\nclass Solution:\n    def beautifulArray(self, N: int) -> List[int]:\n        @lru_cache(None)  # 使用缓存来加速计算\n        def dp(n):\n            if n == 1:\n                return [1]  # 基本情况，返回单个元素的数组\n            ans = []\n            # 生成奇数部分\n            for a in dp(n - n // 2):\n                ans += [a * 2 - 1]\n            # 生成偶数部分\n            for b in dp(n // 2):\n                ans += [b * 2]\n            return ans\n\n        return dp(N)\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/73#issuecomment-1684832955","body":"```\n# 抄答案，\n\n# 将 nums 中所有数异或起来得到数 x，x 必定不为 0，因为相同的两个数都约掉了，相当于那两个只出现了一次的数进行 xor。\n\n# 随便找一个 x 的 bit 为 1 的位置，为 1 就代表这两个出现一次的数在该位置的 bit 不同。\n\n# 这样就可以根据这个为 1 的 bit 位来将原问题分解为两个子问题，子问题的定义是：给定一个数组，该数组只有一个数出现一次，其他数都出现两次。\n\n# 这样就转换为基本的找出只出现一次数的问题了，直接将这个数组所有元素 xor 起来得到的就是答案。\n\n# 为方便求解，本题使用的是低位最早出现 1 的位置。\n\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xor = a = b = 0\n        right_bit = 1\n        length = len(nums)\n        for i in nums:\n            xor ^= i\n        while right_bit & xor == 0:\n            right_bit <<= 1\n        for i in nums:\n            if right_bit & i:\n                a ^= i\n            else:\n                b ^= i\n        return [a, b]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/74#issuecomment-1685218740","body":"```\nclass Solution:\n    \n    def __init__(self):\n        self.res = []\n        # 记录回溯算法的递归路径\n        self.track = []\n\n    # 主函数\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        self.backtrack(nums, 0)\n        return self.res\n    \n    # 回溯算法核心函数，遍历子集问题的回溯树\n    def backtrack(self, nums: List[int], start: int) -> None:\n        \n        # 前序位置，每个节点的值都是一个子集\n        self.res.append(self.track[:])\n        \n        # 回溯算法标准框架\n        for i in range(start, len(nums)):\n            # 做选择\n            self.track.append(nums[i])\n            # 通过 start 参数控制树枝的遍历，避免产生重复的子集\n            self.backtrack(nums, i + 1)\n            # 撤销选择\n            self.track.pop()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/75#issuecomment-1686571897","body":"```\nclass Node(object):\n    def __init__(self):\n        self.children = collections.defaultdict(Node)\n        self.isword = False\n        \nclass Trie(object):\n\n    def __init__(self):\n        self.root = Node()\n\n    def insert(self, word):\n        current = self.root\n        for w in word:\n            current = current.children[w]\n        current.isword = True\n\n    def search(self, word):\n        current = self.root\n        for w in word:\n            current = current.children.get(w)\n            if current == None:\n                return False\n        return current.isword\n\n    def startsWith(self, prefix):\n        current = self.root\n        for w in prefix:\n            current = current.children.get(w)\n            if current == None:\n                return False\n        return True\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/76#issuecomment-1688400727","body":"```\nclass MapSum:\n\n    def __init__(self):\n        self.m = {}\n    def insert(self, key, val):\n        self.m[key] = val\n\n    def sum(self, prefix):\n        count = 0\n        for key in self.m:\n            if key.startswith(prefix):\n                count += self.m[key]\n        return count\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/77#issuecomment-1690197030","body":"```\n# 思路\n# trie中记录smalls中的字符串，末尾记录字符串，方便后面遍历。\n# trie中的search用于搜索字符串，将搜索到的字符串存入返回值中。\n# 遍历big长字符串，将其与trie匹配。\n# 按smalls顺序输出最终结果\n\nclass Trie:\n    def __init__(self, words):\n        self.d = {}\n        for word in words:\n            t = self.d\n            for w in word:\n                if w not in t:\n                    t[w] = {}\n                t = t[w]\n            t['end'] = word\n    \n    def search(self, s):\n        t = self.d\n        res = []\n        for w in s:\n            if w not in t:\n                break\n            t = t[w]\n            if 'end' in t:\n                res.append(t['end'])\n        return res\n\nclass Solution:\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\n        trie = Trie(smalls)\n        hit = collections.defaultdict(list)\n\n        for i in range(len(big)):\n            matchs = trie.search(big[i:])\n            for word in matchs:\n                hit[word].append(i)\n        \n        res = []\n        for word in smalls:\n            res.append(hit[word])\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/78#issuecomment-1694646515","body":"```\r\n# UnionFind类\r\n# 1 一个father字典（哈希表）用于记录每个省份的核心城市（随意指定的），核心城市相同则说明两个城市属于一个省份\r\n# 2 find方法用于寻找当前城市所在省份的核心城市\r\n# 3 union方法用于把两个城市连接到一个省份中\r\n# \r\n# findCircleNum方法\r\n# 1 遍历矩阵，只遍历一半，遇到“1”连接两个城市到一个省份\r\n# 2 union方法中会将省份数量减一（若两个城市已在同一个省份则不减）\r\n# 3 返回省份数量\r\n\r\n\r\n\r\nclass UnionFind:\r\n    def __init__(self, count):\r\n        self.father = {}\r\n        self.count = count\r\n    \r\n    def find(self, x):\r\n        self.father.setdefault(x, x)\r\n        if x != self.father[x]:\r\n            self.father[x] = self.find(self.father[x])\r\n        return self.father[x]\r\n    \r\n    def union(self, x, y):\r\n        fx, fy = self.find(x), self.find(y)\r\n        if fx == fy: return\r\n        self.father[fx] = fy\r\n        self.count -= 1\r\n\r\nclass Solution:\r\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\r\n        n = len(isConnected)\r\n        uf = UnionFind(n)\r\n        \r\n        for i in range(n):\r\n            for j in range(i + 1, n):\r\n                if isConnected[i][j]:\r\n                    uf.union(i, j)\r\n        return uf.count\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/79#issuecomment-1693566471","body":" ```\n# 思路\n# 1 两个字典（Java用两个数组更快），一个用于记录每个节点的父节点，一个用于记录每个连通区域的大小。\n# 2 寻找待删除节点时，记录每个源病毒（即initial）所在连通区域的父节点\n#     如果某一连通区域有两个源病毒，该区域无论如何都会被感染，放弃该区域\n#     在所有只有一个源病毒的连通区域中，选择size最大的区域中的源病毒节点\n# 3 因为若满足条件的节点有多个，要返回索引最小的节点。先将源病毒索引排序，只有区域size更大才会更新最后要返回的索引index，可以保证返回的是最小索引。\n\nclass UnionFind:\n    def __init__(self):\n        self.father = {}\n        self.size = {}\n    \n    def find(self, x):\n        self.father.setdefault(x, x)\n        if x != self.father[x]:\n            self.father[x] = self.find(self.father[x])\n        return self.father[x]\n    \n    def union(self, x, y):\n        fx, fy = self.find(x), self.find(y)\n        if self.size.setdefault(fx, 1) < self.size.setdefault(fy, 1):\n            self.father[fx] = fy\n            self.size[fy] += self.size[fx]\n        elif fx != fy:\n            self.father[fy] = fx\n            self.size[fx] += self.size[fy]\n\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        uf = UnionFind()\n        \n        # 遍历\n        for i in range(len(graph)):\n            for j in range(i, len(graph)):\n                if graph[i][j]:\n                    uf.union(i, j)\n\n        # 寻找最优待删除节点\n        initial.sort()\n        max_size, index, fi = 0, -1, []\n        cnt = collections.defaultdict(int)\n        for init in initial:\n            fi.append(uf.find(init))\n            cnt[fi[-1]] += 1\n        for i in range(len(initial)):\n            if cnt[fi[i]] > 1:\n                continue\n            if uf.size[fi[i]] > max_size:\n                max_size = uf.size[fi[i]]\n                index = initial[i]\n        \n        return index if index != -1 else initial[0]\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/80#issuecomment-1694342104","body":"```\r\n# 并查集\r\n# 步骤：\r\n\r\n# 将连通块个数初始化成顶点的个数。\r\n# 遍历所有的边 如果边上两个顶点没有连接，连接之，连通块个数-1；\r\n\r\n\r\nclass UnionFind:\r\n    def __init__(self,size):\r\n        self.father = [None] * size\r\n        self.num_of_sets = size\r\n    \r\n    def find(self,x):\r\n        \"\"\"\r\n        路径压缩\r\n        \"\"\"\r\n        if self.father[x] is None: return x\r\n        \r\n        self.father[x] = self.find(self.father[x])\r\n        \r\n        return self.father[x]\r\n    \r\n    def is_connected(self,x,y):\r\n        return self.find(x) == self.find(y)\r\n    \r\n    def merge(self,x,y):\r\n        root_x,root_y = self.find(x),self.find(y)\r\n        \r\n        self.father[root_x] = root_y\r\n        self.num_of_sets -= 1\r\n\r\nclass Solution:\r\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\r\n        if len(connections) < n-1: return -1\r\n\r\n        uf = UnionFind(n)\r\n\r\n        for n1,n2 in connections:\r\n            if uf.is_connected(n1,n2):\r\n                continue\r\n            uf.merge(n1,n2)\r\n\r\n        return uf.num_of_sets-1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/81#issuecomment-1694645420","body":"```\nclass Solution:\n    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        left, right = self.pruneTree(root.left), self.pruneTree(root.right)\n        return None if not root.val and not left and not right else TreeNode(root.val, left,right)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/82#issuecomment-1697526416","body":"```\r\nfrom typing import List\r\n\r\nclass Solution:\r\n    def __init__(self):\r\n        self.res = []\r\n        # 记录回溯的路径\r\n        self.track = []\r\n        # 记录 track 中的路径和\r\n        self.trackSum = 0\r\n\r\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\r\n        if len(candidates) == 0:\r\n            return self.res\r\n        self.backtrack(candidates, 0, target)\r\n        return self.res\r\n\r\n    # 回溯算法主函数\r\n    def backtrack(self, nums: List[int], start: int, target: int) -> None:\r\n        # base case，找到目标和，记录结果\r\n        if self.trackSum == target:\r\n            self.res.append(list(self.track))\r\n            return None\r\n        # base case，超过目标和，停止向下遍历\r\n        if self.trackSum > target:\r\n            return None\r\n\r\n        # 回溯算法标准框架\r\n        for i in range(start, len(nums)):\r\n            # 选择 nums[i]\r\n            self.trackSum += nums[i]\r\n            self.track.append(nums[i])\r\n            # 递归遍历下一层回溯树\r\n            # 同一元素可重复使用，注意参数\r\n            self.backtrack(nums, i, target)\r\n            # 撤销选择 nums[i]\r\n            self.trackSum -= nums[i]\r\n            self.track.pop()\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/83#issuecomment-1697521040","body":"```\n# 为了避免产生重复解，本题candidates需要排序\n\n# backtrack步骤如下：\n# 剪枝：如果当前tmp数组的和cur已经大于目标target，没必要枚举了，直接return\n# 如果当前tmp数组的和cur正好和目标target相等，找到一个组合，加到结果res中去，并return\n# for循环遍历从index开始的数，选一个数进入下一层递归。\n# 如果从index开始的数有连续出现的重复数字，跳过该数字continue，因为这会产生重复解\n# 因为数不可以重复选择，所以在进入下一层递归时，i要加1，从i之后的数中选择接下来的数\n\n\nclass Solution:\n    def __init__(self):\n        self.res = []\n        # 记录回溯的路径\n        self.track = []\n        # 记录 track 中的元素之和\n        self.trackSum = 0\n    \n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        if not candidates:\n            return self.res\n        # 先排序，让相同的元素靠在一起\n        candidates.sort()\n        self.backtrack(candidates, 0, target)\n        return self.res\n    \n    # 回溯算法主函数\n    def backtrack(self, nums: List[int], start: int, target: int):\n        # base case，达到目标和，找到符合条件的组合\n        if self.trackSum == target:\n            self.res.append(self.track[:])\n            return\n        # base case，超过目标和，直接结束\n        if self.trackSum > target:\n            return\n        \n        # 回溯算法标准框架\n        for i in range(start, len(nums)):\n            # 剪枝逻辑，值相同的树枝，只遍历第一条\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            # 做选择\n            self.track.append(nums[i])\n            self.trackSum += nums[i]\n            # 递归遍历下一层回溯树\n            self.backtrack(nums, i + 1, target)\n            # 撤销选择\n            self.track.pop()\n            self.trackSum -= nums[i]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/84#issuecomment-1699081864","body":"```\nclass Solution:\n    def __init__(self):\n        self.res = []  # 用于存储结果\n        self.track = []  # 用于存储路径\n        self.used = []  # 记录元素是否使用过\n\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        # 先排序，让相同的元素靠在一起\n        nums.sort()\n        self.used = [False] * len(nums)\n        self.backtrack(nums)\n        return self.res\n    \n    def backtrack(self, nums):\n        if len(self.track) == len(nums):\n            self.res.append(self.track.copy())\n            return\n        \n        for i in range(len(nums)):\n            if self.used[i]:\n                continue\n            # 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置\n            if i > 0 and nums[i] == nums[i - 1] and not self.used[i - 1]:\n                continue\n            self.track.append(nums[i])\n            self.used[i] = True\n            self.backtrack(nums)\n            self.track.pop()\n            self.used[i] = False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/85#issuecomment-1701227462","body":"```\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        return haystack.find(needle)\n\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n    \n        # Func: 计算偏移表\n        def calShiftMat(st):\n            dic = {}\n            for i in range(len(st)-1,-1,-1):\n                if not dic.get(st[i]):\n                    dic[st[i]] = len(st)-i\n            dic[\"ot\"] = len(st)+1\n            return dic\n        \n        # 其他情况判断\n        if len(needle) > len(haystack):return -1\n        if needle==\"\": return 0\n       \n        # 偏移表预处理    \n        dic = calShiftMat(needle)\n        idx = 0\n    \n        while idx+len(needle) <= len(haystack):\n            \n            # 待匹配字符串\n            str_cut = haystack[idx:idx+len(needle)]\n            \n            # 判断是否匹配\n            if str_cut==needle:\n                return idx\n            else:\n                # 边界处理\n                if idx+len(needle) >= len(haystack):\n                    return -1\n                # 不匹配情况下，根据下一个字符的偏移，移动idx\n                cur_c = haystack[idx+len(needle)]\n                if dic.get(cur_c):\n                    idx += dic[cur_c]\n                else:\n                    idx += dic[\"ot\"]\n            \n        \n        return -1 if idx+len(needle) >= len(haystack) else idx\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/86#issuecomment-1702931864","body":"```\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        a=len(needle)\n        b=len(haystack)\n        if a==0:\n            return 0\n        next=self.getnext(a,needle)\n        p=-1\n        for j in range(b):\n            while p>=0 and needle[p+1]!=haystack[j]:\n                p=next[p]\n            if needle[p+1]==haystack[j]:\n                p+=1\n            if p==a-1:\n                return j-a+1\n        return -1\n\n    def getnext(self,a,needle):\n        next=['' for i in range(a)]\n        k=-1\n        next[0]=k\n        for i in range(1,len(needle)):\n            while (k>-1 and needle[k+1]!=needle[i]):\n                k=next[k]\n            if needle[k+1]==needle[i]:\n                k+=1\n            next[i]=k\n        return next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/87#issuecomment-1703735970","body":"```\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n                \n        def maxHepify(arr, i, end):     # 大顶堆\n            j = 2*i + 1                 # j为i的左子节点【建堆时下标0表示堆顶】\n            while j <= end:             # 自上而下进行调整\n                if j+1 <= end and arr[j+1] > arr[j]:    # i的左右子节点分别为j和j+1\n                    j += 1                              # 取两者之间的较大者\n                \n                if arr[i] < arr[j]:             # 若i指示的元素小于其子节点中的较大者\n                    arr[i], arr[j] = arr[j], arr[i]     # 交换i和j的元素，并继续往下判断\n                    i = j                       # 往下走：i调整为其子节点j\n                    j = 2*i + 1                 # j调整为i的左子节点\n                else:                           # 否则，结束调整\n                    break\n        \n        n = len(nums)\n        \n        # 建堆【大顶堆】\n        for i in range(n//2-1, -1, -1):         # 从第一个非叶子节点n//2-1开始依次往上进行建堆的调整\n            maxHepify(nums, i, n-1)\n\n        # 排序：依次将堆顶元素（当前最大值）放置到尾部，并调整堆\n        # k-1次重建堆（堆顶元素），或 k次交换到尾部（倒数第k个元素）\n        for j in range(n-1, n-k-1, -1):\n            nums[0], nums[j] = nums[j], nums[0]     # 堆顶元素（当前最大值）放置到尾部j\n            maxHepify(nums, 0, j-1)                 # j-1变成尾部，并从堆顶0开始调整堆\n        \n        return nums[-k]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/88#issuecomment-1704341313","body":"```\nclass Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        # 初始化\n        heap = [-stone for stone in stones]\n        heapq.heapify(heap)\n\n        # 模拟\n        while len(heap) > 1:\n            x,y = heapq.heappop(heap),heapq.heappop(heap)\n            if x != y:\n                heapq.heappush(heap,x-y)\n\n        if heap: return -heap[0]\n        return 0\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/89#issuecomment-1705472314","body":"```\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        def mergeTwoLists(l1, l2):\n            dummy = ListNode()\n            current = dummy\n\n            while l1 and l2:\n                if l1.val < l2.val:\n                    current.next = l1\n                    l1 = l1.next\n                else:\n                    current.next = l2\n                    l2 = l2.next\n                current = current.next\n\n            if l1:\n                current.next = l1\n            if l2:\n                current.next = l2\n\n            return dummy.next\n\n        def mergeSortLists(lists, left, right):\n            if left == right:\n                return lists[left]\n            mid = left + (right - left) // 2\n            left_list = mergeSortLists(lists, left, mid)\n            right_list = mergeSortLists(lists, mid + 1, right)\n            return mergeTwoLists(left_list, right_list)\n\n        if not lists:\n            return None\n\n        return mergeSortLists(lists, 0, len(lists) - 1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/90#issuecomment-1706523284","body":" ```\n# 最大堆\n# 首先遍历字符串，用哈希表记录每个字符出现的次数\n# 然后把哈希表中的键值对加到堆中，按照value形成最大堆\n# 循环弹出堆中的value最大的字符，将字符根据其出现次数加到res中\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        count = {}\n        for c in s:\n            count[c] = count.get(c, 0) + 1\n        items = [(-val, key) for key, val in count.items()]\n        heapq.heapify(items)\n        res = \"\"\n        while items:\n            val, key = heapq.heappop(items)\n            res += key * (-val)\n        return res\n\n```","onTime":true},null,null,null],"yetfan":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585659380","body":"**思路**\r\n反向遍历，处理进位。如果数组num处理完，还有k没处理，直接把k加上进位，完成剩余的new_k的处理。\r\n\r\n**代码**\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        ans = []\r\n        c = 0 \r\n\r\n        for i in num[::-1]:\r\n            nk = k % 10 if k>0 else 0\r\n            k = k // 10\r\n\r\n            new = i + nk + c\r\n            ans.append(new % 10)\r\n            c = new // 10\r\n\r\n        k += c\r\n        while k > 0:\r\n            nk = k % 10\r\n            k = k // 10\r\n            ans.append(nk)\r\n     \r\n        \r\n        return ans[::-1]\r\n```\r\n\r\n**复杂度**\r\n时间 O(N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586194733","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [0] * n\r\n\r\n        idx = -n\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                idx = i\r\n            ans[i] = i - idx\r\n\r\n        idx = 2 * n\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            ans[i] = min(ans[i], idx - i)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587335878","body":"## 代码 ##\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else:\r\n            self.size -= 1\r\n            return self.stack.pop(-1)\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        m = min(self.size, k)\r\n        for i in range(m):\r\n            self.stack[i] += val\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1596178965","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1589604631","body":"## 代码 ##\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            for i in range(len(self.stack1)):\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack2.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593326691","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594805474","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        if (add := n - k % n) == n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        while add:\r\n            cur = cur.next\r\n            add -= 1\r\n        \r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595793761","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        head = ListNode(0)\r\n        head.next = head\r\n        temp = head\r\n        while temp.next and temp.next.next:\r\n            node1 = temp.next\r\n            node2 = temp.next.next\r\n            temp.next = node2\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            temp = node1\r\n        return head.next\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596178812","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        \r\n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\r\n            if left == right:\r\n                return None\r\n            mid = getMedian(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n        \r\n        return buildTree(head, None)\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598791918","body":"## 代码 ##\r\n```python\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604477550","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1606138539","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        curVal = curHeight = 0\r\n        def dfs(node: Optional[TreeNode], height: int) -> None:\r\n            if node is None:\r\n                return\r\n            height += 1\r\n            dfs(node.left, height)\r\n            dfs(node.right, height)\r\n            nonlocal curVal, curHeight\r\n            if height > curHeight:\r\n                curHeight = height\r\n                curVal = node.val\r\n        dfs(root, 0)\r\n        return curVal\r\n\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616702728","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        res = []\r\n        m, n, ls = len(words), len(words[0]), len(s)\r\n        for i in range(n):\r\n            if i + m * n > ls:\r\n                break\r\n            differ = Counter()\r\n            for j in range(m):\r\n                word = s[i + j * n: i + (j + 1) * n]\r\n                differ[word] += 1\r\n            for word in words:\r\n                differ[word] -= 1\r\n                if differ[word] == 0:\r\n                    del differ[word]\r\n            for start in range(i, ls - m * n + 1, n):\r\n                if start != i:\r\n                    word = s[start + (m - 1) * n: start + m * n]\r\n                    differ[word] += 1\r\n                    if differ[word] == 0:\r\n                        del differ[word]\r\n                    word = s[start - n: start]\r\n                    differ[word] -= 1\r\n                    if differ[word] == 0:\r\n                        del differ[word]\r\n                if len(differ) == 0:\r\n                    res.append(start)\r\n        return res\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1620484593","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627747279","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        g = [[] for _ in range(n)]\r\n        for x, y in dislikes:\r\n            g[x - 1].append(y - 1)\r\n            g[y - 1].append(x - 1)\r\n        color = [0] * n  # color[x] = 0 表示未访问节点 x\r\n        def dfs(x: int, c: int) -> bool:\r\n            color[x] = c\r\n            return all(color[y] != c and (color[y] or dfs(y, -c)) for y in g[x])\r\n        return all(c or dfs(i, 1) for i, c in enumerate(color))\r\n\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1634502033","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def numberOfRounds(self, startTime: str, finishTime: str) -> int:\r\n        t0 = 60 * int(startTime[:2]) + int(startTime[3:])\r\n        t1 = 60 * int(finishTime[:2]) + int(finishTime[3:])\r\n        if t1 < t0:\r\n            t1 += 1440\r\n        t1 = t1 // 15 * 15\r\n        return max(0, (t1 - t0)) // 15\r\n\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1644147121","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def find_kth_smallest(self, nums, k):\r\n        distance = []\r\n        n = len(nums)\r\n        for i in range(n):\r\n            for j in range(i + 1, n):\r\n                distance.append(abs(nums[i] - nums[j]))\r\n\r\n        distance.sort()\r\n        return distance[k]\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/47#issuecomment-1648190057","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def findAnagrams(self, s: str, p: str) -> List[int]:\r\n        s_len, p_len = len(s), len(p)\r\n        \r\n        if s_len < p_len:\r\n            return []\r\n\r\n        ans = []\r\n        s_count = [0] * 26\r\n        p_count = [0] * 26\r\n        for i in range(p_len):\r\n            s_count[ord(s[i]) - 97] += 1\r\n            p_count[ord(p[i]) - 97] += 1\r\n\r\n        if s_count == p_count:\r\n            ans.append(0)\r\n\r\n        for i in range(s_len - p_len):\r\n            s_count[ord(s[i]) - 97] -= 1\r\n            s_count[ord(s[i + p_len]) - 97] += 1\r\n            \r\n            if s_count == p_count:\r\n                ans.append(i + 1)\r\n\r\n        return ans\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/52#issuecomment-1656762547","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def dfs(self, grid, cur_i, cur_j) -> int:\r\n        if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:\r\n            return 0\r\n        grid[cur_i][cur_j] = 0\r\n        ans = 1\r\n        for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\r\n            next_i, next_j = cur_i + di, cur_j + dj\r\n            ans += self.dfs(grid, next_i, next_j)\r\n        return ans\r\n\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        ans = 0\r\n        for i, l in enumerate(grid):\r\n            for j, n in enumerate(l):\r\n                ans = max(self.dfs(grid, i, j), ans)\r\n        return ans\r\n\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/58#issuecomment-1665771925","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def findNumberOfLIS(self, nums: List[int]) -> int:\r\n        n, max_len, ans = len(nums), 0, 0\r\n        dp = [0] * n\r\n        cnt = [0] * n\r\n        for i, x in enumerate(nums):\r\n            dp[i] = 1\r\n            cnt[i] = 1\r\n            for j in range(i):\r\n                if x > nums[j]:\r\n                    if dp[j] + 1 > dp[i]:\r\n                        dp[i] = dp[j] + 1\r\n                        cnt[i] = cnt[j]\r\n                    elif dp[j] + 1 == dp[i]:\r\n                        cnt[i] += cnt[j]\r\n            if dp[i] > max_len:\r\n                max_len = dp[i]\r\n                ans = cnt[i]\r\n            elif dp[i] == max_len:\r\n                ans += cnt[i]\r\n        return ans\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/60#issuecomment-1666903298","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def uniquePaths(self, m: int, n: int) -> int:\r\n        cur = [1] * n\r\n        for i in range(1, m):\r\n            for j in range(1, n):\r\n                cur[j] += cur[j-1]\r\n        return cur[-1]\r\n\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/66#issuecomment-1675411258","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def change(self, amount: int, coins: List[int]) -> int:\r\n        dp = [1] + [0] * amount\r\n        for c in coins:\r\n            for i in range(c, amount+1):\r\n                dp[i] += dp[i-c]\r\n\r\n        return dp[amount]\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/73#issuecomment-1685023343","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def singleNumber(self, nums: List[int]) -> List[int]:\r\n        xorsum = 0\r\n        for num in nums:\r\n            xorsum ^= num\r\n        \r\n        lsb = xorsum & (-xorsum)\r\n        type1 = type2 = 0\r\n        for num in nums:\r\n            if num & lsb:\r\n                type1 ^= num\r\n            else:\r\n                type2 ^= num\r\n        \r\n        return [type1, type2]\r\n\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/78#issuecomment-1691664489","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\r\n        def dfs(i: int):\r\n            for j in range(cities):\r\n                if isConnected[i][j] == 1 and j not in visited:\r\n                    visited.add(j)\r\n                    dfs(j)\r\n        \r\n        cities = len(isConnected)\r\n        visited = set()\r\n        provinces = 0\r\n\r\n        for i in range(cities):\r\n            if i not in visited:\r\n                dfs(i)\r\n                provinces += 1\r\n        \r\n        return provinces\r\n\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/85#issuecomment-1701041905","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def strStr(self, s: str, t: str) -> int:\r\n        def prefix_function(s):     \r\n            n = len(s)\r\n            pi = [0] * n\r\n\r\n            j = 0\r\n            for i in range(1, n):\r\n                while j>0 and s[i] != s[j]:  \r\n                    j = pi[j-1]       \r\n\r\n                if s[i] == s[j]: \r\n                    j += 1\r\n                \r\n                pi[i] = j\r\n            return pi\r\n        \r\n        n, m = len(s), len(t)\r\n        pi = prefix_function(t) \r\n\r\n        j = 0\r\n        for i in range(n):\r\n\r\n            while j>0 and s[i] != t[j]:\r\n                j = pi[j-1]\r\n\r\n            if s[i] == t[j]:\r\n                j += 1\r\n                if j == m:       \r\n                    return i-m+1\r\n        return -1\r\n\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/90#issuecomment-1706815582","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def frequencySort(self, s: str) -> str:\r\n        return ''.join([i[0]*i[1] for i in sorted(Counter(s).items(),key=lambda x:x[1],reverse=True)])\r\n```","onTime":true},null,null,null],"zhiyuanpeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bwspsu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arinzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mdge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yin02":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elsa-zhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asur4s":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhihaowan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"apockira":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guowei0223":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuqianyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sj941127":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darwintk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"h-steven":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mischaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wurongronga":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miduoliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyshenzhengkang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y4h2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yoco323":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forschers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shanshuiqiankun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"annabellhyx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwfrankfung":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huibinny":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggmybro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"myleetcodejourney":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"want2333":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"staringwhere":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryanbaiyansong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dou-yu-xuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cs12300":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chiehw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aesir-idun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaldsk12":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hxj2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"for123s":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzhilin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yfu6":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585467731","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        for i in range(len(num) - 1, -1, -1):\n            if not k: break\n            k, num[i] = divmod(num[i] + k, 10)\n        while k:\n            k, a = divmod(k, 10)\n            num = [a] + num\n        return num","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592008492","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n\n        for num in arr:\n            largest = num\n            while stack and stack[-1] > num:\n                largest = max(largest, stack.pop())\n            stack.append(largest)\n        \n        return len(stack)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1599611570","body":"    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.dic = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.dic:\n            return -1\n        \n        self.dic.move_to_end(key)\n        return self.dic[key]\n        \n    def put(self, key: int, value: int) -> None:\n        if key in self.dic:\n            self.dic.move_to_end(key)\n        \n        self.dic[key] = value\n        if len(self.dic) > self.capacity:\n            self.dic.popitem(False)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mengsixing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"import-ant":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangqianqian202301":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"airwalkers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhumengcheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leonalhq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hjy-u":[null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1585862063","body":"traverse left -> right then right -> left\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        answer = [0]*len(s)\r\n        idx = float('-inf')\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                idx = i\r\n            answer[i] = i - idx\r\n        for i in range(idx, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            answer[i] = min(answer[i], idx - i)\r\n        return answer\r\n```\r\ntime: O(N)\r\nspace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587618244","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n        self.increase_length = 0\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.insert(0, x)\n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop(0)\n\n    def increment(self, k: int, val: int) -> None:\n        self.increase_length = min(k, len(self.stack))\n        for i in range(self.increase_length):\n            self.stack[len(self.stack) - 1 - i] += val\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596370587","body":"```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pA = headA\n        pB = headB\n        if pA == None or pB == None:\n            return None\n        while (pA != pB):\n            pA = pA.next if pA is not None else headB\n            pB = pB.next if pB is not None else headA\n        return pA\n```\n\ntime: O(N)\\\nspace: O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607775183","body":"```\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return 'None'\n        return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def dfs(dataList):\n            val = dataList.pop(0)\n            if val == 'None':\n                return None\n            root = TreeNode(int(val))\n            root.left = dfs(dataList)\n            root.right = dfs(dataList)\n            return root\n\n        dataList = data.split(',')\n        return dfs(dataList)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"csthaha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zepherust":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feefeefee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hughlin07":[null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587605630","body":"public class CustomStack {\n\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top =-1;\n    }\n    public void Push(int x) {\n        if(top!=stack.Length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    public int Pop() {\n        if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    public void Increment(int k, int val) {\n        int limit = Math.Min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589035452","body":"class Solution {\n    public String decodeString(String s) {\n        \n        Stack<Integer> times = new Stack<>();\n        Stack<String> temp_String = new Stack<>();\n        StringBuilder result = new StringBuilder();\n        int count = 0;\n        \n        for(char c : s.toCharArray()){\n            if( c == '['){\n                times.push(count);\n                temp_String.push(result.toString());\n                count = 0;\n                result = new StringBuilder();\n            }\n            else if(c == ']'){\n                StringBuilder temp = new StringBuilder();\n                int temp_times = times.pop();\n                \n                for(int i = 0; i < temp_times; i++){\n                    temp.append(result);\n                }\n                result = new StringBuilder(temp_String.pop() + temp.toString());\n            }\n            else if(c >= '0' && c <= '9'){\n                count = count * 10 + c - '0';\n            }\n            else{\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591514206","body":"class MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593253543","body":"public class Solution {\n\n     public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        int nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i];\n            int y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) {\n                nonzero--;\n            }\n            if (count.get(x) == 1) {\n                nonzero++;\n            }\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) {\n                nonzero++;\n            }\n            if (count.get(y) == 0) {\n                nonzero--;\n            }\n\n            if (nonzero == 0) {\n                ans++;\n            }\n        }\n\n        return ans;\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595702806","body":"class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode preNode = new ListNode(-1, head), res;\n        preNode.next = head;\n        res = head.next;\n        ListNode firstNode = head, secondNode, nextNode;\n        while(firstNode != null && firstNode.next != null){\n            secondNode = firstNode.next;\n            nextNode = secondNode.next;\n\n            firstNode.next = nextNode;\n            secondNode.next = firstNode;\n            preNode.next = secondNode;\n\n            preNode = firstNode;\n            firstNode = nextNode;\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596168171","body":"class Solution {\r\n\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        return dfs(head,null);\r\n    }\r\n    private TreeNode dfs(ListNode head, ListNode tail){\r\n        if(head == tail) return null;\r\n        ListNode fast = head, slow = head;\r\n        while(fast != tail && fast.next != tail){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = dfs(head, slow);\r\n        root.right = dfs(slow.next, tail);\r\n        return root;\r\n    }\r\n\r\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1599047599","body":"public class Solution {\n\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        Set<ListNode> visited = new HashSet<ListNode>();\n        while (pos != null) {\n            if (visited.contains(pos)) {\n                return pos;\n            } else {\n                visited.add(pos);\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n\n}\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604111173","body":"class Solution {\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607200180","body":"public class Codec {\n\n    int cnt=0;\n    TreeNode convertVecToTree(int size,String[] vec){\n        if(cnt>=size || vec[cnt].equals(\"N\")){\n            cnt++;\n            return null;\n        } \n        TreeNode root= new TreeNode(Integer.parseInt(vec[cnt]));\n        cnt++;\n        root.left=convertVecToTree(size,vec);\n        root.right=convertVecToTree(size,vec);\n        return root;\n        \n    }\n    void serializeTree(TreeNode root,StringBuffer s){\n        if(root==null){\n            s.append(',');\n            s.append('N');\n            return;\n        }\n        if(s.length()==0) s.append(Integer.toString(root.val));\n       else  s.append(\",\"+Integer.toString(root.val));\n        serializeTree(root.left,s);\n        serializeTree(root.right,s);\n    }\n\n    \n    public String serialize(TreeNode root) {\n        if(root==null) return \"\";\n        StringBuffer s= new StringBuffer();\n        serializeTree(root,s);\n        String ans=s.toString();\n        // System.out.println(ans);\n        return ans;\n    }\n\n   \n    public TreeNode deserialize(String data) {\n        if(data==\"\") return null;\n        String[] vec=data.split(\",\");\n        TreeNode root=convertVecToTree(vec.length,vec);\n        return root;\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615940830","body":"class Solution {\n    \n    public int lengthOfLongestSubstring(String s) {\n\n        int left = 0;\n        int maxLen = 0;\n        Set<Character> set = new HashSet<>();\n\n        for (int i = 0; i < s.length(); i++) {\n\n            if (!set.add(s.charAt(i))) {\n                \n                maxLen = Math.max(maxLen, set.size());\n                while (s.charAt(left) != s.charAt(i)) {\n\n                    set.remove(s.charAt(left));\n                    left++;\n                }\n\n                left += 1;\n            }\n        }\n\n        return Math.max(maxLen, set.size());\n    }\n}\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1618723865","body":"class Solution {\n\n    public int minSubarray(int[] nums, int k) {\n\n        long tar = 0;\n\n        for (int n : nums)\n            tar += n;\n\n        tar = Math.floorMod(tar, k);\n        if (tar == 0) return 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        long prefix = 0l;\n        int res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n\n\n            if (map.containsKey(Math.floorMod(prefix - tar, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, k)));\n             map.put(mod, i);\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huizsh":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1588556589","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n                # pop 掉 \"[\"\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594257574","body":"```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null) return head;\r\n        int count = 0;\r\n        ListNode now = head;\r\n        while(now != null){\r\n            now = now.next;\r\n            count++;\r\n        }\r\n        k = k % count;\r\n        ListNode slow = head, fast = head;\r\n        while(fast.next != null){\r\n            if(k-- <= 0){\r\n                slow = slow.next;\r\n            }\r\n            fast = fast.next;\r\n        }\r\n        fast.next = head;\r\n        ListNode res = slow.next;\r\n        slow.next = null;\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596467061","body":"```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604070693","body":"class Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1608726287","body":"```\nclass Solution(object):\n    def verticalTraversal(self, root):\n        seen = collections.defaultdict(\n            lambda: collections.defaultdict(list))\n\n        def dfs(root, x=0, y=0):\n            if not root:\n                return\n            seen[x][y].append(root.val)\n            dfs(root.left, x-1, y+1)\n            dfs(root.right, x+1, y+1)\n\n        dfs(root)\n        ans = []\n        # x 排序、\n        for x in sorted(seen):\n            level = []\n            # y 排序\n            for y in sorted(seen[x]):\n                # 值排序\n                level += sorted(v for v in seen[x][y])\n            ans.append(level)\n\n        return ans\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614332884","body":"```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1\n            for count in m.values():\n                ans += count * (count-1)\n        return ans\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1619435002","body":"```\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1623143167","body":"```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n\n        while(l<=r):\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1631809500","body":"```\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(task[0], i, task[1]) for i, task in enumerate(tasks)]\n        tasks.sort()\n        backlog = []\n        time = 0\n        ans = []\n        pos = 0\n        for _ in tasks:\n            if not backlog:\n                time = max(time, tasks[pos][0])\n            while pos < len(tasks) and tasks[pos][0] <= time:\n                heapq.heappush(backlog, (tasks[pos][2], tasks[pos][1]))\n                pos += 1\n            d, j = heapq.heappop(backlog)\n            time += d\n            ans.append(j)\n        return ans\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1636030413","body":"```\nclass Solution:\n    def minCharacters(self, A: str, B: str) -> int:\n        counter_A = [0] * 26\n        counter_B = [0] * 26\n        for a in A:\n            counter_A[ord(a) - ord('a')] += 1\n        for b in B:\n            counter_B[ord(b) - ord('a')] += 1\n        ans = len(A) + len(B)\n        for i in range(26):\n            ans = min(ans, len(A) + len(B) - counter_A[i] - counter_B[i])\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_A[j]\n            for j in range(i):\n                t += counter_B[j]\n            ans = min(ans, t)\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_B[j]\n            for j in range(i):\n                t += counter_A[j]\n            ans = min(ans, t)\n        return ans\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1643928406","body":"```\nclass Solution:\n    def solve(self, A, k):\n        A.sort()\n        def count_not_greater(diff):\n            i = ans = 0\n            for j in range(1, len(A)):\n                while A[j] - A[i] > diff:\n                    i += 1\n                ans += j - i\n            return ans\n        l, r = 0, A[-1] - A[0]\n        k += 1 # zero based -> one based\n        while l <= r:\n            mid = (l + r) // 2\n            if count_not_greater(mid) >= k:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/48#issuecomment-1649431165","body":"```\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        l, counter, N, ct = 0, Counter(), len(s), Counter(t)\n        k = 0\n        ret, ans = inf, \"\"\n        for r in range(N):\n            counter[s[r]] += 1\n            if s[r] in t and counter[s[r]] == ct[s[r]]:\n                k += 1\n            while k == len(ct):\n                if r - l + 1 < ret:\n                    ans = s[l:r+1]\n                ret = min(r - l + 1, ret)\n                counter[s[l]] -= 1\n                if s[l] in t and counter[s[l]] == ct[s[l]]-1:\n                    k -= 1\n                l += 1\n        return ans\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/54#issuecomment-1658284827","body":"```\n    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        boxes = set(initialBoxes)\n        q = [i for i in boxes if status[i]]\n        for i in q:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    q.append(j)\n            for j in keys[i]:\n                if status[j] == 0 and j in boxes:\n                    q.append(j)\n                status[j] = 1\n        return sum(candies[i] for i in q)\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/61#issuecomment-1667292045","body":"```\nclass Solution {\n\n    private int[][] dir = {{-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}};\n\n    public double knightProbability(int N, int K, int r, int c) {\n\n        double[][] dp = new double[N][N];\n        dp[r][c] = 1;\n\n        for (int step = 1; step <= K; step++) {\n\n            double[][] dpTemp = new double[N][N];\n\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    for (int[] direction : dir) {\n\n                        int lastR = i - direction[0];\n                        int lastC = j - direction[1];\n                        if (lastR >= 0 && lastR < N && lastC >= 0 && lastC < N)\n                            dpTemp[i][j] += dp[lastR][lastC] * 0.125;\n                    }\n\n            dp = dpTemp;\n        }\n\n        double res = 0;\n\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                res += dp[i][j];\n\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chanceyliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hshen11":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"horace7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzh0114":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dragonfcl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huifeng248":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sarah11qing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"el1as7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zcytm3000":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585704276","body":"class Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        n=len(A)\n        ans = []\n\n        for i in range(n-1, -1, -1):\n            total = A[i] + K % 10\n\n            K //= 10\n            \n            if total >= 10:\n            \n                K += 1\n\n            ans.append(total % 10)\n            \n        \n        while K > 0:\n            ans.append(K % 10)\n            K //= 10\n        return ans[::-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586212044","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        a=[]\n        b=[]\n        for i,ch in enumerate(s):\n            if ch==c:\n                b.append(int(i))\n        return([min(abs(x-i) for i in b) for x in range(len(s))])","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587539008","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589556937","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n       num_stack = [] \n       char_stack = []\n       res = ''\n       num_str = ''\n       for i in s:\n           if i.isdigit():\n               num_str+=i\n           elif i == '[':\n               char_stack.append(res)\n               num_stack.append(num_str)\n               res = ''\n               num_str = ''\n           elif i == ']':\n               res = char_stack.pop() + int(num_stack.pop()) * res \n           else:\n               res += i\n       return res","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598241941","body":"class Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1606650773","body":"class Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return 'None'\n        return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))\n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def dfs(dataList):\n            val = dataList.pop(0)\n            if val == 'None':\n                return None\n            root = TreeNode(int(val))\n            root.left = dfs(dataList)\n            root.right = dfs(dataList)\n            return root\n\n        dataList = data.split(',')\n        return dfs(dataList)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1617494635","body":"class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        x = sum(nums) % p\n        if x == 0:\n            return 0\n        y = 0\n        index = {0: -1}\n        ans = len(nums)\n        for i, v in enumerate(nums):\n            y = (y + v) % p\n            if (y - x) % p in index:\n                ans = min(ans, i - index[(y - x) % p])\n            index[y] = i\n        return ans if ans < len(nums) else -1","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1628532067","body":"class Solution:\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637711650","body":"class Solution:\r\n    def firstBadVersion(self, n: int) -> int:\r\n        left = 1\r\n        right = n \r\n        if n == 1:\r\n            return 1\r\n        while left <= right:\r\n            test = left + (right-left)//2 # 防止溢出\r\n            if isBadVersion(test) == False:\r\n                left = test + 1\r\n            elif isBadVersion(test) == True and isBadVersion(test-1) == False:\r\n                return test\r\n            else:\r\n                right = test - 1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xb798298436":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ywang525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"limbo42":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorapocket":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoeyzyzyzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jasonqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lp1506947671":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"texamc2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joemonkeylee":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585689329","body":"```typescript\n\nfunction addToArrayForm(num: number[], k: number): number[] {\n  let res: number[] = [];\n  let carry: number = 0;\n  let N: number = num.length - 1;\n  let temp: number = 0;\n  while (k / 10 != 0 || N >= 0) {\n    if (N >= 0) {\n      temp = num[N];\n    } else {\n      temp = 0;\n    }\n    if ((k % 10) + temp + carry >= 10) {\n      res.push((k % 10) + temp + carry - 10);\n      carry = 1;\n    } else {\n      res.push((k % 10) + temp + carry);\n      carry = 0;\n    }\n    N--;\n    k = (k - (k % 10)) / 10;\n  }\n  if (carry == 1) {\n    res.push(carry);\n  }\n  return res.reverse();\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586091293","body":"```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n  const N = s.length;\n  let res: number[] = new Array(N).fill(Number.MAX_SAFE_INTEGER);\n\n  let prev = 0;\n  for (let i = 0; i < N; i++) {\n    if (s[i] == c) {\n      for (let j = prev; j <= i; j++) {\n        res[j] = i - j;\n      }\n      prev = i;\n    }\n  }\n\n  prev = N - 1;\n  for (let i = N - 1; i >= 0; i--) {\n    if (s[i] == c) {\n      for (let j = prev; j >= i; j--) {\n        res[j] = Math.min(res[j], j - i);\n      }\n      prev = i;\n    }\n  }\n  return res;\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587565711","body":"```typescript\nclass CustomStack {\n  private vector: number[];\n  private maxSize: number;\n  constructor(maxSize: number) {\n    this.vector = [];\n    this.maxSize = maxSize;\n  }\n\n  push(x: number): void {\n    if (this.vector.length < this.maxSize) {\n      this.vector.push(x);\n    }\n  }\n\n  pop(): number {\n    if (this.vector.length) {\n      const temp = this.vector[this.vector.length - 1];\n      this.vector = [\n        ...this.vector.filter((x, index) => index != this.vector.length - 1),\n      ];\n      return temp;\n    } else {\n      return -1;\n    }\n  }\n\n  increment(k: number, val: number): void {\n    const count = Math.min(k, this.vector.length);\n    for (let i = 0; i < count; i++) {\n      this.vector[i] += val;\n    }\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589441996","body":"```typescript\nfunction decodeString(s: string): string {\n  const numStack: number[] = [];\n  const strStack: string[] = [];\n  let cur = \"\";\n  let num = 0;\n  for (const c of s) {\n    if (/\\d/.test(c)) {\n      num = num * 10 + parseInt(c);\n    } else if (c === \"[\") {\n      numStack.push(num);\n      strStack.push(cur);\n      cur = \"\";\n      num = 0;\n    } else if (c === \"]\") {\n      const tmp = cur;\n      cur = strStack.pop()!;\n      const repeatTimes = numStack.pop()!;\n      for (let i = 0; i < repeatTimes; i++) {\n        cur += tmp;\n      }\n      num = 0;\n    } else {\n      cur += c;\n    }\n  }\n  return cur;\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590614141","body":"class MyQueue {\n    inStack: number[] = [];\n    outStack: number[] = [];\n\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.inStack.push(x);\n    }\n\n    pop(): number {\n        if (!this.outStack.length) {\n            this.in2out();\n        }\n        return this.outStack.pop();\n    }\n\n    peek(): number {\n        if (!this.outStack.length) {\n            this.in2out();\n        }\n        return this.outStack[this.outStack.length - 1];\n    }\n\n    empty(): boolean {\n        return this.outStack.length === 0 && this.inStack.length === 0;\n    }\n\n    in2out() {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    };\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593184664","body":"```typescript\nfunction maxChunksToSorted(arr: number[]): number {\n  let clone = [...arr].sort((a, b) => a - b);\n  let n = arr.length,\n    ans = 0;\n  const map = new Map<number, number>();\n  for (let i = 0, tot = 0; i < n; i++) {\n    const a = arr[i],\n      b = clone[i];\n    if (!map.has(a)) map.set(a, 0);\n    if (map.get(a) == 0) tot++;\n    else if (map.get(a) == -1) tot--;\n    map.set(a, map.get(a) + 1);\n    if (!map.has(b)) map.set(b, 0);\n    if (map.get(b) == 0) tot++;\n    else if (map.get(b) == 1) tot--;\n    map.set(b, map.get(b) - 1);\n    if (tot == 0) ans++;\n  }\n  return ans;\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594829554","body":"```typescript\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    if (head === null || k === 0) return head\n    let temp = head\n    let n = 1\n    while (temp.next) {\n        temp = temp.next\n        n++\n    }\n    temp.next = head\n\n    k = n - k % n - 1\n    while (k > 0) {\n        head = head.next\n        k--\n    }\n    const res = head.next\n    head.next = null\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595790935","body":"```typescript\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    const dummy = new ListNode(0, head);\n    let cur = dummy;\n    while (cur.next != null && cur.next.next != null) {\n        const first = cur.next;\n        const second = first.next;\n        cur.next = second;\n        first.next = second.next;\n        second.next = first;\n        cur = first;\n    }\n    return dummy.next;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596183890","body":"```typescript\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n  if (head === null) return null;\n\n  let slow: ListNode | null = head;\n  let fast: ListNode | null = head;\n  let prev: ListNode | null = null;\n\n  while (fast !== null && fast.next !== null) {\n    prev = slow;\n    slow = slow!.next;\n    fast = fast.next.next;\n  }\n\n  const middle = slow!;\n  const node = new TreeNode(middle.val);\n  if (head === middle) return node;\n\n  prev!.next = null;\n\n  node.left = sortedListToBST(head);\n  node.right = sortedListToBST(middle.next);\n\n  return node;\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1597417042","body":"```typescript\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode pA = headA, pB = headB;\n        while(pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1599031784","body":"```typescript\nfunction detectCycle(head: ListNode | null): ListNode | null {\n    const visited = new Set();\n    while (head !== null) {\n        if (visited.has(head)) {\n            return head;\n        }\n        visited.add(head);\n        head = head.next;\n    }\n    return null;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600916804","body":"```typescript\nclass LRUCache {\n    private capacity: number;\n    private vector: { key: number, value: number }[] = [];\n    constructor(capacity: number) {\n        this.capacity = capacity;\n    }\n\n    get(key: number): number {\n        let index = this.vector.findIndex(x => x.key == key);\n        if (index != -1) {\n            let res = this.vector[index];\n            this.vector.splice(index, 1);\n            this.vector.push(res);\n            return res.value;\n        } else {\n            return -1;\n        }\n    }\n\n    put(key: number, value: number): void {\n        let index = this.vector.findIndex(x => x.key == key);\n        if (index != -1) {\n            let res = this.vector[index];\n            res.value = value;\n            this.vector.splice(index, 1);\n            this.vector.push(res);\n        } else {\n            if (this.vector.length == this.capacity) {\n                this.vector.shift();\n            }\n            this.vector.push({ key, value });\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602688869","body":"```typescript\nfunction maxDepth(root: TreeNode | null): number {\n    if (!root) return 0;\n    let leftHeight = maxDepth(root.left);\n    let rightHeight = maxDepth(root.right);\n    let height = 1 + Math.max(leftHeight, rightHeight);\n    return height;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1603096877","body":"```typescript\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    if (p === null && q === null) {\n        return true;\n    }\n    if (p === null || q === null) {\n        return false;\n    }\n    if (p.val !== q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605529825","body":"```typescript\nfunction sumNumbers(root: TreeNode | null): number {\n    const traversal = (root: TreeNode | null, temp: string, arr: number[]) => {\n        temp += root.val;\n        if (!root.left && !root.right) arr.push(parseInt(temp));\n        root.left && traversal(root.left, temp, res);\n        root.right && traversal(root.right, temp, res);\n    }\n    let res: number[] = []\n    traversal(root, '', res);\n    return sum(res);\n};\n\nconst sum = (arr: number[]): number => {\n    return arr.reduce(function (prev, cur) {\n        return prev + cur;\n    }, 0);\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605983643","body":"```typescript\n\nfunction findBottomLeftValue(root: TreeNode | null): number {\n    let curVal: number;\n    const dfs = (root, height) => {\n        if (!root) {\n            return;\n        }\n        height++;\n        dfs(root.left, height);\n        dfs(root.right, height);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n    }\n\n    let curHeight = 0;\n    dfs(root, 0);\n    return curVal;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607765393","body":"```typescript\n/*\n * Encodes a tree to a single string.\n */\nfunction serialize(root: TreeNode | null): string {\n    if (root == null) {\n        return 'X';\n    }\n    const left = serialize(root.left);\n    const right = serialize(root.right);\n    return root.val + ',' + left + ',' + right;\n};\n\n/*\n * Decodes your encoded data to tree.\n */\nfunction deserialize(data: string): TreeNode | null {\n    const list = data.split(',');\n    const buildTree = (list) => {\n        const rootVal = list.shift();\n        if (rootVal == \"X\") {\n            return null;\n        }\n        const root = new TreeNode(rootVal);\n        root.left = buildTree(list);\n        root.right = buildTree(list);\n        return root;\n    };\n    return buildTree(list);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1609797555","body":"```typescript\r\nfunction verticalTraversal(root) {\r\n    const res = [];\r\n    if (!root)\r\n        return res;\r\n    let current = [[0, 0, root]];\r\n    const map = new Map();\r\n    while (current.length > 0) {\r\n        const next = [];\r\n        for (const [x, y, node] of current) {\r\n            const arr = map.get(x) ?? [];\r\n            map.set(x, arr);\r\n            arr.push([y, node.val]);\r\n            if (node.left)\r\n                next.push([x - 1, y + 1, node.left]);\r\n            if (node.right)\r\n                next.push([x + 1, y + 1, node.right]);\r\n        }\r\n        current = next;\r\n    }\r\n    for (const arr of Array.from(map)\r\n        .sort((a, b) => a[0] - b[0])\r\n        .map((a) => a[1])) {\r\n        res.push(arr\r\n            .sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]))\r\n            .map((a) => a[1]));\r\n    }\r\n    return res;\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1609900107","body":"```typescript\r\nfunction twoSum(nums: number[], target: number): number[] {\r\n    let res: number[] = [];\r\n    let dict: Map<number, number> = new Map<number, number>();\r\n    let temp: number = 0;\r\n    for (let i = 0; i < nums.length; i++) {\r\n        temp = target - nums[i];\r\n        if (dict.has(temp)) {\r\n            let index = dict.get(temp);\r\n            return [i, index]\r\n        } else {\r\n            dict.set(nums[i], i);\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1612651664","body":"```typescript\r\nfunction topKFrequent(nums: number[], k: number): number[] {\r\n    let dict: Map<number, number> = new Map();\r\n    let res: number[] = []\r\n    let N = nums.length;\r\n    for (let i = 0; i < N; i++) {\r\n        if (dict.has(nums[i])) {\r\n            dict.set(nums[i], dict.get(nums[i]) + 1);\r\n        } else {\r\n            dict.set(nums[i], 1);\r\n        }\r\n    }\r\n\r\n    // let temp: [number, number][] = [];\r\n    // let index = 0;\r\n    // for (let item of dict) {\r\n    //     temp[index] = item;\r\n    //     index++\r\n    // }\r\n\r\n    let temp = Array.from(dict);\r\n    let length = Math.min(temp.length, k);\r\n    res = temp.sort((a, b) => b[1] - a[1]).slice(0, length).map(x => x[0]);\r\n    return res;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1613585095","body":"```typescript\nfunction numberOfBoomerangs(points: number[][]): number {\n    let res = 0;\n    for (let i = 0; i < points.length; i++) {\n        const map = new Map();\n        for (let j = 0; j < points.length; j++) {\n            if (i === j) continue;\n            const hypotenuse =\n                Math.pow(points[i][0] - points[j][0], 2) +\n                Math.pow(points[i][1] - points[j][1], 2);\n            map.set(hypotenuse, (map.get(hypotenuse) ?? 0) + 1);\n        }\n        for (let count of map.values()) {\n            res += count * (count - 1)\n        }\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615944418","body":"```typescript\nfunction lengthOfLongestSubstring(s: string): number {\n    if (s.length <= 1) {\n        return s.length;\n    }\n    let res = 0;\n    let temp: Set<string> = new Set<string>();\n    let current = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (!temp.has(s[i])) {\n            temp.add(s[i]);\n        }\n        else {\n            res = Math.max(temp.size, res);\n            temp.clear();\n            i = current;\n            current++;\n        }\n    }\n    return Math.max(temp.size, res);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616706252","body":"```typescript\nfunction findSubstring(s: string, words: string[]): number[] {\n    const l = s.length, m = words.length, n = words[0].length;\n    let ans: number[] = [], map1 = new Map();\n    for (let word of words) {\n        map1.set(word, map1.has(word) ? map1.get(word) + 1 : 1);\n    }\n    for (let i = 0; i <= l - m * n; i++) {\n        let sub = s.substring(i, i + m * n), map2 = new Map(), equals = true;\n        for (let j = 0; j <= (m - 1) * n; j += n) {\n            let str = sub.substring(j, j + n);\n            if (map1.has(str)) {\n                map2.set(str, map2.has(str) ? map2.get(str) + 1 : 1);\n            } else {\n                break;\n            }\n            if (map2.get(str) > map1.get(str)) break;\n        }\n        for (const [k, v] of map1) {\n            if (!map2.has(k) || v !== map2.get(k)) {\n                equals = false;\n                break;\n            }\n        }\n        if (equals) ans.push(i);\n    }\n    return ans;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1620110376","body":"```typescript\nfunction middleNode(head: ListNode | null): ListNode | null {\n    if (head == null) {\n        return null;\n    }\n    let slow = head;\n    let fast = head;\n\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1621721930","body":"```typescript\nfunction removeDuplicates(nums: number[]): number {\n    if (nums == null || nums.length == 0) return 0;\n    let p = 0;\n    let q = 1;\n    while (q < nums.length) {\n        if (nums[p] != nums[q]) {\n            nums[p + 1] = nums[q];\n            p++;\n        }\n        q++;\n    }\n    return p + 1;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1623761163","body":"```typescript\nfunction searchInsert(nums: number[], target: number): number {\n    let left: number = 0;\n    let right: number = nums.length - 1;\n    let mid: number = 0;\n    while (left <= right) {\n        mid = left + Math.floor((right - left) / 2)\n        if (nums[mid] === target) {\n            return mid\n        } else if (nums[mid] > target) {\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return left\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1625174735","body":"```typescript\nvar maxSlidingWindow = function(nums, k) {\n    const queue = [];\n    const ans = [];\n    for (let i = 0; i < k; i++) {\n        while (queue.length && nums[i] >= nums[queue[queue.length - 1]]) {\n            queue.pop();\n        }\n        queue.push(i);\n    }\n    ans.push(nums[queue[0]]);\n    for (let i = k; i < nums.length; i++) {\n        while (queue.length && nums[i] >= nums[queue[queue.length - 1]]) {\n            queue.pop();\n        }\n        queue.push(i);\n        while (queue[0] <= i - k) {\n            queue.shift();\n        }\n        ans.push(nums[queue[0]]);\n    }\n    return ans;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1625893307","body":"```typescript\nfunction findJudge(n: number, trust: number[][]): number {\n    if (n === 1) return 1\n    const map: Map<number, number> = new Map()\n    for (let z = 1; z <= n; z++) map.set(z, 0)\n    for (let z of trust) {\n        map.delete(z[0])\n        if (map.get(z[1]) || map.get(z[1]) === 0) map.set(z[1], map.get(z[1]) + 1)\n    }\n    for (let z of map.entries()) if (z[1] === n - 1) return z[0]\n    return -1\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1628836735","body":"```typescript\n\nfunction sortItems(\n  n: number,\n  m: number,\n  group: number[],\n  beforeItems: number[][]\n): number[] {\n\n  for (let i = 0; i < group.length; i++) {\n    if (group[i] == -1) {\n      group[i] = m;\n      m++;\n    }\n  }\n\n  const groupAdj: number[][] = Array(m)\n    .fill(undefined)\n    .map(() => Array());\n  const itemAdj: number[][] = Array(n)\n    .fill(undefined)\n    .map(() => Array());\n\n  let groupInDegree: number[] = Array(m).fill(0);\n  let itemInDegree: number[] = Array(n).fill(0);\n\n  for (let i = 0; i < group.length; i++) {\n    let curGroup = group[i];\n    for (let beforeItem of beforeItems[i]) {\n      let beforeGroup = group[beforeItem];\n      if (beforeGroup != curGroup) {\n        groupAdj[beforeGroup].push(curGroup);\n        groupInDegree[curGroup]++;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let item of beforeItems[i]) {\n      itemAdj[item].push(i);\n      itemInDegree[i]++;\n    }\n  }\n\n  let groupResult: number[] = topoLogicalSort(groupAdj, groupInDegree, m);\n  if (groupResult.length == 0) {\n    return [];\n  }\n  let itemResult = topoLogicalSort(itemAdj, itemInDegree, n);\n  if (itemResult.length == 0) {\n    return [];\n  }\n  let group2Items: Map<number, number[]> = new Map();\n  for (let item of itemResult) {\n    let key = group[item];\n    if (group2Items.has(key)) {\n      group2Items.get(group[item]).push(item);\n    } else {\n      group2Items.set(key, [item]);\n    }\n  }\n\n  let result: number[] = Array();\n  for (let group of groupResult) {\n    let items = group2Items.get(group) ?? [];\n    result = result.concat(items);\n  }\n  return result;\n}\n\nfunction topoLogicalSort(\n  adj: number[][],\n  inDegree: number[],\n  n: number\n): number[] {\n  let result: number[] = [];\n  let queue: number[] = [];\n  for (let i = 0; i < n; i++) {\n    if (inDegree[i] == 0) {\n      queue.push(i);\n    }\n  }\n  while (queue.length != 0) {\n    let front = queue.shift();\n    result.push(front);\n    for (let successor of adj[front]) {\n      inDegree[successor]--;\n      if (inDegree[successor] == 0) {\n        queue.push(successor);\n      }\n    }\n  }\n  if (result.length == n) {\n    return result;\n  }\n  return [];\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1629426310","body":"```typescript\nvar judgeCircle = function (moves) {\n  let x = 0\n  let y = 0\n  for (let i = 0; i < moves.length; i++) {\n    switch (moves[i]) {\n      case 'L': {\n        x--\n        break\n      }\n      case 'R': {\n        x++\n        break\n      }\n      case 'U': {\n        y--\n        break\n      }\n      case 'D': {\n        y++\n        break\n      }\n    }\n  }\n  return x === 0 && y === 0\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"northseacoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dominique9898":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wl678":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"meisgithub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sye9286":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fuku-l":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585688464","body":"### 思路\r\n从最后一位开始相加，每次记录进位。\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int sum = 0;\r\n        int carry = 0;\r\n        int idx = num.length-1;\r\n        while(idx >=0 || k !=0){\r\n            int a = idx >= 0 ? num[idx]:0;\r\n            int b = k!=0 ? k%10:0;\r\n            sum = a+b+carry;\r\n            res.add(0,sum%10);\r\n            carry = sum/10;\r\n            idx--;\r\n            k/=10;\r\n        }\r\n        if(carry!=0) res.add(0, carry);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586216605","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n            int[] res = new int[s.length()];\r\n            int ch = c;\r\n            for (int i = 0; i < s.length(); i++) {\r\n                int a = s.indexOf(ch, i);\r\n                if (a == i) {\r\n                    res[i] = 0;\r\n                } else {\r\n                    res[i] = Math.abs(a - i);\r\n                }\r\n            }\r\n            for (int i = s.length() - 1; i >= 0; i--) {\r\n                int a = s.lastIndexOf(ch, i);\r\n                if (Math.abs(a - i) < res[i]) {\r\n                    res[i] = Math.abs(a - i);\r\n                } else if(a<0){ // 如果找到\r\n                    break;\r\n                }\r\n            }\r\n            return res;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586316635","body":"### 思路\r\n因为题目中 inc() 方法需要遍历栈底到k的区间，因此使用使用数组和指针来完成\r\n\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n    int[] arr = null;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < arr.length-1){\r\n            arr[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top >= 0){\r\n            return arr[top--];\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int loop = Math.min(k-1, top);\r\n        for(int i = 0; i <= loop; i++){\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：出栈和入栈为O(1)，increment方法为O(N)， N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589160667","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n            // 将数字、字母、左括号、右括号看作独立的str，用栈来维护这些str\r\n            // 1. 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\r\n            // 2. 如果为字符或左括号，直接进栈\r\n            // 3. 如果为右括号，开始出栈。一直到左括号出栈，出栈序列反转后拼成字符串a，取出栈顶数字num，将a重复num次后进栈\r\n            Deque<String> stack = new ArrayDeque<String>();\r\n            int idx = 0;\r\n            while (idx < s.length()) {\r\n                char ch = s.charAt(idx);\r\n                if (Character.isDigit(ch)) {\r\n                    // 数字\r\n                    int end = s.indexOf('[',idx);\r\n                    stack.push(s.substring(idx, end));\r\n                    idx = end;\r\n                } else if(']' == ch){\r\n                    // 出栈，直到遇到'['\r\n                    String a = \"\";\r\n                    while (!\"[\".equals(stack.peek())){\r\n                        a = stack.pop() + a;\r\n                    }\r\n                    stack.pop();\r\n                    int num = Integer.parseInt(stack.pop());\r\n                    String val = \"\";\r\n                    for (int i = 0; i < num; i++) {\r\n                        val+=a;\r\n                    }\r\n                    stack.push(val);\r\n                    idx++;\r\n                }else {\r\n                    // 字符 或者 [ 直接进栈\r\n                    stack.push(String.valueOf(ch));\r\n                    idx++;\r\n                }\r\n            }\r\n\r\n            StringBuffer res = new StringBuffer();\r\n            Object[] str = stack.toArray();\r\n            for (int i = str.length-1; i >=0; i--) {\r\n                res.append(str[i]);\r\n            }\r\n            return res.toString();\r\n        }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591083000","body":"### 代码\r\n```java\r\nclass MyQueue {\r\n    Deque<Integer> push_stack;\r\n    Deque<Integer> pop_stack;\r\n    public MyQueue() {\r\n        this.push_stack = new ArrayDeque<Integer>();\r\n        this.pop_stack = new ArrayDeque<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        push_stack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(pop_stack.isEmpty() && push_stack.isEmpty()){\r\n            return -1;\r\n        } else if(pop_stack.isEmpty()){\r\n            while(!push_stack.isEmpty()){\r\n                pop_stack.push(push_stack.pop());\r\n            }\r\n        } \r\n        return pop_stack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(pop_stack.isEmpty() && push_stack.isEmpty()){\r\n            return -1;\r\n        } else if(pop_stack.isEmpty()){\r\n            while(!push_stack.isEmpty()){\r\n                pop_stack.push(push_stack.pop());\r\n            }\r\n        } \r\n        return pop_stack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return pop_stack.isEmpty() && push_stack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593001530","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> stack = new ArrayDeque<Integer>();\r\n        for(int n: arr){\r\n            if(stack.isEmpty() || n >= stack.peek()){\r\n                stack.push(n);\r\n            } else {\r\n                int max = stack.pop();\r\n                while(!stack.isEmpty() && stack.peek() > n){\r\n                    stack.pop();\r\n                }\r\n                stack.push(max);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594691404","body":"### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n\r\n        ListNode p1 = head;\r\n        ListNode p2 = head;\r\n        int size = 1;\r\n        for(int i = 0; i < k; i++){\r\n            if(p2.next!=null){\r\n                p2 = p2.next;\r\n                size++;\r\n            } else {\r\n                p2 = head;\r\n                k = (k % size) + size;\r\n            }\r\n        }\r\n\r\n        while(p2.next!=null){\r\n            p2 = p2.next;\r\n            p1 = p1.next;\r\n        }\r\n\r\n        p2.next = head;\r\n        head = p1.next;\r\n        p1.next = null;\r\n\r\n        return head;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595788986","body":"### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        ListNode pre = new ListNode(0);\r\n        pre.next = head;\r\n        ListNode cur = pre;\r\n        while (cur.next != null && cur.next.next!=null){\r\n            ListNode tmp = cur.next;\r\n            cur.next = tmp.next;\r\n            tmp.next = cur.next.next;\r\n            cur.next.next = tmp;\r\n            cur = tmp;\r\n        }\r\n        return pre.next;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1595813450","body":"### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        // 递归+快慢指针\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right){\r\n        if(left == right){\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right){\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while(fast != right && fast.next != right){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1597294623","body":"### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) return null;\r\n        ListNode p1 = headA;\r\n        ListNode p2 = headB;\r\n        while (p1 != p2) {\r\n            p1 = p1 == null ? headB : p1.next;\r\n            p2 = p2 == null ? headA : p2.next;\r\n        }\r\n        return p1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598902269","body":"### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n            ListNode p1 = head, p2 = head;\r\n            while (true) {\r\n                if (p2 == null || p2.next == null) {\r\n                    return null;\r\n                }\r\n                p1 = p1.next;\r\n                p2 = p2.next.next;\r\n                if (p1 == p2) {\r\n                    break;\r\n                }\r\n            }\r\n            p2 = head;\r\n            while (p1 != p2) {\r\n                p1 = p1.next;\r\n                p2 = p2.next;\r\n            }\r\n            return p1;\r\n        }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600818195","body":"### 代码\r\n```java\r\nclass LRUCache {\r\n    int cap;\r\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\r\n    public LRUCache(int capacity) {\r\n        this.cap = capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(!cache.containsKey(key)){\r\n            return -1;\r\n        }\r\n        // 将 key 变为最近使用\r\n        makeRecently(key);\r\n        return cache.get(key);\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(cache.containsKey(key)){\r\n            cache.put(key,value);\r\n            makeRecently(key);\r\n            return;\r\n        }\r\n        if(cache.size() >= this.cap){\r\n            // 移除最久未使用的key--链表头部\r\n            int oldKey = cache.keySet().iterator().next();\r\n            cache.remove(oldKey);\r\n        }\r\n        cache.put(key,value);\r\n    }\r\n\r\n    private void makeRecently(int key){\r\n        int value = cache.get(key);\r\n        cache.remove(key);\r\n        cache.put(key,value);\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604167243","body":"### 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null || q == null) return p == q;\r\n        if(p.val != q.val) return false;\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605507885","body":"### 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        return dfs(root, 0);\r\n    }\r\n    public int dfs(TreeNode root, int preNum){\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        int sum = root.val + preNum * 10;\r\n        if(root.left == null && root.right == null){\r\n            // 根节点\r\n            return sum;\r\n        } else {\r\n            return dfs(root.right, sum) + dfs(root.left, sum);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1606084762","body":"### 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        // 广度优先遍历，先遍历右子树，再遍历左子树。保证最后遍历的节点为最底层 最左边 节点的值。\r\n        Queue<TreeNode> bfs = new LinkedList<>();\r\n        bfs.offer(root);\r\n        int res = -1;\r\n        while(!bfs.isEmpty()){\r\n            TreeNode cur = bfs.poll();\r\n            res = cur.val;\r\n            if(cur.right != null){\r\n                bfs.offer(cur.right);\r\n            }\r\n            if(cur.left != null){\r\n                bfs.offer(cur.left);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607459337","body":"### 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        return serialize(root, \"\");\r\n    }\r\n    \r\n    private String serialize(TreeNode root,String str) {\r\n        if(root == null){\r\n            str += \"None,\";\r\n        } else {\r\n            str += str.valueOf(root.val) + \",\";\r\n            str = serialize(root.left, str);\r\n            str = serialize(root.right, str);\r\n        }\r\n        return str;\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        List<String> nodes =  new LinkedList<String>(Arrays.asList(data.split(\",\")));\r\n        return deserialize(nodes);\r\n    }\r\n    private TreeNode deserialize(List<String> nodes){\r\n        if(\"None\".equals(nodes.get(0))){\r\n            nodes.remove(0);\r\n            return null;\r\n        }\r\n        System.out.println(nodes.get(0));\r\n        TreeNode root = new TreeNode(Integer.valueOf(nodes.get(0)));\r\n        nodes.remove(0);\r\n        root.left = deserialize(nodes);\r\n        root.right = deserialize(nodes);\r\n\r\n        return root;\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1609771508","body":"### 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<int[]> nodes = new ArrayList<int[]>();\r\n        dfs(root, 0, 0, nodes);\r\n        Collections.sort(nodes, new Comparator<int[]>() {\r\n            public int compare(int[] tuple1, int[] tuple2) {\r\n                if (tuple1[0] != tuple2[0]) {\r\n                    return tuple1[0] - tuple2[0];\r\n                } else if (tuple1[1] != tuple2[1]) {\r\n                    return tuple1[1] - tuple2[1];\r\n                } else {\r\n                    return tuple1[2] - tuple2[2];\r\n                }\r\n            }\r\n        });\r\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\r\n        int size = 0;\r\n        int lastcol = Integer.MIN_VALUE;\r\n        for (int[] tuple : nodes) {\r\n            int col = tuple[0], row = tuple[1], value = tuple[2];\r\n            if (col != lastcol) {\r\n                lastcol = col;\r\n                ans.add(new ArrayList<Integer>());\r\n                size++;\r\n            }\r\n            ans.get(size - 1).add(value);\r\n        }\r\n        return ans;\r\n    }\r\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes){\r\n        if(node == null){\r\n            return;\r\n        }\r\n        nodes.add(new int[]{col, row, node.val});\r\n        dfs(node.left, row+1, col-1, nodes);\r\n        dfs(node.right, row+1, col+1, nodes);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1611666326","body":"### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for(int i = 0; i < nums.length; i++){\r\n            int sec = target - nums[i];\r\n            if(map.containsKey(sec)){\r\n                return new int[]{i,map.get(sec)};\r\n            } \r\n            map.put(nums[i],i);\r\n        }\r\n\r\n        return new int[]{};\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1613187091","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer, Integer> coutMap = new HashMap<Integer,Integer>();\r\n        for(int n : nums){\r\n            coutMap.put(n, coutMap.getOrDefault(n, 0)+1);\r\n        }\r\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>(){\r\n            public int compare(int[] m, int[] n){\r\n                return m[1] - n[1];\r\n            }\r\n        });\r\n        for(Map.Entry<Integer, Integer> entry: coutMap.entrySet()){\r\n            int num = entry.getKey();\r\n            int count = entry.getValue();\r\n            if(queue.size() == k){\r\n                if(queue.peek()[1] < count){\r\n                    queue.poll();\r\n                    queue.offer(new int[]{num, count});\r\n                }\r\n            } else {\r\n                queue.offer(new int[]{num, count});\r\n            }\r\n        }\r\n        int[] res = new int[k];\r\n        for(int i = 0; i<k; i++){\r\n            res[i] = queue.poll()[0];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614364170","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n            int ans = 0;\r\n            Map<Integer, Integer> cnt = new HashMap<>();\r\n            for (int[] p : points) {\r\n                cnt.clear();\r\n                for (int[] q : points) {\r\n                    int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                    int m = cnt.getOrDefault(dis, 0);\r\n                    ans += m*2;\r\n\r\n                    cnt.put(dis, m+1);\r\n                }\r\n            }\r\n            return ans;\r\n\r\n        }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616695069","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int m = words.length, n = words[0].length(), ls = s.length();\r\n        for (int i = 0; i < n; i++) {\r\n            if (i + m * n > ls) {\r\n                break;\r\n            }\r\n            Map<String, Integer> differ = new HashMap<String, Integer>();\r\n            for (int j = 0; j < m; j++) {\r\n                String word = s.substring(i + j * n, i + (j + 1) * n);\r\n                differ.put(word, differ.getOrDefault(word, 0) + 1);\r\n            }\r\n            for (String word : words) {\r\n                differ.put(word, differ.getOrDefault(word, 0) - 1);\r\n                if (differ.get(word) == 0) {\r\n                    differ.remove(word);\r\n                }\r\n            }\r\n            for (int start = i; start < ls - m * n + 1; start += n) {\r\n                if (start != i) {\r\n                    String word = s.substring(start + (m - 1) * n, start + m * n);\r\n                    differ.put(word, differ.getOrDefault(word, 0) + 1);\r\n                    if (differ.get(word) == 0) {\r\n                        differ.remove(word);\r\n                    }\r\n                    word = s.substring(start - n, start);\r\n                    differ.put(word, differ.getOrDefault(word, 0) - 1);\r\n                    if (differ.get(word) == 0) {\r\n                        differ.remove(word);\r\n                    }\r\n                }\r\n                if (differ.isEmpty()) {\r\n                    res.add(start);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1618707415","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int minSubarray(int[] nums, int p) {\r\n        // 1. 前缀和\r\n        // nums = {1,2,3,4,5,6,7}\r\n        // pres = {1,3,6,10,15,21,28}\r\n        // 对坐标 i,j 的nums求和，等价于 pres[j] - pres[i-1]\r\n        // 2. 同余定理：\r\n        // 如果 x % k = a, y % k = a\r\n        // 那么 (x-y) % k = 0\r\n\r\n        // (sum - sub) % p = 0  等价于 sum % p = sub % p\r\n        int x = 0;\r\n        for(int num: nums){\r\n            x = (x+num)%p;\r\n        }\r\n        if(x == 0){\r\n            return 0;\r\n        }\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        int y = 0, res = nums.length;\r\n        for(int i = 0; i<nums.length; i++){\r\n            map.put(y, i);\r\n            y = (y + nums[i]) % p;\r\n            if(map.containsKey((y - x + p) % p)) {\r\n                res = Math.min(res, i - map.get((y - x + p) % p) + 1);\r\n            }\r\n        }\r\n        return res == nums.length ? -1 : res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1620322684","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        if(head == null){\r\n            return head;\r\n        }\r\n        ListNode s = head, f = head;\r\n        while(f!=null && f.next !=null){\r\n            s = s.next;\r\n            f = f.next.next;\r\n        }\r\n        return s;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1622034794","body":"### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        // 双指针\r\n        int i = 0,j = 1;\r\n        for(; j < nums.length;){\r\n            if(nums[i] == nums[j]){\r\n                j++;\r\n            } else {\r\n                nums[++i] = nums[j++];\r\n            }\r\n        }\r\n        return i+1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1623665081","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        for(int i = 0; i < nums.length; i++){\r\n            if(nums[i] == target || nums[i] > target) {\r\n                return i;\r\n            }\r\n        }\r\n        return nums.length;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1625553799","body":"### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        // 1. 将 nums 的前k个元素放入优先队列中\r\n        int n = nums.length;\r\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>(){\r\n            public int compare(int[] pair1, int[] pair2){\r\n                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair2[1];\r\n            }\r\n        });\r\n        for(int i = 0; i<k; i++){\r\n            queue.offer(new int[]{nums[i], i});\r\n        }\r\n        int[] ans = new int[n - k + 1];\r\n        ans[0] = queue.peek()[0];\r\n        // 2. 向右移动时，将一个元素入队，此时堆顶为最大值\r\n        for(int i = k; i<nums.length; i++){\r\n            queue.offer(new int[]{nums[i], i});\r\n            // 3. 将最左侧的值出队\r\n            while(queue.peek()[1] <= i - k){\r\n                queue.poll();\r\n            }\r\n            // 将堆顶保存\r\n            ans[i - k + 1] = queue.peek()[0];\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1627267411","body":"### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int findJudge(int n, int[][] trust) {\r\n        int[][] map = new int[n][2];\r\n        for (int[] node : trust) {\r\n            map[]\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            if (out[i] == 0 && in[i] == (n-1)){\r\n                return i+1;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627616860","body":"### 代码\r\n```java\r\nclass Solution {\r\n    ArrayList<Integer>[] graph;\r\n    Map<Integer, Integer> color;\r\n\r\n    public boolean possibleBipartition(int n, int[][] dislikes) {\r\n        // 遍历图，生成邻接矩阵（图）\r\n        graph = new ArrayList[n+1];\r\n        for(int i = 1; i<=n; i++){\r\n            graph[i] = new ArrayList();\r\n        }\r\n        for(int[] edge: dislikes){\r\n            graph[edge[0]].add(edge[1]);\r\n            graph[edge[1]].add(edge[0]);\r\n        }\r\n\r\n        // 分组：\r\n        // 0: 未分组 1：组一 -1：组二\r\n        color = new HashMap();\r\n        for(int node = 1; node <= n; node++){\r\n            if(!color.containsKey(node) && !dfs(node, 0)){\r\n                return false;\r\n            }\r\n        } \r\n        return true;\r\n    }\r\n\r\n\r\n    private boolean dfs(int node, int c){\r\n        if(color.containsKey(node)){\r\n            return color.get(node) == c;\r\n        }\r\n        color.put(node, c);\r\n        for(int next: graph[node]){\r\n            if(!dfs(next, c^1)) { \r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1629199527","body":"### 代码\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Queue;\r\n\r\npublic class Solution {\r\n\r\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        for (int i = 0; i < group.length; i++) {\r\n            if (group[i] == -1) {\r\n                group[i] = m;\r\n                m++;\r\n            }\r\n        }\r\n\r\n        List<Integer>[] groupAdj = new ArrayList[m];\r\n        List<Integer>[] itemAdj = new ArrayList[n];\r\n        for (int i = 0; i < m; i++) {\r\n            groupAdj[i] = new ArrayList<>();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            itemAdj[i] = new ArrayList<>();\r\n        }\r\n\r\n        int[] groupsIndegree = new int[m];\r\n        int[] itemsIndegree = new int[n];\r\n\r\n        int len = group.length;\r\n        for (int i = 0; i < len; i++) {\r\n            int currentGroup = group[i];\r\n            for (int beforeItem : beforeItems.get(i)) {\r\n                int beforeGroup = group[beforeItem];\r\n                if (beforeGroup != currentGroup) {\r\n                    groupAdj[beforeGroup].add(currentGroup);\r\n                    groupsIndegree[currentGroup]++;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            for (Integer item : beforeItems.get(i)) {\r\n                itemAdj[item].add(i);\r\n                itemsIndegree[i]++;\r\n            }\r\n        }\r\n\r\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\r\n        if (groupsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\r\n        if (itemsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n\r\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\r\n        for (Integer item : itemsList) {\r\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\r\n        }\r\n\r\n        List<Integer> res = new ArrayList<>();\r\n        for (Integer groupId : groupsList) {\r\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\r\n            res.addAll(items);\r\n        }\r\n        return res.stream().mapToInt(Integer::valueOf).toArray();\r\n    }\r\n\r\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for (int i = 0; i < n; i++) {\r\n            if (inDegree[i] == 0) {\r\n                queue.offer(i);\r\n            }\r\n        }\r\n\r\n        while (!queue.isEmpty()) {\r\n            Integer front = queue.poll();\r\n            res.add(front);\r\n            for (int successor : adj[front]) {\r\n                inDegree[successor]--;\r\n                if (inDegree[successor] == 0) {\r\n                    queue.offer(successor);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (res.size() == n) {\r\n            return res;\r\n        }\r\n        return new ArrayList<>();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1630970855","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public boolean judgeCircle(String moves) {\r\n        // RL\r\n        int rl = 0;\r\n        int ud = 0;\r\n        for(char ch: moves.toCharArray()){\r\n            if('R' == ch){\r\n                rl--;\r\n            } else if('L' == ch){\r\n                rl++;\r\n            } else if('U' == ch){\r\n                ud--;\r\n            } else if('D' == ch){\r\n                ud++;\r\n            }\r\n        }\r\n        return rl==0 && ud == 0;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1632744347","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] getOrder(int[][] ts) {\r\n        int n = ts.length;\r\n        // 将 ts 转存成 nts，保留任务编号\r\n        int[][] nts = new int[n][3];\r\n        for (int i = 0; i < n; i++) nts[i] = new int[]{ts[i][0], ts[i][1], i};\r\n        // 根据任务入队时间进行排序\r\n        Arrays.sort(nts, (a,b)->a[0]-b[0]);\r\n        // 根据题意，先按照「持续时间」排序，再根据「任务编号」排序\r\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->{\r\n            if (a[1] != b[1]) return a[1] - b[1];\r\n            return a[2] - b[2];\r\n        });\r\n        int[] ans = new int[n];\r\n        for (int time = 1, j = 0, idx = 0; idx < n; ) {\r\n        \t// 如果当前任务可以添加到「队列」中（满足入队时间）则进行入队\r\n            while (j < n && nts[j][0] <= time) q.add(nts[j++]);\r\n            if (q.isEmpty()) {\r\n\t            // 如果当前「队列」没有任务，直接跳到下个任务的入队时间\r\n                time = nts[j][0];\r\n            } else {\r\n            \t// 如果有可执行任务的话，根据优先级将任务出队（记录下标），并跳到该任务完成时间点\r\n                int[] cur = q.poll();\r\n                ans[idx++] = cur[2];\r\n                time += cur[1];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1634311861","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int numberOfRounds(String loginTime, String logoutTime) {\r\n        int in = 60 * Integer.parseInt(loginTime.substring(0,2)) + Integer.parseInt(loginTime.substring(3,5));\r\n        int out = 60 * Integer.parseInt(logoutTime.substring(0,2)) + Integer.parseInt(logoutTime.substring(3,5));\r\n        if(out < in) {\r\n            // outTime 为第二天\r\n            out += 1440;\r\n        }\r\n        out = out / 15 * 15;\r\n        return Math.max(0, (out - in)) / 15;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1636025814","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int minCharacters(String a, String b) {\r\n        // 计数+枚举\r\n        // 1. 词频统计\r\n        // 枚举字符i,统计a中，>=i 的字符数量，b中 <i的字符数量。\r\n        // 如果将两个字符中的所有字符都变成 i\r\n        //      字符串a需要修改的字符数位 ca = n - c1[i]\r\n        //      字符串b需要修改的字符数位 cb = m - c2[i]\r\n        // 总修改次数为 ca + cb\r\n         int n = a.length(), m = b.length(), ans = 0x3f3f3f3f;\r\n        int[] c1 = new int[26], c2 = new int[26];\r\n        for (char c : a.toCharArray()) c1[c - 'a']++;\r\n        for (char c : b.toCharArray()) c2[c - 'a']++;\r\n        for (int i = 0; i < 26 && ans != 0; i++) {\r\n            // 3\r\n            int ca = n - c1[i], cb = m - c2[i];\r\n            ans = Math.min(ans, ca + cb);\r\n            if (i == 0) continue;\r\n            int r1 = 0, r2 = 0;\r\n            // 1\r\n            for (int j = i; j < 26; j++) r1 += c1[j];\r\n            for (int j = 0; j < i; j++) r1 += c2[j];\r\n            // 2\r\n            for (int j = i; j < 26; j++) r2 += c2[j];\r\n            for (int j = 0; j < i; j++) r2 += c1[j];\r\n            ans = Math.min(ans, Math.min(r1, r2));\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1636805072","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] sortArray(int[] nums) {\r\n        heapSort(nums);\r\n        return nums;\r\n    }\r\n\r\n    public void heapSort(int[] nums) {\r\n        int len = nums.length - 1;\r\n        buildMaxHeap(nums, len);\r\n        for (int i = len; i >= 1; --i) {\r\n            swap(nums, i, 0);\r\n            len -= 1;\r\n            maxHeapify(nums, 0, len);\r\n        }\r\n    }\r\n\r\n    public void buildMaxHeap(int[] nums, int len) {\r\n        for (int i = len / 2; i >= 0; --i) {\r\n            maxHeapify(nums, i, len);\r\n        }\r\n    }\r\n\r\n    public void maxHeapify(int[] nums, int i, int len) {\r\n        for (; (i << 1) + 1 <= len;) {\r\n            int lson = (i << 1) + 1;\r\n            int rson = (i << 1) + 2;\r\n            int large;\r\n            if (lson <= len && nums[lson] > nums[i]) {\r\n                large = lson;\r\n            } else {\r\n                large = i;\r\n            }\r\n            if (rson <= len && nums[rson] > nums[large]) {\r\n                large = rson;\r\n            }\r\n            if (large != i) {\r\n                swap(nums, i, large);\r\n                i = large;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void swap(int[] nums, int i, int j) {\r\n        int temp = nums[i];\r\n        nums[i] = nums[j];\r\n        nums[j] = temp;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637115473","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int mySqrt(int x) {\r\n        int l = 0, r = x, ans = -1;\r\n        while(l <= r){\r\n            int mid = l + (r - l) / 2;\r\n            if((long) mid * mid <= x){\r\n                ans = mid;\r\n                l = mid + 1;\r\n            } else {\r\n                r = mid - 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1638356032","body":"### 代码\r\n```java\r\npublic class Solution extends VersionControl {\r\n    public int firstBadVersion(int n) {\r\n        int l = 0, r = n, ans = -1;\r\n        while(l <= r){\r\n            int mid = l + (r-l)/2;\r\n            if(isBadVersion(mid)) {\r\n                ans = mid;\r\n                r = mid - 1;\r\n            } else {\r\n                l = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1640405827","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int reversePairs(int[] nums) {\r\n        if(nums.length == 0) return 0;\r\n        return reversePairsRecursive(nums, 0, nums.length - 1);\r\n    }\r\n    public int reversePairsRecursive(int[] nums, int l, int r){\r\n        if(l == r){\r\n            return 0;\r\n        } else {\r\n            int mid = (l + r) /2;\r\n            int n1 = reversePairsRecursive(nums, l, mid);\r\n            int n2 = reversePairsRecursive(nums, mid+1, r);\r\n            int res = n1 + n2;\r\n            // 统计下标对数量\r\n            int i = l;\r\n            int j = mid + 1;\r\n            while(i <= mid){\r\n                while(j <= r && (long) nums[i] > 2 *(long)nums[j]){\r\n                    j ++;\r\n                }\r\n                res += j - mid - 1;\r\n                i++;\r\n            }\r\n\r\n\r\n            // 合并两个排序数组\r\n            int[] sort = new int[r - l + 1];\r\n            int p1 = l, p2 = mid + 1;\r\n            int p = 0;\r\n            while(p1 <= mid || p2 <= r){\r\n                if(p1 > mid){\r\n                    sort[p++] = nums[p2++];\r\n                } else if(p2 > r) {\r\n                    sort[p++] = nums[p1++];\r\n                } else{\r\n                    if(nums[p1] < nums[p2]){\r\n                        sort[p++] = nums[p1++];\r\n                    } else{\r\n                        sort[p++] = nums[p2++];\r\n                    }\r\n                }\r\n            }\r\n            for(int k = 0; k < sort.length; k++){\r\n                nums[l + k] = sort[k];\r\n            }\r\n            return res;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/42#issuecomment-1641977101","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int findRadius(int[] houses, int[] heaters) {\r\n        int ans = 0;\r\n        Arrays.sort(heaters);\r\n        for(int house:houses){\r\n            int i = binarySearch(heaters, house);\r\n            int j = i +1;\r\n            int leftDistance = i < 0? Integer.MAX_VALUE : house - heaters[i];\r\n            int rightDistance = j >= heaters.length ? Integer.MAX_VALUE : heaters[j] - house;\r\n            ans = Math.max(ans, leftDistance < rightDistance ? leftDistance : rightDistance);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public int binarySearch(int[] nums, int target){\r\n        int left = 0, right = nums.length - 1;\r\n        if(nums[left] > target){\r\n            return -1;\r\n        }\r\n        while(left < right){\r\n            int mid = left + (right - left + 1) / 2;\r\n            if (nums[mid] > target){\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1644157831","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int solve(int[] nums, int k) {\r\n        Arrays.sort(nums);\r\n        int absMin = 0;\r\n        int absMax = nums[nums.length-1] - nums[0];\r\n\r\n        while (absMin <= absMax) {\r\n            int absMid = (absMin + absMax) / 2;\r\n            if (count_not_greater(nums, absMid) <= k) {\r\n                absMin = absMid + 1;\r\n            } else {\r\n                absMax = absMid - 1;\r\n            }\r\n        }\r\n\r\n        return absMin;\r\n    }\r\n\r\n    private long count_not_greater(int[] nums, int targetDiff) {\r\n        long count = 0;\r\n\r\n        int l = 0;\r\n        for (int r=1; r<nums.length; r++) {\r\n            while (nums[r] - nums[l] > targetDiff) {\r\n                l++;\r\n            }\r\n\r\n            count += r - l;\r\n        }\r\n        return count;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/44#issuecomment-1645604700","body":"### 代码\r\n```java\r\npublic class Solution {\r\n\r\n    private int N;\r\n\r\n    public static final int[][] DIRECTIONS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\r\n\r\n    public int swimInWater(int[][] grid) {\r\n        this.N = grid.length;\r\n\r\n        int len = N * N;\r\n        // 下标：方格的高度，值：对应在方格中的坐标\r\n        int[] index = new int[len];\r\n        for (int i = 0; i < N; i++) {\r\n            for (int j = 0; j < N; j++) {\r\n                index[grid[i][j]] = getIndex(i, j);\r\n            }\r\n        }\r\n\r\n        UnionFind unionFind = new UnionFind(len);\r\n        for (int i = 0; i < len; i++) {\r\n            int x = index[i] / N;\r\n            int y = index[i] % N;\r\n\r\n            for (int[] direction : DIRECTIONS) {\r\n                int newX = x + direction[0];\r\n                int newY = y + direction[1];\r\n                if (inArea(newX, newY) && grid[newX][newY] <= i) {\r\n                    unionFind.union(index[i], getIndex(newX, newY));\r\n                }\r\n\r\n                if (unionFind.isConnected(0, len - 1)) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private int getIndex(int x, int y) {\r\n        return x * N + y;\r\n    }\r\n\r\n    private boolean inArea(int x, int y) {\r\n        return x >= 0 && x < N && y >= 0 && y < N;\r\n    }\r\n\r\n    private class UnionFind {\r\n\r\n        private int[] parent;\r\n\r\n        public UnionFind(int n) {\r\n            this.parent = new int[n];\r\n            for (int i = 0; i < n; i++) {\r\n                parent[i] = i;\r\n            }\r\n        }\r\n\r\n        public int root(int x) {\r\n            while (x != parent[x]) {\r\n                parent[x] = parent[parent[x]];\r\n                x = parent[x];\r\n            }\r\n            return x;\r\n        }\r\n\r\n        public boolean isConnected(int x, int y) {\r\n            return root(x) == root(y);\r\n        }\r\n\r\n        public void union(int p, int q) {\r\n            if (isConnected(p, q)) {\r\n                return;\r\n            }\r\n            parent[root(p)] = root(q);\r\n        }\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/45#issuecomment-1646604153","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int maxVowels(String s, int k) {\r\n           String vowels = \"aeiou\";\r\n           int n = s.length();\r\n            int l = 0, r = (l + k) < n ? l + k : n;\r\n            int cnt = 0;\r\n            for (int i = l; i < r; i++) {\r\n                if (vowels.indexOf(s.charAt(i)) >= 0){\r\n                    cnt ++;\r\n                }\r\n            }\r\n            int ans = cnt;\r\n            for(int i = r; i < n; i++){\r\n                if (vowels.indexOf(s.charAt(i - k)) >= 0){\r\n                    cnt--;\r\n                }\r\n                if (vowels.indexOf(s.charAt(i)) >= 0){\r\n                    cnt++;\r\n                }\r\n                ans = ans > cnt ? ans : cnt;\r\n            }\r\n            return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/46#issuecomment-1646814047","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public double new21Game(int n, int k, int maxPts) {\r\n            if (k == 0) {\r\n                return 1.0;\r\n            }\r\n            double[] dp = new double[k + maxPts];\r\n            for (int i = k; i <= n && i < k + maxPts; i++) {\r\n                dp[i] = 1.0;\r\n            }\r\n            dp[k - 1] = 1.0 * Math.min(n-k+1, maxPts) / maxPts;\r\n            for (int i = k - 2; i >= 0; i--) {\r\n                dp[i] = dp[i + 1] - (dp[i+maxPts+1] - dp[i + 1]) / maxPts;\r\n            }\r\n            return dp[0];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/47#issuecomment-1648025142","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> findAnagrams(String s, String p) {\r\n        if(s.length() < p.length()){\r\n            return new ArrayList<Integer>();\r\n        }\r\n        List<Integer> res = new ArrayList<>();\r\n        int sLen = s.length();\r\n        int pLen = p.length();\r\n        int[] sCnt = new int[26];\r\n        int[] pCnt = new int[26];\r\n        for(int i = 0; i<pLen; i++){\r\n            sCnt[s.charAt(i) - 'a']++;\r\n            pCnt[p.charAt(i) - 'a']++;\r\n        }\r\n        if(Arrays.equals(sCnt, pCnt)){\r\n            res.add(0);\r\n        }\r\n        for(int i = 0; i<sLen - pLen; i++){\r\n            sCnt[s.charAt(i) - 'a']--;\r\n            sCnt[s.charAt(i+pLen) - 'a']++;   \r\n            if(Arrays.equals(sCnt, pCnt)){\r\n                res.add(i+1);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/48#issuecomment-1649998038","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public String minWindow(String s, String t) {\r\n        if(s == null || s == \"\" || t == null || t == \"\" || s.length() < t.length()){\r\n            return \"\";\r\n        }\r\n        int[] tCnt = new int[128];\r\n        int[] sCnt = new int[128];\r\n        // 统计目标字符串中的字符数量\r\n        int tLen = t.length();\r\n        int sLen = s.length();\r\n        for(int i = 0; i< tLen; i++){\r\n            tCnt[t.charAt(i)]++;\r\n        }\r\n        int left = 0, right = 0, min = sLen + 1;\r\n        int count = 0, start = 0;\r\n        while(right < sLen){\r\n            char ch = s.charAt(right);\r\n            if(tCnt[ch] == 0){\r\n                right++;\r\n                continue;\r\n            }\r\n            if(sCnt[ch] < tCnt[ch]){\r\n                count++;\r\n            }\r\n            sCnt[ch]++;\r\n            right++;\r\n            while(count == tLen){\r\n                if(right - left < min){\r\n                    min = right - left;\r\n                    start = left;\r\n                }\r\n                char l = s.charAt(left);\r\n                if(tCnt[l] == 0){\r\n                    left++;\r\n                    continue;\r\n                }\r\n                if(sCnt[l] == tCnt[l]){\r\n                    count--;\r\n                }\r\n                sCnt[l]--;\r\n                left++;\r\n            }\r\n        }\r\n        if(min == sLen + 1){\r\n            return \"\";\r\n        }\r\n        return s.substring(start, start+min);\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/50#issuecomment-1653876836","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public List<String> readBinaryWatch(int turnedOn) {\r\n        List<String> ans = new ArrayList<>();\r\n        for(int i = 0; i<1024; i++){\r\n            int h = i >> 6, m = i&63;\r\n            if(h<12 && m<60 && Integer.bitCount(i) == turnedOn){\r\n                ans.add(h+\":\"+(m < 10 ? \"0\":\"\")+m);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/52#issuecomment-1656756980","body":"#### 代码\r\n```java\r\nclass Solution {\r\n    public int maxAreaOfIsland(int[][] grid) {\r\n        int ans = 0;\r\n        for (int i = 0; i != grid.length; ++i) {\r\n            for (int j = 0; j != grid[0].length; ++j) {\r\n                ans = Math.max(ans, dfs(grid, i, j));\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public int dfs(int[][] grid, int cur_i, int cur_j) {\r\n        if (cur_i < 0 || cur_j < 0 || cur_i == grid.length || cur_j == grid[0].length || grid[cur_i][cur_j] != 1) {\r\n            return 0;\r\n        }\r\n        grid[cur_i][cur_j] = 0;\r\n        int[] di = {0, 0, 1, -1};\r\n        int[] dj = {1, -1, 0, 0};\r\n        int ans = 1;\r\n        for (int index = 0; index != 4; ++index) {\r\n            int next_i = cur_i + di[index], next_j = cur_j + dj[index];\r\n            ans += dfs(grid, next_i, next_j);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/53#issuecomment-1657194333","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int maxDistance(int[][] grid) {\r\n        final int INF = 1000000;\r\n        int[] dx = {-1, 0, 1, 0};\r\n        int[] dy = {0, 1, 0, -1};\r\n        int n = grid.length;\r\n        int[][] d = new int[n][n];\r\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>(){\r\n            public int compare(int[] s1, int[] s2){\r\n                return s1[0] - s2[0];\r\n            }\r\n        });\r\n        for(int i = 0; i< n; i++){\r\n            for(int j = 0; j<n; j++){\r\n                d[i][j] = INF;\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i< n; i++){\r\n            for(int j = 0; j<n; j++){\r\n                if(grid[i][j] == 1){\r\n                    d[i][j] = 0;\r\n                    queue.offer(new int[]{0, i, j});\r\n                }\r\n            }\r\n        }\r\n\r\n        while(!queue.isEmpty()){\r\n            int[] f = queue.poll();\r\n            for(int i = 0; i<4; i++){\r\n                int nx = f[1] + dx[i], ny = f[2]+dy[i];\r\n                if(!(nx >= 0 && nx < n && ny >= 0 && ny < n)){\r\n                    continue;\r\n                }\r\n                if(f[0] + 1 < d[nx][ny]){\r\n                    d[nx][ny] = f[0] + 1;\r\n                    queue.offer(new int[]{d[nx][ny], nx, ny});\r\n                }\r\n            }\r\n        }\r\n\r\n        int ans = -1;\r\n        for(int i = 0; i< n; i++){\r\n            for(int j = 0; j<n; j++){\r\n                if(grid[i][j] == 0){\r\n                    ans = ans > d[i][j] ? ans : d[i][j];\r\n                }\r\n            }\r\n        }\r\n        return ans == INF ? -1 : ans;\r\n        \r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/54#issuecomment-1658559768","body":"#### 代码\r\n```java\r\nclass Solution {\r\n    public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\r\n        int len = status.length;\r\n        boolean[] visited = new boolean[len];\r\n        Set<Integer> haveBox = new HashSet<>();\r\n        Set<Integer> haveKey = new HashSet<>();\r\n        Queue<Integer> q = new LinkedList<>();\r\n        for(int i = 0; i< initialBoxes.length; i++){\r\n            int idx = initialBoxes[i];\r\n            haveBox.add(idx);\r\n            if(status[idx] == 1){\r\n                q.offer(idx);\r\n                visited[idx] = true;\r\n            }\r\n        }\r\n\r\n        int ans = 0;\r\n        while(!q.isEmpty()){\r\n            Integer cur = q.poll();\r\n            ans+= candies[cur];\r\n            int[] curKey = keys[cur];\r\n            int[] curBox = containedBoxes[cur];\r\n            for(int key:curKey){\r\n                haveKey.add(key);\r\n                if(!visited[key] && haveBox.contains(key)){\r\n                    q.offer(key);\r\n                    visited[key] = true;\r\n                }\r\n            }\r\n            for(int box: curBox){\r\n                haveBox.add(box);\r\n                if(!visited[box] && (haveKey.contains(box) || status[box] == 1)){\r\n                    q.offer(box);\r\n                    visited[box] = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return ans;\r\n\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/55#issuecomment-1660530505","body":"[987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<int[]> nodes = new ArrayList<int[]>();\r\n        dfs(root, 0, 0, nodes);\r\n        Collections.sort(nodes, new Comparator<int[]>() {\r\n            public int compare(int[] tuple1, int[] tuple2) {\r\n                if (tuple1[0] != tuple2[0]) {\r\n                    return tuple1[0] - tuple2[0];\r\n                } else if (tuple1[1] != tuple2[1]) {\r\n                    return tuple1[1] - tuple2[1];\r\n                } else {\r\n                    return tuple1[2] - tuple2[2];\r\n                }\r\n            }\r\n        });\r\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\r\n        int size = 0;\r\n        int lastcol = Integer.MIN_VALUE;\r\n        for (int[] tuple : nodes) {\r\n            int col = tuple[0], row = tuple[1], value = tuple[2];\r\n            if (col != lastcol) {\r\n                lastcol = col;\r\n                ans.add(new ArrayList<Integer>());\r\n                size++;\r\n            }\r\n            ans.get(size - 1).add(value);\r\n        }\r\n        return ans;\r\n    }\r\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes){\r\n        if(node == null){\r\n            return;\r\n        }\r\n        nodes.add(new int[]{col, row, node.val});\r\n        dfs(node.left, row+1, col-1, nodes);\r\n        dfs(node.right, row+1, col+1, nodes);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/56#issuecomment-1660680339","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int minCostClimbingStairs(int[] cost) {\r\n        int n = cost.length;\r\n        int[] dp = new int[n+1];\r\n        dp[0] = dp[1] = 0;\r\n        for(int i = 2; i<=n; i++){\r\n            dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2] + cost[i-2]);\r\n        }\r\n        return dp[n];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/57#issuecomment-1664181954","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int rob(int[] nums) {\r\n        if(nums.length == 0){\r\n            return 0;\r\n        }\r\n        int N = nums.length;\r\n        int[] dp = new int[N+1];\r\n        dp[0] = 0;\r\n        dp[1] = nums[0];\r\n        for(int k = 2; k <= N; k++){\r\n            dp[k] = Math.max(dp[k-1], nums[k-1]+dp[k-2]);\r\n        }\r\n        return dp[N];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/58#issuecomment-1665769381","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int findNumberOfLIS(int[] nums) {\r\n        int n = nums.length, maxLen = 0, ans = 0;\r\n        int[] dp = new int[n];\r\n        int[] cnt = new int[n];\r\n        for(int i = 0; i<n; i++){\r\n            dp[i] = 1;\r\n            cnt[i] = 1;\r\n            for(int j = 0; j<i; j++){\r\n                if(nums[i] > nums[j]){\r\n                    if(dp[j] + 1 > dp[i]){\r\n                        dp[i] = dp[j] + 1;\r\n                        cnt[i] = cnt[j]; // 重置计数\r\n                    } else if(dp[j] + 1 == dp[i]){\r\n                        cnt[i] += cnt[j];\r\n                    }\r\n                }\r\n            }\r\n            if(dp[i] > maxLen){\r\n                maxLen = dp[i];\r\n                ans = cnt[i];\r\n            } else if(dp[i] == maxLen){\r\n                ans += cnt[i];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/59#issuecomment-1666539987","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int longestCommonSubsequence(String text1, String text2) {\r\n        int m = text1.length(), n = text2.length();\r\n        int[][] dp = new int[m + 1][n + 1];\r\n        for (int i = 1; i <= m; i++) {\r\n            char c1 = text1.charAt(i - 1);\r\n            for (int j = 1; j <= n; j++) {\r\n                char c2 = text2.charAt(j - 1);\r\n                if (c1 == c2) {\r\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\r\n                } else {\r\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\r\n                }\r\n            }\r\n        }\r\n        return dp[m][n];\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/61#issuecomment-1667822322","body":"### 代码\r\n```java\r\nclass Solution {\r\n    static int[][] dirs = {{-2,-1}, {-2,1},{2,-1},{2,1},{-1,-2},{-1,2},{1,-2},{1,2}};\r\n\r\n    public double knightProbability(int n, int k, int row, int column) {\r\n        double[][][] dp = new double[k+1][n][n];\r\n        for(int step = 0; step <= k; step++){\r\n            for(int i = 0; i<n; i++){\r\n                for(int j = 0; j<n; j++){\r\n                    if(step == 0){\r\n                        dp[step][i][j] = 1;\r\n                    } else {\r\n                        for(int[] dir:dirs){\r\n                            int ni = i+dir[0], nj = j + dir[1];\r\n                            if(ni >= 0 && ni < n && nj >=0 && nj < n) {\r\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return dp[k][row][column];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/62#issuecomment-1669575904","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\r\n        if(maxChoosableInteger >= desiredTotal) return true;\r\n        if((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) return false;\r\n\r\n        return dfs(0, desiredTotal, new Boolean[1 << maxChoosableInteger], maxChoosableInteger);\r\n    }\r\n\r\n    private boolean dfs(int state, int desiredTotal, Boolean[] dp, int maxChoosableInteger){\r\n        if(dp[state] != null){\r\n            return dp[state];\r\n        }\r\n\r\n        for(int i = 1; i <= maxChoosableInteger; i++){\r\n            int cur = 1 << (i - 1);\r\n            if((cur & state) != 0){\r\n                continue;\r\n            }\r\n\r\n            if(i >= desiredTotal || !dfs(cur|state, desiredTotal - i, dp, maxChoosableInteger)){\r\n                return dp[state] = true;\r\n            }\r\n        }\r\n        return dp[state] = false;\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/63#issuecomment-1671413028","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public boolean canPartition(int[] nums) {\r\n        int n = nums.length;\r\n        if(n < 2){\r\n            return false;\r\n        }\r\n        int sum = 0, maxNum = 0;\r\n        for(int num: nums){\r\n            sum += num;\r\n            maxNum = Math.max(maxNum, num);\r\n        }\r\n        if(sum % 2 != 0){\r\n            return false;\r\n        }\r\n        int target = sum / 2;\r\n        if(maxNum > target){\r\n            return false;\r\n        }\r\n        boolean[] dp = new boolean[target+1];\r\n        dp[0] = true;\r\n        for(int i = 0; i<n; i++){\r\n            int num = nums[i];\r\n            for(int j= target; j >= num; j--){\r\n                dp[j] |= dp[j-num];\r\n            }\r\n        }\r\n        return dp[target];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/64#issuecomment-1673399917","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int findTargetSumWays(int[] nums, int target) {\r\n        int sum = 0;\r\n        for(int num:nums){\r\n            sum += num;\r\n        }\r\n        int diff = sum - target;\r\n        if(diff < 0 || diff % 2 != 0){\r\n            return 0;\r\n        }\r\n        int n = nums.length, neg = diff / 2;\r\n        int[][] dp = new int[n+1][neg+1];\r\n        dp[0][0] = 1;\r\n        for(int i = 1; i <= n; i++){\r\n            int num = nums[i - 1];\r\n            for(int j = 0; j <= neg; j++){\r\n                dp[i][j] = dp[i-1][j];\r\n                if(j >= num){\r\n                    dp[i][j] += dp[i-1][j-num];\r\n                }\r\n            }\r\n        }\r\n        return dp[n][neg];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/65#issuecomment-1674770558","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int coinChange(int[] coins, int amount) {\r\n        if(amount < 1){\r\n            return 0;\r\n        }\r\n        return coinChange(coins, amount, new int[amount]);\r\n    }\r\n    private int coinChange(int[] coins, int rem, int[] count){\r\n        if(rem < 0){\r\n            return -1;\r\n        }\r\n        if(rem == 0){\r\n            return 0;\r\n        }\r\n        if(count[rem - 1] != 0){\r\n            return count[rem - 1];\r\n        }\r\n        int min = Integer.MAX_VALUE;\r\n        for(int coin:coins){\r\n            int res = coinChange(coins, rem - coin, count);\r\n            if(res >= 0 && res < min){\r\n                min = 1 + res;\r\n            }\r\n        }\r\n        count[rem - 1] = (min == Integer.MAX_VALUE) ? -1 : min;\r\n        return count[rem - 1];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/66#issuecomment-1675961423","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int change(int amount, int[] coins) {\r\n        int[] dp = new int[amount+1];\r\n        dp[0] = 1;\r\n        for(int coin: coins){\r\n            for(int i = coin; i<=amount; i++){\r\n                dp[i] += dp[i - coin];\r\n            }\r\n        }\r\n        return dp[amount];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/67#issuecomment-1675995606","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int findContentChildren(int[] g, int[] s) {\r\n        // 1. 对两个数组进行排序\r\n        Arrays.sort(g);\r\n        Arrays.sort(s);\r\n        // 2. 记录满足的孩子数量\r\n        int child = 0;\r\n        int cookie = 0;\r\n        // 3. 遍历饼干数组\r\n        while (cookie < s.length && child < g.length ) {\r\n            if (s[cookie] >= g[child]) {\r\n                child++;\r\n            }\r\n            cookie++;\r\n        }\r\n        return child;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/68#issuecomment-1677530505","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int eraseOverlapIntervals(int[][] intervals) {\r\n        if(intervals.length == 0){\r\n            return 0;\r\n        }\r\n\r\n        Arrays.sort(intervals, new Comparator<int[]>(){\r\n            public int compare(int[] interval1, int[] interval2){\r\n                return interval1[1] - interval2[1];\r\n            }\r\n        });\r\n\r\n        int n = intervals.length;\r\n        int right = intervals[0][1];\r\n        int ans = 1;\r\n        for(int i = 1; i<n; i++){\r\n            if(intervals[i][0] >= right){\r\n                ans++;\r\n                right = intervals[i][1];\r\n            }\r\n        }\r\n        return n - ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/69#issuecomment-1679129057","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public boolean canJump(int[] nums) {\r\n        int n = nums.length;\r\n        int maxPosition = 0;\r\n        for (int i = 0; i < n && maxPosition < n - 1; i++) {\r\n            if (maxPosition < i) {\r\n                return false;\r\n            }\r\n            maxPosition = Math.max(maxPosition, i + nums[i]);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/70#issuecomment-1680780054","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int numTrees(int n) {\r\n        int[] G = new int[n + 1];\r\n        G[0] = 1;\r\n        G[1] = 1;\r\n        for(int i = 2; i<=n; i++){\r\n            for(int j = 1; j<=i; j++){\r\n                G[i] += G[j - 1] * G[i - j];\r\n            }\r\n        }\r\n        return G[n];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/71#issuecomment-1682268579","body":"### 代码\r\n```java\r\nclass Solution {\r\n    class Status implements Comparable<Status>{\r\n        int val;\r\n        ListNode ptr;\r\n        Status(int val, ListNode ptr){\r\n            this.val = val;\r\n            this.ptr = ptr;\r\n        }\r\n        public int compareTo(Status status2){\r\n            return this.val - status2.val;\r\n        }\r\n    }\r\n    PriorityQueue<Status> queue = new PriorityQueue<Status>();\r\n\r\n    public ListNode mergeKLists(ListNode[] lists) {\r\n        for(ListNode node: lists){\r\n            if(node != null){\r\n                queue.offer(new Status(node.val, node));\r\n            }\r\n        }\r\n        ListNode head = new ListNode(0);\r\n        ListNode tail = head;\r\n        while(!queue.isEmpty()){\r\n            Status f = queue.poll();\r\n            tail.next = f.ptr;\r\n            tail = tail.next;\r\n            if(f.ptr.next != null){\r\n                queue.offer(new Status(f.ptr.next.val, f.ptr.next));\r\n            }\r\n        }\r\n        return head.next;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/72#issuecomment-1684100510","body":"### 代码\r\n```java\r\nclass Solution {\r\n    Map<Integer, int[]> memo;\r\n    public int[] beautifulArray(int n) {\r\n        memo = new HashMap();\r\n        return f(n);\r\n    }\r\n    public int[] f(int n){\r\n        if(memo.containsKey(n)){\r\n            return memo.get(n);\r\n        }\r\n\r\n        int[] ans = new int[n];\r\n        if(n == 1){\r\n            ans[0] = 1;\r\n        } else {\r\n            int t = 0;\r\n            for(int x: f((n+1)/2)){\r\n                ans[t++] = 2*x-1;\r\n            } \r\n            for(int x:f(n/2)){\r\n                ans[t++] = 2*x;\r\n            }\r\n        }\r\n        memo.put(n, ans);\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/73#issuecomment-1685030065","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] singleNumber(int[] nums) {\r\n        int xor = 0;\r\n        for(int num : nums){\r\n            xor ^= num;\r\n        }\r\n        int mask = 1;\r\n        while((mask & xor) == 0){\r\n            mask <<= 1;\r\n        }\r\n        int[] res = new int[2];\r\n        for(int num: nums){\r\n            if((i & mask) == 0){\r\n                res[0] ^= i;\r\n            } else {\r\n                res[1] ^= i;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/74#issuecomment-1685309809","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public List<List<Integer>> subsets(int[] nums) {\r\n        List<List<Integer>> res = new LinkedList<>();\r\n        int start = 0, end = 1 << nums.length;\r\n        for(int sign = start; sign < end; sign++){\r\n            List<Integer> list = new LinkedList<>();\r\n            for(int i = 0; i<nums.length; i++){\r\n                if(((1<<i) & sign) != 0){\r\n                    list.add(nums[i]);\r\n                }\r\n            }\r\n                res.add(list);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/75#issuecomment-1686478202","body":"### 代码\r\n```java\r\nclass Trie {\r\n    TrieNode root;\r\n    public Trie() {\r\n         root = new TrieNode();\r\n    }\r\n    \r\n    public void insert(String word) {\r\n         TrieNode node = root;\r\n\r\n        for (int i = 0; i < word.length(); i++) {\r\n\r\n            if (node.children[word.charAt(i) - 'a'] == null)\r\n                node.children[word.charAt(i) - 'a'] = new TrieNode();\r\n\r\n            node = node.children[word.charAt(i) - 'a'];\r\n            node.preCount++;\r\n        }\r\n\r\n        node.count++;\r\n    }\r\n    \r\n    public boolean search(String word) {\r\n        \r\n        TrieNode node = root;\r\n\r\n        for (int i = 0; i < word.length(); i++) {\r\n\r\n            if (node.children[word.charAt(i) - 'a'] == null)\r\n                return false;\r\n\r\n            node = node.children[word.charAt(i) - 'a'];\r\n        }\r\n\r\n        return node.count > 0;\r\n    }\r\n    \r\n    public boolean startsWith(String prefix) {\r\n        \r\n        TrieNode node = root;\r\n\r\n        for (int i = 0; i < prefix.length(); i++) {\r\n\r\n            if (node.children[prefix.charAt(i) - 'a'] == null)\r\n                return false;\r\n            node = node.children[prefix.charAt(i) - 'a'];\r\n        }\r\n\r\n        return node.preCount > 0;\r\n    }\r\n     private class TrieNode {\r\n\r\n        int count; //表示以该处节点构成的串的个数\r\n        int preCount; //表示以该处节点构成的前缀的字串的个数\r\n        TrieNode[] children;\r\n\r\n        TrieNode() {\r\n\r\n            children = new TrieNode[26];\r\n            count = 0;\r\n            preCount = 0;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/76#issuecomment-1688262655","body":"### 代码\r\n```java\r\nclass MapSum {\r\n    Map<String, Integer> map;\r\n    Map<String, Integer> prefixmap;\r\n    public MapSum() {\r\n        map = new HashMap<>();\r\n        prefixmap = new HashMap<>();\r\n    }\r\n    \r\n    public void insert(String key, int val) {\r\n        int detal = val - map.getOrDefault(key, 0);\r\n        map.put(key, val);\r\n        for(int i = 1; i<=key.length(); i++){\r\n            String cur = key.substring(0,i);\r\n            prefixmap.put(cur, prefixmap.getOrDefault(cur, 0) +detal);\r\n        }\r\n    }\r\n    \r\n    public int sum(String prefix) {\r\n        return prefixmap.getOrDefault(prefix, 0);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/77#issuecomment-1690183975","body":"### 代码\r\n```java\r\nclass Solution {\r\n\r\n    class Trie{\r\n        TrieNode root;\r\n        public Trie(String[] words){\r\n            root = new TrieNode();\r\n            for(String word : words){\r\n                TrieNode node = root;\r\n                for(char w : word.toCharArray()){\r\n                    int i = w - 'a';\r\n                    if(node.next[i] == null){\r\n                        node.next[i] = new TrieNode();\r\n                    }\r\n                    node = node.next[i];\r\n                }\r\n                node.end = word;\r\n            }\r\n        }\r\n\r\n        public List<String> search(String str){\r\n            TrieNode node = root;\r\n            List<String> res = new ArrayList<>();\r\n            for(char c : str.toCharArray()){\r\n                int i = c - 'a';\r\n                if(node.next[i] == null){\r\n                    break;\r\n                }\r\n                node = node.next[i];\r\n                if(node.end != null){\r\n                    res.add(node.end);\r\n                }\r\n            }\r\n            return res;\r\n        }  \r\n    }\r\n\r\n    class TrieNode{\r\n        String end;\r\n        TrieNode[] next = new TrieNode[26];\r\n    }\r\n\r\n\r\n    public int[][] multiSearch(String big, String[] smalls) {\r\n        Trie trie = new Trie(smalls);\r\n        Map<String, List<Integer>> hit = new HashMap<>();\r\n        for(int i = 0; i < big.length(); i++){\r\n            List<String> matchs = trie.search(big.substring(i));\r\n            for(String word: matchs){\r\n                if(!hit.containsKey(word)){\r\n                    hit.put(word, new ArrayList<>());\r\n                }\r\n                hit.get(word).add(i);\r\n            }\r\n        }\r\n        \r\n        int[][] res = new int[smalls.length][];\r\n        for(int i = 0; i < smalls.length; i++){\r\n            List<Integer> list = hit.get(smalls[i]);\r\n            if(list == null){\r\n                res[i] = new int[0];\r\n                continue;\r\n            }\r\n            int size = list.size();\r\n            res[i] = new int[size];\r\n            for(int j = 0; j < size; j++){\r\n                res[i][j] = list.get(j);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/78#issuecomment-1691534013","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int findCircleNum(int[][] isConnected) {\r\n        int cities = isConnected.length;\r\n        boolean[] visited = new boolean[cities];\r\n        int provinces = 0;\r\n        Queue<Integer> q = new LinkedList<Integer>();\r\n        for(int i = 0; i<cities; i++){\r\n            if(!visited[i]) {\r\n                q.offer(i);\r\n                while(!q.isEmpty()){\r\n                    int j = q.poll();\r\n                    visited[j] = true;\r\n                    for(int k = 0; k < cities; k++){\r\n                        if(isConnected[j][k] == 1 && !visited[k]){\r\n                            q.offer(k);\r\n                        }\r\n                    }\r\n                }\r\n                provinces++;\r\n            }\r\n        }\r\n        return provinces;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/79#issuecomment-1693558370","body":"### 代码\r\n```java\r\nclass Solution {\r\n\tint n;\r\n\r\n\tint[] p;// 并查集root\r\n\tint[] s;// 连通节点数量\r\n\tint[] m;// 感染节点数量\r\n\tint[] o;// 感染来源\r\n\r\n\tpublic int minMalwareSpread(int[][] graph, int[] initial) {\r\n\t\t// 初始化并查集\r\n\t\tn = graph.length;\r\n\t\tp = new int[n];\r\n\t\ts = new int[n];\r\n\t\tm = new int[n];\r\n\t\to = new int[n];\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tp[i] = i;\r\n\t\t\ts[i] = 1;\r\n\t\t}\r\n\t\t// 连通节点，记录连通节点数量\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tfor (int j = 0; j < n; j++) {\r\n\t\t\t\tif (graph[i][j] == 1) {\r\n\t\t\t\t\tint pi = find(i), pj = find(j);\r\n\t\t\t\t\tif (pi == pj)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tint si = s[pi], sj = s[pj];\r\n\t\t\t\t\tp[pi] = pj;\r\n\t\t\t\t\ts[pj] = si + sj;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 每个连通块的感染数量\r\n\t\tint min = Integer.MAX_VALUE;\r\n\t\tfor (int i = 0; i < initial.length; i++) {\r\n\t\t\tint cur = find(initial[i]);\r\n\t\t\tm[cur]++;\r\n\t\t\to[cur] = initial[i];\r\n\t\t\tmin = Math.min(min, initial[i]);\r\n\t\t}\r\n\t\tint ansi = -1, anss = -1;\r\n\t\t// 只有感染数量是1的有救，这其中联通最大的最值得救，先出先算\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tif (m[i] == 1) {\r\n\t\t\t\tif (s[i] > anss) {\r\n\t\t\t\t\tansi = o[i];\r\n\t\t\t\t\tanss = s[i];\r\n\t\t\t\t} else if (s[i] == anss && o[i] < ansi) {\r\n\t\t\t\t\tansi = o[i];// 感染源小的\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ansi == -1 ? min : ansi;\r\n\t}\r\n\r\n\tprivate int find(int index) {\r\n\t\tif (p[index] != index) {\r\n\t\t\tp[index] = find(p[index]);\r\n\t\t}\r\n\t\treturn p[index];\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/80#issuecomment-1694387241","body":"### 代码\r\n```java\r\nclass Solution {\r\n    List<Integer>[] edges;\r\n    boolean[] used;\r\n    public int makeConnected(int n, int[][] connections) {\r\n        if(connections.length < n - 1){\r\n            return -1;\r\n        }\r\n        edges = new List[n];\r\n        for(int i = 0; i<n; i++){\r\n            edges[i] = new ArrayList<Integer>();\r\n        }\r\n        for(int[] conn: connections){\r\n            edges[conn[0]].add(conn[1]);\r\n            edges[conn[1]].add(conn[0]);\r\n        }\r\n        used = new boolean[n];\r\n        int ans = 0;\r\n        for(int i = 0; i<n; i++){\r\n            if(!used[i]){\r\n                dfs(i);\r\n                ans++;\r\n            }\r\n        }\r\n        return ans - 1;\r\n    }\r\n    private void dfs(int u){\r\n        used[u] = true;\r\n        for(int v : edges[u]){\r\n            if(!used[v]){\r\n                dfs(v);\r\n            }\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/81#issuecomment-1694668466","body":"### 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode pruneTree(TreeNode root) {\r\n        if(root == null){\r\n            return null;\r\n        }\r\n        root.left = pruneTree(root.left);\r\n        root.right = pruneTree(root.right);\r\n        if(root.left == null && root.right == null && root.val == 0){\r\n            return null;\r\n        }\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/82#issuecomment-1695895171","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\r\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\r\n        List<Integer> combine = new ArrayList<Integer>();\r\n        dfs(candidates, target, ans, combine, 0);\r\n        return ans;\r\n    }\r\n    private void dfs(int[] candidates, int target, List<List<Integer>> ans, List<Integer> combine, int idx){\r\n        if(idx == candidates.length){\r\n            return;\r\n        }\r\n        if(target == 0){\r\n            ans.add(new ArrayList<Integer>(combine));\r\n            return;\r\n        }\r\n        // 跳过\r\n        dfs(candidates, target, ans, combine, idx+1);\r\n        // 选择当前数\r\n        if(target - candidates[idx] >= 0){\r\n            combine.add(candidates[idx]);\r\n            dfs(candidates, target - candidates[idx], ans, combine, idx);\r\n            combine.remove(combine.size() - 1);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/83#issuecomment-1697560892","body":"### 代码\r\n```java\r\nclass Solution {\r\n    List<int[]> freq = new ArrayList<int[]>();\r\n    List<List<Integer>> ans = new ArrayList<List<Integer>>();\r\n    List<Integer> sequence = new ArrayList<Integer>();\r\n\r\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\r\n        Arrays.sort(candidates);\r\n        for(int num:candidates){\r\n            int size = freq.size();\r\n            if(freq.isEmpty() || num != freq.get(size - 1)[0]){\r\n                freq.add(new int[]{num, 1});\r\n            } else {\r\n                freq.get(size - 1)[1]++;\r\n            }\r\n        }\r\n        dfs(0, target);\r\n        return ans;\r\n    }\r\n\r\n    public void dfs(int pos, int rest){\r\n        if(rest == 0){\r\n            ans.add(new ArrayList<Integer>(sequence));\r\n            return;\r\n        }\r\n        if(pos == freq.size() || rest < freq.get(pos)[0]){\r\n            return;\r\n        }\r\n\r\n        dfs(pos + 1, rest);\r\n        int most = Math.min(rest / freq.get(pos)[0], freq.get(pos)[1]);\r\n        for(int i = 1; i <= most; ++i){\r\n            sequence.add(freq.get(pos)[0]);\r\n            dfs(pos + 1, rest - i * freq.get(pos)[0]);\r\n        }\r\n        for(int i = 1; i <= most; ++i){\r\n            sequence.remove(sequence.size() - 1);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/84#issuecomment-1699436478","body":"### 代码\r\n```java\r\nclass Solution {\r\n    boolean[] vis;\r\n\r\n    public List<List<Integer>> permuteUnique(int[] nums) {\r\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\r\n        List<Integer> perm = new ArrayList<Integer>();\r\n        vis = new boolean[nums.length];\r\n        Arrays.sort(nums);\r\n        backtrack(nums, ans, 0, perm);\r\n        return ans;\r\n    }\r\n\r\n    public void backtrack(int[] nums, List<List<Integer>> ans, int idx, List<Integer> perm) {\r\n        if (idx == nums.length) {\r\n            ans.add(new ArrayList<Integer>(perm));\r\n            return;\r\n        }\r\n        for (int i = 0; i < nums.length; ++i) {\r\n            if (vis[i] || (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1])) {\r\n                continue;\r\n            }\r\n            perm.add(nums[i]);\r\n            vis[i] = true;\r\n            backtrack(nums, ans, idx + 1, perm);\r\n            vis[i] = false;\r\n            perm.remove(idx);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/85#issuecomment-1700917828","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int strStr(String ss, String pp) {\r\n        int n = ss.length(), m = pp.length();\r\n        char[] s = ss.toCharArray(), p = pp.toCharArray();\r\n        // 枚举原串的「发起点」\r\n        for (int i = 0; i <= n - m; i++) {\r\n            // 从原串的「发起点」和匹配串的「首位」开始，尝试匹配\r\n            int a = i, b = 0;\r\n            while (b < m && s[a] == p[b]) {\r\n                a++;\r\n                b++;\r\n            }\r\n            // 如果能够完全匹配，返回原串的「发起点」下标\r\n            if (b == m) return i;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/86#issuecomment-1702869524","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int strStr(String ss, String pp) {\r\n        int n = ss.length(), m = pp.length();\r\n        char[] s = ss.toCharArray(), p = pp.toCharArray();\r\n        // 枚举原串的「发起点」\r\n        for (int i = 0; i <= n - m; i++) {\r\n            // 从原串的「发起点」和匹配串的「首位」开始，尝试匹配\r\n            int a = i, b = 0;\r\n            while (b < m && s[a] == p[b]) {\r\n                a++;\r\n                b++;\r\n            }\r\n            // 如果能够完全匹配，返回原串的「发起点」下标\r\n            if (b == m) return i;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/87#issuecomment-1703728388","body":"### 代码\r\n```java\r\nclass Solution {\r\n    int quickselect(int[] nums, int l, int r, int k) {\r\n        if (l == r) return nums[k];\r\n        int x = nums[l], i = l - 1, j = r + 1;\r\n        while (i < j) {\r\n            do i++; while (nums[i] < x);\r\n            do j--; while (nums[j] > x);\r\n            if (i < j){\r\n                int tmp = nums[i];\r\n                nums[i] = nums[j];\r\n                nums[j] = tmp;\r\n            }\r\n        }\r\n        if (k <= j) return quickselect(nums, l, j, k);\r\n        else return quickselect(nums, j + 1, r, k);\r\n    }\r\n    public int findKthLargest(int[] _nums, int k) {\r\n        int n = _nums.length;\r\n        return quickselect(_nums, 0, n - 1, n - k);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/88#issuecomment-1704306573","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int lastStoneWeight(int[] stones) {\r\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b) -> b - a);\r\n        for(int stone:stones){\r\n            pq.offer(stone);\r\n        }\r\n\r\n        while(pq.size() > 1){\r\n            int a = pq.poll();\r\n            int b = pq.poll();\r\n            if(a>b){\r\n                pq.offer(a - b);\r\n            }\r\n        }\r\n        return pq.isEmpty() ? 0 : pq.poll();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/89#issuecomment-1705451544","body":"### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    class Status implements Comparable<Status>{\r\n        int val;\r\n        ListNode ptr;\r\n        Status(int val, ListNode ptr){\r\n            this.val = val;\r\n            this.ptr = ptr;\r\n        }\r\n        public int compareTo(Status status2){\r\n            return this.val - status2.val;\r\n        }\r\n    }\r\n    PriorityQueue<Status> queue = new PriorityQueue<Status>();\r\n\r\n    public ListNode mergeKLists(ListNode[] lists) {\r\n        for(ListNode node: lists){\r\n            if(node != null){\r\n                queue.offer(new Status(node.val, node));\r\n            }\r\n        }\r\n        ListNode head = new ListNode(0);\r\n        ListNode tail = head;\r\n        while(!queue.isEmpty()){\r\n            Status f = queue.poll();\r\n            tail.next = f.ptr;\r\n            tail = tail.next;\r\n            if(f.ptr.next != null){\r\n                queue.offer(new Status(f.ptr.next.val, f.ptr.next));\r\n            }\r\n        }\r\n        return head.next;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null],"kangliqi1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richardtaok":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chocolate-emperor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lydia61":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangjiahuan17":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"seanutf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyong-hub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erquaner":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiujingxukong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x1aox1a":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"drinkmorekaik":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dinjufen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzmt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"munmust":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan-jie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hktangshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpbc007":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linlizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"krabbejing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"firehaosky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chao-cc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cruiseyugh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quieter2018":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jadeliu13":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoq777":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangyanlineu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxiner":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufanzh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"franciszq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangqinsen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"manwzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"soso1105":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585270363","body":"### 思路\n\n通过字符串与int之间的转换形成\n\n### 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        resStr = \"\"\n        for i in num:\n            resStr +=str(i)\n        res = str(int(resStr)+k)\n        reslist = []\n        for i in res:\n            reslist.append(int(i))\n        return reslist\n```\n\n**复杂度分析**\n\n\\- 时间复杂度：*O*(*n*)\n\\- 空间复杂度：*O*(*n*)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1585931055","body":"### 思路\n\n数组的遍历\n\n### 代码\n\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        indexList = []\n        for index,val in enumerate(s):\n            if val == c:\n                indexList.append(index)\n        resList = []\n        p = 0\n        # print(indexList)\n        for index,val in enumerate(s):\n            # print(index)\n            if p < len(indexList)-1 and (abs(index-indexList[p]) > abs(index-indexList[p+1])):\n                p += 1\n            resList.append(abs(index-indexList[p]))\n        return resList\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586373223","body":"### 思路\n\npop时把栈顶元素弹出\n\n### 代码\n\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = 0\n        self.maxSize = maxSize\n        self.customStack = []\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.customStack.append(x)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        temp = self.customStack[self.size - 1]\n        del self.customStack[self.size - 1]\n        self.size -= 1\n        return temp\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.size)):\n            self.customStack[i] += val\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1588256328","body":"### 思路\n\n用python中的正则表达式实现（逐层替换）\n\n### 代码\n\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        while '[' in s:\n            s = re.sub(r'(\\d+)\\[([A-Za-z]*)\\]', lambda m:int(m.group(1)) * m.group(2), s)\n        return s\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590311836","body":"### 思路\n\n使用两个栈来实现队列。\n\n### 代码\n\n\n```python\nclass Stack(object):\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x):              # 入栈\n        self.stack.append(x)\n\n    def pop(self):                  # 出栈\n        if self.is_empty:           # 注意特殊情况\n            return None\n        return self.stack.pop()\n\n    @property\n    def length(self):               # 获取栈中元素\n        return len(self.stack)\n    \n    @property                      \n    def is_empty(self):            # 获取栈的状态：是否为空\n        return self.length == 0\n\n\nclass MyQueue(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = Stack()                           # 基本栈\n        self.stack2 = Stack()                           # 辅助栈\n\n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.push(x)                      # 入栈，即入队列\n\n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        while self.stack1.length > 1:                   \n            self.stack2.push(self.stack1.pop())         \n        res = self.stack1.pop()                         \n        while not self.stack2.is_empty:                 \n            self.stack1.push(self.stack2.pop())         \n        return res                                      \n\n    def peek(self):\n        \"\"\"\n        Get the front element.\n        :rtype: int\n        \"\"\"\n        while self.stack1.length > 1:                  \n            self.stack2.push(self.stack1.pop())         \n        res = self.stack1.pop()                         \n        self.stack2.push(res)                           \n        while self.stack2.length > 0:                   \n            self.stack1.push(self.stack2.pop())         \n        return res                                      \n\n    def empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        return self.stack1.is_empty                     \n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592171301","body":"### 思路\n\n通过单调栈实现逻辑\n\n### 代码\n\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i in arr:\n            if stack and stack[-1]>i:\n                cur = stack[-1]\n                while stack and stack[-1]>i:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(i)\n        return len(stack)\n\n\n\nif __name__ == '__main__':\n    arr = [5,4,3,2,1]\n    result = Solution().maxChunksToSorted(arr)\n    print(result)\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1593829281","body":"### 思路\n\n1.用快慢指针确定旋转后链表的头节点\n若链表的长度为n，让快指针先走k%n步，然后快慢指针同时向前走，直到快指针的next为空，此时慢指针的next为旋转后链表的头节点\n2.移花接木\n快指针的next指向原链表的头节点head\nhead指向慢指针的next，作为新链表的头节点返回\n断掉慢指针和head之间的链，否则会形成环\n\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        fast, slow = head, head\n        # 找到fast的起始节点\n        def findStart(fast, k):\n            length = 0\n            while k>0:\n                k -= 1\n                length += 1\n                fast = fast.next\n                if not fast:\n                    fast = head                                    \n                    k = k % length                    \n                    return findStart(fast, k)\n            return fast\n                   \n        fast = findStart(fast, k)\n         \n        while fast and fast.next:           \n            fast = fast.next\n            slow = slow.next\n   \n        fast.next = head\n        head = slow.next\n        slow.next = None\n        return head\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595760793","body":"### 思路\n\n递归\n\n### 代码\n\n```python\nclass Solution:\n   def swapPairs(self, head: ListNode) -> ListNode:\n       if not head or not head.next: return head\n\n       next = head.next\n       head.next = self.swapPairs(next.next)\n       next.next = head\n\n       return next\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596123405","body":"### 思路\n\n快慢指针。使用快慢指针找到链表的中间节点，即为二叉搜索树的根节点，然后递归链表左半部分和右半部分\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if head is None:\n            return None\n        if head.next is None:\n            return TreeNode(head.val)\n        slow = ListNode(-1)\n        slow.next = head\n        fast = head\n        while fast is not None:\n            last = slow\n            slow = slow.next\n            fast = fast.next.next if fast.next is not None else None\n        last.next = None\n        right = slow.next\n        slow.next = None\n        root = TreeNode(slow.val)\n        if slow is not head:\n            root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(right)\n        return root \n```\n\n**复杂度分析**\n\n- 时间复杂度：O(NLogN)\n- 空间复杂度：O(LogN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596298944","body":"### 思路\n\n双指针\n\n### 代码\n\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a = headA\n        b = headB\n        while a!=b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598827807","body":"### 思路\n\n使用额外的数组存储已访问过的节点，当某时刻访问时判断当前节点的`next`是否已出现过\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head: return None\n\n        res = []\n        while head.next:\n            if head.next in res:\n                return res[res.index(head.next)]\n            res.append(head)\n            head = head.next\n\n        return None\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600833477","body":"### 思路\n\n哈希表、双向链表\n\n### 代码\n\n```python\nclass Node(object):\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass DoubleLinkedList(object):\n    def __init__(self):\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.size = 0\n    \n    def add_to_head(self, node):\n        \"\"\"添加节点到头部\n        \"\"\"\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n        self.size += 1\n    \n    def remove_node(self, node):\n        \"\"\"删除节点\n        \"\"\"\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        self.size -= 1\n    \n    def remove_tail(self):\n        \"\"\"删除尾部节点\n        \"\"\"\n        if self.size == 0:\n            return None\n        node = self.tail.prev\n        self.remove_node(node)\n        return node\n    \n    def get_size(self):\n        return self.size\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        self.cache = DoubleLinkedList()\n\n    def get(self, key: int) -> int:\n        # 判断 key 是否存在，分情况处理\n        if key not in self.hashmap:\n            return -1\n        # 通过哈希表定位其在双向链表的位置\n        value = self.hashmap[key].value\n        # 这里实现的逻辑在 put 操作体现\n        # put 操作在键存在时，同样需要移至链表头部\n        self.put(key, value)\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        # 先创建节点\n        node = Node(key, value)\n        # 同样判断 key 是否存在\n        # 分情况处理\n        if key in self.hashmap:\n            self.cache.remove_node(self.hashmap[key])\n            self.cache.add_to_head(node)\n            self.hashmap[key] = node\n        else:\n            # 判断缓存容量是否不够\n            if self.capacity == self.cache.get_size():\n                # 删除最后的节点\n                tail = self.cache.remove_tail()\n                self.hashmap.pop(tail.key)\n            # 添加到头部\n            self.cache.add_to_head(node)\n            self.hashmap[key] = node\n\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1601747721","body":"### 思路\n\n递归去计算左右子树的最大深度，当遇到叶子节点时，退出递归。\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        left_tree_depth = self.maxDepth(root.left)\n        right_tree_depth = self.maxDepth(root.right)\n\n        return max(left_tree_depth, right_tree_depth) + 1\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1603318989","body":"### 思路\n\n通过分别遍历两棵树来获取它们的遍历序列（前序遍历、中序遍历和后序遍历均可），然后判断序列是否相同即可。\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p == None and q == None: return True\n        if p == None or q == None: return False\n\n        r1, r2 = [], []\n        def inorder(root, index):\n            if root == None:\n                if index == 1: r1.append(-1)\n                else: r2.append(-1)\n                return None\n\n            if index == 1: r1.append(root.val)\n            else: r2.append(root.val)\n            inorder(root.left, index)\n            inorder(root.right, index)\n\n        inorder(p, 1)\n        inorder(q, 2)\n        \n        return r1 == r2 \n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1604974679","body":"### 思路\n\n二叉树先序遍历\n用数组存储所有二叉树路径的字符串，最后转换为整数后求和\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        path = ''\n        result = []\n        \n        self.helper(root, path, result)\n        \n        return sum([int(path) for path in result])\n    \n    def helper(self, root, path, result):\n        if not root:\n            return \n        \n        path += str(root.val)\n        \n        if not root.left and not root.right:\n            result.append(path)\n            \n        self.helper(root.left, path, result)\n        self.helper(root.right, path, result)\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605752424","body":"### 思路\n\n找到树的最后一行，找到那一行的第一个节点\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = collections.deque()\n        queue.append(root)\n        while queue:\n            length = len(queue)\n            res = queue[0].val\n            for _ in range(length):\n                cur = queue.popleft()\n                if cur.left:\n                    queue.append(cur.left)\n                if cur.right:\n                    queue.append(cur.right)\n        return res\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607271806","body":"### 思路\n\n用三个指针分别指向数组第一项，第二项和第三项（如果存在的话），这里用 p1，p2，p3 来标记，分别表示当前处理的节点，当前处理的节点的左子节点和当前处理的节点的右子节点。\np1 每次移动一位，p2 和 p3 每次移动两位。\np1.left = p2; p1.right = p3。\n持续上面的步骤直到 p1 移动到最后。\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Codec:\n    def serialize(self, root):\n        ans = ''\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node:\n                ans += str(node.val) + ','\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                ans += '#,'\n        print(ans[:-1])\n        return ans[:-1]\n\n\n\n    def deserialize(self, data: str):\n        if data == '#': return None\n        nodes = data.split(',')\n        if not nodes: return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        # 已经有 root 了，因此从 1 开始\n        i = 1\n\n        while i < len(nodes) - 1:\n            node = queue.pop(0)\n            lv = nodes[i]\n            rv = nodes[i + 1]\n            i += 2\n            if lv != '#':\n                l = TreeNode(lv)\n                node.left = l\n                queue.append(l)\n\n            if rv != '#':\n                r = TreeNode(rv)\n                node.right = r\n                queue.append(r)\n        return root\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1608455364","body":"### 思路\n\nDFS，BFS\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        seen = collections.defaultdict(\n            lambda: collections.defaultdict(list))\n\n        def dfs(root, x=0, y=0):\n            if not root:\n                return\n            seen[x][y].append(root.val)\n            dfs(root.left, x-1, y+1)\n            dfs(root.right, x+1, y+1)\n\n        dfs(root)\n        ans = []\n        # x 排序、\n        for x in sorted(seen):\n            level = []\n            # y 排序\n            for y in sorted(seen[x]):\n                # 值排序\n                level += sorted(v for v in seen[x][y])\n            ans.append(level)\n\n        return ans\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1611508105","body":"### 思路\n\n哈希表\n\n### 代码\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        records = dict()\n\n        # 用枚举更方便，就不需要通过索引再去取当前位置的值\n        for idx, val in enumerate(nums):\n            if target - val not in records:\n                records[val] = idx\n            else:\n                return [records[target - val], idx] # 如果存在就返回字典记录索\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1616161672","body":"### 思路\r\n\r\n哈希表+堆栈\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        seen={}#哈希表存元素\r\n        for num in nums:\r\n            seen[num]=seen.get(num,0)+1\r\n        #建堆\r\n        heap=[]\r\n        for num,freq in seen.items():\r\n            #把数字和频率作为一个元组加到堆中\r\n            \r\n            heapq.heappush(heap,(freq,num))\r\n            #如果堆中元素超过k，则移除频率最低的元素\r\n            if len(heap)>k:\r\n                heapq.heappop(heap)\r\n        #将堆中剩余元素按频率从高到低加入到列表中，降序排序\r\n        res=[]\r\n        for i in range(k-1,-1,-1):\r\n            res.append(heapq.heappop(heap)[1])\r\n\r\n        return res[::-1]\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1616162633","body":"### 思路\r\n\r\n我们需要对所有点进行遍历，用一个字典统计该点与其他点的距离，字典的键是两点欧氏距离的平方，字典的值是该距离出现的次数；\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points):\r\n        res = 0\r\n        for p1 in points:\r\n\r\n            # 定义一个距离计数器，用于统计每一个距离出现的次数\r\n            dist_dict = {}\r\n\r\n            for p2 in points:\r\n\r\n                dist = (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2      # 计算p1和p2点距离的平方\r\n\r\n                dist_dict[dist] = dist_dict[dist] + 1 if dist in dist_dict else 1   # 更新字典中距离计数器\r\n\r\n            for val in dist_dict.values():                      # 遍历每一个出现的距离\r\n                if val >= 2:                                    # 如果出现次数大于等于2\r\n                    res += val*(val-1)                          # 那么把当前两两组合的结果加入res中\r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N^2)\r\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1616162956","body":"### 思路\r\n\r\n哈希表+滑动窗口\r\n\r\n### 代码\r\n\r\n```python\r\nimport collections\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        seen={}#collections.defaultdict()创建哈希表\r\n        left=right=0#创建双指针\r\n        ans=0\r\n        for char in range(len(s)):\r\n            char=s[right]\r\n            right+=1\r\n            seen[char]=seen.get(char,0)+1#求哈希表窗口里面元素的频率\r\n            while seen[char]>1:#先判断左边是够需要收缩，右边是确定了吗\r\n                left0=s[left]\r\n                left+=1\r\n                seen[left0]-=1\r\n            ans=max(ans,right-left)      \r\n            #seen[char].append()\r\n        return ans\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616161359","body":"### 思路\n\n滑动窗口\n\n### 代码\n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n\n        # 处理特殊情况\n        if not s or not words:\n            return []\n        \n        # 哈希表统计单词出现次数，用以后续比较\n        word_cnt = Counter(words)\n        \n        # 单词长度\n        word_len = len(words[0])\n\n        # 返回结果列表\n        ans = []\n\n        # 遍历，进行窗口滑动\n        for i in range(word_len):\n            left = i\n            right = i\n            cnt = 0\n\n            # 哈希表记录窗口的单词出现次数\n            window = Counter()\n\n            # 限定边界\n            # 这里表示窗口的内容不足以组成串联所有单词的子串，循环结束\n            while left + len(words) * word_len <= len(s):\n                # 窗口单词出现的次数，与 word_cnt 对比\n                while cnt <  len(words):\n                    word = s[right:right+word_len]\n                    # 如果单词不在 words 中，或者此时单词数量大于 words 中的单词数量时，退出循环另外处理\n                    # 单词次数相等也跳出另外判断\n                    # 否则更新哈希表 window\n                    if (word not in words) or (window[word] >= word_cnt[word]):\n                        break\n                    window[word] += 1\n                    cnt += 1\n                    right += word_len\n                \n                # 先判断哈希表是否相等，相等则加入返回列表中\n                if word_cnt == window:\n                    ans.append(left)\n\n                # 再处理单词数溢出的情况\n                # 区分在于单词是否在 words 中\n                if word in words:\n                    # 剔除左边部分\n                    left_word = s[left: left+word_len]\n                    window[left_word] -= 1\n                    left += word_len\n                    cnt -= 1\n                    \n                else:\n                    # 如果单词不在 words 中，\n                    # 清空哈希表，重置窗口开始位置\n                    right += word_len\n                    window.clear()\n                    left = right\n                    cnt = 0\n\n        return ans\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1617072872","body":"### 思路\n\n要移除的连续子数组的和对p求余要等于数组总和对p求余。\n\n### 代码\n\n```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        x = sum(nums) % p\n        if x == 0:\n            return 0\n        n = len(nums) \n        d = defaultdict(lambda:-1)\n        cur_sum = 0\n        d[0] = 0\n        ans = n\n        for i in range(n):\n            cur_sum += nums[i]\n            temp =  (cur_sum % p - x + p)%p\n            if d[temp] != -1:\n                ans = min(ans,i+1-d[temp]) \n            d[cur_sum % p] = i+1\n        return -1 if ans == n else ans\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1619336792","body":"### 思路\n\n定义快慢指针，同时从头结点开始向后遍历，快指针每次走两步，慢指针每次走一步，当快指针走到末尾结点时，慢指针恰好走到中间结点。\n\n### 代码\n\n```python\nclass Solution:\n    def middleNode(self, head):\n        \"\"\"\n        :param head: ListNode\n        :return: ListNode\n        \"\"\"\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1620816944","body":"### 思路\n\n双指针法\n\n### 代码\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        p = 0\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n               continue\n            else:\n                p += 1\n                nums[p] = nums[i]\n        # 题目要求返回的是长度，所有坐标要加 1\n        return p + 1\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1623157575","body":"### 思路\n\n将整个数组看成一条线段，将这条线断从中间切开，查看线段中间位置所在的值和插入数之间的大小关系，根据此大小关系可以抛弃一半线段。\n\n### 代码\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)-1            # 初始化左右端点位置\n        while left <= right:                    # 当条件合法时\n            mid = left + (right - left) // 2    # 获取中点，如果是偶数取靠左的位置\n            if nums[mid] == target:             # 找到该数\n                return mid                      # 直接返回\n            elif nums[mid] > target:            # 如果当前位置数比插入值大\n                right = mid - 1                 # 更新右端点\n            else:                               # 如果当前位置数比插入值小\n                left = mid + 1                  # 更新左端点\n        return left  \n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1624426260","body":"### 思路\n\n用一个数组index记录滑动窗口中可能是最大值的下标\n第一个窗口的index中只保留3和-1的下标，因为有3在，1不可能是最大值\n第三个窗口的index中只保留5的下标，因为有5在，-1和-3在滑动过程中也不可能是最大值\n\n所以，当第i个数的下标准备进index时，需要移除所有index中已有下标指向的比第i个数要小的数的下标，如在第三个窗口中，-1，-3的下标都要出index，3的下标也要出index,因为超过了窗口范围\n当第i个数小于index最后一个数时，i进index，因为当i前面的下标出index后，i指向的数有可能是最大的\n\n### 代码\n\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        if n<2 or k==1:\n            return nums\n        res = []\n        index = [0]    \n        queue = [nums[0]]\n        \n        for i in range(1,n):\n            \n            if index[0]<=i-k:\n                index.pop(0)\n            while index and nums[index[-1]]<nums[i]:\n                index.pop()\n            index.append(i)\n            if i>=k-1:\n                res.append(nums[index[0]])\n          \n        return res \n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1626361125","body":"### 思路\n\n根据条件进行遍历\n\n### 代码\n\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        # 如果存在n-1个人，代表符合条件2\n        res = set(x for x,_ in trust)\n        if len(res) != n-1:\n            return -1\n        for i in range(1,n+1):\n            if i not in res:\n                break\n        num = 0\n        # 遍历统计信任疑似法官的人数\n        for _,y in trust:\n            if y == i:\n                num += 1\n        return i if num == n-1 else -1\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627567486","body":"### 思路\n\nbfs二分法\n\n### 代码\n\n```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        graph=defaultdict(list)\n        for a,b in dislikes:\n            graph[a-1].append(b-1)\n            graph[b-1].append(a-1)\n        color=[0]*n\n        stk=[]\n   \n        for i in range(n):\n            if color[i]==0:\n                color[i]=1\n                stk.append(i)\n            while len(stk)>0:\n                p=stk.pop(0)\n                for j in graph[p]:\n                    if color[j]==0:\n                        color[j]=3-color[p]\n                        stk.append(j)\n                    elif color[j]==color[p]:\n                        return False\n                    else:\n                        continue\n        return True\n                \n```\n\n**复杂度分析**\n\n- 时间复杂度：O(M+N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1636005821","body":"### 思路\r\n\r\n拓扑排序\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    # 拓扑排序\r\n    def tp_sort(self, items, indegree, neighbors):\r\n        q = collections.deque([])\r\n        ans = []\r\n        for item in items:\r\n            if not indegree[item]:\r\n                q.append(item)\r\n        while q:\r\n            cur = q.popleft()\r\n            ans.append(cur)\r\n\r\n            for neighbor in neighbors[cur]:\r\n                indegree[neighbor] -= 1\r\n                if not indegree[neighbor]:\r\n                    q.append(neighbor)\r\n\r\n        return ans\r\n\r\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\r\n        max_group_id = m\r\n        for project in range(n):\r\n            if group[project] == -1:\r\n                group[project] = max_group_id\r\n                max_group_id += 1\r\n\r\n        project_indegree = collections.defaultdict(int)\r\n        group_indegree = collections.defaultdict(int)\r\n        project_neighbors = collections.defaultdict(list)\r\n        group_neighbors = collections.defaultdict(list)\r\n        group_projects = collections.defaultdict(list)\r\n\r\n        for project in range(n):\r\n            group_projects[group[project]].append(project)\r\n\r\n            for pre in pres[project]:\r\n                if group[pre] != group[project]:\r\n                    # 小组关系图\r\n                    group_indegree[group[project]] += 1\r\n                    group_neighbors[group[pre]].append(group[project])\r\n                else:\r\n                    # 项目关系图\r\n                    project_indegree[project] += 1\r\n                    project_neighbors[pre].append(project)\r\n\r\n        ans = []\r\n        # 先对组进行拓扑排序\r\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\r\n\r\n        if len(group_queue) != max_group_id:\r\n            return []\r\n\r\n        for group_id in group_queue:\r\n            # 对小组中的项目进行拓扑排序\r\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\r\n\r\n            if len(project_queue) != len(group_projects[group_id]):\r\n                return []\r\n            ans += project_queue\r\n\r\n        return ans\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(M+N)\r\n- 空间复杂度：O(M+N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1630634905","body":"### 思路\n\n模拟\n\n### 代码\n\n```python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        # 定义变量 x，y\n        x = 0\n        y = 0\n\n        # 遍历 moves，获取每步移动指令\n        for move in moves:\n            # 对应 4 个方位指令，分别更新 x，y 的值\n            if move == 'R':\n                x += 1\n            elif move == 'L':\n                x -= 1\n            elif move == 'U':\n                y += 1\n            elif move == 'D':\n                y -= 1\n\n        # 如果 x，y 的值都为 0,表示机器人回到原点\n        if x == 0 and y == 0:\n            return True\n        return False\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1632755800","body":"### 思路\n\n模拟\n\n### 代码\n\n```python\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(task[0], i, task[1]) for i, task in enumerate(tasks)]\n        tasks.sort()\n        backlog = []\n        time = 0\n        ans = []\n        pos = 0\n        for _ in tasks:\n            if not backlog:\n                time = max(time, tasks[pos][0])\n            while pos < len(tasks) and tasks[pos][0] <= time:\n                heapq.heappush(backlog, (tasks[pos][2], tasks[pos][1]))\n                pos += 1\n            d, j = heapq.heappop(backlog)\n            time += d\n            ans.append(j)\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1634347927","body":"### 思路\n\n将开始时间和结束时间规范到标准时间\n\n### 代码\n\n```python\nclass Solution:\n    def numberOfRounds(self, startTime: str, finishTime: str) -> int:\n        sh, sm = map(int, startTime.split(\":\"))\n        eh, em = map(int, finishTime.split(\":\"))\n        if 0 < sm < 15:\n            sm = 15\n        elif 15 < sm < 30:\n            sm = 30\n        elif 30 < sm < 45:\n            sm = 45\n        elif 45 < sm < 60:\n            sm = 0\n            sh += 1\n        if 0 < em < 15:\n            em = 0\n        elif 15 < em < 30:\n            em = 15\n        elif 30 < em < 45:\n            em = 30\n        elif 45 < em < 60:\n            em = 45\n        st = sh * 60 + sm\n        et = eh * 60 + em\n        if st > et:\n            et += 24 * 60\n        return (et - st) // 15\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1636003745","body":"### 思路\n\n前缀和、后缀和\n\n### 代码\n\n```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        presum_A = 0\n        presum_B = 0\n\n        counter_A = Counter([ch for ch in a])\n        counter_B = Counter([ch for ch in b])\n\n        res = sys.maxsize\n\n        m, n = len(a), len(b)\n\n        res = min(res, m - max(counter_A.values()) + n - max(counter_B.values()))\n        presum_A = []\n        sum_A = 0\n        presum_B = []\n        sum_B = 0\n\n        for i in range(0, 26):\n            sum_A += counter_A[chr(i + 97)]\n            presum_A.append(sum_A)\n            sum_B += counter_B[chr(i + 97)]\n            presum_B.append(sum_B)\n        \n        for i in range(0, 25):\n            res = min(m - presum_A[i] + presum_B[i], res)\n        \n        for i in range(0, 25):\n            res = min(n - presum_B[i] + presum_A[i], res)\n        \n        return res\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1636777626","body":"### 思路\n\n快速排序\n\n### 代码\n\n```python\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def quick_sort(array, l, r):\n            if l < r:\n                q = partition(array, l, r)\n                quick_sort(array, l, q - 1)\n                quick_sort(array, q + 1, r)\n\n        def partition(array, l, r):\n            x = array[r]\n            i = l\n            for j in range(l, r):\n                if array[j] <= x:\n                    array[i], array[j] = array[j], array[i]\n                    i += 1\n            array[i], array[r] = array[r], array[i]\n            return i\n        quick_sort(nums, 0, len(nums)-1)\n        return nums\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637084054","body":"### 思路\n\n二分法\n\n### 代码\n\n```python\ndef mySqrt(self, x):\n    if x < 2: return x\n\n    l, r = 0, x\n    while l + 1 < r:\n        root = (l+r)//2\n        if root > x//root:\n            r = root\n        elif root < x//root:\n            l = root\n        else:\n            return root\n            \n    return l # floor\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(LogN)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637639167","body":"### 思路\n\n(1)使用isBadVersion(mid)来判断mid是否在单元测试中出错。如果\nisBadVersion(mid)为False,说明mid左边均未出错，那么start设置为mid+1，将在区间[mid_1,mid]中查找；如果isBadVersion(mid)为True, mid位置版本错误，我们要寻找第一个版本出错的地方，那么将end设置为mid-1。\n\n### 代码\n\n```python\n# The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -> bool:\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        start = 1\n        end = n\n        while(start<=end):\n            mid = (start+end)//2\n            if(isBadVersion(mid)):\n                end = mid-1\n            else:\n                start = mid+1\n        return start\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(LogN)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1640368834","body":"### 思路\n\n二分法\n\n### 代码\n\n```python\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        tb, res = [], 0\n        for n in reversed(nums) :\n            res += bisect.bisect_left(tb, n)\n            n2 = 2*n\n            idx = bisect.bisect_left(tb, n2)\n            tb.insert(idx, n2)\n        return res\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(NLogN)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/42#issuecomment-1642177718","body":"### 思路\n\n二分法\n\n### 代码\n\n```python\nclass Solution:\n    def findRadius(self, houses, heaters):\n        houses.sort()\n        heaters.sort()\n        radius = 0\n\n        for house in houses:\n            left, right = 0, len(heaters)\n\n            while left < right:\n                mid = (left + right) // 2\n\n                if heaters[mid] < house:\n                    left = mid + 1\n                else:\n                    right = mid\n\n            left_dist = abs(heaters[left] - house) if left < len(heaters) else float('inf')\n            prev_dist = abs(heaters[left - 1] - house) if left > 0 else float('inf')\n            radius = max(radius, min(left_dist, prev_dist))\n\n        return radius\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(NLogN)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1644082306","body":"### 思路\n\n二分法\n\n### 代码\n\n```python\nclass Solution:\n    def solve(self, A, k):\n        A.sort()\n        def count_not_greater(diff):\n            i = ans = 0\n            for j in range(1, len(A)):\n                while A[j] - A[i] > diff:\n                    i += 1\n                ans += j - i\n            return ans\n        l, r = 0, A[-1] - A[0]\n        k += 1 # zero based -> one based\n        while l <= r:\n            mid = (l + r) // 2\n            if count_not_greater(mid) >= k:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(NLogN)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/44#issuecomment-1645529848","body":"### 思路\n\n优先队列\n 在搜索的同时将周围的水位加入优先队列\n 每次选择最低的水位移动\n\n并查集\n 将两个相邻的方块看作两个结点, 权为两者水位较高值\n\n### 代码\n\n```python\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        d, m, n, result, q = [(0, 1), (0, -1), (1, 0), (-1, 0)], len(grid), len(grid[0]), 0, [[grid[0][0], 0, 0]]\n        visited = [[False] * n for _ in range(m)]\n        while q:\n            h, x, y = heapq.heappop(q)\n            result = max(result, h)\n            if x == m - 1 and y == n - 1:\n                break\n            for dx, dy in d:\n                next_x, next_y = x + dx, y + dy\n                if -1 < next_x < m and -1 < next_y < n and not visited[next_x][next_y]:\n                    visited[next_x][next_y] = True\n                    heapq.heappush(q, [grid[next_x][next_y], next_x, next_y])\n        return result\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n ^ 2lgn)\n- 空间复杂度：O(n ^ 2)\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/49#issuecomment-1651655985","body":"### 思路\n\n同向双指针\n\n\n### 代码\n\n```python\ndef minOperations(self, nums, x):\n    currSum, n, ans, l = sum(nums), len(nums), float('inf'), 0\n\n    for r in range(n):\n        currSum -= nums[r]\n        # if smaller, move `l` to left\n        while currSum < x and l <= r:\n            currSum += nums[l]\n            l += 1\n        # check if equal\n        if currSum == x:\n            ans = min(ans, (n-1-r)+l)\n\n    return ans if ans != float('inf') else -1\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/53#issuecomment-1657206265","body":"### 思路\n\nBFS\n\n\n### 代码\n\n```python\nclass Solution:\n    def maxDistance(self, grid):\n        rows = len(grid)\n        cols = len(grid[0])\n\n        ocean_queue = []\n        land_queue = []\n\n   \n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 0:\n                    ocean_queue.append((i, j))\n                else:\n                    land_queue.append((i, j))\n\n        if len(ocean_queue) == 0 or len(land_queue) == 0:\n            return -1\n\n        max_distance = -1\n\n   \n        while ocean_queue:\n            ocean_cell = ocean_queue.pop(0)\n\n         \n            x0, y0 = ocean_cell\n            for land_cell in land_queue:\n  \n                x1, y1 = land_cell\n                distance = abs(x0 - x1) + abs(y0 - y1)\n                max_distance = max(max_distance, distance)\n        return max_distance\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(N^2)\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/60#issuecomment-1666679078","body":"### 思路\n\n动态规划\n\n\n### 代码\n\n```python\nclass Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [[0]*m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i==0 or j==0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1]\n                     \n        return dp[n-1][m-1]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pkuphy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenya-zhu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wty9sky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skyoct":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingzxy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaodingc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jyjsunny":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aoxiangw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"enrilwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aswrise":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aneureka":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ljqchlsw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jingyuzhou123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dianlandu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jameswangxin":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585714129","body":"```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n      List<Integer> result = new ArrayList<>();\n        for(int i = num.length - 1; i >= 0; i--){\n            int sum = num[i] + k % 10;         \n            k /= 10;    \n            if(sum >= 10){\n                k++;                        \n                sum -= 10;                \n            }\n            result.add(sum);\n        }\n\n        for(; k > 0; k /= 10){               \n            result.add(k % 10);               \n        }\n        Collections.reverse(result);\n        return result;\n    }\n}\n```\n时间复杂度 O(n)\n\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586168728","body":"```java\n class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int lp = -n, rp= -n;\n        int[] ans = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                lp = i;\n            } else {\n                int diff = Math.abs(i-lp);\n                ans[i] = diff;\n            }\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                rp = i;\n            } else {\n                if (rp == -1) {\n                    continue;\n                }\n                int diff = Math.abs(i-rp);\n                ans[i] = Math.min(ans[i], diff);\n            }\n        }\n        return ans;\n    }\n}\n```\n正向遍历一遍数组，如果当前遍历到的字符是题目中给定的字符，那么记录一下此时字符出现的位置，否则更新一下当前字符与给的字符的下标差；反向遍历数组也是做类似的操作，遍历的同时与第一次正向遍历数组计算出的距离差两者取较小值作为当前位置的最终结果。\n\n时间复杂度 : O(n)\n\n空间复杂度:  O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594837246","body":"```cpp\n   /**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head) return nullptr;\n        int len = 0;\n        auto dummy = new ListNode(-1);\n        dummy->next = head;\n        auto p = head;\n        while (p) {\n            len++;\n            p = p->next;\n        }\n        k %= len;\n        if (k == 0) return head;\n        p = head; auto q = head; //p是慢指针，q是快指针\n        while (k--) q = q->next;\n        while (q->next) {\n            p = p->next;\n            q = q->next;\n        }\n        auto temp = dummy->next;\n        dummy->next = p->next;\n        q->next = temp;\n        p->next = nullptr;\n        return dummy->next;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1597410596","body":"```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        auto p = headA, q = headB;\n        while (p != q) {\n            p = p ? p->next : headB;\n            q = q ? q->next : headA;\n        }\n        return p;\n    }\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604471603","body":"```cpp\n   /**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (!p && !q) return true;\n        if (p && !q) return false;\n        if (!p && q) return false;\n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1613440282","body":"```cpp\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> cnt;\n        for (int val : nums) cnt[val]++;\n        int n = nums.size();\n        vector<int> ss(n+1);\n        for (auto it = cnt.begin(); it != cnt.end(); it++) {\n            ss[it->second]++;\n        }\n        int index = n;\n        while (k > 0) {\n            k -= ss[index--];\n        }\n        vector<int> ans;\n        for (auto it = cnt.begin(); it != cnt.end(); it++) {\n            if (it->second > index) {\n                ans.push_back(it->first);\n            }\n        }\n        return ans;\n    }\n};\n````","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1620178756","body":"```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        auto p = head, q = head;\n        while (q && q->next) {\n            q = q->next;\n            p = p->next;\n            if (q) q = q->next;\n        }\n        //cout << p->val << endl;\n        return p;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenxied":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuozhouzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shin-guid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bochengwan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyo-tom":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uratora":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guitarys":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585711905","body":"public int AddToArrayForm(int[] num, int k) {\nint result = k;\n\n        for (int i = 0; i > num.Length; i++) {\n          result = result + num[i] * Math.Pow(10,num.Length-i);\n        }\n\n       \n\n        return result;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586194431","body":"``` python\n\nclass Solution:\n    def shortestToChar(self, s:str, c:str) : #指定s、c的类型\n        n = len(s)\n        answer = [0] * n\n        print('answer的类型',type(answer))\n        last_position = -float(\"inf\")\n        for i in range(n):\n            if s[i] == c:\n                last_position = i\n            answer[i] = i - last_position\n\n        next_position = float(\"inf\")\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                next_position = i\n            answer[i] = min(answer[i], next_position - i)\n\n        return answer\n\ns = \"loveleetcode\"\nc = \"e\"\nsolution = Solution()\nans = solution.shortestToChar(s, c)\nprint(ans)  # 输出 [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\n\ns = \"aaab\"\nc = \"b\"\nsolution = Solution()\nans = solution.shortestToChar(s, c)\nprint(ans)  # 输出 [3, 2, 1, 0]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587236256","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        n = len(self.stack)\n        for i in range(min(k, n)):\n            self.stack[i] += val\n接下来使用样例进行验证：\npythonCopy Code\ncustomStack = CustomStack(3)  # 栈是空的 []\nprint(customStack.push(1))  # null\nprint(customStack.push(2))  # null\nprint(customStack.pop())  # 2\nprint(customStack.push(2))  # null\nprint(customStack.push(3))  # null\nprint(customStack.push(4))  # null\nprint(customStack.increment(5, 100))  # null\nprint(customStack.increment(2, 100))  # null\nprint(customStack.pop())  # 103\nprint(customStack.pop())  # 202\nprint(customStack.pop())  # 201\nprint(customStack.pop())  # -1\n输出结果为：\nCopy Code\nNone\nNone\n2\nNone\nNone\nNone\nNone\nNone\n103\n202\n201\n-1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1588896853","body":"``` python\ndef decodeString(s: str) -> str:\n    stack = []\n    res = \"\"\n    k = 0\n\n    for c in s:\n        if c.isdigit():\n            k = k * 10 + int(c)\n        elif c.isalpha():\n            res += c\n        elif c == \"[\":\n            stack.append((res, k))\n            res, k = \"\", 0\n        elif c == \"]\":\n            prev_res, prev_k = stack.pop()\n            res = prev_res + prev_k * res\n\n    return res\ns = \"3[a]2[bc]\"\nprint(decodeString(s))  # 输出：\"aaabcbc\"\n\ns = \"3[a2[c]]\"\nprint(decodeString(s))  # 输出：\"accaccacc\"\n\ns = \"2[abc]3[cd]ef\"\nprint(decodeString(s))  # 输出：\"abcabccdcdcdef\"\n\ns = \"abc3[cd]xyz\"\nprint(decodeString(s))  # 输出：\"abccdcdcdxyz\"\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591168009","body":"``` python \nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.list_push = []  # 用于 push 操作的列表\n        self.list_pop = []   # 用于 pop 和 peek 操作的列表\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.list_push.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.list_pop:         # 如果 list_pop 为空，则需要将 list_push 中的元素倒入 list_pop 中\n            while self.list_push:\n                self.list_pop.append(self.list_push.pop())\n        return self.list_pop.pop()    # 弹出 list_pop 列表末尾元素\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if not self.list_pop:         # 如果 list_pop 为空，则需要将 list_push 中的元素倒入 list_pop 中\n            while self.list_push:\n                self.list_pop.append(self.list_push.pop())\n        return self.list_pop[-1]      # 返回 list_pop 列表末尾元素\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not self.list_push and not self.list_pop   # 当且仅当两个列表均为空时，队列为空\n\nqueue = MyQueue()\nqueue.push(1)\nqueue.push(2)\nprint(queue.peek())    # 返回 1\nprint(queue.pop())     # 返回 1\nprint(queue.empty())   # 返回 False\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593163278","body":"``` python\ndef maxChunksToSorted(arr):\n    stack = []\n    for num in arr:\n        if not stack or num >= stack[-1][0]:\n            # 当前元素可以加入到当前块中\n            stack.append((num, 1))\n        else:\n            # 当前元素需要新开一块\n            cnt = 0\n            while stack and num < stack[-1][0]:\n                _, c = stack.pop()\n                cnt += c\n            stack.append((num, cnt))\n    return len(stack)\n\narr1 = [5,4,3,2,1]  # 因为不可以翻转，仍是按顺序拼接，所以拼接后仍不是有序数组\nprint(maxChunksToSorted(arr1))  # 输出 1\n\narr2 = [2,1,3,4,4]\nprint(maxChunksToSorted(arr2))  # 输出 4\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594135840","body":"``` python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef rotateRight(head: ListNode, k: int) -> ListNode:\n    # 处理特殊情况\n    if head is None or head.next is None or k == 0:\n        return head\n\n    # 计算链表长度，同时将链表首尾相连\n    n, tail = 1, head\n    while tail.next:\n        n += 1\n        tail = tail.next\n    tail.next = head\n\n    # 计算实际要移动的步数\n    k %= n\n\n    # 找到新的头结点和尾结点\n    new_tail = head\n    for _ in range(n - k - 1):\n        new_tail = new_tail.next\n    new_head = new_tail.next\n\n    # 断开链表，返回新的头结点\n    new_tail.next = None\n    return new_head\n\n\nhead1 = ListNode(1)\nhead1.next = ListNode(2)\nhead1.next.next = ListNode(3)\nhead1.next.next.next = ListNode(4)\nhead1.next.next.next.next = ListNode(5)\n\nk1 = 2\nprint(\"输入：\", end=\"\")\np1 = head1\nwhile p1:\n    print(p1.val, \"->\", end=\" \")\n    p1 = p1.next\nprint(\"NULL, k =\", k1)\n\nnew_head1 = rotateRight(head1, k1)\n\nprint(\"输出：\", end=\"\")\np1 = new_head1\nwhile p1:\n    print(p1.val, \"->\", end=\" \")\n    p1 = p1.next\nprint(\"NULL\")\nprint()\n\nhead2 = ListNode(0)\nhead2.next = ListNode(1)\nhead2.next.next = ListNode(2)\n\nk2 = 4\nprint(\"输入：\", end=\"\")\np2 = head2\nwhile p2:\n    print(p2.val, \"->\", end=\" \")\n    p2 = p2.next\nprint(\"NULL, k =\", k2)\n\nnew_head2 = rotateRight(head2, k2)\n\nprint(\"输出：\", end=\"\")\np2 = new_head2\nwhile p2:\n    print(p2.val, \"->\", end=\" \")\n    p2 = p2.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595772908","body":"``` python \nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # 如果链表为空或者只有一个节点，直接返回head\n        if not head or not head.next:\n            return head\n\n        # 定义新的头节点new_head和前驱节点prev\n        new_head = head.next\n        prev = ListNode(0)\n\n        # 开始遍历链表\n        while head and head.next:\n            # 获取当前要交换的两个节点\n            first_node, second_node = head, head.next\n\n            # 进行节点交换\n            first_node.next = second_node.next\n            second_node.next = first_node\n\n            # 将前驱节点指向交换后的第二个节点\n            prev.next = second_node\n\n            # 更新head和prev\n            prev, head = first_node, first_node.next\n\n        return new_head\n\n\n# 示例输入\nhead1 = ListNode(1)\nnode2 = ListNode(2)\nnode3 = ListNode(3)\nnode4 = ListNode(4)\n\nhead1.next = node2\nnode2.next = node3\nnode3.next = node4\n\n# 创建Solution对象\nsolution = Solution()\n\n# 打印示例输出\nprint(\"示例1结果：\")\nres1 = solution.swapPairs(head1)\nwhile res1:\n    print(res1.val)\n    res1 = res1.next\n\nhead2 = None\nprint(\"示例2结果：\")\nres2 = solution.swapPairs(head2)\nwhile res2:\n    print(res2.val)\n    res2 = res2.next\n\nhead3 = ListNode(1)\nprint(\"示例3结果：\")\nres3 = solution.swapPairs(head3)\nwhile res3:\n    print(res3.val)\n    res3 = res3.next\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1595998722","body":"``` python \n\n# Definition for singly-linked list.\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        # 寻找链表中点\n        slow, fast = head, head.next.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        # 将链表断开，分别构建左子树和右子树\n        mid = slow.next\n        slow.next = None\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        return root\n\n\n# 示例\nhead = ListNode(-10)\nhead.next = ListNode(-3)\nhead.next.next = ListNode(0)\nhead.next.next.next = ListNode(5)\nhead.next.next.next.next = ListNode(9)\n\nsolution = Solution()\nroot = solution.sortedListToBST(head)\n\ndef printTree(root):\n    if not root:\n        return\n    print(root.val)\n    printTree(root.left)\n    printTree(root.right)\n\nprintTree(root)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596222919","body":"``` python \n# 链表节点的定义\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        # 计算链表A和链表B的长度\n        lenA, lenB = 0, 0\n        pA, pB = headA, headB\n        while pA:\n            lenA += 1\n            pA = pA.next\n        while pB:\n            lenB += 1\n            pB = pB.next\n\n        # 让较长的链表先移动n-m步\n        if lenA > lenB:\n            for i in range(lenA - lenB):\n                headA = headA.next\n        else:\n            for i in range(lenB - lenA):\n                headB = headB.next\n\n        # 同时移动两个指针，直到找到交点或达到链表尾部\n        while headA and headB:\n            if headA == headB:\n                return headA\n            headA = headA.next\n            headB = headB.next\n\n        # 没有交点，返回null\n        return None\n\n\n# 输入数据\nintersectVal = 8\nlistA = ListNode(4)\nlistA.next = ListNode(1)\nlistA.next.next = ListNode(8)\nlistA.next.next.next = ListNode(4)\nlistA.next.next.next.next = ListNode(5)\n\nlistB = ListNode(5)\nlistB.next = ListNode(6)\nlistB.next.next = ListNode(1)\nlistB.next.next.next = listA.next.next\n\nskipA = 2\nskipB = 3\n\n# 输出结果\nsolution = Solution()\nintersection_node = solution.getIntersectionNode(listA, listB)\nif intersection_node:\n    print(\"Intersected at '{}'\".format(intersection_node.val))\nelse:\n    print(\"null\")\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598220717","body":"···python\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return None\n        \n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n        \n        if not fast or not fast.next:\n            return None\n        \n        ptr1, ptr2 = head, fast\n        while ptr1 != ptr2:\n            ptr1 = ptr1.next\n            ptr2 = ptr2.next\n        \n        return ptr1\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600072076","body":"``` python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 将查询的元素提到最前面\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        # 先查询 key 是否已经在缓存中\n        if key in self.cache:\n            # 更新值\n            self.cache[key] = value\n            # 将元素提到最前面\n            self.cache.move_to_end(key)\n        else:\n            # 如果缓存满了，则删除最久未使用的元素\n            if len(self.cache) >= self.capacity:\n                self.cache.popitem(last=False)\n            # 插入新元素\n            self.cache[key] = value\n\n\nlru_cache = LRUCache(2)\nlru_cache.put(1, 1)\nlru_cache.put(2, 2)\nprint(lru_cache.get(1))  # 输出 1\nlru_cache.put(3, 3)\nprint(lru_cache.get(2))  # 输出 -1\nlru_cache.put(4, 4)\nprint(lru_cache.get(1))  # 输出 -1\nprint(lru_cache.get(3))  # 输出 3\nprint(lru_cache.get(4))  # 输出 4\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602818203","body":"class Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == NULL) {\n            return 0;\n        }\n\n        int left_depth = maxDepth(root->left);\n        int right_depth = maxDepth(root->right);\n        return max(left_depth, right_depth) + 1;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604407863","body":"class Solution {\n\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605276374","body":"class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sumNumbers(root: TreeNode) -> int:\n    if not root:\n        return 0\n    \n    def dfs(node, num):\n        if not node:\n            return 0\n        \n        num = num * 10 + node.val\n        if not node.left and not node.right:\n            return num\n        \n        return dfs(node.left, num) + dfs(node.right, num)\n    \n    return dfs(root, 0)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1606037946","body":"``` python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef findBottomLeftValue(root):\n    queue = [root]\n    leftmost = root.val\n\n    while queue:\n        size = len(queue)\n        for i in range(size):\n            node = queue.pop(0)\n            if i == 0:\n                leftmost = node.val\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return leftmost\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.right.left = TreeNode(5)\nroot.right.right = TreeNode(6)\nroot.right.left.left = TreeNode(7)\n\nresult = findBottomLeftValue(root)\nprint(result)  # 输出: 7\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1606733692","body":"```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Codec:\n    def serialize(self, root: TreeNode) -> str:\n        \"\"\"Encodes a tree to a single string.\n        \"\"\"\n        if not root:\n            return ''\n        # 使用preorder遍历序列化二叉树\n        res = []\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(str(node.val))\n                stack.append(node.right)\n                stack.append(node.left)\n            else:\n                res.append('null')\n        return ','.join(res)\n\n    def deserialize(self, data: str) -> TreeNode:\n        \"\"\"Decodes your encoded data to tree.\n        \"\"\"\n        if not data:\n            return None\n        # 将序列化结果解析成列表\n        vals = data.split(',')\n        # 使用DFS递归构建二叉树\n        def dfs():\n            val = vals.pop(0)\n            if val == 'null':\n                return None\n            node = TreeNode(int(val))\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        return dfs()\n\n# 测试样例\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.right.left = TreeNode(4)\nroot.right.right = TreeNode(5)\n\ncodec = Codec()\ns = codec.serialize(root)\nprint(s)  # 序列化结果: \"1,2,null,null,3,4,null,null,5,null,null,\"\nnew_root = codec.deserialize(s)\nprint(new_root.val)  # 重构后的根节点值: 1\nprint(new_root.left.val)  # 重构后的左子树根节点值: 2\nprint(new_root.right.val)  # 重构后的右子树根节点值: 3\nprint(new_root.right.left.val)  # 重构后的右子树的左子树根节点值: 4\nprint(new_root.right.right.val)  # 重构后的右子树的右子树根节点值: 5\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1608835994","body":"``` python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef verticalTraversal(root):\n    # 创建一个字典用于保存每个节点所在列的信息\n    column_table = {}\n\n    # 定义 DFS 函数\n    def dfs(node, x, y):\n        if not node:\n            return\n\n        # 将节点值添加到相应列的列表中\n        if x in column_table:\n            column_table[x].append((y, node.val))\n        else:\n            column_table[x] = [(y, node.val)]\n\n        # 递归遍历左右子节点\n        dfs(node.left, x - 1, y - 1)\n        dfs(node.right, x + 1, y - 1)\n\n    # 执行 DFS 遍历\n    dfs(root, 0, 0)\n\n    # 对列索引进行排序\n    sorted_columns = sorted(column_table.keys())\n\n    # 根据列索引获取节点值列表，并添加到结果列表中\n    result = []\n    for col in sorted_columns:\n        column_values = [val for y, val in sorted(column_table[col])]\n        result.append(column_values)\n\n    return result\n\n\n# 示例用法\nroot = TreeNode(3)\nroot.left = TreeNode(9)\nroot.right = TreeNode(20)\nroot.right.left = TreeNode(15)\nroot.right.right = TreeNode(7)\nresult = verticalTraversal(root)\nprint(result)  # 输出：[[9], [3, 15], [20], [7]]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1610922412","body":"``` python\ndef twoSum(nums, target):\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n\n# 示例测试\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = twoSum(nums, target)\nprint(result)  # 输出 [0, 1]\n\nnums = [3, 2, 4]\ntarget = 6\nresult = twoSum(nums, target)\nprint(result)  # 输出 [1, 2]\n\nnums = [3, 3]\ntarget = 6\nresult = twoSum(nums, target)\nprint(result)  # 输出 [0, 1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1611842015","body":"``` python\n\nfrom collections import Counter\n\ndef topKFrequent(nums, k):\n    counts = Counter(nums)\n    frequent_nums = sorted(counts, key=lambda x: counts[x], reverse=True)\n    return frequent_nums[:k]\n\n# 示例1\nnums1 = [1, 1, 1, 2, 2, 3]\nk1 = 2\nresult1 = topKFrequent(nums1, k1)\nprint(result1)  # 输出: [1, 2]\n\n# 示例2\nnums2 = [1]\nk2 = 1\nresult2 = topKFrequent(nums2, k2)\nprint(result2)  # 输出: [1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614534919","body":"``` python\ndef distance(p1, p2):\n    # 计算两点之间的欧式距离的平方\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\ndef numberOfBoomerangs(points):\n    result = 0\n    for p1 in points:\n        # 创建一个字典来存储每个点与其他点的距离出现的频次\n        distances = {}\n        for p2 in points:\n            # 计算当前点与其他点的距离\n            d = distance(p1, p2)\n            # 将距离及其频次添加到字典中\n            if d in distances:\n                distances[d] += 1\n            else:\n                distances[d] = 1\n\n        # 对于每个点，计算可以形成回旋镖的数量\n        for key in distances:\n            count = distances[key]\n            # 如果有至少两个点与当前点的距离相等，则可以形成回旋镖\n            if count >= 2:\n                result += count * (count - 1)\n    return result\n\n\n\npoints = [[0,0],[1,0],[2,0]]\nresult = numberOfBoomerangs(points)\nprint(result)  # 输出: 2\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615933634","body":"class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        charSet = set()\n        left = 0\n        res = 0\n\n        for right in range(len(s)):\n            while s[right] in charSet:\n                charSet.remove(s[left])\n                left += 1\n            charSet.add(s[right])\n            res = max(res, right - left + 1)\n\n        return res","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1617419265","body":"```python\nclass Solution:\n    def minSubarray(self, nums, p):\n        total_sum = sum(nums)\n        if total_sum % p == 0:\n            return 0\n        remainder = total_sum % p\n        min_length = float('inf')\n\n        prefix_sums = {0: -1}\n        curr_sum = 0\n\n        for i, num in enumerate(nums):\n            curr_sum += num\n            target = (curr_sum - remainder) % p\n            if target in prefix_sums:\n                min_length = min(min_length, i - prefix_sums[target])\n                prefix_sums[curr_sum % p] = i\n        if min_length == len(nums):\n            return -1\n\n        return min_length","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1618870762","body":"``` python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef middleNode(head):\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    return slow\n\n\n# 测试样例\nhead = ListNode(1)\nnode2 = ListNode(2)\nnode3 = ListNode(3)\nnode4 = ListNode(4)\nnode5 = ListNode(5)\nhead.next = node2\nnode2.next = node3\nnode3.next = node4\nnode4.next = node5\n\nresult = middleNode(head)\nwhile result:\n    print(result.val)\n    result = result.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1620936057","body":"``` python\nclass Solution:\n    # nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\n    def removeDuplicates(self, nums):\n        if not nums:\n            return 0\n\n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n\n        return i + 1\nsolution = Solution()\n\nnums1 = [1, 1, 2]\nlength1 = solution.removeDuplicates(nums1)\nprint(\"Modified Array 1:\", nums1[:length1])\n\nnums2 = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]\nlength2 = solution.removeDuplicates(nums2)\nprint(\"Modified Array 2:\", nums2[:length2])\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1623604206","body":"```python \nclass Solution:\n    def search_insert(self, nums, target):\n        left = 0\n        right = len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\nnums = [1, 3, 5, 6]\ntarget = 5\nsolution = Solution()\nprint(solution.search_insert(nums, target))  \ntarget = 2\nprint(solution.search_insert(nums, target))  \ntarget = 7\nprint(solution.search_insert(nums, target)) \n\ntarget = 0\nprint(solution.search_insert(nums, target))  \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1624610292","body":"``` python \nfrom collections import deque\n\ndef maxSlidingWindow(nums, k):\n    result = []\n    window = deque()  \n    for i in range(len(nums)):\n\n        while window and nums[i] >= nums[window[-1]]:\n            window.pop()\n\n        window.append(i)\n\n        if window[0] <= i - k:\n            window.popleft()\n\n        if i >= k - 1:\n            result.append(nums[window[0]])\n\n    return result\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\noutput = maxSlidingWindow(nums, k)\nprint(output)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1626917316","body":"```python\nclass Solution:\n    def findJudge(self, n, trust):\n        trust_count = [0] * (n + 1)\n        for a, b in trust:\n            trust_count[a] -= 1  \n            trust_count[b] += 1  \n        for i in range(1, n + 1):\n            if trust_count[i] == n - 1: \n                return i\n\n        return -1 \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627627100","body":"```python\nclass Solution:\n    def possible_bi_partition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = defaultdict(list)\n\n        # 构建邻接表形式的图\n        for x, y in dislikes:\n            graph[x].append(y)\n            graph[y].append(x)\n\n        colors = [-1] * (N + 1)\n\n        def dfs(node, color):\n            colors[node] = color\n\n            for neighbor in graph[node]:\n                if colors[neighbor] == color:\n                    return False\n                if colors[neighbor] == -1 and not dfs(neighbor, 1 - color):\n                    return False\n\n            return True\n\n        for i in range(1, N + 1):\n            if colors[i] == -1 and not dfs(i, 0):\n                return False\n\n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1630006666","body":"def sortItems(n, m, group, beforeItems):\n    # 创建图和入度列表\n    graph = {i: [] for i in range(n + m)}\n    in_degree = [0] * (n + m)\n\n    # 构建图和更新入度\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m + i\n        else:\n            group[i] = group[i]\n        in_degree[group[i]] += 1\n\n    for i in range(n):\n        for j in beforeItems[i]:\n            if group[i] != group[j]:\n                graph[group[j]].append(group[i])\n                in_degree[group[i]] += 1\n\n    # 深度优先搜索\n    def dfs(node):\n        nonlocal valid\n        visited[node] = 1\n        for x in graph[node]:\n            if not valid:\n                return\n            if visited[x] == 1:\n                valid = False\n                return\n            if visited[x] == 0:\n                dfs(x)\n                if not valid:\n                    return\n        visited[node] = 2\n        res.append(node)\n\n    # 拓扑排序\n    def topological_sort():\n        nonlocal valid\n        for i in range(n + m):\n            if not valid:\n                return\n            if visited[i] == 0:\n                dfs(i)\n\n    # 初始化访问状态和结果列表\n    visited = [0] * (n + m)\n    res = []\n    valid = True\n\n    topological_sort()\n\n    return res[::-1] if valid else []\n\n# 测试示例\nn = 8\nm = 2\ngroup = [-1,-1,1,0,0,1,0,-1]\nbeforeItems = [[],[6],[5],[6],[3,6],[],[],[]]\nprint(sortItems(n, m, group, beforeItems))  # [6, 3, 4, 1, 5, 2, 0, 7]\n\nbeforeItems = [[],[6],[5],[6],[3],[],[4],[]]\nprint(sortItems(n, m, group, beforeItems))  # []\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1630024854","body":"\n```python\nclass Solution:\n    def __init__(self):\n        self.x = 0  # 初始水平位置为0\n        self.y = 0  # 初始垂直位置为0\n    def move(self, direction):\n        if direction == \"R\":\n            self.x += 1         # 自身加一\n        elif direction == \"L\":\n            self.x -= 1         # 自身减一\n        elif direction == \"U\":\n            self.y += 1\n        elif direction == \"D\":\n            self.y -= 1\n    def judgeCircle(self, moves):\n        for move in moves:\n            self.move(move)\n        return self.x == self.y == 0\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1632123329","body":"```python\nimport heapq\nclass Task:\n    def __init__(self, enqueueTime, processingTime, index):\n        self.enqueueTime = enqueueTime\n        self.processingTime = processingTime\n        self.index = index\n\n    def __lt__(self, other):\n        if self.processingTime == other.processingTime:\n            return self.index < other.index\n        return self.processingTime < other.processingTime\n\n\ndef getOrder(tasks):\n    n = len(tasks)\n    taskList = []\n\n    for i in range(n):\n        task = Task(tasks[i][0], tasks[i][1], i)\n        taskList.append(task)\n\n    taskList.sort(key=lambda x: x.enqueueTime) \n\n    taskQueue = []  \n    result = []  \n    time = 0  \n    i = 0 \n\n    while i < n or taskQueue:\n        if not taskQueue:  \n            time = max(time, taskList[i].enqueueTime)\n\n        while i < n and taskList[i].enqueueTime <= time:  \n            heapq.heappush(taskQueue, taskList[i])\n            i += 1\n\n        if taskQueue:\n            task = heapq.heappop(taskQueue)\n            result.append(task.index)\n            time += task.processingTime\n\n    return result\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1633481827","body":"``` python \nclass Solution(object):\n    def numberOfRounds(self, loginTime, logoutTime):\n        \"\"\"\n        :type loginTime: str\n        :type logoutTime: str\n        :rtype: int\n        \"\"\"\n        start_hour, start_minute = map(int, loginTime.split(\":\"))\n        end_hour, end_minute = map(int, logoutTime.split(\":\"))\n\n        if end_hour < start_hour or (end_hour == start_hour and end_minute < start_minute):\n            end_hour += 24\n\n        start_rounded_minute = ((start_minute + 14) // 15) * 15\n        end_rounded_minute = (end_minute // 15) * 15\n\n        start_time = start_hour * 60 + start_rounded_minute\n        end_time = end_hour * 60 + end_rounded_minute\n\n        return max(0, (end_time - start_time) // 15)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635294035","body":"```python\nclass Solution(object):\n    def minCharacters(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n\n        def countChars(s):\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n            return count\n\n        count_a = countChars(a)\n        count_b = countChars(b)\n        n = len(a)\n        m = len(b)\n\n        # 计算满足条件1的最少操作数\n        min_ops = n + m - max(count_a[0] + count_b[0], count_a[-1] + count_b[-1])\n\n        # 计算满足条件2的最少操作数\n        for i in range(25):\n            count_a[i + 1] += count_a[i]\n            count_b[i + 1] += count_b[i]\n            ops = n - count_a[i] + count_b[i]\n            min_ops = min(min_ops, ops)\n            ops = m - count_b[i] + count_a[i]\n            min_ops = min(min_ops, ops)\n\n        # 计算满足条件3的最少操作数\n        same_char = n + m - max(count_a[25], count_b[25])\n        min_ops = min(min_ops, same_char)\n\n        return min_ops\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1636807504","body":"```python\nclass Solution:\n    def sortArray(self, nums):\n        sorted_nums = sorted(nums)\n        return sorted_nums\n\n# 示例1\nnums1 = [5, 2, 3, 1]\nsolution1 = Solution()\nsorted_nums1 = solution1.sortArray(nums1)\nprint(sorted_nums1)\n\n# 示例2\nnums2 = [5, 1, 1, 2, 0, 0]\nsolution2 = Solution()\nsorted_nums2 = solution2.sortArray(nums2)\nprint(sorted_nums2)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637000980","body":"``` python\nlass Solution:\n    def sqrt(self, x):\n        if x == 0 or x == 1:\n            return x\n\n        left, right = 1, x\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n                result = mid\n            else:\n                right = mid - 1\n\n        return result\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637266319","body":"```python \nclass Solution:\n    def __init__(self):\n        self.bad_version = 0\n\n    def isBadVersion(self, version):\n        # 调用API接口，判断版本是否出错\n        pass\n\n    def firstBadVersion(self, n):\n        left = 1\n        right = n\n\n        while left < right:\n            mid = left + (right - left) // 2\n            if self.isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n\n        return left\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1639241787","body":"``` python\nclass Solution:\n    def reversePairs(self, nums):\n        if len(nums) <= 1:\n            return 0\n\n        self.count = 0\n        self.mergeSort(nums, 0, len(nums) - 1)\n\n        return self.count\n\n    def mergeSort(self, nums, left, right):\n        if left >= right:\n            return\n\n        mid = (left + right) // 2\n\n        self.mergeSort(nums, left, mid)\n        self.mergeSort(nums, mid + 1, right)\n        self.merge(nums, left, mid, right)\n\n    def merge(self, nums, left, mid, right):\n        i = left\n        j = mid + 1\n\n        while i <= mid and j <= right:\n            if nums[i] > 2 * nums[j]:\n                self.count += mid - i + 1\n                j += 1\n            else:\n                i += 1\n\n        nums[left:right + 1] = sorted(nums[left:right + 1])\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/42#issuecomment-1641420653","body":"``` python\nimport math\n\nclass StreetLights:\n    def __init__(self, nums):\n        self.nums = sorted(nums)\n        self.n = len(nums)\n\n    def smallest_r(self):\n        min_r = float('inf')\n        \n        for i in range(self.n - 2):\n            for j in range(i + 1, self.n - 1):\n                mid = (self.nums[i] + self.nums[j]) / 2\n                max_dist = max(mid - self.nums[i], self.nums[j] - mid)\n                \n                for k in range(j + 1, self.n):\n                    dist = max(self.nums[k] - mid, max_dist)\n                    min_r = min(min_r, dist)\n        \n        return min_r / 2\n\nnums = [3, 4, 5, 6]\nlights = StreetLights(nums)\nprint(lights.smallest_r())\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1643050088","body":"``` python\nclass Solution:\n    def find_kth_smallest(self, nums, k):\n        distances = []\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                distances.append(abs(nums[i] - nums[j]))\n\n        distances.sort()\n        return distances[k]\n\n    def print_example(self):\n        nums = [1, 5, 3, 2]\n        k = 3\n\n        result = self.find_kth_smallest(nums, k)\n        print(result)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/44#issuecomment-1644993901","body":"``` python\nfrom collections import deque\nclass Solution:\n    def swimInWater(self, grid):\n        n = len(grid)\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = set()\n        queue = deque([(0, 0, grid[0][0])])  \n        while queue:\n            x, y, height = queue.popleft()\n            if x == n-1 and y == n-1:  \n                return height\n\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    next_height = max(height, grid[nx][ny])\n                    if next_height <= height:  \n                        queue.append((nx, ny, next_height))\n        return -1  \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/45#issuecomment-1646608872","body":"```python\ndef maxVowels(s: str, k: int) -> int:\n    vowels = set(['a', 'e', 'i', 'o', 'u'])\n    max_vowels = 0\n    current_vowels = 0\n    \n    # 计算初始窗口中的元音字母数\n    for i in range(k):\n        if s[i] in vowels:\n            current_vowels += 1\n    max_vowels = current_vowels\n    \n    # 滑动窗口计算所有子字符串中的最大元音字母数\n    for i in range(k, len(s)):\n        if s[i-k] in vowels:\n            current_vowels -= 1\n        if s[i] in vowels:\n            current_vowels += 1\n        max_vowels = max(max_vowels, current_vowels)\n    \n    return max_vowels\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/46#issuecomment-1646635056","body":"``` python\nclass Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        # 创建动态规划数组\n        dp = [0.0] * (K + W)\n        \n        # 计算累积概率\n        for i in range(K, N + 1):\n            dp[i] = 1.0\n        \n        # 计算剩余的概率\n        for i in range(K - 1, -1, -1):\n            for j in range(1, W + 1):\n                dp[i] += dp[i + j] / W\n        \n        return dp[0]\n\n# 创建示例对象并调用方法\nsolution = Solution()\nresult = solution.new21Game(N=10, K=1, W=10)\nprint(\"输出：{:.5f}\".format(result))\n\nresult = solution.new21Game(N=6, K=1, W=10)\nprint(\"输出：{:.5f}\".format(result))\n\nresult = solution.new21Game(N=21, K=17, W=10)\nprint(\"输出：{:.5f}\".format(result))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/47#issuecomment-1647041208","body":"``` python\nfrom collections import Counter\n\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        result = []\n        target = Counter(p)\n        \n        left = 0\n        current = Counter(s[:len(p)])\n        \n        while left <= len(s) - len(p):\n            if current == target:\n                result.append(left)\n                \n            if current[s[left]] > 1:\n                current[s[left]] -= 1\n            else:\n                del current[s[left]]\n            \n            if left + len(p) < len(s):\n                current[s[left + len(p)]] += 1\n            \n            left += 1\n        \n        return result\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/48#issuecomment-1648845510","body":"```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        target_count = {}\n        for char in t:\n            target_count[char] = target_count.get(char, 0) + 1\n\n        window_count = {}\n\n        formed = 0\n\n        start = 0\n        min_length = float('inf')\n\n        left = 0\n\n        for right in range(len(s)):\n            char = s[right]\n\n            window_count[char] = window_count.get(char, 0) + 1\n\n            if char in target_count and window_count[char] <= target_count[char]:\n                formed += 1\n\n            while formed == len(t):\n                if right - left + 1 < min_length:\n                    min_length = right - left + 1\n                    start = left\n\n                char = s[left]\n                window_count[char] -= 1\n                if char in target_count and window_count[char] < target_count[char]:\n                    formed -= 1\n                left += 1\n\n        if min_length == float('inf'):\n            return \"\"\n\n        return s[start:start+min_length]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/49#issuecomment-1650544149","body":"``` python\nclass Solution:\n    def minOperations(self, nums, target):\n        memo = {}\n\n        def dp(nums, target):\n            if target == 0:\n                return 0\n            if target < 0 or len(nums) == 0:\n                return float('inf')\n\n            if target in memo:\n                return memo[target]\n\n            option1 = dp(nums[:-1], target - nums[-1]) + 1\n            option2 = dp(nums[1:], target - nums[0]) + 1\n            result = min(option1, option2)\n            memo[target] = result\n            return result\n\n        result = dp(nums, target)\n\n        if result == float('inf'):\n            return -1\n        else:\n            return result\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/50#issuecomment-1652326020","body":"``` python\nclass Solution:\n    def readBinaryWatch(self, num: int) -> [str]:\n        result = []\n\n        def countBits(n):\n            count = 0\n            while n > 0:\n                if n & 1 == 1:\n                    count += 1\n                n >>= 1\n            return count\n        def getTimeString(hours, minutes):\n            return str(hours) + ':' + '{:02d}'.format(minutes)\n        for hours in range(12):\n            for minutes in range(60):\n                if countBits(hours) + countBits(minutes) == num:\n                    result.append(getTimeString(hours, minutes))\n\n        return result\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/51#issuecomment-1654955864","body":"``` python\nclass NQueens:\n    def __init__(self, n):\n        self.n = n\n        self.count = 0\n        self.columns = []\n\n    def solveNQueens(self):\n        self.backtrack(0)\n        return self.count\n\n    def backtrack(self, row):\n        if row == self.n:\n            self.count += 1\n            return\n\n        for col in range(self.n):\n            if self.is_valid(row, col):\n                self.columns.append(col)\n                self.backtrack(row + 1)\n                self.columns.pop()\n\n    def is_valid(self, row, col):\n        for r, c in enumerate(self.columns):\n            if c == col or r - c == row - col or r + c == row + col:\n                return False\n        return True\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/53#issuecomment-1657066896","body":"``` python\nclass Solution:\n    def maxDistance(self, grid):\n        rows = len(grid)\n        cols = len(grid[0])\n\n        ocean_queue = []\n        land_queue = []\n\n   \n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 0:\n                    ocean_queue.append((i, j))\n                else:\n                    land_queue.append((i, j))\n\n        if len(ocean_queue) == 0 or len(land_queue) == 0:\n            return -1\n\n        max_distance = -1\n\n   \n        while ocean_queue:\n            ocean_cell = ocean_queue.pop(0)\n\n         \n            x0, y0 = ocean_cell\n            for land_cell in land_queue:\n  \n                x1, y1 = land_cell\n                distance = abs(x0 - x1) + abs(y0 - y1)\n                max_distance = max(max_distance, distance)\n        return max_distance\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/54#issuecomment-1658599104","body":"```python\nclass Solution:\n    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        total_candies = 0\n        visited = set()\n        queue = []\n\n        for box in initialBoxes:\n            visited.add(box)\n            queue.append(box)\n\n        while queue:\n            box = queue.pop(0)\n            if status[box] == 0:\n                queue.append(box)\n            else:\n                total_candies += candies[box]\n                for key in keys[box]:\n                    if key not in visited:\n                        queue.append(key)\n                        visited.add(key)\n                for contained_box in containedBoxes[box]:\n                    queue.append(contained_box)\n                    visited.add(contained_box)\n\n        return total_candies\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/56#issuecomment-1662231894","body":"```python\nclass Solution:\n    def minCostClimbingStairs(self, cost):\n        n = len(cost)\n        if n < 2:\n            return 0\n\n        dp = [0] * (n + 1)  # 使用dp数组来保存截止每个阶梯的最低花费值\n\n        for i in range(2, n + 1):\n            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])\n\n        return dp[n]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/57#issuecomment-1663204095","body":"``` java\npublic int rob(int[] nums) {\n        int n = nums.length;\n        if (n == 0) {\n            return 0;\n        }\n        if (n == 1) {\n            return nums[0];\n        }\n        if (n == 2) {\n            return Math.max(nums[0], nums[1]);\n        }\n        int[] dp = new int[n];\n        dp[0] = nums[0];  // 第一个房屋的最高金额为其本身的金额\n        dp[1] = Math.max(nums[0], nums[1]);  // 第二个房屋的最高金额为两个房屋中金额较大的那个\n        for (int i = 2; i < n; i++) {\n            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]); //每一个房屋得到的金额已经是加上之前的了\n        }\n\n        return dp[n-1];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/58#issuecomment-1664721008","body":"``` python\nclass Solution:\n    def findNumberOfLIS(self, nums):\n        if not nums:\n            return 0\n        n = len(nums)\n        lengths = [1] * n  \n        counts = [1] * n   \n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if lengths[j] + 1 > lengths[i]:\n                        lengths[i] = lengths[j] + 1\n                        counts[i] = counts[j]\n                    elif lengths[j] + 1 == lengths[i]:\n                        counts[i] += counts[j]\n        max_length = max(lengths)\n        res = sum(count for length, count in zip(lengths, counts) if length == max_length)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/59#issuecomment-1666532682","body":"``` python\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[m][n]\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/61#issuecomment-1667056571","body":"```python\nclass Solution:\n    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:\n        directions = [(-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1)]\n        dp = [[0] * N for _ in range(N)]\n        dp[r][c] = 1\n\n        for _ in range(K):\n            temp = [[0] * N for _ in range(N)]\n            for i in range(N):\n                for j in range(N):\n                    for d in directions:\n                        nr, nc = i + d[0], j + d[1]\n                        if 0 <= nr < N and 0 <= nc < N:\n                            temp[nr][nc] += dp[i][j] / 8.0\n            dp = temp\n        prob = 0\n        for i in range(N):\n            for j in range(N):\n                prob += dp[i][j]\n        return prob\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/62#issuecomment-1668830610","body":"``` python\nclass Solution:\n    def canWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        if desiredTotal <= 0:\n            return True\n        if maxChoosableInteger * (maxChoosableInteger + 1) // 2 < desiredTotal:\n            return False\n        self.memo = {}\n        def canWinHelper(used: int, total: int) -> bool:\n            if total <= 0:\n                return False\n            if used in self.memo:\n                return self.memo[used]\n\n            for i in range(1, maxChoosableInteger + 1):\n                if not used & (1 << (i - 1)):\n                    if not canWinHelper(used | (1 << (i - 1)), total - i):\n                        self.memo[used] = True\n                        return True\n            self.memo[used] = False\n            return False\n        return canWinHelper(0, desiredTotal)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/63#issuecomment-1670500764","body":"``` python\nclass Solution:\n    def canPartition(self, nums) -> bool:\n        total_sum = sum(nums)\n        if total_sum % 2 != 0:\n            return False\n        target_sum = total_sum // 2\n        dp = [[False] * (target_sum + 1) for _ in range(len(nums) + 1)]\n        dp[0][0] = True\n        for i in range(1, len(nums) + 1):\n            num = nums[i - 1]\n            for j in range(target_sum + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= num:\n                    dp[i][j] = dp[i][j] or dp[i - 1][j - num]\n        return dp[len(nums)][target_sum]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/64#issuecomment-1673104266","body":"```python\nclass Solution:\n    def findTargetSumWays(self, nums, target):\n        total_sum = sum(nums)\n        if total_sum < target or (total_sum + target) % 2 != 0:\n            return 0\n        subset_sum = (total_sum + target) // 2\n        dp = [0] * (subset_sum + 1)\n        dp[0] = 1\n        for num in nums:\n            for i in range(subset_sum, num - 1, -1):\n                dp[i] += dp[i - num]\n\n        return dp[subset_sum]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/65#issuecomment-1674047898","body":"``` python\nclass Solution:\n    def coinChange(self, coins, amount):\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n        if dp[amount] == float('inf'):\n            return -1\n        else:\n            return dp[amount]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/66#issuecomment-1675769478","body":"``` python\nclass Solution:\n    def change(self, amount, coins):\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for coin in coins:  \n            for i in range(coin, amount + 1): \n                dp[i] += dp[i - coin]\n\n        return dp[amount]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/67#issuecomment-1676335963","body":"```python\nclass Solution:\n    def findContentChildren(self, g, s):\n        g.sort()\n        s.sort()\n\n        child_index = 0  \n        cookie_index = 0  \n        count = 0  \n        while child_index < len(g) and cookie_index < len(s):\n            if s[cookie_index] >= g[child_index]:\n                count += 1  \n                child_index += 1  \n            cookie_index += 1  \n        return count\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/68#issuecomment-1676589462","body":"``` python\nclass Solution:\n    def eraseOverlapIntervals(self, intervals):\n        if not intervals:\n            return 0\n        intervals.sort(key=lambda x: x[1])\n        count = 1  \n        end = intervals[0][1]  \n        for i in range(1, len(intervals)):\n            start = intervals[i][0]\n            if start >= end:\n                count += 1\n                end = intervals[i][1]\n        return len(intervals) - count\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/69#issuecomment-1677740559","body":"```python\nclass JumpGame:\n    def canJump(self, nums):\n        position = 0\n        for i in range(len(nums)):\n            if position >= len(nums) - 1:\n                return True\n            if nums[position] == 0:\n                return False\n            max_jump = nums[position]\n            position = position + max_jump\n        return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/70#issuecomment-1679285067","body":"``` python\nclass Solution:\n    def numTrees(self, n):\n        if n == 0 or n == 1:\n            return 1\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]\n\n# 示例用法\nsolution = Solution()\nn = 3\nresult = solution.numTrees(n)\nprint(result)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/71#issuecomment-1681771609","body":"``` python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeKLists(lists):\n    if not lists:\n        return None\n\n    while len(lists) > 1:\n        merged_lists = []\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i+1] if i+1 < len(lists) else None\n            merged = mergeTwoLists(l1, l2)\n            merged_lists.append(merged)\n        lists = merged_lists\n\n    return lists[0]\n\ndef mergeTwoLists(l1, l2):\n    if l1 is None:\n        return l2\n    if l2 is None:\n        return l1\n\n    if l1.val < l2.val:\n        l1.next = mergeTwoLists(l1.next, l2)\n        return l1\n    else:\n        l2.next = mergeTwoLists(l1, l2.next)\n        return l2\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/72#issuecomment-1683462416","body":"``` python\nclass Solution:\n    def beautifulArray(self, N):\n        if N == 1:\n            return [1]\n        odds = self.beautifulArray((N + 1) // 2)  \n        evens = self.beautifulArray(N // 2)  \n        return [2*x - 1 for x in odds] + [2*x for x in evens]\nsolution = Solution()\nN = 4\nbeautiful_array = solution.beautifulArray(N)\nprint(beautiful_array)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/73#issuecomment-1685256621","body":"``` python \nclass Solution:\n    def singleNumber(self, nums):\n        # 计算数组中所有元素的异或结果\n        xor_result = 0\n        for num in nums:\n            xor_result ^= num\n        # 获取异或结果中的最低位的1\n        lowest_bit = xor_result & (-xor_result)\n        # 根据最低位的1将数组分成两部分，并分别计算异或结果\n        result1 = 0\n        result2 = 0\n        for num in nums:\n            if num & lowest_bit:\n                result1 ^= num\n            else:\n                result2 ^= num\n        return [result1, result2]\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/74#issuecomment-1685255606","body":"``` python\nclass Solution:\n    def subsets(self, nums):\n        subsets = [[]]  # 初始为空集\n        for num in nums:\n            subsets += [subset + [num] for subset in subsets]\n        return subsets\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/75#issuecomment-1685661058","body":"``` python \nclass TrieNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end_of_word = False\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def _char_to_index(self, ch):\n        return ord(ch) - ord('a')\n\n    def insert(self, word):\n        current = self.root\n        for ch in word:\n            index = self._char_to_index(ch)\n            if not current.children[index]:\n                current.children[index] = TrieNode()\n            current = current.children[index]\n        current.is_end_of_word = True\n\n    def search(self, word):\n        current = self.root\n        for ch in word:\n            index = self._char_to_index(ch)\n            if not current.children[index]:\n                return False\n            current = current.children[index]\n        return current.is_end_of_word\n\n    def startsWith(self, prefix):\n        current = self.root\n        for ch in prefix:\n            index = self._char_to_index(ch)\n            if not current.children[index]:\n                return False\n            current = current.children[index]\n        return True\n\n\n# 示例用法\ntrie = Trie()\ntrie.insert(\"apple\")\nprint(trie.search(\"apple\"))  # 返回 True\nprint(trie.search(\"app\"))  # 返回 False\nprint(trie.startsWith(\"app\"))  # 返回 True\ntrie.insert(\"app\")\nprint(trie.search(\"app\"))  # 返回 True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/76#issuecomment-1688375079","body":"``` python\nclass MapSum:\n    def __init__(self):\n        self.map = {}\n\n    def insert(self, key, val):\n        self.map[key] = val\n\n    def sum(self, prefix):\n        total_sum = 0\n        for key, val in self.map.items():\n            if key.startswith(prefix):\n                total_sum += val\n        return total_sum\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/77#issuecomment-1689126041","body":"``` python \nclass SearchPositions:\n    def search_positions(self, big, smalls):\n        positions = []\n        for small in smalls:\n            indexes = []\n            start_index = 0\n            while True:\n                index = big.find(small, start_index)\n                if index == -1:\n                    break\n                indexes.append(index)\n                start_index = index + 1\n            positions.append(indexes)\n        return positions\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/78#issuecomment-1690869050","body":"``` python \nclass Solution:\n    def findCircleNum(self, isConnected):\n        n = len(isConnected)\n        visited = [False] * n\n        count = 0\n\n        def dfs(city):\n            visited[city] = True\n            for neighbor in range(n):\n                if isConnected[city][neighbor] == 1 and not visited[neighbor]:\n                    dfs(neighbor)\n\n        for city in range(n):\n            if not visited[city]:\n                dfs(city)\n                count += 1\n\n        return count\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/80#issuecomment-1694159889","body":"``` python\nclass Solution:\n    def makeConnected(self, n: int, connections):\n        if len(connections) < n - 1:\n            return -1\n        parent = list(range(n))\n        count = n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        def union(x, y):\n            nonlocal count\n            rootX, rootY = find(x), find(y)\n            if rootX != rootY:\n                parent[rootX] = rootY\n                count -= 1\n        for connection in connections:\n            union(connection[0], connection[1])\n        return count - 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/81#issuecomment-1694535658","body":"``` python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def pruneTree(self, root: TreeNode) -> TreeNode:\n        if root is None:\n            return None\n\n        root.left = self.pruneTree(root.left)\n        root.right = self.pruneTree(root.right)\n        if root.val == 0 and root.left is None and root.right is None:\n            return None\n        else:\n            return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/82#issuecomment-1694733236","body":"``` python\nclass Solution:\n    def combinationSum(self, candidates, target):\n        result = []\n        candidates.sort()\n        def backtrack(start, curr_list, curr_sum):\n            if curr_sum == target:\n                result.append(curr_list[:])\n                return\n            if curr_sum > target:\n                return\n            for i in range(start, len(candidates)):\n                curr_list.append(candidates[i]) \n                curr_sum += candidates[i] \n                backtrack(i, curr_list, curr_sum)\n                curr_list.pop()  \n                curr_sum -= candidates[i]  \n        backtrack(0, [], 0)\n\n        return result\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/83#issuecomment-1697653679","body":"``` python\nclass Solution:\n    def combinationSum2(self, candidates, target):\n        candidates.sort() \n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n\n    def dfs(self, candidates, target, start, path, res):\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:  \n                break\n            self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\n\n```\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/84#issuecomment-1698373422","body":"``` python\nclass Permutations:\n    def __init__(self):\n        self.result = []\n        \n    def permuteUnique(self, nums):\n        if not nums:\n            return []\n        \n        used = [False] * len(nums)\n        current_permutation = []\n        self.backtrack(sorted(nums), used, current_permutation)\n        \n        return self.result\n    \n    def backtrack(self, nums, used, current_permutation):\n        if len(current_permutation) == len(nums):\n            self.result.append(list(current_permutation))\n            return\n        \n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):\n                continue\n                \n            used[i] = True\n            current_permutation.append(nums[i])\n            self.backtrack(nums, used, current_permutation)\n            used[i] = False\n            current_permutation.pop()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/85#issuecomment-1700140475","body":"``` python\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        if not haystack or len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/86#issuecomment-1701363441","body":"``` python\nclass Solution:\n    def strStr(self, haystack, needle):\n        if not needle:\n            return 0\n\n        n = len(haystack)\n        m = len(needle)\n        for i in range(n - m + 1):\n            if haystack[i:i + m] == needle:\n                return i\n\n        return -1\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/90#issuecomment-1706056322","body":"``` python\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        # 使用字典存储每个字符出现的次数\n        freq_dict = {}\n        for c in s:\n            freq_dict[c] = freq_dict.get(c, 0) + 1\n\n        # 将字典按值降序排列\n        freq_list = sorted(freq_dict.items(), key=lambda item: item[1], reverse=True)\n\n        # 按排序后的顺序拼接结果字符串\n        res = \"\"\n        for item in freq_list:\n            res += item[0] * item[1]\n        return res\n\n# 示例用法\nsolution = Solution()\ns = \"tree\"\nresult = solution.frequencySort(s)\nprint(result)\n\ns = \"cccaaa\"\nresult = solution.frequencySort(s)\nprint(result)\n\ns = \"Aabb\"\nresult = solution.frequencySort(s)\nprint(result)\n```","onTime":true},null,null,null],"sosdogecoin":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585713150","body":"public int AddToArrayForm(int[] num, int k) {\r\nint result = k;\r\n    for (int i = 0; i > num.Length; i++) {\r\n      result = result + num[i] * Math.Pow(10,num.Length-i);}\r\n    return result;}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586215698","body":"def solution(s, c):\n\na = [i for i in range(len(s)) if c == s[i]]\nprint(a)\nb = []\n\nfor i in a:\n\n    for x in range(len(s)):\n\n        b.append(min(abs(x-i),abs(len(s)-x-i)))\n        \nreturn b\n\n复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587605946","body":"class CustomStack: \n\n    def __init__(self, maxSize: int): \n        self.stack = [] \n        self.max_size = maxSize \n\n    def push(self, x: int) -> None: \n        if len(self.stack) < self.max_size: \n            self.stack.append(x) \n\n    def pop(self) -> int: \n        if self.stack: \n            return self.stack.pop() \n        else: \n            return -1 \n\n    def increment(self, k: int, val: int) -> None: \n        for i in range(min(len(self.stack), k)): \n            self.stack[i] += val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589581610","body":"class CustomStack:\n\n    def __init__(self, size: int):\n        self.st = []\n        self.cnt = 0\n        self.size = size\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n\n\n    def pop(self) -> int:\n        if self.cnt == 0: return -1\n        self.cnt -= 1\n        return self.st.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(self.cnt, k)):\n            self.st[i] += val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1593327841","body":"class CustomStack: \n\n    def __init__(self, maxSize: int): \n        self.stack = [] \n        self.max_size = maxSize \n\n    def push(self, x: int) -> None: \n        if len(self.stack) < self.max_size: \n            self.stack.append(x) \n\n    def pop(self) -> int: \n        if self.stack: \n            return self.stack.pop() \n        else: \n            return -1 \n\n    def increment(self, k: int, val: int) -> None: \n        for i in range(min(len(self.stack), k)): \n            self.stack[i] += val","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593326161","body":"class Solution(object):\n    def maxChunksToSorted(self, arr):\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lrwhc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwewwt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyk1337":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585452280","body":"BF:\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        a = \"\".join([str(x) for x in num])\n        b = str(int(a)+k)\n        return [int(x) for x in b]\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587621148","body":"def __init__(self, maxSize: int): \n    self.stack = [] \n    self.max_size = maxSize \n\ndef push(self, x: int) -> None: \n    if len(self.stack) < self.max_size: \n        self.stack.append(x) \n\ndef pop(self) -> int: \n    if self.stack: \n        return self.stack.pop() \n    else: \n        return -1 \n\ndef increment(self, k: int, val: int) -> None: \n    for i in range(min(len(self.stack), k)): \n        self.stack[i] += val","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1606732805","body":"def serialize(self, root):\n    \"\"\"Encodes a tree to a single string.\n    \n    :type root: TreeNode\n    :rtype: str\n    \"\"\"\n    if not root:\n        return 'None'\n    return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))\n    \ndef deserialize(self, data):\n    \"\"\"Decodes your encoded data to tree.\n    \n    :type data: str\n    :rtype: TreeNode\n    \"\"\"\n    def dfs(dataList):\n        val = dataList.pop(0)\n        if val == 'None':\n            return None\n        root = TreeNode(int(val))\n        root.left = dfs(dataList)\n        root.right = dfs(dataList)\n        return root\n\n    dataList = data.split(',')\n    return dfs(dataList)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyu1131":[null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586828559","body":"```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        stack_.reserve(maxSize);\n        add_.resize(maxSize);\n        max_size_ = maxSize;\n    }\n    \n    void push(int x) {\n        if (stack_.size() < max_size_)\n        {\n            stack_.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if (!stack_.empty())\n        {\n            int idx = stack_.size();\n            int res = stack_.back();\n            res += add_[idx - 1];\n            if (idx != 1)\n            {\n                add_[idx - 2] += add_[idx - 1];\n            }\n            add_[idx - 1] = 0;\n            stack_.pop_back();\n            return res;\n        }\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        int size = stack_.size();\n        if (size == 0)\n        {\n            return;\n        }\n        k = min(k, size);\n        add_[k - 1] += val;\n    }\n\nprivate:\n    vector<int> stack_, add_;// add_用来记录要加的值\n    int max_size_;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589380614","body":"```c++\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // 获取一个数字并进栈\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // 左括号出栈\n                stk.pop_back();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // 构造字符串\n                while (repTime--) t += o; \n                // 将构造好的字符串入栈\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596131355","body":"```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (!head)\n        {\n            return nullptr;\n        }\n\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        ListNode* pre = nullptr;\n        while (fast)\n        {\n            fast = fast->next;\n            if (fast)\n            {\n                fast = fast->next;\n            }\n            pre = slow;\n            slow = slow->next;\n        }\n        // 找到slow为根节点\n        TreeNode* root = new TreeNode(slow->val);\n        if (pre)\n        {\n            pre->next = nullptr;\n        }\n        ListNode* next = slow->next;\n        slow->next = nullptr;\n\n        if (slow != head) //如果就是唯一的节点，那就没有左子树了\n        {\n            root->left = sortedListToBST(head);\n        }\n        root->right = sortedListToBST(next);\n\n        return root;\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605274995","body":"```C++\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        if (!root)\n        {\n            return 0;\n        }\n        int tmp = 0;\n        long long sum = 0;\n        preOrder(root, tmp, sum);\n        return (int) sum;\n    }\n\nprivate:\n    void preOrder(TreeNode* root, int& tmp, long long& sum)\n    {\n        if (!root->left && !root->right)\n        {\n            tmp = 10 * tmp + root->val;\n            sum += tmp;\n            tmp = tmp / 10;\n            return;\n        }\n\n        tmp = 10 * tmp + root->val;\n        if (root->left)\n        {\n            preOrder(root->left, tmp, sum);\n        }\n        if (root->right)\n        {\n            preOrder(root->right, tmp, sum);\n        }\n        tmp = tmp / 10;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"diana21170648":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585616818","body":"### 思路\n低位到高位遍历，注意进位\n\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n=len(num)-1\n        carry=0\n        ans=[]\n        for i in range(n,-1,-1):#从后往前遍历\n              num[i], carry=(carry+num[i]+k%10)%10,(carry+num[i]+k%10)//10\n              k//=10\n        #考虑998+2还需要进位\n        carry=carry+k\n        while carry:\n            ans=[(carry)%10]+ans\n            carry//=10\n        return ans+num\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586078968","body":"### 思路\n数组从两端遍历\n\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n=len(s)\n        res=[]\n        #标记字符c的位置，有则标记为0，没有则标记为None\n        for i in range(n):\n            if s[i]==c:\n                res.append(0)\n            else:\n                res.append(None)\n        #只需要遍历非0的位置\n        #从左向右遍历\n        for i in range(1,n):\n            if res[i] !=0 and res[i-1] is not None:\n                res[i]=res[i-1]+1\n        #从右向左遍历\n        for i in range(n-2,-1,-1):\n            if res[i] is None or res[i+1]+1 < res[i]:\n                res[i]=res[i+1]+1\n        return res\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586780839","body":"### 思路\n栈的实现，增量栈先出后加再入栈\n出栈主要边界-1\n入栈注意边界maxsize\n\n### 代码\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.st=[]\n        self.cnt=0\n        self.size=maxSize\n\n    def push(self, x: int) -> None:#判断是否满了，满了就不能添加到栈顶\n        if self.cnt<self.size:\n            self.st.append(x)\n            self.cnt+=1\n\n    def pop(self) -> int:#栈为空，则返回-1\n        if self.cnt==0:\n            return -1\n        self.cnt-=1\n        return self.st.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0,min(self.cnt,k)):\n            self.st[i]+=val\n\n```\n**复杂度分析**\n- 时间复杂度：O(min（k,cnt）)，其中 cnt为栈的可操作长度，k为要增量的个数。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1588693081","body":"### 思路\ndfs+栈 递归\n\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        def dfs(start):\n            rstr=rcnt=''#rstr为重复的字符串，rcnt为出现的重复的数字\n            while start<len(s):\n                if s[start].isnumeric():#是数字，可能有多位\n                    rcnt+=s[start]\n                elif s[start]=='[':#遇见左括号，开始递归\n                    start,tstr=dfs(start+1)#更新指针\n                    rstr=rstr+tstr*int(rcnt)\n                    rcnt=''#清空重复的数字\n                elif s[start]==']':#遇见右括号，则一次dfs结束\n                    return start,rstr\n                else:\n                    rstr+=s[start]\n                start+=1\n            return rstr\n        return dfs(0)#递归的入口\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为解码后s的长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590310082","body":"### 思路\n用两个栈实现一个先进先出的队列\npush进s1里\npop时，先判断s2非空，再pop进s2\npeek的是s2的队头元素\ns1和s2均空时，则为真，否则一直为false\n\n### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.s1=[]\n        self.s2=[]\n\n\n    def push(self, x: int) -> None:\n        self.s1.append(x)\n\n\n    def pop(self) -> int:\n        #先用oeak保证s2非空\n        self.peek()\n        return self.s2.pop()\n\n\n    def peek(self) -> int:\n        #把s1栈的元素压入栈s2\n        if not self.s2:#此时s2为空\n            while self.s1:\n                self.s2.append(self.s1.pop())\n        return self.s2[-1]\n\n\n    def empty(self) -> bool:#为空返回True\n        return not self.s1 and not self.s2\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为栈中元素的个数。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592695718","body":"### 思路\n单调升序栈，a比栈顶小，则a应该在栈顶的下边，所一栈顶出栈并记为最大值，然后pop所有有比a大的值，直到把a放进栈\n如果直接添加，则升序序列还在继续，则栈块数未增加，如果弹出再增加证明升序序列结束，压入元素，栈数增加1\n\n### 代码\n```python\nfrom typing import List\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int: \n        stack=[]\n        for a in arr:\n            if stack and stack[-1]>a:#单调升序栈，a比栈顶小，则a应该在栈顶的下边，所一栈顶出栈并记为最大值，然后pop所有有比a大的值，直到把a放进栈\n            #如果直接添加，则升序序列还在继续，则栈块数未增加，如果弹出再增加证明升序序列结束，压入元素，栈数增加1\n                cur=stack[-1]\n                while stack and stack[-1]>a:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)#stack存的是块信息，栈里存储的是所有块的最大值，栈的大小就是最终划分块的数量\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594568181","body":"### 思路\n思考：如果是个环的话就好办了，用next()指针,需要考虑当k大于链表长度的时候移出链表尾的情况，所以先对k2移动做了处理\n\n### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head:#判断链表是否为空\n            k1=head\n            k2=head\n            count=1#记录链表长度\n            num=0#记录已经旋转的节点数\n            while num<k:\n                if k2.next:#如果k2没有到结尾，则继续后移\n                #需要现将count+1，再移动k2，否则count少一位\n                    count+=1\n                    k2=k2.next\n                else:\n                    k=k%count#如果k的值大于链表的长度count,那么我们只需要将链表旋转count次就可以实现相同的效果\n                    num=-1#末尾的索引\n                    k2=head\n            #一个循环结束，继续下一个循环\n                num+=1\n            while k2.next:#k1和k2同事移动，直到k2到链表尾部\n                k1=k1.next\n                k2=k2.next\n            #如果k1和k2没有连着，那k2到达尾部时，k1之后还有元素，则将k1和之后的元素断开，此时k1就是链表尾部，然后保存下一个节点为cur\n            if k1.next:\n                cur=k1.next\n            else:\n                return head\n            #k2指向原链表的头部，把k1断开后保存的cur当做新的链表头\n            k1.next=None\n            k2.next=head\n            return cur\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为链表长度。\n- 空间复杂度：O(1)，没有占用其余空间，O（1）复杂度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595694707","body":"### 思路\n递归\n\n### 代码\n```python\nPython3 Code:\n\nclass Solution:\n   def swapPairs(self, head: ListNode) -> ListNode:\n       if not head or not head.next: return head\n\n       next = head.next\n       head.next = self.swapPairs(next.next)\n       next.next = head\n\n       return next\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596056476","body":"### 思路\n用双指针解题\n\n### 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        pre,slow,fast=None,head,head\n        while fast and fast.next:\n            fast=fast.next.next\n            pre=slow\n            slow=slow.next\n        if pre:\n            pre.next=None\n        node=TreeNode(slow.val)\n        if slow==fast:\n            return node\n        node.left=self.sortedListToBST(head)\n        node.right=self.sortedListToBST(slow.next)\n        return node\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)，其中 n为每一层的操作数，logn为二叉树的深度。\n- 空间复杂度：O(logn)，logn为二叉树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596442549","body":"### 思路\n法一用哈希表存储a，检查b是否在里面可以\n法二用双指针\n\n### 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a,b=headA,headB\n        while a !=b:\n            if a:\n                a=a.next\n            else:\n                a=headB\n            if b:\n                b=b.next\n            else:\n                b=headA\n        return a\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为链表长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598256703","body":"### 思路\n法一遍历链表，用哈希表存节点，第一次遍历两次的节点就是环的入口\n法二用双指针，快走两步，慢走一步，如果慢=快，证明有环，慢从头开始，快从相遇点开始，下次相遇点即为环的入口\n以下内容使用法二\n\n### 代码\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow,fast=head,head\n        x=None\n        while fast and fast.next:\n            fast=fast.next.next\n            slow=slow.next\n            if fast==slow:\n                x=fast\n                break\n        if not x:\n            return None\n        slow=head\n        while slow !=x:\n            slow=slow.next\n            x=x.next\n        return slow\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为链表的长度。\n- 空间复杂度：O(1)，使用快慢指针，未占用其它空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1599986053","body":"### 思路\npython有内置的的双向链表，OrderedDict\nget读操作操作的是头部，put写操作操作的是尾部\n链表增删容易，但是查找麻烦，所以用哈希表存起来，使得增删查都只需要O（1）\n\n\n### 代码\n```python\nfrom collections import OrderedDict\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.maxsize=capacity\n        self.LRUCache=OrderedDict()\n\n\n    def get(self, key: int) -> int:#读操作\n        if key in self.LRUCache:#在缓存中，移动到字典尾部，证明为最常使用的元素\n            self.LRUCache.move_to_end(key)\n        return self.LRUCache.get(key,-1)#-1代表最尾部的元素,找不到，返回-1\n\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.LRUCache:#写操作如果存在则删掉再重新赋值\n            del self.LRUCache[key]\n        self.LRUCache[key]=value#重新赋值的元素放在末尾\n        if len(self.LRUCache)>self.maxsize:#超出缓存容量，则删除字典的头部元素\n            self.LRUCache.popitem(last=False)\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(1)，增删查平均为O(1)\n- 空间复杂度：O(N),链表和哈希表的大小均为N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602691199","body":"### 思路\r\n遇到二叉树，就考虑dfs\r\n也可用层序遍历BFS\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=0, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为节点数。\r\n- 空间复杂度：O(h)，h为树的深度，最坏情况下h=N，这时候树转化为链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604236952","body":"### 思路\n法一用递归，法二用队列创建BFS实现层序遍历，法三用前序和中序遍历判断树的结构是否相同,以下程序用法二BFS\n\n### 代码\n```python\nfrom collections import deque\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not q and not p:\n            return True\n        if not q or not q:\n            return False\n        q1 = collections.deque([p])\n        q2 = collections.deque([q])\n        while q1 and q2:\n            node1 = q1.popleft()\n            node2 = q2.popleft()\n            if node1 is None and node2 is None:#判断node.val时需要判断是否为空，否则力扣代码提交会报错\n                continue  # 继续下一次循环\n            if node1 is None or node2 is None:\n                return False\n            if node1.val != node2.val:\n                return False\n            left1, right1 = node1.left, node1.right\n            left2, right2 = node2.left, node2.right\n            if (not left1) ^ (not left2):\n                return False\n            if (not right1) ^ (not right2):\n                return False\n            if left1:\n                q1.append(left1)\n            if right1:\n                q1.append(right1)\n            if left2:\n                q2.append(left2)\n            if right2:\n                q2.append(right2)\n        return not q1 and not q2\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为节点个数。\n- 空间复杂度：O(Q)，最长队列的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605312563","body":"### 思路\ndfs或bfs，求树的路径\n\n### 代码\n```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root,cur):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return cur*10+root.val\n            return dfs(root.left,cur*10+root.val)+ dfs(root.right,cur*10+root.val)\n        return dfs(root,0)\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为节点数目。\n- 空间复杂度：O(h)，h为二叉树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605844698","body":"### 思路\nbfs找最后一层第一个元素，一共queue\ndfs找最深层最后一个元素\n\n### 代码\n```python\nimport collections\nclass Solution(object):\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue=collections.deque()\n        queue.append(root)\n        while queue:\n            length=len(queue)\n            res=queue[0].val#队列最左边的值，即为结果\n            for _ in range(length):#处理当前层的所有节点\n                cur=queue.popleft()#如果本层不为空，则队列第一个值弹出，为本层腾地方\n                if cur.left:\n                    queue.append(cur.left)\n                if cur.right:\n                    queue.append(cur.right)\n        return res\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为节点数。\n- 空间复杂度：O(q)，q为队列的长度，最坏情况下为完全二叉树，此时，q=n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1606773636","body":"### 思路\n序列化就是遍历，把遍历的结果变成字符串，反序列化的时候，需要考虑序列化的顺序，以便更好地进行确定跟和各个节点的值\n\ndfs和bfs都能做，实现的过程有差别\n\n### 代码\n```python\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def preorder(root):\n            if not root:\n                return \"null,\"\n            return str(root.val)+\",\"+preorder(root.left)+preorder(root.right)\n        return preorder(root)[:-1]#对字符串切片，最后一个字符后不加逗号\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        nodes=data.split(\",\")\n        def preorder(i):\n            if i>=len(nodes) or nodes[i]==\"null\":\n                return i,None\n            root=TreeNode(nodes[i])\n            j,root.left=preorder(i+1)\n            k,root.right=preorder(j+1)\n            return k,root\n        return preorder(0)[1]\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为节点数目。\n- 空间复杂度：O(h)，h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1608657217","body":"### 思路\n三层排序，x排序哪一列，y排序哪一层，值排序满足同一列同位置元素递增\n\n### 代码\n```python\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        #用哈希表存储遍历的元素\n        seen=collections.defaultdict(lambda:collections.defaultdict(list))\n        def dfs(root,x=0,y=0):\n            if not root:\n                return\n            seen[x][y].append(root.val)\n            dfs(root.left,x-1,y+1)\n            dfs(root.right,x+1,y+1)\n        dfs(root)\n        ans=[]\n        #开始三层排序\n        for x in sorted(seen):\n            level=[]\n            for y in sorted(seen[x]):\n                level+=sorted(value for value in seen[x][y])\n            ans.append(level)\n        return ans\n\n```\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为节点数。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1611216553","body":"### 思路\n用哈希表做两数之和（也可以暴力法）\n\n### 代码\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        map={}\n        for i in range(len(nums)):\n            if nums[i] in map:\n                return [map[nums[i]],i]\n            map[target-nums[i]]=i\n        return []\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1612379592","body":"### 思路\n哈希表+堆排序\n\n### 代码\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        seen={}#哈希表存元素\n        for num in nums:\n            seen[num]=seen.get(num,0)+1\n        #建堆\n        heap=[]\n        for num,freq in seen.items():\n            #把数字和频率作为一个元组加到堆中\n            \n            heapq.heappush(heap,(freq,num))\n            #如果堆中元素超过k，则移除频率最低的元素\n            if len(heap)>k:\n                heapq.heappop(heap)\n        #将堆中剩余元素按频率从高到低加入到列表中，降序排序\n        res=[]\n        for i in range(k-1,-1,-1):\n            res.append(heapq.heappop(heap)[1])\n\n        return res[::-1]\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614063604","body":"### 思路\n回旋镖，一个点到其余两个点的距离相同，另两个点之间的距离不相同（等腰三角形）\n\n### 代码\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n=len(points)\n        ans=0\n        for i in range(n):\n            seen=collections.defaultdict(int)\n            for j in range(n):#顺序也需要考虑进去\n                dist=abs(points[i][0]-points[j][0])**2+abs(points[i][1]-points[j][1])**2#每对点之间距离的平方\n                seen[dist]+=1#把距离求出来放进哈希表\n            for count in seen.values():\n                ans+=count*(count-1)\n        return ans\n\n```\n**复杂度分析**\n- 时间复杂度：O(N^2)，其中 N 为元组数。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615680266","body":"### 思路\n先存入哈希表，然后用滑动窗口，窗口内只能出现不重复的元素，出现重复的元素，证明需要缩小窗口的范围，窗口的左边界和右边界用双指针处理\n自己最初的思路和暴力差不多，如果出现重复，则中断循环\nset集合无序且唯一，是更高效的统计方式\n\n### 代码\n```python\nimport collections\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen={}#collections.defaultdict()创建哈希表\n        left=right=0#创建双指针\n        ans=0\n        for char in range(len(s)):\n            char=s[right]\n            right+=1\n            seen[char]=seen.get(char,0)+1#求哈希表窗口里面元素的频率\n            while seen[char]>1:#先判断左边是够需要收缩，右边是确定了吗\n                left0=s[left]\n                left+=1\n                seen[left0]-=1\n            ans=max(ans,right-left)      \n            #seen[char].append()\n        return ans\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为str长度。\n- 空间复杂度：O(s)，字符集的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616428200","body":"### 思路\n两个哈希表，字符串,剪枝\n\n### 代码\n```python\nfrom typing import List\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        seen={}#第一个哈希表\n        #left=right=0\n        ans=[]\n        n=len(s)\n        m=len(words)\n        k=len(words[0])\n        if words is None or len(words)==0:\n            return ans\n\n        for word in words:#求每个单词出现的频率\n            seen[word]=seen.get(word,0)+1\n\n        for i in range(n-m*k+1):\n            #得到当前窗口字符串\n            cur_str=s[i:i+m*k]\n            #新建第二个哈希表，暂存words的组合字符串\n            temp={}\n            j=0\n\n            while j<len(cur_str):\n                #提取单词\n                word=cur_str[j:j+k]\n                #剪枝，很早了解，第一次见，剪枝就是退出的意思\n                if word not in seen:\n                    break\n                temp[word]=temp.get(word,0)+1#统计在temp里面word出现的频率\n                #继续剪枝\n                if temp[word]>seen[word]:\n                    break\n                j+=k\n            if j==len(cur_str):\n                ans.append(i)\n\n        return ans\n\n```\n**复杂度分析**\n- 时间复杂度：O(N*M*K)，n为s的长度，m为words的长度，k为单个word的长度。\n- 空间复杂度：O(M)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1617120969","body":"### 思路\n第一步，简历哈希表方便查找，第二步处理特殊情况即sums的和小于整数p\n\n### 代码\n```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        seen={0:-1}#以应对从数组索引 0 处开始取子数组的情况。注意：这是一个非常重要的技巧\n        sum_total=sum(nums)\n        n=len(nums)\n        cha=sum_total%p#10%6=4\n        cur=0\n        if sum_total<p:\n            return -1\n        if cha==0:\n            return 0\n        for i,x in enumerate(nums):#同时遍历索引和值\n            cur=(cur+x)%p#0+3%6=3，在计算当前前缀和的值\n            target=(cur-cha+p)%p#3-4+6=5%6=5，在计算目标前缀和的值\n            if target in seen:#在哈希表中有目标移除的值或数组\n                n=min(n,i-seen[target])#可移除的最小子数组的长度\n            seen[cur]=i#把前缀和的索引添加进哈希表\n        return -1 if n==len(nums) else n\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(min（N,cha）)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1619363578","body":"### 思路\n需要输出中间节点后面所有的内容，所以用快慢指针，一个走一步，一个走两步，如果要输出中间节点就可以用左右端点指针，一个指向头，一个指向尾\n\n### 代码\n```python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        #n=len(head)\n        left=right=head\n        #right=tail\n        while right and right.next:\n            left=left.next\n            right=right.next.next\n        return left\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为链表长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1620883315","body":"### 思路\n用快慢指针（读写指针）\n\n### 代码\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        left=right=0\n        if not nums:\n            return 0\n        while right<len(nums):\n            if nums[right]!=nums[left]:#如果不相等，则读指针后移，写指针也后\n                left+=1\n                nums[left]=nums[right]#保证最后返回的nums不重复\n            right+=1\n        return left+1#索引从0开始\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1623555482","body":"### 思路\n二分+双指针\n\n### 代码\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return 0\n        \n        left=0\n        right=len(nums)-1\n        while left<=right:\n            mid=(left+right)//2\n            if nums[mid]==target:\n                return mid\n            if nums[mid]<target:\n                left=mid+1\n            else:\n                right=mid-1\n        return left\n\n```\n**复杂度分析**\n- 时间复杂度：O(logn)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1624575481","body":"\n### 思路\n维护单调队列\n\n### 代码\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        ans=[]\n        q=collections.deque()\n        for i in range(len(nums)):\n            while q and nums[q[-1]]<=nums[i]:#队列不为空，且元素小，移除队尾元素\n                q.pop()\n            while q and i-q[0]>=k:#队列不为空，队头元素不在滑动窗口内，弹出队头移除失效元素\n                q.popleft()\n            q.append(i)\n            if i>=k-1:\n                ans.append(nums[q[0]])\n        return ans\n\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(k)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1626908984","body":"### 思路\n邻接矩阵，有向图，用两个数组，一个表示出度，一个表示入度，找入度为n-1且出度为0的索引，即是小镇法官\n\n### 代码\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_degree=[0]*(n+1)\n        out_degree=[0]*(n+1)\n        for i,j in trust:\n            in_degree[j]+=1\n            out_degree[i]+=1\n        for a in range(1,n+1):\n            if in_degree[a]==n-1 and out_degree[a]==0:\n                return a\n        return -1\n        \n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627648078","body":"### 思路\n用邻接矩阵建图，表示的是无向图，建议一个颜色数组，-1和1分别表示分组，0表示未进行着色分组，然后用dfs遍历，如果能将不喜欢的人二分分组，那么未true，如果不能分开，则返回false\n\n### 代码\n```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        #建图\n        graph=[[0]*n for _ in range(n)]\n        colors=[0]*n\n        for a,b in dislikes:\n            graph[a-1][b-1]=1#a不喜欢b\n            graph[b-1][a-1]=1#表示b不喜欢a\n        #对着色的节点进行循环\n        for i in range(n):\n            #如果i没着色，且着色后还是不能二分，则表示不能分开\n            if colors[i]==0 and not self.dfs(graph,colors,i,1,n):\n                return False\n        return True#排除所有不能二分分情况，那么最后能二分就是True\n    def dfs(self,graph,colors,i,color,n):\n        colors[i]=color\n        for j in range(n):#-1*color,乘以-1保证不会栈溢出\n            if graph[i][j]==1:\n                if colors[j]==color:\n                    return False\n                if colors[j]==0 and not self.dfs(graph,colors,j,-1*color,n):\n                    return False\n        return True\n        \n\n```\n**复杂度分析**\n- 时间复杂度：O(V+E)，其中 v是点数，e是边数。\n- 空间复杂度：O(V^2),邻接矩阵建图\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1628435519","body":"### 思路\n拓扑排序\n\n### 代码\n```python\nclass Solution:\n    # 拓扑排序\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n        # 先对组进行拓扑排序\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            # 对小组中的项目进行拓扑排序\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(M+N)，其中 N 为数组长度。\n- 空间复杂度：O(M+N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1629964280","body":"### 思路\n简单图题目，模拟是直接把题目翻译为代码即可\n以原点为坐标，左加右减，上加下减\n\n### 代码\n```python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x,y=0,0\n        for move in moves:\n            if move=='R':\n                x+=1\n            if move=='L':\n                x-=1\n            if move=='U':\n                y+=1\n            if move=='D':\n                y-=1\n        return x==0 and y==0\n    \n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为字符串长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1631763194","body":"### 思路\n使用堆，每一个位置存储一个元组，然后使用小顶堆，然后根据任务所花时长决定谁先进入cpu被处理，如果任务执行时间一样，则小的下标具有高的优先级,还需要注意一个开始时间\n\n### 代码\n```python\nfrom typing import  List\nimport heapq\ndef getorder(tasks:List[List[int]])->List[int]:\n    #为了不破坏原始索引，需要先对task做一个处理，加入索引\n    tasks=[(task[0],i,task[1])for i ,task in enumerate(tasks)]\n    tasks.sort()\n    A=[]#CPU运行的任务,队列\n    time=0\n    ans=[]\n    position=0\n    for _ in tasks:\n        if not A :\n            time=max(time,tasks[position][0])#没有运行的任务，那么时间直接跳到需要开始任务的时间\n        while position<len(tasks) and tasks[position][0]<=time:#当任务没结束且时间没开始，则将任务添加进堆中，也就是准备进行处理的队列把所有后续开始的任务加入堆中\n            heapq.heappush(A,(tasks[position][2],tasks[position][1]))\n            position+=1\n        d,j=heapq.heappop(A)#从堆中中取出一个任务，并将其加入到ans中\n        time+=d#d是任务开始的时间\n        ans.append(j) #j是  任务所需要花的时长\n    return ans\n\n        \ntasks=[[1,2],[2,4],[3,2],[4,1]]\nprint(getorder(tasks))   \n\n```\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(N),用了堆\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1633736617","body":"### 思路\n开始时间以右边的结束时间为主，结束时间以左边的\n\n### 代码\n```python\nclass Solution:\n    def numberOfRounds(self, startTime:str, finishTime:str)->int:\n        sh,sm=map(int,startTime.split(\":\"))\n        eh,em=map(int,finishTime.split(\":\"))\n        count_jinwei=0#看天数是否加1\n        #转换成分钟,看时间是否进位\n        if sh*60+sm>eh*60+em:\n            count_jinwei+=1\n\n        #处理开始时间：\n        if 0<sm<=15:\n            sm=15\n        elif 15<sm<=30:\n            sm=30\n        elif 30<sm<=45:\n            sm=45\n        elif 45<sm<=60:\n            sm=0\n            sh+=1#小时进位\n\n        #处理结束时间：\n        if 0<=em<15:\n            em=0\n        elif 15<=em<30:\n            em=15\n        elif 30<=em<45:\n            em=30\n        elif 45<=em<60:\n            em=45\n\n        start_shijian=sh*60+sm\n        end_shijian=eh*60+em\n        if count_jinwei==1:\n            end_shijian+=24*60\n        return max(0,(end_shijian-start_shijian))//15#把时间加一起之后取整\n#s=Solution()\n#startTime=\"12:01\"\n#finishTime=\"12:46\"\n#print(s.numberOfRounds1904(startTime,finishTime))\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635208722","body":"### 思路\n模拟计数，字母只有26个，所以可以用数组计数\n\n### 代码\n```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        counter_a=[0]*26#实际索引0-25\n        counter_b=[0]*26\n\n        #遍历找各字母出现的次数，最坏的情况就是a与b中所有字母都不同，那就需要m+n的长度\n        for aa in a:\n            counter_a[ord(aa)-ord('a')]+=1\n        for bb in b:\n            counter_b[ord(bb)-ord('a')]+=1\n\n        #开始计算转换,需要改变的最少字符数\n        ans=len(a)+len(b)\n        for i in range(26):\n            ans=min(ans,len(a)+len(b)-counter_a[i]-counter_b[i])\n        \n        #把a中所有字母变得比b小，需要转换的最少字符数\n        for i in range(1,26):#不从0开始是因为a就是0\n            t=0\n            for j in range(i,26):\n                t+=counter_a[j]\n            for j in range(i):\n                t+=counter_b[j]\n            ans=min(ans,t)\n        #把b中所有字母变得比a小，需要转换的最少字符数\n        for i in range(1,26):\n            t=0\n            for j in range(i,26):\n                t+=counter_b[j]\n            for j in range(i):\n                t+=counter_a[j]\n            ans=min(ans,t)\n        return ans\n\n\n\n\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N+M)，其中 N 为字符串a的长度，M为字符串b的长度。\n- 空间复杂度：O(26)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1636630717","body":"### 思路\n计数排序和快排都可以\n\n\n### 代码\n```python\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        cnt=[0]*(50000*2+1)\n        res=[]\n        #统计频率\n        for num in nums:\n            cnt[num+50000]+=1#存在负数，加5000使得数组下标为正\n        for i in range(len(cnt)):\n            res.extend([i-50000]*cnt[i])\n        return res\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(M),M=50000*2+1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637076479","body":"### 思路\n二分左加右减求左边界\n\n### 代码\n```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        ans,l,r=0,0,x\n        while l<=r:\n            mid=(l+r)//2\n            if mid**2<=x:\n                ans=mid\n                l=mid+1\n            if mid**2>x:\n                \n                r=mid-1\n        return int(ans)\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(logN)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637297862","body":"### 思路\n二分找左边界\n\n### 代码\n```python\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        l,r=1,n\n        while l<=r:\n            mid=(l+r)//2\n            if isBadVersion(mid):\n                r=mid-1\n            else:\n                l=mid+1\n        return l\n\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(logN)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1639226406","body":"### 思路\r\n二分\r\n\r\n### 代码\r\n```python\r\nfrom sortedcontainers import SortedList\r\nclass Solution:\r\n    #def reversePairs(self, nums: List[int]) -> int:\r\n    def reversePairs(self,A):\r\n        d=SortedList()\r\n        cnt=0\r\n        for a in A:\r\n            i=d.bisect_right(a*2)\r\n            cnt+=len(d)-i\r\n            d.add(a)\r\n        return cnt\r\n\r\n\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/42#issuecomment-1641317429","body":"### 思路\n二分找左边界\n\n### 代码\n```python\n\nclass Solution:\n    def solve(self, nums):\n        nums.sort()\n        N = len(nums)\n        if N <= 3:\n            return 0\n        LIGHTS = 3\n        # 这里使用的是直径，因此最终返回需要除以 2\n        def possible(diameter):\n            start = nums[0]\n            end = start + diameter\n            for i in range(LIGHTS):\n                idx = bisect_right(nums, end)\n                if idx >= N:\n                    return True\n                start = nums[idx]\n                end = start + diameter\n            return False\n\n        l, r = 0, nums[-1] - nums[0]\n        while l <= r:\n            mid = (l + r) // 2\n            if possible(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l / 2\n\n\n```\n**复杂度分析**\n- 时间复杂度：O()，其中 N 为数组长度。\n- 空间复杂度：O()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1643490305","body":"### 思路\n二分\n\n### 代码\n```python\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        nums.sort()\n\n        def count_not_greater(diff):\n            i = ans = 0\n            for j in range(1, len(nums)):\n                while nums[j] - nums[i] > diff:\n                    i += 1\n                ans += j - i\n            return ans\n\n        l, r = 0, nums[-1] - nums[0]\n        while l < =r:\n            mid = (l + r) // 2\n            if count_not_greater(mid) < k:\n                l = mid + 1\n            else:\n                r = mid-1\n        return l\n\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/44#issuecomment-1645656267","body":"### 思路\r\n二分找左边界\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def swimInWater(self, grid: List[List[int]]) -> int:\r\n        l, r = 0, max([max(vec) for vec in grid])\r\n        seen = set()\r\n\r\n        def test(mid, x, y):\r\n            if x > len(grid) - 1 or x < 0 or y > len(grid[0]) - 1 or y < 0:\r\n                return False\r\n            if grid[x][y] > mid:\r\n                return False\r\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1):\r\n                return True\r\n            if (x, y) in seen:\r\n                return False\r\n            seen.add((x, y))\r\n            ans = test(mid, x + 1, y) or test(mid, x - 1,\r\n                                              y) or test(mid, x, y + 1) or test(mid, x, y - 1)\r\n            return ans\r\n        while l <= r:\r\n            mid = (l + r) // 2\r\n            if test(mid, 0, 0):\r\n                r = mid - 1\r\n            else:\r\n                l = mid + 1\r\n            seen = set()\r\n        return l\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(NlogM)，其中 N 为grid长度，M为grid最大值。\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/45#issuecomment-1646597796","body":"### 思路\n滑动窗口\n\n### 代码\n```python\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        res = 0\n        temp = 0\n        vowels = set(['a','e','i','o','u'])\n        for i in range(k):\n            res += s[i] in vowels\n        if res==k: return k\n        temp = res\n        for i in range(k,len(s)):\n            temp += (s[i] in vowels) - (s[i-k] in vowels)\n            res = max(temp,res)\n            if res ==k: return k\n        return res\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为字符串长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/46#issuecomment-1646838718","body":"### 思路\n滑动窗口+动态规划\n\n### 代码\n```python\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        dp=[0]*(k+maxPts)#动态规划\n        sum=0#滑动窗口\n        for i in range(k,k+maxPts):\n            if i<=n:\n                dp[i]=1\n            sum+=dp[i]\n        for i in range(k-1,-1,-1):\n            dp[i]=sum/maxPts\n            sum+=dp[i]-dp[i+maxPts]\n        return dp[0]\n\n\n```\n**复杂度分析**\n- 时间复杂度：T=O(K+maxPts)，其中 N 为数组长度。\n- 空间复杂度：S=O(K+maxPts)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/47#issuecomment-1648033576","body":"\n### 思路\n滑动窗口\n\n### 代码\n```python\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        target = collections.Counter(p)\n        ans = []\n        for i in range(len(s)):\n            if i >= len(p):\n                target[s[i - len(p)]] += 1\n                if target[s[i - len(p)]] == 0:\n                    del target[s[i - len(p)]]\n            target[s[i]] -= 1\n            if target[s[i]] == 0:\n                del target[s[i]]\n            if len(target) == 0:\n                ans.append(i - len(p) + 1)\n        return ans\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为str长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/48#issuecomment-1649815450","body":"### 思路\n更新滑动窗口\n\n### 代码\n```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        l, counter, N, ct = 0, Counter(), len(s), Counter(t)\n        k = 0\n        ret, ans = inf, \"\"\n        for r in range(N):\n            counter[s[r]] += 1\n            if s[r] in t and counter[s[r]] == ct[s[r]]:\n                k += 1\n            while k == len(ct):\n                if r - l + 1 < ret:\n                    ans = s[l:r+1]\n                ret = min(r - l + 1, ret)\n                counter[s[l]] -= 1\n                if s[l] in t and counter[s[l]] == ct[s[l]]-1:\n                    k -= 1\n                l += 1\n        return ans\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N+k)。\n- 空间复杂度：O(s)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/49#issuecomment-1650836244","body":"### 思路\n滑动窗口+逆向思维\n\n### 代码\n```python\n  def solve(self, A, target):\n        if not A and not target: return 0\n        target = sum(A) - target\n        ans = len(A) + 1\n        i = t = 0\n\n        for j in range(len(A)):\n            t += A[j]\n            while i <= j and t > target:\n                t -= A[i]\n                i += 1\n            if t == target: ans = min(ans, len(A) - (j - i + 1))\n        return -1 if ans == len(A) + 1 else ans\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/50#issuecomment-1653560400","body":"### 思路\n用回溯处理二进制手表，笛卡尔积找两个集合的所有可能，剪枝处理所有不满足的情况\n\n### 代码\n```python\nfrom itertools import combinations\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        def possible_number(count,minute=False):\n            if count==0:\n                return [0]\n            if minute:\n                return filter(lambda a:a<60,map(sum,combinations([1,2,4,8,16,32],count)))\n            return filter(lambda a:a<12,map(sum,combinations([1,2,4,8],count)))\n        \n        ans=set()#用笛卡尔积表示两个集合的所有可能得组合，但是得处理不满足题目要求的情况\n        for i in range(min(4,turnedOn+1)):#到num+1处理所有可能的情况\n            for a in possible_number(i):\n                for b in possible_number(turnedOn-i,True):\n                    ans.add(str(a)+\":\"+str(b).rjust(2,'0'))\n        return list(ans)\n\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(2^N)。\n- 空间复杂度：O(2^N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/51#issuecomment-1655737003","body":"### 思路\ndfs+回溯\n\n### 代码\n```python\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def dfs(pre,i):\n            nonlocal queen\n            if i==n:\n                queen+=1\n                return\n            for j in range(n):\n                if j in col:\n                    if i-j in right and i+j in left:\n                        col.discard(j)\n                        right.discard(i-j)\n                        left.discard(i+j)\n                        dfs(pre+[j],i+1)\n                        col.add(j)\n                        right.add(i-j)\n                        left.add(i+j)\n            return\n        col=set(list(range(n)))\n        right=set(list(range(1-n,n,1)))\n        left=set(list(range(2*n)))\n        queen=0\n        dfs([],0)\n        return queen\n\n\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N！)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/52#issuecomment-1656526489","body":"### 思路\nBFS\n\n### 代码\n```python\nfrom collections import deque\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        m=len(grid)\n        ans=0\n        n=len(grid[0])\n        fangxiang=[(1,0),(-1,0),(0,1),(0,-1)]#表示上下左右\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]==1:#如果当前是陆地，开始bfs\n                    queue=deque([(i,j)])#当做元组添加进去\n                    grid[i][j]=0#标记为已访问，下一步开始岛屿面积加一\n                    area=1\n\n                    while queue:#队列不为空，就证明bfs还没有遍历结束\n                        x,y=queue.popleft()\n                        for fxx,fxy in fangxiang:\n                            newx,newy=x+fxx,y+fxy\n                            if 0<=newx<m and 0<=newy<n and grid[newx][newy]==1:\n                                queue.append((newx,newy))\n                                grid[newx][newy]=0\n                                area+=1\n                    ans=max(ans,area)\n        return ans\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(M*N)\n- 空间复杂度：O(M*N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/53#issuecomment-1657110995","body":"### 思路\nbfs+队列，陆地入队\n\n### 代码\n```python\n\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        n=len(grid)\n        steps=-1\n        queue=collections.deque([(i,j)for i in range(n) for j in range(n) if grid[i][j]==1])\n        if len(queue)==0 or len(queue)==n**2:\n            return steps\n        while len(queue)>0:\n            for _ in range(len(queue)):\n                x,y=queue.popleft()\n                for xi,yj in (x+1,y),(x-1,y),(x,y+1),(x,y-1):#遍历上下左右\n                    if xi>=0 and xi<n and yj>=0 and yj<n and grid[xi][yj]==0:#判断在格子范围内\n                        queue.append((xi,yj))\n                        grid[xi][yj]=-1#遍历过之后置为-1，表示已经处理过了，避免重复计算\n            steps+=1\n        return steps\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N*N)，其中 N 为数组长度。\n- 空间复杂度：O(N*N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/54#issuecomment-1657760729","body":"### 思路\n思路：把所有的开着的盒子和所有能找到钥匙的没开着的盒子添加进队列，然后找队列里面所有的糖果数即可，因为是树结构，所以能用BFS\n\n### 代码\n```python\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        boxes=set(initialBoxes)\n        queue=collections.deque([i for i in boxes if status[i]])\n        for i in queue:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    queue.append(j)\n            for j in keys[i]:\n                if status[j]==0 and j in boxes:\n                    queue.append(j)\n                status[j]=1\n        return sum(candies[i] for i in queue)\n\n```\n**复杂度分析**\n- 时间复杂度：O(N+K)，其中 N 为数组长度，K为钥匙数。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/55#issuecomment-1659474778","body":"### 思路\nBFS双端队列插入删除方便\n哈希表存储未被占用的值\n\n### 代码\n```python\nfrom collections import deque\nclass Solution:\n    def solve(self,root):\n        queue=collections.deque([root,0])\n        seen={}\n        while queue:\n            cur,pos=queue.popleft()\n            if pos not in seen:\n                seen(pos)=cur.value\n            if cur.left:\n                queue.append(cur.left,pos-1)\n            if cur.right:\n                queue.append(cur,right,pos+1)\n        return list(map(lambda x:x[1],sorted(seen.items(),key=lambda x:x[0])))#按键值排序的value值\n\n```\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为二叉树节点个数，使用了排序。\n- 空间复杂度：O(N)，使用了哈希表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/56#issuecomment-1661906857","body":"### 思路\n动态规划\n\n### 代码\n```python\n#20230802 第121(54)天 11：18\n#T=O(n)\n#S=O(1)，滚动数组优化\n\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        prev, curr = cost[0], cost[1]\n        for i in range(2, len(cost)+1):\n            next = min(prev, curr) + (cost[i] if i != len(cost) else 0)\n            prev, curr = curr, next\n        return curr\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/57#issuecomment-1663871148","body":"### 思路\n记忆化递归动态规划 打家劫舍\n\n### 代码\n```python\n#20230803 第122(55)天 \n#T=O(n)\n#S=O(1)\n#没用dp数组\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        n=len(nums)\n        if n==1:\n            return nums[0]\n        else:\n            pre=nums[0]\n            cur=max(nums[1],pre)\n            for i in range(2,n):\n                cur,pre=max(pre+nums[i],cur),cur\n            return cur\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)，使用了记忆化递归优化空间复杂度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/58#issuecomment-1664882405","body":"### 思路\n动态规划LIS\n\n\n### 代码\n```python\n\n\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n=len(nums)\n        dp=[[1,1]for i in range(n)]#[1,1]第一个1表示长度，第二个1表示个数\n        ans=[1,1]\n        longest=1\n        for i in range(n):\n            for j in range(i+1,n):\n                if nums[j]>nums[i]:\n                    if dp[i][0]+1>dp[j][0]:\n                        dp[j][0]=dp[i][0]+1\n                        dp[j][1]=dp[i][1]\n                        longest=max(longest,dp[j][0])\n                    elif dp[j][0]==dp[i][0]+1:\n                        dp[j][1]+=dp[i][1]\n        return sum(dp[i][1] for i in range(n) if dp[i][0]==longest)\n\n```\n\n**复杂度分析**\n时间复杂度：O(N^2)，其中 N 为数组长度。\n空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/59#issuecomment-1666499650","body":"### 思路\n动态规划\n\n### 代码\n```python\nclass Solution:\n    def longestCommonSubsequence(self, A: str, B: str) -> int:\n        m, n = len(A), len(B)\n        ans = 0\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if A[i - 1] == B[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    ans = max(ans, dp[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return ans\n\n```\n**复杂度分析**\n- 时间复杂度：O(M*N)，其中 N 为数组长度。\n- 空间复杂度：O(M*N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/60#issuecomment-1666784431","body":"### 思路\nDP\n\n### 代码\n```python\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp=[[1]*n for _ in range(m)]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j]=dp[i-1][j]+dp[i][j-1]\n        return dp[m-1][n-1]\n\n```\n**复杂度分析**\n- 时间复杂度：O(M*N)，其中 M,N 为数组长度。\n- 空间复杂度：O(M*N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/61#issuecomment-1667137795","body":"### 思路\n动态规划先确定八个方向，再分贝求概率，再得出结果\n\n### 代码\n```python\nclass Solution:\n    def knightProbability(self, n: int, k: int, row: int, col: int) -> float:\n        directions=[[-1,-2],[1,-2],[2,-1],[2,1],[1,2],[-1,2],[-2,1],[-2,-1]]\n        dp=[[0.0]*n for _ in range(n)]\n        dp[row][col]=1.0\n        for step in range(1,k+1):\n            dp_temp=[[0.0]*n for _ in range(n)]\n            for i in range(n):\n                for j in range(n):\n                    for direction in directions:\n                        old_row=i-direction[0]\n                        old_col=j-direction[1]\n                        if 0<=old_row<n and 0<=old_col<n:\n                            dp_temp[i][j]+=dp[old_row][old_col]*0.125\n            dp=dp_temp\n        res=0.0\n        for i in range(n):\n            for j in range(n):\n                res+=dp[i][j]\n        return res\n\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(k*N^2)，其中 N 为数组长度。\n- 空间复杂度：O(N^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/62#issuecomment-1668777429","body":"### 思路\n动态规划\n\n### 代码\n```python\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        if desiredTotal <= maxChoosableInteger:\n            return True\n        if sum(range(maxChoosableInteger + 1)) < desiredTotal:\n            return False\n\n        @lru_cache(None)\n        def dp(picked, acc):\n            if acc >= desiredTotal:\n                return False\n            if picked == (1 << (maxChoosableInteger + 1)) - 1:\n                return False\n            for n in range(1, maxChoosableInteger + 1):\n                if picked & 1 << n == 0:\n                    if not dp(picked | 1 << n, acc + n):\n                        return True\n            return False\n\n        return dp(0, 0)\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(2^m)\n- 空间复杂度：O(2^m)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/63#issuecomment-1670786409","body":"### 思路\n动态规划\n\n### 代码\n```python\n\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        tar=sum(nums)//2\n        if tar+tar !=sum(nums):\n            return False\n        dp=[False]*(tar+1)\n        dp[0]=True\n        for i in range(1,len(nums)+1):\n            for j in range(tar,0,-1):\n                if dp[j] or (j-nums[i-1]>-1 and dp[j-nums[i-1]]):\n                    dp[j]=True\n        return dp[-1]\n\n```\n**复杂度分析**\n- 时间复杂度：O(N*N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/64#issuecomment-1673072310","body":"### 思路\n动态规划解决背包问题\n\n### 代码\n```python\n\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        t=sum(nums)+abs(target)\n        if t%2:\n            return 0\n        t=t//2#背包的大小\n        dp=[0]*(t+1)\n        dp[0]=1\n        for i in range(len(nums)):\n            for j in range(t,nums[i]-1,-1):\n                #if j - nums[i] >= 0:\n                dp[j]+=dp[j-nums[i]]\n        return dp[-1]\n\n```\n**复杂度分析**\n- 时间复杂度：T=O(fushu*(sum(nums)+target))/2\n- 空间复杂度：S=O(sum(nums)+target)/2\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/65#issuecomment-1674435494","body":"### 思路\n可以重复取值的完全背包\n\n### 代码\n```python\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp=[amount+1]*(amount+1)\n        dp[0]=0\n        \n        for i in range(1,amount+1):\n            for coin in coins:\n                if i>=coin:#还没有达到目标值则更新dp，取小值\n                    dp[i]=min(dp[i],dp[i-coin]+1)#dp是要取的最少硬币数，在统计数量\n        return -1 if dp[amount]==amount+1 else dp[amount]\n\n```\n**复杂度分析**\n- 时间复杂度：O(N*amount)，其中 N 为len(coins)。\n- 空间复杂度：O(amount),背包容量大小就是空间复杂度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/66#issuecomment-1675602494","body":"### 思路\n滚动数组优化，动态规划，注意硬币倒着往前选择\n\n### 代码\n```python\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp=[0]*(amount+1)#求max，dp初始化为0\n        dp[0]=1\n        for j in range(len(coins)):#硬币大小\n            for i in range(1,amount+1):#背包大小\n                if i>=coins[j]:\n                    #dp[i - coins[j]] 表示在从总金额中减去当前硬币面额的值后，剩余的金额的方法数\n                    #硬币面额小于当前面额，才能通过硬币组合实现amount\n                    dp[i]+=dp[i-coins[j]]#选择i，dp[i]表示凑成zmount的次数\n        return dp[-1]\n\n```\n**复杂度分析**\n- 时间复杂度：O(n*amount)，n=len(coins)。\n- 空间复杂度：O(amount),amount即为背包的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/67#issuecomment-1676326237","body":"### 思路\n贪心，选大饼干先满足胃口大的\n\n### 代码\n```python\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        s.sort(reverse=True)\n        g.sort(reverse=True)\n        si,gi=0,0\n        count=0\n        #当孩子没有满足且饼干还有剩余\n        while si<len(s) and gi<len(g):\n            #如果饼干值大于孩子的胃口值，证明可以满足孩子的胃口\n            if s[si]>=g[gi]:\n                count+=1\n                si+=1#饼干分完\n            gi+=1#开始满足下一个孩子\n        return count\n\n```\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/68#issuecomment-1676579981","body":"### 思路\nlis\n\n### 代码\n```python\nclass Solution:\n    def LIS(SELF,A:List[int])->int:\n        d=[]#存储最长递增子序列的元素\n        for s,e in A:\n            i=bisect.bisect_left(d,e)\n            if i<len(d):\n                d[i]=e\n            elif not d or d[-1]<=s:\n                d.append(e)\n        return len(d)\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        n=len(intervals)\n        if n==0:\n            return 0\n        ans=1#至少考虑一个不重叠的区间\n        intervals.sort(key=lambda a:a[0])\n        return n-self.LIS(intervals)\n\n```\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/69#issuecomment-1678959159","body":"### 思路\n具体就是用一个变量记录当前能够到达的最大的索引\n\n\n### 代码\n```python\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        m_max=0\n        n=len(nums)\n        for i in range(n-1):\n            if m_max<i:\n                return Fslse\n            m_max=max(m_max,nums[i]+i)\n            if m_max>=n-1:\n                return True\n        return m_max>=n-1\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/70#issuecomment-1680542461","body":"### 思路\n用笛卡尔积计算所有组合\n用哈希表优化时间复杂度\n分治\n\n### 代码\n```python\nclass Solution:\n    visited=dict()\n    def numTrees(self, n: int) -> int:\n        if n in self.visited:\n            return self.visited.get(n)\n        if n<=1:\n            return 1\n        ans=0\n        for i in range(1,n+1):\n            ans+=self.numTrees(i-1)*self.numTrees(n-i)#笛卡尔积\n        self.visited[n]=ans\n        return ans\n\n```\n**复杂度分析**\n- 时间复杂度：O(N^2)。\n- 空间复杂度：O(N),递归栈的深度和哈希表均为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/71#issuecomment-1681593439","body":"### 思路\n先合并两个，两两合并最后再合到一起\n\n\n### 代码\n```python\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        n = len(lists)\n\n        # basic cases\n        if n == 0: return None\n        if n == 1: return lists[0]\n        if n == 2: return self.mergeTwoLists(lists[0], lists[1])\n\n        # divide and conqure if not basic cases\n        mid = n // 2\n        return self.mergeTwoLists(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:n]))\n\n\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        res = ListNode(0)\n        c1, c2, c3 = l1, l2, res\n        while c1 or c2:\n            if c1 and c2:\n                if c1.val < c2.val:\n                    c3.next = ListNode(c1.val)\n                    c1 = c1.next\n                else:\n                    c3.next = ListNode(c2.val)\n                    c2 = c2.next\n                c3 = c3.next\n            elif c1:\n                c3.next = c1\n                break\n            else:\n                c3.next = c2\n                break\n\n        return res.next\n\n```\n**复杂度分析**\n- 时间复杂度：O(knlogk)，其中 N 为数组长度。\n- 空间复杂度：O(logk)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/72#issuecomment-1683252607","body":"### 思路\n问题分解为子问题，递归解决，注意需要分为奇数和偶数\n\n### 代码\n```python\nclass Solution:\n    def beautifulArray(self, N: int) -> List[int]:\n        @lru_cache(None)\n        def dp(n):#递归调用\n            if n==1:\n                return [1]\n            ans=[]\n            for i in dp(n-n//2):\n                ans+=[i*2-1]\n            for j in dp(n//2):\n                ans+=[j*2]\n            return ans\n        return dp(N)\n\n```\n**复杂度分析**\n- 时间复杂度：O(2^N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/73#issuecomment-1684752977","body":"### 思路\n用哈希表做空间复杂度不满足题意，所以用了位运算\n\n### 代码\n```python\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xor=a=b=0\n        n=len(nums)\n        first_bit=1\n        for i in nums:#将所有的数字异或，会只剩下只出现一次的的数字不为零，相当于筛选出来了只出现一次的元素\n            xor ^=i\n        while first_bit & xor==0:#与运算，找不同的低位\n            first_bit<<=1#左移一位相当于乘以2，直到找到低位bit为1的num\n\n        for i in nums:#异或之后的nums\n            if first_bit & i:\n                a ^=i\n            else:\n                b ^=i\n        return [a,b]\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/74#issuecomment-1685247948","body":"### 思路\n用位运算决定每一个元素去还是不取\n\n### 代码\n```python\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        ans,end=[],1<<len(nums)\n        for i in range(end):\n            subset=[]\n            for j in range(len(nums)):\n                if  ((1<<j)&i)!=0:\n                    subset.append(nums[j])\n            ans.append(subset)\n        return ans   \n\n```\n**复杂度分析**\n- 时间复杂度：O(N*2N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/75#issuecomment-1685770392","body":"### 思路\n前缀树\n\n### 代码\n```python\nclass TireNode:\n    def __init__(self):\n        self.count=0\n        self.perCount=0\n        self.children={}#字典\n\n\nclass Trie:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.root=TireNode()\n\n\n    def insert(self, word: str) -> None:\n        \"\"\"\n        Inserts a word into the trie.\n        \"\"\"\n        node=self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char]=TireNode()\n            node=node.children[char]\n            node.perCount+=1\n        node.count+=1\n\n\n\n    def search(self, word: str) -> bool:\n        \"\"\"\n        Returns if the word is in the trie.\n        \"\"\"\n        node=self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node=node.children[char]\n        return node.count>0\n            \n\n\n    def startsWith(self, prefix: str) -> bool:\n        \"\"\"\n        Returns if there is any word in the trie that starts with the given prefix.\n        \"\"\"\n        node=self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node=node.children[char]\n        return node.perCount>0\n\n```\n**复杂度分析**\n- 时间复杂度：O(1)创建Tire，插入查找和匹配为O(N)\n- 空间复杂度：O(char总字数*字符集的大小)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/76#issuecomment-1687799562","body":"### 思路\n哈希表\n\n### 代码\n```python\nclass MapSum:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.hashmap={}\n\n    def sum(self,prefix: str ) -> int :\n        count=0\n        for key in self.hashmap:\n            if key.startswith(prefix):\n                count+=self.hashmap[key]\n        return count\n\n    def insert(self,key: str, val: int ) ->None:\n        self.hashmap[key]=val#没有就插入，有就覆盖\n\n\n```\n**复杂度分析**\n- 时间复杂度：insert是O(1)，sum是O(N*S,)其中 N 为key的个数，s是前缀长度。\n- 空间复杂度：O(N),N为不重复的key的个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/77#issuecomment-1689162629","body":"### 思路\ntire\n暴力\nKMP\n\n### 代码\n```python\nclass Solution:\n    class TrieNode:\n        def __init__(self):\n            self.children = [None] * 26  # 存储子节点\n            self.isWord = False  # 标记是否为单词的结束\n            self.id = 0  # 存储小字符串的索引\n\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\n        root = self.TrieNode()  # 初始化根节点\n        \n        n = len(smalls)\n        res = [[] for _ in range(n)]  # 初始化结果集\n        \n        # 建树\n        for i in range(n):\n            self.insert(root, smalls[i], i)  # 插入小字符串到 Trie 树中\n        \n        for i in range(len(big)):\n            tmp = root\n            for j in range(i, len(big)):\n                if not tmp.children[ord(big[j]) - ord('a')]:\n                    break  # 如果当前字符不存在于 Trie 树中，退出循环\n                \n                tmp = tmp.children[ord(big[j]) - ord('a')]\n                \n                if tmp.isWord:\n                    res[tmp.id].append(i)  # 将找到的索引添加到结果集\n        \n        # 返回二维数组\n        ret = []\n        for i in range(n):\n            ret.append(res[i])\n        \n        return ret\n\n    def insert(self, root: TrieNode, word: str, id: int):\n        tmp = root\n        for i in range(len(word)):\n            if not tmp.children[ord(word[i]) - ord('a')]:\n                tmp.children[ord(word[i]) - ord('a')] = self.TrieNode()  # 创建新的节点\n            \n            tmp = tmp.children[ord(word[i]) - ord('a')]\n        \n        tmp.isWord = True  # 标记为一个单词的结束\n        tmp.id = id  # 存储小字符串的索引\n\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N*k)，其中 N 为敏感词最长单词长度，K为big长度。\n- 空间复杂度：O(s),匹配成功位置的个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/78#issuecomment-1690949459","body":"### 思路\nDFS\nBFS\n并查集\n\n### 代码\n```python\nclass UF:\n    def __init__(self,n)->None:\n        self.parent={i: i for i in range(n)}\n        self.size=n\n    \n    def find(self,i):\n        if self.parent[i] !=i:\n            self.parent[i]=self.find(self.parent[i])\n        return self.parent[i]\n    \n    def connect(self,i,j):#如果同一个子集相连，并查集数量不变，如果属于不同的自己相连，那么数量需要减一\n        root_i,root_j=self.find(i),self.find(j)\n        if root_i !=root_j:\n            self.size-=1\n            self.parent[root_i]=root_j\n\nclass Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        n=len(isConnected)\n        uf=UF(n)\n        for i in range(n):\n            for j in range(n):\n                if isConnected[i][j]:\n                    uf.connect(i,j)\n        return uf.size\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为矩阵M的大小。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/79#issuecomment-1693011857","body":"### 思路\r\n并查集\r\ndfs\r\n\r\n### 代码\r\n```python\r\nclass UF: \r\n    def __init__ (self):\r\n        self.father={}\r\n        self.size={}\r\n    def find(self,x):\r\n        self.father.setdefault(x,x)\r\n        if x !=self.father[x]:\r\n            self.father[x]=self.find(self.father[x])\r\n        return self.father[x]\r\n    def connect(self,x,y):\r\n        fx,fy=self.find(x),self.find(y)\r\n        if self.size.setdefault(fx,1)<self.size.setdefault(fy,1):\r\n            self.father[fx]=fy\r\n            self.size[fy]+=self.size[fx]\r\n        elif fx!=fy:\r\n            self.father[fy]=fx\r\n            self.size[fx] +=self.size[fy]\r\nclass Solution:\r\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\r\n        uf=UF()\r\n        for i in range(len(graph)):\r\n            for j in range(i,len(graph)):\r\n                if graph[i][j]:\r\n                    uf.connect(i,j)\r\n        initial.sort()\r\n        max_size,index,fi=0,-1,[]\r\n        cnt=collections.defaultdict(int)\r\n        for init in initial:\r\n            fi.append(uf.find(init))\r\n            cnt[fi[-1]]+=1\r\n        for i in range(len(initial)):\r\n            if cnt[fi[i]]>1:\r\n                continue\r\n            if uf.size[fi[i]]>max_size:\r\n                max_size=uf.size[fi[i]]\r\n                index=initial[i]\r\n        return index if index !=-1 else initial[0]\r\n\r\n\r\n\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N*alpha（n）)，其中 N 为矩阵长度长度，n为按秩合并的次数。\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/80#issuecomment-1694215843","body":"### 思路\n并查集/dfs\n\n### 代码\n```python\nclass Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        root=[i for i in range(n)]\n        def find(p):\n            while p !=root[p]:\n                root[p]=root[root[p]]#路径压缩\n                p=root[p]#便于下一次循环操作\n            return p\n        def union(p,q):\n            root[find(p)]=find(q)\n        \n        rongyu=0\n        for connec in connections:\n            a,b=connec\n            if find(a) !=find(b):\n                union(a,b)\n            else:\n                rongyu+=1#a和b处于一个集合，那么冗余的线就多一根\n\n        diff_root=set()\n        for i in range(n):\n            diff_root.add(find(i))\n        return len(diff_root)-1 if rongyu>=len(diff_root)-1 else -1\n        #缺线缆则返回-1   \n\n```\n**复杂度分析**\n- 时间复杂度：O(logx)，其中 x 为查找的次数，O(logy)，y为连接的次数。\n- 空间复杂度：O(n),n为计算机的个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/81#issuecomment-1694606861","body":"### 思路\n二叉树剪枝\n\n### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pruneTree(self, root: TreeNode) -> TreeNode:\n        A={}\n        def minTree(node):\n            if not node:\n                return None\n            if node in A:\n                return A[node]\n            left=minTree(node.left)\n            right=minTree(node.right)\n            if not left:\n                node.left=None\n            if not right:\n                node.right=None\n            ans=node.val==1 or left or right\n            return ans\n        return root if minTree(root) else None\n\n```\n**复杂度分析**\n- 时间复杂度：O(H)，其中 H为二叉树的高度。\n- 空间复杂度：O(N)，最坏的结果是剪掉所有的枝","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/82#issuecomment-1694886778","body":"### 思路\n回溯\n剪枝\n\n### 代码\n```python\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(ans,temp,candidates,tar,start):\n            if tar<0:\n                return\n            elif tar==0:\n                return ans.append(temp.copy())\n            for i in range(start,len(candidates)):\n                temp.append(candidates[i])\n                backtrack(ans,temp,candidates,tar-candidates[i],i)#代表数字可以重复使用\n                temp.pop()\n        ans=[]\n        backtrack(ans,[],candidates,target,0)\n        return ans\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N^H)，其中 N 为数组长度,H为递归栈的最大深度。\n- 空间复杂度：O(H)，H为递归栈的最大深度.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/83#issuecomment-1696689140","body":"### 思路\n回溯忘记pop了，老报错\n\n### 代码\n```python\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        n=len(candidates)\n        if n==0:\n            return []\n        candidates.sort()\n        temp=[]\n        ans=[]\n        def backtrack(curcandidates,target,n,curSum,indBgein,temp,ans):\n            if curSum==target:\n                ans.append(temp.copy())\n            for i in range(indBgein,n):\n                nextSum=curSum+curcandidates[i]\n                if nextSum>target:\n                    break\n                if i>indBgein and  curcandidates[i-1]==curcandidates[i]:\n                    continue\n                temp.append(curcandidates[i])\n                backtrack(curcandidates,target,n,nextSum,i+1,temp,ans)\n                temp.pop()\n        backtrack(candidates,target,n,0,0,temp,ans)\n        return ans\n\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N*2^n)，其中 N 为数组长度。\n- 空间复杂度：O(Target/N)，递归调用栈深度和记录路径的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/84#issuecomment-1698377039","body":"### 思路\n回溯剪枝，去掉重复解看先处理左边，再处理右边\n\n### 代码\n```python\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        def backtrack(nums,pre):\n            nonlocal res\n            if len(nums)<=1:\n                res.append(pre+nums)\n                return\n            for key,value in enumerate(nums):\n                if value not in nums[:key]:\n                    backtrack(nums[:key]+nums[key+1:],pre+[value])\n        res=[]\n        if not len(nums):\n            return []\n        backtrack(nums,[])\n        return res\n\n\n```\n**复杂度分析**\n- 时间复杂度：O(N!*op(res))，其中 N 为数组长度。\n- 空间复杂度：O(N*N!)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/85#issuecomment-1700292750","body":"### 思路\r\n暴力法时间复杂度m*n，滚动哈希选的好，直接是m+n\r\n\r\n### 代码\r\n```python\r\n#暴力法和滚动哈希\r\n\r\nclass Solution:\r\n    def strStr(self, haystack: str, needle: str) -> int:\r\n        if not haystack and  not needle:\r\n            return 0\r\n        if not haystack or len(haystack)<len(needle):\r\n            return -1\r\n        if not needle:\r\n            return 0\r\n\r\n        hash_val=0\r\n        tar=0\r\n        prime=101\r\n\r\n        for i in range(len(haystack)):\r\n            if i<len(needle):\r\n                hash_val=hash_val*26+(ord(haystack[i])-ord(\"a\"))\r\n                hash_val%=prime\r\n                tar=tar*26+(ord(needle[i])-ord(\"a\"))\r\n                tar%=prime\r\n            else:\r\n                hash_val = (hash_val - (ord(haystack[i - len(needle)]) - ord(\"a\")) * ((26 ** (len(needle) - 1)) % prime)) * 26 + (ord(haystack[i]) - ord(\"a\"))#更新哈希表的值，减去左边，加上右边\r\n                hash_val%=prime\r\n\r\n            if  i>=len(needle)-1 and hash_val==tar and haystack[i-len(needle)+1:i+1]==needle:\r\n                return i-len(needle)+1\r\n        return 0 if hash_val==tar and haystack[i-len(needle)+1:i+1]==needle else -1\r\n\r\n\r\n\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N+M)，其中 N 为haystacy数组长度,M为needle的长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/86#issuecomment-1702117917","body":"### 思路\nkmp\n\n### 代码\n```python\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        n, m = len(haystack), len(needle)\n        if m > n:\n            return -1\n        if not needle:\n            return 0\n\n        def computeNext(needle):  # 更改为不与内置函数冲突的名称\n            next = [0] * m\n            j = 0\n            for i in range(1, len(needle)):\n                while j > 0 and needle[i] != needle[j]:\n                    j = next[j - 1]\n                if needle[i] == needle[j]:\n                    j += 1\n                next[i] = j\n            return next\n\n        next_arr = computeNext(needle)  # 使用与内置函数不冲突的变量名\n        i, j = 0, 0\n        while i < n and j < m:\n            if haystack[i] == needle[j]:\n                i += 1\n                j += 1\n            else:\n                if j > 0:\n                    j = next_arr[j - 1]\n                else:\n                    i += 1\n        if j == m:\n            return i - j\n        return -1\n\n```\n**复杂度分析**\n- 时间复杂度：O(N+M)，其中 N 为数组长度。\n- 空间复杂度：O(M)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/87#issuecomment-1703765572","body":"### 思路\n小顶堆，数组短排序也行，就是时间复杂度高一点\n\n### 代码\n```python\n#k大的小顶堆\n\nimport heapq\n\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        n=len(nums)\n        h=[]\n        for i in range(k):\n            heapq.heappush(h,nums[i])\n        for i in range(k,n):\n            if nums[i]>h[0]:\n                heapq.heapreplace(h,nums[i])\n        return h[0]\n         \n\n```\n**复杂度分析**\n- 时间复杂度：O(Nlogk)，其中 N 为数组长度。\n- 空间复杂度：O(k)，小顶堆空间换时间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/88#issuecomment-1703998145","body":"### 思路\n建立堆，两两比较，再考虑舍弃还是入堆，然后知道达到边界条件，就是只有一个元素的时候，返回堆顶元素，达到目标\n\n### 代码\n```python\nclass Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        h=[-stone for stone in stones]\n        heapq.heapify(h)\n        while len(h)>1:\n            a,b=heapq.heappop(h),heapq.heappop(h)\n            if a !=b:\n                heapq.heappush(h,a-b)\n        return -h[0] if h else 0\n\n```\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度,logN为堆的插入删除复杂度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/89#issuecomment-1704480518","body":"### 思路\n归并排序\n\n### 代码\n```python\n#先合并两个，两两合并最后再合到一起\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        n = len(lists)\n\n        # basic cases\n        if n == 0: return None\n        if n == 1: return lists[0]\n        if n == 2: return self.mergeTwoLists(lists[0], lists[1])\n\n        # divide and conqure if not basic cases\n        mid = n // 2\n        return self.mergeTwoLists(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:n]))\n\n\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        res = ListNode(0)\n        c1, c2, c3 = l1, l2, res\n        while c1 or c2:\n            if c1 and c2:\n                if c1.val < c2.val:\n                    c3.next = ListNode(c1.val)\n                    c1 = c1.next\n                else:\n                    c3.next = ListNode(c2.val)\n                    c2 = c2.next\n                c3 = c3.next\n            elif c1:\n                c3.next = c1\n                break\n            else:\n                c3.next = c2\n                break\n\n        return res.next\n\n```\n**复杂度分析**\n- 时间复杂度：O(Nlogk)，其中 N 为链表所有节点的个数，logk为归并排序的层数。\n- 空间复杂度：O(logk)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/90#issuecomment-1705847027","body":"### 思路\n哈希表统计次数\n优先队列排序\n出堆构成降序字符串\n\n### 代码\n```python\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        dict={}\n        for ch in s:\n            dict[ch]=dict.get(ch,0)+1\n        pq=sorted(dict.items(),key=lambda x:x[1],reverse=True)\n        res=[]#存储结果\n        for ch,count in pq:\n            #count=dict[ch]\n            res.append(ch*count)\n        return ''.join(res)\n\n```\n**复杂度分析**\n- 时间复杂度：O(N+KlogK)，其中 N 为字符串个数，K为不重复字符串个数。\n- 空间复杂度：O(K)，最坏情况下，均不重复，K=N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/91#issuecomment-1707567044","body":"### 思路\n堆二分找有序矩阵中的第K小\n\n### 代码\n```python\nclass Solution:\n    def notGreaterCount(self, matrix, target):\n        # 等价于在matrix中搜索mid，搜索的过程中利用有序的性质记录比mid小的元素个数\n\n        # 我们选择左下角，作为开始元素\n        curRow = 0\n        # 多少列\n        COL_COUNT = len(matrix[0])\n        # 最后一列的索引\n        LAST_COL = COL_COUNT - 1\n        res = 0\n\n        while curRow < len(matrix):\n            # 比较最后一列的数据和target的大小\n            if matrix[curRow][LAST_COL] < target:\n                res += COL_COUNT\n            else:\n                i = COL_COUNT - 1\n                while i >= 0 and matrix[curRow][i] > target:\n                    i -= 1\n                # 注意这里要加1\n                res += i + 1\n            curRow += 1\n\n        return res\n\n    def kthSmallest(self, matrix, k):\n        if len(matrix) < 1:\n            return None\n        start = matrix[0][0]\n        end = matrix[len(matrix) - 1][len(matrix[0]) - 1]\n        while start < end:\n            mid = start + ((end - start) >> 1)\n            count = self.notGreaterCount(matrix, mid)\n            if count < k:\n                start = mid + 1\n            else:\n                end = mid\n        # 返回start，mid，end都一样\n        return start\n\n```\n**复杂度分析**\n- 时间复杂度：O(Nlog（r-l）)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,null],"61hhh":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585692895","body":"### 思路\n\n逐位求和并考虑进位问题，求和需要判断 num、k 是否没有取完，每次计算更新值\n\n\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        int carry = 0;\n        for (int i = n - 1; i >= 0 || k > 0 || carry > 0; i--) {\n            int sum = carry;\n            if (i >= 0) {\n                sum += num[i];\n            }\n            if (k > 0) {\n                sum += k % 10;\n                k /= 10;\n            }\n            res.add(sum % 10);\n            carry = sum / 10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586212707","body":"### 思路\n\n遍历计算每个字符最近的左 c 保存距离、遍历计算每个字符最近的右 c ，取更小值保存距离。每次匹配到 c 就更新下标\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pos = -len;\n        // 找到每个字符左边最近的c，计算距离\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pos = i;\n            }\n            res[i] = i - pos;\n        }\n        // 找到每个字符右边最近的c，计算距离，与左c取更小值\n        pos = 2 * len;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pos = i;\n            }\n            res[i] = Math.min(res[i], pos - i);\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587183271","body":"### 代码\n\n```java\nclass CustomStack {\n\n    int[] stack;\n    int maxSize;\n    int top;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.stack = new int[maxSize];\n        this.top = 0;\n    }\n\n    public void push(int x) {\n        if (top < maxSize) {\n            stack[top++] = x;\n        }\n    }\n\n    public int pop() {\n        if (top > 0) {\n            return stack[--top];\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < stack.length; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589442375","body":"### 思路\n\n两个栈分别存储数字和字符，tmp记录普通字符串、num记录重复次数\n\n遇到字符就追加tmp、遇到数字就算num值、遇到左括号就将tmp+num压栈并重置、遇到右括号两栈分别出栈，将tmp重复num次拼接到字符后\n\n### 代码\n\n```java\nclass Solution {\n    Stack<StringBuilder> strs = new Stack<>();\n    Stack<Integer> nums = new Stack<>();\n    StringBuilder tmp = new StringBuilder();\n    int num = 0;\n\n    public String decodeString(String s) {\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                tmp.append(c);// 普通字符加入当前记录字符串中\n            }\n            if (Character.isDigit(c)) {\n                num = num * 10 + c - '0';// 数字可能有多位\n            }\n            if (c == '[') {\n                // [ 前数字入栈并初始化为0\n                nums.push(num);\n                num = 0;\n                // [ 前的字符串暂存入栈、重置字符串\n                strs.push(tmp);\n                tmp = new StringBuilder();\n            }\n            if (c == ']') {\n                // 括号内的字符串用于重复\n                StringBuilder inner = tmp;\n                Integer times = nums.pop();\n                // []内字符串拼接在 strs 栈顶字符后面\n                tmp = strs.pop();\n                while (times-- > 0) {\n                    tmp.append(inner);\n                }\n                num = 0;\n            }\n        }\n        return tmp.toString();\n    }\n}\n```\n\n\n### 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591422577","body":"### 思路\n\n栈 s1 用于模拟队列，s2 用于输入栈，栈顶元素用一个额外的元素存储\n\n### 代码\n\n```java\nclass MyQueue {\n\n    Stack<Integer> s1 = new Stack<>();\n    Stack<Integer> s2 = new Stack<>();\n    int front;\n\n    public MyQueue() {\n\n    }\n\n    public void push(int x) {\n        if (s1.empty()) {\n            front = x;\n        }\n        while (!s1.empty()) {\n            s2.push(s1.pop());\n        }\n        s2.push(x);\n        while (!s2.empty()) {\n            s1.push(s2.pop());\n        }\n    }\n\n    public int pop() {\n        int ans = s1.pop();\n        if (!s1.empty()) {\n            front = s1.peek();\n        }\n        return ans;\n    }\n\n    public int peek() {\n        return front;\n    }\n\n    public boolean empty() {\n        return s1.isEmpty();\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593246800","body":"### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < n; i++) {\n            if (stack.isEmpty() || arr[i] >= stack.peek()) {\n                stack.push(arr[i]);\n            } else {\n                int top = stack.pop();\n                while (!stack.isEmpty() && arr[i] < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(top);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594885356","body":"### 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        // 计算长度\n        int len = 1;\n        ListNode cur = head;\n        while (cur.next != null) {\n            cur = cur.next;\n            len++;\n        }\n        // 实际移动次数\n        k = k % len;\n        if (k == 0) {\n            return head;\n        }\n        // 首尾相连\n        cur.next = head;\n        // 计算需要断开的点、断开链表\n        ListNode last = head;\n        for (int i = 0; i < len - k - 1; i++) {\n            last = last.next;\n        }\n        ListNode newHead = last.next;\n        last.next = null;\n\n        return newHead;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595777232","body":"### 代码\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        // pre.next总是指向待交换节点的前一个\n        ListNode pre = dummy;\n\n        while ((head != null) && (head.next != null)) {\n            ListNode first = head;\n            ListNode second = first.next;\n            // 交换节点\n            pre.next = second;\n            first.next = second.next;\n            second.next = first;\n            // pre后移\n            pre = first;\n            head = first.next;\n        }\n        return dummy.next;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596169765","body":"### 代码\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n\n        // 找到链表的中间节点\n        ListNode slow = head, fast = head.next.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        // 以中间节点的值创建根节点\n        TreeNode root = new TreeNode(slow.next.val);\n\n        // 递归地构建左子树和右子树\n        ListNode rightHead = slow.next.next;\n        slow.next = null;\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(rightHead);\n\n        return root;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596652167","body":"### 代码\n\n```java\npublic class Solution {\n\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA;\n        ListNode pB = headB;\n        \n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598963678","body":"代码\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while (true) {\n            // 没环时fast先结束 fast速度为2 要判断fast和fast.next 避免NPE\n            if (fast == null || fast.next == null) {\n                return null;\n            }\n            fast = fast.next.next;\n            slow = slow.next;\n            // 相遇时退出循环\n            if (fast == slow) {\n                break;\n            }\n        }\n        // 重置slow到起点 同速度前进\n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n}\n```\n复杂度分析\n● 时间复杂度：O(n)\n● 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600345415","body":"### 思路\n双向链表+哈希表，哈希表存储key到链表节点的映射，链表节点存储key，value；初始化的head、tail作为dummyNode简化链表操作；操作后更新节点到头部；查出容量删除尾部节点\n### 代码\n```java\nclass LRUCache {\n    public final ListNode head;\n    public final ListNode tail;\n    public final Map<Integer, ListNode> map;\n    public final int capacity;\n\n    public LRUCache(int capacity) {\n        this.map = new HashMap<>();\n        this.capacity = capacity;\n        this.head = new ListNode(-1, -1);\n        this.tail = new ListNode(-1, -1);\n        head.next = tail;\n        tail.pre = head;\n    }\n\n    public int get(int key) {\n        ListNode node = map.get(key);\n        if (node == null) {\n            return -1;\n        }\n        refreshNew(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        ListNode node = map.get(key);\n        if (node != null) {// 存在则更新value\n            node.value = value;\n            refreshNew(node);\n        } else {\n            ListNode newNode = new ListNode(key, value);\n            map.put(key, newNode);\n            addToHead(newNode);\n            if (map.size() > capacity) {\n                ListNode toRemove = removeOld();\n                map.remove(toRemove.key);\n            }\n        }\n    }\n\n    // 操作的节点移到最前面\n    public void refreshNew(ListNode node) {\n        // 删除node原有的位置关联\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n        // 添加到头部\n        addToHead(node);\n    }\n\n    public void addToHead(ListNode node) {\n        node.next = head.next;\n        node.pre = head;\n        node.next.pre = node;\n        head.next = node;\n    }\n\n    // 移除最旧的节点\n    public ListNode removeOld() {\n        ListNode removeNode = tail.pre;\n        tail.pre = removeNode.pre;\n        removeNode.pre.next = tail;\n        return removeNode;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：get、put 复杂度 O(1)\n- 空间复杂度：O(capacity)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1608662001","body":"BFS遍历+优先级队列\n```java\npublic class Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if (root == null) {\n            return res;\n        }\n        Map<Integer, List<Pair>> map = new HashMap<>();\n        Queue<Pair> queue = new PriorityQueue<>();\n        queue.offer(new Pair(root, 0, 0));\n        int minCol = 0, maxCol = 0;\n        while (!queue.isEmpty()) {\n            Pair curr = queue.poll();\n            int row = curr.row;\n            int col = curr.col;\n            TreeNode node = curr.node;\n            map.putIfAbsent(col, new ArrayList<>());\n            map.get(col).add(curr);\n            minCol = Math.min(minCol, col);\n            maxCol = Math.max(maxCol, col);\n            if (node.left != null) {\n                queue.offer(new Pair(node.left, row + 1, col - 1));\n            }\n            if (node.right != null) {\n                queue.offer(new Pair(node.right, row + 1, col + 1));\n            }\n        }\n        for (int i = minCol; i <= maxCol; i++) {\n            List<Pair> pairs = map.get(i);\n            Collections.sort(pairs);\n            List<Integer> column = new ArrayList<>();\n            for (Pair pair : pairs) {\n                column.add(pair.node.val);\n            }\n            res.add(column);\n        }\n        return res;\n    }\n\n    class Pair implements Comparable<Pair> {\n        TreeNode node;\n        int row;\n        int col;\n\n        public Pair(TreeNode node, int row, int col) {\n            this.node = node;\n            this.row = row;\n            this.col = col;\n        }\n\n        @Override\n        public int compareTo(Pair other) {\n            if (this.row != other.row) {\n                return Integer.compare(this.row, other.row);\n            } else if (this.col != other.col) {\n                return Integer.compare(this.col, other.col);\n            } else {\n                return Integer.compare(this.node.val, other.node.val);\n            }\n        }\n    }\n}\n```\n\n### 复杂度\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1610806636","body":"### 思路\n\n哈希表存储数值与index映射\n\n### 代码\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int minusNum = target - nums[i];\n            if (map.containsKey(minusNum)) {\n                return new int[]{map.get(minusNum), i};\n            }\n            map.put(nums[i], i);\n        }\n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}\n```\n\n\n\n### 复杂度\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1612706105","body":"### 代码\n\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        // 频率存到 hashMap\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            int times = map.getOrDefault(num, 0);\n            map.put(num, times + 1);\n        }\n        // 构建大根堆\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return map.get(o2) - map.get(o1);\n            }\n        });\n        for (Integer key : map.keySet()) {\n            maxHeap.offer(key);\n        }\n        // 取出前 K 个\n        int[] result = new int[k];\n        int index = 0;\n        while (index < k) {\n            result[index++] = maxHeap.poll();\n        }\n        return result;\n    }\n}\n```\n\n### 复杂度\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614042734","body":"### 代码\n\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();// 距离:相同距离的点数量\n        for (int i = 0; i < points.length; i++) {\n            // 遍历其他点 统计其他点到点i的距离\n            for (int j = 0; j < points.length; j++) {\n                if (i == j) {\n                    continue;\n                }\n                int distance = calDistance(points[i], points[j]);\n                map.put(distance, map.getOrDefault(distance, 0) + 1);\n            }\n            // 相同距离点集中取两个与当前点i构成回旋镖\n            // 考虑顺序用排列 A(n,2) = n*(n-1);\n            for (int val : map.values()) {\n                res += val * (val - 1);\n            }\n            map.clear();// 清空map\n        }\n        return res;\n    }\n\n    private int calDistance(int[] p1, int[] p2) {\n        int x = p2[0] - p1[0];\n        int y = p2[1] - p1[1];\n        return x * x + y * y;\n    }\n}\n```\n\n### 复杂度\n\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1623875939","body":"###思路\n\n二分查找\n\n### 代码\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while (left <= right) {\n            int mid = (right - left) / 2 + left;\n            if (nums[mid] == target) {\n                return mid;\n            }\n            if (nums[mid] > target) {\n                right = mid - 1;\n            }\n            if (nums[mid] < target) {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```\n\n### 复杂度分析\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1630388583","body":"### 代码\n```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        for (char move : moves.toCharArray()) {\n            if (move == 'R') {\n                x++;\n            } else if (move == 'L') {\n                x--;\n            } else if (move == 'U') {\n                y++;\n            } else if (move == 'D') {\n                y--;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}\n```\n\n### 复杂度\n- 时间复杂度：遍历moves，O(n)\n- 空间复杂度：无额外存储，O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quaaaaaack":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acy925":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585027784","body":"### 思路\n两步：\n第一步：先把给的数组合成一个数；\n第二步：把合成的数加上给的数，再按上面的过程逆着一遍，变成数组。\n\n### 代码\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n\n        a = 0\n        for i in num:\n            a = a * 10 + i\n        a = a + k\n\n        ans = []\n        while a != 0:\n            ans.append(a % 10)\n            a = a // 10\n        \n        return ans[::-1]\n\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组num长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1585786044","body":"### 思路\n\n将问题分解为两次遍历数组。\n首先，从左到右遍历，同时维护一个记录字符 s 位置的变量。记录数组每个元素到该变量的距离。（注：变量初始值为负无穷）\n然后，从右到左遍历，同时维护一个记录字符 s 位置的变量。记录数组每个元素到该变量的距离。（注：变量初始值为正无穷）\n最后，比较上述两个距离，最小值为结果。\n\n\n### 代码\n\n\n```python\nclass Solution(object):\n    def shortestToChar(self, S, C):\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(S):\n            if x == C: prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in range(len(S) - 1, -1, -1):\n            if S[i] == C: prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586402648","body":"### 思路\n\n列表实现栈，一个指针变量记录栈顶元素的位置，最后可以优化成全部 O(1)\n\n### 代码\n\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.add = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        ans = self.stk[self.top] + self.add[self.top]\n        if self.top != 0:\n            self.add[self.top - 1] += self.add[self.top]\n        self.add[self.top] = 0\n        self.top -= 1\n        return ans\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k - 1, self.top)\n        if lim >= 0:\n            self.add[lim] += val\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589262511","body":"### 思路\n\n递归，找到 k[ ... ]，中间的递归\n\n### 代码\n\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        def dfs(s, i):\n            res, multi = \"\", 0\n            while i < len(s):\n                if '0' <= s[i] <= '9':\n                    multi = multi * 10 + int(s[i])\n                elif s[i] == '[':\n                    i, tmp = dfs(s, i + 1)\n                    res += multi * tmp\n                    multi = 0\n                elif s[i] == ']':\n                    return i, res\n                else:\n                    res += s[i]\n                i += 1\n            return res\n        return dfs(s,0)\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591208678","body":"### 代码\n\n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595786316","body":"### 思路\n        # 两两swap,反转节点的基本操作 p->a->b->\n        # 头节点会变化，所以要增加虚拟头节点p\n        \n        # 三板斧\n        #1、让虚拟头节点p指向b\n        #2、让a指向b.next\n        #3、让b指向a\n        # 然后 p 移动到a，继续该过程\n\n\n### 代码\n\n\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n        dummy = ListNode(-1,head)\n        p = dummy\n        \n        while p.next and p.next.next:\n            a,b = p.next,p.next.next\n            p.next = b\n            a.next = b.next\n            b.next = a\n            \n            p = a\n        return dummy.next\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1595936563","body":"### 代码\n\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n\n\n\n```\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1599014336","body":"### 思路\n快慢指针\n\n### 代码\n\n\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if fast == slow:\n                break\n        if fast is None or fast.next is None:\n            return None\n        \n        slow = head\n        while slow != fast:\n            fast = fast.next\n            slow = slow.next\n        return slow\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1599490421","body":"### 思路\r\n\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass ListNode: # 定义双链表的节点\r\n    def __init__(self, key, value):\r\n        self.key = key\r\n        self.value = value\r\n        self.left = None\r\n        self.right = None\r\n\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity): \r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.look_up = collections.defaultdict() # 哈希表\r\n        self.head = ListNode(-1,-1) # 双链表，需要头和尾\r\n        self.tail = ListNode(-1,-1)\r\n        self.head.right = self.tail # 刚开始初始化的时候，只有两个结点\r\n        self.tail.left = self.head\r\n        self.capacity = capacity\r\n\r\n    def remove(self, node):\r\n        node.left.right = node.right\r\n        node.right.left = node.left # 我右侧节点的左侧等于我的左侧\r\n\r\n    def insert(self, node):\r\n        node.right = self.head.right\r\n        node.left = self.head\r\n\r\n        self.head.right.left = node\r\n        self.head.right = node\r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        if key not in self.look_up: # 先判断是否存在\r\n            return -1\r\n        else:\r\n            node = self.look_up[key]\r\n            #先把这个节点从链表里remove\r\n            self.remove(node)\r\n            #再把这个节点放到链表头部\r\n            self.insert(node)\r\n            return node.value\r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if key in self.look_up: # 第一种情况：如果哈希表里有key\r\n            node = self.look_up[key]\r\n            node.value = value\r\n            #将这个node从链表里remove，\r\n            self.remove(node)\r\n            #将这个node插入到头部\r\n            self.insert(node)\r\n        else:                  # 第二种情况：如果哈希表里没有key，则插入\r\n            #如果链表已经满了\r\n            if len(self.look_up) == self.capacity:\r\n                node = self.tail.left\r\n                self.remove(node) # 从链表里把最后一个节点删除\r\n                # self.tail.left = node.left\r\n                # node.left.right = self.tail\r\n                del self.look_up[node.key] # 从哈希表里把最后一个节点删除\r\n                \r\n\r\n            #创建节点\r\n            node = ListNode(key, value)\r\n            #将节点放入look_up里\r\n            self.look_up[key] = node\r\n            #将节点放入链表里\r\n            self.insert(node)\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607696264","body":"### 思路\n\nDFS\n\n### 代码\n\n\n```python\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        path = []\n        def dfs(root):\n            if not root:\n                path.append(\"null\") # 如果 path 为空，加上 null\n                return \n            path.append(str(root.val)) # 遍历顺序 根，左，右\n            dfs(root.left)\n            dfs(root.right)\n        dfs(root)\n        return ','.join(path)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def dfs(dataList):\n            val = dataList.pop(0)\n            if val == 'null': # 当前是空\n                return None\n            \n            root = TreeNode(int(val)) # 当前非空，为根节点\n            root.left = dfs(dataList)\n            root.right = dfs(dataList)\n            return root\n        \n        dataList = data.split(',')\n        return dfs(dataList)\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616388242","body":"### 思路\n\n        # 把 s 按 k 分成窗口，每 m 个窗口形成一组\n        # 统计该组里的有效单词个数，与给定的单词组匹配个数\n\n### 代码\n\n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:return []\n        one_word = len(words[0])\n        word_num = len(words)\n        n = len(s)\n        if n < one_word:return []\n        words = Counter(words)\n        res = []\n        for i in range(0, one_word):\n            cur_cnt = 0\n            left = i\n            right = i\n            cur_Counter = Counter()\n            while right + one_word <= n:\n                w = s[right:right + one_word]\n                right += one_word\n\n                if w not in words:# 如果新的word不是给定的 word，则删除窗口，重新统计\n                    left = right\n                    cur_Counter.clear()\n                    cur_cnt = 0\n                else:             # 如果新的word是给定的 word，则更新窗口hashmap\n                    cur_Counter[w] += 1\n                    cur_cnt += 1\n                    while cur_Counter[w] > words[w]:\n                        left_w = s[left:left+one_word]\n                        left += one_word\n                        cur_Counter[left_w] -= 1\n                        cur_cnt -= 1\n                if cur_cnt == word_num :\n                        res.append(left)\n        return res\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1627357341","body":"### 代码\n\n\n```java\n\n\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] in = new int[n + 1], out = new int[n + 1];\n        for (int[] t : trust) {\n            int a = t[0], b = t[1];\n            in[b]++; out[a]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (in[i] == n - 1 && out[i] == 0) return i;\n        }\n        return -1;\n    }\n}\n\n\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1636364457","body":"### 代码\n\n\n```java\n\npublic class Solution {\n    public int[] sortArray(int[] nums) {\n        int len = nums.length;\n\n        for (int i = 1; i < len; i++) {\n            // 先暂存这个元素，然后之前元素逐个后移，留出空位\n            int temp = nums[i];\n            int j = i;\n            while (j > 0 && nums[j - 1] > temp) {\n                nums[j] = nums[j - 1];\n                j--;\n            }\n            nums[j] = temp;\n        }\n        return nums;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N2)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/44#issuecomment-1644866268","body":"### 代码\n\n\n```python\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]):\n        neighbors = {0:(0,0)}\n        seen = set()\n        time = 0\n        directions = [(1,0),(0,1),(-1,0),(0,-1)]\n        while True:\n            if time not in neighbors.keys():\n                time += 1\n                continue\n            (row,col) = neighbors[time]\n            if self.flood(grid,time,row,col,directions,seen,neighbors):\n                return time\n            time += 1\n        return 1\n    \n    def flood(self,grid,time,row,col,directions,seen,neighbors):\n        if (row,col) in seen:\n            return False\n        if grid[row][col] > time:\n            neighbors[grid[row][col]] = (row,col)\n            return False\n        if (row,col) == (len(grid)-1,len(grid)-1):\n            return True\n        seen.add((row,col))\n        for (r,c) in directions:\n            if row+r < 0 or row+r == len(grid) or col+c < 0 or col+c == len(grid):\n                continue\n            if self.flood(grid,time,row+r,col+c,directions,seen,neighbors):\n                return True\n        return False\n\n\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/50#issuecomment-1652859236","body":"### 代码\n\n\n```python\nclass Solution:\n    def readBinaryWatch(self, sum: int) -> List[str]:\n        res = []\n        for i in range(1<<10):\n            # 看我们穷举到i变成二进制有多少个1，2^10 次方种情况\n            cur_one = 0\n\n            # j用来数当前i有多少个1\n            for j in range(10):\n                if (i >> j) & 1 == 1: # i 的第 j 位是1\n                    cur_one += 1\n\n            # 假如说当前i 的二进制位上的1，和num亮了多少盏灯一样的话\n            # 我们就要判断这个当前i能不能构成合法时间了\n            if cur_one == sum:\n                # 只有上面四盏灯才是小时，i 右移 6 位，比较高的 4 位\n                hour = i >> 6\n                # 下面六盏灯是分钟\n                # 63 = 111111\n                minute = i & 63\n\n                # 看时间合不合法\n                if hour < 12 and minute < 60:\n                    res.append(\"%d:%02d\"%(hour,minute))\n\n        return res\n\n\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/56#issuecomment-1661455943","body":"\n```python\n\n\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        minimum_cost = [0] * (len(cost) + 1)\n        for i in range(2, len(cost) + 1):\n            take_one_step = minimum_cost[i - 1] + cost[i - 1]\n            take_two_steps = minimum_cost[i - 2] + cost[i - 2]\n            minimum_cost[i] = min(take_one_step, take_two_steps)\n        return minimum_cost[-1]\n\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bi9potato":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585312097","body":"### 思路\r\n\r\n从后遍历num和k每一位并相加，进位存在carry变量内\r\n\r\n### 代码\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n        List<Integer> res = new LinkedList<>();\r\n        int carry = 0;\r\n\r\n        for( int i = num.length-1; i > -1 ; i-- ) {\r\n\r\n            int new_digit = num[i] + k%10 + carry;\r\n\r\n            if(new_digit > 9) carry = 1; // update carry\r\n            else carry = 0;\r\n\r\n            res.add(0, new_digit % 10); // eliminate carry\r\n\r\n            k /= 10;\r\n\r\n        }\r\n\r\n        while( k != 0) {\r\n\r\n            int new_digit = k%10 + carry;\r\n\r\n            if(new_digit > 9) carry = 1; // update carry\r\n            else carry = 0;\r\n\r\n            res.add(0, new_digit % 10); // eliminate carry\r\n\r\n            k /= 10;\r\n\r\n        }\r\n\r\n        if (carry == 1) res.add(0, 1);\r\n\r\n        return res;\r\n        \r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1585759880","body":"### Aproach\r\n\r\nForward and backward traversal\r\n\r\n### Code\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n\r\n\r\n        int len = s.length();\r\n        int c_idx = -len;\r\n\r\n        int[] res = new int[len];\r\n        \r\n        // Traverse from left\r\n        // Calculate distance from each char to the nearest c on its left\r\n        for (int i = 0; i <len; i++) {\r\n            if (s.charAt(i) == c) c_idx = i;\r\n            res[i] = i-c_idx;\r\n        }\r\n\r\n        // Traverse from right\r\n        // Calculate distance from each char to the nearest c on its right\r\n        // compare two distances to keep the shortest one\r\n        for (int i = c_idx; i > -1; i-- ) {\r\n            if (s.charAt(i) == c) c_idx = i;\r\n            res[i] = Math.min(res[i], c_idx-i);\r\n        }\r\n\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n**Complexity Analysis**\r\n- time $\\mathcal{O}(N)$\r\n- space $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586253181","body":"### Approch\n\nTrade space for time by using an additional stack.  \nAdd `val` during the `pop` operation.\n\n### code\n\n```java\n\nclass CustomStack {\n\n    private int[] s;\n    private int top_pointer;\n    private int bottom_pointer;\n\n    private int[] inc_s;\n\n    public CustomStack(int maxSize) {\n\n        s = new int[maxSize];\n        top_pointer = -1;\n        bottom_pointer = 0;\n\n        inc_s = new int[maxSize];\n        \n    }\n    \n    public void push(int x) {\n\n        if ( top_pointer < s.length-1 ) {\n            s[++top_pointer] = x;\n        } \n        \n    }\n    \n    public int pop() {\n\n        if (top_pointer == -1) {\n            return -1;\n        } else {\n            if (inc_s[top_pointer] != 0) {\n                int val = inc_s[top_pointer];\n                if (top_pointer != 0) inc_s[top_pointer-1] += val;\n                inc_s[top_pointer] = 0;\n                return s[top_pointer--] + val;\n            } else {\n                return s[top_pointer--];\n            }\n        }\n\n    }\n    \n    public void increment(int k, int val) {\n\n        if (k-1 > top_pointer) {\n            k = top_pointer+1;\n        }\n\n        if (k > 0) inc_s[k-1] += val;\n        \n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n\n**Complexity Analysis**\n- time: All $\\mathcal{O}(1)$ \n- space: All $\\mathcal{O}(1)$ but `CostomStack` $\\mathcal{O}(N)$ ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1588442534","body":"# Approch\n\nNested brackets require concatenating strings **from inside out**, which corresponds to **LIFO** property of stack.\n\nTraverse each char in string s:\n\n- If `c == '['`, push multiplier and string into the stack.\n\n- If `c == ']'`,\n    1. Pop the multiplier and string from stack.\n    2. Multiply the current string by the popped multiplier and concatenate it with the popped string.\n\n- If `c == digit`, concatenate and record it.\n\n- If `c == char`, append it to the current string.\n\n## Note:\n\n- Implement the stack using `LinkedList`/ `ArrayDeque` (not thread-safe) cuz they're faster than `Stack` (thread-safe).\n- `StringBuilder` (not thread-safe) is  faster than `StringBuffer`(thread-safe).\n\n# Code\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n\n        Deque<Integer> n_stack = new LinkedList<>();\n        Deque<StringBuilder> s_stack = new LinkedList<>();\n\n        StringBuilder sb = new StringBuilder();\n        int n = 0;\n\n        for( int i = 0; i < s.length(); i++) {\n\n            char c = s.charAt(i);\n\n            if (c >= '0' && c <= '9') {\n                n = n*10 + c-'0';\n            } else if (c == '[') {\n                n_stack.push(n);\n                n = 0;\n                s_stack.push(sb);\n                sb = new StringBuilder();\n            } else if (c == ']') {\n\n                int temp_n = n_stack.pop(); \n                StringBuilder temp_sb = new StringBuilder();\n                for(int j = 0; j < temp_n; j++) {\n                    temp_sb.append(sb);\n                }\n\n                sb = s_stack.pop().append(temp_sb);\n            } else { // c == char\n                sb.append(c);\n            }\n\n        }\n\n        return sb.toString();\n        \n    }\n}\n\n```\n\n\n# Complexity Analysis\n- Time: $\\mathcal{O}(N)$ \n- Space: $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1589804536","body":"# Approach\n\n\n# Code\n\n```java\n\nclass MyQueue {\n\n    Deque<Integer> s1;\n    Deque<Integer> s2;\n\n    public MyQueue() {\n\n        s1 = new LinkedList<>();\n        s2 = new LinkedList<>();\n        \n    }\n    \n    public void push(int x) {\n\n        s1.push(x);\n        \n    }\n    \n    public int pop() {\n\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty()) {\n                s2.push(s1.pop());\n            }\n        }\n\n        return s2.pop();\n        \n    }\n    \n    public int peek() {\n\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty()) {\n                s2.push(s1.pop());\n            }\n        }\n\n        return s2.peek();\n        \n    }\n    \n    public boolean empty() {\n\n        return s1.isEmpty() && s2.isEmpty();\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n\n# Complexity Analysis\n\n- Time: \n    $\\mathcal{O}(1)$ for `push`, \n    $\\mathcal{O}(N)$ for `pop`, \n    $\\mathcal{O}(N)$ for `peek`, \n    $\\mathcal{O}(1)$ for `empty`\n- Space: $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592405765","body":"# Approach\n\n# Code\n\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n\n        Deque<Integer> deq = new LinkedList<>();\n\n        for (int num : arr) {\n\n            if (deq.isEmpty()) {\n                deq.push(num);\n            } else { // deq is not empty\n                int max = deq.peek();\n                if (num >= max) {\n                    deq.push(num);\n                } else { // num < max\n                    while (!deq.isEmpty() && deq.peek() > num) {\n                        deq.pop();\n                    }\n                    deq.push(max);\n                }\n            }\n\n\n        }\n\n        return deq.size();\n\n    }\n}\n\n\n```\n\n# Complexity Analysis\n\n- Time $\\mathcal{O}(N)$\n- Space $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1593502241","body":"# Approach\n\nRotate the last k nodes (len of linked list is k) to the front.\n\n# Code\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n\n        if (head == null) return head;\n\n        ListNode old_tail = head;\n        int len = 1;\n        while (old_tail.next != null) {\n            len++;\n            old_tail = old_tail.next;\n        }\n        // System.out.println(len);\n\n\n        ListNode new_tail = head;\n        int idx = len - k % len;\n        // System.out.println(idx);\n        for (int i = 1; i < idx; i++) {\n            new_tail = new_tail.next;\n        }\n        // System.out.println(new_tail.val);\n\n        old_tail.next = head;\n        head = new_tail.next;\n        new_tail.next = null;\n\n        return head;\n\n        \n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Spce $\\mathcal{O}(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595033288","body":"# Approach\n\ndummy node\n\n# Code\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n\n        ListNode node = dummy;\n        while (node != null && node.next != null && node.next.next != null) {\n\n            ListNode tmp = node.next;\n\n            node.next = tmp.next;\n            tmp.next = node.next.next;\n            node.next.next = tmp;\n\n            node = node.next.next;\n\n        }\n\n        return dummy.next;\n        \n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Spce $\\mathcal{O}(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1595886043","body":"# Approach\r\n\r\nFast n slow pointers to get the middle node, then use **BFS recursively**.\r\n\r\n# Code\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n\r\n        return dfs(head, null);\r\n        \r\n    }\r\n\r\n    private TreeNode dfs(ListNode head, ListNode tail) {\r\n\r\n        if (head == tail) {\r\n            return null;\r\n        }\r\n\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while (fast != tail && fast.next != tail) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = dfs(head, slow);\r\n        root.right = dfs(slow.next, tail);\r\n\r\n        return root;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n# Complexity Analysis\r\n- Time $\\mathcal{O}(N\\log{N})$\r\n- Spce $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596225269","body":"# Approach\n\nDouble pointer\n\nTraverse original linkedlist first, then traverse the other linkedlist.\n\n# Code\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n\n        ListNode pA = headA;\n        ListNode pB = headB;\n\n        while (pA != pB) {\n\n            if (pA == null) {\n                pA = headB;\n            } else {\n                pA = pA.next;\n            }\n\n            \n\n            if (pB == null) {\n                pB = headA;\n            } else {\n                pB = pB.next;\n            }\n\n            \n\n        }\n\n        return pA;\n        \n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Spce $\\mathcal{O}(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1597517080","body":"# Approach\n\nFast and Slow Pointers\n\n# Code\n\n```java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n\n        ListNode pSlow = head;\n        ListNode pFast = head;\n\n        while (pFast != null && pFast.next != null ) {\n            pSlow = pSlow.next;\n            pFast = pFast.next.next;\n\n            if (pFast == pSlow) break;\n        }\n\n        if (pFast == null || pFast.next == null) {\n            return null;\n        }\n\n        pSlow = head;\n        while (pSlow != pFast) {\n            pSlow = pSlow.next;\n            pFast = pFast.next;\n        }\n\n        return pSlow;\n        \n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Spce $\\mathcal{O}(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1599302475","body":"# Approach\n\nLinkedList + HashMap  \nUse LinkedList to store order of keys, and HashMap to store key-value pairs.  \n\n# Code\n\n```java\n\nclass LRUCache {\n\n    private HashMap<Integer, Node> map;\n    private int maxLen;\n    private DoubleLinkedList dll;\n\n\n    public LRUCache(int capacity) {\n        \n        map = new HashMap<>();\n        dll = new DoubleLinkedList();\n        maxLen = capacity;\n\n    }\n    \n    public int get(int key) {\n\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            int val = node.val;\n\n            dll.rm(node);\n            dll.addLast(node);\n\n            return val;\n            \n        } else {\n            return -1;\n        }\n        \n    }\n    \n    public void put(int key, int value) {\n\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            node.val = value;\n            dll.rm(node);\n            dll.addLast(node);\n        } else {\n\n            if (dll.getLen() >= maxLen ) {\n                int tmp_key = dll.rmFirst();\n                map.remove(tmp_key);\n            }\n            Node node = new Node(key, value);\n            map.put(key, node);\n            dll.addLast(node);\n        }\n\n        \n    }\n}\n\nclass Node {\n\n    public int key, val;\n\n    public Node next, prev;\n\n    public Node (int key, int val) {\n        this.key = key;\n        this.val = val;\n    }\n\n}\n\nclass DoubleLinkedList {\n\n    private Node head;\n    private Node tail;\n    private int len;\n\n    public DoubleLinkedList () {\n        head = new Node(-1, -1);\n        tail = new Node(-1, -1);\n\n        head.next = tail;\n        tail.prev = head;\n\n        len = 0;\n    }\n\n    public void rm (Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n\n        len--;\n    }\n\n    public int rmFirst () {\n\n        if (head.next != tail) {\n\n            int key = head.next.key;\n\n            head.next = head.next.next;\n            head.next.prev = head;\n            len--;\n\n            return key;\n        }\n\n        return -1;\n\n        \n    }\n\n    public void rmLast () {\n        if (head.next != tail) {\n            tail.prev = tail.prev.prev;\n            tail.prev.next = tail;\n            len--;\n        }\n\n        \n    }\n\n    public void addLast (Node node) {\n        tail.prev.next = node;\n        node.prev = tail.prev;\n\n        node.next = tail;\n        tail.prev = node;\n\n        len++;\n\n    }\n\n    public int getLen () {\n        return len;\n    }\n\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(1)$ for `get` and `put`\n- Space $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1601162354","body":"# Approach\n\nrecursion, depth = max(left_depth, right_depth) + 1\n\n# Code\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n\n        if (root == null) {\n            return 0;\n        }\n\n        int left_depth = maxDepth(root.left);\n        int right_depth = maxDepth(root.right);\n\n        return Math.max(left_depth, right_depth ) + 1;\n        \n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Space $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1603113889","body":"# Approach\n\nDFS. Note the base case, only q == p == null means the traverse is completed and return true then.\n\n# Code\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n\n        if (p == null) {\n            if (q == null) return true; // traverse completed\n            else return false;\n        } else { // p != null\n            if (q == null || p.val != q.val) return false;\n        }\n\n        boolean isLeftSame = isSameTree(p.left, q.left);\n        boolean isRightSame = isSameTree(p.right, q.right);\n\n        return isLeftSame &&  isRightSame;\n        \n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Space $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1604613017","body":"# Approach\n\nDFS\n\n# Code\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    int res = 0;\n    StringBuilder num = new StringBuilder();\n\n    public int sumNumbers(TreeNode root) {\n\n        dfs(root);\n\n        return res;\n        \n    }\n\n    private void dfs(TreeNode root) {\n\n        if (root == null) return;\n        num.append(root.val);\n        if (root.left == null && root.right == null) res += Integer.parseInt(num.toString());\n\n        dfs(root.left);\n        dfs(root.right);\n\n        num.deleteCharAt(num.length() - 1);\n\n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Space $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605664768","body":"# Approach\n\nDFS, inorder traversal.\n\n# Code\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    int maxDepth = 0;\n    int currDepth = 0;\n\n    int res;\n\n    public int findBottomLeftValue(TreeNode root) {\n\n        dfs(root);\n\n        return res;\n        \n    }\n\n    private void dfs(TreeNode root) {\n\n        if (root== null) return;\n\n        currDepth++;\n\n    \n        dfs(root.left);\n        if (root.left == null && root.right == null) {\n            if (currDepth > maxDepth) {\n                maxDepth = currDepth;\n                res = root.val;\n            }\n            \n        }\n        \n        \n        \n\n        dfs(root.right);\n\n        currDepth--;\n\n        \n\n    }\n\n\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Space $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1606233246","body":"# Approach\n\nPreorder traverse\n\n# Code\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    StringBuilder sb;\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        sb = new StringBuilder();\n\n        serializeTraverse(root);\n\n        sb.insert(0, '[');\n        sb.setCharAt(sb.length()-1, ']');\n\n        return sb.toString();\n    }\n\n    private void serializeTraverse(TreeNode root) {\n\n        if (root == null) {\n            sb.append('*').append(',');\n            return;\n        }\n\n        sb.append(root.val).append(',');\n\n        serializeTraverse(root.left);\n        serializeTraverse(root.right);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n\n        String[] vals = data.substring(1, data.length()-1).split(\",\");\n\n        Queue<String> q = new LinkedList<>();\n        for (String val : vals) {\n            q.offer(val);\n        }\n\n        return deserializeTraverse(q);\n    }\n\n    private TreeNode deserializeTraverse(Queue<String> q) {\n\n        if (q.isEmpty() ) return null;\n        if (q.peek().equals(\"*\")) {\n            q.poll();\n            return null;\n        }\n\n        int num = Integer.parseInt(q.poll());\n\n        TreeNode node = new TreeNode(num);\n\n        node.left = deserializeTraverse(q);\n        node.right = deserializeTraverse(q);\n\n        return node;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Space $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1608618569","body":"# Approach\n\nPre-order traversal to get coordinates of each node, then sort the nodes by their column and row.\n\n# Code\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n\n\nclass Solution {\n\n    class CoordinateMappedNode {\n        public int row, col;\n        public TreeNode node;\n\n        public CoordinateMappedNode(TreeNode node, int row, int col) {\n            this.row = row;\n            this.col = col;\n            this.node = node;\n        }\n    }\n\n    List<CoordinateMappedNode> list = new LinkedList<>();\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n\n        traverse(root, 0, 0);\n        \n        Collections.sort(list, \n            (CoordinateMappedNode node1, CoordinateMappedNode node2) -> {\n                if (node1.row == node2.row && node1.col == node2.col) {\n                    return node1.node.val - node2.node.val;\n                } else if (node1.col == node2.col) {\n                    return node1.row - node2.row;\n                } else {\n                    return node1.col - node2.col;\n                }\n            }\n        );\n        \n        int currCol = Integer.MIN_VALUE;\n        List<List<Integer>> res = new LinkedList<>();\n        for (int i = 0; i < list.size(); i++) {\n            CoordinateMappedNode node = list.get(i);\n            if (node.col > currCol) {\n                res.add(new LinkedList<>());\n                currCol = node.col;\n            }\n            res.get(res.size()-1).add(node.node.val);\n\n        }\n\n        return res;\n\n\n    }\n\n    private void traverse(TreeNode root, int row, int col) {\n\n        if (root == null) return;\n\n        list.add(new CoordinateMappedNode(root, row, col));\n\n        traverse(root.left, row+1, col-1);\n        traverse(root.right, row+1, col+1);\n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N\\log{N})$ as time complexity of `Collections.sort` is $\\mathcal{O}(N\\log{N})$.\n- Space $\\mathcal{O}(N)$ ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1609930059","body":"# Approach\n\nHashMap\n\n# Code\n\n```java\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        \n        HashMap<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(nums[i])) {\n                return new int[] {i, map.get(nums[i])};\n            }\n\n            map.put(target - nums[i], i);\n        }\n\n        return null;\n\n    }\n}\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Space $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1612371766","body":"# Approach\n\nHashMap + Min Heap\n\n# Code\n\n```java\n\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n\n        HashMap<Integer, Integer> map = new HashMap<>();\n\n        for (int num : nums) {\n            if (map.containsKey(num)) {\n                map.put(num, map.get(num)+1);\n            } else {\n                map.put(num, 0);\n            }\n        }\n\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(\n            (a, b) -> {\n                return a.getValue().compareTo(b.getValue());\n            }\n        );\n\n        for( Map.Entry<Integer, Integer> ele : map.entrySet()) {\n            pq.offer(ele);\n            if (pq.size() > k) {\n                pq.poll();\n            }\n        }\n\n        int[] res = new int[k];\n        for(int i = 0; i < k; i++) {\n            res[i] = pq.poll().getKey();\n        }\n\n        return res;\n\n\n\n\n\n\n        \n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N\\log{N})$\n- Space $\\mathcal{O}(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1613786132","body":"``` Java\n\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n\n        if (points.length < 3) return 0;\n\n        int res = 0;\n\n        for (int i = 0; i < points.length; i++) {\n            // System.out.println(points[i]);\n            \n            HashMap<Integer, Integer> map = new HashMap<>();\n\n            for (int j = 0; j < points.length; j++) {\n\n                if (i == j) continue;\n\n                int dis = distance(points[i], points[j]);\n                if (map.containsKey(dis)) {\n                    map.put(dis, map.get(dis)+1);\n                } else {\n                    map.put(dis, 1);\n                }\n                \n\n            }\n\n            for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n                if (entry.getValue() >= 2) {\n                    res += entry.getValue() * (entry.getValue()-1);\n                }\n            }\n\n\n\n        }\n\n        return res;\n\n    }\n\n    private int distance(int[] a, int[] b) {\n        return (a[0] - b[0])*(a[0] - b[0]) + (a[1] - b[1])*(a[1] - b[1]);\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615962114","body":"# Approach\n\nHashMap\n\n# Code\n\n```java\n\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n\n        int left = 0, right = 0;\n        int res = 0;\n\n        HashMap<Character, Integer> map = new HashMap<>();\n\n        while (right < s.length()) {\n\n            char c = s.charAt(right);\n            right++;\n\n            if (map.containsKey(c)) {\n                map.put(c, map.get(c)+1);\n            } else {\n                map.put(c, 1);\n            }\n\n            while (map.get(c) > 1) {\n                map.put(s.charAt(left), map.get(s.charAt(left))-1);\n                left++;\n            }\n\n            res = res > right-left ? res : right-left;\n\n        }\n\n        return res;\n        \n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Space $\\mathcal{O}(N)$","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1621063259","body":"# Approach\n\nDouble pointers\n\n# Code\n\n```java\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n\n        int slow = 0, fast = slow+1;\n\n        while (fast < nums.length) {\n            while (fast < nums.length && nums[fast] == nums[slow]) {\n                fast++;\n            }\n            if (fast < nums.length) {\n                nums[++slow] = nums[fast];\n            }\n        }\n\n        return slow+1;\n        \n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Space $\\mathcal{O}(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1622269464","body":"# Approach\n\nBinary search, cuz the **array is sorted** and the limitation of **time complexity is $\\mathcal{O}(\\log{N})$**.\n\n# Code\n\n```java\n\nclass Solution {\n\n    private int target;\n\n    public int searchInsert(int[] nums, int target) {\n\n        this.target = target;\n\n        return bs(nums, 0, nums.length-1);\n        \n    }\n\n    private int bs(int[] nums, int l, int r) {\n\n        if ( l >= r) {\n            if (nums[l] < target) {\n                return l+1;\n            } else {\n                return l;\n            }\n        }\n\n        int mid = l + ((r-l) >> 1);\n        // System.out.println(mid);\n\n        if (nums[mid] > target) {\n            return bs(nums, l, mid-1);\n        } else if (nums[mid] < target) {\n            return bs(nums, mid+1, r);\n        } else {\n            return mid;\n        }\n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(\\log{N})$\n- Space $\\mathcal{O}(\\log{N})$, cuz the height of the recursion stack is $\\mathcal{O}(\\log{N})$.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1624084116","body":"# Approach\n\nMonotonic queue.\n\n# Code\n\n```java\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n\n        int[] res = new int[nums.length-k+1];\n\n        Deque<Integer> dq = new LinkedList<>();\n\n        for (int j = 0, i = 1-k; j < nums.length; i++, j++) {\n\n            if (i > 0 && dq.peekFirst() == nums[i-1]) {\n                dq.removeFirst();\n            }\n\n            while (!dq.isEmpty() && dq.peekLast() < nums[j] ) {\n                dq.removeLast();\n            }\n\n            dq.addLast(nums[j]);\n\n            if (i >= 0) {\n                res[i] = dq.peekFirst();\n            }\n\n        }\n\n        return res;\n        \n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Space $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1625893100","body":"# Approach\n\nAbsracting it as graph. The judge has in-degree of $N-1$ and out-degree of $0$.\n\n# Code\n\n```java\n\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n\n        int[] in_degree = new int[n+1];\n        int[] out_degree = new int[n+1];\n\n        for (int i = 0; i < trust.length; i++) {\n            out_degree[trust[i][0]] += 1;\n            in_degree[trust[i][1]] += 1;\n        }\n\n        for (int i = 1; i < n+1; i++) {\n            if (in_degree[i] == n-1 && out_degree[i] == 0) {\n                return i;\n            }\n        }\n\n        return -1;\n        \n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N)$\n- Space $\\mathcal{O}(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627547049","body":"# Approach\n\nUse DFS to traverse the graph.\n\n# Code\n\n```java\n\nclass Solution {\n\n\n    private boolean[] group;\n    private boolean[] visited;\n    private boolean res;\n\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n\n        List<Integer>[] graph = new LinkedList[n+1];\n\n        for (int i = 1; i < n+1; i++) {\n            graph[i] = new LinkedList<>();\n        }\n\n        for (int[] edge : dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n\n        group = new boolean[n+1];\n        visited = new boolean[n+1];\n        res = true;\n\n        for (int node = 1; node < n+1; node++) {\n            dfs(graph, node);\n        }\n\n        return res;\n        \n    }\n\n    private void dfs(List<Integer>[] graph, int node) {\n\n        if (!res) {\n            return;\n        }\n\n        visited[node] = true;\n\n        for (int nbr : graph[node]) {\n            if (visited[nbr]) {\n                if (group[nbr] == group[node]) {\n                    res = false;\n                    return;\n                }\n            } else {\n                group[nbr] = !group[node];\n                dfs(graph, nbr);\n            }\n        }\n\n        return;\n\n    }\n}\n\n```\n\n# Complexity Analysis\n- Time $\\mathcal{O}(N+E)$, where $N$ is # of nodes and $E$ is # of edge (dislikes).\n- Space $\\mathcal{O}(N+E)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1628056670","body":"``` java\r\nclass Solution {\r\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        int totalGroups = m;\r\n        Map<Integer, List<Integer>> indexGroupMap = new HashMap<>();\r\n        for (int i = 0; i < n; i++) {\r\n            if (group[i] == -1) {\r\n                group[i] = totalGroups;\r\n                indexGroupMap.put(totalGroups, new ArrayList<>());\r\n                indexGroupMap.get(totalGroups).add(i);\r\n                totalGroups++;\r\n            } else {\r\n                indexGroupMap.putIfAbsent(group[i], new ArrayList<>());\r\n                indexGroupMap.get(group[i]).add(i);\r\n            }\r\n        }\r\n\r\n        int[] externalInMap = new int[totalGroups];\r\n        int[] internalInMap = new int[n];\r\n        Map<Integer, List<Integer>> externalGraph = new HashMap<>();\r\n        Map<Integer, List<Integer>> internalGraph = new HashMap<>();\r\n        for (int i = 0; i < beforeItems.size(); i++) {\r\n            if (beforeItems.get(i).size() > 0) {\r\n                int groupNumber = group[i];\r\n                for (int j = 0; j < beforeItems.get(i).size(); j++) {\r\n                    int prevItem = beforeItems.get(i).get(j);\r\n                    int prevGroupNumber = group[prevItem];\r\n                    if (groupNumber == prevGroupNumber) {\r\n                        internalGraph.putIfAbsent(prevItem, new ArrayList<>());\r\n                        internalGraph.get(prevItem).add(i);\r\n                        internalInMap[i]++;\r\n                    } else {\r\n                        externalGraph.putIfAbsent(prevGroupNumber, new ArrayList<>());\r\n                        externalGraph.get(prevGroupNumber).add(groupNumber);\r\n                        externalInMap[groupNumber]++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Queue<Integer> externalQueue = new LinkedList<>();\r\n        for (int i = 0; i < totalGroups; i++) {\r\n            if (externalInMap[i] == 0) {\r\n                externalQueue.offer(i);\r\n            }\r\n        }\r\n\r\n        int[] res = new int[n];\r\n        int resIndex = 0;\r\n\r\n        while (!externalQueue.isEmpty()) {\r\n            int curGroup = externalQueue.poll();\r\n            Queue<Integer> internalQueue = new LinkedList<>();\r\n            if (indexGroupMap.containsKey(curGroup)) {\r\n                for (int item : indexGroupMap.get(curGroup)) {\r\n                    if (internalInMap[item] == 0) {\r\n                        internalQueue.offer(item);\r\n                    }\r\n                }\r\n            }\r\n            while (!internalQueue.isEmpty()) {\r\n                int curItem = internalQueue.poll();\r\n                res[resIndex] = curItem;\r\n                resIndex++;\r\n                if (internalGraph.containsKey(curItem)) {\r\n                    for (int nextItemInGroup : internalGraph.get(curItem)) {\r\n                        internalInMap[nextItemInGroup]--;\r\n                        if (internalInMap[nextItemInGroup] == 0) {\r\n                            internalQueue.offer(nextItemInGroup);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (externalGraph.containsKey(curGroup)) {\r\n                for (int nextGroup : externalGraph.get(curGroup)) {\r\n                    externalInMap[nextGroup]--;\r\n                    if (externalInMap[nextGroup] == 0) {\r\n                        externalQueue.offer(nextGroup);\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        return resIndex == n ? res : new int[]{};\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1629327740","body":"```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n\n        int x = 0, y = 0;\n\n        for (int i = 0; i < moves.length(); i++) {\n            char c = moves.charAt(i);\n\n            if (c == 'U') {\n                y -=1;\n            } else if (c == 'D') {\n                y +=1;\n            } else if (c == 'L') {\n                x -=1;\n            } else {\n                x +=1;\n            }\n        }\n\n        if (x == 0 && y == 0) {\n            return true;\n        }\n\n        return false;\n        \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1631150252","body":"```java\r\n\r\nclass Solution {\r\n    public int[] getOrder(int[][] tasks) {\r\n        int n = tasks.length;\r\n        int[] ans = new int[n];\r\n        int[][] extTasks = new int[n][3];\r\n        for(int i = 0; i < n; i++) {\r\n            extTasks[i][0] = i;\r\n            extTasks[i][1] = tasks[i][0];\r\n            extTasks[i][2] = tasks[i][1];\r\n        }\r\n        Arrays.sort(extTasks, (a,b)->a[1] - b[1]);\r\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[2] == b[2] ? a[0] - b[0] : a[2] - b[2]);\r\n        int time = 0;\r\n        int ai = 0;\r\n        int ti = 0;\r\n        while(ai < n) {\r\n            while(ti < n && extTasks[ti][1] <= time) {\r\n                pq.offer(extTasks[ti++]);\r\n                \r\n            }\r\n            if(pq.isEmpty()) {\r\n                time = extTasks[ti][1];\r\n                continue;\r\n            }\r\n            int[] bestFit = pq.poll();\r\n            ans[ai++] = bestFit[0];\r\n            time += bestFit[2];\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585429513","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n \n\n示例 1：\n\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n \n\n提示：\n\n1 <= num.length <= 104\n0 <= num[i] <= 9\nnum 不包含任何前导零，除了零本身\n1 <= k <= 104\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc addToArrayForm(array []int, num int) []int {\n    // 1. plus two array \n    anotherArray :=  plusTwoArray(array, num)\n\n    // 2. reverseArray\n    return reverseArray(anotherArray)\n}\n\n\nfunc plusTwoArray(arr1 []int, num int)(res []int){\n\n    i := len(arr1) - 1\n    carry := 0\n    for i >= 0 || num > 0 {   // \n        a, b := 0, 0\n        if i >= 0 {\n            a = arr1[i]\n            i--\n        }\n\n        if num >= 0 {\n            b = num % 10\n            num /= 10\n        }\n\n\n        sum := a + b + carry\n\n        res = append(res, sum % 10)\n        carry = sum / 10\n    }\n\n\n    if carry > 0 {\n        res = append(res, carry)\n    }\n\n    return res\n}\n\nfunc reverseArray(array []int) []int {\n\n    i, j := 0, len(array) - 1\n\n    for i < j {\n        array[i], array[j] = array[j], array[i]\n        i++\n        j--\n    }\n\n    return array\n}\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1585883406","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc shortestToChar(s string, c byte) []int {\n\n\tvar res []int = make([]int, len(s))\n\n    cur := math.MaxInt\n\n    // 1. 从前往后\n    for index, char := range s {\n        if char == int32(c) {\n            cur = index\n        }\n\n        if cur == math.MaxInt {\n            res[index]  = math.MaxInt\n        } else {\n            res[index] = index - cur\n        }\n    }\n\n    // 2. 从后往前\n    cur = math.MaxInt\n    for index := len(s) - 1; index >= 0 ; index-- {\n        char := s[index]\n\n        if char == c {\n            cur = index\n        }\n\n        abs := cur - index\n        if res[index] > abs {\n            res[index] = abs\n        }\n    }\n\n    return res\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586406051","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode.cn/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持对其元素进行增量操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack stk = new CustomStack(3); // 栈是空的 []\nstk.push(1);                          // 栈变为 [1]\nstk.push(2);                          // 栈变为 [1, 2]\nstk.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\nstk.push(2);                          // 栈变为 [1, 2]\nstk.push(3);                          // 栈变为 [1, 2, 3]\nstk.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\nstk.increment(5, 100);                // 栈变为 [101, 102, 103]\nstk.increment(2, 100);                // 栈变为 [201, 202, 103]\nstk.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\nstk.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\nstk.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\nstk.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize, x, k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\ntype CustomStack struct {\n    stack []int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    if maxSize < 0 {\n        return CustomStack{}\n    }\n\n    return CustomStack{\n        stack: make([]int, 0, maxSize),\n    }\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if len(this.stack) == cap(this.stack) {\n        return\n    } \n    this.stack = append(this.stack, x)\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if (len(this.stack) == 0 ){\n        return -1\n    }\n\n    pop := this.stack[len(this.stack)-1]\n    this.stack = this.stack[:len(this.stack)-1]\n    return pop\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n\n    n := min(k, len(this.stack))\n\n    for i := 0; i < n; i++ {\n        this.stack[i] = this.stack[i] + val\n    }\n\n    return\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589192540","body":"\n## 题目地址(394. 字符串解码)\n\nhttps://leetcode.cn/problems/decode-string/\n\n## 题目描述\n\n```\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n \n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n\n示例 3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n示例 4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n\n\n \n\n提示：\n\n1 <= s.length <= 30\ns 由小写英文字母、数字和方括号 '[]' 组成\ns 保证是一个 有效 的输入。\ns 中所有整数的取值范围为 [1, 300] \n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc decodeString(s string) string {\n    stk := []string{}\n    ptr := 0\n    for ptr < len(s) {\n        cur := s[ptr]\n        if cur >= '0' && cur <= '9' {\n            digits := getDigits(s, &ptr)\n            stk = append(stk, digits)\n        } else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\n            stk = append(stk, string(cur))\n            ptr++\n        } else {\n            ptr++\n            sub := []string{}\n            for stk[len(stk)-1] != \"[\" {\n                sub = append(sub, stk[len(stk)-1])\n                stk = stk[:len(stk)-1]\n            }\n            for i := 0; i < len(sub)/2; i++ {\n                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\n            }\n            stk = stk[:len(stk)-1]\n            repTime, _ := strconv.Atoi(stk[len(stk)-1])\n            stk = stk[:len(stk)-1]\n            t := strings.Repeat(getString(sub), repTime)\n            stk = append(stk, t)\n        }\n    }\n    return getString(stk)\n}\n\nfunc getDigits(s string, ptr *int) string {\n    ret := \"\"\n    for ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\n        ret += string(s[*ptr])\n    }\n    return ret\n}\n\nfunc getString(v []string) string {\n    ret := \"\"\n    for _, s := range v {\n        ret += s\n    }\n    return ret\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591229016","body":"\n## 题目地址(232. 用栈实现队列)\n\nhttps://leetcode.cn/problems/implement-queue-using-stacks/\n\n## 题目描述\n\n```\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\n实现 MyQueue 类：\n\nvoid push(int x) 将元素 x 推到队列的末尾\nint pop() 从队列的开头移除并返回元素\nint peek() 返回队列开头的元素\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n说明：\n\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n示例 1：\n\n输入：\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n\n\n \n\n提示：\n\n1 <= x <= 9\n最多调用 100 次 push、pop、peek 和 empty\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\n\n \n\n进阶：\n\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\ntype MyQueue struct {\n    inStack, outStack []int\n}\n\n\nfunc Constructor() MyQueue {\n    return MyQueue{}\n}\n\n\nfunc (q *MyQueue) Push(x int)  {\n    q.inStack = append(q.inStack, x)\n}\n\n\nfunc (q *MyQueue) Pop() int {\n    if len(q.outStack) == 0 {\n        q.in2out()\n    }\n    temp := q.outStack[len(q.outStack)-1]\n    q.outStack = q.outStack[:len(q.outStack)-1]\n    return temp\n}\n\nfunc (q *MyQueue) in2out() {\n    for len(q.inStack) > 0 {\n        q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])\n        q.inStack = q.inStack[:len(q.inStack)-1]\n    }\n}\n\nfunc (q *MyQueue) Peek() int {\n    if len(q.outStack) == 0 {\n        q.in2out()\n    }\n    return q.outStack[len(q.outStack)-1]\n}\n\n\nfunc (q *MyQueue) Empty() bool {\n    if len(q.inStack) == 0 && len(q.outStack) == 0 {\n        return true\n    }\n    return false\n}\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Peek();\n * param_4 := obj.Empty();\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594796056","body":"/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc rotateRight(head *ListNode, k int) *ListNode {\n    // 1. 减枝\n    if head == nil || k == 0 || head.Next == nil {\n        return head\n    }\n\n    // 2. 计算链表长度\n    n := 1\n    iter := head\n    for iter.Next != nil {\n        iter = iter.Next \n        n++\n    }\n\n\n    // 3. 取余右移\n    add := n - k % n\n    if add == n {\n        return head\n    }\n    \n    // 3. 链表成环\n    iter.Next = head\n    \n    for add > 0 {\n       iter = iter.Next \n       add--\n    }\n    ret := iter.Next \n    iter.Next = nil\n    return ret\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595771604","body":"\n## 题目地址(24. 两两交换链表中的节点)\n\nhttps://leetcode.cn/problems/swap-nodes-in-pairs/\n\n## 题目描述\n\n```\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\n \n\n示例 1：\n\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n\n示例 2：\n\n输入：head = []\n输出：[]\n\n\n示例 3：\n\n输入：head = [1]\n输出：[1]\n\n\n \n\n提示：\n\n链表中节点的数目在范围 [0, 100] 内\n0 <= Node.val <= 100\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n\n    dummyNode := &ListNode{\n        Next: head,\n    }\n\n    pre := dummyNode\n\n    for head != nil && head.Next != nil {\n        pre.Next = head.Next \n\n        temp := head.Next.Next\n\n        head.Next.Next = head\n        head.Next = temp\n\n        pre = head\n        head = temp\n    }\n\n    return dummyNode.Next\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596133673","body":"\n## 题目地址(109. 有序链表转换二叉搜索树)\n\nhttps://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/\n\n## 题目描述\n\n```\n给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。\n\n \n\n示例 1:\n\n输入: head = [-10,-3,0,5,9]\n输出: [0,-3,9,-10,null,5]\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n\n\n示例 2:\n\n输入: head = []\n输出: []\n\n\n \n\n提示:\n\nhead 中的节点数在[0, 2 * 104] 范围内\n-105 <= Node.val <= 105\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc sortedListToBST(head *ListNode) *TreeNode {\n    return buildTree(head, nil)\n}\n\nfunc getMedian(left, right *ListNode) *ListNode {\n    fast, slow := left, left\n    for fast != right && fast.Next != right {\n        fast = fast.Next.Next\n        slow = slow.Next\n    }\n    return slow\n}\n\nfunc buildTree(left, right *ListNode) *TreeNode{\n    if left == right {\n        return nil\n    }\n    mid := getMedian(left, right)\n    root := &TreeNode{mid.Val, nil, nil}\n    root.Left = buildTree(left, mid)\n    root.Right = buildTree(mid.Next, right)\n    return root\n}\n\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaoygcq":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585432380","body":"### 思路\n将数字转化为一个数组;之后将两个数组进行逐位相加.\n\n### 代码\n\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let len = num.length;\n    let kSplitArr = String(k).split(\"\").map(item => Number(item));\n    let kSplitLen = kSplitArr.length;\n    if(len < kSplitLen) {\n        let temp = num;\n        num = kSplitArr;\n        kSplitArr = temp;\n    }\n\n    // 逐位相加\n    let flag = 0;\n    len = num.length - 1;\n    while(kSplitArr.length || flag) {\n        let kVal = kSplitArr.pop();\n        let val;\n        if(kVal >= 0) {\n            val = num[len] + kVal + flag;\n        } else {\n            val = num[len] + flag;\n        }\n        flag = Math.floor(val / 10);\n        num[len] = val % 10;\n        if(flag && len - 1 < 0) {\n           num.unshift(flag)\n        }\n        len--;\n    }\n    // console.log(num)\n    return num;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1585973451","body":"### 思路\n\n遍历字符串；\n- 创建一个结果数组`res`，长度与字符串长度相同；并对每一个数组项赋初值`Infinity`;\n- 如果当前字符的值于目标字符`c`相同，那当前的`res[i] = 0`,并以当前位置向两边发散：如果一个字符到当前字符的距离比他原有的值要小(`res[j] > i - j`)，那就对其进行重新赋值；反之则终止此次发散。\n- 最终返回结果数组`res` \n\n### 代码\n\n\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const len = s.length;\n    let res = new Array(len).fill(Infinity);\n    for(let i = 0; i < len; i++) {\n        if(s[i] === c) {\n            res[i] = 0;\n            for(let j = i - 1; j >= 0; j--) {\n                if(res[j] > i - j) {\n                    res[j] = i - j;\n                } else {\n                    break;\n                }\n            }\n\n            for(let j = i + 1; j < len; j++) {\n                if(res[j] > j - i) {\n                    res[j] = j - i;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    return res;\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586381740","body":"### 思路\n\n增量更新数值时，先将栈中所有数据弹出；之后根据个数`k`以及栈的实际大小完成数据的增量更新\n\n### 代码\n\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length) {\n        return this.stack.pop();\n    }\n    return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let temp = [];\n    while(this.stack.length) {\n        temp.push(this.stack.pop());\n    }\n\n    while(temp.length && k) {\n        this.stack.push(temp.pop() + val);\n        k--;\n    }\n\n    while(temp.length) {\n        this.stack.push(temp.pop())\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1588266206","body":"### 思路\n使用栈对字符进行存储;\n- 遍历当前字符串，如果字符不是一个']'，直接入栈。\n- 如果当前字符是一个']';则需要将栈中的一部分数据进行弹出：\n    - 弹出数据时，若当前字符是在'['字符之前出栈的都是普通字符；\n    - 在'['之后弹出的是数字；拿到数字过后，直接进行字符串重建`x = str.repeat(y)`;\n    - 注意：上一步重建的字符串还需要添加会栈中(保证最终的字符串中各子串的相对位置不变)\n- 遍历完成，根据栈中内容，完成整体结果输出\n\n### 代码\n\n\n```js\n/**\n * @param {number} maxSize\n */\n/**\n * @param {string} s\n * @return {string}\n */\nconst decodeString = (s) => {\n    let stack = [];\n    let temp = [];\n    let num = [];\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] !== ']') {\n            stack.push(s[i]);\n        } else {\n            // 取出字符出栈\n            while(stack[stack.length - 1] !== '[') {\n                temp.unshift(stack.pop());\n            }\n            // 需要将'['出栈\n            stack.pop();\n\n            // 取出数字\n            while(/\\d/.test(stack[stack.length - 1])) {\n                num.unshift(stack.pop())\n            }\n\n            let numStr = Number(num.join(\"\"));\n            let str = temp.join(\"\");\n            num.length = 0;\n            temp.length = 0;\n            stack.push(str.repeat(numStr));\n        }\n    }\n    return stack.join(\"\");\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590202878","body":"### 思路\n栈与队列的本质区别：\n- 栈是先进后出\n- 队列是先进先出\n所以，要想通过栈去模拟一个队列，那就需要两个栈(一个用于存，一个用于取)。两者主要的区别体现在去首个元素\n如队列`[1,2,3]`的队首是1；如果是栈，那其栈顶元素为3；所以可以在取队列首个元素时，先将栈中\n的所有内容弹出`[3,2,1]`(只在当前作为取的这个栈为空时才需要弹出用于存的栈的所有内容);这样栈顶元素就是1了\n\n### 代码\n\n\n```js\nvar MyQueue = function() {\n    this.queue = [];\n    this.hqueue = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.queue.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(!this.hqueue.length) {\n        while(this.queue.length) {\n            this.hqueue.push(this.queue.pop());\n        }\n    }\n\n    return this.hqueue.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.hqueue.length) {\n        while(this.queue.length) {\n            this.hqueue.push(this.queue.pop());\n        }\n    }\n\n    return this.hqueue[this.hqueue.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.queue.length && !this.hqueue.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593146404","body":"### 思路\n将一个数组分块，保证分块后的有序数组合并起来依旧是一个有序数组；使用前缀和的方案；\n先将数组排序。判断一个位置i是否可以分块的前提就是：\n- 原始数组从第0项到i项到和为sum2\n- 排序后的数组从第0项到i项到和为sum1\n只要sum1 === sum2；那就说明是可以在该位置进行划分；\n### 代码\n\n\n```js\nvar maxChunksToSorted = function (arr) {\n  let sum1 = 0;\n  let sum2 = 0;\n  let ans = 0;\n  let arr2 = [...arr].sort((a, b) => a - b);\n  for (let i in arr) {\n    sum1 = sum1 + arr[i];\n    sum2 = sum2 + arr2[i];\n    if (sum1 == sum2) {\n      ans += 1;\n      sum1 = 0;\n      sum2 = 0;\n    }\n  }\n  return ans;\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1593866155","body":"### 思路\n旋转链表，将每个节点向右移动k个位置 => 将链表的后len - k个节点当作链表的起始节点：\n[1,2,3,4,5] k = 2;\n=>\n[1,2,3] -> [4,5]\n=>\n[4,5] -> [1,2,3]\n为了实现上面的效果，有以下步骤：\n- 获取当前链表长度(循环) len\n- 判断当前是否需要移动，如果 k % len === 0;那就不需要移动\n- 使用指针到 len - (k % len) - 1的位置，即示例中值为3的节点位置。\n- 取出需要放到起始位置的节点[4,5],并将原有的头节点添加到节点值为5的节点之后。 \n### 代码\n\n\n```js\nvar rotateRight = function(head, k) {\n    let len = 0;\n    let curr = head;\n    if(!head || !k) return head;\n    while(curr) {\n        len++;\n        curr = curr.next;\n    }\n    let dis = k % len;\n    if(!dis) return head;\n    let runLen = len - dis - 1;\n    let end = head;\n    while(runLen > 0) {\n        end = end.next;\n        runLen--;\n    }\n    let newHead = end.next;\n    let next = newHead;\n    end.next = null;\n    while(next.next) {\n        next = next.next;\n    }\n    next.next = head;\n    return newHead;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595558914","body":"### 思路\n每两两交换，使用两个指针；遍历链表，通过记录一个当前遍历的索引值是否为偶数，决定是否进行交换。\n这种需要记录当前索引位置链表题，建议添加一个空头节点\n注意点：\n- 确定需要交换的两个节点\n- 确定有哪些节点的指向关系\n如：\n1->2->3->4\n- dummy -> 1->2->3->4\n交换1,2时:\n- 2 -> 1 \n- 1 -> 3\n- dummy -> 2\n所以，我们的两个指针的间隔需要为2；不然我们没办法完成第三步。\n### 代码\n\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    let dummy = new ListNode();\n    dummy.next = head;\n    let prev = dummy;\n    let curr = dummy.next;\n    if(!curr) return head;\n    curr = curr.next;\n    let count = 0;\n    while(curr) {\n        if(count % 2 === 0) {\n            let next = curr.next;\n            let prevOne = prev.next;\n            prevOne.next = next;\n            curr.next = prevOne;\n            prev.next = curr;\n            [curr, prevOne] = [prevOne, curr];\n        }\n        curr = curr.next;\n        prev = prev.next;\n        count++;\n    }\n    return dummy.next;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1595912585","body":"### 思路\n确定如何正确的定位中间节点： 快慢指针是一种办法，如果快指针一次走两步、慢指针一次走一步，\n那快指针指向链表末尾时，慢指针正好在中间.\n### 代码\n\n\n```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction sortedListToBST (head) {\n    if(!head) return head;\n    let slow = fast = head;\n    let slowPrev = null;\n    while(fast && fast.next) {\n        slowPrev = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    let root = new TreeNode(slow.val);\n    if(slowPrev) {\n        slowPrev.next = null;\n        root.left = sortedListToBST(head);\n    }\n    root.right = sortedListToBST(slow.next);\n    return root;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(logN)，其中 N 为数组长度。\n- 空间复杂度：O(NlogN)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596318916","body":"### 思路\n首先根据链表的长度，确定两个链表需要进行比较的起点位置。之后各个节点依次比较\n### 代码\n\n\n```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let lenA = getLen(headA);\n    let lenB = getLen(headB);\n\n    if(lenA < lenB) {\n        [headA, headB] = [headB, headA];\n        [lenB, lenA] = [lenA, lenB];\n    }\n\n    let dis = lenA - lenB;\n    let currA = headA;\n    let currB = headB;\n    while(dis--) {\n        currA = currA.next;\n    }\n\n    while(currA && currB) {\n        if(currB === currA) {\n            return currB;\n        }\n        currA = currA.next;\n        currB = currB.next;\n    }\n    return null;\n};\n\nfunction getLen(head) {\n    let count = 0;\n    let curr = head;\n    while(curr) {\n        curr = curr.next;\n        count++;\n    }\n    return count;\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(logN)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1597890387","body":"### 思路\n使用一个Map来记录已经遍历过的节点，如果在遍历过程中，又遇到了之前遍历的节点，那就认为该节点为环形链表的头节点。\n### 代码\n\n\n```js\nvar detectCycle = function(head) {\n    let map = new WeakMap();\n    let curr = head;\n    while(curr) {\n        if(!map.has(curr)) {\n            map.set(curr, 1);\n        } else {\n            return curr;\n        }\n        curr = curr.next;\n    }\n    return null;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1599757758","body":"### 思路\n直接利用Map中键的特性完成。\n### 代码\n\n\n```js\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.size = capacity;\n    this.map = new Map();\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(this.map.has(key)) {\n        let res = this.map.get(key);\n        this.map.delete(key);\n        this.put(key, res);\n        return res;\n    }\n    return -1;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if(this.map.has(key)) {\n        this.map.delete(key);\n    } else if(this.map.size === this.size) {\n        let keys = [...this.map.keys()];\n        this.map.delete(keys[0])\n    }\n    this.map.set(key, value);\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1601860427","body":"### 思路\n使用递归实现： 节点最大高度 = max(左子节点最大高度， 右子节点最大高度) + 1；\n确定边界条件：\nif(!root) return 0;\n### 代码\n\n\n```js\nvar maxDepth = function(root) {\n    if(!root) return 0;\n    let left = maxDepth(root.left);\n    let right = maxDepth(root.right);\n\n    return Math.max(left, right) + 1;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604091614","body":"### 思路\n使用递归实现\n确定边界条件：\n- 两个节点都为null时，返回true\n- 如果只有一个节点为null，返回false\n- 判断两个都不为null节点的值是否相等，若相等，进一步判断其子节点是否相等(左子节点、右子节点)\n- 反之，直接返回false\n### 代码\n\n\n```js\nvar isSameTree = function(p, q) {\n    if(!p && !q) return true;\n    if((p && !q) || (!p && q)) return false;\n    if(p.val === q.val) {\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    } else {\n        return false;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605300186","body":"### 思路\n- 收集所有的路径(根节点到叶子节点)\n- 在叶子节点处，计算当前路径的数值\n### 代码\n\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    let res = 0;\n    if(!root) return res;\n    const dfs = (root, arr = []) => {\n        arr.push(root.val);\n        if(!root.left && !root.right) {\n            res += Number([...arr].join(\"\"));\n            return;\n        }\n        if(root.left) {\n            dfs(root.left, arr);\n            arr.pop();\n        }\n        if(root.right) {\n            dfs(root.right, arr);\n            arr.pop();\n        }\n    }\n    dfs(root, []);\n    \n    return res;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605781296","body":"### 思路\n- 使用bfs进行层序遍历，并记录每一层的数据信息\n- 取记录数组的最后一项的第一个值\n### 代码\n\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    let res = [];\n    if(!root) return root;\n    const queue = [root];\n    while(queue.length) {\n        let len = queue.length;\n        let temp = [];\n        while(len--) {\n            const top = queue.shift();\n            temp.push(top.val);\n            if(top.left) {\n                queue.push(top.left);\n            }\n            if(top.right) {\n                queue.push(top.right);\n            }\n        }\n        res.push(temp);\n    }\n    return res.pop().shift()\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1606333504","body":"### 思路\n- 使用bfs进行层序遍历，并记录每一层的数据信息(需要记录到叶子节点的子节点(用于反序列化时判断是否需要创建子节点))\n- 借用一个队列，通过bfs实现反序列化： 队列维护当前已构建树的节点信息；从序列化的内容中每次取两个值，这两个值就是当前树节点的左右子节点。\n### 代码\n\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    let res = [];\n    if(!root) return 'x';\n    let queue = [root];\n    while(queue.length) {\n        let len = queue.length;\n        while(len--) {\n            let top = queue.shift();\n            res.push(top ? top.val : 'x');\n            if(top) {\n                queue.push(top.left);\n            }\n            if(top) {\n                queue.push(top.right);\n            }\n        }\n    }\n    return res.join(\",\");\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    let arr = data.split(\",\");\n    if(arr[0] == 'x') return null;\n    let root = new TreeNode(arr[0]);\n    let cursor = 1;\n    let queue = [root];\n    while(cursor < arr.length) {\n        let curr = queue.shift();\n\n        let left = arr[cursor];\n        let right = arr[cursor+1];\n\n        if(left != 'x') {\n            let leftNode = new TreeNode(left);\n            curr.left = leftNode;\n            queue.push(leftNode);\n        }\n\n        if(right != 'x') {\n            let rightNode = new TreeNode(right);\n            curr.right = rightNode;\n            queue.push(rightNode);\n        }\n\n        cursor += 2;\n    }\n    return root;\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1608493820","body":"### 思路\n使用dfs遍历树，并通过数组记录每一个节点的col、row、val；之后对该数组进行排序，合并\n### 代码\n\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n    let res = [];\n    if(!root) return root;\n    function dfs(root, row, col) {\n        if(!root) return;\n        dfs(root.left, row+1, col - 1);\n        dfs(root.right, row+1, col + 1);\n        res.push({col, row, val: [root.val]});\n    }\n    dfs(root, 0, 0)\n\n    res.sort((a, b) => {\n        if(a.col !== b.col) {\n            return a.col - b.col\n        } else if(a.row != b.row) {\n            return a.row - b.row;\n        } else {\n            return a.val[0] - b.val[0];\n        }\n    })\n    for(let i = res.length - 1; i > 0; i--) {\n        if(res[i].col === res[i-1].col) {\n            res[i-1].val.push(...res[i].val);\n            res.splice(i, 1);\n        }\n    }\n    return res.map(item => item.val);\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1610361383","body":"### 思路\n遍历数组，同时使用map记录已经遍历的数据；\n### 代码\n\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    let map = new Map();\n\n    for(let index = 0; index < nums.length; index++) {\n        let val = nums[index];\n\n        if(map.has(val)) {\n            return [map.get(val), index];\n        }\n        map.set(target - val, index);        \n    }\n\n    return [];\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1612241790","body":"### 思路\n遍历数据，使用map记录数据的次数；之后基于map的记录数据，排序，返回结果\n### 代码\n\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    let map = new Map();\n    for(let val of nums) {\n        if(!map.has(val)) {\n            map.set(val, 1)\n        } else {\n            let count = map.get(val);\n            map.set(val, ++count);\n        }\n    }\n\n    let entries = [...map.entries()];\n    entries.sort((a, b) => b[1] - a[1]);\n    return entries.slice(0, k).map(item => item[0]);\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1613942216","body":"### 思路\n欧式距离： Math.sqrt((x1-x2) ** (x1-x2) + (y1-y2) ** (y1-y2))\n遍历数据，使用map记录每一个节点到齐相邻节点的欧式距离的数量，可直接求平方和，避免开方。\n之后记录map中存储的数量；\n注意：\n假设 [B1, B2, ... Bn] 为 n 个和 A 距离相同的点。 那么 [B1, B2, ... Bn] 中任意两个点其实都和A构成了回旋镖三元组， 所以就转化成从**n个点中任选两个（需要考虑顺序）**的问题。 答案当然是： n * (n - 1) 。\n### 代码\n\n\n```js\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    let ans = 0;\n    for (const p of points) {\n        const cnt = new Map();\n        for (const q of points) {\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n            cnt.set(dis, (cnt.get(dis) || 0) + 1);\n        }\n        for (const [_, m] of cnt.entries()) {\n            ans += m * (m - 1);\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N2)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615318754","body":"### 思路\n滑动窗口：\n- 设置一个标识字符其实位置索引值的变量left\n- 遍历字符串中的所有字符，使用map对字符的位置进行记录。\n    - 如果当前字符已经存在于map中，并且其位置(map中记录的字符位置)在起始变量left之后，则需要更新left： left的值应该更新为map记录的字符位置的后一位，因为前面的字符肯定会导致重复。\n    - 每一次循环都需要取最大的窗口值，同时更新map中的字符位置信息\n### 代码\n\n\n```js\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let map = {};\n    let res = 0;\n    let left = 0;\n    for(let i = 0; i < s.length; i++) {\n        const curr = s[i];\n        if(map[curr] >= 0 && map[curr] >= left) {\n            left = map[curr] + 1; \n        }\n        map[curr] = i;\n        res = Math.max(i - left + 1, res);\n    }\n    return  res;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616328991","body":"### 思路\n简单模拟\n- 通过map记录words中的所有单词\n- 遍历字符串s，取出符合长度的子串，遍历子串，判断子串中的单词数是否与map记录的相同，相同则记录索引。\n### 代码\n\n\n```js\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    if(!words.length || !s) return [];\n    let wordsMap = {};\n    let res = [];\n    let wordsLen = words.length;\n    let strLen = words[0].length;\n    let subStrLen = strLen * wordsLen;\n    for(let val of words) {\n        if(!wordsMap[val]) {\n            wordsMap[val] = 1;\n        } else {\n            wordsMap[val]++;\n        }\n    }\n    for(let i = 0; i < s.length - subStrLen + 1; i++) {\n        let subStr = s.slice(i, subStrLen + i);\n        // 遍历子串，记录子串是否符合要求\n        compareSubStr(subStr, strLen, wordsMap) && res.push(i);\n    }\n    return res;\n};\n\nfunction compareSubStr(str, strLen, map) {\n    let newMap = {};\n    for(let i = 0; i < str.length; i += strLen) {\n        let temp = str.slice(i, i + strLen);\n        newMap[temp] ? newMap[temp]++ : newMap[temp] = 1;\n    }\n\n    let keys = Object.keys(map);\n    for(let key of keys) {\n        if(!newMap[key] || newMap[key] != map[key]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1618215236","body":"### 思路\n前缀和、同余定理\n### 代码\n\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} p\n * @return {number}\n */\nvar minSubarray = function(nums, p) {\n    let sum = 0;\n    for (const num of nums) {\n        sum = (sum + num) % p;\n    }\n    if (sum === 0) {\n        return 0;\n    }\n    const index = new Map();\n    let y = 0, res = nums.length;\n    for (let i = 0; i < nums.length; i++) {\n        index.set(y, i); // f[i] mod p = y，因此哈希表记录 y 对应的下标为 i\n        y = (y + nums[i]) % p;\n        if (index.has((y - sum + p) % p)) {\n            res = Math.min(res, i - index.get((y - sum + p) % p) + 1);\n        }\n    }\n    return res === nums.length ? -1 : res;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1619310307","body":"### 思路\n快慢指针：\n快指针一次走两步\n慢指针一次走一步\n### 代码\n\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    if(!head) return head;\n    let slow = fast = head;\n    while(fast && fast.next) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    return slow;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1620928422","body":"### 思路\n双指针：\n指针left指向数组的第一个元素\n指针right指向数组的第二个元素\n\n- 移动指针，如果nums[left] == nums[right];right指针继续移动\n- 如果nums[left] != nums[right];将right指针的值移动到left指针下一个位置；同时移动left、right指针\n### 代码\n\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    if(nums.length < 1) return 1;\n    let left = 0, right = 0;\n    while(right < nums.length) {\n        if(nums[left] == nums[right]) {\n            right++;\n        } else {\n            nums[left + 1] = nums[right];\n            left++;\n            right++;\n        }\n    }\n    return left + 1;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1622854483","body":"### 思路\n二分查找\n### 代码\n\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n    while(left <= right) {\n        let middleIndex = Math.floor(left + (right - left) / 2)\n        let middle = nums[middleIndex];\n        if(target === middle) {\n            return middleIndex;\n        } else if(target > middle) {\n            left = middleIndex + 1;\n        } else {\n            right = middleIndex - 1;\n        }\n    }\n    return left;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1624563184","body":"### 思路\n维护一个双端队列：\n遍历数组，维护一个值递减的队列；当遍历到索引i，并且i >= k - 1的时候，可以取出队头的值(该窗口中的最大值)；\n同时，当队头的值已经在窗口之外时，需要将其弹出\n### 代码\n\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst maxSlidingWindow = function (nums, k) {\n    let res = [];\n    if(nums.length < k) return res;\n    let queue = [];\n    for(let i = 0; i < nums.length; i++) {\n        let curr = nums[i];\n        while(queue.length && nums[queue[queue.length - 1]] < curr) {\n            queue.pop();\n        }\n        queue.push(i);\n\n        while(i >= k && queue[0] <= i - k) {\n            queue.shift();\n        }\n        if(i >= k - 1) {\n            res.push(nums[queue[0]])\n        }\n    }\n\n    return res;\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(kN)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1626653524","body":"### 思路\r\n本质上是一个图的问题：\r\n计算图中每一个节点的入度和出度；当一个节点的入度为n-1(n-1个人都信任)；出度为0(不信任任何人) => 则当前节点为法官\r\n### 代码\r\n\r\n\r\n```js\r\nvar findJudge = function(n, trust) {\r\n    const inDegrees = new Array(n + 1).fill(0);\r\n    const outDegrees = new Array(n + 1).fill(0);\r\n    for (const edge of trust) {\r\n        const x = edge[0], y = edge[1];\r\n        ++inDegrees[y];\r\n        ++outDegrees[x];\r\n    }\r\n    for (let i = 1; i <= n; ++i) {\r\n        if (inDegrees[i] === n - 1 && outDegrees[i] === 0) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627710294","body":"### 思路\n二分图\n- 构建图\n- 遍历图\n\n### 代码\n\n\n```js\n/**\n * @param {number} n\n * @param {number[][]} dislikes\n * @return {boolean}\n */\nvar possibleBipartition = function (n, dislikes) {\n  let ok = true;\n  // 图节点编号从 1 开始\n  let color = new Array(n + 1).fill(false);\n  let visited = new Array(n + 1).fill(false);\n  const buildGraph = (n, dislikes) => {\n    // 图节点编号为 1...n\n    let graph = new Array(n + 1).fill(0).map(() => new Array());\n    for (let edge of dislikes) {\n      let v = edge[1];\n      let w = edge[0];\n      // 「无向图」相当于「双向图」\n      // v -> w\n      graph[v].push(w);\n      // w -> v\n      graph[w].push(v);\n    }\n    return graph;\n  };\n  const traverse = (graph, v) => {\n    if (!ok) return;\n    visited[v] = true;\n    for (let w of graph[v]) {\n      if (!visited[w]) {\n        /**\n         * 相邻节点 w 没有被访问过\n         * 那么应该给节点 w 涂上和节点 v 不同的颜色\n         */\n        color[w] = !color[v];\n        // 继续遍历 w\n        traverse(graph, w);\n      } else {\n        /**\n         * 相邻节点 w 已经被访问过\n         * 根据 v 和 w 的颜色判断是否是二分图\n         */\n        if (color[w] == color[v]) ok = false;\n      }\n    }\n  };\n\n  // 转化成邻接表表示图结构\n  const graph = buildGraph(n, dislikes);\n  for (let i = 1; i <= n; i++) {\n    if (!visited[i]) traverse(graph, i);\n  }\n  return ok;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1628368611","body":"### 思路\n二分图\n- 构建图\n- 遍历图\n\n### 代码\n\n\n```js\n/**\n * @param {number} n\n * @param {number} m\n * @param {number[]} group\n * @param {number[][]} beforeItems\n * @return {number[]}\n */\n var sortItems = function(n, m, group, beforeItems) {\n    const grahG = [], degG = new Uint16Array(n + m), idsG = [], \n          grahI = [], degI = new Uint16Array(n), idsI = [], r = []\n    for (let i = 0; i < n; i++) {\n        if (group[i] === -1) {\n            idsG[m] = m // 从组数起分配，避免重复\n            group[i] = m++\n        } else idsG[group[i]] = group[i]\n        if (!idsI[group[i]]) idsI[group[i]] = [] // 同组项目，放入到一起\n        idsI[group[i]].push(i)\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < beforeItems[i].length; j++) {\n            const itemI = beforeItems[i][j]\n            if (group[i] === group[itemI]) {// 同组，收集 项目 依赖\n                degI[i]++\n                if (!grahI[itemI]) grahI[itemI] = []\n                grahI[itemI].push(i)\n            } else {// 不同组，收集 组 依赖\n                degG[group[i]]++\n                if (!grahG[group[itemI]]) grahG[group[itemI]] = []\n                grahG[group[itemI]].push(group[i])\n            }\n        }\n    }\n    const idsGS = sort(idsG.filter(v => v !== void 0), grahG, degG) // 组排序\n    if (idsGS.length === 0) return []\n    for (let i = 0; i < idsGS.length; i++) {// 组有序，组内项目排序\n        if (!idsI[idsGS[i]]) continue\n        const idsIS = sort(idsI[idsGS[i]], grahI, degI)\n        if (idsIS.length === 0) return []\n        r.push(...idsIS)\n    }\n    return r\n};\nconst sort = (ids, grah, deg) => {// 拓扑排序：id列表，图，入度\n    const q = [], r = []\n    let start = 0\n    for (let i = 0; i < ids.length; i++) if (deg[ids[i]] === 0) q.push(ids[i])\n    while (start < q.length) {\n        const n = q[start++]\n        r.push(n)\n        if (!grah[n]) continue\n        for (let i = 0; i < grah[n].length; i++) if (--deg[grah[n][i]] === 0) q.push(grah[n][i])\n    }\n    return r.length === ids.length ? r : []\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1630526084","body":"### 思路\n将字符转化为具体操作；使用一个数组代表当前的行为。\n### 代码\n\n\n```js\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function(moves) {\n    const actions = {\n        U: [0, -1],\n        D: [0, 1],\n        L: [-1, 0],\n        R: [1, 0]\n    };\n\n    let res = [0, 0];\n    for(const item of moves) {\n        let action = actions[item]\n        res = [res[0] + action[0], res[1] + action[1]]\n    }\n    \n    for(let item of res) {\n        if(item != 0) return false;\n    }\n    return true\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1632455517","body":"### 思路\n优先队列\n### 代码\n\n\n```js\nclass Heap {\n  constructor(compare) {\n    this.A = [];\n    this.compare = compare;\n  }\n  size() {\n    return this.A.length;\n  }\n  left(i) {\n    return 2 * i + 1;\n  }\n  right(i) {\n    return 2 * i + 2;\n  }\n  parent(i) {\n    return i > 0 ? (i - 1) >>> 1 : -1;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  peek() {\n    return this.A[0];\n  }\n  heapifyDown(i) {\n    let p = i;\n    const l = this.left(i),\n      r = this.right(i),\n      size = this.size();\n    if (l < size && this.compare(l, p)) p = l;\n    if (r < size && this.compare(r, p)) p = r;\n    if (p !== i) {\n      this.exchange(i, p);\n      this.heapifyDown(p);\n    }\n  }\n  heapifyUp(i) {\n    const p = this.parent(i);\n    if (p >= 0 && this.compare(i, p)) {\n      this.exchange(i, p);\n      this.heapifyUp(p);\n    }\n  }\n  exchange(x, y) {\n    const temp = this.A[x];\n    this.A[x] = this.A[y];\n    this.A[y] = temp;\n  }\n  compare() {\n    throw new Error('Must be implement!');\n  }\n}\n\nclass PriorityQueue1 extends Heap {\n  constructor(compare) {\n    super(compare);\n  }\n  enqueue(node) {\n    this.A.push(node);\n    this.heapifyUp(this.size() - 1);\n  }\n  dequeue() {\n    const first = this.A[0];\n    const last = this.A.pop();\n    if (first !== last) {\n      this.A[0] = last;\n      this.heapifyDown(0);\n    }\n    return first;\n  }\n}\n\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nvar getOrder = function(tasks) {\n  // 为每个 task 添加一个索引属性并排序\n  tasks.forEach((v, i) => v.push(i));\n  tasks.sort((a, b) => b[0] - a[0]);\n\n  // 初始化小根堆/优先队列\n  const heap = new PriorityQueue1(function(x, y) {\n    // 第一优先级为执行时间，第二优先级为任务索引\n    return this.A[x][1] !== this.A[y][1]\n      ? this.A[x][1] < this.A[y][1]\n      : this.A[x][2] < this.A[y][2]\n  });\n  const ans = [];\n  // CPU 时间：初始化为首个任务的开始时间\n  let time = tasks[tasks.length - 1][0];\n\n  // 保证执行完所有任务\n  while (heap.size() || tasks.length) {\n    // 取出任务队列中优先级最高的任务\n    if (!heap.isEmpty()) {\n      const task = heap.dequeue();\n      ans.push(task[2]); // 记录结果\n      time += task[1];  // 任务执行完毕，递增 CPU 时间\n    }\n\n    // 添加任务到任务队列\n    addTask(heap, tasks, time);\n\n    // 边界：任务队列为空（剩余任务的入队时间跨度太大，导致上一步未能添加任务）\n    if (heap.isEmpty() && tasks.length) {\n      // 将 CPU 时间快进到下一个任务，并添加任务到任务队列\n      time = tasks[tasks.length - 1][0];\n      addTask(heap, tasks, time);\n    }\n  }\n\n  return ans;\n};\n\nfunction addTask(heap, tasks, time) {\n  // 将 tasks 中入队时间不快于当前 CPU 时间的任务入队\n  while (tasks.length && tasks[tasks.length - 1][0] <= time) {\n    heap.enqueue(tasks.pop());\n  }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1633450533","body":"### 思路\n分割开始/结束时间；通过分钟数确定偏移量offset；通过小时决定整体的数量count。\n最后的结果为 count - offset\n### 代码\n\n\n```js\n/**\n * @param {string} loginTime\n * @param {string} logoutTime\n * @return {number}\n */\nvar numberOfRounds = function(loginTime, logoutTime) {\n    let offset = 0;\n    let count = 0;\n    let startArr = loginTime.split(\":\").map(item => Number(item));\n    let startTime = startArr[0];\n    let offsetTime = startArr[1];\n    offset += findStartOffset(offsetTime);\n    let endArr = logoutTime.split(\":\").map(item => Number(item));\n    let endTime = endArr[0];\n    offsetTime = endArr[1];\n    offset -= findEndOffset(offsetTime);\n    if(endTime != startTime) {\n        if(endTime < startTime) {\n            endTime += 24;\n        }\n    } else {\n        if(endArr[1] < startArr[1]) {\n            endTime += 24;\n        }\n    }\n\n    count += (endTime - startTime) * 4 - offset\n    console.log(offset, \"==\", count)\n    return count >= 0 ? count : 0;\n};\n\nfunction findStartOffset(offsetTime) {\n    const offsetArr = [0, 15, 30, 45];\n    for(let i = 0; i < offsetArr.length; i++) {\n        if(offsetTime <= offsetArr[i]) {\n            return i;\n        }\n    }\n    return 4;\n}\n\nfunction findEndOffset(offsetTime) {\n    const offsetArr = [0, 15, 30, 45];\n    for(let i = offsetArr.length - 1; i >= 0; i--) {\n        if(offsetTime >= offsetArr[i]) {\n            return i;\n        }\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635767784","body":"### 代码\n\n\n```js\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nvar minCharacters = function(a, b) {\n    let arrA = new Array(26).fill(0);\n    let arrB = new Array(26).fill(0);\n    const n = a.length;\n    const m = b.length;\n    const sum = m + n;\n    for(let letter of a) {\n        arrA[letter.charCodeAt() - 97]++;\n    }\n\n    for(let letter of b) {\n        arrB[letter.charCodeAt() - 97]++;\n    }\n    let ans = sum;\n    for(let i = 0; i < 26; i++) {\n        for (let i = 0; i < 26 && ans != 0; i++) {\n            // 3\n            let ca = n - arrA[i], cb = m - arrB[i];\n            ans = Math.min(ans, ca + cb);\n            if (i == 0) continue;\n            let r1 = 0, r2 = 0;\n\n            // 1 使用了数组对字符个数进行了存储，所以，\n            // i以后的为大于当前字符的字符个数；反之则为小于当前字符的字符个数\n            for (let j = i; j < 26; j++) r1 += arrA[j];\n            for (let j = 0; j < i; j++) r1 += arrB[j];\n            \n            // 2\n            for (let j = i; j < 26; j++) r2 += arrB[j];\n            for (let j = 0; j < i; j++) r2 += arrA[j];\n            ans = Math.min(ans, Math.min(r1, r2));\n        }\n        return ans;\n    }\n\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1636708317","body":"### 思路\n快排\n### 代码\n\n\n```js\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortArray = function(nums) {\n    function quickSort(nums, left = 0, right = nums.length - 1) {\n        if(right >= 1) {\n            let index = partition(nums, left, right);\n            if(left < index - 1) {\n                quickSort(nums, left, index - 1);\n            }\n\n            if(right > index) {\n                quickSort(nums, index, right);\n            }\n        }\n    }\n\n    function partition(nums, left, right) {\n        let pivot = nums[Math.floor(left + (right - left) / 2)];\n        while(left <= right) {\n            while(nums[left] < pivot) {\n                left++;\n            }\n\n            while(nums[right] > pivot) {\n                right--;\n            }\n\n            if(left <= right) {\n                [nums[left], nums[right]] = [nums[right], nums[left]];\n                left++;\n                right--;\n            }\n        }\n        return left;\n    }\n    quickSort(nums);\n    return nums;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637077672","body":"### 思路\n二分\n### 代码\n\n\n```js\n/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) {\n    let left = 0, right = x;\n    let ans = -1;\n    while(left <= right) {\n        let middle = Math.floor(left + (right - left) / 2);\n        if(middle * middle <= x) {\n            left = middle + 1;\n            ans = middle;\n        } else {\n            right = middle - 1;\n        }\n    }\n    return ans;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(logN)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637324771","body":"### 思路\n二分\n### 代码\n\n\n```js\n/**\n * Definition for isBadVersion()\n * \n * @param {integer} version number\n * @return {boolean} whether the version is bad\n * isBadVersion = function(version) {\n *     ...\n * };\n */\n\n/**\n * @param {function} isBadVersion()\n * @return {function}\n */\nvar solution = function(isBadVersion) {\n    /**\n     * @param {integer} n Total versions\n     * @return {integer} The first bad version\n     */\n    return function(n) {\n        let left = 0, right = n;\n        while(left <= right) {\n            let middle = Math.floor(left + (right - left) / 2);\n            if(isBadVersion(middle)) {\n                right = middle - 1;\n                ans = middle;\n            } else {\n                left = middle + 1;\n            }\n        }\n        return left;\n    };\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(logN)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1640349400","body":"### 思路\n归并排序\n### 代码\n\n\n```js\nvar reversePairs = function (nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    let count = 0;\n\n    function mergeSort(nums, start, end) {\n        if (start == end) {\n            return 0;\n        }\n        const mid = start + ((end - start) >> 1);\n        mergeSort(nums, start, mid);\n        mergeSort(nums, mid + 1, end);\n\n        let i = start;\n        let j = mid + 1;\n        while (i <= mid && j <= end) {\n            if (nums[i] > 2 * nums[j]) {\n                count += mid - i + 1;\n                j++;\n            } else {\n                i++;\n            }\n        }\n        i = start;\n        j = mid + 1;\n        const temp = new Array(end - start + 1);\n        let index = 0;\n        while (i <= mid && j <= end) {\n            if (nums[i] < nums[j]) {\n                temp[index] = nums[i];\n                index++;\n                i++;\n            } else {\n                temp[index] = nums[j];\n                index++;\n                j++;\n            }\n        }\n        while (i <= mid) {\n            temp[index] = nums[i];\n            index++;\n            i++;\n        }\n        while (j <= end) {\n            temp[index] = nums[j];\n            index++;\n            j++;\n        }\n        for (let i = start, k = 0; i <= end; i++, k++) {\n            nums[i] = temp[k];\n        }\n    }\n    \n    mergeSort(nums, 0, nums.length - 1);\n    return count;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/42#issuecomment-1641714904","body":"### 思路\n二分查找：\n遍历houses中的每一个元素，找到离每一个元素最近的heater（使用二分的方式进行查找）\n最终的答案是上面找到的 离每一个元素最近的heater 中的最小值\n\n### 代码\n```js\nvar findRadius = function(houses, heaters) {\n    let ans = 0;\n    heaters.sort((a, b) => a - b);\n    for (const house of houses) {\n        const i = binarySearch(heaters, house);\n        const j = i + 1;\n        const leftDistance = i < 0 ? Number.MAX_VALUE : house - heaters[i];\n        const rightDistance = j >= heaters.length ? Number.MAX_VALUE : heaters[j] - house;\n        const curDistance = Math.min(leftDistance, rightDistance);\n        ans = Math.max(ans, curDistance);\n    }\n    return ans;\n};\n\nconst binarySearch = (nums, target) => {\n    let left = 0, right = nums.length - 1;\n    if (nums[left] > target) {\n        return -1;\n    }\n    while (left < right) {\n        const mid = Math.floor((right - left + 1) / 2) + left;\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid;\n        }\n    }\n    return left;\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1644043420","body":"### 思路\n二分查找\n\n### 代码\n```js\nvar smallestDistancePair = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    let n = nums.length, left = 0, right = nums[n - 1] - nums[0];\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        let cnt = 0;\n        for (let j = 0; j < n; j++) {\n            const i = binarySearch(nums, j, nums[j] - mid);\n            cnt += j - i;\n        }\n        if (cnt >= k) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n};\n\nconst binarySearch = (nums, end, target) => {\n    let left = 0, right = end;\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/45#issuecomment-1646448533","body":"### 思路\n滑动窗口：\n- 首先记录第一个窗口的元音字母数目num；\n- 移动窗口，如果移出的元素(左边)为元音字母，则num--；\n- 如果移入的元素(右边)为元音字母，则num++；\n### 代码\n```js\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar maxVowels = function(s, k) {\n    let ans = -1;\n    let left = 0, right = k;\n    const Letters = ['a', 'e', 'i', 'o', 'u'];\n    let num = count(s.slice(left, right));\n    while(right <= s.length) {\n        if(left > 0) {\n            if(Letters.includes(s[right-1])) {\n                num++;\n            }\n            if(Letters.includes(s[left-1])) {\n                num--\n            }\n        }\n        num > ans && (ans = num)\n        left++;\n        right++;\n    }\n    return ans;\n};\n\nfunction count(str) {\n    const Letters = ['a', 'e', 'i', 'o', 'u'];\n    \n    let num = 0;\n    for(let val of str) {\n        Letters.includes(val) && num++;\n    }\n    return num;\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/47#issuecomment-1648077580","body":"### 思路\n滑动窗口；\n### 代码\n```js\n/**\n * @param {string} s\n * @param {string} p\n * @return {number[]}\n */\nvar findAnagrams = function(s, p) {\n    let origin = countStr(p);\n    let res = [];\n    let len = p.length;\n    for(let i = 0; i <= s.length - len; i++) {\n        let temp = countStr(s.slice(i, i+len), Object.assign({}, origin));\n\n        if(temp) {\n            res.push(i);\n        }\n    }\n    return res;\n};\n\nfunction countStr(str, map) {\n    if(map) {\n        for(let val of str) {\n            if(!map[val]) return false;\n            map[val]--;\n        }\n        return true;\n    } else {\n        let res = {};\n        for(let val of str) {\n            if(!res[val]) {\n                res[val] = 0;\n            }\n            res[val]++;\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(KN)，其中 N 为s的长度， K为p的长度。\n- 空间复杂度：O(K)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/49#issuecomment-1651833193","body":"### 思路\r\n滑动窗口:\r\n把求k个数的最大和 => 连续 len - k个数的最小和\r\n### 代码\r\n```js\r\n/**\r\n * @param {number[]} cardPoints\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar maxScore = function(cardPoints, k) {\r\n    // 求连续 cardPoints.length - k 个元素的最小和\r\n    let len = cardPoints.length;\r\n    let size = len - k;\r\n    let sum = 0;\r\n    for(let i = 0; i < size; i++) {\r\n        sum += cardPoints[i];\r\n    }\r\n\r\n    let minSum = sum;\r\n    for(let i = len - k; i < len; i++) {\r\n        sum += cardPoints[i] - cardPoints[i - size];\r\n        minSum = Math.min(minSum, sum);\r\n    }\r\n\r\n    return cardPoints.reduce((prev, curr) => prev + curr) - minSum;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(K)，其中 N 为s的长度， K\r\n- 空间复杂度：O(Math.max(K, N - k))\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/50#issuecomment-1653812783","body":"### 思路\n将问题转化为从 [1,2,4,8,1,2,4,8,16,32] 中选择一定数量的数字，并且满足时间格式的排列个数\n### 代码\n```js\n/**\n * @param {number} turnedOn\n * @return {string[]}\n */\n/**\n * @param {number} num\n * @return {string[]}\n */\nvar readBinaryWatch = function(num) {\n  const arr = [1, 2, 4, 8, 1, 2, 4, 8, 16, 32]\n  const result = []\n  backTrace(arr, num, 0, [0, 0], result)\n  return result\n};\n\nvar backTrace = function(arr, num, start, temp, result) {\n  if (temp[0] >= 12 || temp[1] >= 60) return\n  if (num === 0) {\n    result.push(`${temp[0]}:${padding(temp[1])}`)\n    return\n  }\n\n  for (let i = start; i < arr.length; i++) {\n    if (i <= 3) {\n      temp[0] = temp[0] + arr[i]\n    } else {\n      temp[1] = temp[1] + arr[i]\n    }\n    num = num - 1\n    backTrace(arr, num, i + 1, temp, result)\n    if (i <= 3) {\n      temp[0] = temp[0] - arr[i]\n    } else {\n      temp[1] = temp[1] - arr[i]\n    }\n    num = num + 1\n  }\n}\n\nvar padding = function(num) {\n  return num < 10 ? `0${num}` : num\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/52#issuecomment-1656580017","body":"### 思路\n通过dfs找出所有相连的格子，并记录其面积和；最终取最大值。\n通过染色法实现对值为1的格子的查找。\n### 代码\n```js\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxAreaOfIsland = function(grid) {\n  let area = 0;\n  let m = grid.length, n = grid[0].length;\n  for(let i = 0; i < m; i++) {\n    for(let j = 0; j < n; j++) {\n      if(grid[i][j] == 1) {\n        let temp = dfs(grid, i, j);\n        temp >= area && (area = temp);\n      }\n    }\n  }\n\n  return area;\n\n  function dfs(grid, i, j) {\n    let temp = 0;\n    if(i < 0 || i >= m || j < 0 || j >= n) {\n        return temp;\n    }\n    if(grid[i][j] == 1) {\n        temp += 1;\n        grid[i][j] = 2;\n        temp += dfs(grid, i - 1, j);\n        temp += dfs(grid, i + 1, j);\n        temp += dfs(grid, i, j - 1);\n        temp += dfs(grid, i, j + 1);\n    }\n    return temp;\n  }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(MN)，其中 N 为数组行数的长度， M为数组列数。\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/53#issuecomment-1657085322","body":"### 思路\n多源BFS;从陆地往外扩展，直到所有的海洋变为陆地，记录需要的次数\n### 代码\n```js\n/**\n * @param {number[][]} grid\n * @return {number}\n */\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nfunction maxDistance(grid) {\n    const n = grid.length;\n    const queue = [];\n\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            // 将所有陆地加入队列，而不是海洋，陆地不断扩展到海洋\n            if (grid[i][j] == 1) {\n                queue.push([i, j]);\n            }\n        }\n    }\n\n    let ans = -1;\n    // 都是海洋 或 都是陆地\n    if (queue.length === 0 || queue.length === n * n) {\n        return ans;\n    }\n\n    // 方向数组\n    const locations = [\n        [0, -1],\n        [0, 1],\n        [-1, 0],\n        [1, 0],\n    ];\n\n    while (queue.length != 0) {\n        const len = queue.length;\n\n        // 对每个陆地4个方向搜索\n        for (let k = 0; k < len; k++) {\n            const [x, y] = queue.shift();\n            // 向该点的4个方向进行搜索\n            for (const location of locations) {\n                const nextI = x + location[0];\n                const nextJ = y + location[1];\n\n                // 合法 且 是海洋\n                if (\n                    nextI >= 0 &&\n                    nextI < n &&\n                    nextJ >= 0 &&\n                    nextJ < n &&\n                    grid[nextI][nextJ] == 0\n                ) {\n                    grid[nextI][nextJ] = 1; // 变为陆地\n                    queue.push([nextI, nextJ]);\n                }\n            }\n        }\n        ans++;\n    }\n    return ans;\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N2)，其中 N 为数组行数的长度， M为数组列数。\n- 空间复杂度：O(1)\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/56#issuecomment-1662363945","body":"### 思路\ndp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1])\n### 代码\n```js\nvar minCostClimbingStairs = function (cost) {\n  let len = cost.length;\n  let dp = Array(len + 1).fill(0);\n  dp[0] = dp[1] = 0;\n  for (let i = 2; i <= len; i++) {\n    dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n  }\n  console.log(dp);\n  return dp[len];\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组行数的长度.\n- 空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"catkathy":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585533545","body":"### 思路\r\n将整数数组 num 转换为一个整数，然后将整数 k 加到这个整数上，再将得到的和转换回整数数组\r\n\r\n### Python Code\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n\r\n        n = 0\r\n        for i in num:\r\n            n = n * 10 + i\r\n        \r\n        n = n + k\r\n        num = []\r\n\r\n        while n != 0:\r\n            num.append(n % 10)\r\n            n //= 10\r\n            \r\n        return num[::-1]\r\n```\r\n\r\n### 复杂度分析\r\n- Time: O(N)\r\n- Space: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586053981","body":"#### 思路 \r\niterating through the string s while calculating the occurrence of character C.\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        n = len(s)\r\n        ans = [0] * n\r\n        j = float('-inf')\r\n        \r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                j = i\r\n            ans[i] = i - j\r\n        \r\n        j = float('inf')\r\n        \r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                j = i\r\n            ans[i] = min(ans[i], j - i)\r\n        \r\n        return ans\r\n```\r\n\r\n#### Time & Space Complexity\r\n- Time complexity: O(n)\r\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586789924","body":"#### Code\r\n``` Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.increment = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n            self.increment.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n\r\n        index = len(self.stack) - 1\r\n        val = self.stack.pop() + self.increment[index]\r\n\r\n        if index > 0:\r\n            self.increment[index - 1] += self.increment[index]\r\n        self.increment[index] = 0\r\n\r\n        return val\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        index = min(k, len(self.stack)) - 1\r\n        if index >= 0:\r\n            self.increment[index] += val\r\n```\r\n\r\n#### Time & Space Complexities\r\n- Time: O(1)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1588767540","body":"#### 思路\r\n栈，遍历\r\n\r\n#### Code\r\n``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n\r\n        for i in range(len(s)):\r\n            if s[i] != \"]\":\r\n                stack.append(s[i])\r\n            else:\r\n                sub_str = \"\"\r\n                while stack[-1] != \"[\":\r\n                    sub_str = stack.pop() + sub_str\r\n                stack.pop()\r\n\r\n                multiplier = \"\" \r\n                while stack and stack[-1].isdigit():\r\n                    multiplier = stack.pop() + multiplier\r\n                    \r\n                stack.append(int(multiplier) * sub_str)\r\n\r\n        return \"\".join(stack)\r\n```\r\n\r\n\r\n#### 复杂度分析:\r\n- Time: O(n)\r\n- Space: O(m)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590607404","body":"#### 思路\r\n用两个栈实现一个队列\r\n\r\n#### Code\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.s1.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        self.peek()\r\n        return self.s2.pop()\r\n        \r\n    def peek(self) -> int:\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2[-1]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        return not self.s1 and not self.s2\r\n        \r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n#### 复杂度分析\r\n- Time: O(n) when pop and peek, O(1) for others\r\n- Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592675842","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for value in arr:\r\n            if not stack or value >= stack[-1]:\r\n                stack.append(value)\r\n            else:\r\n                max_value = stack.pop()\r\n                while stack and stack[-1] > value:\r\n                    stack.pop()\r\n                stack.append(max_value)\r\n        return len(stack)\r\n```\r\n\r\n#### 复杂度分析：\r\n- Time: O（n)\r\n- Space: O(n)\r\n- Space:","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594302502","body":"#### Code\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n\r\n        if head is None or head.next is None:\r\n            return head\r\n    \r\n\r\n        num_nodes = 0\r\n        node = head\r\n        while node is not None:\r\n            num_nodes += 1\r\n            node = node.next\r\n        \r\n        # Step 2: Calculate effective rotation\r\n        k = k % num_nodes\r\n        \r\n        # Step 3: Check if rotation is unnecessary\r\n        if k == 0:\r\n            return head\r\n        \r\n        # Step 4: Find the (k+1)-th node from the end\r\n        fast = head\r\n        slow = head\r\n        for _ in range(k):\r\n            fast = fast.next\r\n        \r\n        while fast.next is not None:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        \r\n        dummy = slow.next\r\n        slow.next = None\r\n        fast.next = head\r\n        \r\n        return dummy\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595666191","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        dummy = ListNode(0)\r\n        dummy.next = head\r\n        prev = dummy\r\n    \r\n        while prev.next is not None and prev.next.next is not None:\r\n            temp = head.next.next\r\n            prev.next = head.next\r\n            head.next.next = head\r\n            head.next = temp\r\n            prev = head\r\n            head = head.next\r\n    \r\n        return dummy.next\r\n```\r\n\r\n####  复杂度分析\r\n- Time: O(n)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596014046","body":"#### 思路\r\n快慢指针\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head or not head.next:\r\n            return TreeNode(head.val) if head else None\r\n        \r\n        dummy = ListNode(0)\r\n        dummy.next = head\r\n        slow, fast, prev = head, head, dummy\r\n\r\n        while fast and fast.next:\r\n            prev = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            \r\n        new_head = slow.next\r\n        prev.next = None  \r\n        \r\n        root = TreeNode(slow.val)\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(new_head)\r\n\r\n        return root\r\n```\r\n\r\n#### 复杂度分析：\r\n- Time: O(n)\r\n- Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596510084","body":"#### 思路\r\n双指针\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        p1, p2 = headA, headB\r\n        while p1 != p2:\r\n            if p1 is None:\r\n                p1 = headB\r\n            else:\r\n                p1 = p1.next\r\n            if p2 is None:\r\n                p2 = headA\r\n            else:\r\n                p2 = p2.next\r\n        return p2 # or p1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598200323","body":"#### 思路\r\n快慢指针\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        slow, fast = head, head\r\n        \r\n        # find the meeting point\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            # if found, break the loop\r\n            if slow == fast:\r\n                break\r\n            # if not, return null\r\n        else:\r\n            return None\r\n\r\n\r\n        # Find the node where the cycle begins\r\n        # Move the slow pointer to the head of the linked list\r\n        slow = head\r\n        \r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return fast # or return slow (starting point)\r\n\r\n        # Move both pointers at the same pace until they meet again\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600285569","body":"#### Code\r\n```python\r\nclass ListNode:\r\n    def __init__ (self, key = 0, val = 0):\r\n        self.key = key\r\n        self.val = val \r\n        self.next = None\r\n        self.prev = None  \r\n\r\nclass LRUCache:   \r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashMap = {}\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def remove_node(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def add_node_to_last(self, node):\r\n        self.tail.prev.next = node\r\n        node.prev = self.tail.prev\r\n        node.next = self.tail\r\n        self.tail.prev = node\r\n\r\n    def move_node_to_last(self, node):\r\n        self.remove_node(node)\r\n        self.add_node_to_last(node)     \r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.hashMap:\r\n            return -1\r\n        node = self.hashMap[key]\r\n        self.move_node_to_last(node)\r\n        return node.val\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashMap:\r\n            node = self.hashMap[key]\r\n            node.val = value\r\n            self.move_node_to_last(node)\r\n            return\r\n        if len(self.hashMap) == self.capacity:\r\n            del self.hashMap[self.head.next.key]\r\n            self.remove_node(self.head.next)\r\n        node = ListNode(key, value)\r\n        self.hashMap[key] = node\r\n        self.add_node_to_last(node)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602222713","body":"#### Code\n``` python\n\nclass Solution:\n  def maxDepth(self, root: Optional[TreeNode]) -> int:\n    if not root:\n      return 0\n    return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1603721749","body":"#### Code\r\n``` python\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        stack = [(p, q)]\r\n        while stack:\r\n            (p, q) = stack.pop()\r\n            if p and q and p.val == q.val:\r\n                stack.extend([\r\n                    (p.left,  q.left),\r\n                    (p.right, q.right)\r\n                ])\r\n            elif p or q:\r\n                return False\r\n        return True\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605302681","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        def dfs(node: TreeNode, current_sum: int) -> int:\r\n            if not node:\r\n                return 0\r\n\r\n            current_sum = current_sum * 10 + node.val\r\n\r\n            if not node.left and not node.right:\r\n                return current_sum\r\n\r\n            left_sum = dfs(node.left, current_sum)\r\n            right_sum = dfs(node.right, current_sum)\r\n\r\n            return left_sum + right_sum\r\n\r\n        return dfs(root, 0)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1606138781","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return None\r\n        q = []\r\n        ans = []\r\n        if root:\r\n            q.append(root)\r\n        while(q):\r\n            node = q.pop(0)\r\n            ans.append(node.val)\r\n            if node.right:q.append(node.right)\r\n            if node.left:q.append(node.left)\r\n        return ans[-1]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1606717091","body":"#### Code\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return 'None'\r\n        return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))\r\n        \r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        def dfs(dataList):\r\n            val = dataList.pop(0)\r\n            if val == 'None':\r\n                return None\r\n            root = TreeNode(int(val))\r\n            root.left = dfs(dataList)\r\n            root.right = dfs(dataList)\r\n            return root\r\n\r\n        dataList = data.split(',')\r\n        return dfs(dataList)\r\n        \r\n\r\n# Your Codec object will be instantiated and called as such:\r\n# ser = Codec()\r\n# deser = Codec()\r\n# ans = deser.deserialize(ser.serialize(root))\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1608867549","body":"#### 思路\r\ndfs\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        def dfs(node, row, col):\r\n            if node is None:\r\n                return\r\n\r\n            # Add the current node to the column dict\r\n            if col in columns:\r\n                columns[col].append((row, node.val))\r\n            else:\r\n                columns[col] = [(row, node.val)]\r\n\r\n            # Recursive calls for the left and right children\r\n            dfs(node.left, row + 1, col - 1)\r\n            dfs(node.right, row + 1, col + 1)\r\n\r\n        # Dict to store nodes by column position\r\n        columns = {}\r\n        # Perform the DFS traversal\r\n        dfs(root, 0, 0)\r\n\r\n        # Sort the columns based on the column index\r\n        sorted_columns = sorted(columns.items(), key=lambda x: x[0])\r\n\r\n        # Build the result list\r\n        result = []\r\n        for col, nodes in sorted_columns:\r\n            # Sort the nodes in each column by row and node value\r\n            sorted_nodes = sorted(nodes, key=lambda x: (x[0], x[1]))\r\n            # Extract the node values from the sorted nodes\r\n            values = [node[1] for node in sorted_nodes]\r\n            result.append(values)\r\n\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1610882515","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        n = len(nums)\r\n        for i in range(n):\r\n            for j in range(i+1, n):\r\n                if nums[i] + nums[j]==target:\r\n                    return i, j\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1612466821","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        count = {}\r\n        freq = [[] for i in range(len(nums) + 1)]\r\n        \r\n        for n in nums:\r\n            count[n] = count.get(n, 0) + 1\r\n        for n, c in count.items():\r\n            freq[c].append(n)\r\n            \r\n        \r\n        res = []\r\n        for i in range(len(freq) - 1, 0, -1):\r\n            for n in freq[i]:\r\n                res.append(n)\r\n                if len(res) == k:\r\n                    return res\r\n\r\n        \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614179831","body":"#### 思路\r\n哈希映射\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        n = len(points)\r\n        ans = 0\r\n        for i in range(n):\r\n            dist_map = defaultdict(int)\r\n            for j in range(n):\r\n                if i == j:\r\n                    continue\r\n                x = points[i][0] - points[j][0]\r\n                y = points[i][1] - points[j][1]\r\n                dist = x * x + y * y\r\n                dist_map[dist] += 1\r\n            for dist in dist_map:\r\n                cnt = dist_map[dist]\r\n                ans += cnt * (cnt - 1)\r\n        return and\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615502977","body":"#### Code\r\n``` python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        charSet = set()\r\n        left = 0\r\n        res = 0\r\n\r\n        for right in range(len(s)):\r\n            while s[right] in charSet:\r\n                charSet.remove(s[left])\r\n                left += 1\r\n            charSet.add(s[right])\r\n            res = max(res, right - left + 1)\r\n\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616395033","body":"#### 思路\r\n滑动窗口\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        if not s or not words:\r\n            return []\r\n\r\n        word_length = len(words[0])\r\n        total_length = len(words) * word_length\r\n        word_freq = Counter(words)\r\n        result = []\r\n\r\n        for i in range(len(s) - total_length + 1):\r\n            seen = {}\r\n            for j in range(i, i + total_length, word_length):\r\n                curr_word = s[j:j + word_length]\r\n                if curr_word not in word_freq or seen.get(curr_word, 0) >= word_freq[curr_word]:\r\n                    break\r\n                seen[curr_word] = seen.get(curr_word, 0) + 1\r\n            else:\r\n                result.append(i)\r\n\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1617511005","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def minSubarray(self, nums: List[int], p: int) -> int:\r\n        total_sum = sum(nums)\r\n        target = total_sum % p\r\n        if target == 0:\r\n            return 0\r\n\r\n        prefix_sums = {0: -1}  # initial prefix sum of 0 at index -1\r\n        current_sum = 0\r\n        result = float('inf')\r\n\r\n        for i, num in enumerate(nums):\r\n            current_sum = (current_sum + num) % p\r\n\r\n            complement = (current_sum - target) % p\r\n            if complement in prefix_sums:\r\n                result = min(result, i - prefix_sums[complement])\r\n\r\n            prefix_sums[current_sum] = i\r\n        \r\n        if result < len(nums):\r\n            return result\r\n        else:\r\n            return -1\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1619649563","body":"#### 思路\r\n快慢指针\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1621099112","body":"\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        n = len(nums)\r\n        j = 0\r\n\r\n        for i in range(n):\r\n            if nums[i] != nums[j]:\r\n                j += 1\r\n                nums[j] = nums[i]\r\n\r\n        return j + 1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1622556486","body":"#### 思路\r\nbinary search\r\n\r\n#### Code\r\n```\r\n        left, right = -1, len(nums)\r\n        while left + 1 != right:\r\n            mid = (left + right) // 2\r\n            if nums[mid] < target:\r\n                left = mid\r\n            else:\r\n                right = mid\r\n        return right\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1626898201","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        graph = defaultdict(list)\r\n        in_degrees = [0] * (n+1)\r\n        out_degrees = [0] * (n+1)\r\n\r\n        for a, b in trust:\r\n            graph[a].append(b)\r\n            out_degrees[a] += 1\r\n            in_degrees[b] += 1\r\n\r\n        for i in range(1, n+1):\r\n            if out_degrees[i] == 0 and in_degrees[i] == n-1:\r\n                return i\r\n\r\n        return -1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627625917","body":"#### 思路\r\nBFS\r\n\r\n#### Code\r\n```\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n\r\n        graph = defaultdict(list)\r\n        for a, b in dislikes:\r\n            graph[a].append(b)\r\n            graph[b].append(a)\r\n\r\n        colors = [0] * (n + 1)\r\n\r\n        for i in range(1, n + 1):\r\n            if colors[i] == 0:\r\n                colors[i] = 1\r\n                queue = deque([i])\r\n\r\n                while queue:\r\n                    person = queue.popleft()\r\n                    for disliked_person in graph[person]:\r\n                        if colors[disliked_person] == colors[person]:\r\n                            return False  \r\n                        if colors[disliked_person] == 0:\r\n                            colors[disliked_person] = -colors[person]\r\n                            queue.append(disliked_person)\r\n\r\n        return True\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1628415645","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def sortItems(self, n, m, group, beforeItems):\r\n        def get_top_order(graph, indegree):\r\n            top_order = []\r\n            stack = [node for node in range(len(graph)) if indegree[node] == 0]\r\n            while stack:\r\n                v = stack.pop()\r\n                top_order.append(v)\r\n                for u in graph[v]:\r\n                    indegree[u] -= 1\r\n                    if indegree[u] == 0:\r\n                        stack.append(u)\r\n            return top_order if len(top_order) == len(graph) else []\r\n\r\n        for u in range(len(group)):\r\n            if group[u] == -1:\r\n                group[u] = m\r\n                m += 1\r\n\r\n        graph_items = [[] for _ in range(n)]\r\n        indegree_items = [0] * n\r\n        graph_groups = [[] for _ in range(m)]\r\n        indegree_groups = [0] * m\r\n        for u in range(n):\r\n            for v in beforeItems[u]:\r\n                graph_items[v].append(u)\r\n                indegree_items[u] += 1\r\n                if group[u] != group[v]:\r\n                    graph_groups[group[v]].append(group[u])\r\n                    indegree_groups[group[u]] += 1\r\n\r\n        item_order = get_top_order(graph_items, indegree_items)\r\n        group_order = get_top_order(graph_groups, indegree_groups)\r\n        if not item_order or not group_order:\r\n            return []\r\n\r\n        order_within_group = collections.defaultdict(list)\r\n        for v in item_order:\r\n            order_within_group[group[v]].append(v)\r\n\r\n        res = []\r\n        for group in group_order:\r\n            res += order_within_group[group]\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1630363188","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def judgeCircle(self, moves: str) -> bool:\r\n        x = 0  \r\n        y = 0  \r\n\r\n        for move in moves:\r\n            if move == 'U':\r\n                y += 1  # Move up\r\n            elif move == 'D':\r\n                y -= 1  # Move down\r\n            elif move == 'L':\r\n                x -= 1  # Move left\r\n            elif move == 'R':\r\n                x += 1  # Move right\r\n\r\n        return x == 0 and y == 0\r\n```\r\n\r\n#### 复杂度分析\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1632177712","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:       \r\n        for i, t in enumerate(tasks):\r\n            t.append(i)\r\n        tasks.sort(key = lambda t: t[0])\r\n\r\n        ans, pq = [], []\r\n        i, time = 0, tasks[0][0]\r\n        while i < len(tasks):\r\n            while i<len(tasks) and time >= tasks[i][0]:\r\n                heappush(pq, [tasks[i][1], tasks[i][2]])\r\n                i+=1\r\n            \r\n            if pq:\r\n                priority, idx = heappop(pq)\r\n                ans.append(idx)\r\n                time += priority\r\n            else:\r\n                time = tasks[i][0]\r\n        \r\n        while pq:\r\n            priority, idx = heappop(pq)\r\n            ans.append(idx)\r\n        return ans\r\n```\r\n\r\n#### 复杂度分析\r\n- Time: O(N)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1633830283","body":"#### 思路\r\n将登录时间和注销时间转换为分钟表示，将登录时间向上调整到下一个15分钟的间隔，将注销时间向下调整到上一个15分钟的间隔，然后计算调整后的时间之间完整的15分钟间隔的个数。\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\r\n\r\n        login_minutes = self.time_to_minutes(loginTime)\r\n        logout_minutes = self.time_to_minutes(logoutTime)\r\n\r\n        if logout_minutes < login_minutes:\r\n            logout_minutes += 24 * 60\r\n\r\n        rounded_login = self.round_up(login_minutes)\r\n        rounded_logout = self.round_down(logout_minutes)\r\n\r\n        # Calculate the number of rounds played\r\n        num_rounds = max(0, (rounded_logout - rounded_login) // 15)\r\n\r\n        return num_rounds\r\n\r\n    def time_to_minutes(self, time_str: str) -> int:\r\n        # Parse the hours and minutes from the time string\r\n        hours, minutes = map(int, time_str.split(':'))\r\n        # Convert hours to minutes and sum with minutes\r\n        total_minutes = hours * 60 + minutes\r\n        return total_minutes\r\n\r\n    def round_up(self, minutes: int) -> int:\r\n        # Round up to the next multiple of 15\r\n        rounded_minutes = (minutes + 14) // 15 * 15\r\n        return rounded_minutes\r\n\r\n    def round_down(self, minutes: int) -> int:\r\n        # Round down to the previous multiple of 15\r\n        rounded_minutes = minutes // 15 * 15\r\n        return rounded_minutes\r\n```\r\n\r\n#### 复杂度分析\r\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635509279","body":"#### 思路\r\n通过累计频率数组来计算满足条件所需的最小操作次数\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n        presum_A = 0\r\n        presum_B = 0\r\n\r\n        counter_A = Counter([ch for ch in a])\r\n        counter_B = Counter([ch for ch in b])\r\n\r\n        res = sys.maxsize\r\n\r\n        m, n = len(a), len(b)\r\n\r\n        res = min(res, m - max(counter_A.values()) + n - max(counter_B.values()))\r\n        presum_A = []\r\n        sum_A = 0\r\n        presum_B = []\r\n        sum_B = 0\r\n\r\n        for i in range(0, 26):\r\n            sum_A += counter_A[chr(i + 97)]\r\n            presum_A.append(sum_A)\r\n            sum_B += counter_B[chr(i + 97)]\r\n            presum_B.append(sum_B)\r\n        \r\n        for i in range(0, 25):\r\n            res = min(m - presum_A[i] + presum_B[i], res)\r\n        \r\n        for i in range(0, 25):\r\n            res = min(n - presum_B[i] + presum_A[i], res)\r\n        \r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1636718161","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def sortArray(self, nums: List[int]) -> List[int]:\r\n        if len(nums) <= 1: return nums\r\n\r\n        mid = len(nums) // 2\r\n        left = nums[:mid]\r\n        right = nums[mid:]\r\n\r\n        left_sorted = self.sortArray(left)\r\n        right_sorted = self.sortArray(right)\r\n\r\n        return self.merge(left_sorted, right_sorted)\r\n    \r\n    def merge(self, left: List[int], right: List[int]) -> List[int]:\r\n        merged = []\r\n        i = j = 0\r\n        \r\n        while i < len(left) and j < len(right):\r\n            if left[i] <= right[j]:\r\n                merged.append(left[i])\r\n                i += 1\r\n            else:\r\n                merged.append(right[j])\r\n                j += 1\r\n        \r\n        merged.extend(left[i:])\r\n        merged.extend(right[j:])\r\n        \r\n        return merged\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637051848","body":"```python\n\ndef mySqrt(x):\n    if x == 0:\n        return 0\n\n    left, right = 1, x\n    while left <= right:\n        mid = (left + right) // 2\n        if mid * mid == x:\n            return mid\n        elif mid * mid < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return right\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637367682","body":"#### 思路\r\nBinary Search\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def firstBadVersion(self, n: int) -> int:\r\n        left, right = -1, n\r\n        while left + 1!= right:\r\n            mid = (left + right)//2\r\n            if not isBadVersion(mid):\r\n                left = mid\r\n            else:\r\n                right = mid\r\n        return right\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1639662383","body":"#### Code\r\n```python\r\nclass Solution:\r\n    def reversePairs(self, nums: List[int]) -> int:\r\n        self.res = 0\r\n\r\n        def merge_sort(arr, start, end):\r\n            if start == end:\r\n                return\r\n\r\n            mid = start + (end - start) // 2\r\n\r\n            merge_sort(arr, start, mid)\r\n            merge_sort(arr, mid + 1, end)\r\n\r\n            i, j = start, mid + 1\r\n            while i <= mid and j <= end:\r\n                if arr[i] > 2 * arr[j]:\r\n                    self.res += mid - i + 1\r\n                    j += 1\r\n                else:\r\n                    i += 1\r\n\r\n            i, j, index = start, mid + 1, 0\r\n            temp = [0] * (end - start + 1)\r\n            while i <= mid and j <= end:\r\n                if arr[i] < arr[j]:\r\n                    temp[index] = arr[i]\r\n                    i += 1\r\n                else:\r\n                    temp[index] = arr[j]\r\n                    j += 1\r\n                index += 1\r\n\r\n            while i <= mid:\r\n                temp[index] = arr[i]\r\n                i += 1\r\n                index += 1\r\n\r\n            while j <= end:\r\n                temp[index] = arr[j]\r\n                j += 1\r\n                index += 1\r\n\r\n            index = 0\r\n            for i in range(start, end + 1):\r\n                arr[i] = temp[index]\r\n                index += 1\r\n\r\n        merge_sort(nums, 0, len(nums) - 1)\r\n\r\n        return self.res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/42#issuecomment-1641581067","body":"#### Code(475\r\n```python\r\nclass Solution:\r\n    def findRadius(self, houses, heaters):\r\n        houses.sort()\r\n        heaters.sort()\r\n        radius = 0\r\n\r\n        for house in houses:\r\n            left, right = 0, len(heaters)\r\n\r\n            while left < right:\r\n                mid = (left + right) // 2\r\n\r\n                if heaters[mid] < house:\r\n                    left = mid + 1\r\n                else:\r\n                    right = mid\r\n\r\n            left_dist = abs(heaters[left] - house) if left < len(heaters) else float('inf')\r\n            prev_dist = abs(heaters[left - 1] - house) if left > 0 else float('inf')\r\n            radius = max(radius, min(left_dist, prev_dist))\r\n\r\n        return radius\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/46#issuecomment-1646783847","body":"```python\r\nclass Solution:\r\n    def new21Game(self, N, K, maxPts):\r\n        if K == 0:\r\n            return 1.0\r\n        if N >= K - 1 + maxPts:\r\n            return 1.0\r\n\r\n        dp = [0.0] * (N + 1)\r\n\r\n        probability = 0.0  \r\n        windowSum = 1.0 \r\n        dp[0] = 1.0\r\n\r\n        for i in range(1, N + 1):\r\n            dp[i] = windowSum / maxPts\r\n\r\n            if i < K:\r\n                windowSum += dp[i]\r\n            else:\r\n                probability += dp[i]\r\n\r\n            if i >= maxPts:\r\n                windowSum -= dp[i - maxPts]\r\n\r\n        return probability\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/47#issuecomment-1647406521","body":"```java\r\nclass Solution {\r\n    public List<Integer> findAnagrams(String s, String p) {\r\n        HashMap<Character, Integer> window_map = new HashMap<>();\r\n        HashMap<Character, Integer> p_map = new HashMap<>();\r\n        for (int i = 0; i < p.length(); i++){\r\n            char c1 = p.charAt(i);\r\n            p_map.put(c1, p_map.getOrDefault(c1, 0) + 1);\r\n        }\r\n        int left, right, count;\r\n        left = right = count = 0;\r\n        ArrayList<Integer> res = new ArrayList<>();\r\n        \r\n        while(right < s.length()){\r\n            char c = s.charAt(right);\r\n            right++;\r\n            if (p_map.containsKey(c)){\r\n                window_map.put(c, window_map.getOrDefault(c, 0) + 1);\r\n                if(window_map.get(c).equals(p_map.get(c))){\r\n                    count++;\r\n                }\r\n            }\r\n            while(right - left == p.length()){\r\n                if (count == p_map.size()){\r\n                    res.add(left);\r\n                }\r\n                char d = s.charAt(left);\r\n                left++;\r\n                if (p_map.containsKey(d)){\r\n                    if (window_map.get(d).equals(p_map.get(d))){\r\n                        count--;\r\n                    }\r\n                    window_map.put(d, window_map.getOrDefault(d, 0) -1);\r\n                }\r\n            } \r\n        }\r\n        return res;  \r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/48#issuecomment-1649305403","body":"```python\r\nclass Solution:\r\n    def minWindow(self, s: str, t: str) -> str:\r\n        lookup = collections.defaultdict(int)\r\n        for c in t:\r\n            lookup[c] += 1\r\n        start = 0\r\n        end = 0\r\n        min_len = float('inf')\r\n        counter = len(t)\r\n        res = \"\"\r\n        while end < len(s):\r\n            if lookup[s[end]] > 0:\r\n                counter -= 1\r\n            lookup[s[end]] -=1\r\n            end += 1\r\n\r\n            while counter == 0:\r\n                if min_len > end - start:\r\n                    min_len = end - start\r\n                    res = s[start:end]\r\n                if lookup[s[start]]==0:\r\n                    counter += 1\r\n                lookup[s[start]] += 1\r\n                start += 1\r\n        return res\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/52#issuecomment-1656586089","body":"```python\r\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        res, row, col = 0, len(grid), len(grid[0])\r\n        \r\n        def dfs(x, y):\r\n            if not (0 <= x < row and 0 <= y < col):\r\n                return 0\r\n            if grid[x][y] == 1:\r\n                grid[x][y] = 0\r\n                return 1 + dfs(x-1, y) + dfs(x, y-1) + dfs(x+1, y) + dfs(x, y+1)\r\n            return 0\r\n\r\n        for m in range(row):\r\n            for n in range(col):\r\n                if grid[m][n] == 1:\r\n                    res = max(dfs(m, n), res)\r\n        return res\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yqycs":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585533896","body":"### 思路：\n    将K逐位分解，加入到A中。具体实现方式是将 K 从末位开始依次加到 A 中对应位置上，若相加后的结果大于等于 10，则将进位部分加到下一位上；若 K 加完后仍有进位，则在 A 的最前面插入一个 0。\n\n### 代码：\n```\nclass Solution:\n  def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        i = len(A) - 1\n        while K:\n            A[i] += K\n            K, A[i] = A[i] // 10, A[i] % 10\n            i -= 1\n            if i < 0 and K:\n                A.insert(0,0)\n                i = 0\n        return A\n```\n\n### 复杂度：\n     时间复杂度为 O(n)，其中 n 为数组 A 的长度。因为需要遍历整个数组 A，所以时间复杂度与数组 A 的长度成正比。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586017357","body":"### 功能\n    实现了一个函数，输入一个字符串s和一个字符c，输出一个列表，列表中的每个元素表示s中对应位置到字符c的最短距离。\n### 算法思路\n    遍历字符串s中的每个字符，如果该字符就是c，则距离为0，否则向左向右分别查找最近的一个字符c，并计算距离。最后取左右距离中的较小值作为该位置到字符c的最短距离。\n### 时间复杂度\n    因为对于每个字符，都需要向左向右查找最近的字符c，最坏情况下需要遍历整个字符串两遍，所以时间复杂度为O(n)。\n```\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            if (i == 0 or i == len(s)-1) and s[i] == c:\n                res.append(0)\n            else:\n                j, k = i, i\n                m, n = 0, 0\n                while(s[j] != c):\n                    j += 1\n                    m += 1\n                    if j > len(s)-1:\n                        m = float(\"inf\")\n                        break\n                while(s[k] != c): \n                    k -= 1\n                    n += 1\n                    if k < 0:\n                        n = float(\"inf\")\n                        break\n                res.append(min(m,n))\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586690631","body":"### 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = 0\n        self.maxSize = maxSize\n        self.CustomStack = []\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.CustomStack.append(x)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        res = self.CustomStack[-1]\n        del self.CustomStack[-1]\n        self.size -= 1\n        return res\n       \n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.size)):\n            self.CustomStack[i] += val\n```\n### 复杂度\n    push()方法的时间复杂度为 $O(1)，需在列表末尾添加一个元素。\n    pop()方法的时间复杂度为 $O(1)，需删除列表末尾的一个元素。\n    increment()方法的时间复杂度为 O(k)，需遍历栈顶的前k个元素进行加法操作。\n    空间复杂度为 O(maxSize)，需使用一个列表来存储栈的元素。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1588614568","body":"### 思路\n⽤栈处理，遇到 \"[\"，就要开始重复字符串了，另外重复的数字是可能存在多位的，\n所以需要往前找到不为数字的那⼀位，把数字转换出来。\n最后⽤把 stack ⾥⾯的字符串都串联起来即可\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        def dfs(s, i):\n            res, multi = \"\", 0\n            while i < len(s):\n                if '0' <= s[i] <= '9':\n                    multi = multi * 10 + int(s[i])\n                elif s[i] == '[':\n                    i, tmp = dfs(s, i + 1)\n                    res += multi * tmp\n                    multi = 0\n                elif s[i] == ']':\n                    return i, res\n                else:\n                    res += s[i]\n                i += 1\n            return res\n        return dfs(s,0)\n```\n### 复杂度\n时间复杂度:  O(n)\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590381808","body":"### 代码\n```\nclass MyQueue:\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n        self.front = None\n\n    def push(self, x: int) -> None:\n        if not self.s1: self.front = x\n        self.s1.append(x)\n\n    def pop(self) -> int:\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            self.front = None\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        if self.s2: \n            return self.s2[-1]\n        return self.front\n\n    def empty(self) -> bool:\n        if not self.s1 and not self.s2:\n            return True\n        return False\n```\n\n### 复杂度\n时间复杂度：\n- 入队操作的时间复杂度为O(1)\n- 出队操作的时间复杂度最坏情况下为O(n)，因为需要将s1中的所有元素都弹出并压入s2中，但平均时间复杂度为O(1)\n- 查看队首元素的时间复杂度为O(1)\n- 判断队列是否为空的时间复杂度为O(1)\n\n空间复杂度：\n- 需要使用两个栈s1和s2来实现队列，因此空间复杂度为O(n)，其中n为队列中元素的个数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuxinyu-znb":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585540099","body":"## 思路：\n将k和num全都转化为num数组，倒叙排列后逐位相加，因为如果直接都转为数字相加的话，有可能会溢出。\n逐位相加后如果超过9了说明需要进位，将进位符置1，如不满则为0，将保留各位后的数字push进结果数组。\n依次相加后直到某个长度更短的数组全部遍历完后结束相加过程。\n再将两数组剩余的部分进行遍历填充，这里要注意的是记得将之前的进位符进行处理，防止遗漏。\n都遍历完之后再处理一遍进位符\n最后将数组倒序回来就可以得到最终的结果\n## 代码：\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let k_num = String(k).split('').map((num) => Number(num)).reverse()\n    num = num.reverse()\n    let temp = 0;\n    const k_len = k_num.length;\n    const num_len = num.length;\n    let i = 0;\n    let res_num = []\n    while(i < k_len && i< num_len) {\n        let res = k_num[i] + num[i] + temp\n        if (res > 9) {\n            temp = 1\n            res = res - 10\n        } else {\n            temp = 0\n        }\n        res_num.push(res)\n        i++\n    }\n    while(i < k_len) {\n        let res = k_num[i] + temp\n        if (res > 9) {\n            temp = 1\n            res = res - 10\n        } else {\n            temp = 0\n        }\n        res_num.push(res)\n        i++\n    }\n    while(i < num_len) {\n        let res = num[i] + temp\n        if (res > 9) {\n            temp = 1\n            res = res - 10\n        } else {\n            temp = 0\n        }\n        res_num.push(res)\n        i++\n    }\n    if (temp > 0) {\n        res_num.push(temp)\n    }\n    return res_num.reverse()\n};\n```\n## 复杂度：\n时间复杂度为O(n)\n空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586063941","body":"## 思路\n左到右遍历一遍记录位置的同时记录一遍到c的距离\n再从右到左遍历比较取最小值\n## 代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let n = s.length\n    const res = new Array(n).fill(0)\n    for(let i = 0, x = -n; i < n; ++i) {\n        if (s[i] === c) {\n            x = i\n        }\n        res[i] = i - x\n    }\n    for(let j = n - 1, y = 2 * n; j >= 0; --j) {\n        if (s[j] === c) {\n            y = j\n        }\n        res[j] = Math.min(res[j], y - j)\n    }\n    return res\n};\n```\n\n## 复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587604009","body":"```javascript\nfunction ListNode(val){\n    this.val=val;\n    this.next=null;\n}\nvar CustomStack = function(maxSize) {\n    this.maxSize=maxSize;\n    //链表头指向栈顶；\n    this.head=null;\n    this.length=0;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.length===this.maxSize) return;\n    let node=new ListNode(x);\n    let linkList=this.head;\n    node.next=linkList;\n    this.head=node;\n    this.length++;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.length===0) return -1;\n    let linkList=this.head.next;\n    let popVal=this.head.val;\n    this.head=linkList;\n    this.length--;\n    return popVal;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(k<0) return;\n    let start=this.length-k;\n    let currentNode=this.head;\n    if(start>0){\n        for(let i=0;i<start;++i){\n            currentNode=currentNode.next;\n        }\n    }\n    while(currentNode){\n        currentNode.val+=val;\n        currentNode=currentNode.next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589330713","body":"## 思路\n利用栈来操作\n\n## 代码\n```javascript\n// 用两个栈来存放当前状态，前者是重复次数，后者是累积字符串\n    let repetStack=[],resStack=[];\n    //拼接字符串\n    let resStr = \"\";\n    //表示重复次数\n    let repet = 0;\n    // 遍历s\n    for(let i=0;i<s.length;i++){\n        let cur = s.charAt(i);\n        if(cur == '['){\n            //双双压入栈中,保存当前状态\n            repetStack.push(repet);\n            resStack.push(resStr);\n            //置空，准备下面的累积\n            repet = 0;\n            resStr = \"\";\n        }else if(cur == ']'){\n            // 取出当前重复次数栈中的值，也就是当前字符串的重复次数\n            let count = repetStack.pop();\n            // 根据重复次数生成重复字符串，赋值给temp，和resStr拼接\n            let temp = \"\";\n            for(let i = 0;i<count;i++){\n                temp += resStr;\n            }\n            // 和前面已经求得的字符串进行拼接\n            resStr = resStack.pop() + temp;\n        }else if(cur>='0' && cur<='9'){\n            // repet累积\n            repet = repet*10 + (cur-'0');\n        }else{\n            //字符累积\n            resStr += cur;\n        }\n    }\n    return resStr;\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freesan44":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585574093","body":"## 思想:\n通过小数组大数组分别pop来实现\n\n## 代码:\n```\nclass Solution989 {\n    func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] {\n//        var newK = Array<Int>()\n//        var vk = k\n//        var vNum: [Int] = num\n//        var newRet = Array<Int>()\n//\n//        while vk>0 {\n//            newK.insert(vk%10, at: 0)\n//            vk = vk/10\n//        }\n//        var temp = 0\n//        while vNum.count>0 || newK.count>0 || temp != 0{\n//            var left = 0\n//            var right = 0\n//            if vNum.count>0{\n//                left = vNum.removeLast()\n//            }\n//            if newK.count>0{\n//                right = newK.removeLast()\n//            }\n//            print(right,left)\n//            var ret = left + right + temp\n//            temp = 0\n//            if ret>9{\n//                temp = ret/10\n//                ret = ret%10\n//            }\n//            newRet.insert(ret, at: 0)\n////            print(newRet)\n//        }\n//        return newRet\n        var res = [Int]()\n        var n = num.count\n        var vk = k\n\n        for i in stride(from: n - 1, through: 0, by: -1) {\n            if i >= 0 {\n                vk += num[i]\n            }\n            res.append(vk % 10)\n            vk /= 10\n        }\n\n        while vk > 0 {\n            res.append(vk % 10)\n            vk /= 10\n        }\n\n        return res.reversed()\n    }\n    \n    func test() {\n//        var num = [2,7,4]\n//        var k = 983\n        var num = [1,2,0,0]\n        var k = 34\n        let ret = addToArrayForm(num,k);\n        print(ret);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586140164","body":"## 代码\n```\nclass Solution821 {\n    func shortestToChar(_ S: String, _ C: Character) -> [Int] {\n        var result = [Int]()\n        for (i, char) in S.enumerated() {\n            if char == C {\n                result.append(0)\n            } else {\n                var left = i\n                var right = i\n                while left >= 0 || right < S.count {\n                    if left >= 0 && S[S.index(S.startIndex, offsetBy: left)] == C {\n                        result.append(i - left)\n                        break\n                    }\n                    if right < S.count && S[S.index(S.startIndex, offsetBy: right)] == C {\n                        result.append(right - i)\n                        break\n                    }\n                    left -= 1\n                    right += 1\n                }\n            }\n        }\n        return result\n    }\n    func test() {\n        var s = \"loveleetcode\"\n        var c: Character = \"e\"\n        let ret = shortestToChar(s,c);\n        print(ret);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586719677","body":"## 思路\n## 代码\n```\nclass CustomStack {\n    \n    var maxLen: Int\n    var tempArr: [Int]\n    \n    init(_ maxSize: Int) {\n        maxLen = maxSize\n        tempArr = Array<Int>()\n    }\n    \n    func push(_ x: Int) {\n        if tempArr.count <= maxLen-1{\n            tempArr.append(x)\n        }\n    }\n    \n    func pop() -> Int {\n        if tempArr.count == 0{\n            return -1\n        }\n        else{\n            return tempArr.removeLast() \n        }\n    }\n    \n    func increment(_ k: Int, _ val: Int) {\n        if tempArr.count <= k{\n            self.tempArr = self.tempArr.map{$0 + val}\n        }\n        else\n        {\n            for i in self.tempArr.indices.prefix(k){\n                self.tempArr[i] += val\n            }\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * let obj = CustomStack(maxSize)\n * obj.push(x)\n * let ret_2: Int = obj.pop()\n * obj.increment(k, val)\n */\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592158199","body":"## 思路\n计数排序\n\n## 代码\n```\nclass Solution768 {\n    func maxChunksToSorted(_ arr: [Int]) -> Int {\n        // 定义一个变量 ans，用于记录最终的答案\n        var ans = 0\n        var countA = [Int: Int]()\n        var countB = [Int: Int]()\n        \n        // 遍历 arr 和 arr.sorted()，将它们的每个元素合并成一个元组 (a, b)\n        for (a, b) in zip(arr, arr.sorted()) {\n            // 在 countA 中增加 a 出现的次数\n            countA[a, default: 0] += 1\n            // 在 countB 中增加 b 出现的次数\n            countB[b, default: 0] += 1\n            // 如果 countA 和 countB 相等，那么说明 arr 的前 i 个元素可以分成一个 chunk，并将 ans 加 1\n            print(countA,countB)\n            if countA == countB {\n                ans += 1\n            }\n        }\n\n        // 返回最终的答案\n        return ans\n    }\n    func test() {\n//        var arr = [5,4,3,2,1]\n        var arr = [2,1,3,4,4]\n        let ret = maxChunksToSorted(arr);\n        print(ret);\n    }\n    \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1593849424","body":"## 思路\n快慢指针\n\n## 代码\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\n        guard let head = head else { return nil }\n        var p1: ListNode? = head\n        var p2: ListNode? = head\n        var count = 1\n        var i = 0\n        var k = k\n\n        while i < k {\n            if let next = p2?.next {\n                count += 1\n                p2 = next\n            } else {\n                k = k % count\n                i = -1\n                p2 = head\n            }\n            i += 1\n        }\n\n        while p2?.next != nil {\n            p1 = p1?.next\n            p2 = p2?.next\n        }\n\n        if let next = p1?.next {\n            let tmp = next\n            p1?.next = nil\n            p2?.next = head\n            return tmp\n        } else {\n            return head\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595660020","body":"```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func swapPairs(_ head: ListNode?) -> ListNode? {\n        guard let head = head, let next = head.next else {\n        return head\n    }\n\n    let dummy = ListNode(-1, head)\n    var prev: ListNode? = dummy\n    var cur: ListNode? = prev?.next\n\n    while cur != nil && cur?.next != nil {\n        let nextNode = cur?.next\n        cur?.next = nextNode?.next\n        nextNode?.next = cur\n        prev?.next = nextNode\n\n        prev = cur\n        cur = cur?.next\n    }\n\n    return dummy.next\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596310347","body":"## 思路\n双指针\n## 代码\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.next = nil\n *     }\n * }\n */\n\nclass Solution {\n    func getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode? {\n         var a = headA\n    var b = headB\n    \n    while a !== b {\n        a = a != nil ? a!.next : headB\n        b = b != nil ? b!.next : headA\n    }\n    \n    return a\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602022506","body":"```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func maxDepth(_ root: TreeNode?) -> Int {\n        guard let root = root else { return 0 }\n        return 1 + max(maxDepth(root.left), maxDepth(root.right))\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605777875","body":"## 代码\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func findBottomLeftValue(_ root: TreeNode?) -> Int {\n        var queue = [TreeNode?]()\n        queue.append(root)\n        var res = 0\n        while !queue.isEmpty {\n            let length = queue.count\n            res = queue[0]?.val ?? 0\n            for _ in 0..<length {\n                let cur = queue.removeFirst()\n                if let left = cur?.left {\n                    queue.append(left)\n                }\n                if let right = cur?.right {\n                    queue.append(right)\n                }\n            }\n        }\n        return res\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1608465486","body":"```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func verticalTraversal(_ root: TreeNode?) -> [[Int]] {\n        var seen: [Int: [Int: [Int]]] = [:]\n    \n    func dfs(_ root: TreeNode?, _ x: Int = 0, _ y: Int = 0) {\n        guard let root = root else {\n            return\n        }\n        seen[x, default: [:]][y, default: []].append(root.val)\n        dfs(root.left, x - 1, y + 1)\n        dfs(root.right, x + 1, y + 1)\n    }\n    \n    dfs(root)\n    var ans: [[Int]] = []\n    for x in seen.keys.sorted() {\n        var level: [Int] = []\n        for y in seen[x]!.keys.sorted() {\n            level.append(contentsOf: seen[x]![y]!.sorted())\n        }\n        ans.append(level)\n    }\n    return ans\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1610345527","body":"```\nclass Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n//        for (index,value) in nums.enumerated(){\n//            let tempTarget = target\n//            var temp = tempTarget - value\n//            //遍历index之后的数组\n//            for (index2,value2) in nums.enumerated().filter({ (index2,_) in index2>index}){\n//                if (temp - value2) == 0{\n//                    return[index,index2]\n//                }\n//            }\n//\n//        }\n        var dic : [Int:Int] = [Int:Int]()\n        for (index, value) in nums.enumerated(){\n            let tempTarget = target\n            var temp = tempTarget - value\n            if dic[temp] != nil {\n                return [dic[temp]!,index]\n            }\n            dic[value] = index\n//            print(dic)\n        }\n        \n        return []\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1613937578","body":"```\nclass Solution {\n    func numberOfBoomerangs(_ points: [[Int]]) -> Int {\n        if points.isEmpty || points.count <= 2 {\n        return 0\n    }\n\n    var res = 0\n    var equalCount = [Int: Int]()\n\n    for i in 0..<points.count {\n        for j in 0..<points.count {\n            let distance = getDistance(points[i], points[j])\n            equalCount[distance, default: 0] += 1\n        }\n\n        for count in equalCount.values {\n            res += count * (count - 1)\n        }\n        equalCount.removeAll()\n    }\n\n    return res\n    }\n    private func getDistance(_ x: [Int], _ y: [Int]) -> Int {\n    let x1 = y[0] - x[0]\n    let y1 = y[1] - x[1]\n\n    return x1 * x1 + y1 * y1\n}\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1617017498","body":"```\nclass Solution {\n    func minSubarray(_ nums: [Int], _ p: Int) -> Int {\n         var total = nums.reduce(0, +)\n    let mod = total % p\n    if mod == 0 { return 0 }\n\n    var ans = nums.count\n    total = 0\n    var dic: [Int: Int] = [0: -1]\n    for j in 0..<nums.count {\n        total += nums[j]\n        let cur = total % p\n        let target = (cur - mod + p) % p\n        if let index = dic[target] {\n            ans = min(ans, j - index)\n        }\n        dic[cur] = j\n    }\n\n    if ans == nums.count {\n        return -1\n    }\n    return ans\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1619236748","body":"```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init() { self.val = 0; self.next = nil; }\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\n * }\n */\nclass Solution {\n    func middleNode(_ head: ListNode?) -> ListNode? {\n        var slow = head\n        var fast = head\n        \n        while fast != nil && fast?.next != nil {\n            fast = fast?.next?.next\n            slow = slow?.next\n        }\n        \n        return slow\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1622671232","body":"```\nclass Solution {\n    func searchInsert(_ nums: [Int], _ target: Int) -> Int {\n        var l = 0\n    var r = nums.count - 1\n\n    while l <= r {\n        let mid = (l + r) / 2\n        if nums[mid] == target {\n            return mid\n        }\n        if nums[mid] < target {\n            l = mid + 1\n        } else {\n            r = mid - 1\n        }\n    }\n    return l\n    }\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1629869870","body":"```\nclass Solution {\n    func judgeCircle(_ moves: String) -> Bool {\n    var x = 0\n    var y = 0\n    for move in moves {\n        if move == \"R\" { x += 1 }\n        if move == \"L\" { x -= 1 }\n        if move == \"U\" { y += 1 }\n        if move == \"D\" { y -= 1 }\n    }\n\n    return x == 0 && y == 0\n}\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635059009","body":"```\nclass Solution {\n    func minCharacters(_ A: String, _ B: String) -> Int {\n        var counter_A = [Int](repeating: 0, count: 26)\n    var counter_B = [Int](repeating: 0, count: 26)\n    \n    for a in A {\n        let index = Int(a.asciiValue! - Character(\"a\").asciiValue!)\n        counter_A[index] += 1\n    }\n    \n    for b in B {\n        let index = Int(b.asciiValue! - Character(\"a\").asciiValue!)\n        counter_B[index] += 1\n    }\n    \n    var ans = A.count + B.count\n    \n    for i in 0..<26 {\n        ans = min(ans, A.count + B.count - counter_A[i] - counter_B[i])\n    }\n    \n    for i in 1..<26 {\n        var t = 0\n        for j in i..<26 {\n            t += counter_A[j]\n        }\n        \n        for j in 0..<i {\n            t += counter_B[j]\n        }\n        \n        ans = min(ans, t)\n    }\n    \n    for i in 1..<26 {\n        var t = 0\n        for j in i..<26 {\n            t += counter_B[j]\n        }\n        \n        for j in 0..<i {\n            t += counter_A[j]\n        }\n        \n        ans = min(ans, t)\n    }\n    \n    return ans\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637217681","body":"```\n/**\n * The knows API is defined in the parent class VersionControl.\n *     func isBadVersion(_ version: Int) -> Bool{}\n */\n\nclass Solution : VersionControl {\n    func firstBadVersion(_ n: Int) -> Int {\n        var l = 1\n    var r = n\n    \n    while l <= r {\n        let mid = (l + r) / 2\n        \n        if isBadVersion(mid) {\n            // 收缩\n            r = mid - 1\n        } else {\n            l = mid + 1\n        }\n    }\n    \n    return l\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1639004726","body":"```\nclass Solution {\n    func reversePairs(_ A: [Int]) -> Int {\n        var ans = 0\n        \n        for i in 0..<A.count {\n            for j in (i+1)..<A.count {\n                if A[i] > A[j] * 2 {\n                    ans += 1\n                }\n            }\n        }\n        \n        return ans\n    }\n}\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/44#issuecomment-1644772403","body":"```\nclass Solution {\n    func swimInWater(_ grid: [[Int]]) -> Int {\n         var l = 0\n        var r = grid.flatMap { $0 }.max() ?? 0\n        var seen = Set<(Int, Int)>()\n\n        func test(_ mid: Int, _ x: Int, _ y: Int) -> Bool {\n            if x > grid.count - 1 || x < 0 || y > grid[0].count - 1 || y < 0 {\n                return false\n            }\n            if grid[x][y] > mid {\n                return false\n            }\n            if (x, y) == (grid.count - 1, grid[0].count - 1) {\n                return true\n            }\n            if seen.contains((x, y)) {\n                return false\n            }\n            seen.insert((x, y))\n            let ans = test(mid, x + 1, y) || test(mid, x - 1, y) || test(mid, x, y + 1) || test(mid, x, y - 1)\n            return ans\n        }\n        \n        while l <= r {\n            let mid = (l + r) / 2\n            if test(mid, 0, 0) {\n                r = mid - 1\n            } else {\n                l = mid + 1\n            }\n            seen = Set<(Int, Int)>()\n        }\n        \n        return l\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/47#issuecomment-1646986269","body":"```\nclass Solution {\n    func findAnagrams(_ s: String, _ p: String) -> [Int] {\n        var target = [Character: Int]()\n        var ans = [Int]()\n        \n        for char in p {\n            target[char, default: 0] += 1\n        }\n        \n        for i in 0..<s.count {\n            if i >= p.count {\n                let charToRemove = s[s.index(s.startIndex, offsetBy: i - p.count)]\n                target[charToRemove] = (target[charToRemove] ?? 0) + 1\n                if target[charToRemove] == 0 {\n                    target[charToRemove] = nil\n                }\n            }\n            \n            let charToAdd = s[s.index(s.startIndex, offsetBy: i)]\n            target[charToAdd, default: 0] -= 1\n            if target[charToAdd] == 0 {\n                target[charToAdd] = nil\n            }\n            \n            if target.isEmpty {\n                ans.append(i - p.count + 1)\n            }\n        }\n        \n        return ans\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/50#issuecomment-1652682222","body":"```\nclass Solution {\n    func readBinaryWatch(_ num: Int) -> [String] {\n        return (0..<12).flatMap { a in\n            (0..<60).compactMap { b in\n                let binary = String(a, radix: 2) + String(b, radix: 2)\n                let count = binary.filter { $0 == \"1\" }.count\n                if count == num {\n                    return \"\\(a):\\(String(b).padding(toLength: 2, withPad: \"0\", startingAt: 0))\"\n                } else {\n                    return nil\n                }\n            }\n        }\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/54#issuecomment-1657292371","body":"```\nclass Solution {\n    func maxCandies(_ status: [Int], _ candies: [Int], _ keys: [[Int]], _ containedBoxes: [[Int]], _ initialBoxes: [Int]) -> Int {\n        var boxes = Set(initialBoxes)\n    var queue = initialBoxes.filter { status[$0] }\n    var totalCandies = 0\n    \n    while !queue.isEmpty {\n        let box = queue.removeFirst()\n        for containedBox in containedBoxes[box] {\n            boxes.insert(containedBox)\n            if status[containedBox] {\n                queue.append(containedBox)\n            }\n        }\n        for key in keys[box] {\n            if status[key] == false && boxes.contains(key) {\n                queue.append(key)\n            }\n            status[key] = true\n        }\n        totalCandies += candies[box]\n    }\n    \n    return totalCandies\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/56#issuecomment-1661239200","body":"```\nclass Solution {\n    func minCostClimbingStairs(_ cost: [Int]) -> Int {\n        if cost.isEmpty {\n        return 0\n    }\n    \n    var dp = Array(repeating: 0, count: cost.count + 1)\n    dp[0] = cost[0]\n    dp[1] = cost[1]\n    \n    for i in 2...cost.count {\n        dp[i] = min(dp[i - 1], dp[i - 2]) + (i == cost.count ? 0 : cost[i])\n    }\n    \n    return dp[cost.count]\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/58#issuecomment-1664741877","body":"```\nclass Solution {\n    func findNumberOfLIS(_ nums: [Int]) -> Int {\n        let n = nums.count\n    var dp = [[1, 1]] + Array(repeating: [1, 1], count: n-1)\n    var ans = [1, 1]\n    var longest = 1\n    \n    for i in 0..<n {\n        for j in i+1..<n {\n            if nums[j] > nums[i] {\n                if dp[i][0] + 1 > dp[j][0] {\n                    dp[j][0] = dp[i][0] + 1\n                    dp[j][1] = dp[i][1]\n                    longest = max(longest, dp[j][0])\n                } else if dp[i][0] + 1 == dp[j][0] {\n                    dp[j][1] += dp[i][1]\n                }\n            }\n        }\n    }\n    \n    return dp.filter { $0[0] == longest }.reduce(0) { $0 + $1[1] }\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/61#issuecomment-1667003927","body":"```\nclass Solution {\n    private let dir = [[-1, -2], [1, -2], [2, -1], [2, 1], [1, 2], [-1, 2], [-2, 1], [-2, -1]]\n\n    func knightProbability(_ N: Int, _ K: Int, _ r: Int, _ c: Int) -> Double {\n        var dp = Array(repeating: Array(repeating: 0.0, count: N), count: N)\n        dp[r][c] = 1\n\n        for step in 1...K {\n\n            var dpTemp = Array(repeating: Array(repeating: 0.0, count: N), count: N)\n\n            for i in 0..<N {\n                for j in 0..<N {\n                    for direction in dir {\n\n                        let lastR = i - direction[0]\n                        let lastC = j - direction[1]\n                        if lastR >= 0 && lastR < N && lastC >= 0 && lastC < N {\n                            dpTemp[i][j] += dp[lastR][lastC] * 0.125\n                        }\n                    }\n                }\n            }\n\n            dp = dpTemp\n        }\n\n        var res = 0.0\n\n        for i in 0..<N {\n            for j in 0..<N {\n                res += dp[i][j]\n            }\n        }\n\n        return res\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/62#issuecomment-1668694481","body":"```\nclass Solution {\n    func canIWin(_ maxChoosableInteger: Int, _ desiredTotal: Int) -> Bool {\n        if desiredTotal <= maxChoosableInteger {\n            return true\n        }\n        if (1...maxChoosableInteger).reduce(0, +) < desiredTotal {\n            return false\n        }\n        \n        var memo: [Int: Bool] = [:]\n        \n        func dp(_ picked: Int, _ acc: Int) -> Bool {\n            if acc >= desiredTotal {\n                return false\n            }\n            if picked == (1 << (maxChoosableInteger + 1)) - 1 {\n                return false\n            }\n            if let result = memo[picked] {\n                return result\n            }\n            \n            for n in 1...maxChoosableInteger {\n                if picked & (1 << n) == 0 {\n                    if !dp(picked | (1 << n), acc + n) {\n                        memo[picked] = true\n                        return true\n                    }\n                }\n            }\n            memo[picked] = false\n            return false\n        }\n        \n        return dp(0, 0)\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/64#issuecomment-1672313317","body":"```\nclass Solution {\n    func findTargetSumWays(_ nums: [Int], _ target: Int) -> Int {\n        let totalSum = nums.reduce(0, +)\n        let desiredSum = totalSum + target\n        \n        if desiredSum % 2 != 0 {\n            return 0\n        }\n        \n        let halfSum = desiredSum / 2\n        var dp = [Int](repeating: 0, count: halfSum + 1)\n        dp[0] = 1\n        \n        for i in 0..<nums.count {\n            for j in (nums[i]...halfSum).reversed() {\n                dp[j] += dp[j - nums[i]]\n            }\n        }\n        \n        return dp[halfSum]\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/65#issuecomment-1674091432","body":"```\nclass Solution {\n    func coinChange(_ coins: [Int], _ amount: Int) -> Int {\n                var dp = [Int](repeating: amount + 1, count: amount + 1)\n        dp[0] = 0\n        \n        for i in 1...amount {\n            for coin in coins {\n                if i >= coin {\n                    dp[i] = min(dp[i], dp[i - coin] + 1)\n                }\n            }\n        }\n        \n        return dp[amount] == amount + 1 ? -1 : dp[amount]\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/68#issuecomment-1676490196","body":"```\nclass Solution {\n    func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {\n        let n = intervals.count\n    if n == 0 {\n        return 0\n    }\n    \n    var dp = [Int](repeating: 1, count: n)\n    var ans = 1\n    var sortedIntervals = intervals.sorted { $0[0] < $1[0] }\n    \n    for i in 0..<n {\n        for j in (0..<i).reversed() {\n            if sortedIntervals[i][0] >= sortedIntervals[j][1] {\n                dp[i] = max(dp[i], dp[j] + 1)\n                break // 由于是按照开始时间排序的，因此可以剪枝\n            }\n        }\n    }\n    \n    return n - dp.max()!\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/69#issuecomment-1678196025","body":"```\nclass Solution {\n    func canJump(_ nums: [Int]) -> Bool {\n        var maxIndex = 0\n        let length = nums.count\n        \n        for i in 0..<(length - 1) {\n            if maxIndex < i {\n                return false\n            }\n            maxIndex = max(maxIndex, nums[i] + i)\n            \n            if maxIndex >= length - 1 {\n                return true\n            }\n        }\n        \n        return maxIndex >= length - 1\n\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/72#issuecomment-1683085570","body":"```\nclass Solution {\n    func beautifulArray(_ N: Int) -> [Int] {\n        var cache = [Int: [Int]]()\n\n        func dp(_ n: Int) -> [Int] {\n            if n == 1 {\n                return [1]\n            }\n\n            if let cachedResult = cache[n] {\n                return cachedResult\n            }\n\n            var ans = [Int]()\n            for a in dp(n - n / 2) {\n                ans.append(a * 2 - 1)\n            }\n            for b in dp(n / 2) {\n                ans.append(b * 2)\n            }\n\n            cache[n] = ans\n            return ans\n        }\n\n        return dp(N)\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/75#issuecomment-1685420479","body":"```\nclass TrieNode {\n    var count: Int\n    var preCount: Int\n    var children: [Character: TrieNode]\n\n    init() {\n        count = 0\n        preCount = 0\n        children = [:]\n    }\n}\n\nclass Trie {\n    var root: TrieNode\n\n    init() {\n        root = TrieNode()\n    }\n\n    func insert(_ word: String) {\n        var node = root\n        for ch in word {\n            if node.children[ch] == nil {\n                node.children[ch] = TrieNode()\n            }\n            node = node.children[ch]!\n            node.preCount += 1\n        }\n        node.count += 1\n    }\n\n    func search(_ word: String) -> Bool {\n        var node = root\n        for ch in word {\n            if node.children[ch] == nil {\n                return false\n            }\n            node = node.children[ch]!\n        }\n        return node.count > 0\n    }\n\n    func startsWith(_ prefix: String) -> Bool {\n        var node = root\n        for ch in prefix {\n            if node.children[ch] == nil {\n                return false\n            }\n            node = node.children[ch]!\n        }\n        return node.preCount > 0\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/77#issuecomment-1689030759","body":"```\nclass Solution {\n\n    private var root = Node()\n\n    func multiSearch(_ big: String, _ smalls: [String]) -> [[Int]] {\n\n        let n = smalls.count\n        // 初始化结果集\n        var res = [[Int]](repeating: [], count: n)\n        // 建树\n        for i in 0..<smalls.count {\n            insert(smalls[i], i)\n        }\n\n        for i in 0..<big.count {\n            var tmp = root\n            var j = i\n            while j < big.count {\n                let char = big[big.index(big.startIndex, offsetBy: j)]\n                // 不存在以该串为prefix的敏感词\n                if tmp.children[char] == nil {\n                    break\n                }\n\n                tmp = tmp.children[char]!\n\n                if tmp.isWord {\n                    res[tmp.id].append(i)\n                }\n\n                j += 1\n            }\n        }\n        // 返回二维数组\n        var ret = [[Int]]()\n\n        for i in 0..<n {\n            ret.append(res[i])\n        }\n\n        return ret\n    }\n\n    private func insert(_ word: String, _ id: Int) {\n\n        var tmp = root\n\n        for char in word {\n            if tmp.children[char] == nil {\n                tmp.children[char] = Node()\n            }\n\n            tmp = tmp.children[char]!\n        }\n\n        tmp.isWord = true\n        tmp.id = id\n    }\n\n    class Node {\n\n        var children: [Character: Node]\n        var isWord: Bool\n        var id: Int\n\n        init() {\n            children = [:]\n            isWord = false\n            id = 0\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/78#issuecomment-1690812780","body":"```\nclass Solution {\n    func findCircleNum(_ isConnected: [[Int]]) -> Int {\n        var visited = Set<Int>()\n        var provinces = 0\n        \n        func dfs(_ i: Int) {\n            visited.insert(i)\n            for j in 0..<isConnected[i].count {\n                if !visited.contains(j) && isConnected[i][j] == 1 {\n                    dfs(j)\n                }\n            }\n        }\n        \n        for i in 0..<isConnected.count {\n            if !visited.contains(i) {\n                dfs(i)\n                provinces += 1\n            }\n        }\n        \n        return provinces\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/82#issuecomment-1694793529","body":"```\nclass Solution {\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\n        var ans = [[Int]]()\n        \n        func backtrack(_ list: inout [[Int]], _ tempList: inout [Int], _ nums: [Int], _ remain: Int, _ start: Int) {\n            if remain < 0 {\n                return\n            } else if remain == 0 {\n                list.append(tempList)\n                return\n            }\n            for i in start..<nums.count {\n                tempList.append(nums[i])\n                backtrack(&list, &tempList, nums, remain - nums[i], i)\n                tempList.removeLast()\n            }\n        }\n        \n        var tempList = [Int]()\n        backtrack(&ans, &tempList, candidates.sorted(), target, 0)\n        return ans\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/83#issuecomment-1696643877","body":"```\nclass Solution {\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\n        let lenCan = candidates.count\n        if lenCan == 0 {\n            return []\n        }\n        let sortedCandidates = candidates.sorted()\n        var path = [Int]()\n        var res = [[Int]]()\n        backtrack(sortedCandidates, target, lenCan, 0, 0, &path, &res)\n        return res\n    }\n    \n    func backtrack(_ curCandidates: [Int], _ target: Int, _ lenCan: Int, _ curSum: Int, _ indBegin: Int, _ path: inout [Int], _ res: inout [[Int]]) {\n        if curSum == target {\n            res.append(path)\n        }\n        var index = indBegin\n        while index < lenCan {\n            let nextSum = curSum + curCandidates[index]\n            if nextSum > target {\n                break\n            }\n            if index > indBegin && curCandidates[index-1] == curCandidates[index] {\n                index += 1\n                continue\n            }\n            path.append(curCandidates[index])\n            backtrack(curCandidates, target, lenCan, nextSum, index+1, &path, &res)\n            path.removeLast()\n            index += 1\n        }\n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/85#issuecomment-1699963864","body":"```\nclass Solution {\n    func strStr(_ haystack: String, _ needle: String) -> Int {\n        let lenA = haystack.count\n        let lenB = needle.count\n        \n        if lenB == 0 {\n            return 0\n        }\n        if lenB > lenA {\n            return -1\n        }\n        \n        let endIndex = haystack.index(haystack.endIndex, offsetBy: -(lenB - 1))\n        for i in 0...(lenA - lenB) {\n            let startIndex = haystack.index(haystack.startIndex, offsetBy: i)\n            let endIndex = haystack.index(startIndex, offsetBy: lenB)\n            let substring = haystack[startIndex..<endIndex]\n            if substring == needle {\n                return i\n            }\n        }\n        return -1\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/86#issuecomment-1701898254","body":"```\nclass Solution {\n    func strStr(_ haystack: String, _ needle: String) -> Int {\n        let lenA = haystack.count\n        let lenB = needle.count\n        \n        if lenB == 0 {\n            return 0\n        }\n        if lenB > lenA {\n            return -1\n        }\n        \n        let endIndex = haystack.index(haystack.endIndex, offsetBy: -(lenB - 1))\n        for i in 0...(lenA - lenB) {\n            let startIndex = haystack.index(haystack.startIndex, offsetBy: i)\n            let endIndex = haystack.index(startIndex, offsetBy: lenB)\n            let substring = haystack[startIndex..<endIndex]\n            if substring == needle {\n                return i\n            }\n        }\n        return -1\n    }\n}\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/90#issuecomment-1705770016","body":"```\nclass Solution {\n    func frequencySort(_ s: String) -> String {\n        var dict: [Character: Int] = [:]\n        \n        for ch in s {\n            dict[ch, default: 0] += 1\n        }\n        \n        let vals = dict.sorted(by: { $0.value > $1.value })\n        \n        var res = \"\"\n        \n        for (k, v) in vals {\n            res += String(repeating: k, count: v)\n        }\n        \n        return res\n    }\n}\n\n```","onTime":true},null,null,null],"mo660":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585663967","body":"## 思路\n将数组反向与数字余数相加，记录进位。处理完数组后，k与进位相加，再遍历k值，求%10以及/10，最后res数组反序\n## 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int>res;\n        int carryNum = 0;\n        for(int i = num.size() - 1; i >= 0; i--)\n        {\n            int tmpSum = num[i] + carryNum;\n            if (k)\n                tmpSum += (k%10);\n            res.push_back(tmpSum%10);\n            carryNum = tmpSum/10;\n            if (k)\n                k = k/10;\n        }\n        k += carryNum;\n        while (k)\n        {\n            res.push_back(k % 10);\n            k = k/10;\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n## 复杂度\n 时间 O(N)  \n 空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1585979534","body":"## 思路\n1. 记录每一c在s中的位置\n2. 遍历s，计算出每一个字符与c位置的最小值\n## 代码\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> coordinate;\n        for(int i = 0; i < s.length(); i++)\n        {\n            if (s[i] == c)\n            {\n                coordinate.push_back(i);\n            }\n        }\n        vector<int> res;\n        for(int i = 0; i < s.length(); i++)\n        {\n            int tmp = INT32_MAX;\n            for(auto it : coordinate)\n            {\n                tmp = min(tmp, abs(i-it));\n            }\n            res.push_back(tmp);\n        }\n        return res;\n    }\n};\n```\n## 复杂度\n 时间O(n+k) \n \n空间O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587410520","body":"## 思路\r\n使用辅助数组存储add值，**负数与容器的size比较会为false**\r\n## 代码\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        add.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top < stk.size()-1)\r\n        {\r\n            top++;\r\n            stk[top] = x;\r\n        }else\r\n        {\r\n            cout<<\"sdasda\"<<endl;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1)\r\n            return -1;\r\n        int ret = add[top] + stk[top];\r\n        if (top != 0)\r\n        {\r\n            add[top-1] += add[top];\r\n        }\r\n        add[top] = 0;\r\n        top--;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int minNum = min(k-1, top);\r\n        if (minNum >= 0)\r\n            add[minNum] += val;\r\n    }\r\nprivate:\r\n    vector<int> add;\r\n    vector<int> stk;\r\n    int top;\r\n};\r\n```\r\n## 复杂度\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589379829","body":"## 思路\n使用两个栈，一个存入string一个存入num。【】符号不需要存入栈，当遇到‘】’时，直接对string扩充倍数再拼接到string栈的top上，之后再pop两个栈\n## 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string>stks;\n        stack<int>stkn;\n        string res = \"\";\n        int num = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n            if (s[i] >= '0' && s[i] <= '9')\n            {\n                num = num*10 + (s[i] - '0');\n            }\n            else if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z'))\n            {\n                res += s[i];\n            }\n            else if (s[i] == '[')\n            {\n                stkn.push(num);\n                stks.push(res);\n                res = \"\";\n                num = 0;\n            }\n            else\n            {\n                int times = stkn.top();\n                string tmp = stks.top();\n                for (int i = 0; i < times; i++)\n                {\n                    tmp += res;\n                }\n                res = tmp;\n                stkn.pop();\n                stks.pop();\n            }\n        }\n        return res;\n    }\n};\n```\n## 复杂度\n* 时间复杂度：O(N)\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591242980","body":"## 思路\r\n双栈操作，在pop或者peek的时候出栈stk1，入栈stk2.\r\n## 代码\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        stk1.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (stk2.empty())\r\n        {\r\n            while (!stk1.empty())\r\n            {\r\n                int tmp = stk1.top();\r\n                stk2.push(tmp);\r\n                stk1.pop();\r\n            }\r\n        }\r\n        int res = stk2.top();\r\n        stk2.pop();\r\n        return res;\r\n    }\r\n    \r\n    int peek() {\r\n        if (stk2.empty())\r\n        {\r\n            while (!stk1.empty())\r\n            {\r\n                int tmp = stk1.top();\r\n                stk2.push(tmp);\r\n                stk1.pop();\r\n            }\r\n        }\r\n        int res = stk2.top();\r\n        return res;\r\n    }\r\n    \r\n    bool empty() {\r\n        return stk1.empty() && stk2.empty();\r\n    }\r\nprivate:\r\n    stack<int>stk1;\r\n    stack<int>stk2;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593101232","body":"## 思路\r\n将数组排序后，遍历数组。使用哈希表计数\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        vector sortArr = arr;\r\n        sort(sortArr.begin(), sortArr.end());\r\n        map<int, int>count;\r\n        int res;\r\n        for (int i = 0; i < arr.size(); i++)\r\n        {\r\n            int sortLast = arr[i];\r\n            int sortAfter = sortArr[i];\r\n            count[sortAfter]++;\r\n            count[sortLast]--;\r\n            if (count[sortLast] == 0)\r\n                count.erase(sortLast);\r\n            if (count[sortAfter] == 0)\r\n                count.erase(sortAfter);\r\n            if (count.empty())\r\n                res++;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594325967","body":"## 思路\r\n先遍历链表，求出size，并记录尾指针。找到链表断开的位置n = size - (k % size);断开链表，头部接到尾部后面\r\n## 代码\r\n```c++\r\nclass Solution\r\n{\r\npublic:\r\n    ListNode *rotateRight(ListNode *head, int k)\r\n    {\r\n        if (nullptr == head)\r\n            return nullptr;\r\n        int size = 0;\r\n        ListNode *tail = NULL;\r\n        for (ListNode *next = head; next != NULL; next = next->next)\r\n        {\r\n            size++;\r\n            if (next->next == nullptr)\r\n                tail = next;\r\n        }\r\n        int n = size - (k % size);\r\n        if (n == size)\r\n            return head;\r\n        ListNode *res = head;\r\n        int count = 1;\r\n        while (count != n)\r\n        {\r\n            res = res->next;\r\n            count++;\r\n        }\r\n        ListNode *tmp = res;\r\n        res = res->next;\r\n        tmp->next = nullptr;\r\n        tail->next = head;\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1597067503","body":"## 思路\r\n使用快慢指针，遍历出链表的中点，然后使用递归，遍历出每一段的中点\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if (nullptr == head) return nullptr;\r\n        ListNode* start = head;\r\n        ListNode* end = nullptr;\r\n        return dfs(start, end);\r\n    }\r\n    TreeNode* dfs(ListNode* start, ListNode* end){\r\n        if (start == end) return nullptr;\r\n        ListNode *low = start;\r\n        ListNode *fast = start;\r\n        while (end != fast && end != fast->next)\r\n        {\r\n            low = low->next;\r\n            fast = fast->next->next;\r\n        }\r\n        TreeNode *node = new TreeNode(low->val);\r\n        node->left = dfs(start, low);\r\n        node->right = dfs(low->next, end);\r\n        return node;\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1597028728","body":"## 思路\r\n双指针遍历两条链表，当指针到一条链表尾部时，换到另一条链表头部开始遍历，\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (nullptr == headA || nullptr == headB) return nullptr;\r\n        ListNode *pA = headA;\r\n        ListNode *pB = headB;\r\n        while (pA != pB)\r\n        {\r\n            pA = pA->next;\r\n            pB = pB->next;\r\n            if (nullptr == pA && nullptr == pB)\r\n                return nullptr;\r\n            if (nullptr == pA)\r\n                pA = headB;\r\n            if (nullptr == pB)\r\n                pB = headA;\r\n        }\r\n        return pA;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598887802","body":"``` c＋＋\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *slowPtr = head;\r\n        ListNode *fastPtr = head;\r\n        while(1){\r\n            if (nullptr == fastPtr || nullptr == fastPtr->next) return nullptr;\r\n            slowPtr = slowPtr->next;\r\n            fastPtr = fastPtr->next->next;\r\n            if (slowPtr == fastPtr) break;\r\n        }\r\n        fastPtr = head;\r\n        while(fastPtr != slowPtr){\r\n            slowPtr = slowPtr->next;\r\n            fastPtr = fastPtr->next;\r\n        }\r\n        return fastPtr;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605808493","body":"## 思路\r\n使用dfs遍历树，记录深度，如果当前深度大于最大深度，就舍弃之前的深度\r\n## 代码\r\n```c++\r\nstruct TreeNode {\r\n    int val;\r\n    TreeNode *left;\r\n    TreeNode *right;\r\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    int res;\r\n    int maxHeight;\r\n    void dfs(TreeNode* root, int height)\r\n    {\r\n        if (nullptr == root)\r\n            return;\r\n        height++;\r\n        dfs(root->left, height);\r\n        dfs(root->right, height);\r\n        if (height > maxHeight)\r\n        {\r\n            res = root->val;\r\n            maxHeight = height;\r\n        }\r\n    }\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        res = root->val;\r\n        dfs(root, 0);\r\n        return res;\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1606397189","body":"## 思路\r\n评论区大哥用istringstream的方法。。。\r\n## 代码\r\n```c++\r\nclass Codec {\r\npublic:\r\n\r\n    // Encodes a tree to a single string.\r\n    string serialize(TreeNode* root) {\r\n        if (nullptr == root)\r\n            return \"#\";\r\n        return to_string(root->val) + \" \" + serialize(root->left) + \" \" + serialize(root->right);\r\n    }\r\n\r\n    TreeNode* mydeserialize(istringstream &ss ){\r\n        string tmp;\r\n        ss >> tmp;\r\n        if (tmp == \"#\")\r\n            return nullptr;\r\n        TreeNode* node = new TreeNode(stoi(tmp));\r\n        node->left = mydeserialize(ss);\r\n        node->right = mydeserialize(ss);\r\n        return node;\r\n    }\r\n    // Decodes your encoded data to tree.\r\n    TreeNode* deserialize(string data) {\r\n        istringstream ss(data);\r\n        return mydeserialize(ss);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1609657642","body":"## 思路\r\n使用dfs遍历数，使用map存储输的坐标以及值，map的成员是关键，key是y坐标，val又是一个map，该map的key是x坐标，val是一个可重复的set\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    map<int, map<int, multiset<int>>> mp;\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        dfs(root, 0, 0);\r\n        vector<vector<int>> res;\r\n        for (auto& it1 : mp) {\r\n            vector<int> tmp;\r\n            for (auto& it2 : it1.second) {\r\n                for (auto val : it2.second) {\r\n                    tmp.emplace_back(val);\r\n                }\r\n            }\r\n            res.emplace_back(tmp);\r\n        }\r\n        return res;\r\n    }\r\n    void dfs(TreeNode* root, int x, int y) {\r\n        if (nullptr == root) \r\n            return;\r\n        mp[x][y].insert(root->val);\r\n        dfs(root->left, x-1, y+1);\r\n        dfs(root->right, x+1, y+1);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1610442559","body":"## 思路 \r\n哈希做法\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> twoSum(vector<int>& nums, int target) {\r\n        map<int, int>mp;\r\n        for(int i = 0; i < nums.size(); i++){\r\n            if (mp.count(target - nums[i])){\r\n                return {mp[target - nums[i]], i};\r\n            }\r\n            mp[nums[i]] = i;\r\n        }\r\n        return {};\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1613239082","body":"```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        map<int,int>mp;\r\n        for (auto &num : nums){\r\n            mp[num]++;\r\n        }\r\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\r\n        for(auto a:mp){\r\n            if(q.size() == k){\r\n                if (q.top().first<a.second){\r\n                    q.pop();\r\n                    q.push(make_pair(a.second,a.first));\r\n                }\r\n            }else{\r\n                q.push(make_pair(a.second,a.first));\r\n            }\r\n        }\r\n        vector<int> ret;\r\n        while(!q.empty()){\r\n            ret.push_back(q.top().second);\r\n            q.pop();\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1613987327","body":"## 思路\r\nA(n, 2)\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n        int res = 0;\r\n        for(auto it : points){\r\n            unordered_map<int, int> mp;\r\n            for(auto it1 : points){\r\n                int num = (it1[0] - it[0])*(it1[0] - it[0]) + (it1[1] - it[1])*(it1[1] - it[1]);\r\n                mp[num]++;\r\n            }\r\n            for(auto &p : mp){\r\n                res += p.second*(p.second-1);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615949279","body":"## 代码\r\n```c++\r\n// 暴力\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        int res = 0;\r\n        for (int i = 0; i < s.length(); i++)\r\n        {\r\n            map<char, int>mp;\r\n            int tmp = 1;\r\n            mp[s[i]]++;\r\n            for (int j = i+1; j < s.length(); j++)\r\n            {   \r\n                if (mp.count(s[j]) == 0)\r\n                {\r\n                    mp[s[j]]++;\r\n                    tmp++;\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n            res = max(tmp, res);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616672234","body":"## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> findSubstring(string s, vector<string>& words) {\r\n        unordered_map<string, int>mp;\r\n        vector<int>res;\r\n        if (words.empty())\r\n            return res;\r\n        for(auto &word : words){\r\n            mp[word]++;\r\n        }\r\n\r\n        int slen = s.length(); int m = words[0].length();int n = words.size();\r\n        for (int i = 0; i < slen - (m*n) +1; i++)\r\n        {\r\n            string strTmp = s.substr(i, m*n);\r\n            unordered_map<string, int>tmp;\r\n            int j = 0;\r\n            for (j = 0; j < m*n; j+=m)\r\n            {\r\n                string wordTmp = strTmp.substr(j, m);\r\n                if (mp.find(wordTmp) == mp.end())\r\n                    break;\r\n                tmp[wordTmp]++;\r\n                if (tmp[wordTmp] > mp[wordTmp])\r\n                    break;\r\n            }\r\n            if (j == m*n)\r\n                res.push_back(i);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1618469966","body":"```c++\r\nclass Solution {\r\npublic:\r\n    int getModulus(long a, long k){\r\n        return (a%k + k)%k;\r\n    }\r\n    int minSubarray(vector<int>& nums, int p) {\r\n        long sum = 0;\r\n        for (auto &it : nums)\r\n        {\r\n            sum += it;\r\n            sum %= p;\r\n        }\r\n        int target = getModulus(sum, p);\r\n        if (target == 0)\r\n            return 0;\r\n        int minLen = nums.size();\r\n        map<int, int>mp;\r\n        mp[0] = -1;\r\n        long preSum = 0;\r\n        for (int i = 0; i < nums.size(); i++)\r\n        {\r\n            preSum += nums[i];\r\n            int k = getModulus(preSum, p);\r\n            mp[k] = i;\r\n            if (mp.count(getModulus(preSum - target, p)))\r\n                minLen = min(minLen, i - mp[getModulus(preSum - target, p)] );\r\n        }\r\n        return minLen == nums.size() ? -1 : minLen;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1619387300","body":"## 思路\r\n快慢指针\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode* low = head;\r\n        ListNode* fast = head;\r\n        while (fast != nullptr && fast->next != nullptr)\r\n        {\r\n            low = low->next;\r\n            fast = fast->next->next;\r\n        }\r\n        return low;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1622770681","body":"```c++\r\nclass Solution {\r\npublic:\r\n    int searchInsert(vector<int>& nums, int target) {\r\n        int len = nums.size();\r\n        int l = 0, r = len - 1;\r\n        while (l <= r)\r\n        {\r\n            int mid = (r - l)/2 + l;\r\n            if(nums[mid] >= target){\r\n                r = mid - 1;\r\n            }else{\r\n                l = mid + 1;\r\n            }\r\n        }\r\n        return l;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1625498743","body":"## 思路\r\n使用map从大到小的排序，一个个添加与移除\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    struct Compare {\r\n        bool operator()(const int& a, const int& b) const {\r\n            return a > b;\r\n        }\r\n    };\r\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n        map<int, int , Compare>mp;\r\n        int l = 0, r = 0;\r\n        int len = nums.size();\r\n        for (int r = 0; r < k; r++)\r\n        {\r\n            mp[nums[r]]++;\r\n        }\r\n        vector<int> res;\r\n        res.push_back(mp.begin()->first);\r\n        for (int r = k; r < len; r++)\r\n        {\r\n            mp[nums[r]]++;\r\n            mp[nums[l]]--;\r\n            if (0 == mp[l])\r\n                mp.erase(nums[l]);\r\n            l++;\r\n            res.push_back(mp.begin()->first);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1626409160","body":"## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int findJudge(int n, vector<vector<int>>& trust) {\r\n        vector<int> inDo(n+1);\r\n        vector<int> outDo(n+1);\r\n        for(auto &it : trust){\r\n            inDo[it[1]]++;\r\n            outDo[it[0]]++;\r\n        }\r\n        for (int i = 1; i <= n; i++)\r\n        {\r\n            if(inDo[i] == n-1 && outDo[i] == 0)\r\n                return i;\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1629942249","body":"## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    bool judgeCircle(string moves) {\r\n        int sLen = moves.length();\r\n        pair<int, int> coordinate(0, 0);\r\n        for (int i = 0; i < sLen; i++)\r\n        {\r\n            switch (moves[i])\r\n            {\r\n            case 'L':\r\n                coordinate.second -= 1;\r\n                break;\r\n            case 'R':\r\n                coordinate.second += 1;\r\n                break;\r\n            case 'U':\r\n                coordinate.first += 1;\r\n                break;\r\n            case 'D':\r\n                coordinate.first -= 1;\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n        }\r\n        if (0 == coordinate.first && 0 == coordinate.second)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1634400133","body":"## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int numberOfRounds(string loginTime, string logoutTime) {\r\n        int start = 60 * stoi(loginTime.substr(0,2)) + stoi(loginTime.substr(3,5));\r\n        int end = 60 * stoi(logoutTime.substr(0,2)) + stoi(logoutTime.substr(3,5));\r\n        int res = 0;\r\n        if (start > end)\r\n            end += 60*24;\r\n        end = end/15 *15;\r\n        res = (end - start)/15;\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635662194","body":"## 思路\r\n前缀和、后缀和\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int minCharacters(string a, string b) {\r\n        vector<int>bufA(26, 0);\r\n        vector<int>bufB(26, 0);\r\n        for (auto &t : a) bufA[t-'a']++;\r\n        for (auto &t : b) bufB[t-'a']++;\r\n        int lenA = a.length(), lenB = b.length();\r\n        int maxN = INT_MAX, sumA = 0, sumB = 0;\r\n        for (int i = 0; i < 25; i++)\r\n        {\r\n            sumA += bufA[i];\r\n            sumB += bufB[i];\r\n            maxN = min(min(maxN, lenA+lenB-bufA[i]-bufB[i]), min(lenA - sumA + sumB, lenB - sumB + sumA));\r\n        }\r\n        maxN = min(maxN, lenA+lenB-bufA[25]-bufB[25]);\r\n        return maxN;\r\n    }\r\n};\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637261026","body":"```c++\r\nclass Solution {\r\npublic:\r\n    int firstBadVersion(int n) {\r\n        int l = 1;\r\n        int r = n;\r\n        while(l < r){\r\n            int mid = l + (r - l)/2;\r\n            if (isBadVersion(mid)){\r\n                r = mid;\r\n            }else {\r\n                l = mid + 1;\r\n            }\r\n        }\r\n        return l ;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/44#issuecomment-1645407590","body":"```c++\r\nclass Solution {\r\npublic:\r\n    bool check(vector<vector<int>>& grid, int threshold) {\r\n        if (grid[0][0] > threshold) {\r\n            return false;\r\n        }\r\n        int n = grid.size();\r\n        vector<vector<int>> visited(n, vector<int>(n, 0));\r\n        visited[0][0] = 1;\r\n        queue<pair<int, int>> q;\r\n        q.push(make_pair(0, 0));\r\n\r\n        vector<pair<int, int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\r\n        while (!q.empty()) {\r\n            auto [i, j] = q.front();\r\n            q.pop();\r\n\r\n            for (const auto [di, dj]: directions) {\r\n                int ni = i + di, nj = j + dj;\r\n                if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\r\n                    if (visited[ni][nj] == 0 && grid[ni][nj] <= threshold) {\r\n                        q.push(make_pair(ni, nj));\r\n                        visited[ni][nj] = 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return visited[n - 1][n - 1] == 1;\r\n    }\r\n\r\n    int swimInWater(vector<vector<int>>& grid) {\r\n        int n = grid.size();\r\n        int left = 0, right = n * n - 1;\r\n        while (left < right) {\r\n            int mid = (left + right) / 2;\r\n            if (check(grid, mid)) {\r\n                right = mid;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        } \r\n        return left;\r\n    }\r\n};\r\n\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/48#issuecomment-1649802037","body":"```c++\r\nclass Solution {\r\npublic:\r\n    string minWindow(string s, string t) {\r\n        unordered_map<char, int> hs, ht;\r\n        for (auto c: t) ht[c] ++ ;\r\n        string res;\r\n        int cnt = 0;\r\n        for (int i = 0, j = 0; i < s.size(); i ++ ) {\r\n            hs[s[i]] ++ ;\r\n            if (hs[s[i]] <= ht[s[i]]) cnt ++ ;\r\n\r\n            while (hs[s[j]] > ht[s[j]]) hs[s[j ++ ]] -- ;\r\n            if (cnt == t.size()) {\r\n                if (res.empty() || i - j + 1 < res.size())\r\n                    res = s.substr(j, i - j + 1);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/51#issuecomment-1654835835","body":"```c++\r\nclass Solution {\r\npublic:\r\n    int totalNQueens(int n) {\r\n        dfs(n, 0, 0, 0, 0);\r\n        \r\n        return this->res;\r\n    }\r\n    \r\n    void dfs(int n, int row, int col, int ld, int rd) {\r\n        if (row >= n) { res++; return; }\r\n        \r\n        // 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历\r\n        int bits = ~(col | ld | rd) & ((1 << n) - 1);\r\n        while (bits > 0) {\r\n            int pick = bits & -bits; // 注: x & -x\r\n            dfs(n, row + 1, col | pick, (ld | pick) << 1, (rd | pick) >> 1);\r\n            bits &= bits - 1; // 注: x & (x - 1)\r\n        }\r\n    }\r\n\r\nprivate:\r\n    int res = 0;\r\n};\r\n\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/57#issuecomment-1663166978","body":"```c++\r\nclass Solution {\r\npublic:\r\n    int rob(vector<int>& nums) {\r\n    int prev = 0;\r\n    int curr = 0;\r\n\r\n    // 每次循环，计算“偷到当前房子为止的最大金额”\r\n    for (int i : nums) {\r\n        // 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]\r\n        // dp[k] = max{ dp[k-1], dp[k-2] + i }\r\n        int temp = max(curr, prev + i);\r\n        prev = curr;\r\n        curr = temp;\r\n        // 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]\r\n    }\r\n\r\n    return curr;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/63#issuecomment-1671359309","body":"```c++\r\nclass Solution {\r\npublic:\r\n    bool canPartition(vector<int>& nums) {\r\n        int sum = 0;\r\n        int size = nums.size();\r\n        for(auto i : nums){\r\n            sum += i;\r\n        }\r\n        if (size < 2)\r\n            return false;\r\n        int target = 0;\r\n        if (sum % 2)\r\n            return false;\r\n        else\r\n            target = sum/2;\r\n        int maxNum = *max_element(nums.begin(), nums.end());\r\n        if (maxNum > target) {\r\n            return false;\r\n        }\r\n        vector<vector<int>> dp(size, vector<int>(target + 1, 0));\r\n        for (int i = 0; i < size; i++)\r\n        {\r\n            dp[i][0] = true;\r\n        }\r\n        dp[0][nums[0]] = true;\r\n        for (int i = 1; i < size; i++)\r\n        {\r\n            for (int j = 1; j < target+1; j++)\r\n            {\r\n                if (j >= nums[i])\r\n                {\r\n                    dp[i][j] = dp[i-1][j] | dp[i-1][j-nums[i]];\r\n                }\r\n                else\r\n                {\r\n                    dp[i][j] = dp[i-1][j];\r\n                }\r\n            }\r\n        }\r\n        return dp[size-1][target];\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sencc":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585681518","body":"思路\n将数字列表 num 转换为数字字符串，再将数字与k相加，最后返回一个列表\n\n代码\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        list_str = \"\".join(str(x) for x in num)\n        number = int(list_str)+k\n        return [int(x) for x in str(number)]\n\n复杂度\n空间复杂度O(n)\n时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586217778","body":"代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        e_indexes = []\n        res = []\n\n        for i in range(len(s)):\n            if s[i] == c:\n                e_indexes.append(i)\n        \n        for i in range(len(s)):\n            index = min([abs(i-e) for e in e_indexes])\n            res.append(index)\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587568343","body":"思路:使用一个列表来存储栈中的元素\n\n代码:\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n\n空间复杂度：O(1)\n时间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589564762","body":"思路：使用栈的思路\n\n代码：\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        multiplier = 0\n        current_str = ''\n\n        for c in s:\n            if c.isdigit():\n                multiplier = multiplier * 10 + int(c)\n            elif c.isalpha():\n                current_str += c\n            elif c == '[':\n                stack.append((multiplier, current_str))\n                multiplier = 0\n                current_str = ''\n            elif c == ']':\n                prev_multiplier, prev_str = stack.pop()\n                current_str = prev_str + prev_multiplier * current_str\n\n        return current_str\n\n时间复杂度为 O(n)，n 是字符串的长度\n\n空间复杂度为O(m)，m是栈的最大深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591466850","body":"思路：\n  使用两个栈，一个作为输入栈stack1，用于push操作；另一个作为输出栈stack2，用于pop和peek操作\n\n代码：\n\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []  # 输入栈，用于push操作\n        self.stack2 = []  # 输出栈，用于pop和peek操作\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not self.stack1 and not self.stack2\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593269577","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        count = 0\n        max_val = 0\n        for i, val in enumerate(arr):\n            max_val = max(max_val, val)\n            if i == max_val:\n                count += 1\n                max_val = i + 1\n        return count\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594887182","body":"代码：\n\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        # 获取链表长度\n        n = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            n += 1\n        \n        # 首尾相连形成闭环\n        curr.next = head\n        \n        # 计算实际需要旋转的次数\n        k %= n\n        \n        # 找到新的头、尾指针\n        tail = head\n        for i in range(n - k - 1):\n            tail = tail.next\n        new_head = tail.next\n        \n        # 断开环状链表\n        tail.next = None\n        \n        return new_head\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596185512","body":"代码：\n\nclass Solution:\n\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        nums = []\n        while head:\n            nums.append(head.val)\n            head = head.next\n        \n        def build_bst(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = build_bst(left, mid - 1)\n            root.right = build_bst(mid + 1, right)\n            return root\n        \n        return build_bst(0, len(nums) - 1)\n\n时间复杂度O(nlogn)，空间复杂度O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"randong22":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585692846","body":"## 解题思路\n\n整体思路还是逐位计算，麻烦的点在于使用原地算法完成，时间复杂度为 max(n.length, k的位数)中较大的一个，具体细节写在代码注释中，关键点在于如何不重置k对k进行计算和处理\n\n## 代码\n```typescript\nvar addToArrayForm = function (num: number[], k: number) {\n  let add = false; // 存储当前位数计算结果是否超过 10,需要进位\n  let i = 1; // 存储当前循环到的位数\n  let l = num.length; // 存储 num 的长度,后续用的时候方便点\n  while (10 ** (i - 1) <= k || add) {\n    // 截止条件为 k 遍历完成10 ** (i - 1) <= k 例如当k === 9的时候 10 ** (1 - 1) <= 9 证明还需要一次,10 ** (2 - 1) > 9 就证明遍历完成了,的同时进位也处理完成\n    let ki = ~~((k % 10 ** i) / 10 ** (i - 1)) + (add ? 1 : 0); // 计算当前 k 的值是多少, k % 10 ** i去除超过当前位数的,例如 134 计算第二位 = 134 % 10 ** 2 = 34,  / 10 ** (i - 1) 去除小于当前为的,例如 34 / 10 ** (2 - 1) = 3.4, ~~(3.4) = 3 这样即可获取当前数字第二位为 3这如果不想这么麻烦可以每次重置 k 的值,向下去除一位取整即可, add 为上一次计算是够有进位\n    let numi = num[l - i] ?? 0; // 存储当前 num 的位数上是什么,由于可能有 k 的总长度 > num 的长度的情况,这需要做 undefined 判断\n    let tari = numi + ki; // 计算当前位数的和\n    if (tari >= 10) {\n      // 如果当前位数和超过 10 了,更改 add 状态, 更改当前位置和的值\n      add = true;\n      tari -= 10;\n    } else {\n      add = false;\n    }\n    if (i === l + 1) {\n      // 如果当前位数已经超过 num 了,要像 num 之前 push,否则直接原地更改 num 即可\n      num.unshift(tari);\n      l = num.length;\n    } else {\n      num[l - i] = tari;\n    }\n    i++;\n  }\n  return num;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586184291","body":"## 解题思路\r\n\r\n先获取到对应的字母位于数组中的所有下标idxs\r\n重新遍历 s，从idxs[0]和idxs[1]开始，用 last 和next存储当前对比的下标， idx 存储当前对比的索引，用当前下标对比，取 i - index[0] 和 i - index[1]的绝对值中较小的一个放入结果中\r\n当i === next的时候， 重置last, next ,idx\r\n\r\n## 代码\r\n```typescript\r\nvar shortestToChar = function (s: string, c: string) {\r\n  let idxs = [];\r\n  let final = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      idxs.push(i);\r\n    }\r\n  }\r\n  idxs.push(999999999999);\r\n  let last = idxs[0];\r\n  let next = idxs[1];\r\n  let idx = 1;\r\n  for (let i = 0; i < s.length; i++) {\r\n    final.push(Math.min(Math.abs(last - i), next - i));\r\n    if (i === next) {\r\n      idx++;\r\n      last = next;\r\n      next = idxs[idx];\r\n    }\r\n  }\r\n  return final;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586621378","body":"## 思路\r\n1. pop方法对栈的长度为0时，返回-1；\r\n2. push方法对栈的长度为maxSize时，不进行push；\r\n3. increment方法对序号小于指定值的元素进行操作，循环时筛选；\r\n## 代码\r\n```typescript\r\nclass CustomStack {\r\n  private arr: number[] = [];\r\n  private maxSize: number;\r\n  constructor(maxSize: number) {\r\n    this.maxSize = maxSize;\r\n  }\r\n\r\n  push(x: number): void {\r\n    if (this.arr.length < this.maxSize) {\r\n      thiincreas.arr.push(x);\r\n    }\r\n  }\r\n\r\n  pop(): number {\r\n    if (this.arr.length > 0) {\r\n      return this.arr.pop()!;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  increment(k: number, val: number): void {\r\n    this.arr.forEach((_val, index) => {\r\n      if (index < k) {\r\n        this.arr[index] = val + _val;\r\n      }\r\n    });\r\n  }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589373166","body":"# 394. decode-string\r\n\r\n## 前置知识\r\n\r\n- 栈\r\n- 括号匹配\r\n\r\n## 思路\r\n\r\n遍历输入字符串，遇到数字则更新当前数字，遇到字母则加入当前字符串，遇到左括号则把当前数字和字符串入栈并重置当前数字和字符串，遇到右括号则出栈并解码字符串。\r\n\r\n## 代码\r\n\r\n```typescript\r\nfunction decodeString(s: string): string {\r\n  const stack: [number, string][] = [];\r\n  let currStr = \"\";\r\n  let currNum = 0;\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    const char = s[i];\r\n    if (/\\d/.test(char)) {\r\n      // 如果是数字，更新当前数字\r\n      currNum = currNum * 10 + Number(char);\r\n    } else if (char === \"[\") {\r\n      // 如果是左括号，把当前数字和字符串入栈，重置当前数字和字符串\r\n      stack.push([currNum, currStr]);\r\n      currNum = 0;\r\n      currStr = \"\";\r\n    } else if (char === \"]\") {\r\n      // 如果是右括号，出栈并解码字符串\r\n      const [num, prevStr] = stack.pop()!;\r\n      currStr = prevStr + currStr.repeat(num);\r\n    } else {\r\n      // 如果是字母，加入当前字符串\r\n      currStr += char;\r\n    }\r\n  }\r\n  return currStr;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591309880","body":"# 232\r\n\r\n## 前置知识\r\n\r\n栈\r\n\r\n## 思路\r\n\r\nts里通过api实现即可\r\n\r\n## 代码(typescript)\r\n\r\n```typescript\r\nclass MyQueue {\r\n  private arr: any[];\r\n  constructor() {\r\n    this.arr = [];\r\n  }\r\n\r\n  push(x: number): void {\r\n    this.arr.push(x);\r\n  }\r\n\r\n  pop(): number {\r\n    return this.arr.shift();\r\n  }\r\n\r\n  peek(): number {\r\n    return this.arr[0];\r\n  }\r\n\r\n  empty(): boolean {\r\n    return this.arr.length === 0;\r\n  }\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592404449","body":"# 768\r\n\r\n## 前置知识\r\n\r\n双指针\r\n\r\n## 思路\r\n\r\n从左到右依次遍历，同时满足以下条件即可分块：\r\n\r\n1. 双指针的范围内最大值，不大于下一个值\r\n2. 双指针的范围内最大值，不大于后续范围内的最小值\r\n\r\n## 代码\r\n\r\n```typescript\r\nfunction maxChunksToSorted(arr: number[]): number {\r\n  let count = 1,\r\n    i = 0,\r\n    j = 1,\r\n    max = arr[i];\r\n  while (j < arr.length) {\r\n    const rMin = Math.min(...arr.slice(j));\r\n    if (max > arr[j] || max > rMin) {\r\n      max = Math.max(max, arr[j]);\r\n      j++;\r\n    } else {\r\n      i = j++;\r\n      max = arr[i];\r\n      count++;\r\n    }\r\n  }\r\n  return count;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n^2)\r\n空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594603111","body":"# 61\r\n\r\n## 前置知识\r\n\r\n数组，链表\r\n\r\n## 思路\r\n\r\n第一次遍历链表，给出长度，并成环\r\n第二次遍历链表，指定节点断开\r\n\r\n## 代码(Typescript)\r\n\r\n```typescript\r\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\r\n  if (head === null) {\r\n    return null;\r\n  }\r\n  let count = 1,\r\n    tail = head;\r\n  while (tail.next !== null) {\r\n    count++;\r\n    tail = tail.next;\r\n  }\r\n  k = k % count;\r\n  if (k === 0) {\r\n    return head;\r\n  }\r\n  let newTail = head;\r\n  for (let i = 0; i < count - k - 1; i++) {\r\n    newTail = newTail.next!;\r\n  }\r\n  const newHead = newTail.next!;\r\n  tail.next = head;\r\n  newTail.next = null;\r\n  return newHead;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595785751","body":"typescript\r\n```typescript\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     val: number\r\n *     next: ListNode | null\r\n *     constructor(val?: number, next?: ListNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.next = (next===undefined ? null : next)\r\n *     }\r\n * }\r\n */\r\n\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n  let node = new ListNode();\r\n  let cur = node;\r\n  node.next = head;\r\n  while (cur?.next?.next) {\r\n    let _node = cur.next;\r\n    let left = _node;\r\n    let right = _node.next;\r\n    left.next = right!.next;\r\n    right!.next = left;\r\n    cur.next = right;\r\n    cur = left;\r\n  }\r\n  return node.next;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596187228","body":"```typescript\r\nvar sortedListToBST = function(head) {\r\n    let child = head;\r\n    const arr = [];\r\n    while(child) {\r\n        arr.push(child.val);\r\n        child = child.next;\r\n    }\r\n    function buildTree(arr, left, right) {\r\n        if(left > right) return null;\r\n        if(left === right) return new TreeNode(arr[left]);\r\n        else if (right - left === 1) {\r\n            let r = new TreeNode(arr[right]);\r\n            r.left = new TreeNode(arr[left]);\r\n            return r;\r\n        }\r\n        let mid = (left + right + 1) >> 1;\r\n        let root = new TreeNode(arr[mid])\r\n        root.left = buildTree(arr, left, mid - 1);\r\n        root.right = buildTree(arr, mid + 1, right);\r\n        return root;\r\n    }\r\n    return buildTree(arr, 0, arr.length - 1);\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1597292702","body":"```typescript\r\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\r\n    if (headA === null || headB === null) return null;\r\n\r\n    let pA = headA, pB = headB;\r\n\r\n    while (pA !== pB) {\r\n        pA = pA === null ? headB : pA.next; // 链表A循环结束就循环链表B \r\n        pB = pB === null ? headA : pB.next; // 链表B循环结束就循环链表A \r\n    }\r\n\r\n    return pA; // 当pA == pB时就是交点\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598103701","body":"typescript\r\n```typescript\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     val: number\r\n *     next: ListNode | null\r\n *     constructor(val?: number, next?: ListNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.next = (next===undefined ? null : next)\r\n *     }\r\n * }\r\n */\r\n\r\nfunction detectCycle(head: ListNode | null): ListNode | null {\r\n  const retNode = new ListNode();\r\n  retNode.next = head;\r\n  let front = retNode,\r\n    end = retNode;\r\n  while (end && end.next) {\r\n    front = front.next!;\r\n    end = end.next?.next!;\r\n    if (front === end) {\r\n      break;\r\n    }\r\n  }\r\n  if (!end || !end.next) {\r\n    return null;\r\n  }\r\n  front = retNode;\r\n  while (front !== end) {\r\n    front = front.next!;\r\n    end = end.next!;\r\n  }\r\n  return end;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1601017850","body":"//链表节点的定义\r\nclass ListNode {\r\n  constructor(key, value) {\r\n    this.key = key;\r\n    this.value = value;\r\n    this.pre = null;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nclass LRUCache {\r\n  constructor(capacity) {\r\n    this.capacity = capacity; //容量\r\n    this.nodeCnt = 0;\r\n    this.cache = {};\r\n    this.dummyHead = new ListNode();\r\n    this.dummyTail = new ListNode();\r\n    this.dummyHead.next = this.dummyTail;\r\n    this.dummyTail.pre = this.dummyHead;\r\n  }\r\n  put(key, value) {\r\n    //当前节点在cache里\r\n    if (this.cache[key]) {\r\n      this.cache[key].value = value;\r\n      //移动到队头：先删，然后插入头部\r\n      //1.在双向链表中删除该节点\r\n      this.cache[key].next.pre = this.cache[key].pre;\r\n      this.cache[key].pre.next = this.cache[key].next;\r\n      //2.添加到队头\r\n      this.cache[key].pre = this.dummyHead;\r\n      this.cache[key].next = this.dummyHead.next;\r\n      this.dummyHead.next.pre = this.cache[key];\r\n      this.dummyHead.next = this.cache[key];\r\n    } else {\r\n      const newNode = new ListNode(key, value);\r\n      this.cache[key] = newNode;\r\n      //添加到队头\r\n      newNode.pre = this.dummyHead;\r\n      newNode.next = this.dummyHead.next;\r\n      this.dummyHead.next.pre = newNode;\r\n      this.dummyHead.next = newNode;\r\n      //判断是否需要删除节点\r\n      this.nodeCnt++;\r\n      if (this.nodeCnt > this.capacity) {\r\n        const tail = this.dummyTail.pre;\r\n        const pre = tail.pre,\r\n          next = tail.next;\r\n        pre.next = next;\r\n        next.pre = pre;\r\n        delete this.cache[tail.key];\r\n        this.nodeCnt--;\r\n      }\r\n    }\r\n  }\r\n  get(key) {\r\n    if (this.cache[key]) {\r\n      //移动到队头：先删，然后插入头部\r\n      //1.在双向链表中删除该节点\r\n      this.cache[key].next.pre = this.cache[key].pre;\r\n      this.cache[key].pre.next = this.cache[key].next;\r\n      //2.添加到队头\r\n      this.cache[key].pre = this.dummyHead;\r\n      this.cache[key].next = this.dummyHead.next;\r\n      this.dummyHead.next.pre = this.cache[key];\r\n      this.dummyHead.next = this.cache[key];\r\n      return this.cache[key].value;\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602024801","body":"/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    if(!root) {\r\n        return 0;\r\n    } else {\r\n        const left = maxDepth(root.left);\r\n        const right = maxDepth(root.right);\r\n        return Math.max(left, right) + 1;\r\n    }\r\n};\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1603388737","body":"```typescript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n    if(p == null && q == null) \r\n        return true;\r\n    if(p == null || q == null) \r\n        return false;\r\n    if(p.val != q.val) \r\n        return false;\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1608716284","body":"```typescript\r\n\r\nfunction sumNumbers(root: TreeNode | null, sum = 0): number {\r\n  const isLeaf = (node: TreeNode) => !node?.left && !node?.right\r\n  if (!root || isLeaf(root)) {\r\n    return sum * 10 + root?.val || 0\r\n  }\r\n  return sumNumbers(root.left, sum * 10 + root.val) + sumNumbers(root.right, sum * 10 + root.val)\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1606051701","body":"```javascript\r\nvar findBottomLeftValue = function(root) {\r\n    const dfs = (root, height) => {\r\n        if (!root) {\r\n            return;\r\n        }\r\n        height++;\r\n        dfs(root.left, height);\r\n        dfs(root.right, height);\r\n        if (height > curHeight) {\r\n            curHeight = height;\r\n            curVal = root.val;\r\n        }\r\n    }\r\n\r\n    let curHeight = 0;\r\n    dfs(root, 0);\r\n    return curVal;\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607393182","body":"```typescript\r\nfunction serialize(root: TreeNode | null): string {\r\n  if (root == null) {\r\n    // 遍历到 null 节点\r\n    return \"#\";\r\n  }\r\n  const left = serialize(root.left); // 左子树的序列化结果\r\n  const right = serialize(root.right); // 右子树的序列化结果\r\n  return root.val + \",\" + left + \",\" + right; // 按  根,左,右  拼接字符串\r\n}\r\n\r\nfunction deserialize(data: string): TreeNode | null {\r\n  const list = data.split(\",\"); // split成数组\r\n\r\n  const buildTree = (list: any[]) => {\r\n    // 基于list构建当前子树\r\n    const node = list.shift(); // 弹出首项，获取它的“数据”\r\n    if (node == \"#\") {\r\n      // 是#，返回null节点\r\n      return null;\r\n    }\r\n    const root = new TreeNode(node); // 不是#，则创建节点\r\n    root.left = buildTree(list); // 递归构建左子树\r\n    root.right = buildTree(list); // 递归构建右子树\r\n    return root; // 返回当前构建好的root\r\n  };\r\n\r\n  return buildTree(list); // 构建的入口\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1608710617","body":"```typescript\r\nfunction verticalTraversal(root: TreeNode | null): number[][] {\r\n  if (!root) return [];\r\n\r\n  const map = { \"0\": [[1, root.val]] };\r\n\r\n  const dfs = (node: TreeNode | null, cur: number, level: number) => {\r\n    if (!node) return;\r\n    if (!map[cur]) {\r\n      map[cur] = [];\r\n    }\r\n    map[cur].push([level, node.val]);\r\n    dfs(node.left, cur - 1, level + 1);\r\n    dfs(node.right, cur + 1, level + 1);\r\n  };\r\n\r\n  dfs(root.left, -1, 2);\r\n  dfs(root.right, 1, 2);\r\n\r\n  return Object.keys(map)\r\n    .map((key) => parseInt(key))\r\n    .sort((a, b) => a - b)\r\n    .map((key) =>\r\n      map[key]\r\n        .sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]))\r\n        .map((item) => item[1])\r\n    );\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1610913792","body":"```typescript\r\nfunction twoSum(nums: number[], target: number): number[] {\r\n  const map = new Map();\r\n  for (let i = 0; i < nums.length; i++) {\r\n    if (map.has(target - nums[i])) {\r\n      return [i, map.get(target - nums[i])];\r\n    }\r\n    map.set(nums[i], i);\r\n  }\r\n  return [];\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1613292029","body":"```typescript\r\nfunction topKFrequent(nums: number[], k: number): number[] {\r\n  // 统计每个元素的频率\r\n  const freqMap: { [key: number]: number } = {};\r\n  for (const num of nums) {\r\n    freqMap[num] = (freqMap[num] || 0) + 1;\r\n  }\r\n\r\n  // 创建一个最小堆\r\n  const heap: [number, number][] = [];\r\n  for (const num in freqMap) {\r\n    heap.push([parseInt(num), freqMap[num]]);\r\n    if (heap.length > k) {\r\n      // 删除堆顶元素（频率最小的元素）\r\n      heap.sort((a, b) => a[1] - b[1]);\r\n      heap.shift();\r\n    }\r\n  }\r\n\r\n  // 返回堆中的元素\r\n  return heap.map((item) => item[0]);\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614704768","body":"```typescript\r\nfunction numberOfBoomerangs(points: number[][]): number {\r\n    let res = 0;\r\n    for (let i = 0; i < points.length; i++) {\r\n        const map = new Map();\r\n        for (let j = 0; j < points.length; j++) {\r\n            if (i === j) continue;\r\n            const hypotenuse =\r\n                Math.pow(points[i][0] - points[j][0], 2) +\r\n                Math.pow(points[i][1] - points[j][1], 2);\r\n            map.set(hypotenuse, (map.get(hypotenuse) ?? 0) + 1);\r\n        }\r\n        for (let count of map.values()) {\r\n            res += count * (count - 1)\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beginner-jamji":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585694528","body":"思路\n使用逐位相加的思路解决，同时考虑A和K的长度比较\n\n代码\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        n = len(A)\n        ans = []\n\n        for i in range(n-1, -1, -1):\n            total = A[i] + K % 10\n\n            K //= 10\n            \n            if total >= 10:\n                #当前位相加结果大于 10 时，进位 1 加入下一位计算\n                K += 1\n\n            ans.append(total % 10)\n            \n        # 这里考虑数组 A 的长度小于整数 K 位数个数的情况\n        while K > 0:\n            ans.append(K % 10)\n            K //= 10\n        # 因为添加进来是由低位往高位，输出时进行逆序输出\n        return ans[::-1]\n\n复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586192759","body":"思路\n首先应该获取到该字符在字符串 s 中的所有下标位置，遍历一次字符串，并将等于目标字符的下标添加至动态数组arr中，使用指针比较下标间的最短距离。\n\n代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res, p, arr = [], 0, [i for i in range(len(s)) if s[i] == c]\n        for i, j in enumerate(s):\n            if p < len(arr) - 1 and abs(arr[p] - i) > abs(arr[p + 1] - i):\n                p += 1\n            res.append(abs(arr[p] - i))\n        return res\n\n复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587511888","body":"思路\n创建两个数组stack和nums 添加一个指针p\n\n代码\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.stack = [0] * maxSize\n        self.nums = [0] * maxSize\n        self.size = maxSize - 1\n        self.p = -1\n\n    def push(self, x: int):\n        if self.p != self.size:\n            self.p += 1\n            self.stack[self.p] = x\n\n    def pop(self):\n        if self.p == -1:\n            return -1\n        x, val = self.stack[self.p], self.nums[self.p]\n        self.nums[self.p] = 0\n        self.p -= 1\n        if self.p != -1:\n            self.nums[self.p] += val\n        return x + val\n\n    def increment(self, k: int, val: int):\n        if self.p >= 0:\n            k = min(self.p, k - 1)\n            self.nums[k] += val\n\n复杂度\n时间复杂度O(1)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589095858","body":"思路\n遍历给定字符串，遇到非 ] 入栈\n\n代码\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in s:\n            if i == ']':\n                strs = ''\n                repeat = ''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop() + repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n\n复杂度\n时间复杂度O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591366307","body":"思路\n队列是一种先入先出的数据结构，而栈是一种后入先出的数据结构，所以一个栈绝对满足不了队列的特性，因此这里需要两个栈，分别是输入栈和输出栈：输入栈来反转元素的入队顺序，元素入只能从输入栈进。输出栈用来存储元素的正常顺序，元素出只能从输出栈出。\n\n代码\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        # 初始化输入栈和输出栈\n        self.inStack = []\n        self.outStack = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        # 有新元素进来，进入输入栈\n        self.inStack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        # 如果为空\n        if self.empty():\n            return None\n\n        # 如果输出栈不为空，返回输出栈中的元素\n        if self.outStack:\n            return self.outStack.pop()\n        # 输出栈为空,将输入栈的元素压入输出栈\n        else:\n            while self.inStack:\n                val = self.inStack.pop()\n                self.outStack.append(val)\n            return self.outStack.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        # 使用已有的函数 pop\n        res = self.pop()\n        # pop 函数弹出了 res，所以要再添加回去\n        self.outStack.append(res)\n\n        return res\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        # 两个栈都为空，队列才为空\n        if not(self.inStack or self.outStack):\n            return True\n\n        return False\n\n复杂度\n时间空间均为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593124261","body":"思路\n分割点的左边与右边各自排序后依然是升序的，每一次割点以及左边的最大值小于等于右边数组的最小值\n\n代码\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        n = len(arr)\n        # 生成后缀的最小值\n        post = [arr[-1]]\n        for i in range(n-2, -1, -1):\n            post.append(min(post[-1], arr[i]))\n        post = post[::-1]\n\n        # 从前往后判断割点\n        ans = 0\n        pre = float('-inf')\n        for i in range(n):\n            pre = max(pre, arr[i])\n            if i+1 < n and pre <= post[i+1]:\n                ans += 1\n                pre = float('-inf')\n        ans += 1\n        return ans\n\n复杂度\n时间空间均为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594845895","body":"思路\n求链表长度 找出倒数第 k+1k+1k+1 个节点 将链表的倒数第 k+1k+1k+1 个节点和倒数第 kkk 个节点断开，并把后半部分拼接到链表的头部\n\n代码\nclass Solution:\n    def rotateRight(self, head, k):\n        if not head or not head.next: return head\n        # 求链表长度\n        _len = 0\n        cur = head\n        while cur:\n            _len += 1\n            cur = cur.next\n        # 对长度取模\n        k %= _len\n        if k == 0: return head\n        # 让 fast 先向后走 k 步\n        fast, slow = head, head\n        while k:\n            fast = fast.next\n            k -= 1\n        # 此时 slow 和 fast 之间的距离是 k；fast 指向第 k+1 个节点\n        # 当 fast.next 为空时，fast 指向链表最后一个节点，slow 指向倒数第 k + 1 个节点\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        # newHead 是倒数第 k 个节点，即新链表的头\n        newHead = slow.next\n        # 让倒数第 k + 1 个节点 和 倒数第 k 个节点断开\n        slow.next = None\n        # 让最后一个节点指向原始链表的头\n        fast.next = head\n        return newHead\n\n复杂度\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yzhyzhyzh123":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585695141","body":"# 思路\n将k和num全都转化为num数组，倒叙排列后逐位相加，逐位相加后如果超过9了说明需要进位，将进位符置1，如不满则为0，将保留各位后的数字添加进结果数组。\n依次相加后直到某个长度更短的数组全部遍历完后结束相加过程。\n最后将数组倒序回来就可以得到最终的结果\n\n# 代码\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        // 1. 从后往前逐位相加\n        for(int i = n - 1; i >= 0; i--){\n            // 逐位相加\n            int sum = num[i] + k % 10;         \n            k /= 10;    \n            // 两位相加 进位\n            if(sum >= 10){\n                k++;                        // 进位到k的末尾\n                sum -= 10;                  // 进位清掉\n            }\n            // 1.2 当前相加的结果 添加到结果集\n            res.add(sum);\n        }\n\n        // 2. k的数字长度大于数组的数字长度\n        for(; k > 0; k /= 10){               \n            res.add(k % 10);               \n        }\n\n        // 3. 结果集翻转\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n# 复杂度\n时间复杂度为O(n)\n空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586168087","body":"# 思路\n分别从前往后，从后往前遍历，取这两个中较小的一个就是答案最近的距离。\n# 代码\n~~~\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int index = -len;\n        // 从左往右，第一次遍历记录下s[i]左边最近的一个c字符\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                index = i;\n            }\n            res[i] = i - index;\n        }\n        index =  len  * 2;\n        // 第二次遍历记录下s[i]右边最近的一个c字符，从右向左\n        // 取这两个中较小的一个，这就是距离c字符最近的\n        for (int i = len - 1; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                index = i;\n            }\n            res[i] = Math.min(res[i], index - i);\n        }\n        return res;\n    }\n}\n~~~\n# 复杂度\n时间复杂度：O(n)，需要遍历两次字符串的所有字符。\n空间复杂度：O(1)，只需常数的空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587609342","body":"# 思路\n push ，判断当前元素的个数是否达到上限，如果没有达到，就把 top 后移一个位置并添加一个元素。\npop ，判断当前栈是否为空，非空返回栈顶元素并将 top 前移一位，否则返回 -1.\ninc ，直接对栈底的最多 k 个元素加上 val。\n\n# 代码\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n# 复杂度\n\n时间复杂度：O(1)\n\n空间复杂度：O(n)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589562002","body":"# 思路\n定义两个栈，一个栈numstack用来存放数字，一个栈restack用来存放字符。\n# 代码\n~~~\nclass Solution {\n    public String decodeString(String s) {\n        //定义两个栈用来存放倍数和字符\n        Deque<Integer> numstack = new ArrayDeque<>();\n        Deque<StringBuilder> restack = new ArrayDeque<>();\n        //拼接数字\n        int num = 0;\n        //存放结果\n        StringBuilder res = new StringBuilder();\n\n        for(char c : s.toCharArray()){\n            //遇到数字就压入数字栈\n            if(c >= '0' && c <= '9'){\n                //取出连续的数字\n                num = num * 10 + c - '0';\n            }else if(c == '['){\n                //遇到左括号\n                //将上次计算出的数字压栈\n                numstack.addLast(num);\n                //将上一次的倍数后的结果字符存入字符栈\n                restack.addLast(res);\n                //重置数字和结果\n                num = 0;\n                res = new StringBuilder();\n            }else if(c == ']'){\n                StringBuilder temp = new StringBuilder();\n                //获取倍数\n                int count = numstack.pollLast();\n                //进行循环当前字符,拼接到上一次结果中\n                for(int i = 0; i < count; i++){\n                   temp.append(res);\n                }\n                //与括号外的合并\n                res = restack.pollLast().append(temp);\n            }else{\n                res.append(c);\n            }\n        }\n        return res.toString();\n    }\n}\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591354671","body":"# 思路\n两个栈，一个栈输入栈，一个栈输出栈。\n# 代码\n~~~\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if (outStack.isEmpty()) {\n            while (!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if (outStack.isEmpty()) {\n             while (!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593298909","body":"# 代码\n~~~\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(head);\n            }\n            else {\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}\n~~~\n#  复杂度\n时间复杂度 O(N) \n空间复杂度 O(N) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594904985","body":"# 思路\n遍历整个链表，求出链表的长度n，并找出链表的尾节点tail，再次从头节点head开始遍历，找到第n - k个节点p，那么1 ~ p是链表的前 n - k个节点，p+1 ~ n是链表的后k个节点，依次执行 tail->next = head，head = p->next，p->next = nullptr，将链表的后k个节点和前 n - k个节点拼接到一块，并让head指向新的头节点(p->next)，新的尾节点即p节点的next指针指向null。\n最后返回链表的新的头节点head。\n# 代码\n~~~\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null|| k == 0)  \n             return head;\n        int n = 0;\t\t\t   //链表的长度\n        ListNode tail = null;  //尾节点\n        for(ListNode p = head; p != null ; p = p.next){\n            tail = p;\n            n++;\n        }\n        k %= n;\n        ListNode p = head;\n        for(int i = 0; i < n - k - 1; i++)  \n             p = p.next;   //找到链表的第n-k个节点\n        tail.next = head;\n        head = p.next;\n        p.next = null;\n        return head;  //返回新的头节点\n    }\n}\n~~~\n# 复杂度\n时间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1594930619","body":"# 代码\n~~~\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode pre = new ListNode(0);\n        pre.next = head;\n        ListNode temp = pre;\n        while(temp.next != null && temp.next.next != null) {\n            ListNode start = temp.next;\n            ListNode end = temp.next.next;\n            temp.next = end;\n            start.next = end.next;\n            end.next = start;\n            temp = start;\n        }\n        return pre.next;\n    }\n}\n~~~\n# 复杂度\n时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596190754","body":"# 代码\n~~~\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        List<Integer> nums = new ArrayList<>();\n        while(head != null){\n            nums.add(head.val);\n            head = head.next;\n        }\n        TreeNode root = toBST(nums, 0, nums.size() - 1);\n        return root;\n    }\n    public TreeNode toBST(List<Integer> nums, int be, int ed){\n        if(be > ed) return null;\n        TreeNode root = new TreeNode(nums.get(be + (ed - be) / 2));\n        root.left = toBST(nums, be, be + (ed - be) / 2 - 1);\n        root.right = toBST(nums, be + (ed - be) / 2 + 1, ed);\n        return root;\n    }\n}\n~~~\n# 复杂度分析\n时间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1597406054","body":"~~~\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n        while (a != b) {\n            if (a != null) {\n                a = a.next;\n            }\n            else {\n                a = headB;\n            }\n            if (b != null) {\n                b = b.next;\n            } else {\n                b = headA;\n            }\n        }\n        return a;\n    }\n}\n~~~\n# 复杂度分析\n时间复杂度 O(N)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598996916","body":"# 思路\n快慢指针\n# 代码\n~~~\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n            if (fast == slow) {\n                ListNode ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n}\n~~~\n# 复杂度\n时间复杂度O(n)\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600636759","body":"~~~\npublic class LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > capacity) {\n                DLinkedNode tail = removeTail();\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n        else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n~~~\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602779333","body":"# 思路\n分别求出左子树和右子树的最大深度，二叉树的最大深度等于max（左子树最大深度，右子树最大深度）+ 1。\n# 代码\n~~~\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        int childMaxDepth = Math.max(left, right);\n        return childMaxDepth + 1;\n    }\n}\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604381190","body":"# 代码\n~~~\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null || q == null) {\n            return false;\n        } else if (p.val != q.val) {\n            return false;\n        } else {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n\n    }\n}\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605578711","body":"# 思路\nDFS\n# 代码\n~~~\nclass Solution {\n    public int res;\n    public int sumNumbers(TreeNode root) {\n        dfs (root, 0);\n        return res;\n    }\n\n    public void dfs (TreeNode root, int last) {\n        if (root == null) {\n            return;\n        }\n        if (root.left == null && root.right == null) {\n            res += last * 10 + root.val;\n            return;\n        }\n        dfs(root.left, last * 10 + root.val);\n        dfs(root.right, last * 10 + root.val);\n    }\n}\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1606127198","body":"# 代码\n~~~\nclass Solution {\n    int curVal = 0;\n    int curHeight = 0;\n    public int findBottomLeftValue(TreeNode root) {\n        int curHeight = 0;\n        dfs(root, 0);\n        return curVal;\n    }\n\n    public void dfs (TreeNode root, int height) {\n        if (root == null) {\n            return;\n        }\n        height++;\n        dfs(root.left, height);\n        dfs(root.right, height);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n    }\n}\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607739803","body":"# 代码\n~~~\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1609755715","body":"# 代码\n~~~\nclass Solution {\n    PriorityQueue<int[]> q = new PriorityQueue<>((a, b)->{ // col, row, val\n        if (a[0] != b[0]) return a[0] - b[0];\n        if (a[1] != b[1]) return a[1] - b[1];\n        return a[2] - b[2];\n    });\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        int[] info = new int[]{0, 0, root.val};\n        q.add(info);\n        dfs(root, info);\n        List<List<Integer>> ans = new ArrayList<>();\n        while (!q.isEmpty()) {\n            List<Integer> tmp = new ArrayList<>();\n            int[] poll = q.peek();\n            while (!q.isEmpty() && q.peek()[0] == poll[0]) tmp.add(q.poll()[2]);\n            ans.add(tmp);\n        }\n        return ans;\n    }\n    void dfs(TreeNode root, int[] fa) {\n        if (root.left != null) {\n            int[] linfo = new int[]{fa[0] - 1, fa[1] + 1, root.left.val};\n            q.add(linfo);\n            dfs(root.left, linfo);\n        }\n        if (root.right != null) {\n            int[] rinfo = new int[]{fa[0] + 1, fa[1] + 1, root.right.val};\n            q.add(rinfo);\n            dfs(root.right, rinfo);\n        }\n    }\n}\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1611600524","body":"# 代码\n~~~\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // for (int i = 0; i < nums.length; i++) {\n        //     for ( int  j = i + 1; j < nums.length; j++) {\n        //         if (nums[i] + nums[j] == target) {\n        //             return new int [] {i, j};\n        //         }\n        //     }\n        // }\n        // return new int  [0];\n\n        // 2. 哈希\n        Map<Integer, Integer> hashTable = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; i++ ) {\n            if (hashTable.containsKey(target - nums[i])){\n                return new int [] {hashTable.get(target - nums[i]), i};\n            }\n            hashTable.put(nums[i], i);\n        }\n        return new int[0];\n    }\n}\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1613337971","body":"#  代码\n快速排序\n~~~\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\n        }\n\n        List<int[]> values = new ArrayList<int[]>();\n        for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            values.add(new int[]{num, count});\n        }\n        int[] ret = new int[k];\n        qsort(values, 0, values.size() - 1, ret, 0, k);\n        return ret;\n    }\n\n    public void qsort(List<int[]> values, int start, int end, int[] ret, int retIndex, int k) {\n        int picked = (int) (Math.random() * (end - start + 1)) + start;\n        Collections.swap(values, picked, start);\n        \n        int pivot = values.get(start)[1];\n        int index = start;\n        for (int i = start + 1; i <= end; i++) {\n            if (values.get(i)[1] >= pivot) {\n                Collections.swap(values, index + 1, i);\n                index++;\n            }\n        }\n        Collections.swap(values, start, index);\n\n        if (k <= index - start) {\n            qsort(values, start, index - 1, ret, retIndex, k);\n        } else {\n            for (int i = start; i <= index; i++) {\n                ret[retIndex++] = values.get(i)[0];\n            }\n            if (k > index - start + 1) {\n                qsort(values, index + 1, end, ret, retIndex, k - (index - start + 1));\n            }\n        }\n    }\n}\n~~~","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1618775882","body":"# 代码\n~~~\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n        int x = 0;\n        for (int num : nums) {\n            x = (x + num) % p;\n        }\n        if (x == 0) {\n            return 0;\n        }\n        Map<Integer, Integer> index = new HashMap<Integer, Integer>();\n        int y = 0, res = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            index.put(y, i);    // f[i] mod p = y，因此哈希表记录 y 对应的下标为 i\n            y = (y + nums[i]) % p;\n            if (index.containsKey((y - x + p) % p)) {\n                res = Math.min(res, i - index.get((y - x + p) % p) + 1);\n            }\n        }\n        return res == nums.length ? -1 : res;\n    }\n}\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1620465968","body":"# 思路\n快慢指针\n# 代码\n~~~\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head; \n        ListNode slow = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1622040178","body":"# 代码\n~~~\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        // 双指针，\n        int n = nums.length;\n        int fast = 1;\n        int slow = 1;\n        while (fast < n) {\n            if (nums[fast -1] != nums[fast]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n            fast++;\n            \n        }\n        return slow ;\n    }\n}\n\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1623909231","body":"~~~\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if (nums.length == 0) return -1;\n\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left <= right) {\n\n            int mid = left + (right - left) / 2;\n            if (target > nums[mid]) {\n                left = mid + 1;\n            } else if (target < nums[mid]) {\n                right = mid - 1;\n            } else if (target == nums[mid]){\n                return mid;\n            }\n        }\n\n        return left;\n    }\n}\n~~~","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1627381705","body":"~~~\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[][] map = new int[n][2];\n        for (int[] node : trust) {\n            map[]\n        }\n        for (int i = 0; i < n; i++) {\n            if (out[i] == 0 && in[i] == (n-1)){\n                return i+1;\n            }\n        }\n        return -1;\n    }\n}\n~~~","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1631078874","body":"~~~\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x =0; int y =0;\n        for (int i = 0; i < moves.length(); i++) {\n            if (moves.charAt(i) == 'R')\n                x++;\n            if (moves.charAt(i) == 'L')\n                x--;\n            if (moves.charAt(i) == 'U')\n                y++;\n            if (moves.charAt(i) == 'D')\n                y--;\n        }\n        return x == 0 && y == 0;\n    }\n}\n~~~","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1636807857","body":"~~~\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        randomizedQuicksort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    public void randomizedQuicksort(int[] nums, int l, int r) {\n        if (l < r) {\n            int pos = randomizedPartition(nums, l, r);\n            randomizedQuicksort(nums, l, pos - 1);\n            randomizedQuicksort(nums, pos + 1, r);\n        }\n    }\n\n    public int randomizedPartition(int[] nums, int l, int r) {\n        int i = new Random().nextInt(r - l + 1) + l; // 随机选一个作为我们的主元\n        swap(nums, r, i);\n        return partition(nums, l, r);\n    }\n\n    public int partition(int[] nums, int l, int r) {\n        int pivot = nums[r];\n        int i = l - 1;\n        for (int j = l; j <= r - 1; ++j) {\n            if (nums[j] <= pivot) {\n                i = i + 1;\n                swap(nums, i, j);\n            }\n        }\n        swap(nums, i + 1, r);\n        return i + 1;\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n~~~","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/44#issuecomment-1645731341","body":"~~~\nclass Solution {\n    int[][] dirs = new int[][]{{1,0}, {-1,0}, {0,1}, {0,-1}};\n    public int swimInWater(int[][] grid) {\n        int n = grid.length;\n        int l = 0, r = n * n;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (check(grid, mid)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return r;\n    }\n    boolean check(int[][] grid, int time) {\n        int n = grid.length;\n        boolean[][] visited = new boolean[n][n];\n        Deque<int[]> queue = new ArrayDeque<>();\n        queue.addLast(new int[]{0, 0});\n        visited[0][0] = true;\n        while (!queue.isEmpty()) {\n            int[] pos = queue.pollFirst();\n            int x = pos[0], y = pos[1];\n            if (x == n - 1 && y == n - 1) return true;\n\n            for (int[] dir : dirs) {\n                int newX = x + dir[0], newY = y + dir[1];\n                int[] to = new int[]{newX, newY};\n                if (inArea(n, newX, newY) && !visited[newX][newY] && canMove(grid, pos, to, time)) {\n                    visited[newX][newY] = true;\n                    queue.addLast(to);\n                }\n            }\n        }\n        return false;\n    }\n    boolean inArea(int n, int x, int y) {\n        return x >= 0 && x < n && y >= 0 && y < n;\n    }\n    boolean canMove(int[][] grid, int[] from, int[] to, int time) {\n        return time >= Math.max(grid[from[0]][from[1]], grid[to[0]][to[1]]);\n    }\n}\n~~~","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/46#issuecomment-1646867958","body":"~~~\nclass Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0) {\n            return 1.0;\n        }\n        double[] dp = new double[k + maxPts];\n        for (int i = k; i <= n && i < k + maxPts; i++) {\n            dp[i] = 1.0;\n        }\n        for (int i = k - 1; i >= 0; i--) {\n            for (int j = 1; j <= maxPts; j++) {\n                dp[i] += dp[i + j] / maxPts;\n            }\n        }\n        return dp[0];\n    }\n}\n~~~","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunstrongchina":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585695458","body":"思路：\r\n先将列表转化为整数，加起来，然后再将最终结果展开为列表\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        ##对k进行展开\r\n        num_val = 0\r\n        for i in range(1,len(num)+1):\r\n            num_val += num[-i] * (10 ** (i-1))\r\n        num_val += k\r\n        ex_vals = []\r\n        while num_val > 9:\r\n            v1 = num_val % 10\r\n            ex_vals= [v1] + ex_vals\r\n            num_val -= v1\r\n            num_val  = num_val // 10\r\n        ex_vals = [num_val] + ex_vals\r\n        return ex_vals\r\n```\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586194079","body":"思路：先找到c字符所在的位置，然后遍历字符数据（不是离左边近就是离右边近），两个一比较取最近\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ##先找到c的1位置\r\n        indexs = []\r\n        for i,s1 in enumerate(s):\r\n            if s1 == c:\r\n                indexs.append(i)\r\n        result = []\r\n        i = 0\r\n        for j in range(len(indexs)):\r\n            while i <= indexs[j]:\r\n                if j-1 >=0:\r\n                    minDis = abs(indexs[j] -i)\r\n                    if i -indexs[j-1] < minDis:\r\n                        minDis = i -indexs[j-1]\r\n                else:\r\n                    minDis = abs(indexs[j] - i)\r\n                result.append(minDis)\r\n                i +=1\r\n        while i < len(s):\r\n            result.append(i - indexs[-1])\r\n            i += 1\r\n        return result\r\n```\r\n时间复杂度：o(n)\r\n空间复杂度: o(n)            \r\n        \r\n\r\n            ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589496599","body":"##思路\n遇到']'就开始退栈，然后退到'['时就弹出之前的数字字符，这样就完成了一个字符串[]的decode操作\n···python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        strlist = []\n        i = 0\n        while i < len(s):\n            if len(strlist) > 0:\n                if (strlist[-1] >= 'a' and s[i] >= 'a') or (strlist[-1] <= '9' and s[i] <= '9'):\n                    strlist[-1] += s[i]\n                else:\n                    strlist.append(s[i])\n            else:\n                strlist.append(s[i])\n            if strlist[-1] == ']':\n                ####先把]给退栈了\n                strlist.pop()\n                ####开始退栈\n                str1 = ''\n                while strlist[-1] != '[':\n                    str1 = strlist.pop() + str1\n                ###将[弹出来\n                strlist.pop()\n                num1 = int(strlist.pop())\n                strlist.append(str1 * num1)\n            i += 1\n        return ''.join(strlist)\n···\n时间复杂度：O(n+k*c)\n空间复杂度：O(n)\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591492871","body":"### 思路\r\n一个栈用来支持插入元素，如果要弹出元素的时候，就用另一个输出栈就接住插入栈的元素\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.list1 = []\r\n        self.list2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.list1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        self.peek()\r\n        return self.list2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.list2:\r\n            while self.list1:\r\n                self.list2.append(self.list1.pop())\r\n        return self.list2[-1]\r\n    def empty(self) -> bool:\r\n        return not self.list1 and not self.list2\r\n```\r\n时间复杂度：插入O(1)，弹出O(n）\r\n空间复杂度：O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596182996","body":"##思路\n不断地找中值作为根节点，左右节点分段寻找\n```python\ndef constructTree(head,tail):\n    if head == tail:\n        return None\n    fast = head\n    slow = head\n    while fast != tail and fast.next != tail:\n        fast = fast.next.next\n        slow = slow.next\n    root = TreeNode(slow.val)\n    root.left = constructTree(head,slow)\n    root.right = constructTree(slow.next,tail)\n    return root\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if head is None:\n            return head\n        return constructTree(head,None)\n```\n##时间复杂度O(nlogn)\n##空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1597346245","body":"##思路\n解法一：\n将A链表的node存储到字典到，列表B的node如果在字典里，就算是相交了\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        ##list1\n        list1 = {}\n        while headA:\n            list1[headA] = headA.val\n            headA = headA.next\n        \n        while headB:\n            val1 = headB.val\n            if headB in list1:  \n                return headB\n            else:\n                headB = headB.next\n        return None\n```\n##时间复杂度：O(n)\n##空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598829909","body":"##思路\n将每一个节点存入到字典中，如果某个节点再次出现时，就是环开始的地方\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dict1 = {}\n        i = 0\n        while head:\n            i = 0 \n            if head in dict1.keys():\n                return head\n            else:\n                dict1[head] =  i\n            i += 1\n            head = head.next\n        return head\n```\n##时间复杂度O(n)\n##空间复杂度O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604438209","body":"#思路\n递归解法\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p is None and q is None:\n            return True\n        else:\n            if p is not None and q is not None:\n                if p.val == q.val:\n                    return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n                else:\n                    return False\n            else:\n                return False\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1606136827","body":"#思路，BFS\n```python\nclass Solution:\n    def __init__(self):\n        self.res = 0 \n        self.max_level = 0\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        self.res = root.val\n        def dfs(root,level1):\n            if not root:\n                return\n            if level1 > self.max_level:\n                self.res = root.val\n                self.max_level = level1\n            dfs(root.left,level1 + 1)\n            dfs(root.right,level1 + 1)\n        dfs(root,0)\n        return self.res\n```\n#时间复杂度:O(n)\n#空间复杂度:O(h)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614724573","body":"#思路：字典存储，键是距离，值是点的序号，\n#判断相交：[1,2] [0,2] set([1,2]+[0,2])的长度小于4\n```python\nfrom collections import defaultdict\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        def calcuDis(point1,point2):\n            dis = (point1[0]-point2[0])**2 + (point1[1]-point2[1])**2\n            return dis\n        dict1 = defaultdict(list)\n        num = 0\n        for i in range(len(points)-1):\n            for j in range(i+1,len(points)):\n                distance = calcuDis(points[i],points[j])\n                #####判断有多少个相交的set\n                for list1 in dict1[distance]:\n                    ####如果相交小于4,就找到一对\n                    if len(set([i,j] + list1)) < 4:\n                        num += 2\n                dict1[distance].append([i,j])\n        return num\n```\n时间复杂度:O(n*(n-1)/2*k),k为同距离的平均点数 \n空间复杂度:O(n)           \n        \n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615412130","body":"# 思路\n双指正，一个forward负责向前开拓，一个shrink负责收缩，当出现重复字符时，进行收缩\n```python\nfrom collections import defaultdict\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        shrink = 0\n        forward = 0\n        max_len = 0\n        rangeStr = defaultdict(int)\n        while forward < len(s):\n            if rangeStr[s[forward]] == 0:\n                rangeStr[s[forward]] = 1\n            else:\n                while rangeStr[s[forward]]== 1 :\n                    ##开始收缩\n                    rangeStr[s[shrink]] -= 1\n                    if rangeStr[s[shrink]] == 0:\n                        del rangeStr[s[shrink]]\n                    shrink += 1\n                rangeStr[s[forward]] = 1\n            max_len = max(max_len,len(rangeStr))\n            forward += 1\n        return max_len\n```\n时间复杂度：O(n）\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dongzegithub":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585696197","body":"  ```java\n public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1;\n        int carry = 0;\n        int sum = 0;\n        while (i >= 0 || k > 0) {\n            int n = i >= 0 ? num[i] : 0;\n            int m = k > 0 ? k % 10 : 0;\n            k = k/10;\n            i--;\n\n            sum = n + m + carry;\n            carry = sum / 10;\n            res.add(sum % 10);\n        }\n        if (carry != 0) {\n            res.add(carry);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595789444","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        // pre.next总是指向待交换节点的前一个\n        ListNode pre = dummy;\n\n        while ((head != null) && (head.next != null)) {\n            ListNode first = head;\n            ListNode second = first.next;\n            // 交换节点\n            pre.next = second;\n            first.next = second.next;\n            second.next = first;\n            // pre后移\n            pre = first;\n            head = first.next;\n        }\n        return dummy.next;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605313275","body":"```java\nclass Solution {\n    int res = 0;\n    public int sumNumbers(TreeNode root) {\n        dfs(root,0);\n        return res;\n    }\n    public void dfs(TreeNode root, int pre){\n        if(root == null) return;\n        pre = pre*10 + root.val;\n        if(root.left == null && root.right == null){\n            res += pre;\n            return;\n        }\n        if(root.left !=null){\n            dfs(root.left, pre);\n        }\n\n        if(root.right != null){\n            dfs(root.right, pre);\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615941897","body":"```java\npublic int lengthOfLongestSubstring(String s) {\n\n    int left = 0;\n    int maxLen = 0;\n    Set<Character> set = new HashSet<>();\n\n    for (int i = 0; i < s.length(); i++) {\n\n        if (!set.add(s.charAt(i))) {\n            \n            maxLen = Math.max(maxLen, set.size());\n            while (s.charAt(left) != s.charAt(i)) {\n\n                set.remove(s.charAt(left));\n                left++;\n            }\n\n            left += 1;\n        }\n    }\n\n    return Math.max(maxLen, set.size());\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1627384533","body":"```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[][] map = new int[n][2];\n        for (int[] node : trust) {\n            map[]\n        }\n        for (int i = 0; i < n; i++) {\n            if (out[i] == 0 && in[i] == (n-1)){\n                return i+1;\n            }\n        }\n        return -1;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"metsystem":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585710301","body":"  public int AddToArrayForm(int[] num, int k) {\n\t\t int result = k;\n      \n            for (int i = 0; i > num.Length; i++) {\n              result = result + num[i] * Math.Pow(10,num.Length-i);\n            }\n\n           \n\n            return result;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586182364","body":"using System;\nusing System.Collections.Generic;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tConsole.WriteLine(\"Hello World\");\n\t\tstring  S = \"loveleetcode\";\n\t\tchar C = 'e';\n\t \tint [] result = get(S,C);\n\t\t  for(int i =0 ;i<result.Length;i++){\n              Console.WriteLine(result[i]+\",\");\n            }\n\t}\n\t\n\tpublic static int[] get(string s, char c){\n\t\t    List<int>  cList = new List<int>();\n            for(int i =0 ;i<s.Length;i++){\n                if(s[i]== c){ cList.Add(i); }\n            }\n            int[] result = new int[s.Length];\n\t\t\tfor(int j = 0 ;j<s.Length;j++){\n\t\t\t\tif(s[j] == c){\n\t\t\t\t\tresult[j]= 0;\n\t\t\t\t}else{\n\t\t\t\t\tint cI = 0;\n\t\t\t\t\tint mI = 0;\n\t\t\t\t\tfor(int k = 0 ;k<cList.Count;k++){\n\t\t\t\t\t\tif(cList[k]>j){\n\t\t\t\t\t\t\tcI =cList[k] -j;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcI = j -cList[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(mI== 0  || cI<mI){\n\t\t\t\t\t\t\tmI\t= cI ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t\tresult[j]=mI;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\n            return result;\n\t\t}\n\t}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587205037","body":"```csharp\r\npublic class Program\r\n{\r\n    public static void Main()\r\n    {\r\n        CustomStack customStack = new CustomStack(3); // 栈是空的 []\r\n        customStack.Push(1); // 栈变为 [1]\r\n        customStack.Push(2); // 栈变为 [1, 2]\r\n        customStack.Pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\n        customStack.Push(2); // 栈变为 [1, 2]\r\n        customStack.Push(3); // 栈变为 [1, 2, 3]\r\n        customStack.Push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\n        customStack.Increment(5, 100); // 栈变为 [101, 102, 103]\r\n        customStack.Increment(2, 100); // 栈变为 [201, 202, 103]\r\n        customStack.Pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\n        customStack.Pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\n        customStack.Pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []\r\n        customStack.pop(); \r\n    }\r\n}\r\n\r\npublic class CunstomStack\r\n{\r\n    private int[] data;\r\n    private int maxSize;\r\n    private int top;\r\n    public CunstomStack(int maxSize)\r\n    {\r\n        this.data = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n    }\r\n\r\n    public void Push(int x)\r\n    {\r\n        if (top < maxSize)\r\n        {\r\n            top = top++;\r\n            data[top] = x;\r\n        }\r\n    }\r\n\r\n    public int Pop()\r\n    {\r\n        int result = -1;\r\n        if (top > 0)\r\n        {\r\n            result = data[top];\r\n            data[top] = null;\r\n            top = top - 1;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n\r\n    public void Increment(int k, int val)\r\n    {\r\n        int result = k - 1;\r\n        if (result > maxSize)\r\n        {\r\n            result = maxSize;\r\n        }\r\n\r\n        for (int i = 0; i < result; i++)\r\n        {\r\n            data[i] = data[i] + val;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589527267","body":"public static string DecodeString(string s) {\n    Stack<int> numStack = new Stack<int>();\n    Stack<string> strStack = new Stack<string>();\n    string result = \"\";\n    int num = 0;\n    for (int i = 0; i < s.Length; i++) {\n        char c = s[i];\n        if (char.IsDigit(c)) {\n            num = num * 10 + (c - '0');\n        } else if (c == '[') {\n            numStack.Push(num);\n            strStack.Push(result);\n            result = \"\";\n            num = 0;\n        } else if (c == ']') {\n            int count = numStack.Pop();\n            StringBuilder sb = new StringBuilder(strStack.Pop());\n            for (int j = 0; j < count; j++) {\n                sb.Append(result);\n            }\n            result = sb.ToString();\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591532650","body":"public class MyQueue {\n    private Stack<int> stack1;\n    private Stack<int> stack2;\n\n  \n    public MyQueue() {\n        stack1 = new Stack<int>();\n        stack2 = new Stack<int>();\n    }\n    \n\n    public void Push(int x) {\n        stack1.Push(x);\n    }\n\n    public int Pop() {\n        if (stack2.Count == 0) {\n            while (stack1.Count > 0) {\n                stack2.Push(stack1.Pop());\n            }\n        }\n        return stack2.Pop();\n    }\n    \n\n    public int Peek() {\n        if (stack2.Count == 0) {\n            while (stack1.Count > 0) {\n                stack2.Push(stack1.Pop());\n            }\n        }\n        return stack2.Peek();    \n    }\n    \n\n    public bool Empty() {\n        return stack1.Count == 0 && stack2.Count == 0;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592955936","body":"public class Solution {\n    public int[] AddToArrayForm(int[] A, int K) {\n        int n = A.Length;\n        List<int> ans = new List<int>();\n        int i = n - 1, carry = 0;\n        while (i >= 0 || K != 0 || carry != 0) {\n            int x = i >= 0 ? A[i] : 0;\n            int y = K % 10, sum = x + y + carry;\n            ans.Add(sum % 10);\n            carry = sum / 10;\n            i--;\n            K /= 10;\n        }\n        ans.Reverse();\n        return ans.ToArray();\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595749885","body":"public class Solution {\n    public ListNode SwapPairs(ListNode head) { \n        var headNode = new ListNode(0,head);\n        var pre = headNode;\n        while (pre.next != null && pre.next.next != null){\n            var cur = pre.next;\n            var next = cur.next; \n\n            pre.next = next;\n            cur.next = next.next;\n            next.next=cur;\n            pre = cur;\n        \n        } \n\n        return headNode.next;\n    }\n\n    \n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1597332065","body":"public class Solution {\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA, pB = headB;\n        \n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        \n        return pA;\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1606068550","body":"```c#\r\npublic int FindBottomLeftValue(TreeNode root) {\r\n    Queue<TreeNode> queue = new Queue<TreeNode>();\r\n    queue.Enqueue(root);\r\n    int res = 0;\r\n    while (queue.Count > 0) {\r\n        int size = queue.Count;\r\n        for (int i = 0; i < size; i++) {\r\n            TreeNode node = queue.Dequeue();\r\n            if (i == 0) { // 记录每层最左边的节点\r\n                res = node.val;\r\n            }\r\n            if (node.right != null) {\r\n                queue.Enqueue(node.right);\r\n            }\r\n            if (node.left != null) {\r\n                queue.Enqueue(node.left);\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miller-em":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585714496","body":"# 思路\n直接在数组最后的元素进行相加，将k得到最后一位数，放在数组的末尾， 再取高位，从num的末尾指针从后到前，得到原数组相加\n\n# 代码\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k:\n                num.insert(0,0)\n                i = 0\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586095681","body":"# 思路 \n首先记录每一个目标字符的位置，然后再对s字符串进行遍历，对每个位置计算目标字符的位置的绝对值，找出最小的那个。\n\n# 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        e_indexes = []\n        res = []\n\n        # 记录每一个e的位置\n        for i in range(len(s)):\n            if s[i] == c:\n                e_indexes.append(i)\n        \n        # 计算每一个位置跟目标的距离\n        for i in range(len(s)):\n            index = min([abs(i-e) for e in e_indexes])\n            res.append(index)\n        return res\n```\n# 复杂度\n时间复杂度 O(N^2)\n空间复杂度 O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587515216","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.st = []\n\n    def push(self, x: int) -> None:\n        if len(self.st) < self.maxSize:\n            self.st.append(x)\n\n    def pop(self) -> int:\n        num = -1\n        if len(self.st) > 0:\n            num = self.st.pop()\n        return num\n\n    def increment(self, k: int, val: int) -> None:\n        if k >= len(self.st):\n            self.st = [i+val for i in self.st]\n        else:\n            for i in range(k):\n                self.st[i] = self.st[i]+val\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592305348","body":"l## 思路\n能够实现题述功能的小子块必须和全部排好序的数组的局部数组内的元素的出现频次是一样的。因此考虑使用哈希表记录频次。\n\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        cnt = Counter()\n        res = 0\n\n        for x, y in zip(arr, sorted):\n            cnt[x] += 1\n            if cnt[x] == 0:\n                del cnt[x]\n            cnt[y] -= 1\n            if cnt[y] == 0:\n                del cnt[y]\n            if len(cnt) == 0:\n                res += 1\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594617865","body":"```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k==0 or not head or not head.next:\n            return head\n        \n        # 计算表长度\n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        # 如果移动过后刚刚好等于原来的链表则不需要移动\n        if (add := n - k%n) == 0:\n            return head\n\n        # 闭合成环\n        cur.next = head\n        while add:\n            add -= 1\n            cur = cur.next\n        ret = cur.next\n        cur.next = None\n        return ret\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorian-byte":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585823446","body":"**思路：**\n\n给定一个整数数组num和一个非负整数k，将k加到数组num的表示形式上，返回相加后的新数组。\n我们可以从数组num的最后一位开始，将k的个位数与num的最后一位相加，并记录进位。然后依次将k的十位数、百位数等与num的前一位相加，并考虑进位。如果num已经遍历完而k还有剩余位数，可以将剩余的位数与进位相加。最后，将剩余的进位加入结果数组中。\n\n**代码：**\n```python\ndef addToArrayForm(num, k):\n    kstr = list(map(int, str(k)))  # 将k转换为整数数组\n    res = []  # 结果数组\n    carry = 0  # 进位\n    while kstr or num or carry:\n        kp = kstr.pop() if kstr else 0  # 获取k的当前位数，若已经遍历完则为0\n        np = num.pop() if num else 0  # 获取num的当前位数，若已经遍历完则为0\n        mod = (kp + np + carry) % 10  # 当前位数相加并考虑进位后的结果\n        carry = (kp + np + carry) // 10  # 计算进位\n        res.insert(0, mod)  # 将当前位数的结果插入到结果数组的最前面\n    return res\n```\n\n**复杂度分析：**\n\n时间复杂度：假设num的长度为n，k的位数为m，则时间复杂度为O(max(n, m))，需要遍历num和k的位数。\n空间复杂度：除了返回的结果数组外，额外使用了kstr、res和carry这些辅助变量，空间复杂度为O(max(n, m))。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1585817921","body":"**思路：**\r\n\r\n给定一个整数数组num和一个非负整数k，将k加到数组num的表示形式上，返回相加后的新数组。\r\n我们可以从数组num的最后一位开始，将k的个位数与num的最后一位相加，并记录进位。然后依次将k的十位数、百位数等与num的前一位相加，并考虑进位。如果num已经遍历完而k还有剩余位数，可以将剩余的位数与进位相加。最后，将剩余的进位加入结果数组中。\r\n\r\n**代码：**\r\n```python\r\ndef addToArrayForm(num, k):\r\n    kstr = list(map(int, str(k)))  # 将k转换为整数数组\r\n    res = []  # 结果数组\r\n    carry = 0  # 进位\r\n    while kstr or num or carry:\r\n        kp = kstr.pop() if kstr else 0  # 获取k的当前位数，若已经遍历完则为0\r\n        np = num.pop() if num else 0  # 获取num的当前位数，若已经遍历完则为0\r\n        mod = (kp + np + carry) % 10  # 当前位数相加并考虑进位后的结果\r\n        carry = (kp + np + carry) // 10  # 计算进位\r\n        res.insert(0, mod)  # 将当前位数的结果插入到结果数组的最前面\r\n    return res\r\n```\r\n\r\n**复杂度分析：**\r\n\r\n时间复杂度：假设num的长度为n，k的位数为m，则时间复杂度为O(max(n, m))，需要遍历num和k的位数。\r\n空间复杂度：除了返回的结果数组外，额外使用了kstr、res和carry这些辅助变量，空间复杂度为O(max(n, m))。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1592006786","body":"**思路：**\n\n该代码实现了一个自定义栈的类CustomStack，具有以下方法：\n\n__init__(self, maxSize: int)：初始化方法，用于设置栈的最大大小maxSize，并创建一个空的栈stack和一个与栈同样大小的增量数组incrementals。\npush(self, x: int)：将元素x压入栈中，如果栈未满，则将元素添加到stack中，并在incrementals中添加一个初始值为0的增量。\npop(self)：从栈中弹出一个元素，并返回其值。如果栈为空，则返回-1。如果栈的大小大于1，则将倒数第二个增量值与最后一个增量值相加，并更新增量数组和栈的大小。\nincrement(self, k: int, val: int)：将栈的后k个元素的增量值增加val。如果k大于栈的大小，则只更新栈的大小范围内的元素的增量值。\n\n**代码：**\n```python\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        self.incrementals = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n            self.incrementals.append(0)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        if len(self.stack) > 1:\n            self.incrementals[-2] += self.incrementals[-1]\n        return self.stack.pop() + self.incrementals.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        size = min(k, len(self.stack))\n        if size > 0:\n            self.incrementals[size - 1] += val\n\n```\n\n**复杂度分析：**\n\n时间复杂度：push和pop操作的时间复杂度都是O(1)，而increment操作的时间复杂度取决于给定的范围k，最坏情况下为O(k)。因此，整体的时间复杂度取决于具体的操作序列。\n空间复杂度：除了存储栈元素的空间外，额外使用了一个与栈大小相同的增量数组。因此，空间复杂度为O(maxSize)。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1592146935","body":"**思路：**\n\n这段代码是一个解码字符串的函数。给定一个经过编码的字符串，编码规则是 k[encoded_string]，表示将 encoded_string 重复 k 次。需要将编码后的字符串解码成原始字符串。\n\n该解码函数使用栈来辅助解码过程。遍历输入字符串的每个字符，根据不同的情况进行处理：\n\n如果当前字符是数字，表示有一个新的重复次数，将其累加到 cur_num 中。\n如果当前字符是字母，直接将其添加到 cur_str 中。\n如果当前字符是左括号 [，将当前的 cur_str 和 cur_num 入栈，并将 cur_str 和 cur_num 重置为空字符串和零。\n如果当前字符是右括号 ]，表示一个重复子串的结束。从栈中弹出上一个字符串和重复次数，将当前的 cur_str 乘以重复次数并加到上一个字符串之后，得到新的 cur_str。\n遍历结束后，cur_str 中存储的就是解码后的字符串。\n最后返回 cur_str。\n\n**代码：**\n```python\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        cur_num = 0\n        cur_str = ''\n        for c in s:\n            if c == '[':\n                # Push the current count and string to the stack\n                stack.append((cur_str, cur_num))\n                # Reset the current count and string\n                cur_num = 0\n                cur_str = ''\n            elif c == ']':\n                # Pop the previous string and count from the stack\n                prev_str, num = stack.pop()\n                # Add the decoded substring to the previous string\n                cur_str = prev_str + num * cur_str\n            elif c.isdigit():\n                cur_num = cur_num * 10 + int(c)\n            else:  # c.isalpha()\n                cur_str += c\n        return cur_str\n\n```\n\n**复杂度分析：**\n\n时间复杂度：假设输入字符串的长度是 n。需要遍历整个字符串，每个字符只会入栈一次，出栈一次。因此，时间复杂度是 O(n)。\n\n空间复杂度：最坏情况下，栈的深度会达到 n，每个字符都会入栈。因此，空间复杂度是 O(n)。\n\n(以上内容由ChatGPT生成。我通过对比ChatGPT的答案来修改自己写的代码，然后再自己打一遍。)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1592184195","body":"**代码：**\n```python\n\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n```\n\n**复杂度分析：**\n\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592233400","body":"**思路：**\n\n这个问题可以通过一次遍历数组来解决。我们可以使用两个辅助数组mx和mn，其中mx[i]表示从数组开头到第i个位置的最大值，mn[i]表示从数组末尾到第i个位置的最小值。然后，我们遍历数组，对于每个位置i，如果mx[i]小于等于mn[i+1]，说明在位置i可以分割一个新的块，我们将结果加一。最后返回结果即可。\n\n**代码：**\n```python\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        n = len(arr)\n        mx, mn = [-1] * n, [float('inf')] * n\n\n        # Calculate max values from the start to current position\n        mx[0] = arr[0]\n        for i in range(1, n):\n            mx[i] = max(mx[i-1], arr[i])\n        \n        # Calculate min values from the end to current position\n        mn[-1] = arr[-1]\n        for i in range(n-2, -1, -1):\n            mn[i] = min(mn[i+1], arr[i])\n        \n        # Count all chunk points\n        return sum(mx[i] <= mn[i+1] for i in range(n-1)) + 1\n\n```\n\n**复杂度分析：**\n\n时间复杂度：遍历数组需要O(n)的时间，其中n是数组的长度。\n\n空间复杂度：需要两个辅助数组mx和mn来存储最大值和最小值，每个数组的长度为n，因此空间复杂度为O(n)。\n\n(以上内容由ChatGPT生成。我通过对比ChatGPT的答案来修改自己写的代码，然后再自己打一遍。)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1596381301","body":"**思路：**\n\n这段代码实现了一个链表的右旋转操作。给定一个链表的头节点 head 和一个非负整数 k，将链表向右旋转 k 个位置。\n\n首先，判断链表是否为空或者只有一个节点，如果是的话，直接返回原链表。\n\n接下来，计算链表的长度 l，并找到链表的尾节点 tail。\n\n由于旋转 k 个位置，可能大于链表的长度，所以取 k 对 l 取模，得到实际旋转的位置。\n\n如果 k 取模后的结果为 0，说明旋转后的链表和原链表一样，直接返回原链表。\n\n接下来，找到旋转位置的前一个节点 cur，即找到新链表的头节点的前一个节点。\n\n将 cur 的下一个节点作为新链表的头节点 newhead。\n\n将 cur 的下一个节点设为 None，断开原链表。\n\n将原链表的尾节点 tail 的下一个节点指向原链表的头节点 head。\n\n最后，返回新链表的头节点 newhead。\n\n**代码：**\n```python\n\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        l = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            l += 1\n        tail = cur\n        k %= l\n        if k == 0:\n            return head\n        cur = head\n        for _ in range(l - k - 1):\n            cur = cur.next\n        newhead = cur.next\n        cur.next = None\n        tail.next = head\n        return newhead\n\n```\n\n**复杂度分析：**\n\n时间复杂度：该算法需要遍历链表两次。第一次是为了计算链表的长度，第二次是为了找到新链表的头节点的前一个节点。所以时间复杂度为 O(n)，其中 n 是链表的长度。\n\n空间复杂度：该算法只使用了常数级别的额外空间，所以空间复杂度为 O(1)。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1596443964","body":"**思路：**\n\n这段代码实现了一个链表中相邻节点的交换操作。首先判断链表是否为空或者只有一个节点，如果是的话直接返回该链表。否则，定义两个指针first_node和second_node分别指向当前的两个节点，然后进行交换操作。将first_node的next指针指向递归调用swapPairs函数后得到的新链表的头节点，然后将second_node的next指针指向first_node，完成交换。最后返回second_node作为新链表的头节点。\n\n**代码：**\n```python\n\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        first_node = head\n        second_node = head.next \n\n        first_node.next = self.swapPairs(second_node.next)\n        second_node.next = first_node\n\n        return second_node\n\n```\n\n**复杂度分析：**\n\n时间复杂度：假设链表的长度为 n，递归过程中每次都会处理两个节点，所以总的操作次数为 n/2，因此时间复杂度为 O(n)。\n\n空间复杂度：递归调用的次数与链表的长度相关，最坏情况下链表长度为 n，所以递归调用的次数为 O(n)，因此空间复杂度为 O(n)。\n\n(以上内容由ChatGPT生成。我通过对比ChatGPT的答案来修改自己写的代码，然后再自己打一遍。)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596555887","body":"**思路：**\n\n这段代码实现了将有序链表转换为二叉搜索树的功能。可以使用递归的方式来解决这个问题。\n\n我们可以使用快慢指针找到链表的中间节点，然后以中间节点作为根节点构建二叉搜索树。中间节点的左边将构成左子树，中间节点的右边将构成右子树。递归地处理左右子链表，将它们分别转换为左右子树。\n\n具体步骤如下：\n\n处理基本情况：如果链表为空，返回 None。如果链表只有一个节点，将该节点作为根节点返回。\n使用快慢指针找到链表的中间节点。初始时，将快指针和慢指针都指向链表的头节点。\n快指针每次向前移动两步，慢指针每次向前移动一步，直到快指针到达链表末尾或者下一个节点为空。\n此时，慢指针指向链表的中间节点。\n将中间节点作为根节点创建一个新的二叉树节点。\n将中间节点的左侧链表作为左子链表，递归地调用 sortedListToBST 函数构建左子树，并将返回的根节点赋值给根节点的左指针。\n将中间节点的右侧链表作为右子链表，递归地调用 sortedListToBST 函数构建右子树，并将返回的根节点赋值给根节点的右指针。\n返回根节点。\n\n**代码：**\n```python\n\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        # Base case handling\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n\n        # Find the middle element for root\n        slow, fast = head, head.next.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # Cut off the list from the middle\n        mid = slow.next\n        slow.next = None\n\n        # Create a new tree node with mid element\n        node = TreeNode(mid.val)\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(mid.next)\n\n        return node\n\n```\n\n**复杂度分析：**\n\n时间复杂度：O(nlogn)，其中 n 是链表的长度。在每次递归调用中，都需要遍历链表找到中间节点，共需 logn 次。每次找到中间节点后，需要进行链表切割操作，时间复杂度为 O(1)。因此，总时间复杂度为 O(nlogn)。\n\n空间复杂度：O(logn)。\n\n(以上内容由ChatGPT生成。我通过对比ChatGPT的答案来修改自己写的代码，然后再自己打一遍。)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596595820","body":"**思路：**\n\n该问题可以通过使用双指针来解决。我们可以分别用指针 A 和指针 B 遍历链表 headA 和链表 headB，当到达链表末尾时，将指针 A 移动到链表 headB 的头部，将指针 B 移动到链表 headA 的头部。这样，指针 A 和指针 B 的移动长度就会相等。如果链表 headA 和链表 headB 有相交节点，那么在某一次移动中，指针 A 和指针 B 将会相遇于相交节点；如果链表 headA 和链表 headB 无相交节点，那么在某一次移动后，指针 A 和指针 B 同时移动到链表末尾，此时 A 和 B 都为 None，循环结束。\n\n**代码：**\n```python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n\n```\n\n**复杂度分析：**\n\n时间复杂度：O(m + n)，其中 m 和 n 分别为链表 headA 和链表 headB 的长度。最坏情况下，指针 A 和指针 B 都要遍历整个链表。\n\n空间复杂度：O(1)，只使用了常数级的额外空间。\n\n(以上内容由ChatGPT生成。我通过对比ChatGPT的答案来修改自己写的代码，然后再自己打一遍。)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1606700251","body":"**思路：**\n\n这段代码是一个链表中检测环的问题，使用了快慢指针的方法。首先，将两个指针slow和fast都指向链表的头节点。然后，slow每次移动一个节点，fast每次移动两个节点，直到两个指针相遇或者到达链表末尾。\n\n如果两个指针相遇，说明链表中存在环。此时，将fast重新指向链表头节点，并将slow保持在相遇位置。然后，将fast和slow同时每次移动一个节点，直到它们再次相遇，相遇的节点即为环的入口节点。\n\n如果两个指针没有相遇，说明链表中不存在环，返回None。\n\n**代码：**\n```python\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head\n        while True:\n            if not (fast and fast.next): return\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n        fast = head\n        while slow != fast:\n            fast = fast.next\n            slow = slow.next\n        return fast\n\n```\n\n**复杂度分析：**\n\n时间复杂度：O(n)，其中 n 是链表的长度。快指针每次移动两个节点，慢指针每次移动一个节点，最多移动 n 次。\n\n空间复杂度：O(1)，只使用了常数大小的额外空间。\n\n(以上内容由ChatGPT生成。我通过对比ChatGPT的答案来修改自己写的代码，然后再自己打一遍。)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1606730026","body":"**思路：**\n\n该问题是求二叉树的最大深度，可以使用递归的方法解决。如果当前节点为空，表示已经达到叶子节点的子节点，返回深度0。否则，分别递归计算左子树和右子树的最大深度，并返回较大的深度值加1。\n\n**代码：**\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left) + 1, self.maxDepth(root.right) + 1)\n```\n\n**复杂度分析：**\n\n时间复杂度：假设树的节点数为n，每个节点都需要遍历一次，所以时间复杂度为O(n)。\n\n空间复杂度：递归过程中需要使用系统栈空间，最坏情况下，树的高度为n，所以空间复杂度为O(n)。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1606745978","body":"**思路：**\n\n这段代码是用来判断两个二叉树是否相同的。我们可以通过递归的方式来比较两个树的每个节点是否相同。\n\n具体实现如下：\n\n首先，判断两个节点是否都为空，如果都为空，表示当前节点相同，返回True。\n其次，如果其中一个节点为空而另一个节点不为空，表示当前节点不同，返回False。\n然后，比较两个节点的值是否相同，如果不相同，表示当前节点不同，返回False。\n最后，递归地比较两个节点的左子树和右子树是否相同，如果都相同，返回True；否则，返回False。\n\n**代码：**\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not (p or q):\n            return True\n        if not (p and q):\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)\n```\n\n**复杂度分析：**\n\n时间复杂度：O(min(N, M))，其中 N 和 M 分别是两个二叉树的节点数，最坏情况下需要遍历两个二叉树的所有节点。\n空间复杂度：O(min(H1, H2))，其中 H1 和 H2 分别是两个二叉树的高度，递归调用栈的空间复杂度取决于二叉树的高度。在最坏情况下，二叉树的高度为 N 或 M，此时空间复杂度为 O(min(N, M))。","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635023771","body":"```python3\n    def minCharacters(self, word1: str, word2: str) -> int:\n        count1 = [0] * 26\n        count2 = [0] * 26\n        \n        for ch in word1:\n            count1[ord(ch) - ord('a')] += 1\n        \n        for ch in word2:\n            count2[ord(ch) - ord('a')] += 1\n        \n        len1, len2 = len(word1), len(word2)\n        prefix_sum1 = prefix_sum2 = 0\n        min_ops = len1 + len2\n        \n        for i in range(25):\n            prefix_sum1 += count1[i]\n            prefix_sum2 += count2[i]\n            min_ops = min(min_ops, len1 - prefix_sum1 + prefix_sum2, prefix_sum1 + len2 - prefix_sum2, len1 - count1[i] + len2 - count2[i])\n        \n        min_ops = min(min_ops, len1 - count1[25] + len2 - count2[25])\n        \n        return min_ops\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637304926","body":"**思路：**\r\n\r\n这是一个经典的二分查找问题。我们知道版本是按顺序排列的，所以我们可以通过二分查找来减少需要检查的版本数量。我们将中间的版本进行检查，如果这个版本是坏的，那么我们知道第一个坏的版本在这个版本的左边（包括这个版本），否则它在这个版本的右边。我们继续这个过程，直到找到第一个坏的版本。\r\n\r\n**代码：**\r\n```python\r\n    def firstBadVersion(self, n: int) -> int:\r\n        l,r = 1, n\r\n        while l < r:\r\n            m = (l+r)//2\r\n            if isBadVersion(m):\r\n                r = m\r\n            else:\r\n                l = m+1\r\n        return l\r\n```\r\n\r\n**复杂度分析：**\r\n\r\n时间复杂度：O(log n)，其中 n 是版本的数量。我们每次都将需要检查的版本数量减半，所以时间复杂度是对数级别的。\r\n空间复杂度：O(1)，我们只使用了常数级别的额外空间，主要用于存储二分查找的边界和中间值。","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1643657223","body":"def kth_diff(nums, k):\r\n    n = len(nums)\r\n    diffs = []\r\n    for i in range(n):\r\n        for j in range(i+1, n):\r\n            diffs.append(abs(nums[i] - nums[j]))\r\n    diffs.sort()\r\n    return diffs[k]","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/46#issuecomment-1646770530","body":"```python\r\n\r\ndef new_21_game_prob(n, k, maxPts):\r\n    if k == 0 or n >= k + maxPts:\r\n        return 1.0\r\n\r\n    dp = [0.0] * (k + maxPts)\r\n    for i in range(k, min(n, k + maxPts)):\r\n        dp[i] = 1.0\r\n\r\n    dp[k - 1] = float(min(n - k + 1, maxPts)) / maxPts\r\n\r\n    for i in range(k - 2, -1, -1):\r\n        dp[i] = dp[i + 1] - (dp[i + maxPts + 1] - dp[i + 1]) / maxPts\r\n\r\n    return dp[0]\r\n\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/50#issuecomment-1652870761","body":"```python\r\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\r\n    from itertools import combinations\r\n    leds = [1, 2, 4, 8, 1, 2, 4, 8, 16, 32]\r\n    times = []\r\n\r\n    for comb in combinations(range(10), turned_on):\r\n        hour = sum(leds[i] for i in comb if i < 4)\r\n        minute = sum(leds[i] for i in comb if i >= 4)\r\n        if hour < 12 and minute < 60:\r\n            times.append(f\"{hour}:{minute:02d}\")\r\n\r\n    return times\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/56#issuecomment-1661196838","body":"**思路：**\r\n\r\n这个问题可以通过动态规划来解决。我们可以从顶部开始向下爬楼梯，对于每一步，我们都计算到达这一步的最小成本。这个成本是当前步骤的成本加上到达下一步或下下一步的最小成本。最后，我们返回到达第0步或第1步的最小成本，因为我们可以从这两步开始爬楼梯。\r\n\r\n**代码：**\r\n```python\r\n\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\r\n        n = len(cost)\r\n        dp = [0] * (n + 1)\r\n        dp[n-1] = cost[n-1]\r\n\r\n        for i in range(n-2, -1, -1):\r\n            dp[i] = cost[i] + min(dp[i+1], dp[i+2])\r\n\r\n        return min(dp[0], dp[1])\r\n\r\n```\r\n\r\n**复杂度分析：**\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yizhewill":[null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1585823486","body":"Traverse from left, then right.\n\n```ruby\ndef shortest_to_char(s, c)\n  prev = -Float::INFINITY\n  ans = []\n\n  s.each_char.with_index do |x, i|\n    prev = i if x == c\n    ans << i - prev\n  end\n  \n  prev = Float::INFINITY\n  (s.length - 1).downto(0) do |i|\n    prev = i if s[i] == c\n    ans[i] = [ans[i], prev - i].min\n  end\n  \n  ans\nend\n```\n\n- Time complexity: O(n)\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1592231814","body":"```python\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        self.incrementals = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n            self.incrementals.append(0)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        if len(self.stack) > 1:\n            self.incrementals[-2] += self.incrementals[-1]\n        return self.stack.pop() + self.incrementals.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        size = min(k, len(self.stack))\n        if size > 0:\n            self.incrementals[size - 1] += val\n\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592234293","body":"```python\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        n = len(arr)\n        mx, mn = [-1] * n, [float('inf')] * n\n\n        # Calculate max values from the start to current position\n        mx[0] = arr[0]\n        for i in range(1, n):\n            mx[i] = max(mx[i-1], arr[i])\n        \n        # Calculate min values from the end to current position\n        mn[-1] = arr[-1]\n        for i in range(n-2, -1, -1):\n            mn[i] = min(mn[i+1], arr[i])\n        \n        # Count all chunk points\n        return sum(mx[i] <= mn[i+1] for i in range(n-1)) + 1\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596288586","body":"```ruby\ndef getIntersectionNode(headA, headB)\n    a, b = headA, headB\n    while a != b\n        a = a ? a.next : headB\n        b = b ? b.next : headA\n    end\n    return a\nend\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1606703261","body":"```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return None\n\n        slow, fast = head, head\n\n        # First loop to find if cycle exists\n        while (fast and fast.next):\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n\n        # If there's no cycle, return None\n        if slow != fast:\n            return None\n\n        # Reset fast pointer to head\n        # Both pointers now move at the same speed\n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n\n        return fast\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635008535","body":"```python3\r\nclass Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n\r\n        A = [0] * 26\r\n        B = [0] * 26\r\n        for ch in a:\r\n            A[ord(ch)-ord('a')] += 1\r\n        for ch in b:\r\n            B[ord(ch)-ord('a')] += 1\r\n\r\n        n1, n2 = len(a), len(b)\r\n        presum1 = presum2 = 0\r\n        ans = n1+n2\r\n        \r\n        for i in range(25):\r\n            presum1 += A[i]\r\n            presum2 += B[i]\r\n\r\n            ans = min(ans, n1-presum1+presum2, presum1+n2-presum2, n1-A[i] + n2-B[i])\r\n\r\n        ans = min(ans, n1-A[25] + n2-B[25])\r\n\r\n        return ans\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637300324","body":"class Solution:\r\n    def firstBadVersion(self, n: int) -> int:\r\n        l,r = 1, n\r\n        while l < r:\r\n            m = (l+r)//2\r\n            if isBadVersion(m):\r\n                r = m\r\n            else:\r\n                l = m+1\r\n        return l","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qiaojunch":[null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1585827597","body":" 思路：       \r\n        ## two pointers\r\n        ## 1. iterate over s and find the indices of c.\r\n        ## 2. iterate over s again, use a pointer j to record the closest c to s[i].\r\n        ## 3. find the smallest dist, \r\n        ###  if i < the left most c, ans = pos_of_c[0] - i\r\n        ###. if i > the right most c, ans = i - pos_of_c[-1]\r\n        ###. else, ans = whichever is close to i\r\n\r\n代码：\r\n\r\n        pos, ans, n = [], [], len(s)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                pos.append(i)\r\n\r\n        j = 0 # point to the closest c to char in s\r\n        for i in range(n):\r\n            if s[i] == c:  \r\n                ans.append(0)\r\n                j += 1\r\n            elif i < pos[0]:\r\n                ans.append(pos[0] - i)\r\n            elif i > pos[-1]:\r\n                ans.append(i - pos[-1])\r\n            else:\r\n                dist_to_left = i - pos[j-1]\r\n                dist_to_right = pos[j] - i\r\n                ans.append(min(dist_to_left, dist_to_right))\r\n        return ans\r\n复杂度：\r\ntime：o(n)\r\nspace: o(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594212413","body":"```\r\nclass Solution:\r\n    def rotateRight(self, head, k):\r\n        if not head:\r\n            return head\r\n\r\n        #connect tail to head\r\n        cur= head\r\n        length =1\r\n        while cur.next:\r\n            cur = cur.next\r\n            length+=1 \r\n        cur.next = head\r\n\r\n        #move to new head\r\n        k= length - (k%length)\r\n        while k>0:\r\n            cur=cur.next\r\n            k-=1\r\n\r\n        #disconnect and return new head\r\n        newhead = cur.next\r\n        cur.next=None\r\n        return newhead\r\n```\r\n\r\n# analyze\r\nTime: o(n)\r\nSpace: o(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhouliuhuo":[null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586031815","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n                String[] split = s.split(\"\");\n        ArrayList<Integer> indexs = new ArrayList<>();\n        for (int i = 0; i < split.length; i++) {\n            String s1 = split[i];\n            if (String.valueOf(c).equals(s1)) {\n                indexs.add(i);\n            }\n        }\n\n        int[] shortes = new int[split.length];\n        for (int i = 0; i < shortes.length; i++) {\n            if (indexs.contains(i)) {\n                shortes[i] = 0;\n            } else {\n                int min = split.length;\n                for (Integer index : indexs) {\n                    min = Integer.min(min, Math.abs(index - i));\n                }\n                shortes[i] = min;\n            }\n        }\n        return shortes;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beanza":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1586173960","body":"var addToArrayForm = function(num, k) {\n    let len = num.length;\n    let kSplitArr = String(k).split(\"\").map(item => Number(item));\n    let kSplitLen = kSplitArr.length;\n    if(len < kSplitLen) {\n        let temp = num;\n        num = kSplitArr;\n        kSplitArr = temp;\n    }\n\n    // 逐位相加\n    let flag = 0;\n    len = num.length - 1;\n    while(kSplitArr.length || flag) {\n        let kVal = kSplitArr.pop();\n        let val;\n        if(kVal >= 0) {\n            val = num[len] + kVal + flag;\n        } else {\n            val = num[len] + flag;\n        }\n        flag = Math.floor(val / 10);\n        num[len] = val % 10;\n        if(flag && len - 1 < 0) {\n           num.unshift(flag)\n        }\n        len--;\n    }\n    // console.log(num)\n    return num;\n};\n复杂度分析\n\n时间复杂度：O(N)，其中 N 为数组长度。\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586190672","body":"##思路\r\n将字符串放进一个数组 将字符C从左到右进行遍历  当C==idex[i]时，记录下标index。将index 与其他字符下标相减放进新的数组里并返回。\r\n##代码\r\n##复杂度\r\nO(n)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587578245","body":"思路\n\n因为题目中 inc() 方法需要遍历栈底到k的区间，因此使用使用数组和指针来完成\n\n代码\n\nclass CustomStack {\n    int[] arr = null;\n    int top;\n    public CustomStack(int maxSize) {\n        arr = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top < arr.length-1){\n            arr[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top >= 0){\n            return arr[top--];\n        } else {\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        int loop = Math.min(k-1, top);\n        for(int i = 0; i <= loop; i++){\n            arr[i] += val;\n        }\n    }\n}\n复杂度分析\n\n时间复杂度：出栈和入栈为O(1)，increment方法为O(N)， N 为数组长度。\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589375584","body":"思路：正则表达式\n\n代码\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        while '[' in s:\n            s = re.sub(r'(\\d+)\\[([A-Za-z]*)\\]', lambda m:int(m.group(1)) * m.group(2), s)\n        return s\n复杂度分析\n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591368636","body":"思路\n\n代码\nclass MyQueue:\n\ndef __init__(self):\n    \"\"\"\n    Initialize your data structure here.\n    \"\"\"\n    # 初始化输入栈和输出栈\n    self.inStack = []\n    self.outStack = []\n\ndef push(self, x: int) -> None:\n    \"\"\"\n    Push element x to the back of queue.\n    \"\"\"\n    # 有新元素进来，进入输入栈\n    self.inStack.append(x)\n\ndef pop(self) -> int:\n    \"\"\"\n    Removes the element from in front of queue and returns that element.\n    \"\"\"\n    # 如果为空\n    if self.empty():\n        return None\n\n    # 如果输出栈不为空，返回输出栈中的元素\n    if self.outStack:\n        return self.outStack.pop()\n    # 输出栈为空,将输入栈的元素压入输出栈\n    else:\n        while self.inStack:\n            val = self.inStack.pop()\n            self.outStack.append(val)\n        return self.outStack.pop()\n\ndef peek(self) -> int:\n    \"\"\"\n    Get the front element.\n    \"\"\"\n    # 使用已有的函数 pop\n    res = self.pop()\n    # pop 函数弹出了 res，所以要再添加回去\n    self.outStack.append(res)\n\n    return res\n\n\ndef empty(self) -> bool:\n    \"\"\"\n    Returns whether the queue is empty.\n    \"\"\"\n    # 两个栈都为空，队列才为空\n    if not(self.inStack or self.outStack):\n        return True\n\n    return False\n复杂度\n时间空间均为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593287041","body":"class Solution:\ndef maxChunksToSorted(self, arr: List[int]) -> int:\ncount = 0\nmax_val = 0\nfor i, val in enumerate(arr):\nmax_val = max(max_val, val)\nif i == max_val:\ncount += 1\nmax_val = i + 1\nreturn count","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594703165","body":"代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null){\n            return head;\n        }\n\n        ListNode p1 = head;\n        ListNode p2 = head;\n        int size = 1;\n        for(int i = 0; i < k; i++){\n            if(p2.next!=null){\n                p2 = p2.next;\n                size++;\n            } else {\n                p2 = head;\n                k = (k % size) + size;\n            }\n        }\n\n        while(p2.next!=null){\n            p2 = p2.next;\n            p1 = p1.next;\n        }\n\n        p2.next = head;\n        head = p1.next;\n        p1.next = null;\n\n        return head;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1596172005","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        next = head.next\n        head.next = self.swapPairs(next.next)\n        next.next = head\n        return next","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596171332","body":"代码\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        // 递归+快慢指针\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right){\n        if(left == right){\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right){\n        ListNode fast = left;\n        ListNode slow = left;\n        while(fast != right && fast.next != right){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596814525","body":"public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<>();\n        ListNode temp = headA;\n        while(temp != null){\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while(temp != null){\n            if(visited.contains(temp)){\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1599086697","body":"思路\n\n使用一个Map来记录已经遍历过的节点，如果在遍历过程中，又遇到了之前遍历的节点，那就认为该节点为环形链表的头节点。\n\n代码\n\nvar detectCycle = function(head) {\n    let map = new WeakMap();\n    let curr = head;\n    while(curr) {\n        if(!map.has(curr)) {\n            map.set(curr, 1);\n        } else {\n            return curr;\n        }\n        curr = curr.next;\n    }\n    return null;\n};\n复杂度分析\n\n时间复杂度：O(N)，其中 N 为数组长度。\n空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1599740977","body":"def __init__(self, capacity: int):\n    self.capacity = capacity\n    self.dic = collections.OrderedDict()\n\ndef get(self, key: int) -> int:\n    if key not in self.dic:\n        return -1\n    \n    self.dic.move_to_end(key)\n    return self.dic[key]\n    \ndef put(self, key: int, value: int) -> None:\n    if key in self.dic:\n        self.dic.move_to_end(key)\n    \n    self.dic[key] = value\n    if len(self.dic) > self.capacity:\n        self.dic.popitem(False)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602639972","body":"int maxDepth(struct TreeNode* root){\n   if(root==NULL)\n   return 0;\n   else{\n       int m=maxDepth(root->left);\n       int n=maxDepth(root->right);\n       if(m>n)\n       return m+1;\n       else\n       return n+1;\n   }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604306436","body":"思路\n\n法一用递归，法二用队列创建BFS实现层序遍历，法三用前序和中序遍历判断树的结构是否相同,以下程序用法二BFS\n\n代码\n\nfrom collections import deque\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not q and not p:\n            return True\n        if not q or not q:\n            return False\n        q1 = collections.deque([p])\n        q2 = collections.deque([q])\n        while q1 and q2:\n            node1 = q1.popleft()\n            node2 = q2.popleft()\n            if node1 is None and node2 is None:#判断node.val时需要判断是否为空，否则力扣代码提交会报错\n                continue  # 继续下一次循环\n            if node1 is None or node2 is None:\n                return False\n            if node1.val != node2.val:\n                return False\n            left1, right1 = node1.left, node1.right\n            left2, right2 = node2.left, node2.right\n            if (not left1) ^ (not left2):\n                return False\n            if (not right1) ^ (not right2):\n                return False\n            if left1:\n                q1.append(left1)\n            if right1:\n                q1.append(right1)\n            if left2:\n                q2.append(left2)\n            if right2:\n                q2.append(right2)\n        return not q1 and not q2\n复杂度分析\n\n时间复杂度：O(N)，其中 N 为节点个数。\n空间复杂度：O(Q)，最长队列的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605770656","body":"思路\n\n二叉树先序遍历\n用数组存储所有二叉树路径的字符串，最后转换为整数后求和\n\n代码\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        path = ''\n        result = []\n        \n        self.helper(root, path, result)\n        \n        return sum([int(path) for path in result])\n    \n    def helper(self, root, path, result):\n        if not root:\n            return \n        \n        path += str(root.val)\n        \n        if not root.left and not root.right:\n            result.append(path)\n            \n        self.helper(root.left, path, result)\n        self.helper(root.right, path, result)\n复杂度分析\n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605770597","body":"思路\n\n二叉树先序遍历\n用数组存储所有二叉树路径的字符串，最后转换为整数后求和\n\n代码\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        path = ''\n        result = []\n        \n        self.helper(root, path, result)\n        \n        return sum([int(path) for path in result])\n    \n    def helper(self, root, path, result):\n        if not root:\n            return \n        \n        path += str(root.val)\n        \n        if not root.left and not root.right:\n            result.append(path)\n            \n        self.helper(root.left, path, result)\n        self.helper(root.right, path, result)\n复杂度分析\n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1606949700","body":"public class Codec {\n// Encodes a tree to a single string.\npublic String serialize(TreeNode root) {\nif (root == null) {\nreturn \"null\";\n}\nreturn root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1613561335","body":"class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> cnt;\n        for (int val : nums) cnt[val]++;\n        int n = nums.size();\n        vector<int> ss(n+1);\n        for (auto it = cnt.begin(); it != cnt.end(); it++) {\n            ss[it->second]++;\n        }\n        int index = n;\n        while (k > 0) {\n            k -= ss[index--];\n        }\n        vector<int> ans;\n        for (auto it = cnt.begin(); it != cnt.end(); it++) {\n            if (it->second > index) {\n                ans.push_back(it->first);\n            }\n        }\n        return ans;\n    }\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1611432031","body":"思路\n\n用哈希表做两数之和（也可以暴力法）\n\n代码\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        map={}\n        for i in range(len(nums)):\n            if nums[i] in map:\n                return [map[nums[i]],i]\n            map[target-nums[i]]=i\n        return []\n复杂度分析\n\n时间复杂度：O(N)，其中 N 为数组长度。\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1613560600","body":"class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> cnt;\n        for (int val : nums) cnt[val]++;\n        int n = nums.size();\n        vector<int> ss(n+1);\n        for (auto it = cnt.begin(); it != cnt.end(); it++) {\n            ss[it->second]++;\n        }\n        int index = n;\n        while (k > 0) {\n            k -= ss[index--];\n        }\n        vector<int> ans;\n        for (auto it = cnt.begin(); it != cnt.end(); it++) {\n            if (it->second > index) {\n                ans.push_back(it->first);\n            }\n        }\n        return ans;\n    }\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614932116","body":"function numberOfBoomerangs(points: number[][]): number {\n    let res = 0;\n    for (let i = 0; i < points.length; i++) {\n        const map = new Map();\n        for (let j = 0; j < points.length; j++) {\n            if (i === j) continue;\n            const hypotenuse =\n                Math.pow(points[i][0] - points[j][0], 2) +\n                Math.pow(points[i][1] - points[j][1], 2);\n            map.set(hypotenuse, (map.get(hypotenuse) ?? 0) + 1);\n        }\n        for (let count of map.values()) {\n            res += count * (count - 1)\n        }\n    }\n    return res;\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1614935352","body":"class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        // 哈希集合，记录每个字符是否出现过\n        unordered_set<char> occ;\n        int n = s.size();\n        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n        int rk = -1, ans = 0;\n        // 枚举左指针的位置，初始值隐性地表示为 -1\n        for (int i = 0; i < n; ++i) {\n            if (i != 0) {\n                // 左指针向右移动一格，移除一个字符\n                occ.erase(s[i - 1]);\n            }\n            while (rk + 1 < n && !occ.count(s[rk + 1])) {\n                // 不断地移动右指针\n                occ.insert(s[rk + 1]);\n                ++rk;\n            }\n            // 第 i 到 rk 个字符是一个极长的无重复字符子串\n            ans = max(ans, rk - i + 1);\n        }\n        return ans;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616697611","body":"class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n        one_word_len = len(words[0])\n        all_words_len = len(words) * one_word_len\n        n = len(s)\n        words_counter = collections.Counter(words)\n        res = []\n        for i in range(0, n - all_words_len + 1):\n            tmp = s[i:i+all_words_len]\n            c_tmp = []\n            for j in range(0, all_words_len, one_word_len):\n                c_tmp.append(tmp[j:j+one_word_len])\n            if collections.Counter(c_tmp) == words_counter:\n                res.append(i)\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1618454417","body":"class Solution {\n    func minSubarray(_ nums: [Int], _ p: Int) -> Int {\n         var total = nums.reduce(0, +)\n    let mod = total % p\n    if mod == 0 { return 0 }\n\n    var ans = nums.count\n    total = 0\n    var dic: [Int: Int] = [0: -1]\n    for j in 0..<nums.count {\n        total += nums[j]\n        let cur = total % p\n        let target = (cur - mod + p) % p\n        if let index = dic[target] {\n            ans = min(ans, j - index)\n        }\n        dic[cur] = j\n    }\n\n    if ans == nums.count {\n        return -1\n    }\n    return ans\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1620286664","body":"class Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1622177274","body":"function removeDuplicates(nums: number[]): number {\n  let i = 1, cur = nums[0], j = 0\n  while (i < nums.length) {\n    if (nums[i] !== cur) {\n      nums[j + 1] = nums[i]\n      j++\n      cur = nums[i]\n    }\n    i++\n  }\n  return nums.length - i + j + 1\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1622178917","body":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        if (nums.length == 0) return -1;\n\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left <= right) {\n\n            int mid = left + (right - left) / 2;\n            if (target > nums[mid]) {\n                left = mid + 1;\n            } else if (target < nums[mid]) {\n                right = mid - 1;\n            } else if (target == nums[mid]){\n                return mid;\n            }\n        }\n\n        return left;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1625591643","body":"代码\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        // 1. 将 nums 的前k个元素放入优先队列中\n        int n = nums.length;\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>(){\n            public int compare(int[] pair1, int[] pair2){\n                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair2[1];\n            }\n        });\n        for(int i = 0; i<k; i++){\n            queue.offer(new int[]{nums[i], i});\n        }\n        int[] ans = new int[n - k + 1];\n        ans[0] = queue.peek()[0];\n        // 2. 向右移动时，将一个元素入队，此时堆顶为最大值\n        for(int i = k; i<nums.length; i++){\n            queue.offer(new int[]{nums[i], i});\n            // 3. 将最左侧的值出队\n            while(queue.peek()[1] <= i - k){\n                queue.poll();\n            }\n            // 将堆顶保存\n            ans[i - k + 1] = queue.peek()[0];\n        }\n        return ans;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1627338709","body":"Approach\n\nAbsracting it as graph. The judge has in-degree of $N-1$ and out-degree of $0$.\n\nCode\n\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n\n        int[] in_degree = new int[n+1];\n        int[] out_degree = new int[n+1];\n\n        for (int i = 0; i < trust.length; i++) {\n            out_degree[trust[i][0]] += 1;\n            in_degree[trust[i][1]] += 1;\n        }\n\n        for (int i = 1; i < n+1; i++) {\n            if (in_degree[i] == n-1 && out_degree[i] == 0) {\n                return i;\n            }\n        }\n\n        return -1;\n        \n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627710562","body":"class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        #建图\n        graph=[[0]*n for _ in range(n)]\n        colors=[0]*n\n        for a,b in dislikes:\n            graph[a-1][b-1]=1#a不喜欢b\n            graph[b-1][a-1]=1#表示b不喜欢a\n        #对着色的节点进行循环\n        for i in range(n):\n            #如果i没着色，且着色后还是不能二分，则表示不能分开\n            if colors[i]==0 and not self.dfs(graph,colors,i,1,n):\n                return False\n        return True#排除所有不能二分分情况，那么最后能二分就是True\n    def dfs(self,graph,colors,i,color,n):\n        colors[i]=color\n        for j in range(n):#-1*color,乘以-1保证不会栈溢出\n            if graph[i][j]==1:\n                if colors[j]==color:\n                    return False\n                if colors[j]==0 and not self.dfs(graph,colors,j,-1*color,n):\n                    return False\n        return True","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1628997890","body":"function sortItems(\n  n: number,\n  m: number,\n  group: number[],\n  beforeItems: number[][]\n): number[] {\n\n  for (let i = 0; i < group.length; i++) {\n    if (group[i] == -1) {\n      group[i] = m;\n      m++;\n    }\n  }\n\n  const groupAdj: number[][] = Array(m)\n    .fill(undefined)\n    .map(() => Array());\n  const itemAdj: number[][] = Array(n)\n    .fill(undefined)\n    .map(() => Array());\n\n  let groupInDegree: number[] = Array(m).fill(0);\n  let itemInDegree: number[] = Array(n).fill(0);\n\n  for (let i = 0; i < group.length; i++) {\n    let curGroup = group[i];\n    for (let beforeItem of beforeItems[i]) {\n      let beforeGroup = group[beforeItem];\n      if (beforeGroup != curGroup) {\n        groupAdj[beforeGroup].push(curGroup);\n        groupInDegree[curGroup]++;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let item of beforeItems[i]) {\n      itemAdj[item].push(i);\n      itemInDegree[i]++;\n    }\n  }\n\n  let groupResult: number[] = topoLogicalSort(groupAdj, groupInDegree, m);\n  if (groupResult.length == 0) {\n    return [];\n  }\n  let itemResult = topoLogicalSort(itemAdj, itemInDegree, n);\n  if (itemResult.length == 0) {\n    return [];\n  }\n  let group2Items: Map<number, number[]> = new Map();\n  for (let item of itemResult) {\n    let key = group[item];\n    if (group2Items.has(key)) {\n      group2Items.get(group[item]).push(item);\n    } else {\n      group2Items.set(key, [item]);\n    }\n  }\n\n  let result: number[] = Array();\n  for (let group of groupResult) {\n    let items = group2Items.get(group) ?? [];\n    result = result.concat(items);\n  }\n  return result;\n}\n\nfunction topoLogicalSort(\n  adj: number[][],\n  inDegree: number[],\n  n: number\n): number[] {\n  let result: number[] = [];\n  let queue: number[] = [];\n  for (let i = 0; i < n; i++) {\n    if (inDegree[i] == 0) {\n      queue.push(i);\n    }\n  }\n  while (queue.length != 0) {\n    let front = queue.shift();\n    result.push(front);\n    for (let successor of adj[front]) {\n      inDegree[successor]--;\n      if (inDegree[successor] == 0) {\n        queue.push(successor);\n      }\n    }\n  }\n  if (result.length == n) {\n    return result;\n  }\n  return [];","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1630996564","body":"class Solution {\n    public boolean judgeCircle(String moves) {\n        // RL\n        int rl = 0;\n        int ud = 0;\n        for(char ch: moves.toCharArray()){\n            if('R' == ch){\n                rl--;\n            } else if('L' == ch){\n                rl++;\n            } else if('U' == ch){\n                ud--;\n            } else if('D' == ch){\n                ud++;\n            }\n        }\n        return rl==0 && ud == 0;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1632145688","body":"class Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(task[0], i, task[1]) for i, task in enumerate(tasks)]\n        tasks.sort()\n        backlog = []\n        time = 0\n        ans = []\n        pos = 0\n        for _ in tasks:\n            if not backlog:\n                time = max(time, tasks[pos][0])\n            while pos < len(tasks) and tasks[pos][0] <= time:\n                heapq.heappush(backlog, (tasks[pos][2], tasks[pos][1]))\n                pos += 1\n            d, j = heapq.heappop(backlog)\n            time += d\n            ans.append(j)\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1634482629","body":"def numberOfRounds(self, loginTime, logoutTime):\n    hs, ms = (int(x) for x in loginTime.split(\":\"))\n    ts = 60 * hs + ms\n    hf, mf = (int(x) for x in logoutTime.split(\":\"))\n    tf = 60 * hf + mf\n    if 0 <= tf - ts < 15: return 0 ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635966069","body":"var minCharacters = function(a, b) {\n    let arrA = new Array(26).fill(0);\n    let arrB = new Array(26).fill(0);\n    const n = a.length;\n    const m = b.length;\n    const sum = m + n;\n    for(let letter of a) {\n        arrA[letter.charCodeAt() - 97]++;\n    }\n\n    for(let letter of b) {\n        arrB[letter.charCodeAt() - 97]++;\n    }\n    let ans = sum;\n    for(let i = 0; i < 26; i++) {\n        for (let i = 0; i < 26 && ans != 0; i++) {\n            // 3\n            let ca = n - arrA[i], cb = m - arrB[i];\n            ans = Math.min(ans, ca + cb);\n            if (i == 0) continue;\n            let r1 = 0, r2 = 0;\n\n            // 1 使用了数组对字符个数进行了存储，所以，\n            // i以后的为大于当前字符的字符个数；反之则为小于当前字符的字符个数\n            for (let j = i; j < 26; j++) r1 += arrA[j];\n            for (let j = 0; j < i; j++) r1 += arrB[j];\n            \n            // 2\n            for (let j = i; j < 26; j++) r2 += arrB[j];\n            for (let j = 0; j < i; j++) r2 += arrA[j];\n            ans = Math.min(ans, Math.min(r1, r2));\n        }\n        return ans;\n    }\n\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1637110444","body":"var temp []int\n\nfunc sortArray(nums []int) []int {\n    if len(nums) == 0 {\n        return nums\n    }\n    temp = make([]int, len(nums))\n\n    sort(&nums, 0, len(nums)-1)\n    return nums\n}\n\nfunc sort(nums *[]int, lo int, hi int) {\n    if lo == hi {\n        return\n    }\n\n    mid := (lo + hi) / 2\n    sort(nums, lo, mid)\n    sort(nums, mid+1, hi)\n    merge(nums, lo, mid, hi)\n\n}\n\nfunc merge(nums *[]int, lo, mid, hi int) {\n    i, j := lo, mid+1\n    \n    for p := lo; p <= hi; p++ {\n        if i == mid + 1 {\n            temp[p] = (*nums)[j]\n            j++\n        } else if j == hi +1 {\n            temp[p] = (*nums)[i]\n            i++\n        } else if (*nums)[i] > (*nums)[j] { \n             temp[p] = (*nums)[j]\n            j++\n        } else {\n             temp[p] =(*nums)[i]\n            i++\n        }\n    }\n    \n    for k := lo; k <= hi ; k++ {\n        (*nums)[k] = temp[k]\n    }\n   \n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637110249","body":"func mySqrt(x int) int {\n    l, r := 0, x\n    ans := -1\n    for l <= r {\n        mid := l + (r - l) / 2\n        if mid * mid <= x {\n            ans = mid\n            l = mid + 1\n        } else {\n            r = mid - 1\n        }\n    }\n    return ans\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1638354287","body":"class Solution:\n    def firstBadVersion(self, n: int) -> int:\n\n        l, r = 1, n\n\n        while l < r:\n            mid = l + (r-l) // 2\n            if isBadVersion(mid):\n                r = mid\n            else:\n                l = mid + 1\n            \n        return l","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1639882852","body":"class Solution:\n    def reversePairs(self, nums):\n        if len(nums) <= 1:\n            return 0\n\n        self.count = 0\n        self.mergeSort(nums, 0, len(nums) - 1)\n\n        return self.count\n\n    def mergeSort(self, nums, left, right):\n        if left >= right:\n            return\n\n        mid = (left + right) // 2\n\n        self.mergeSort(nums, left, mid)\n        self.mergeSort(nums, mid + 1, right)\n        self.merge(nums, left, mid, right)\n\n    def merge(self, nums, left, mid, right):\n        i = left\n        j = mid + 1\n\n        while i <= mid and j <= right:\n            if nums[i] > 2 * nums[j]:\n                self.count += mid - i + 1\n                j += 1\n            else:\n                i += 1\n\n        nums[left:right + 1] = sorted(nums[left:right + 1])","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/42#issuecomment-1642225794","body":"class Solution:\n    def findRadius(self, houses, heaters):\n        houses.sort()\n        heaters.sort()\n        radius = 0\n\n        for house in houses:\n            left, right = 0, len(heaters)\n\n            while left < right:\n                mid = (left + right) // 2\n\n                if heaters[mid] < house:\n                    left = mid + 1\n                else:\n                    right = mid\n\n            left_dist = abs(heaters[left] - house) if left < len(heaters) else float('inf')\n            prev_dist = abs(heaters[left - 1] - house) if left > 0 else float('inf')\n            radius = max(radius, min(left_dist, prev_dist))\n\n        return radius","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1644143203","body":"class Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n=nums.size(), l=0, r=nums[n-1]-nums[0];\n        while(l <= r){\n            int m=(l+r)/2, cnt=0;\n            for(int i=0,j=0;j<n;j++){\n                while(nums[j]-nums[i] > m)\n                    i++;\n                cnt += j-i;\n            }\n            if(cnt >= k)\n                r = m-1;\n            else\n                l = m+1;\n        }\n        return l;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/44#issuecomment-1645983100","body":"public int maxVowels(String s, int k) {\n\n    if (s == null || s.length() < k)\n        return 0;\n\n    int res = 0;\n    Set<Character> set = new HashSet<>(){{\n        add('a');add('e');add('i');add('o');add('u');\n    }};\n\n    for (int i = 0; i < s.length() - k + 1; i++) {\n\n        String sub = s.substring(i, i + k);\n        int count = 0;\n\n        for (int j = 0; j < sub.length(); j++)\n            if (set.contains(sub.charAt(j)))\n                count++;\n\n        res = Math.max(res, count);\n    }\n\n    return res;\n}\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/45#issuecomment-1645982637","body":"public int maxVowels(String s, int k) {\n\n    if (s == null || s.length() < k)\n        return 0;\n\n    int res = 0;\n    Set<Character> set = new HashSet<>(){{\n        add('a');add('e');add('i');add('o');add('u');\n    }};\n\n    for (int i = 0; i < s.length() - k + 1; i++) {\n\n        String sub = s.substring(i, i + k);\n        int count = 0;\n\n        for (int j = 0; j < sub.length(); j++)\n            if (set.contains(sub.charAt(j)))\n                count++;\n\n        res = Math.max(res, count);\n    }\n\n    return res;\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/46#issuecomment-1646837229","body":"class Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0) {\n            return 1.0;\n        }\n        double[] dp = new double[k + maxPts];\n        for (int i = k; i <= n && i < k + maxPts; i++) {\n            dp[i] = 1.0;\n        }\n        for (int i = k - 1; i >= 0; i--) {\n            for (int j = 1; j <= maxPts; j++) {\n                dp[i] += dp[i + j] / maxPts;\n            }\n        }\n        return dp[0];\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/47#issuecomment-1647936371","body":"class Solution {\n    func findAnagrams(_ s: String, _ p: String) -> [Int] {\n        var target = [Character: Int]()\n        var ans = [Int]()\n        \n        for char in p {\n            target[char, default: 0] += 1\n        }\n        \n        for i in 0..<s.count {\n            if i >= p.count {\n                let charToRemove = s[s.index(s.startIndex, offsetBy: i - p.count)]\n                target[charToRemove] = (target[charToRemove] ?? 0) + 1\n                if target[charToRemove] == 0 {\n                    target[charToRemove] = nil\n                }\n            }\n            \n            let charToAdd = s[s.index(s.startIndex, offsetBy: i)]\n            target[charToAdd, default: 0] -= 1\n            if target[charToAdd] == 0 {\n                target[charToAdd] = nil\n            }\n            \n            if target.isEmpty {\n                ans.append(i - p.count + 1)\n            }\n        }\n        \n        return ans\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/48#issuecomment-1650096014","body":"from collections import defaultdict\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n\n        need, window = defaultdict(int), defaultdict(int)\n        for c in t:\n            need[c] += 1\n\n        left, right = 0, 0\n        valid = 0\n        # 记录最小覆盖子串的起始索引及长度\n        start, length = 0, float('inf')\n        while right < len(s):\n            # c 是将移入窗口的字符\n            c = s[right]\n            # 扩大窗口\n            right += 1\n            # 进行窗口内数据的一系列更新\n            if c in need:\n                window[c] += 1\n                if window[c] == need[c]:\n                    valid += 1\n\n            # 判断左侧窗口是否要收缩\n            while valid == len(need):\n                # 在这里更新最小覆盖子串\n                if right - left < length:\n                    start = left\n                    length = right - left\n\n                # d 是将移出窗口的字符\n                d = s[left]\n                # 缩小窗口\n                left += 1\n                # 进行窗口内数据的一系列更新\n                if d in need:\n                    if window[d] == need[d]:\n                        valid -= 1\n                    window[d] -= 1\n\n        # 返回最小覆盖子串\n        return \"\" if length == ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/49#issuecomment-1651984060","body":"class Solution:\n    def minOperations(self, nums, target):\n        memo = {}\n\n        def dp(nums, target):\n            if target == 0:\n                return 0\n            if target < 0 or len(nums) == 0:\n                return float('inf')\n\n            if target in memo:\n                return memo[target]\n\n            option1 = dp(nums[:-1], target - nums[-1]) + 1\n            option2 = dp(nums[1:], target - nums[0]) + 1\n            result = min(option1, option2)\n            memo[target] = result\n            return result\n\n        result = dp(nums, target)\n\n        if result == float('inf'):\n            return -1\n        else:\n            return result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/50#issuecomment-1653936507","body":"const totalNQueens = function (n) {\n  let res = 0;\n  const dfs = (n, row, col, pie, na) => {\n    if (row >= n) {\n      res++;\n      return;\n    }\n    // 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历\n    // 也就是得到当前所有的空位\n    let bits = ~(col | pie | na) & ((1 << n) - 1);\n    while (bits) {\n      // 取最低位的1\n      let p = bits & -bits;\n      // 把P位置上放入皇后\n      bits = bits & (bits - 1);\n      // row + 1 搜索下一行可能的位置\n      // col ｜ p 目前所有放置皇后的列\n      // (pie | p) << 1 和 (na | p) >> 1) 与已放置过皇后的位置 位于一条斜线上的位置\n      dfs(n, row + 1, col | p, (pie | p) << 1, (na | p) >> 1);\n    }\n  };\n  dfs(n, 0, 0, 0, 0);\n  return res;\n};\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/51#issuecomment-1653936153","body":"const totalNQueens = function (n) {\n  let res = 0;\n  const dfs = (n, row, col, pie, na) => {\n    if (row >= n) {\n      res++;\n      return;\n    }\n    // 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历\n    // 也就是得到当前所有的空位\n    let bits = ~(col | pie | na) & ((1 << n) - 1);\n    while (bits) {\n      // 取最低位的1\n      let p = bits & -bits;\n      // 把P位置上放入皇后\n      bits = bits & (bits - 1);\n      // row + 1 搜索下一行可能的位置\n      // col ｜ p 目前所有放置皇后的列\n      // (pie | p) << 1 和 (na | p) >> 1) 与已放置过皇后的位置 位于一条斜线上的位置\n      dfs(n, row + 1, col | p, (pie | p) << 1, (na | p) >> 1);\n    }\n  };\n  dfs(n, 0, 0, 0, 0);\n  return res;\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/52#issuecomment-1656744413","body":"var maxAreaOfIsland = function(grid) {\n    let x = grid.length;\n    let y = grid[0].length;\n    let max = 0;\n    // 遍历二维数组\n    for (let i = 0; i < x; i ++) {\n       for (let j = 0; j < y; j ++) {\n           if (grid[i][j] === 1) {\n               max = Math.max(max, areaOfIsland(grid, i, j, x, y));\n           }\n       } \n    }\n    return max;\n};\n\nvar areaOfIsland = function(grid, i, j, x, y) {\n    // 判断边界条件\n    if(i < 0 || i >= x || j < 0 || j >= y || grid[i][j] === 0) {\n        return 0\n    }\n    let ans = 1;\n    // 将遍历过的岛屿标记为0\n    grid[i][j] = 0;\n    // 遍历岛屿四周\n    ans += areaOfIsland(grid, i + 1, j, x, y);\n    ans += areaOfIsland(grid, i - 1, j, x, y);\n    ans += areaOfIsland(grid, i, j + 1, x, y);\n    ans += areaOfIsland(grid, i, j - 1, x, y);\n    return ans;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/53#issuecomment-1657182175","body":"class Solution:\n    def maxDistance(self, grid):\n        rows = len(grid)\n        cols = len(grid[0])\n\n        ocean_queue = []\n        land_queue = []\n\n   \n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 0:\n                    ocean_queue.append((i, j))\n                else:\n                    land_queue.append((i, j))\n\n        if len(ocean_queue) == 0 or len(land_queue) == 0:\n            return -1\n\n        max_distance = -1\n\n   \n        while ocean_queue:\n            ocean_cell = ocean_queue.pop(0)\n\n         \n            x0, y0 = ocean_cell\n            for land_cell in land_queue:\n  \n                x1, y1 = land_cell\n                distance = abs(x0 - x1) + abs(y0 - y1)\n                max_distance = max(max_distance, distance)\n        return max_distance","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/54#issuecomment-1658502319","body":"def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n        boxes = set(initialBoxes)\n        q = [i for i in boxes if status[i]]\n        for i in q:\n            for j in containedBoxes[i]:\n                boxes.add(j)\n                if status[j]:\n                    q.append(j)\n            for j in keys[i]:\n                if status[j] == 0 and j in boxes:\n                    q.append(j)\n                status[j] = 1\n        return sum(candies[i] for i in q)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/55#issuecomment-1660327104","body":"def verticalOrder(self, root):\n    # 队列存nodes\n    # column存projection信息\n    # 如果project到相同的column, 自动append到一个list\n    columnTable = collections.defaultdict(list)\n    queue = deque([(root, 0)]) #[node, x]\n\n    while queue: #pre-order BFS\n        node, column = queue.popleft()\n\n        if node:\n            columnTable[column].append(node.val) \n            if node.left:\n                queue.append((node.left, column - 1))\n            if node.right:\n                queue.append((node.right, column + 1))\n                    \n    return [columnTable[x] for x in sorted(columnTable.keys())]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/56#issuecomment-1662167381","body":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        prev, curr = cost[0], cost[1]\n        for i in range(2, len(cost)+1):\n            next = min(prev, curr) + (cost[i] if i != len(cost) else 0)\n            prev, curr = curr, next\n        return curr","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/57#issuecomment-1664075230","body":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        n=len(nums)\n        if n==1:\n            return nums[0]\n        else:\n            pre=nums[0]\n            cur=max(nums[1],pre)\n            for i in range(2,n):\n                cur,pre=max(pre+nums[i],cur),cur\n            return cur","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/58#issuecomment-1665660920","body":"class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n=len(nums)\n        dp=[[1,1]for i in range(n)]#[1,1]第一个1表示长度，第二个1表示个数\n        ans=[1,1]\n        longest=1\n        for i in range(n):\n            for j in range(i+1,n):\n                if nums[j]>nums[i]:\n                    if dp[i][0]+1>dp[j][0]:\n                        dp[j][0]=dp[i][0]+1\n                        dp[j][1]=dp[i][1]\n                        longest=max(longest,dp[j][0])\n                    elif dp[j][0]==dp[i][0]+1:\n                        dp[j][1]+=dp[i][1]\n        return sum(dp[i][1] for i in range(n) if dp[i][0]==longest)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/59#issuecomment-1666515450","body":"func longestCommonSubsequence(text1 string, text2 string) int {\n\tdp := make([][]int, len(text1)+1)\n\tfor i := 0; i < len(text1)+1; i++ {\n\t\tdp[i] = make([]int, len(text2)+1)\n\t}\n\n\tfor i := 1; i < len(text1)+1; i++ {\n\t\tfor j := 1; j < len(text2)+1; j++ {\n\t\t\tif text1[i-1] == text2[j-1] {\n\t\t\t\tdp[i][j] = dp[i-1][j-1] + 1\n\t\t\t} else {\n\t\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[len(text1)][len(text2)]\n}\n\nfunc max(a int, b int) int {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/60#issuecomment-1666853377","body":"class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1] * n] + [[1] + [0] * (n - 1)] * (m - 1)\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/61#issuecomment-1667806728","body":"class Solution {\n    static int[][] dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};\n\n    public double knightProbability(int n, int k, int row, int column) {\n        double[][][] dp = new double[k + 1][n][n];\n        for (int step = 0; step <= k; step++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (step == 0) {\n                        dp[step][i][j] = 1;\n                    } else {\n                        for (int[] dir : dirs) {\n                            int ni = i + dir[0], nj = j + dir[1];\n                            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][row][column];\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/62#issuecomment-1669756957","body":"class Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        @cache\n        def dfs(usedNumbers: int, currentTotal: int) -> bool:\n            for i in range(maxChoosableInteger):\n                if (usedNumbers >> i) & 1 == 0:\n                    if currentTotal + i + 1 >= desiredTotal or not dfs(usedNumbers | (1 << i), currentTotal + i + 1):\n                        return True\n            return False\n\n        return (1 + maxChoosableInteger) * maxChoosableInteger // 2 >= desiredTotal and dfs(0, 0)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/63#issuecomment-1671428347","body":"class Solution {\n    public boolean canPartition(int[] nums) {\n        int n = nums.length;\n        if(n < 2){\n            return false;\n        }\n        int sum = 0, maxNum = 0;\n        for(int num: nums){\n            sum += num;\n            maxNum = Math.max(maxNum, num);\n        }\n        if(sum % 2 != 0){\n            return false;\n        }\n        int target = sum / 2;\n        if(maxNum > target){\n            return false;\n        }\n        boolean[] dp = new boolean[target+1];\n        dp[0] = true;\n        for(int i = 0; i<n; i++){\n            int num = nums[i];\n            for(int j= target; j >= num; j--){\n                dp[j] |= dp[j-num];\n            }\n        }\n        return dp[target];\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/64#issuecomment-1673471377","body":"class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for(int num:nums){\n            sum += num;\n        }\n        int diff = sum - target;\n        if(diff < 0 || diff % 2 != 0){\n            return 0;\n        }\n        int n = nums.length, neg = diff / 2;\n        int[][] dp = new int[n+1][neg+1];\n        dp[0][0] = 1;\n        for(int i = 1; i <= n; i++){\n            int num = nums[i - 1];\n            for(int j = 0; j <= neg; j++){\n                dp[i][j] = dp[i-1][j];\n                if(j >= num){\n                    dp[i][j] += dp[i-1][j-num];\n                }\n            }\n        }\n        return dp[n][neg];\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/65#issuecomment-1674801618","body":"var coinChange = function(coins, amount) {\ncoins.sort((a,b) => a-b);\nif (amount === 0) return 0;\nif (amount < coins[0]) return -1;\nlet ans = 999999;\nd(amount, coins.length - 1, 0, coins);\nfunction d(num, index, len, coins) {\nif (num === 0) {\nans = Math.min(ans, len);\nreturn;\n};\nif (index < 0) return;\nfor (let k=Math.floor(num / coins[index]); k >=0 && k + len < ans; k--) {\nd(num - coins[index] * k, index - 1, len + k, coins);\n}\n}\nreturn ans === 999999 ? -1 : ans;\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/67#issuecomment-1676370083","body":"class Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        #基本思想，用最大的饼干满足胃口最大的孩子\n        s.sort(reverse=True)\n        g.sort(reverse=True)\n        cnt = 0\n        i,j = 0,0 \n        while i<len(g) and j<len(s):\n            if g[i]<=s[j]:\n                cnt+=1\n                j+=1\n            i+=1\n        return cnt","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/68#issuecomment-1677511718","body":"class Solution {\n    func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {\n        let n = intervals.count\n    if n == 0 {\n        return 0\n    }\n    \n    var dp = [Int](repeating: 1, count: n)\n    var ans = 1\n    var sortedIntervals = intervals.sorted { $0[0] < $1[0] }\n    \n    for i in 0..<n {\n        for j in (0..<i).reversed() {\n            if sortedIntervals[i][0] >= sortedIntervals[j][1] {\n                dp[i] = max(dp[i], dp[j] + 1)\n                break // 由于是按照开始时间排序的，因此可以剪枝\n            }\n        }\n    }\n    \n    return n - dp.max()!\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/69#issuecomment-1679039412","body":"class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        m_max=0\n        n=len(nums)\n        for i in range(n-1):\n            if m_max<i:\n                return Fslse\n            m_max=max(m_max,nums[i]+i)\n            if m_max>=n-1:\n                return True\n        return m_max>=n-1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/70#issuecomment-1681467674","body":"for i in range(2, n+1):\n        for j in range(1, i+1):\n            G[i] += G[j-1] * G[i-j]\n    return G[n]","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/71#issuecomment-1681468018","body":"function mergeTwoLists(l1, l2) {\n  const dummyHead = {};\n  let current = dummyHead;\n  // l1: 1 -> 3 -> 5\n  // l2: 2 -> 4 -> 6\n  while (l1 !== null && l2 !== null) {\n    if (l1.val < l2.val) {\n      current.next = l1; // 把小的添加到结果链表\n      current = current.next; // 移动结果链表的指针\n      l1 = l1.next; // 移动小的那个链表的指针\n    } else {\n      current.next = l2;\n      current = current.next;\n      l2 = l2.next;\n    }\n  }\n\n  if (l1 === null) {\n    current.next = l2;\n  } else {\n    current.next = l1;\n  }\n  return dummyHead.next;\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/73#issuecomment-1685023521","body":"class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xorsum = 0\n        for num in nums:\n            xorsum ^= num\n        \n        lsb = xorsum & (-xorsum)\n        type1 = type2 = 0\n        for num in nums:\n            if num & lsb:\n                type1 ^= num\n            else:\n                type2 ^= num\n        \n        return [type1, type2]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/74#issuecomment-1685288147","body":"class Solution:\n    \n    def __init__(self):\n        self.res = []\n        # 记录回溯算法的递归路径\n        self.track = []\n\n    # 主函数\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        self.backtrack(nums, 0)\n        return self.res\n    \n    # 回溯算法核心函数，遍历子集问题的回溯树\n    def backtrack(self, nums: List[int], start: int) -> None:\n        \n        # 前序位置，每个节点的值都是一个子集\n        self.res.append(self.track[:])\n        \n        # 回溯算法标准框架\n        for i in range(start, len(nums)):\n            # 做选择\n            self.track.append(nums[i])\n            # 通过 start 参数控制树枝的遍历，避免产生重复的子集\n            self.backtrack(nums, i + 1)\n            # 撤销选择\n            self.track.pop()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/75#issuecomment-1686557791","body":"class TireNode:\n    def __init__(self):\n        self.count=0\n        self.perCount=0\n        self.children={}#字典\n\n\nclass Trie:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.root=TireNode()\n\n\n    def insert(self, word: str) -> None:\n        \"\"\"\n        Inserts a word into the trie.\n        \"\"\"\n        node=self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char]=TireNode()\n            node=node.children[char]\n            node.perCount+=1\n        node.count+=1\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/76#issuecomment-1688368314","body":"Map<String, Integer> prefixmap;\n    public MapSum() {\n        map = new HashMap<>();\n        prefixmap = new HashMap<>();\n    }\n    \n    public void insert(String key, int val) {\n        int detal = val - map.getOrDefault(key, 0);\n        map.put(key, val);\n        for(int i = 1; i<=key.length(); i++){\n            String cur = key.substring(0,i);\n            prefixmap.put(cur, prefixmap.getOrDefault(cur, 0) +detal);\n        }\n    }\n    \n    public int sum(String prefix) {\n        return prefixmap.getOrDefault(prefix, 0);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/77#issuecomment-1690031920","body":"class Solution {\n\n    private var root = Node()\n\n    func multiSearch(_ big: String, _ smalls: [String]) -> [[Int]] {\n\n        let n = smalls.count\n        // 初始化结果集\n        var res = [[Int]](repeating: [], count: n)\n        // 建树\n        for i in 0..<smalls.count {\n            insert(smalls[i], i)\n        }\n\n        for i in 0..<big.count {\n            var tmp = root\n            var j = i\n            while j < big.count {\n                let char = big[big.index(big.startIndex, offsetBy: j)]\n                // 不存在以该串为prefix的敏感词\n                if tmp.children[char] == nil {\n                    break\n                }\n\n                tmp = tmp.children[char]!\n\n                if tmp.isWord {\n                    res[tmp.id].append(i)\n                }\n\n                j += 1\n            }\n        }\n        // 返回二维数组\n        var ret = [[Int]]()\n\n        for i in 0..<n {\n            ret.append(res[i])\n        }\n\n        return ret\n    }\n\n    private func insert(_ word: String, _ id: Int) {\n\n        var tmp = root\n\n        for char in word {\n            if tmp.children[char] == nil {\n                tmp.children[char] = Node()\n            }\n\n            tmp = tmp.children[char]!\n        }\n\n        tmp.isWord = true\n        tmp.id = id\n    }\n\n    class Node {\n\n        var children: [Character: Node]\n        var isWord: Bool\n        var id: Int\n\n        init() {\n            children = [:]\n            isWord = false\n            id = 0\n        }\n    }\n}\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/79#issuecomment-1693592143","body":"class Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        root = [i for i in range(n)]\n\n        def find(p):\n            while p != root[p]:\n                root[p] = root[root[p]]\n                p = root[p]\n\n            return p\n\n        def union(p, q):\n            root[find(p)] = find(q)\n\n        have = 0\n        for connec in connections:\n            a, b = connec\n            if find(a) != find(b):\n                union(a, b)\n            else:\n                have += 1\n\n        diff_root = set()\n        for i in range(n):\n            diff_root.add(find(i))\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/80#issuecomment-1693591078","body":"class Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        root = [i for i in range(n)]\n\n        def find(p):\n            while p != root[p]:\n                root[p] = root[root[p]]\n                p = root[p]\n\n            return p\n\n        def union(p, q):\n            root[find(p)] = find(q)\n\n        have = 0\n        for connec in connections:\n            a, b = connec\n            if find(a) != find(b):\n                union(a, b)\n            else:\n                have += 1\n\n        diff_root = set()\n        for i in range(n):\n            diff_root.add(find(i))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/81#issuecomment-1694703163","body":" */\nclass Solution {\n    public TreeNode pruneTree(TreeNode root) {\n        if(root == null){\n            return null;\n        }\n        root.left = pruneTree(root.left);\n        root.right = pruneTree(root.right);\n        if(root.left == null && root.right == null && root.val == 0){\n            return null;\n        }\n        return root;\n    }\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/82#issuecomment-1694703293","body":" */\nclass Solution {\n    public TreeNode pruneTree(TreeNode root) {\n        if(root == null){\n            return null;\n        }\n        root.left = pruneTree(root.left);\n        root.right = pruneTree(root.right);\n        if(root.left == null && root.right == null && root.val == 0){\n            return null;\n        }\n        return root;\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/84#issuecomment-1699230193","body":"class Solution:\n    def __init__(self):\n        self.res = []  # 用于存储结果\n        self.track = []  # 用于存储路径\n        self.used = []  # 记录元素是否使用过\n\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        # 先排序，让相同的元素靠在一起\n        nums.sort()\n        self.used = [False] * len(nums)\n        self.backtrack(nums)\n        return self.res\n    \n    def backtrack(self, nums):\n        if len(self.track) == len(nums):\n            self.res.append(self.track.copy())\n            return\n        \n        for i in range(len(nums)):\n            if self.used[i]:\n                continue\n            # 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置\n            if i > 0 and nums[i] == nums[i - 1] and not self.used[i - 1]:\n                continue\n            self.track.append(nums[i])\n            self.used[i] = True\n            self.backtrack(nums)\n            self.track.pop()\n            self.used[i] = False","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/85#issuecomment-1700944353","body":"class Solution {\n    public int strStr(String ss, String pp) {\n        int n = ss.length(), m = pp.length();\n        char[] s = ss.toCharArray(), p = pp.toCharArray();\n        // 枚举原串的「发起点」\n        for (int i = 0; i <= n - m; i++) {\n            // 从原串的「发起点」和匹配串的「首位」开始，尝试匹配\n            int a = i, b = 0;\n            while (b < m && s[a] == p[b]) {\n                a++;\n                b++;\n            }\n            // 如果能够完全匹配，返回原串的「发起点」下标\n            if (b == m) return i;\n        }\n        return -1;\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/87#issuecomment-1703836333","body":"import heapq\n\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        n=len(nums)\n        h=[]\n        for i in range(k):\n            heapq.heappush(h,nums[i])\n        for i in range(k,n):\n            if nums[i]>h[0]:\n                heapq.heapreplace(h,nums[i])\n        return h[0]\n         ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/88#issuecomment-1704300849","body":"class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        h=[-stone for stone in stones]\n        heapq.heapify(h)\n        while len(h)>1:\n            a,b=heapq.heappop(h),heapq.heappop(h)\n            if a !=b:\n                heapq.heappush(h,a-b)\n        return -h[0] if h else 0","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/91#issuecomment-1708143018","body":"class Solution:\n    def notGreaterCount(self, matrix, target):\n        # 等价于在matrix中搜索mid，搜索的过程中利用有序的性质记录比mid小的元素个数\n\n        # 我们选择左下角，作为开始元素\n        curRow = 0\n        # 多少列\n        COL_COUNT = len(matrix[0])\n        # 最后一列的索引\n        LAST_COL = COL_COUNT - 1\n        res = 0\n\n        while curRow < len(matrix):\n            # 比较最后一列的数据和target的大小\n            if matrix[curRow][LAST_COL] < target:\n                res += COL_COUNT\n            else:\n                i = COL_COUNT - 1\n                while i >= 0 and matrix[curRow][i] > target:\n                    i -= 1\n                # 注意这里要加1\n                res += i + 1\n            curRow += 1\n\n        return res\n\n    def kthSmallest(self, matrix, k):\n        if len(matrix) < 1:\n            return None\n        start = matrix[0][0]\n        end = matrix[len(matrix) - 1][len(matrix[0]) - 1]\n        while start < end:\n            mid = start + ((end - start) >> 1)\n            count = self.notGreaterCount(matrix, mid)\n            if count < k:\n                start = mid + 1\n            else:\n                end = mid\n        # 返回start，mid，end都一样\n        return start","onTime":true},null,null],"kingxiaozhe":[null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586192063","body":"```javscript\nfunction shortestToChar(S, C) {\n  const result = [];\n\n  for (let i = 0; i < S.length; i++) {\n    let minDistance = Infinity;\n\n    for (let j = 0; j < S.length; j++) {\n      if (S[j] === C) {\n        minDistance = Math.min(minDistance, Math.abs(i - j));\n      }\n    }\n\n    result.push(minDistance);\n  }\n\n  return result;\n}\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587528078","body":"```javascript\nclass CustomStack {\n  constructor(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n    this.pointer = -1;\n  }\n\n  push(x) {\n    if (this.pointer < this.maxSize - 1) {\n      this.pointer++;\n      this.stack.push(x);\n    }\n  }\n\n  pop() {\n    if (this.pointer >= 0) {\n      this.pointer--;\n      return this.stack.pop();\n    }\n    return -1;\n  }\n\n  increment(k, val) {\n    for (let i = 0; i < Math.min(k, this.stack.length); i++) {\n      this.stack[i] += val;\n    }\n  }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589378515","body":"```javascript\nfunction decodeString(s) {\n  const stack = [];\n\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === ']') {\n      let decodedString = '';\n\n      // 解码内部的字符串\n      while (stack[stack.length - 1] !== '[') {\n        decodedString = stack.pop() + decodedString;\n      }\n\n      // 弹出左括号 '['\n      stack.pop();\n\n      let repeatCount = '';\n\n      // 获取重复次数\n      while (stack.length && !isNaN(stack[stack.length - 1])) {\n        repeatCount = stack.pop() + repeatCount;\n      }\n\n      repeatCount = Number(repeatCount);\n\n      // 将解码后的字符串重复指定次数并压入栈中\n      for (let j = 0; j < repeatCount; j++) {\n        stack.push(decodedString);\n      }\n    } else {\n      // 当前字符为数字、字母或左括号 '['，直接压入栈中\n      stack.push(s[i]);\n    }\n  }\n\n  // 将栈中的字符连接成最终的解码字符串\n  return stack.join('');\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591296442","body":"```javscript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n  this.stackPush = []; // 用于入队操作\n  this.stackPop = [];  // 用于出队操作\n};\n\n/**\n * Push element x to the back of queue.\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.stackPush.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  // 如果出队栈为空，则将入队栈的元素全部转移到出队栈中\n  if (this.stackPop.length === 0) {\n    while (this.stackPush.length) {\n      this.stackPop.push(this.stackPush.pop());\n    }\n  }\n\n  return this.stackPop.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  // 如果出队栈为空，则将入队栈的元素全部转移到出队栈中\n  if (this.stackPop.length === 0) {\n    while (this.stackPush.length) {\n      this.stackPop.push(this.stackPush.pop());\n    }\n  }\n\n  return this.stackPop[this.stackPop.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.stackPush.length === 0 && this.stackPop.length === 0;\n};\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594785799","body":"```javascript\nfunction ListNode(val) {\n  this.val = val;\n  this.next = null;\n}\n\nfunction rotateRight(head, k) {\n  if (!head || !head.next || k === 0) {\n    return head;\n  }\n\n  // 计算链表的长度\n  let length = 1;\n  let current = head;\n  while (current.next) {\n    current = current.next;\n    length++;\n  }\n\n  // 计算实际需要移动的步数\n  k = k % length;\n\n  if (k === 0) {\n    return head;\n  }\n\n  // 找到新链表的头结点的前一个节点\n  let newHeadPrev = head;\n  for (let i = 0; i < length - k - 1; i++) {\n    newHeadPrev = newHeadPrev.next;\n  }\n\n  // 将链表旋转\n  let newHead = newHeadPrev.next;\n  newHeadPrev.next = null;\n  current.next = head;\n\n  return newHead;\n}\n\n// 创建示例链表：1->2->3->4->5->NULL\nlet head = new ListNode(1);\nhead.next = new ListNode(2);\nhead.next.next = new ListNode(3);\nhead.next.next.next = new ListNode(4);\nhead.next.next.next.next = new ListNode(5);\n\nlet k = 2;\n\n// 旋转链表\nlet rotatedHead = rotateRight(head, k);\n\n// 输出结果\nlet result = '';\nwhile (rotatedHead) {\n  result += rotatedHead.val + '->';\n  rotatedHead = rotatedHead.next;\n}\nresult += 'NULL';\n\nconsole.log(result);\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595772418","body":"```javascript\nfunction ListNode(val, next) {\n  this.val = val;\n  this.next = next;\n}\n\nfunction swapPairs(head) {\n  const dummy = new ListNode(0);  // 创建虚拟头节点\n  dummy.next = head;\n  let prev = dummy;\n  let curr = head;\n\n  while (curr && curr.next) {\n    const node1 = curr;\n    const node2 = curr.next;\n\n    prev.next = node2;\n    node1.next = node2.next;\n    node2.next = node1;\n\n    prev = node1;\n    curr = node1.next;\n  }\n\n  return dummy.next;\n}\n\n// 创建链表 1->2->3->4\nconst head = new ListNode(1);\nhead.next = new ListNode(2);\nhead.next.next = new ListNode(3);\nhead.next.next.next = new ListNode(4);\n\n// 两两交换相邻节点\nconst newHead = swapPairs(head);\n\n// 输出交换后的链表\nlet currentNode = newHead;\nwhile (currentNode) {\n  console.log(currentNode.val);\n  currentNode = currentNode.next;\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596180660","body":"```javascript\n// 定义链表节点\nclass ListNode {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\n// 定义二叉树节点\nclass TreeNode {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n\n// 将有序链表转换为高度平衡的二叉搜索树\nfunction sortedListToBST(head) {\n  if (!head) return null;\n\n  const nums = [];\n  let curr = head;\n\n  // 将链表中的值存储到数组中\n  while (curr) {\n    nums.push(curr.val);\n    curr = curr.next;\n  }\n\n  // 构建二叉搜索树\n  function buildBST(left, right) {\n    if (left > right) return null;\n\n    const mid = Math.floor((left + right) / 2);\n    const root = new TreeNode(nums[mid]);\n\n    root.left = buildBST(left, mid - 1);\n    root.right = buildBST(mid + 1, right);\n\n    return root;\n  }\n\n  return buildBST(0, nums.length - 1);\n}\n\n// 创建链表 [-10, -3, 0, 5, 9]\nconst head = new ListNode(-10);\nhead.next = new ListNode(-3);\nhead.next.next = new ListNode(0);\nhead.next.next.next = new ListNode(5);\nhead.next.next.next.next = new ListNode(9);\n\n// 转换为二叉搜索树\nconst root = sortedListToBST(head);\n\n// 打印二叉搜索树\nfunction printBinaryTree(root) {\n  if (!root) return;\n  console.log(root.val);\n  printBinaryTree(root.left);\n  printBinaryTree(root.right);\n}\n\nprintBinaryTree(root);\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1597240942","body":"```javascript\nfunction getIntersectionNode(headA, headB) {\n  if (headA === null || headB === null) {\n    return null;\n  }\n  \n  let pointerA = headA;\n  let pointerB = headB;\n  \n  while (pointerA !== pointerB) {\n    pointerA = pointerA === null ? headB : pointerA.next;\n    pointerB = pointerB === null ? headA : pointerB.next;\n  }\n  \n  return pointerA;\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598991021","body":"```javascript\nfunction ListNode(val) {\n  this.val = val;\n  this.next = null;\n}\n\nfunction detectCycle(head) {\n  if (head === null || head.next === null) {\n    return null;\n  }\n\n  let slow = head;\n  let fast = head;\n  let hasCycle = false;\n\n  while (fast !== null && fast.next !== null) {\n    slow = slow.next;\n    fast = fast.next.next;\n\n    if (slow === fast) {\n      hasCycle = true;\n      break;\n    }\n  }\n\n  if (!hasCycle) {\n    return null;\n  }\n\n  slow = head;\n  while (slow !== fast) {\n    slow = slow.next;\n    fast = fast.next;\n  }\n\n  return slow;\n}\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604341869","body":"```javascript\nfunction TreeNode(val, left, right) {\n  this.val = (val === undefined ? 0 : val);\n  this.left = (left === undefined ? null : left);\n  this.right = (right === undefined ? null : right);\n}\n\nfunction isSameTree(p, q) {\n  if (!p && !q) {\n    // 两个节点都为空，认为它们是相同的\n    return true;\n  }\n  if (!p || !q || p.val !== q.val) {\n    // 如果其中一个节点为空，或者节点的值不相等，认为它们不相同\n    return false;\n  }\n  // 递归检查左子树和右子树\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607651961","body":"```javascript\nfunction serialize(root) {\n  if (!root) {\n    return 'null'; // 空节点表示为字符串'null'\n  }\n\n  const left = serialize(root.left); // 序列化左子树\n  const right = serialize(root.right); // 序列化右子树\n\n  return root.val + ',' + left + ',' + right; // 节点值、左子树、右子树以逗号分隔\n}\n\nfunction deserialize(data) {\n  const nodes = data.split(','); // 将序列化后的字符串拆分成节点数组\n  return buildTree(nodes); // 构建二叉树\n}\n\nfunction buildTree(nodes) {\n  const val = nodes.shift(); // 取出第一个节点值\n\n  if (val === 'null') {\n    return null; // 'null'表示空节点\n  }\n\n  const root = new TreeNode(parseInt(val)); // 创建当前节点\n\n  root.left = buildTree(nodes); // 递归构建左子树\n  root.right = buildTree(nodes); // 递归构建右子树\n\n  return root;\n}\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615886925","body":"```javascript\nfunction lengthOfLongestSubstring(s) {\n  let maxLength = 0;\n  let start = 0;\n  const charMap = {};\n\n  for (let end = 0; end < s.length; end++) {\n    const currentChar = s[end];\n\n    if (charMap[currentChar] >= start) {\n      start = charMap[currentChar] + 1;\n    }\n\n    charMap[currentChar] = end;\n    const currentLength = end - start + 1;\n    maxLength = Math.max(maxLength, currentLength);\n  }\n\n  return maxLength;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616657979","body":"```javascript\nfunction findSubstring(s, words) {\n  const result = [];\n  const wordCount = words.length;\n  const wordLength = words[0].length;\n  const totalLength = wordCount * wordLength;\n  \n  if (s.length < totalLength) {\n    return result;\n  }\n  \n  const wordMap = {};\n  for (let word of words) {\n    if (wordMap[word]) {\n      wordMap[word]++;\n    } else {\n      wordMap[word] = 1;\n    }\n  }\n  \n  for (let i = 0; i <= s.length - totalLength; i++) {\n    const substring = s.substr(i, totalLength);\n    const substringMap = {};\n    let j = 0;\n    \n    while (j < totalLength) {\n      const currentWord = substring.substr(j, wordLength);\n      if (!wordMap[currentWord]) {\n        break;\n      }\n      \n      if (substringMap[currentWord]) {\n        substringMap[currentWord]++;\n      } else {\n        substringMap[currentWord] = 1;\n      }\n      \n      if (substringMap[currentWord] > wordMap[currentWord]) {\n        break;\n      }\n      \n      j += wordLength;\n    }\n    \n    if (j === totalLength) {\n      result.push(i);\n    }\n  }\n  \n  return result;\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1618716663","body":"```javascript\nfunction minSubarray(nums, p) {\n  const n = nums.length;\n  let target = 0;\n  for (let i = 0; i < n; i++) {\n    target = (target + nums[i]) % p; // 计算数组元素和对 p 取模\n  }\n  \n  if (target === 0) {\n    return 0; // 如果数组元素和能够整除 p，不需要移除任何元素\n  }\n  \n  const map = new Map(); // 用于记录出现过的余数及其最早出现的索引\n  map.set(0, -1); // 初始化，数组为空时余数为 0 的索引为 -1\n  let currSum = 0;\n  let minLen = n; // 最短子数组长度，默认为数组长度\n  \n  for (let i = 0; i < n; i++) {\n    currSum = (currSum + nums[i]) % p; // 计算当前位置之前的子数组元素和对 p 取模\n    const complement = (currSum - target + p) % p; // 计算当前位置之前的子数组元素和与目标余数的差值\n    \n    if (map.has(complement)) {\n      const len = i - map.get(complement); // 当前位置与之前出现的该余数的位置之间的子数组长度\n      minLen = Math.min(minLen, len); // 更新最短子数组长度\n    }\n    \n    map.set(currSum, i); // 记录当前余数及其索引\n  }\n  \n  return minLen < n ? minLen : -1; // 返回最短子数组长度，如果最短子数组长度等于数组长度，则说明无法满足要求，返回 -1\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ygnauh":[null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586224029","body":"思路：<br>\n1.初始化一个结果数组 res，将其中的每个元素赋值为一个足够大的数。\n2.遍历字符串 S，并判断每个位置上的字符是否为目标字符 C：\n如果是，则将当前位置的 res 值赋为 0。\n如果不是，则分别从左右两个方向开始遍历，记录距离当前位置最近的目标字符的距离，并更新 res 值。\n3.返回结果数组 res。\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int n = S.length();\n        int[] res = new int[n];\n        Arrays.fill(res, n);\n        int pos = -n;\n        for (int i = 0; i < n; i++) {\n            if (S.charAt(i) == C) pos = i;\n            res[i] = Math.min(res[i], i - pos);\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            if (S.charAt(i) == C) pos = i;\n            res[i] = Math.min(res[i], pos - i);\n        }\n        return res;\n    }\n}\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593314218","body":"def maxChunksToSorted(arr) -> int:\n        n = len(arr)\n        i_max, i_min = [-1] * n, [float('inf')] * n\n\n        # Calculate max values from the start to current position\n        i_max[0] = arr[0]\n        for i in range(1, n):\n            i_max[i] = max(i_max[i-1], arr[i])\n        print(\"maximum value from 0 to i\", i_max)\n        # Calculate min values from the end to current position\n        i_min[-1] = arr[-1]\n        for i in range(n-2, -1, -1):\n            i_min[i] = min(i_min[i+1], arr[i])\n        print(\"minimum value from 0 to i\", i_min)\n        # Count all chunk points\n        \n\n        return sum(i_max[i] <= i_min[i+1] for i in range(n-1)) + 1\n\n\nprint(maxChunksToSorted([2,1,2,5,3,4,4]))\n\n复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzbwzt":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1586695111","body":"/*\r\n思路：\r\n逐位相加:\r\n再反转\r\n\r\n复杂度：\r\n空间复杂度:O(N)\r\n时间复杂度:O(N)\r\n*/\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\tout := make([]int, 0)\r\n\tfor i := len(num) - 1; i >= 0; i-- {\r\n\t\tv := k % 10\r\n\t\tk /= 10\r\n\t\tsum := num[i] + v\r\n\t\tif sum >= 10 {\r\n\t\t\tk += 1\r\n\t\t}\r\n\t\tout = append(out, sum%10)\r\n\t}\r\n\r\n\tfor ; k > 0; k /= 10 {\r\n\t\tout = append(out, k%10)\r\n\t}\r\n\r\n\treverse(out)\r\n\treturn out\r\n}\r\n\r\nfunc reverse(a []int) {\r\n\tn := len(a)\r\n\tfor i := 0; i < n/2; i++ {\r\n\t\ta[i], a[n-i-1] = a[n-i-1], a[i]\r\n\t}\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586225246","body":"/*\r\n思路：\r\n遍历数组\r\n\r\n\r\n复杂度：\r\n空间复杂度为 O(n)\r\n时间复杂度为 O(n)\r\n*/\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n\tn := len(s)\r\n\tres := make([]int, n)\r\n\r\n\tl := 0\r\n\tif s[0] != c {\r\n\t\tl = n\r\n\t}\r\n\tr := strings.IndexByte(s[1:], c) + 1\r\n\r\n\tfor i := 0; i < n; i++ {\r\n\t\tres[i] = min(abs(i-l), abs(r-i))\r\n\t\tif i == r {\r\n\t\t\tl = r\r\n\t\t\tr = strings.IndexByte(s[l+1:], c) + l + 1\r\n\t\t}\r\n\t}\r\n\r\n\treturn res\r\n}\r\n\r\nfunc min(a, b int) int {\r\n\tif a < b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n\r\nfunc abs(a int) int {\r\n\tif a < 0 {\r\n\t\treturn -a\r\n\t}\r\n\treturn a\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586521473","body":"\r\n/*\r\n思路:\r\n前缀和思路：维护一个increDiff固定容量的数组，记录每次incre 操作的差值\r\npush时 increDiff: append(0)\r\nincrement(k,v)时 increDiff[k-1]+=v  (k =min(k,cnt))\r\npop时 out=list[cnt-1]+incretment[cnt-1]\r\nincrement[cnt-2]+=increment[cnt-1]\r\nre切割list,increment\r\n\r\n\r\n时间复杂度：全部都是 O(1)\r\n空间复杂度为 O(cnt)\r\n*/\r\n```go\r\ntype CustomStack struct {\r\n\tlist      []int\r\n\tcnt       int\r\n\tmaxsize   int\r\n\tincreDiff []int\r\n}\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n\treturn CustomStack{list: make([]int, 0, maxSize), cnt: 0, maxsize: maxSize, increDiff: make([]int, 0, maxSize)}\r\n}\r\n\r\nfunc (c *CustomStack) Push(x int) {\r\n\tif c.cnt == c.maxsize {\r\n\t\treturn\r\n\t}\r\n\tc.list = append(c.list, x)\r\n\tc.increDiff = append(c.increDiff, 0)\r\n\tc.cnt++\r\n}\r\n\r\nfunc (c *CustomStack) Pop() int {\r\n\tif c.cnt == 0 {\r\n\t\treturn -1\r\n\t}\r\n\tout := c.list[c.cnt-1] + c.increDiff[c.cnt-1]\r\n\r\n\tc.list = c.list[:c.cnt-1]\r\n\tif c.cnt >= 2 {\r\n\t\tc.increDiff[c.cnt-2] += c.increDiff[c.cnt-1]\r\n\t}\r\n\tc.increDiff = c.increDiff[:c.cnt-1]\r\n\r\n\tc.cnt--\r\n\treturn out\r\n}\r\n\r\nfunc (c *CustomStack) Increment(k int, val int) {\r\n\tif k > c.cnt {\r\n\t\tk = c.cnt\r\n\t}\r\n\tif k == 0 {\r\n\t\treturn\r\n\t}\r\n\tc.increDiff[k-1] += val\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1588621576","body":"/*\r\n思路:\r\n栈思路,遍历s,压入栈，遇到']'弹栈\r\n只有四种可能出现的字符: 字母\\ 数字(可能对位)\\ [ \\ ]\r\n\r\n复杂度：\r\n时间复杂度为O(n)\r\n空间复杂度为O(n)\r\n*/\r\n```go\r\nfunc decodeString(s string) string {\r\n\tstack := []string{}\r\n\tlast := []int{}\r\n\ttmpCount := \"\"\r\n\tfor _, v := range s {\r\n\t\tif unicode.IsDigit(v) {\r\n\t\t\ttmpCount += string(v)\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tif len(tmpCount) != 0 {\r\n\t\t\tstack = append(stack, tmpCount)\r\n\t\t\ttmpCount = \"\"\r\n\t\t}\r\n\r\n\t\tif v == '[' {\r\n\t\t\tlast = append(last, len(stack))\r\n\t\t}\r\n\t\tif v == ']' {\r\n\t\t\tnew := last[len(last)-1]\r\n\t\t\tnum := stack[new-1]\r\n\t\t\tvalue := make([]string, len(stack)-new-1)\r\n\t\t\tcopy(value, stack[new+1:])\r\n\t\t\tstack = stack[:new-1]\r\n\t\t\tnum_i, _ := strconv.Atoi(string(num))\r\n\t\t\tfor i := 0; i < num_i; i++ {\r\n\t\t\t\tstack = append(stack, strings.Join(value, \"\"))\r\n\t\t\t}\r\n\t\t\tlast = last[:len(last)-1]\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tstack = append(stack, string(v))\r\n\t}\r\n\treturn strings.Join(stack, \"\")\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590406033","body":"/*\r\n思路：\r\n栈：先入后出\r\n队列：先入先出\r\n使用双栈的来解决:instack,outstack\r\ninstack:每次push时入栈\r\noutstack:每次pop/peek时，弹栈；如果为空，先从instack依次弹栈，再入栈outstack\r\n\r\n复杂度：\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)\r\n*/\r\n\r\n```go\r\ntype MyQueue struct {\r\n\tinstack, outstack []int\r\n}\r\n\r\nfunc Constructor() MyQueue {\r\n\treturn MyQueue{}\r\n}\r\n\r\nfunc (m *MyQueue) Push(x int) {\r\n\tm.instack = append(m.instack, x)\r\n}\r\n\r\nfunc (m *MyQueue) in2out() {\r\n\tfor i := len(m.instack) - 1; i >= 0; i-- {\r\n\t\tm.outstack = append(m.outstack, m.instack[i])\r\n\t}\r\n\tm.instack = nil\r\n}\r\nfunc (m *MyQueue) Pop() int {\r\n\tif len(m.outstack) == 0 {\r\n\t\tm.in2out()\r\n\t}\r\n\tout := m.outstack[len(m.outstack)-1]\r\n\tm.outstack = m.outstack[:len(m.outstack)-1]\r\n\treturn out\r\n}\r\n\r\nfunc (m *MyQueue) Peek() int {\r\n\tif len(m.outstack) == 0 {\r\n\t\tm.in2out()\r\n\t}\r\n\treturn m.outstack[len(m.outstack)-1]\r\n}\r\n\r\nfunc (m *MyQueue) Empty() bool {\r\n\treturn len(m.instack) == 0 && len(m.outstack) == 0\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592705026","body":"/*\r\n思路：\r\n`单调栈`\r\n要想分割chunk，且对每个chunk进行排序后,与总的数组排序后一致，必然遵循的原则是，下一个chunk的最小值，比前一个chunk中的最大值还要大或者等于\r\n可以通过递减单调栈来解决\r\n遍历数组arr,入栈，如果push的值，比栈顶的值小，必然和其是属于同一个chunk,这里需要pop操作，直到大于栈顶得值为止，再入栈最大得那个值(第一个pop的值);\r\neg:[1,1,0,0,1]=>2;[5,1,1,8,1,6,5,9,7,8]=>1\r\n\r\n如果大于/等于栈顶的值，入栈,认为是一个新的chunk\r\n最终得到的栈的长度就是可以分割的max chunk的块数,其中每个数字表示当前chunk中得最大值\r\n\r\n\r\n复杂度:\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n*/\r\n```go\r\nfunc maxChunksToSorted(arr []int) int {\r\n\tstack := []int{}\r\n\tfor _, v := range arr {\r\n\t\tif len(stack) == 0 {\r\n\t\t\tstack = append(stack, v)\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tmax := stack[len(stack)-1]\r\n\t\tif max <= v {\r\n\t\t\tmax = v\r\n\t\t}\r\n\t\tfor len(stack) > 0 && stack[len(stack)-1] > v {\r\n\t\t\tstack = stack[:len(stack)-1]\r\n\t\t}\r\n\t\tstack = append(stack, max)\r\n\t}\r\n\treturn len(stack)\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594155478","body":"\r\n/*\r\n思路：\r\n`快慢指针`\r\neg. A -> B -> C -> D -> E 右移 2 位 D-E-A-B-C\r\n原则：不管移动多少，节点之间的相对位置是不变的\r\n规则：移动k位，倒数第k位会移动到首位,即D会移动到head，倒数第K+1位会移动到last\r\n注意：移动k位和移动k%len效果等同\r\n过程：通过快慢指针回去倒数第K+1个节点\r\n\r\n\r\n复杂度：\r\n时间复杂度：节点最多只遍历两遍，时间复杂度为 O(n)\r\n空间复杂度：未使用额外的空间，空间复杂度 O(1)\r\n*/\r\n```go\r\n// Definition for singly-linked list.\r\ntype ListNode struct {\r\n\tVal  int\r\n\tNext *ListNode\r\n}\r\n\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n\tif head == nil {\r\n\t\treturn nil\r\n\t}\r\n\tlength := 0\r\n\tc := head\r\n\tfor c != nil {\r\n\t\tlength++\r\n\t\tc = c.Next\r\n\t}\r\n\tk = k % length\r\n\tif k == 0 {\r\n\t\treturn head\r\n\t}\r\n\tvar slow, fast = head, head\r\n\tfor i := 0; i < k+1; i++ {\r\n\t\tfast = fast.Next\r\n\t}\r\n\tfor fast != nil {\r\n\t\tfast = fast.Next\r\n\t\tslow = slow.Next\r\n\t}\r\n\tnext := slow.Next\r\n\tslow.Next = nil\r\n\tout := next\r\n\tfor next.Next != nil {\r\n\t\tnext = next.Next\r\n\t}\r\n\tnext.Next = head\r\n\r\n\treturn out\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/9#issuecomment-1595669098","body":"/*\r\n思路：\r\nA->B->C->D\r\n注意：对于一个head node可能改变的链表，可以通过虚拟一个空节点来指代；\r\n两两交换时涉及到四个节点，prehead->A->B->C\r\n\r\n交换步骤：\r\n1. prehead->A->C\r\n2. B->A\r\n3. prehaed->B\r\n\r\n迭代交换\r\n\r\n\r\n复杂度：\r\n时间复杂度: O(n)\r\n空间复杂度：O(1)\r\n\r\n*/\r\n```go\r\n// Definition for singly-linked list.\r\ntype ListNode struct {\r\n\tVal  int\r\n\tNext *ListNode\r\n}\r\n\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn head\r\n\t}\r\n\tprehead := &ListNode{}\r\n\tprehead.Next = head\r\n\r\n\tpre := prehead\r\n\tcur := head\r\n\tfor cur != nil && cur.Next != nil {\r\n\t\tnext := cur.Next\r\n\t\tcur.Next = next.Next\r\n\t\tnext.Next = cur\r\n\t\tpre.Next = next\r\n\r\n\t\tpre = cur\r\n\t\tcur = cur.Next\r\n\t}\r\n\r\n\treturn prehead.Next\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1595995966","body":"/*\r\n思路：\r\n`快慢指针`\r\n前提：链表已经升序排序\r\n根据高度平衡的二叉树原则，可以先选取中间节点作为根节点,左边的都为左节点，右边的都为右节点\r\n对左右子链表再找中间节点,以此重复；\r\n通过快慢指针找到中间节点\r\n\r\n\r\n\r\n复杂度：\r\n空间复杂度：空间复杂度为 O(logn)\r\n时间复杂度：递归树的深度为 logn,每一层的基本操作数为 n,因此总的时间复杂度为O(nlogn)\r\n\r\n*/\r\n\r\n```go\r\n// Definition for singly-linked list.\r\ntype ListNode struct {\r\n\tVal  int\r\n\tNext *ListNode\r\n}\r\n\r\n// Definition for a binary tree node.\r\ntype TreeNode struct {\r\n\tVal   int\r\n\tLeft  *TreeNode\r\n\tRight *TreeNode\r\n}\r\n\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n\tif head == nil {\r\n\t\treturn nil\r\n\t}\r\n\tif head.Next == nil {\r\n\t\treturn &TreeNode{Val: head.Val}\r\n\t}\r\n\tif head.Next.Next == nil {\r\n\t\treturn &TreeNode{Val: head.Next.Val, Left: &TreeNode{Val: head.Val}}\r\n\t}\r\n\r\n\tvar pre *ListNode\r\n\tslow, fast := head, head\r\n\tfor fast != nil && fast.Next != nil {\r\n\t\tpre = slow\r\n\t\tslow = slow.Next\r\n\t\tfast = fast.Next.Next\r\n\t}\r\n\troot := &TreeNode{Val: slow.Val}\r\n\troot.Right = sortedListToBST(slow.Next)\r\n\r\n\tpre.Next = nil\r\n\troot.Left = sortedListToBST(head)\r\n\r\n\treturn root\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596439564","body":"/*\r\n思路：\r\n`双指针`\r\nlistA listB 从head开始遍历;因为长度可能不一样，所以首先需要消除长度差,可以listA 遍历完后，指针指向listB的head\r\n同理B一样，那么双指针走过的路程也就相同,速度一样，路程一样，那么一定会同时到达终点，\r\n此外如果相交的话，也就是存在后半程路程相同，那么AB指针相遇时，就是相交的点\r\n\r\n类型环形跑道，一个在内侧，一个在外侧，总距离都是1000米，起点不同，但是最后冲刺的直线跑道是相同的\r\n\r\n\r\n\r\n复杂度：\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n*/\r\n```go\r\n// Definition for singly-linked list.\r\ntype ListNode struct {\r\n\tVal  int\r\n\tNext *ListNode\r\n}\r\n\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n\tif headA == nil || headB == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tpA := headA\r\n\tpB := headB\r\n\r\n\tfor pA != pB {\r\n\t\tif pA == nil {\r\n\t\t\tpA = headB\r\n\t\t} else {\r\n\t\t\tpA = pA.Next\r\n\t\t}\r\n\r\n\t\tif pB == nil {\r\n\t\t\tpB = headA\r\n\t\t} else {\r\n\t\t\tpB = pB.Next\r\n\t\t}\r\n\t}\r\n\treturn pA\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602797264","body":"\r\n/*\r\n思路：\r\n`递归`\r\n产品经理法\r\n\r\n\r\n\r\n复杂度：\r\n时间复杂度： O(N)\r\n空间复杂度： O(N)\r\n\r\n*/\r\n```go\r\n// Definition for a binary tree node.\r\ntype TreeNode struct {\r\n\tVal   int\r\n\tLeft  *TreeNode\r\n\tRight *TreeNode\r\n}\r\n\r\nfunc maxDepth(root *TreeNode) int {\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\r\n\tnum_left := maxDepth(root.Left)\r\n\tnum_right := maxDepth(root.Right)\r\n\tif num_left < num_right {\r\n\t\treturn num_right + 1\r\n\t} else {\r\n\t\treturn num_left + 1\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1604393054","body":"\r\n/*\r\n思路：\r\n`递归`\r\n\r\n\r\n复杂度：\r\n时间复杂度： O(N)\r\n空间复杂度： O(h) 其中 h 为树的高度\r\n*/\r\n```go\r\n// Definition for a binary tree node.\r\ntype TreeNode struct {\r\n\tVal   int\r\n\tLeft  *TreeNode\r\n\tRight *TreeNode\r\n}\r\n\r\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\r\n\tif p == nil && q == nil {\r\n\t\treturn true\r\n\t}\r\n\r\n\tif p != nil && q != nil {\r\n\t\tif isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right) && p.Val == q.Val {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\treturn false\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605607544","body":"/*\r\n思路：\r\nDFS\r\n*/\r\n```go\r\n// Definition for a binary tree node.\r\n  type TreeNode struct {\r\n      Val int\r\n      Left *TreeNode\r\n      Right *TreeNode\r\n  }\r\n \r\n\r\nfunc dfs(root *TreeNode, prevSum int) int {\r\n    if root == nil {\r\n        return 0\r\n    }\r\n    sum := prevSum*10 + root.Val\r\n    if root.Left == nil && root.Right == nil {\r\n        return sum\r\n    }\r\n    return dfs(root.Left, sum) + dfs(root.Right, sum)\r\n}\r\n\r\nfunc sumNumbers(root *TreeNode) int {\r\n    return dfs(root, 0)\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1606141747","body":"\r\n/*\r\n 思路：\r\n `BFS`\r\n广度优先搜索:创建队列，放入待处理节点，创建数组记录已处理节点\r\n\r\n\r\n复杂度：\r\n时间复杂度： O(N), N 为树的节点数\r\n空间复杂度： O(Q)，其中 Q 为队列长度，最坏的情况是满二叉树，此时和 N 同阶，其中 N 为树的节点总数\r\n\r\n*/\r\n```go\r\n// Definition for a binary tree node.\r\ntype TreeNode struct {\r\n\tVal   int\r\n\tLeft  *TreeNode\r\n\tRight *TreeNode\r\n}\r\n\r\nfunc findBottomLeftValue(root *TreeNode) int {\r\n\tvar out int\r\n\tqueue := []*TreeNode{root}\r\n\tfor len(queue) > 0 {\r\n\t\tout = queue[0].Val\r\n\r\n\t\tsize := len(queue)\r\n\t\tfor i := 0; i < size; i++ {\r\n\t\t\tcur := queue[0]\r\n\t\t\tqueue = queue[1:]\r\n\r\n\t\t\tif cur.Left != nil {\r\n\t\t\t\tqueue = append(queue, cur.Left)\r\n\t\t\t}\r\n\t\t\tif cur.Right != nil {\r\n\t\t\t\tqueue = append(queue, cur.Right)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn out\r\n\r\n}\r\n```\r\n/*\r\n 思路：\r\n `DFS`\r\n深度优先搜索: 它从起始节点开始，沿着一条路径尽可能深地探索，直到到达最深处或无法继续前进时回溯，然后继续探索其他路径。DFS 可以用递归或栈来实现。\r\n\r\n\r\n复杂度：\r\n时间复杂度： O(N), N 为树的节点数\r\n空间复杂度： O(h), h 为树的高度\r\n\r\n*/\r\n\r\n// Definition for a binary tree node.\r\n```go\r\nfunc findBottomLeftValue2(root *TreeNode) int {\r\n\tvar maxdepth int\r\n\tvar out int = root.Val\r\n\r\n\tdfs(root, 0, &out, &maxdepth)\r\n\r\n\treturn out\r\n\r\n}\r\n\r\nfunc dfs(node *TreeNode, depth int, out *int, maxdepth *int) {\r\n\tif node == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tif depth > *maxdepth {\r\n\t\t*out = node.Val\r\n\t\t*maxdepth = depth\r\n\t}\r\n\r\n\tdfs(node.Left, depth+1, out, maxdepth)\r\n\tdfs(node.Right, depth+1, out, maxdepth)\r\n\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1609439595","body":"\r\n/*\r\n思路：\r\n`DFS`\r\n1.对每个节点创建坐标位置\r\n\r\n2.通过深度优先搜索, 定义两层哈希表:map[x]map[y][]int\r\n\r\n3.对x，y,先后排序，获取对应[x][y] 下的节点值,追加到构建返回返回参数\r\n\r\n复杂度:\r\n时间复杂度： O(NlogN)，其中 N 为树的节点总数。\r\n空间复杂度： O(N)，其中 N 为树的节点总数。\r\n*/\r\n```go\r\n// Definition for a binary tree node.\r\ntype TreeNode struct {\r\n\tVal   int\r\n\tLeft  *TreeNode\r\n\tRight *TreeNode\r\n}\r\n\r\nfunc verticalTraversal(root *TreeNode) (out [][]int) {\r\n\tcoords := make(map[int]map[int][]int, 0)\r\n\r\n\tdfs(root, 0, 0, coords)\r\n\r\n\tvar keyX []int\r\n\tfor x := range coords {\r\n\t\tkeyX = append(keyX, x)\r\n\t}\r\n\tsort.Ints(keyX)\r\n\r\n\tfor _, x := range keyX {\r\n\t\tvar keyY []int\r\n\t\tfor y := range coords[x] {\r\n\t\t\tkeyY = append(keyY, y)\r\n\t\t}\r\n\t\tsort.Ints(keyY)\r\n\r\n\t\tnodev := []int{}\r\n\t\tfor _, y := range keyY {\r\n\t\t\tsort.Ints(coords[x][y])\r\n\t\t\tnodev = append(nodev, coords[x][y]...)\r\n\t\t}\r\n\r\n\t\tout = append(out, nodev)\r\n\t}\r\n\treturn out\r\n}\r\n\r\nfunc dfs(node *TreeNode, x int, y int, coords map[int]map[int][]int) {\r\n\tif node == nil {\r\n\t\treturn\r\n\t}\r\n\t_, ok := coords[x]\r\n\tif !ok {\r\n\t\tcoords[x] = map[int][]int{y: {}}\r\n\t}\r\n\tcoords[x][y] = append(coords[x][y], node.Val)\r\n\r\n\tdfs(node.Left, x-1, y+1, coords)\r\n\tdfs(node.Right, x+1, y+1, coords)\r\n} \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1610744205","body":"/*\r\n思路：\r\n`双指针`\r\n\r\n\r\n复杂度：\r\n空间复杂度: O(1)\r\n时间复杂度： O(n^2), n为数组长度\r\n*/\r\n```go\r\nfunc twoSum(nums []int, target int) (out []int) {\r\n\tfor i, v := range nums {\r\n\t\tfor j := i + 1; j < len(nums); j++ {\r\n\t\t\tif v+nums[j] == target {\r\n\t\t\t\tout = append(out, i, j)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n```\r\n/*\r\n思路：\r\n`哈希表`\r\n空间换时间\r\n\r\n复杂度：\r\n空间复杂度: O(n)\r\n时间复杂度： O(n), n为数组长度\r\n*/\r\n```go\r\nfunc twoSum2(nums []int, target int) (out []int) {\r\n\ttarger_map := make(map[int]int)\r\n\tfor i, v := range nums {\r\n\t\tindex, ok := targer_map[v]\r\n\t\tif ok {\r\n\t\t\tout = append(out, i, index)\r\n\t\t\treturn\r\n\t\t}\r\n\t\ttarger_map[target-v] = i\r\n\t}\r\n\treturn\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1613373015","body":"/*\r\n思路：\r\n`哈希表` `桶排序`\r\n\r\n复杂度：\r\n时间复杂度: O(N), N为数组长度\r\n空间复杂度: O(N), N为数组长度\r\n*/\r\n```go\r\nfunc topKFrequent(nums []int, k int) []int {\r\n\tcounter := make(map[int]int, 0)\r\n\tfor _, v := range nums {\r\n\t\tcounter[v]++\r\n\t}\r\n\tbuckets := make([][]int, len(nums)+1)\r\n\tfor value, count := range counter {\r\n\t\tbuckets[count] = append(buckets[count], value)\r\n\t}\r\n\tout := make([]int, 0)\r\n\tc := 0\r\n\tfor i := len(nums); i > 0; i-- {\r\n\t\tif len(buckets[i]) > 0 {\r\n\t\t\tout = append(out, buckets[i]...)\r\n\t\t\tc += len(buckets[i])\r\n\t\t}\r\n\t\tif c == k {\r\n\t\t\tbreak\r\n\t\t}\r\n\r\n\t}\r\n\treturn out\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614400286","body":"/*\r\n思路：\r\n假设有m个点到point[i]的位置相同，那么考虑顺序的情况下，从m中选两个的组合为\r\n$A_{m}^{2}=m*(m-1)$\r\n\r\n通过哈希表key存储距离,value存储节点数量\r\n\r\n\r\n复杂度：\r\n时间复杂度:O(n^2)\r\n空间复杂度:O(n)\r\n*/\r\n```go\r\nfunc numberOfBoomerangs(points [][]int) int {\r\n\tif len(points) < 3 {\r\n\t\treturn 0\r\n\t}\r\n\tvar out int\r\n\r\n\tfor _, point_i := range points {\r\n\t\tcounter := make(map[int]int, 0)\r\n\t\tfor _, point_j := range points {\r\n\t\t\tdistance := math.Pow(float64(point_j[0]-point_i[0]), 2) + math.Pow(float64(point_j[1]-point_i[1]), 2)\r\n\t\t\tcounter[int(distance)] += 1\r\n\t\t}\r\n\r\n\t\tfor _, count := range counter {\r\n\t\t\tout += count * (count - 1)\r\n\t\t}\r\n\t}\r\n\treturn out\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616710475","body":"\r\n/*\r\n思路：\r\n`哈希表` `双指针`\r\n\r\n\r\n\r\n复杂度：\r\n时间复杂度: O(n∗m∗k)  n: 字符串 S 长度, m:words 数组元素个数, k: 为单个 word 字串长度。\r\n空间复杂度: O(m)\r\n*/\r\n```go\r\nfunc findSubstring(s string, words []string) []int {\r\n\tres := []int{}\r\n\twordCount := len(words)\r\n\tif wordCount == 0 {\r\n\t\treturn res\r\n\t}\r\n\r\n\twordMap := make(map[string]int)\r\n\tfor _, word := range words {\r\n\t\twordMap[word]++\r\n\t}\r\n\r\n\tsLen := len(s)\r\n\twordLen := len(words[0])\r\n\r\n\tfor i := 0; i < sLen-wordLen*wordCount+1; i++ {\r\n\t\tcur := s[i : i+wordLen*wordCount]\r\n\t\ttemp := make(map[string]int)\r\n\t\tj := 0\r\n\r\n\t\tfor j < len(cur) {\r\n\t\t\tword := cur[j : j+wordLen]\r\n\t\t\tif _, ok := wordMap[word]; !ok {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\r\n\t\t\ttemp[word]++\r\n\t\t\tif temp[word] > wordMap[word] {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\r\n\t\t\tj += wordLen\r\n\t\t}\r\n\r\n\t\tif j == len(cur) {\r\n\t\t\tres = append(res, i)\r\n\t\t}\r\n\t}\r\n\r\n\treturn res\r\n}\r\n```\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1619609081","body":"/*\r\n思路：\r\n`双指针`\r\nslow走一步,fast走两步\r\n\r\n复杂度：\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n*/\r\n```go\r\n// Definition for singly-linked list.\r\ntype ListNode struct {\r\n\tVal  int\r\n\tNext *ListNode\r\n}\r\n\r\nfunc middleNode(head *ListNode) *ListNode {\r\n\tslow, fast := head, head\r\n\tfor fast != nil && fast.Next != nil {\r\n\t\tslow = slow.Next\r\n\t\tfast = fast.Next.Next\r\n\t}\r\n\treturn slow\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1621376712","body":"/*\r\n思路：\r\n`双指针`\r\nslow,fast\r\n\r\n\r\n复杂度：\r\n时间复杂度: O(n)\r\n空间复杂度: O(1)\r\n\r\n*/\r\n```go\r\nfunc removeDuplicates(nums []int) int {\r\n\tif len(nums) == 0 {\r\n\t\treturn 0\r\n\t}\r\n\tslow, fast := 0, 0\r\n\tfor fast < len(nums) {\r\n\t\tif nums[slow] == nums[fast] {\r\n\t\t\tfast++\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tnums[slow+1] = nums[fast]\r\n\t\tfast++\r\n\t\tslow++\r\n\t}\r\n\t// nums = nums[:slow+1]\r\n\treturn slow + 1\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/28#issuecomment-1623640776","body":"\r\n/*\r\n思路：\r\n`双指针`\r\n\r\n\r\n复杂度：\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n*/\r\n```go\r\nfunc searchInsert(nums []int, target int) int {\r\n\tif len(nums) == 0 {\r\n\t\treturn 0\r\n\t}\r\n\tslow, fast := 0, 0\r\n\tfor fast < len(nums) {\r\n\t\tif nums[slow] < target {\r\n\t\t\tslow++\r\n\t\t}\r\n\t\tif nums[fast] == target {\r\n\t\t\treturn fast\r\n\t\t}\r\n\t\tfast++\r\n\t}\r\n\r\n\treturn slow\r\n}\r\n```\r\n/*\r\n思路：\r\n`二分`\r\n\r\n复杂度：\r\n时间复杂度：O(logn)\r\n空间复杂度：O(1)\r\n*/\r\n```go\r\nfunc searchInsert2(nums []int, target int) int {\r\n\tif len(nums) == 0 {\r\n\t\treturn 0\r\n\t}\r\n\tleft, right := 0, len(nums)-1\r\n\tfor left <= right {\r\n\t\tmiddle := (right-left)>>1 + left\r\n\t\tif nums[middle] == target {\r\n\t\t\treturn middle\r\n\t\t}\r\n\r\n\t\tif nums[middle] < target {\r\n\t\t\tleft = middle + 1\r\n\t\t} else {\r\n\t\t\tright = middle - 1\r\n\t\t}\r\n\t}\r\n\treturn left + 1\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1625605813","body":"\r\n/*\r\n思路：\r\n`单调栈`\r\n\r\n复杂度：\r\n时间复杂度: O(n)\r\n空间复杂度: O(k)\r\n*/\r\n```go\r\nfunc maxSlidingWindow(nums []int, k int) []int {\r\n\tq := []int{}\r\n\tpush := func(i int) {\r\n\t\tfor len(q) > 0 && nums[i] >= nums[q[len(q)-1]] {\r\n\t\t\tq = q[:len(q)-1]\r\n\t\t}\r\n\t\tq = append(q, i)\r\n\t}\r\n\r\n\tfor i := 0; i < k; i++ {\r\n\t\tpush(i)\r\n\t}\r\n\r\n\tn := len(nums)\r\n\tans := make([]int, 1, n-k+1)\r\n\tans[0] = nums[q[0]]\r\n\tfor i := k; i < n; i++ {\r\n\t\tpush(i)\r\n\t\tfor q[0] <= i-k {\r\n\t\t\tq = q[1:]\r\n\t\t}\r\n\t\tans = append(ans, nums[q[0]])\r\n\t}\r\n\treturn ans\r\n}\r\n```\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627736616","body":"/*\r\n思路：\r\n`DFS`\r\n\r\n复杂度：\r\n时间复杂度：O(n+m)\r\n空间复杂度：O(n+m)\r\n*/\r\n```go\r\nfunc possibleBipartition(n int, dislikes [][]int) bool {\r\n    g := make([][]int, n)\r\n    for _, d := range dislikes {\r\n        x, y := d[0]-1, d[1]-1\r\n        g[x] = append(g[x], y)\r\n        g[y] = append(g[y], x)\r\n    }\r\n    color := make([]int, n) // color[x] = 0 表示未访问节点 x\r\n    var dfs func(int, int) bool\r\n    dfs = func(x, c int) bool {\r\n        color[x] = c\r\n        for _, y := range g[x] {\r\n            if color[y] == c || color[y] == 0 && !dfs(y, 3^c) {\r\n                return false\r\n            }\r\n        }\r\n        return true\r\n    }\r\n    for i, c := range color {\r\n        if c == 0 && !dfs(i, 1) {\r\n            return false\r\n        }\r\n    }\r\n    return true\r\n}\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1635713779","body":"\r\n/*\r\n思路：\r\n\r\n复杂度：\r\n时间复杂度：O(1)\r\n空间复杂度: O(1)\r\n*/\r\n```go\r\nfunc judgeCircle(moves string) bool {\r\n\tx, y := 0, 0\r\n\tfor _, move := range moves {\r\n\t\tswitch move {\r\n\t\tcase 'R':\r\n\t\t\tx++\r\n\t\tcase 'L':\r\n\t\t\tx--\r\n\t\tcase 'U':\r\n\t\t\ty++\r\n\t\tcase 'D':\r\n\t\t\ty--\r\n\t\t}\r\n\t}\r\n\r\n\treturn x == 0 && y == 0\r\n}\r\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1634094783","body":"/*\r\n思路：\r\n\r\n复杂度：\r\nO(1)\r\nO(1)\r\n*/\r\n```go\r\nfunc numberOfRounds(loginTime string, logoutTime string) int {\r\n\tin_t := strings.Split(loginTime, \":\")\r\n\tout_t := strings.Split(logoutTime, \":\")\r\n\tif len(in_t) != 2 || len(out_t) != 2 {\r\n\t\treturn 0\r\n\t}\r\n\tin_h_tmp, in_m_tmp := in_t[0], in_t[1]\r\n\tout_h_tmp, out_m_tmp := out_t[0], out_t[1]\r\n\r\n\tin_h, _ := strconv.Atoi(in_h_tmp)\r\n\tin_m, _ := strconv.Atoi(in_m_tmp)\r\n\tout_h, _ := strconv.Atoi(out_h_tmp)\r\n\tout_m, _ := strconv.Atoi(out_m_tmp)\r\n\r\n\tif in_h > out_h || (in_h == out_h && in_m > out_m) {\r\n\t\tout_h += 24\r\n\t}\r\n\tif in_h == out_h && in_m < out_m {\r\n\t\tif (in_m+15)/15*15 > out_m {\r\n\t\t\treturn 0\r\n\t\t}\r\n\t}\r\n\r\n\tif 0 < in_m && in_m <= 15 {\r\n\t\tin_m = 15\r\n\t}\r\n\r\n\tif 15 < in_m && in_m <= 30 {\r\n\t\tin_m = 30\r\n\t}\r\n\r\n\tif 30 < in_m && in_m <= 45 {\r\n\t\tin_m = 45\r\n\t}\r\n\r\n\tif 45 < in_m && in_m <= 59 {\r\n\t\tin_m = 00\r\n\t\tif in_h == out_h && in_m < out_m {\r\n\t\t\treturn 0\r\n\t\t}\r\n\r\n\t\tin_h++\r\n\t}\r\n\r\n\tif 0 <= out_m && out_m < 15 {\r\n\t\tout_m = 0\r\n\t}\r\n\tif 15 < out_m && out_m < 30 {\r\n\t\tout_m = 15\r\n\t}\r\n\tif 30 < out_m && out_m < 45 {\r\n\t\tout_m = 30\r\n\t}\r\n\r\n\tif 45 < out_m && out_m <= 59 {\r\n\t\tout_m = 45\r\n\t}\r\n\r\n\toffset := 0\r\n\tif out_m < in_m {\r\n\t\tif in_h == out_h {\r\n\t\t\tout_h += 24\r\n\t\t}\r\n\t\toffset = (in_m - out_m) / 15\r\n\t\tout_m = in_m\r\n\t}\r\n\treturn (out_h-in_h)*4 + (out_m-in_m)/15 - offset\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635661817","body":"/*\r\n思路：\r\n第一个条件：枚举，A的最大元素要小于B的最小元素;第二个条件:A,B交换位置\r\n注意：枚举时从b开始，因为a是最小的元素\r\n\r\n\r\n复杂度：\r\n时间复杂度：O(m+n)\r\n空间复杂度：O(26)\r\n\r\n*/\r\n```go\r\nfunc minCharacters(a string, b string) int {\r\n\tcountA := [26]int{}\r\n\tcountB := [26]int{}\r\n\tfor _, v := range a {\r\n\t\tcountA[v-'a']++\r\n\t}\r\n\r\n\tfor _, v := range b {\r\n\t\tcountB[v-'a']++\r\n\t}\r\n\tlength := len(a) + len(b)\r\n\tans := length\r\n\tfor i := 0; i < 26; i++ {\r\n\t\tans = min(ans, length-countA[i]-countB[i])\r\n\t}\r\n\r\n\tfor i := 1; i < 26; i++ {\r\n\t\tt := 0\r\n\t\tfor j := i; j < 26; j++ {\r\n\t\t\tt += countA[j]\r\n\t\t}\r\n\r\n\t\tfor j := 0; j < i; j++ {\r\n\t\t\tt += countB[j]\r\n\t\t}\r\n\r\n\t\tans = min(ans, t)\r\n\t}\r\n\r\n\tfor i := 1; i < 26; i++ {\r\n\t\tt := 0\r\n\t\tfor j := i; j < 26; j++ {\r\n\t\t\tt += countB[j]\r\n\t\t}\r\n\r\n\t\tfor j := 0; j < i; j++ {\r\n\t\t\tt += countA[j]\r\n\t\t}\r\n\r\n\t\tans = min(ans, t)\r\n\t}\r\n\r\n\treturn ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n\tif a < b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/38#issuecomment-1637107697","body":"/*\r\n思路：\r\n 归并排序\r\n复杂度：\r\n\r\n*/\r\n```go\r\n\r\nvar temp []int\r\n\r\nfunc sortArray(nums []int) []int {\r\n    if len(nums) == 0 {\r\n        return nums\r\n    }\r\n    temp = make([]int, len(nums))\r\n\r\n    sort(&nums, 0, len(nums)-1)\r\n    return nums\r\n}\r\n\r\nfunc sort(nums *[]int, lo int, hi int) {\r\n    if lo == hi {\r\n        return\r\n    }\r\n\r\n    mid := (lo + hi) / 2\r\n    sort(nums, lo, mid)\r\n    sort(nums, mid+1, hi)\r\n    merge(nums, lo, mid, hi)\r\n\r\n}\r\n\r\nfunc merge(nums *[]int, lo, mid, hi int) {\r\n    i, j := lo, mid+1\r\n    \r\n    for p := lo; p <= hi; p++ {\r\n        if i == mid + 1 {\r\n            temp[p] = (*nums)[j]\r\n            j++\r\n        } else if j == hi +1 {\r\n            temp[p] = (*nums)[i]\r\n            i++\r\n        } else if (*nums)[i] > (*nums)[j] { \r\n             temp[p] = (*nums)[j]\r\n            j++\r\n        } else {\r\n             temp[p] =(*nums)[i]\r\n            i++\r\n        }\r\n    }\r\n    \r\n    for k := lo; k <= hi ; k++ {\r\n        (*nums)[k] = temp[k]\r\n    }\r\n   \r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637106882","body":"/*\r\n思路：\r\n二分\r\n\r\n复杂度：\r\n时间复杂度：O(log⁡x)即为二分查找需要的次数。\r\n\r\n空间复杂度：O(1)\r\n*/\r\n```go\r\nfunc mySqrt(x int) int {\r\n    l, r := 0, x\r\n    ans := -1\r\n    for l <= r {\r\n        mid := l + (r - l) / 2\r\n        if mid * mid <= x {\r\n            ans = mid\r\n            l = mid + 1\r\n        } else {\r\n            r = mid - 1\r\n        }\r\n    }\r\n    return ans\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637306826","body":"/*\r\n思路：\r\n`二分法`\r\n典型的二分寻`找最左边的满足条件的值`。\r\n一句话概括就是：寻找最左边和寻找指定值的差别就是碰到等于号的处理情况。 如果是寻找最左边那么碰到等于继续收缩右边界（寻找最右边就是收缩左边界），查找指定值则是直接返回。\r\n\r\n复杂度：\r\n时间复杂度： O(logN)\r\n空间复杂度： O(1)\r\n*/\r\n```go\r\n/**\r\n * Forward declaration of isBadVersion API.\r\n * @param   version   your guess about first bad version\r\n * @return \t \t      true if current version is bad\r\n *\t\t\t          false if current version is good\r\n */\r\nfunc isBadVersion(version int) bool\r\n\r\nfunc firstBadVersion(n int) int {\r\n\tl, r := 1, n\r\n\tfor l <= r {\r\n\t\tmid := (l + r) / 2\r\n\t\tif isBadVersion(mid) {\r\n\t\t\tr = mid - 1\r\n\t\t} else {\r\n\t\t\tl = mid + 1\r\n\t\t}\r\n\t}\r\n\treturn l\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1639989995","body":"\r\n/*\r\n思路：\r\n`归并排序`\r\n在得到左右有序序列之后，合并左右有序序列之前,统计符合条件的对数\r\n\r\n复杂度：\r\n时间复杂度；O(nlogn)\r\n空间复杂度；O(n)\r\n*/\r\n```go\r\nfunc reversePairs(nums []int) int {\r\n\tif len(nums) == 0 {\r\n\t\treturn 0\r\n\t}\r\n\tcount := 0\r\n\tmergeSort(nums, &count, 0, len(nums)-1)\r\n\treturn count\r\n\r\n}\r\n\r\nfunc mergeSort(nums []int, count *int, start, end int) {\r\n\tif start == end {\r\n\t\treturn\r\n\t}\r\n\tmid := start + (end-start)>>1\r\n\r\n\tmergeSort(nums, count, start, mid)\r\n\tmergeSort(nums, count, mid+1, end)\r\n\r\n\t// 此时左右序列已升序，现在做：合并前的统计、以及合并\r\n\ti := start\r\n\tj := mid + 1\r\n\tfor i <= mid && j <= end { // i j 都不越界\r\n\t\tif nums[i] > 2*nums[j] {\r\n\t\t\t*count += mid - i + 1 // i 到 mid，都ok\r\n\t\t\tj++                   // 考察下一个j，继续找 i\r\n\t\t} else { // 当前i不满足，考察下一个i\r\n\t\t\ti++\r\n\t\t}\r\n\t}\r\n\ti = start\r\n\tj = mid + 1 // 复原 i j 指针，因为现在要合并左右序列\r\n\r\n\ttemp := make([]int, end-start+1) // 辅助数组，存放合并排序的数\r\n\tindex := 0                       // 从0开始\r\n\tfor i <= mid && j <= end {       // 如果 i j 都没越界\r\n\t\tif nums[i] < nums[j] { // nums[i]更小\r\n\t\t\ttemp[index] = nums[i] // 取nums[i]，确定了temp[index]\r\n\t\t\tindex++               // 确定下一个\r\n\t\t\ti++                   // 考察下一个i，j不动\r\n\t\t} else {\r\n\t\t\ttemp[index] = nums[j]\r\n\t\t\tindex++\r\n\t\t\tj++\r\n\t\t}\r\n\t}\r\n\tfor i <= mid { // 如果 i 没越界，j越界了\r\n\t\ttemp[index] = nums[i] // i 和 i右边的都取过来\r\n\t\tindex++               // 确定下一个数\r\n\t\ti++\r\n\t}\r\n\tfor j <= end { // j 没越界，i越界了\r\n\t\ttemp[index] = nums[j] // j 和 j右边的都取过来\r\n\t\tindex++               // 确定下一个数\r\n\t\tj++\r\n\t}\r\n\tk := 0\r\n\tfor i := start; i <= end; i++ { // 根据合并后的情况，更新nums\r\n\t\tnums[i] = temp[k]\r\n\t\tk++\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/42#issuecomment-1641524061","body":"/*\r\n思路：\r\n`能力检测` `最左二分`\r\n\r\n\r\n\r\n复杂度：\r\n时间复杂度： O(nlogn+logn∗log(MAX−MIN))\r\n空间复杂度： O(1)\r\n*/\r\n```go\r\nfunc solve(nums []int) float64 {\r\n\tif len(nums) <= 3 {\r\n\t\treturn 0\r\n\t}\r\n\tsort.Ints(nums)\r\n\tl := 0\r\n\tr := nums[len(nums)-1] - nums[0]\r\n\tfor l <= r {\r\n\t\tmid := l + (r-l)>>1\r\n\t\tif isPossible(nums, mid) {\r\n\t\t\tr = mid - 1\r\n\t\t} else {\r\n\t\t\tl = mid + 1\r\n\t\t}\r\n\t}\r\n\treturn float64(l) / 2\r\n}\r\n\r\nfunc isPossible(nums []int, mid int) bool {\r\n\tstart := nums[0]\r\n\tend := start + mid\r\n\tfor i := 0; i < 3; i++ {\r\n\t\tindex := 0\r\n\t\tfor index < len(nums) && nums[index] <= end {\r\n\t\t\tindex++\r\n\t\t}\r\n\t\tif index >= len(nums) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tstart = nums[index]\r\n\t\tend = start + mid\r\n\t}\r\n\treturn false\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/45#issuecomment-1646603441","body":"/*\r\n思路：\r\n`滑动窗口`\r\n\r\n\r\n复杂度：\r\n时间复杂度： O(n)\r\n空间复杂度： O(1)\r\n\r\n\r\n*/\r\n```go\r\nfunc maxVowels(s string, k int) int {\r\n\tout := 0\r\n\tif len(s) < k {\r\n\t\treturn out\r\n\t}\r\n\tvowels := map[byte]bool{\r\n\t\t'a': true,\r\n\t\t'e': true,\r\n\t\t'i': true,\r\n\t\t'o': true,\r\n\t\t'u': true,\r\n\t}\r\n\r\n\tfor i := 0; i < k; i++ {\r\n\t\tif vowels[s[i]] {\r\n\t\t\tout++\r\n\t\t}\r\n\t}\r\n\tif out == k {\r\n\t\treturn out\r\n\t}\r\n\ttmp := out\r\n\tfor i := k; i < len(s); i++ {\r\n\t\tif vowels[s[i]] {\r\n\t\t\ttmp++\r\n\t\t}\r\n\r\n\t\tif vowels[s[i-k]] {\r\n\t\t\ttmp--\r\n\t\t}\r\n\t\tout = max(out, tmp)\r\n\r\n\t\tif out == k {\r\n\t\t\treturn out\r\n\t\t}\r\n\t}\r\n\treturn out\r\n}\r\n\r\nfunc max(a, b int) int {\r\n\tif a > b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n```\r\n```python\r\n\r\nclass Solution:\r\n    def maxVowels(self, s: str, k: int) -> int:\r\n        vowels = set(['a','e','i','o','u'])\r\n        out=0\r\n        for i in k:\r\n            out+= s[i] in vowels\r\n        \r\n        if out==k: return out\r\n\r\n        tmp=out\r\n        for i in range(k,len(s)):\r\n            tmp+= (s[i]in vowels)- (s[i-k]in vowels)\r\n            out=max(tmp,out)\r\n            if out==k:return out\r\n        return out\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/46#issuecomment-1646869929","body":"/*\r\n思路：\r\n`滑动窗口`\r\n\r\n复杂度：\r\n时间复杂度： O(KW)\r\n\r\n空间复杂度： O(K+W)\r\n*/\r\n```go\r\nfunc new21Game(N, K, W int) float64 {\r\n\tdp := make([]float64, K+W)\r\n\tfor i := K; i < K+W; i++ {\r\n\t\tif i <= N {\r\n\t\t\tdp[i] = 1.0\r\n\t\t}\r\n\t}\r\n\r\n\tfor i := K - 1; i >= 0; i-- {\r\n\t\tsum := 0.0\r\n\t\tfor j := 1; j <= W; j++ {\r\n\t\t\tsum += dp[i+j]\r\n\t\t}\r\n\t\tdp[i] = sum / float64(W)\r\n\t}\r\n\treturn dp[0]\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/48#issuecomment-1649510348","body":"/*\r\n思路：\r\n`滑动窗口`\r\nwhile 右边界 < 合法条件：\r\n  // 右边界扩张\r\n  window右边界+1\r\n  更新状态信息\r\n  // 左边界收缩\r\n  while 符合收缩条件：\r\n    window左边界+1\r\n    更新状态信息\r\n\r\n复杂度：\r\n时间复杂度： O(N+K);N 为 S 串长度，K 为 T 串长度\r\n空间复杂度： O(S)，其中 S 为 T 字符集元素个数\r\n*/\r\n```go\r\nfunc minWindow(s string, t string) (ans string) {\r\n\tcounter := map[byte]int{}\r\n\tl := 0\r\n\tN := len(s)\r\n\tcounter_t := map[byte]int{}\r\n\tfor i := 0; i < len(t); i++ {\r\n\t\tcounter_t[t[i]]++\r\n\t}\r\n\r\n\tres := math.MaxInt32\r\n\tk := 0\r\n\tfor r := 0; r < N; r++ {\r\n\t\tcounter[s[r]]++\r\n\t\tif _, ok := counter_t[s[r]]; ok && counter[s[r]] == counter_t[s[r]] {\r\n\t\t\tk++\r\n\t\t}\r\n\t\tfor k == len(counter_t) {\r\n\t\t\t//收缩左边\r\n\t\t\tif r-l+1 < res {\r\n\t\t\t\tans = s[l : r+1]\r\n\t\t\t}\r\n\t\t\tres = min((r - l + 1), res)\r\n\r\n\t\t\tcounter[s[l]]--\r\n\t\t\tif _, ok := counter_t[s[l]]; ok && counter[s[l]] == counter_t[s[l]]-1 {\r\n\t\t\t\tk--\r\n\t\t\t}\r\n\t\t\tl++\r\n\t\t}\r\n\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n\tif a < b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/49#issuecomment-1651459515","body":"\r\n/*\r\n思路：\r\n`滑动窗口`\r\n\r\n问题可以转换为求nums中最长的连续字串和=sum(nums)-target\r\n\r\n\r\n复杂度：\r\n时间复杂度： O(n)\r\n空间复杂度： 1\r\n*/\r\n```go\r\nfunc solve(nums []int, target int) int {\r\n\tlength := len(nums)\r\n\tsum := 0\r\n\tfor _, v := range nums {\r\n\t\tsum += v\r\n\t}\r\n\r\n\ttarget = sum - target\r\n\r\n\tans := length + 1\r\n\ti := 0\r\n\ttmp_sum := 0\r\n\tfor j := 0; j < length; j++ {\r\n\t\ttmp_sum += nums[j]\r\n\t\tfor tmp_sum > sum {\r\n\t\t\ttmp_sum -= nums[i]\r\n\t\t\ti++\r\n\t\t}\r\n\r\n\t\tif tmp_sum == target {\r\n\t\t\tans = min(ans, length-(j-i+1))\r\n\t\t}\r\n\t}\r\n\tif ans == length+1 {\r\n\t\treturn -1\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n\tif a < b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/50#issuecomment-1653282116","body":"\r\n/*\r\n思路:\r\n\r\n复杂度：\r\n时间复杂度：O(turnedOn^2)\r\n空间复杂度：O(1)\r\n*/\r\n```go\r\nfunc readBinaryWatch(turnedOn int) (ans []string) {\r\n\th_num := min(4, turnedOn+1)\r\n\tfor i := 0; i <= h_num; i++ {\r\n\t\tfor _, h := range possible_number(i, false) {\r\n\t\t\tm := turnedOn - i\r\n\t\t\tif m < 0 {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tfor _, m := range possible_number(m, true) {\r\n\t\t\t\tans = append(ans, fmt.Sprintf(\"%d:%02d\", h, m))\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc possible_number(count int, m bool) (ans []int) {\r\n\tif count == 0 {\r\n\t\treturn []int{0}\r\n\t}\r\n\tif !m {\r\n\t\tfor i := 0; i < 12; i++ {\r\n\t\t\tif bits.OnesCount(uint(i)) == count {\r\n\t\t\t\tans = append(ans, i)\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tfor i := 0; i < 60; i++ {\r\n\t\t\tif bits.OnesCount(uint(i)) == count {\r\n\t\t\t\tans = append(ans, i)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n\tif a < b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/51#issuecomment-1655267354","body":"\r\n/*\r\n思路：\r\n`深度优先搜索`\r\n\r\n\r\n复杂度：\r\n时间复杂度为 O(n!)\r\n空间复杂度为 O(n)\r\n*/\r\n```go\r\nfunc totalNQueens(n int) int {\r\n\tres := 0\r\n\tvar dfs func(n, row, col, pie, na int)\r\n\r\n\tdfs = func(n, row, col, pie, na int) {\r\n\t\tif row >= n {\r\n\t\t\tres++\r\n\t\t\treturn\r\n\t\t}\r\n\t\tbits := ^(col | pie | na) & ((1 << n) - 1)\r\n\t\tfor bits > 0 {\r\n\t\t\tp := bits & -bits\r\n\t\t\tbits = bits & (bits - 1)\r\n\t\t\tdfs(n, row+1, col|p, (pie|p)<<1, (na|p)>>1)\r\n\t\t}\r\n\t}\r\n\r\n\tdfs(n, 0, 0, 0, 0)\r\n\treturn res\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/53#issuecomment-1657184544","body":"/*\r\n复杂度：\r\n时间复杂度为 O(N^2)\r\n空间复杂度为 O(N^2)\r\n*/\r\n```go\r\nfunc maxDistance(grid [][]int) int {\r\n\tn := len(grid)\r\n\tsteps := -1\r\n\tqueue := list.New()\r\n\tfor i := 0; i < n; i++ {\r\n\t\tfor j := 0; j < n; j++ {\r\n\t\t\tif grid[i][j] == 1 {\r\n\t\t\t\tqueue.PushBack([2]int{i, j})\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif queue.Len() == 0 || queue.Len() == n*n {\r\n\t\treturn steps\r\n\t}\r\n\r\n\tdirections := [4][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\r\n\r\n\tfor queue.Len() > 0 {\r\n\t\tqueueLen := queue.Len()\r\n\t\tfor i := 0; i < queueLen; i++ {\r\n\t\t\telem := queue.Front()\r\n\t\t\tqueue.Remove(elem)\r\n\t\t\tx, y := elem.Value.([2]int)[0], elem.Value.([2]int)[1]\r\n\t\t\tfor _, d := range directions {\r\n\t\t\t\txi, yj := x+d[0], y+d[1]\r\n\t\t\t\tif xi >= 0 && xi < n && yj >= 0 && yj < n && grid[xi][yj] == 0 {\r\n\t\t\t\t\tqueue.PushBack([2]int{xi, yj})\r\n\t\t\t\t\tgrid[xi][yj] = -1\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsteps++\r\n\t}\r\n\r\n\treturn steps\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/54#issuecomment-1658007468","body":"/*\r\n思路：\r\n`BFS`\r\n\r\n\r\n复杂度：\r\n时间复杂度： O(n+k) n 为盒子数，k 为钥匙数\r\n空间复杂度： O(n)\r\n*/\r\n```go\r\nfunc maxCandies(status []int, candies []int, keys [][]int, containedBoxes [][]int, initialBoxes []int) int {\r\n\tn := len(status)\r\n\thasKey := make([]int, n)\r\n\tvis := make([]int, n)\r\n\tbox := []int{}\r\n\tans := 0\r\n\r\n\tbox = append(box, initialBoxes...)\r\n\r\n\tfor len(box) > 0 {\r\n\t\tsize := len(box)\r\n\t\tfind := false\r\n\t\tfor i := 0; i < size; i++ {\r\n\t\t\tb := box[i]\r\n\t\t\tif status[b] == 1 || (status[b] == 0 && hasKey[b] == 1) {\r\n\t\t\t\tvis[b] = 1\r\n\t\t\t\tfind = true\r\n\t\t\t\t// 新的钥匙\r\n\t\t\t\tfor _, k := range keys[b] {\r\n\t\t\t\t\thasKey[k] = 1\r\n\t\t\t\t}\r\n\t\t\t\t// 新的糖果\r\n\t\t\t\tans += candies[b]\r\n\t\t\t\t// 新的盒子\r\n\t\t\t\tfor _, c := range containedBoxes[b] {\r\n\t\t\t\t\tif vis[c] == 0 {\r\n\t\t\t\t\t\tbox = append(box, c)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tbox = append(box, b)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif !find {\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tbox = box[size:]\r\n\t}\r\n\r\n\treturn ans\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/59#issuecomment-1666529959","body":"/*\r\n思路：\r\n动态规划\r\n\r\n复杂度：\r\n时间复杂度：O(M*N)，其中 N 为数组长度。\r\n空间复杂度：O(M*N)\r\n*/\r\n```go\r\nfunc longestCommonSubsequence(text1, text2 string) int {\r\n    m, n := len(text1), len(text2)\r\n    dp := make([][]int, m+1)\r\n    for i := range dp {\r\n        dp[i] = make([]int, n+1)\r\n    }\r\n    for i, c1 := range text1 {\r\n        for j, c2 := range text2 {\r\n            if c1 == c2 {\r\n                dp[i+1][j+1] = dp[i][j] + 1\r\n            } else {\r\n                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])\r\n            }\r\n        }\r\n    }\r\n    return dp[m][n]\r\n}\r\n\r\nfunc max(a, b int) int {\r\n    if a > b {\r\n        return a\r\n    }\r\n    return b\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/60#issuecomment-1666897931","body":"/*\r\n思路：\r\n动态规划\r\n复杂度：\r\n时间复杂度：O(mn)\r\n空间复杂度：O(mn)\r\n\r\n*/\r\n```go\r\nfunc uniquePaths(m, n int) int {\r\n    dp := make([][]int, m)\r\n    for i := range dp {\r\n        dp[i] = make([]int, n)\r\n        dp[i][0] = 1\r\n    }\r\n    for j := 0; j < n; j++ {\r\n        dp[0][j] = 1\r\n    }\r\n    for i := 1; i < m; i++ {\r\n        for j := 1; j < n; j++ {\r\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n        }\r\n    }\r\n    return dp[m-1][n-1]\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iambigchen":[null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1586455365","body":"## 思路\n\n用increments来存所有的increment操作，increment[i]表示前i个值都加increment[i]值\n\n在pop的时候，只需要把栈顶值取出，加increment[i]。在更新维护increment[i-1]，将increment[i-1] 变成 increment[i] + increment[i-1]。然后重置increment[i]为0即可\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.list = []\n    this.increments = Array(maxSize).fill(0)\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.list.length < this.maxSize) {\n        this.list.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.list.length === 0) return -1\n    let i = this.list.length - 1\n    this.increments[i-1] += this.increments[i]\n    let res = this.list.pop() + this.increments[i]\n    this.increments[i] = 0\n    return res\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let i = Math.min(k, this.list.length) -1\n    if (i >= 0) {\n        this.increments[i] += val\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weiboshi":[null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587162592","body":"class CustomStack {\n\n    // declare an array to store the elements of the stack\n    private int[] stack;\n    // declare an integer to store the maximum size of the stack\n    private int maxSize;\n    // declare an integer to store the top index of the stack\n    private int top;\n\n    // constructor to initialize the stack with a given maxSize\n    public CustomStack(int maxSize) {\n        // initialize the array with the maxSize\n        this.stack = new int[maxSize];\n        // initialize the maxSize\n        this.maxSize = maxSize;\n        // initialize the top index to -1\n        this.top = -1;\n    }\n\n    // method to push an element x to the top of the stack\n    public void push(int x) {\n        // check if the stack is full\n        if (top == maxSize - 1) {\n            // throw an exception\n            throw new RuntimeException(\"Stack is full\");\n        } else {\n            // increment the top index\n            top++;\n            // assign x to the top position of the array\n            stack[top] = x;\n        }\n    }\n\n    // method to pop an element from the top of the stack\n    public int pop() {\n        // check if the stack is empty\n        if (top == -1) {\n            // return -1 as per the requirement\n            return -1;\n        } else {\n            // store the top element of the array in a variable\n            int x = stack[top];\n            // decrement the top index\n            top--;\n            // return x\n            return x;\n        }\n    }\n\n    // method to increment the bottom k elements of the stack by val\n    public void inc(int k, int val) {\n        // loop through the first k elements of the array or all elements if k > top + 1\n        for (int i = 0; i < Math.min(k, top + 1); i++) {\n            // increment each element by val\n            stack[i] += val;\n        }\n    }\n}\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596849783","body":"// Definition for singly-linked list.\n// public class ListNode {\n//     int val;\n//     ListNode next;\n//     ListNode(int x) {\n//         val = x;\n//         next = null;\n//     }\n// }\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // If either list is empty, return null\n        if (headA == null || headB == null) {\n            return null;\n        }\n        \n        // Initialize two pointers to traverse the lists\n        ListNode pA = headA;\n        ListNode pB = headB;\n        \n        // Loop until the pointers meet or reach the end\n        while (pA != pB) {\n            // If pA reaches the end, move it to the head of list B\n            if (pA == null) {\n                pA = headB;\n            }\n            // Otherwise, move it to the next node\n            else {\n                pA = pA.next;\n            }\n            \n            // If pB reaches the end, move it to the head of list A\n            if (pB == null) {\n                pB = headA;\n            }\n            // Otherwise, move it to the next node\n            else {\n                pB = pB.next;\n            }\n        }\n        \n        // Return the intersection node or null if there is no intersection\n        return pA;\n    }\n}\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1606896709","body":"public class Codec {\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) {\n            return \"null\";\n        }\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] nodes = data.split(\",\");\n        return buildTree(nodes, new int[]{0});\n    }\n\n    private TreeNode buildTree(String[] nodes, int[] index) {\n        if (nodes[index[0]].equals(\"null\")) {\n            index[0]++;\n            return null;\n        }\n        TreeNode node = new TreeNode(Integer.parseInt(nodes[index[0]++]));\n        node.left = buildTree(nodes, index);\n        node.right = buildTree(nodes, index);\n        return node;\n    }\n}\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1618307209","body":"const int maxn = 1e5+5;\nclass Solution {\nprivate:\n    long long pre[maxn];\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        int n = nums.size();\n        for(int i = 1; i <= n; i++) {\n            pre[i] = (pre[i-1] + nums[i-1]) % p ;\n        }\n        int sum = pre[n-1] % p;\n        if(sum == 0) {\n            return 0;\n        }\n        map<int, int> m;\n        int ans = 1e9+7;\n        for(int i = 1; i <= n; i++) {\n            int cur = pre[i-1];\n            int target = (cur-sum+p) % p;\n            if(m[target]) {\n                ans = min(ans, i - m[target]);\n            }\n            m[cur] = i;\n        }\n        if(ans == n || ans == 1e9+7) {\n            return -1;\n        }\n        return ans;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"master-guang":[null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587254742","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length < this.maxSize) {\n        this.stack.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length) {\n        return this.stack.pop()\n    } else {\n        return -1\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(this.stack.length < k) {\n        this.stack = this.stack.map(function(item) {\n            return item += val\n        })\n    } else {\n        for(let i = 0; i < k; i++) {\n            this.stack[i] += val\n        }\n    }\n};\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1592683182","body":"```js\n思路：要想划分最多的块，并且保证排序后的结果和原数组的排序结果相同，则块中的元素必须保证，块中的最大值都比右边的元素小或者相同，块中的最小值都比左边的元素大或者相同。\nvar maxChunksToSorted = function(arr) {\n  const stack = [];\n  for (const num of arr) {\n      if (stack.length === 0 || num >= stack[stack.length - 1]) {\n          stack.push(num);\n      } else {\n          const mx = stack.pop();\n          while (stack.length && stack[stack.length - 1] > num) {\n              stack.pop();\n          }\n          stack.push(mx);\n      }\n  }\n  return stack.length;\n};\n\n//test\nlet arr = [2,1,3,4,4]\nconsole.log(maxChunksToSorted(arr))","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605953168","body":"```js\n// 层序遍历：\nvar findBottomLeftValue = function(root) {\n    //考虑层序遍历 记录最后一行的第一个节点\n    let queue = [];\n    if(root === null){\n        return null;\n    }\n    queue.push(root);\n    let resNode;\n    while(queue.length){\n        let length =  queue.length;\n        for(let i = 0; i < length; i++){\n            let node = queue.shift();\n            if(i === 0){\n                resNode = node.val;\n            }\n            node.left&&queue.push(node.left);\n            node.right&&queue.push(node.right);\n        }\n    }\n    return resNode;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607335029","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nconst serialize = (root) => {\n  if (root == null) {                  // 遍历到 null 节点\n    return 'X';\n  }\n  const left = serialize(root.left);   // 左子树的序列化结果\n  const right = serialize(root.right); // 右子树的序列化结果\n  return root.val + ',' + left + ','+ right; // 按  根,左,右  拼接字符串\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nconst deserialize = (data) => {\n  const list = data.split(',');   // split成数组\n\n  const buildTree = (list) => {   // 基于list构建当前子树\n    const rootVal = list.shift(); // 弹出首项，获取它的“数据”\n    if (rootVal == \"X\") {         // 是X，返回null节点\n      return null;\n    }\n    const root = new TreeNode(rootVal); // 不是X，则创建节点\n    root.left = buildTree(list);        // 递归构建左子树\n    root.right = buildTree(list);       // 递归构建右子树\n    return root;                        // 返回当前构建好的root\n  };\n\n  return buildTree(list); // 构建的入口\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1609170633","body":"```js\n// 困难题，做不出来\nvar verticalTraversal = function (root) {\n  let mapper = new Map()\n  let dfs = (node, rowIndex, level) => {\n    if (!node) {\n      return\n    }\n    if (!mapper.get(rowIndex)) {\n      mapper.set(rowIndex, [])\n    }\n    let tar = mapper.get(rowIndex)\n    if (!tar[level]) {\n      tar[level] = []\n    }\n    tar[level].push(node.val)\n\n    dfs(node.left, rowIndex - 1, level + 1)\n    dfs(node.right, rowIndex + 1, level + 1)\n  }\n\n  dfs(root, 0, 0)\n\n  let indexArr = []\n  for (var [index, arrs] of mapper.entries()) {\n    indexArr.push(index)\n    arrs.forEach((arr) => {\n      arr.sort((a, b) => a - b)\n    })\n  }\n  indexArr.sort((a, b) => a - b)\n  // console.log(indexArr)\n  let target = indexArr.reduce((pre, index) => {\n    pre.push(\n      mapper.get(index).reduce((prev, item) => {\n        prev.push(...item)\n        return prev\n      }, [])\n    )\n    // console.log(mapper.get(index))\n    return pre\n  }, [])\n  return target\n}\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1611011621","body":"```js\n// 思路：哈希表秒解，今天的题目有点简单了\nvar twoSum = function(nums, target) {\n    let map = new Map();\n    for(let i = 0; i < nums.length; i++) {\n        let index = target - nums[i];\n        if(map.has(nums[i])) {\n            return [map.get(nums[i]), i]\n        } else {\n            map.set(index, i)\n        }\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1612988352","body":"```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    let map = new Map();\n    for(let item of nums) {\n        if(map.has(item)) {\n            map.set(item, map.get(item) + 1)\n        } else {\n            map.set(item, 1)\n        }\n    }\n    let arr = [...map].sort((a,b) => b[1] - a[1]);\n    let resArr = []\n    while(k) {\n        resArr.push(arr.shift()[0])\n        k--\n    }\n    return resArr\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1617485239","body":"```js\nlet minSubarray = function (nums, p) {\n  let x = 0;\n  for (const num of nums) {\n    x += num;\n  }\n  x %= p;\n  if (x === 0) {\n    return 0;\n  }\n  const map = new Map();\n  let y = 0;\n  let res = nums.length;\n  for (let i = 0; i < nums.length; i++) {\n    map.set(y, i);\n    y = (y + nums[i]) % p;\n    if (map.has((y - x + p) % p)) {\n      res = Math.min(res, i - map.get((y - x + p) % p) + 1);\n    }\n  }\n  return res === nums.length ? -1 : res;\n};\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1621944513","body":"```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    if(nums.length == 0) {\n        return 0;\n    }\n    let slow = 0;\n    let fast = 0;\n    while(fast < nums.length) {\n        if(nums[fast] != nums[slow]) {\n            slow++\n            nums[slow] = nums[fast]\n        }\n        fast++\n    }\n    return slow + 1\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627577632","body":"```js\n/**\n * @param {number} n\n * @param {number[][]} dislikes\n * @return {boolean}\n */\nvar possibleBipartition = function(n, dislikes) {\n    let ok = true;\n    let color = new Array(n + 1);\n    let visited = new Array(n + 1);\n    let graph = buildGraph(n, dislikes);\n    // 建图函数\n    function buildGraph(n, dislikes) {\n        // 图节点编号为 1...n\n        let graph = new Array(n + 1);\n        for (let i = 1; i <= n; i++) {\n            graph[i] = new Array();\n        }\n        for (let i = 0; i < dislikes.length; i++) {\n            let v = dislikes[i][0];\n            let w = dislikes[i][1];\n            // 「无向图」相当于「双向图」\n            // v -> w\n            graph[v].push(w);\n            // w -> v\n            graph[w].push(v);\n        }\n        return graph;\n    }\n    // 和之前判定二分图的 traverse 函数完全相同\n    function traverse(graph, v) {\n        if (!ok) return;\n        visited[v] = true;\n        for (let i = 0; i < graph[v].length; i++) {\n            let w = graph[v][i];\n            if (!visited[w]) {\n                color[w] = !color[v];\n                traverse(graph, w);\n            } else {\n                if (color[w] == color[v]) {\n                    ok = false;\n                }\n            }\n        }\n    }\n    for (let v = 1; v <= n; v++) {\n        if (!visited[v]) {\n            traverse(graph, v);\n        }\n    }\n    return ok;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/32#issuecomment-1628317265","body":"```js\n// 题目有点难了，对于没怎么学过图论的我，还得继续补知识\nconst topSort = (deg, graph, items) => {\n    const Q = [];\n    for (const item of items) {\n        if (deg[item] === 0) {\n            Q.push(item);\n        }\n    }\n    const res = [];\n    while (Q.length) {\n        const u = Q.shift(); \n        res.push(u);\n        for (let i = 0; i < graph[u].length; ++i) {\n            const v = graph[u][i];\n            if (--deg[v] === 0) {\n                Q.push(v);\n            }\n        }\n    }\n    return res.length == items.length ? res : [];\n}\n\nvar sortItems = function(n, m, group, beforeItems) {\n    const groupItem = new Array(n + m).fill(0).map(() => []);\n\n    // 组间和组内依赖图\n    const groupGraph = new Array(n + m).fill(0).map(() => []);\n    const itemGraph = new Array(n).fill(0).map(() => []);\n\n    // 组间和组内入度数组\n    const groupDegree = new Array(n + m).fill(0);\n    const itemDegree = new Array(n).fill(0);\n    \n    const id = new Array(n + m).fill(0).map((v, index) => index);\n\n    let leftId = m;\n    // 给未分配的 item 分配一个 groupId\n    for (let i = 0; i < n; ++i) {\n        if (group[i] === -1) {\n            group[i] = leftId;\n            leftId += 1;\n        }\n        groupItem[group[i]].push(i);\n    }\n    // 依赖关系建图\n    for (let i = 0; i < n; ++i) {\n        const curGroupId = group[i];\n        for (const item of beforeItems[i]) {\n            const beforeGroupId = group[item];\n            if (beforeGroupId === curGroupId) {\n                itemDegree[i] += 1;\n                itemGraph[item].push(i);   \n            } else {\n                groupDegree[curGroupId] += 1;\n                groupGraph[beforeGroupId].push(curGroupId);\n            }\n        }\n    }\n\n    // 组间拓扑关系排序\n    const groupTopSort = topSort(groupDegree, groupGraph, id); \n    if (groupTopSort.length == 0) {\n        return [];\n    } \n    const ans = [];\n    // 组内拓扑关系排序\n    for (const curGroupId of groupTopSort) {\n        const size = groupItem[curGroupId].length;\n        if (size == 0) {\n            continue;\n        }\n        const res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\n        if (res.length === 0) {\n            return [];\n        }\n        for (const item of res) {\n            ans.push(item);\n        }\n    }\n    return ans;\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1630543381","body":"```js\nvar judgeCircle = function(moves) {\n    let zero = [0,0];\n    let map = {'R': 1, 'L': -1, 'U': 1, 'D': -1}\n    for(let item of moves) {\n        switch (item) {\n            case 'R':\n                zero[1] += map[item];\n                break;\n            case 'L':\n                zero[1] += map[item];\n                break;\n            case 'U':\n                zero[0] += map[item];\n                break;\n            case 'D':\n                zero[0] += map[item];\n                break;\n        }\n    }\n    if(JSON.stringify(zero) === JSON.stringify([0, 0])) {\n        return true\n    } else {\n        return false\n    }\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1635608441","body":"```java\nclass Solution {\npublic:\n    int minCharacters(string a, string b) {\n        vector<int> acnt(26), bcnt(26);\n        for (char c:a) acnt[c - 'a']++;\n        for (char c:b) bcnt[c - 'a']++;\n        int totA = a.size(), totB = b.size();\n        int preA = 0, preB = 0, ans = INT_MAX;\n        for (int i = 0; i < 25; i++) {  // 不包括z\n            preA += acnt[i]; \n            preB += bcnt[i]; \n            ans = min(ans, min(totA - preA + preB, totB - preB + preA));  // 条件1、2\n            ans = min(ans, totA - acnt[i] + totB - bcnt[i]);   // 条件3\n        }\n        ans = min(ans, totA - acnt[25] + totB - bcnt[25]);  // 单独处理z\n        return ans;\n    }\n};\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1637087707","body":"```js\nvar mySqrt = function (x) {\n    let left = 0\n    let right = x\n    while (left <= right) {\n        let mid = left + ((right - left) >> 1)//中间位置索引 x>>1 表示除以2并取整，缩小一下遍历的范围\n        if (mid * mid <= x) {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return right\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637242988","body":"```js\nvar solution = function(isBadVersion) {\n    /**\n     * @param {integer} n Total versions\n     * @return {integer} The first bad version\n     */\n    return function(n) {\n        let left = 1, right = n;\n        while(left <= right) {\n            let mid = Math.floor(left + (right - left) / 2);\n            if(isBadVersion(mid)) {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        }\n        return left\n    };\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1643810922","body":"```js\nvar solve = function(nums,k) {\n    nums.sort((a,b) => a - b);\n    let low = 0, high = nums[nums.length - 1] - nums[0];\n    while(low < high) {\n        let mid = Math.floor((low + high) / 2);\n        let count = 0;\n        let left = 0;\n        for(let right = 0; right < nums.length; right++) {\n            while(nums[right] - nums[left] > mid) {\n                left++;\n            }\n            count += right - left;\n        }\n        if(count >= k) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return low\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/49#issuecomment-1650880334","body":"```js\nconst solve = function(A, target) {\n    if (!A.length && !target) return 0;\n    target = A.reduce((sum, num) => sum + num, 0) - target;\n    let ans = A.length + 1;\n    let i = 0;\n    let t = 0;\n\n    for (let j = 0; j < A.length; j++) {\n      t += A[j];\n      while (i <= j && t > target) {\n        t -= A[i];\n        i++;\n      }\n      if (t === target) ans = Math.min(ans, A.length - (j - i + 1));\n    }\n    return ans === A.length + 1 ? -1 : ans;\n  }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/53#issuecomment-1657198643","body":"```js\nfunction maxDistance(grid) {\n  const dx = [0, 0, 1, -1];\n  const dy = [1, -1, 0, 0];\n\n  const queue = [];\n  const m = grid.length;\n  const n = grid[0].length;\n\n  // 先把所有的陆地都入队。\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === 1) {\n        queue.push([i, j]);\n      }\n    }\n  }\n\n  // 从各个陆地开始，一圈一圈的遍历海洋，最后遍历到的海洋就是离陆地最远的海洋。\n  let hasOcean = false;\n  let point = null;\n  while (queue.length > 0) {\n    point = queue.shift();\n    const x = point[0];\n    const y = point[1];\n\n    // 取出队列的元素，将其四周的海洋入队。\n    for (let i = 0; i < 4; i++) {\n      const newX = x + dx[i];\n      const newY = y + dy[i];\n      if (\n        newX < 0 ||\n        newX >= m ||\n        newY < 0 ||\n        newY >= n ||\n        grid[newX][newY] !== 0\n      ) {\n        continue;\n      }\n      grid[newX][newY] = grid[x][y] + 1; // 这里我直接修改了原数组，因此就不需要额外的数组来标志是否访问\n      hasOcean = true;\n      queue.push([newX, newY]);\n    }\n  }\n\n  // 没有陆地或者没有海洋，返回-1。\n  if (point === null || !hasOcean) {\n    return -1;\n  }\n\n  // 返回最后一次遍历到的海洋的距离。\n  return grid[point[0]][point[1]] - 1;\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/57#issuecomment-1663839628","body":"```js\nvar rob = function(nums) {\n    // 备忘录\n    let memo = new Array(nums.length).fill(-1);\n    // 强盗从第 0 间房子开始抢劫\n    return dp(nums, 0, memo);\n};\n\n// 返回 dp[start..] 能抢到的最大值\nfunction dp(nums, start, memo) {\n    if (start >= nums.length) {\n        return 0;\n    }\n    // 避免重复计算\n    if (memo[start] != -1) return memo[start];\n\n    let res = Math.max(dp(nums, start + 1, memo),\n            nums[start] + dp(nums, start + 2, memo));\n    // 记入备忘录\n    memo[start] = res;\n    return res;\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jennyjgao":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589116849","body":"```\npublic class MedianDecodeString394 {\n    public String decodeString(String s){\n        StringBuilder rs = new StringBuilder();\n        Stack<Integer> kStack = new Stack<>();\n        Stack<StringBuilder> resStack = new Stack<>();\n        int k = 0; //重复k次\n        for(char c: s.toCharArray()){\n            if(c == '['){\n                //记录位置k,和当前结果\n                kStack.push(k);\n                resStack.push(rs);\n                k =0;\n                rs = new StringBuilder();\n            }else if(c == ']'){\n                //出最近的一次左括号记录的次数\n                int curk = kStack.pop();\n                StringBuilder temp = new StringBuilder();\n                for(int i=0;i<curk;i++){\n                    temp.append(rs);\n                }\n                //合并括号\n                rs = resStack.pop().append(temp);\n            }else if(c>='0' && c<='9'){\n                k = c - '0' +k *10; //转一下次数\n            }else{\n                //字符直接加\n                rs.append(c);\n            }\n        }\n        return rs.toString();\n    }\n\n    public static void main(String[] args) {\n        String s = \"3[a]2[bc]\";\n        MedianDecodeString394 md = new MedianDecodeString394();\n        System.out.println(md.decodeString(s));\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590624080","body":"    ``` java\npublic class EasyStackQueue232 {\n    private Stack<Integer> sIn;\n    private Stack<Integer> sOut;\n\n    public EasyStackQueue232(){\n        sIn = new Stack<>();\n        sOut = new Stack<>();\n    }\n    public void push(int x){\n        sIn.push(x);\n    }\n\n    public Integer pop(){\n        // in -> out\n        if(sOut.isEmpty()){\n            while (! sIn.isEmpty()){\n                sOut.push(sIn.pop());\n            }\n        }\n        return sOut.pop();\n    }\n\n    public Integer peek(){\n        if(sOut.isEmpty()){\n            while(!sIn.isEmpty()){\n                sOut.push(sIn.pop());\n            }\n        }\n        return sOut.peek();\n    }\n\n    public boolean empty(){\n        return sIn.isEmpty() && sOut.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        EasyStackQueue232 myQueue = new EasyStackQueue232();\n        myQueue.push(1);\n        myQueue.push(2);\n        myQueue.push(3);\n        System.out.println(myQueue.pop());\n        System.out.println(myQueue.peek());\n        System.out.println(myQueue.empty());\n    }\n}\n    ```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596834540","body":"```\npublic class EasyIntersectionOfTwoLists160 {\n    public static class ListNode{\n        int val;\n        ListNode next;\n\n        ListNode(int x){\n            val = x;\n            next = null;\n        }\n    }\n    \n    public static ListNode getIntersectionOfTwoLists(ListNode headA, ListNode headB){\n        ListNode one = headA;\n        ListNode two = headB;\n        while(one!=two){\n            if(one == null){\n                one = headB;\n            }else{\n                one = one.next;\n            }\n\n            if(two == null){\n                two =headA;\n            }else{\n                two = two.next;\n            }\n        }\n        return one;\n    }\n\n    public static void main(String[] args) {\n        ListNode A = new ListNode(2);\n        ListNode B = new ListNode(3);\n        A.next = B;\n        System.out.println(EasyIntersectionOfTwoLists160.getIntersectionOfTwoLists(A,B).val);\n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1600340710","body":"```\npackage database.linkedlist;\n\nimport java.util.HashMap;\nimport java.util.List;\n\npublic class MedianLRUCache146 {\n    private int capacity;\n    private HashMap<Integer,ListNode> caMap;\n\n    private class ListNode{\n        private Integer key;\n        private Integer value;\n\n        private ListNode pre;\n        private ListNode next;\n\n        public ListNode(){}\n\n        public ListNode(Integer key, Integer value){\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    //初始化 LRUCache\n    private ListNode head;\n    private ListNode tail;\n    public MedianLRUCache146(int capacity){\n        this.capacity = capacity;\n        caMap = new HashMap<>(capacity);\n        head = new ListNode(-1,-1);\n        tail = new ListNode(-1,-1);\n        head.next = tail;\n        tail.next = head;\n    }\n\n    // get key\n    public int get(int key){\n        if (caMap.containsKey(key)){\n            ListNode rs = caMap.get(key);\n            int val = rs.value;\n            moveNode2Head(key); //key被使用\n            return val;\n        }else{\n            return -1;\n        }\n    }\n\n    public void put(int key,int value){\n        //如果已存在key，更新value\n        if(caMap.containsKey(key)){\n            caMap.get(key).value = value;\n            moveNode2Head(key);\n            return;\n        }\n        //如果容量满了\n        if(caMap.size() >= capacity){\n            ListNode oldTail = removeTail();\n            caMap.remove(oldTail.key);\n        }\n        //添加元素\n        ListNode newNode = new ListNode(key,value);\n        caMap.put(key,newNode);\n        addNodeHead(newNode);\n    }\n\n    //在头部增加一个节点\n    private void addNodeHead(ListNode newNode){\n        ListNode oldHead = head.next;\n        oldHead.pre = newNode;\n\n        newNode.pre = head;\n        newNode.next = oldHead;\n\n        head.next = newNode;\n    }\n\n    //如果容量超了需要删除尾节点\n    private ListNode removeTail(){\n        ListNode oldTail = tail.pre;\n        ListNode newTail = oldTail.pre;\n\n        newTail.next = tail;\n        tail.pre = newTail;\n\n        oldTail.next = null;\n        oldTail.pre = null;\n        return oldTail;\n    }\n\n    //更新key的话，需要又更新值。又要把这个节点再放到头部节点\n    private void moveNode2Head(int key){\n        ListNode node = caMap.get(key);\n        node.pre.next = node.next; //前后连接一下\n        node.next.pre = node.pre;\n        addNodeHead(node);\n    }\n\n    /**\n     * [\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\n     * [[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]\n     * [null,-1,null,-1,null,null,2,6]\n     * @param args\n     */\n\n    public static void main(String[] args) {\n        MedianLRUCache146 lruCache = new MedianLRUCache146(2);\n        System.out.println(lruCache.get(2));\n        lruCache.put(2,6);\n        System.out.println(lruCache.get(1));\n        lruCache.put(1,5);\n        lruCache.put(1,2);\n        System.out.println(lruCache.caMap.keySet());\n        System.out.println(lruCache.get(1));\n        System.out.println(lruCache.get(2));\n//        System.out.println(lruCache.capacity);\n//        lruCache.put(1,2);\n//        lruCache.put(2,4);\n//        System.out.println(lruCache.caMap.keySet());\n//        System.out.println(lruCache.get(1));\n//        lruCache.put(3,6);\n//        lruCache.put(4,8);\n//        System.out.println(lruCache.caMap.keySet());\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1606020753","body":"```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605249038","body":"```\nclass Solution {\n    int res = 0;\n    public int sumNumbers(TreeNode root) {\n        dfs(root,0);\n        return res;\n    }\n    public void dfs(TreeNode root, int pre){\n        if(root == null) return;\n        pre = pre*10 + root.val;\n        if(root.left == null && root.right == null){\n            res += pre;\n            return;\n        }\n        if(root.left !=null){\n            dfs(root.left, pre);\n        }\n\n        if(root.right != null){\n            dfs(root.right, pre);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605946259","body":"```\npublic class MedianFindBottomLeftValue513 {\n    //最深且最左的value==> BFS后最后一层的第一个值 => Queue\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            root = queue.poll();\n            if (root.right != null) queue.offer(root.right);\n            if (root.left != null) queue.offer(root.left);\n        }\n        return root.val;\n    }\n\n}\n\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/22#issuecomment-1614065760","body":"```\npublic int numberOfBoomerangs(int[][] points) {\n        int n = points.length;\n        int rs = 0;\n        for(int i=0; i<n;i++){\n            HashMap<Integer,Integer> map = new HashMap<>();\n            //先统计距离相同的节点个数\n            for(int j=0;j<n;j++){\n                if(j==i) continue;\n                int x = points[i][0]-points[j][0];\n                int y = points[i][1]-points[j][1];\n                int dis = x*x +y*y;\n                int cnt = map.getOrDefault(dis,0);//该距离已有点的个数\n                rs+=2*cnt; //该距离已有的每个点都可与当前点构成2个回旋镖\n                map.put(dis,cnt+1);\n            }\n        }\n        return rs;\n    }\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/26#issuecomment-1620051468","body":"```\npublic ListNode middleNode(ListNode head) {\n        //快慢指针\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast!=null && fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1624831459","body":"```   \n public static int[] maxSlidingWindow(int[] nums, int k) {\n        int[] result = new int[nums.length-k+1];\n        if (nums.length == 0 || k == 0 || k > nums.length) {\n            return result;\n        }\n        List<Integer> res = new ArrayList<>();\n        Deque<Integer> queue = new LinkedList<>();\n        for(int i = 0;i<nums.length; i++){\n            if(!queue.isEmpty()){\n                //判断，两个下标差是否等于k，如果等于就删除头部\n                if(i>=queue.peek()+k){\n                    queue.pop();\n                }\n                //当前元素是否大于队尾元素，如果大于就删除\n                while(!queue.isEmpty() && nums[i]>=nums[queue.getLast()]){\n                    queue.removeLast();\n                }\n            }\n            queue.offer(i);\n            // 滑动窗口经过三个元素，获取当前的最大值，也就是队列的头元素\n            if (i + 1 >= k) {\n                res.add(nums[queue.peek()]);\n            }\n        }\n        for(int i=0;i<res.size();i++){\n            //这里存的是 每一个的最大值\n            result[i]=res.get(i);\n//            System.out.println(result[i]);\n        }\n        return result;\n    }\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1634079889","body":"```\nclass Solution {\n    public int numberOfRounds(String loginTime, String logoutTime) {\n        // 分离hour和min\n        int hourA=Integer.parseInt(loginTime.substring(0,2));\n        int minA=Integer.parseInt(loginTime.substring(3,5));\n        int hourB=Integer.parseInt(logoutTime.substring(0,2));\n        int minB=Integer.parseInt(logoutTime.substring(3,5));\n        int res=0;\n        // 退出时间比登录时间小，两种情况：hour小、hour相等min小\n        if(hourB<hourA||(hourA==hourB&&minA>minB)) hourB+=24;\n        // 向上取整登录时间\n        if(minA%15!=0){\n            minA=(minA/15+1)*15;\n        }\n        // 向下取整退出时间\n        if(minB%15!=0){\n            minB=(minB/15)*15;\n        }\n        // hour不相同，则分别计算登录和退出两个hour中可以玩的次数，再用中间的hour数*4\n        if(hourB!=hourA){\n            res=(60-minA)/15;\n            res+=minB/15;\n            res+=(hourB-hourA-1)*4;\n        }else{\n            res=(minB-minA)/15;\n        }\n        return res>=0?res:0;\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/42#issuecomment-1641705853","body":"```\npublic class HardMinimumLight796 {\n    public double minimumLightRadius(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        //直径的最大值是最右侧房子和最左侧房子坐标之差的1/3\n        int left = 0, right = (nums[n - 1] - nums[0]) / 3;\n        while(left <= right){\n            int mid = (left + right) / 2;\n            if(allCovered(mid, nums)){\n                //当前直径可以覆盖，有边界-1\n                right = mid - 1;\n            }else{\n                //当前直径不能覆盖，增大一下\n                left = mid + 1;\n            }\n        }\n        return left / 2.0;\n    }\n\n    private boolean allCovered(int d, int[] nums){\n        int target = nums[0] + d, n = nums.length;\n        int left = 0, right = n - 1;\n        while(left <= right){\n            int mid = (left + right) / 2;\n            if(nums[mid] > target){\n                right = mid - 1;\n            }else{\n                left = mid + 1;\n            }\n        }\n        int leftBorder = left;\n        target = nums[n - 1] - d;\n        left = 0;\n        right = n - 1;\n        while(left <= right){\n            int mid = (left + right) / 2;\n            if(nums[mid] < target){\n                left = mid + 1;\n            }else{\n                right = mid - 1;\n            }\n        }\n        int rightBorder = right;\n        if(rightBorder < 0 || nums[rightBorder] - nums[leftBorder] <= d){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/47#issuecomment-1647703361","body":"```\npublic class MedianFindAnagrams438 {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> res = new ArrayList<Integer>();\n        if (s.length() < p.length()) {\n            return res;\n        }\n        int[] pcount = new int[26];\n        int[] scount = new int[26];\n\n        for (int i = 0; i < p.length(); i++) {    //记录第一组p长度的字符是否符合条件\n            scount[s.charAt(i) - 'a']++;\n            pcount[p.charAt(i) - 'a']++;\n        }\n        if (Arrays.equals(scount, pcount)) {\n            res.add(0);\n        }\n        for (int i = 0; i < s.length() - p.length(); i++) {    //将第一组的第一个字符数量减去\n            scount[s.charAt(i) - 'a']--;\n            //将窗口移动到第二组的最后一个字符的位置\n            scount[s.charAt(i + p.length()) - 'a']++;\n            if (Arrays.equals(scount, pcount)) {\n                res.add(i + 1);\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangjay408":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589410068","body":"type item struct {\n\tn     int\n\tbytes []byte\n}\n\nfunc decodeString(str string) string {\n\tnum := 0\n\tst := []item{{1, []byte{}}}\n\n\tfor i := range str {\n\t\tswitch {\n\t\tcase str[i] == '0':\n\t\t\tnum *= 10\n\t\tcase str[i] > '0' && str[i] <= '9':\n\t\t\tnum = num*10 + int(str[i]-'0')\n\t\tcase str[i] == '[':\n\t\t\tst = append(st, item{num, []byte{}})\n\t\t\tnum = 0\n\t\tcase str[i] == ']':\n\t\t\ttmp := st[len(st)-1]\n\t\t\tst = st[:len(st)-1]\n\t\t\tfor j := 0; j < tmp.n; j++ {\n\t\t\t\tst[len(st)-1].bytes = append(st[len(st)-1].bytes, tmp.bytes...)\n\t\t\t}\n\t\tdefault:\n\t\t\tst[len(st)-1].bytes = append(st[len(st)-1].bytes, str[i])\n\t\t}\n\t}\n\n\treturn string(st[0].bytes)\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591313658","body":"class MyQueue {\n\n    Stack<Integer> og;\n    Stack<Integer> temp;\n    int top;\n    \n    public MyQueue() {\n        og = new Stack();\n        temp = new Stack();\n    }\n    \n    public void push(int x) {\n        if(og.empty())\n            top = x;\n        og.push(x);\n    }\n    \n    public int pop() {\n        while(og.size() != 1)\n        {\n            temp.push(og.pop());\n        }\n        int popped = og.pop();\n        if(!temp.empty())\n            top = temp.peek();\n        while(!temp.empty())\n        {\n            og.push(temp.pop());\n        }\n        return popped;\n    }\n    \n    public int peek() {\n        return top;\n    }\n    \n    public boolean empty() {\n        return og.empty();\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chang-you":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590402125","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        # stack_in for push, stack_out for pop\n        self.stack_in = []\n        self.stack_out = []\n        \n    \n    def push(self, x: int) -> None:\n        self.stack_in.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        \n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -> int:\n        ans = self.pop()\n        self.stack_out.append(ans)\n        return ans\n\n    def empty(self) -> bool:\n        return not (self.stack_in or self.stack_out)\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596370580","body":"\"\"\"\r\n无限长度的问题应该可以这样来解决：\r\n两个链表同时做反向操作，也就是reverse linked list。那么会遇到有以下两种情况：\r\n1. 两个链表不相交部分一样长，那么他们会在某一刻访问到同一个node，那么这个node之后就全一致。\r\n    1.1 如果要恢复链表结构，再reverse一次即可\r\n2. 两个链表不想教部分不一样长，那么其中一个指针it_a会跑到另一个链表头部。此时, 让it_a做reverse list操作直到回到Head(A)，用it_b再次做reverse操作，it_a正常访问next，it_a和it_b指向同一个节点时候，就是交点。此时，链表也正好恢复了原始结构。\r\n更数学化一点语言应该是这样：\r\n假设两个list A，B不想交部分长度分别为M，N，满足M >= N, but we don't know the exact value of M or N.\r\n1. if M == N，after M reverse op, there will be it_A == it_b and the common node is found;\r\n2. if M > N, after N reverse op, it_b will be on common list. And after M+N reverse op, it_a will be at Head(B). And it_b will be M steps away from the common Node.\r\n3. Now let it_a execute reverse op for M+N times and it_a will be back at Head(A), which is also M steps away from the common Node.\r\n4. Now let it_b doing a reverse list op and it_a to visit the list. The two will meet at the common Node and the structure will be restored at this moment.\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = headB if not a else a.next\r\n            b = headA if not b else b.next\r\n        return a\r\n```\r\n    \r\n    ","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/17#issuecomment-1605947638","body":"```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        q = deque([root])\r\n        while q:\r\n            node = q.popleft()\r\n            if node.right:\r\n                q.append(node.right)\r\n            if node.left:\r\n                q.append(node.left)\r\n        return node.val\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616060068","body":"```java\r\nclass Solution {\r\n   public List<Integer> findSubstring(String s, String[] words) {\r\n        if (s == null || words == null || words.length == 0) {\r\n            return new ArrayList<>();\r\n        }\r\n\r\n        List<Integer> res = new ArrayList<>();\r\n        int n = words.length;\r\n        int m = words[0].length();\r\n        HashMap<String, Integer> map = new HashMap<>();\r\n\r\n        for (String str : words) {\r\n            map.put(str, map.getOrDefault(str, 0) + 1);\r\n        }\r\n\r\n        for (int i = 0; i <= s.length() - n * m; i++) {\r\n            HashMap<String, Integer> copy = new HashMap<>(map);\r\n            int k = n;\r\n            int j = i;\r\n            while (k > 0) {\r\n                String str = s.substring(j, j + m);\r\n                if (!copy.containsKey(str) || copy.get(str) < 1) {\r\n                    break;\r\n                }\r\n                copy.put(str, copy.get(str) - 1);\r\n                k--;\r\n                j += m;\r\n            }\r\n            if (k == 0) res.add(i);\r\n        }\r\n        return res;\r\n   }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/31#issuecomment-1627975137","body":"```java\r\nclass Solution {\r\n    public boolean possibleBipartition(int N, int[][] dislikes) {\r\n        int[] color = new int[N + 1];\r\n        List<List<Integer>> graph = new ArrayList<>();\r\n        for (int i = 0; i <= N; i++) {\r\n            graph.add(new ArrayList<>());\r\n        }\r\n        for (int i = 0; i < dislikes.length; i++) {\r\n            graph.get(dislikes[i][0]).add(dislikes[i][1]);\r\n            graph.get(dislikes[i][1]).add(dislikes[i][0]);\r\n        }\r\n        for (int i = 1; i <= N; i++) {\r\n            if (color[i] == 0) {\r\n                color[i] = 1;\r\n                Queue<Integer> queue = new LinkedList<>();\r\n                queue.offer(i);\r\n                while (!queue.isEmpty()) {\r\n                    int cur = queue.poll();\r\n                    for (int neighbor : graph.get(cur)) {\r\n                        if (color[neighbor] == 0) {\r\n                            color[neighbor] = color[cur] == 1 ? -1 : 1;\r\n                            queue.offer(neighbor);\r\n                        } else {\r\n                            if (color[neighbor] == color[cur]) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n}\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rocjemaintiendrai":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1590447112","body":"class MyQueue {\n    Stack<Integer> input = new Stack<>();\n    Stack<Integer> output = new Stack<>();\n\n    public MyQueue() {\n        \n    }\n    \n    public void push(int x) {\n        input.push(x);\n    }\n    \n    public int pop() {\n        shuffle();\n        return output.pop();\n    }\n    \n    public int peek() {\n        shuffle();\n        return output.peek();\n    }\n    \n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n\n    private void shuffle() {\n        if(output.empty()) {\n            while(!input.empty()) {\n                output.push(input.pop());\n            }\n        }\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598065928","body":"public class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast) break; \n        }\n        if(fast == null || fast.next == null)  {\n            return null;\n        }\n        while(head != slow) {\n            head = head.next;\n            slow = slow.next;\n        }\n        return head;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1599944062","body":"class LRUCache {\n    private Node head;\n    private Node tail;\n    private Map<Integer, Node> map;\n    private int capacity;\n\n    public LRUCache(int capacity) {\n        map = new HashMap<>();\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        this.capacity = capacity;\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        if(!map.containsKey(key)) {\n            return -1;\n        }\n        Node node = map.get(key);\n        remove(node);\n        insert(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        if(map.containsKey(key)) {\n            remove(map.get(key));\n        }\n        if(map.size() == capacity) {\n            remove(tail.prev);\n        }\n        insert(new Node(key, value));\n    }\n\n    private void remove(Node node) {\n        map.remove(node.key);\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void insert(Node node) {\n        map.put(node.key, node);\n        Node headNext = head.next;\n        headNext.prev = node;\n        node.next = headNext;\n        head.next = node;\n        node.prev = head;\n        headNext.prev = node;\n    }\n\n    private class Node {\n        Node next, prev;\n        int key, value;\n        Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1601988501","body":"## Recursion\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n}\n\n// Iteration\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        int max = 1;\n        Stack<TreeNode> nodes = new Stack<>();\n        Stack<Integer> depths = new Stack<>();\n        nodes.push(root);\n        depths.push(1);\n        while(!nodes.empty()) {\n            TreeNode cur = nodes.pop();\n            int depth = depths.pop();\n            if(cur.left == null && cur.right == null) {\n                max = Math.max(max, depth);\n            }\n            if(cur.right != null) {\n                nodes.push(cur.right);\n                depths.push(depth + 1);\n            }\n            if(cur.left != null) {\n                nodes.push(cur.left);\n                depths.push(depth + 1);\n            }\n        }\n        return max;\n    }\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/21#issuecomment-1612370355","body":"class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        Queue<Integer> heap = new PriorityQueue<>((a, b) -> map.get(b) - map.get(a));\n        for(int key : map.keySet()) {\n            heap.add(key);\n        }\n        int[] res = new int[k];\n        for(int i = 0; i < k; i++) {\n            res[i] = heap.poll();\n        }\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ainfinitedz":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593326406","body":"### 思路\n\n维持一个始终递增的单调栈，栈内保留的元素即是分片的元素。由此，分片段数是栈的大小\n\n### 代码\n\n```java\nimport java.util.*;\n\nclass Solution {   \n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for(int i = 0; i < arr.length; i++) { //O(n)\n            // 将所有小于当前元素的值pop出来\n            if(!stack.isEmpty() && arr[i] < stack.peek()) {\n                int cur = stack.pop();\n            \t\n                while(!stack.isEmpty() && arr[i] < stack.peek()) { //O(n)\n                    stack.pop();\n                }\n            \tstack.push(cur);\n            } else {\n                stack.push(arr[i]);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n### 算法复杂度\n\n时间复杂度：$O(n)$ 每个元素最多被pop和push一次\n\n空间复杂度：$O(n)$ 栈的大小最大为数组长度","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/13#issuecomment-1601017771","body":"```\npublic class LRUCache {\n    int capacity = 0;\n    LinkedList<Integer> ll = new LinkedList<>();\n    HashMap<Integer, Integer> hashmap = new HashMap<>();\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        Iterator<Integer> it = ll.iterator();\n        int count = 0;\n        while(it.hasNext() && (count < capacity)) {\n            Integer keyCurr = it.next();\n            if(keyCurr == key) {\n                it.remove();\n                ll.addFirst(key);\n                return hashmap.get(key);\n            }\n        }\n        return -1; \n    }\n    \n    public void put(int key, int value) {\n        boolean ifModifyHashMap = !hashmap.containsKey(key);\n        hashmap.put(key, value);\n        if(hashmap.size() > capacity) { \n            Integer removedKey = ll.removeLast();\n            ll.addFirst(key);\n            hashmap.remove(removedKey);\n        } else {\n            if(ifModifyHashMap) ll.addFirst(key);\n        }\n    }\n```\n\n使用链表来确定增删的元素，并在哈希表内实施。(O(1))。\n使用两个元素来跟踪链表的头尾。\n\n遍历util中的内置linkedlist时，使用了Iterator\n\n时间复杂度：O（n）\n\n空间复杂度：O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594872929","body":" public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null){\n            return head;\n        }\n\n        ListNode p1 = head;\n        ListNode p2 = head;\n        int size = 1;\n        for(int i = 0; i < k; i++){\n            if(p2.next!=null){\n                p2 = p2.next;\n                size++;\n            } else {\n                p2 = head;\n                k = (k % size) + size;\n            }\n        }\n\n        while(p2.next!=null){\n            p2 = p2.next;\n            p1 = p1.next;\n        }\n\n        p2.next = head;\n        head = p1.next;\n        p1.next = null;\n\n        return head;\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengistchan":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594882437","body":"public ListNode rotateRight(ListNode head, int k) {\n    if(head==null||k==0){\n        return head;\n    }\n    ListNode cursor=head;\n    ListNode tail=null;//尾指针\n    int length=1;\n    while(cursor.next!=null)//循环 得到总长度\n    {\n        cursor=cursor.next;\n        length++;\n    }\n    int loop=length-(k%length);//得到循环的次数\n    tail=cursor;//指向尾结点\n    cursor.next=head;//改成循环链表\n    cursor=head;//指向头结点\n    for(int i=0;i<loop;i++){//开始循环\n        cursor=cursor.next;\n        tail=tail.next;\n    }\n    tail.next=null;//改成单链表\n    return cursor;//返回当前头\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/10#issuecomment-1596048151","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        // 递归+快慢指针\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right){\n        if(left == right){\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right){\n        ListNode fast = left;\n        ListNode slow = left;\n        while(fast != right && fast.next != right){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/11#issuecomment-1596401366","body":"```typescript\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n  let a = headA, b = headB\n  while(a != b) {\n    a = a ? a.next : null\n    b = b ? b.next : null\n    if(a == null && b == null) return null\n    if(a == null) {\n      a = headB\n    } \n    if(b == null) {\n      b = headA\n    }\n  }\n  return a\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/12#issuecomment-1598052602","body":"```\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        while(head) {\n            if(!less<ListNode *>()(head, head->next)) {\n                return head->next;\n            }\n            head = head->next;\n        }\n        return nullptr;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/14#issuecomment-1602103692","body":"```TypeScript\nfunction maxDepth(root: TreeNode | null): number {\n  if(!root) return 0;\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/15#issuecomment-1602989803","body":"```TypeScript\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean{\n  if (p == null && q === null) return true;\n  if (!p && q || !q && p) return false;\n  if (p.val !== q.val) return false;\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/16#issuecomment-1605273556","body":"```TypeScript\n\nfunction sumNumbers(root: TreeNode | null, sum = 0): number {\n  const isLeaf = (node: TreeNode) => !node?.left && !node?.right\n  if (!root || isLeaf(root)) {\n    return sum * 10 + root?.val || 0\n  }\n  return sumNumbers(root.left, sum * 10 + root.val) + sumNumbers(root.right, sum * 10 + root.val)\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/18#issuecomment-1607458071","body":"```TypeScript\nfunction serialize(root: TreeNode | null): string {\n  const res = []\n  const queue = []\n  root && queue.push(root)\n\n  while (queue.length >= 1) {\n    const node = queue.shift()\n    res.push(node?.val ?? null)\n    node && (queue.push(node.left ?? null))\n    node && (queue.push(node.right ?? null))\n  }\n\n  return `${res.map(i => i ?? 'null').join(',')}` || undefined\n};\n\n/*\n * Decodes your encoded data to tree.\n */\nfunction deserialize(data: string): TreeNode | null {\n  const array = data?.split(',').map(item => item === 'null' ? null : parseInt(item)) || []\n  if (array.length === 0) return null\n  let i = 1, root = new TreeNode(), nodes = []\n  if (array.length > 0) {\n    root.val = array[0]\n    nodes.push(root)\n  }\n  while (i < array.length) {\n    const node = nodes.shift()\n    array[i] !== null && (node.left = new TreeNode(array[i]), nodes.push(node.left))\n    array[i + 1] !== null && (node.right = new TreeNode(array[i + 1]), nodes.push(node.right))\n    i += 2\n  }\n  return root\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/19#issuecomment-1607997244","body":"使用 map + dfs 结合 js 的函数式编程\r\n```TypeScript\r\nfunction verticalTraversal(root: TreeNode | null): number[][] {\r\n  if (!root) return []\r\n\r\n  const map = { '0': [[1, root.val]] }\r\n\r\n  const dfs = (node: TreeNode | null, cur: number, level: number) => {\r\n    if (!node) return\r\n    if (!map[cur]) {\r\n      map[cur] = []\r\n    }\r\n    map[cur].push([level, node.val])\r\n    dfs(node.left, cur - 1, level + 1)\r\n    dfs(node.right, cur + 1, level + 1)\r\n  }\r\n  \r\n  dfs(root.left, -1, 2)\r\n  dfs(root.right, 1, 2)\r\n\r\n  return Object.keys(map).map(key => parseInt(key)).sort((a, b) => a - b).map(key => map[key].sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]).map(item => item[1]))\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/20#issuecomment-1609910421","body":"```TypeScript\nfunc twoSum(nums []int, target int) []int {\n\tm := map[int]int{}\n\tfor i, v := range nums {\n\t\tif _, ok := m[v]; ok {\n\t\t\treturn []int{m[v], i}\n\t\t}\n\t\tm[target-v] = i\n\t}\n\treturn nil\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/23#issuecomment-1615584895","body":"```TypeScript\nfunction lengthOfLongestSubstring(s: string): number {\n  let l = 0, r = 0, sum = 0\n  const map = Array(128).fill(0)\n  const hasIn = (map: Array<number>) => {\n    for (const key of map) {\n      if (key > 1) return false\n    }\n    return true\n  }\n  while (r < s.length) {\n    map[s.charCodeAt(r)]++\n    while (!hasIn(map)) {\n      map[s.charCodeAt(l)]--\n      l++\n    }\n    sum = Math.max(sum, r - l + 1)\n    r++\n  }\n\n  return sum\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/24#issuecomment-1616572364","body":"```TypeScript\nfunction findSubstring(s: string, words: string[]): number[] {\n  const one_length = words[0].length, total_length = one_length * words.length\n  if (words[0].length * words.length > s.length) return []\n\n  const ans = [], map = new Map<string, number>()\n\n  for (let i = 0; i < words.length ; i++) {\n    map.set(words[i], (map.get(words[i]) || 0) + 1)\n  }\n\n  for (let i = 0 ; i <= s.length - total_length ; i++) {\n    const subStr = s.slice(i, i + total_length), t_map = new Map(map)\n    let j = 0\n    while (j < total_length) {\n      const str = subStr.slice(j, j + one_length)\n      if (!t_map.has(str)) break\n      t_map.set(str, t_map.get(str) - 1)\n      j += one_length\n    }\n    if ([...t_map.values()].every(i => i === 0)) {\n      ans.push(i)\n    }\n  }\n\n  return ans\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/25#issuecomment-1617674451","body":"```TypeScript\nfunction minSubarray(nums: number[], p: number): number {\n  const sum = nums.reduce((a, b) => a + b), target = (sum + p) % p, map = new Map<number, number>([[0, -1]])\n  if (target === 0) return 0\n\n  let right = 0, cur = 0, ans = nums.length\n\n  while (right < nums.length) {\n    cur = (cur + nums[right])\n    const t = (cur - target + p) % p\n    if (map.has(t)) {\n      ans = Math.min(ans, right - map.get(t))\n    }\n    map.set(cur % p, right)\n    right++\n  }\n  return ans === nums.length ? -1 : ans\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/27#issuecomment-1620514014","body":"双指针，重拳出击\n```TypeScript\nfunction removeDuplicates(nums: number[]): number {\n  let i = 1, cur = nums[0], j = 0\n  while (i < nums.length) {\n    if (nums[i] !== cur) {\n      nums[j + 1] = nums[i]\n      j++\n      cur = nums[i]\n    }\n    i++\n  }\n  return nums.length - i + j + 1\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/29#issuecomment-1624900664","body":"```\nvar maxSlidingWindow = function(nums, k) {\n    const n = nums.length;\n    const q = [];\n    for (let i = 0; i < k; i++) {\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n            q.pop();\n        }\n        q.push(i);\n    }\n\n    const ans = [nums[q[0]]];\n    for (let i = k; i < n; i++) {\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n            q.pop();\n        }\n        q.push(i);\n        while (q[0] <= i - k) {\n            q.shift();\n        }\n        ans.push(nums[q[0]]);\n    }\n    return ans;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/30#issuecomment-1626931257","body":"```TypeScript\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_degree=[0]*(n+1)\n        out_degree=[0]*(n+1)\n        for i,j in trust:\n            in_degree[j]+=1\n            out_degree[i]+=1\n        for a in range(1,n+1):\n            if in_degree[a]==n-1 and out_degree[a]==0:\n                return a\n        return -1\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1629484944","body":"```TypeScript\nclass Solution {\n    public boolean judgeCircle(String moves) {\n\n        int x = 0, y = 0;\n\n        for (int i = 0; i < moves.length(); i++) {\n            char c = moves.charAt(i);\n\n            if (c == 'U') {\n                y -=1;\n            } else if (c == 'D') {\n                y +=1;\n            } else if (c == 'L') {\n                x -=1;\n            } else {\n                x +=1;\n            }\n        }\n\n        if (x == 0 && y == 0) {\n            return true;\n        }\n\n        return false;\n        \n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1637476400","body":"```TypeScript\nvar solution = function(isBadVersion: any) {\n    return function(n: number): number {\n      let l = 1, r = n\n      while (l <= r) {\n        let m = Math.floor((l + r) / 2)\n        const bool = isBadVersion(m)\n        if (bool) {\n          r = m - 1\n        } else {\n          l = m + 1\n        }\n      }\n      return l\n    };\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/41#issuecomment-1639831760","body":"# Code\n```JavaScript\nvar reversePairs = function(nums) {\n    if (nums.length === 0) {\n        return 0;\n    }\n    return reversePairsRecursive(nums, 0, nums.length - 1);\n};\n\nconst reversePairsRecursive = (nums, left, right) => {\n    if (left === right) {\n        return 0;\n    } else {\n        const mid = Math.floor((left + right) / 2);\n        const n1 = reversePairsRecursive(nums, left, mid);\n        const n2 = reversePairsRecursive(nums, mid + 1, right);\n        let ret = n1 + n2;\n\n        let i = left;\n        let j = mid + 1;\n        while (i <= mid) {\n            while (j <= right && nums[i] > 2 * nums[j]) {\n                j++;\n            }\n            ret += j - mid - 1;\n            i++;\n        }\n\n        const sorted = new Array(right - left + 1);\n        let p1 = left, p2 = mid + 1;\n        let p = 0;\n        while (p1 <= mid || p2 <= right) {\n            if (p1 > mid) {\n                sorted[p++] = nums[p2++];\n            } else if (p2 > right) {\n                sorted[p++] = nums[p1++];\n            } else {\n                if (nums[p1] < nums[p2]) {\n                    sorted[p++] = nums[p1++];\n                } else {\n                    sorted[p++] = nums[p2++];\n                }\n            }\n        }\n        for (let k = 0; k < sorted.length; k++) {\n            nums[left + k] = sorted[k];\n        }\n        return ret;\n    }\n}\n···","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/46#issuecomment-1646631260","body":"```Java\nclass Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0) {\n            return 1.0;\n        }\n        double[] dp = new double[k + maxPts];\n        for (int i = k; i <= n && i < k + maxPts; i++) {\n            dp[i] = 1.0;\n        }\n        for (int i = k - 1; i >= 0; i--) {\n            for (int j = 1; j <= maxPts; j++) {\n                dp[i] += dp[i + j] / maxPts;\n            }\n        }\n        return dp[0];\n    }\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/53#issuecomment-1657165413","body":"```python\nclass Solution:\n    def maxDistance(self, grid):\n        rows = len(grid)\n        cols = len(grid[0])\n\n        ocean_queue = []\n        land_queue = []\n\n   \n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 0:\n                    ocean_queue.append((i, j))\n                else:\n                    land_queue.append((i, j))\n\n        if len(ocean_queue) == 0 or len(land_queue) == 0:\n            return -1\n\n        max_distance = -1\n\n   \n        while ocean_queue:\n            ocean_cell = ocean_queue.pop(0)\n\n         \n            x0, y0 = ocean_cell\n            for land_cell in land_queue:\n  \n                x1, y1 = land_cell\n                distance = abs(x0 - x1) + abs(y0 - y1)\n                max_distance = max(max_distance, distance)\n        return max_distance\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/60#issuecomment-1666813449","body":"```py\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1] * n] + [[1] + [0] * (n - 1)] * (m - 1)\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiyingc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/33#issuecomment-1629823289","body":"### 思路\r\n\r\n题目要求回到原点，那么只要上、下相等，左、右相等即可\r\n\r\n### 代码\r\n```py\r\nclass Solution(object):\r\n    def judgeCircle(self, moves):\r\n        if not moves: return True\r\n\r\n        cnt_map = collections.Counter(moves)\r\n\r\n        # opt 1 遍历4次\r\n        return moves.count('U')==moves.count('D') and moves.count('L')==moves.count('R')\r\n        \r\n        # opt 2 遍历一次\r\n        ans = False\r\n        if 'U' in cnt_map:\r\n            ans = 'D' in cnt_map and cnt_map['U'] == cnt_map['D']\r\n        if ans and 'L' in cnt_map:\r\n            ans = 'R' in cnt_map and cnt_map['L'] == cnt_map['R']\r\n\r\n        return ans\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)，储存counter","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/35#issuecomment-1632805317","body":"```py\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        res = []\n        tasks = sorted([(t[0], t[1], i) for i, t in enumerate(tasks)])\n        i = 0\n        h = []\n        time = tasks[0][0]\n        while len(res) < len(tasks):\n            while (i < len(tasks)) and (tasks[i][0] <= time):\n                heapq.heappush(h, (tasks[i][1], tasks[i][2])) # (processing_time, original_index)\n                i += 1\n            if h:\n                t_diff, original_index = heapq.heappop(h)\n                time += t_diff\n                res.append(original_index)\n            elif i < len(tasks):\n                time = tasks[i][0]\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/36#issuecomment-1633314353","body":"**Intuition** <br>\r\n- key points: is_overnight, floor, ceiling, edge case\r\n\r\n**Code**\r\n```py\r\ndef numberOfRounds(self, loginTime, logoutTime):\r\n    hs, ms = (int(x) for x in loginTime.split(\":\"))\r\n    ts = 60 * hs + ms\r\n    hf, mf = (int(x) for x in logoutTime.split(\":\"))\r\n    tf = 60 * hf + mf\r\n    if 0 <= tf - ts < 15: return 0 # edge case \r\n\r\n    # tf//15 -> convert logout time to the same / earlier 15 min count, we are effectively getting the floor.\r\n    # (ts+14)//15 -> convert login time to the same / later 15 min count, we are effectively getting the ceiling.\r\n    # (ts>tf)*96 -> if login time is later than logout time, add 4 quarters per hour * 24 hours = 96 counts, otherwise add 0.\r\n    return tf//15 - (ts+14)//15 + (ts>tf)*96\r\n\r\n```\r\n**Complexity Analysis** <br>\r\nTime  complexity: O(1) <br>\r\nSpace complexity: O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/37#issuecomment-1636057392","body":"**Intuition** <br>\nCount the frequcy of each character in a and b.\nFind the most common characters most_common = max((c1 + c2).values()),\nthis help meet the condition 3 with m + n - most_common.\n\nThe we calculate the accumulate prefix sum of count.\nThis help finding the number of smaller characters in O(1) time.\n\nEnumerate the character i a,b,c...x,y,\nTo meet condition 1,\nwhich is a < b,\nwe need (m - c1[i]) + c2[i]\n\nTo meet condition 2,\nwhich is a > b,\nwe need n - c2[i] + c1[i]\n\n**Code**\n```py\ndef minCharacters(self, a, b):\n    m, n = len(a), len(b)\n    c1 = Counter(ord(c) - 97 for c in a)\n    c2 = Counter(ord(c) - 97 for c in b)\n    res = m + n - max((c1 + c2).values()) # condition 3\n    for i in range(25):\n        c1[i + 1] += c1[i]\n        c2[i + 1] += c2[i]\n        res = min(res, m - c1[i] + c2[i]) # condition 1\n        res = min(res, n - c2[i] + c1[i]) # condition 2\n    return res\n```\n**Complexity Analysis** <br>\nTime  : O(m+n) <br>\nSpace : O(26)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/39#issuecomment-1636899472","body":"**Intuition** <br>\n二分\n\n**Code**\n```py\ndef mySqrt(self, x):\n    if x < 2: return x\n\n    l, r = 0, x\n    while l + 1 < r:\n        root = (l+r)//2\n        if root > x//root:\n            r = root\n        elif root < x//root:\n            l = root\n        else:\n            return root\n            \n    return l # floor\n```\n**Complexity Analysis** <br>\nTime  complexity: O(logn) <br>\nSpace complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/40#issuecomment-1638415126","body":"### 思路\r\nBinary search: find left-most with duplicates\r\n\r\n### Code\r\n```py\r\ndef firstBadVersion(self, n):\r\n    l, r = 0, n\r\n    \r\n    while l < r:\r\n        mid = (l+r) // 2\r\n        if isBadVersion(mid):\r\n            r = mid\r\n        else:\r\n            l = mid + 1\r\n\r\n    return l\r\n```\r\n\r\n### Complexity\r\nTime  : O(logn) \\\r\nSpace: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/42#issuecomment-1641102140","body":"### 思路\n从左开始模拟放置灯。先在 nums[0] + r 处放置一个灯，其可以覆盖 [0, 2 * r]。由于 nums 已经排好序了，那么这个灯可以覆盖到的房间其实就是 nums 中坐标小于等于 2 * r 所有房间，使用二分查找即可。对于 nums 右侧的所有的房间我们需要继续放置灯，采用同样的方式即可。<br>\nkey: binary search; greedy - find minimum\n\n### Code\n```py\n# 从左开始模拟放置灯。先在 nums[0] + r 处放置一个灯，其可以覆盖 [nums[0], 2 * r]。\n# 由于 nums 已经排好序了，那么这个灯可以覆盖到的房间其实就是 nums 中坐标小于等于 2 * r 所有房间，使用能力检测二分查找即可。\n# 对于 nums 右侧的所有的房间我们需要继续放置灯，采用同样的方式即可。\ndef solve(arr):\n    arr.sort()\n    n = len(arr)\n    if n <= 3:\n        return 0\n    n_lights = 3\n\n    def check(radius):\n        lo, hi = arr[0], arr[0]+2*radius\n\n        for i in range(n_lights):\n            idx = bisect_right(arr, hi)  # find idx that hi can be inserted into sorted arr # O(logn)\n\n            if idx >= n_lights:\n                return True\n\n            lo = nums[idx]\n            hi = lo + 2*radius\n\n            return False\n\n    # l, r = arr[0], arr[-1]\n    # binarySearchFindMinimum(arr)\n\n    return radius\n```\n\n### Complexity\nTime  : O(nlogn) - sort() <br>\nSpace: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/44#issuecomment-1645802952","body":"### 思路\r\n- 每次选水位最低的邻块移动 >> min-heap\r\n- 连通 >> 并查集\r\n\r\n### Code\r\n```py\r\nimport heapq\r\nclass Solution:\r\n    def swimInWater(self, grid):\r\n        N, pq, seen, res = len(grid), [(grid[0][0], 0, 0)], set([(0, 0)]), 0\r\n        while True:\r\n            T, x, y = heapq.heappop(pq)\r\n            res = max(res, T)\r\n            if x == y == N - 1:\r\n                return res\r\n            for i, j in [(x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)]:\r\n                if 0 <= i < N and 0 <= j < N and (i, j) not in seen:\r\n                    seen.add((i, j))\r\n                    heapq.heappush(pq, (grid[i][j], i, j))\r\n```\r\n\r\n### Complexity\r\nTime  ：O(n^2lgn) >> min-heap\r\nSpace：O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/45#issuecomment-1646052569","body":"**Intuition** <br>\r\n- fixed length sliding window\r\n- dp memo stores cnt\r\n\r\n**Code**\r\n```py\r\ndef maxVowels(self, s, k):\r\n    if len(s) < k: return 0\r\n\r\n    vowels = {'a', 'e', 'i', 'o', 'u'}\r\n    ans = cnt = 0\r\n    for i, c in enumerate(s):  # key \r\n        if c in vowels:\r\n            cnt += 1\r\n        if i >= k and s[i - k] in vowels:\r\n            cnt -= 1\r\n        ans  = max(cnt, ans)\r\n    \r\n    return ans    \r\n```\r\n**Complexity Analysis** \\\r\nTime  complexity: O(n) \\\r\nSpace complexity: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/47#issuecomment-1650273121","body":"**思路**\n- Sliding window: enumerate s; i >= CONDITION: 更新ans；更新win\n- 字符串字典：[0 for i in range(26)]; ord(ch)-ord('a') \n\n**Code**\n```py\ndef findAnagrams(self, s, p):\n    len_s, len_p = len(s), len(p)\n    if len_s < len_p: return []\n\n    s_list, p_list = [0 for i in range(26)], [0 for i in range(26)]\n    ans = []\n\n    for ch in p:\n        p_list[ord(ch)-ord('a')] += 1\n\n    for i, ch in enumerate(s):\n        if i >= len_p:\n            s_list[ord(s[i-len_p])-ord('a')] -= 1\n\n        s_list[ord(ch)-ord('a')] += 1\n            \n        if s_list == p_list:\n            ans.append(i-len_p+1)         \n        \n    return ans\n```\n\n**Complexity**\n- Time  : O(n)\n- Space: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/48#issuecomment-1650580026","body":"**思路**\n- 存字典，设相关初始值\n- 遍历s\n- while 右边界 < 合法条件：右边界扩张\n- 更新状态信息\n- while 符合收缩条件：左边界收缩\n- 更新状态信息\n\n**Code**\n```py\nfrom collections import Counter, defaultdict\ndef minWindow(self, s, t):\n    len_s, len_t = len(s), len(t)\n    if len_s < len_t: return \"\"\n\n    counter_s = defaultdict(int)\n    counter_t = defaultdict(int)\n    \n    for ch in t:\n        counter_t[ch] += 1 \n\n    l, valid, ans, min_len = 0, 0, \"\", float('inf')\n    # 遍历s\n    for r in range(len_s):\n        # 进行窗口内数据的状态更新\n        ch = s[r]\n        if ch in counter_t:\n            counter_s[ch] += 1\n            if counter_s[ch] == counter_t[ch]:\n                valid += 1  # 记录 # of matched ch\n        \n        # while 符合收缩条件：左边界收缩\n        while valid == len(counter_t):\n            # 更新最小覆盖子串\n            if r - l < min_len:\n                min_len = r - l\n                ans = s[l:r+1]\n\n            l_ch = s[l]\n            # 进行窗口内数据的状态更新\n            if l_ch in counter_s:\n                counter_s[l_ch] -= 1\n                if counter_s[l_ch] < counter_t[l_ch]:\n                    valid -= 1\n            l += 1 \n\n    return ans\n```\n\n**Complexity**\n- Time   : O(n+m)\n- Space: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/49#issuecomment-1650931687","body":"#### Leetcode同题 - [1658. Minimum Operations to Reduce X to Zero](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/) \n\n**Intuition** <br>\n- Sliding window, 同向双指针\n- 反向思考，先算总和，再缩减至一边 < target，再两边收缩\n- sum([0,..,l) + [r,...,n-1)] = x\n\n**Code**\n```py\ndef minOperations(self, nums, x):\n    currSum, n, ans, l = sum(nums), len(nums), float('inf'), 0\n\n    for r in range(n):\n        # 定位r指针，move至sum[r,...,n-1)<x处\n        # 答案只能存在r,...,n-1和sum(0,...,l)<x区域\n        # 双指针收缩并更新答案\n        currSum -= nums[r]\n        # if smaller, move `l` to left\n        while currSum < x and l <= r:\n            currSum += nums[l]\n            l += 1\n        # check if equal\n        if currSum == x:\n            ans = min(ans, (n-1-r)+l)\n\n    return ans if ans != float('inf') else -1\n```\n**Complexity Analysis** <br>\n- Time  complexity : O(n)\n- Space complexity: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/51#issuecomment-1657065399","body":"**思路** \\\nbacktracking\n\n**Code**\n```py\nclass Solution(object):\n    total = 0\n    n = 0\n    def attack(self, row, col):\n        for c, r in self.cols.items():\n            if c - r == col - row or c + r == col + row:\n                return True\n        return False\n\n    def search(self, row):\n        if row == self.n:\n            self.total += 1\n            return\n        for col in range(self.n):\n            if col in self.cols:\n                continue\n            if self.attack(row, col):\n                continue\n            self.cols[col] = row\n            self.search(row + 1)\n            del self.cols[col]\n\n    def totalNQueens(self, n):\n        self.n = n\n        self.cols = {}\n        self.search(0)\n        return self.total\n```\n\n**Complexity** \\\nTime : O(n!) \\\nSpace: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/52#issuecomment-1657068116","body":"```py\nclass Solution(object):\n    # dfs解法 time complexity: O(n*m) 所有的点都只算了一次\n\n    def maxAreaOfIsland(self, grid):\n        n, m = len(grid), len(grid[0])\n        \n        mx = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:\n                    mx = max(mx, self.dfs(grid, i, j))\n        return mx\n        \n    def dfs(self, grid, i, j):\n        n, m = len(grid), len(grid[0])\n        \n        if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == 0:\n            return 0\n        \n        grid[i][j] = 0\n        return 1 + self.dfs(grid, i - 1, j) + self.dfs(grid, i + 1, j) + self.dfs(grid, i, j - 1) + self.dfs(grid, i, j + 1)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/53#issuecomment-1657072620","body":"```py\nclass Solution(object):\n    # BFS\n    # 从land开始(入队)BFS搜索water, water入队step+1\n    # key1: 初始land入队\n    # key2: is_valid() return True if water\n    # O(n^2), O(n^2)\n    def maxDistance(self, grid):\n        DIRECTIONS = [(0, 1), (1,0), (0,-1), (-1,0)]\n        q = collections.deque()\n        visited = set()\n        n, m = len(grid), len(grid[0])\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]:\n                    q.append((i, j))\n                    visited.add((i, j))\n\n        step = -1\n        while q:\n            step += 1\n            queue_size = len(q)\n            for _ in range(queue_size):\n                x, y = q.popleft()\n                for xi, yi in DIRECTIONS:\n                    new_x, new_y = x+xi, y+yi\n                    if (not self.is_valid(new_x, new_y, grid) \n                        or (new_x, new_y) in visited):\n                        continue\n                    q.append((new_x, new_y))\n                    visited.add((new_x, new_y))\n        \n        return -1 if step == 0 else step\n\n    def is_valid(self, x, y, grid):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):\n            return False\n            \n        return grid[x][y] == 0  # key: return True if water\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/54#issuecomment-1657271735","body":"```py\ndef maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):\n    # BFS\n    # 没有上锁的盒子入队列做 BFS\n        # 遇到盒子， 就将没有上锁的盒子入队列\n        # 遇到钥匙，就将对应的盒子解锁（修改 status 数组），当然前提是我们已经找到了对应的盒子\n    # key: 当前没有盒子的钥匙，后面找到了钥匙后再回头开这个盒子\n    # O(n+k) << boxes+keys\n    # O(n)\n\n    boxes = set(initialBoxes) #set去重\n    q = [i for i in boxes if status[i]] #没有上锁的盒子入队\n    for i in q:\n        for j in containedBoxes[i]:\n            boxes.add(j)\n            if status[j]:\n                q.append(j)\n        for j in keys[i]:\n            if status[j] == 0 and j in boxes: #有钥匙+已找到=可开\n                q.append(j)\n            status[j] = 1 #更新状态\n    return sum(candies[i] for i in q)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/55#issuecomment-1659464308","body":"**思路** \n- Tag: #Tree, #BFS\n- in-order遍历tree\n- tree 映射至 x 轴 >> 坐标记录左右信息\n- 要什么样的view都可✅\n**Code**\n```py\ndef solve(self, root):\n    q = collections.deque([(root, 0)])\n    d = {}\n    while q:  #BFS\n        node, pos = q.popleft()\n        if pos not in d:\n            d[pos] = node.val\n        if node.left:\n            q.append((node.left, pos - 1))\n        if node.right:\n            q.append((node.right, pos + 1))\n\n    return list(map(lambda x:x[1], sorted(d.items(), key=lambda x: x[0]))) #以 node pos、入队顺序依次排序\n```\n**Complexity** \\\nTime  : O(nlgn) << sorted() \\\nSpace: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/56#issuecomment-1662231613","body":"```py\nclass Solution(object):\n    # dp\n    # 长度比cost长度多一个，用来放最初的数值0\n    # 后面的关键就在于取前两个dp的值加上对应cost的值，取小生成新DP值\n    # O(N), O(N)\n    def minCostClimbingStairs(self, cost):\n        if len(cost) < 2: return 0\n        if len(cost) == 2: return min(cost[0],cost[1])\n\n        dp = [0, 0]\n        for i in range(2, len(cost)+1):\n            dp.append(min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]))\n\n        return dp[-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/57#issuecomment-1664458177","body":"```py\nclass Solution(object):\n    # dp表示偷了这个，没偷上个\n    # key: dp intialize with nums\n    # O(n), O(n)\n    \n    def rob(self, nums):\n        # prev2, prev, cur = 0,0,0\n        # for num in nums:\n        #     cur = max(prev, num + prev2)\n        #     prev2 = prev\n        #     prev = cur\n        # return cur\n\n        if not nums: return 0\n        n = len(nums) \n        if n < 3: return max(nums)\n\n        dp = list(nums)  #note: cannot initialized to be 0!! \n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, n):\n            dp[i] = max(dp[i-1], dp[i-2]+nums[i])\n        \n        return dp[-1]\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyli4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/43#issuecomment-1643141256","body":"var smallestDistancePair = function(nums, k) {\n    nums.sort(function(a,b){return a-b});\n    var low = 0;\n    var high = nums[nums.length-1] - nums[0];\n    while(low < high){\n        var mid = Math.floor((low+high)/2);\n        var count = 0;\n        var left = 0;\n        for(var right = 0; right < nums.length; right++){\n            while(nums[right] - nums[left] > mid) left++;\n            count += right - left;\n        }\n        if(count >= k) high = mid;\n        else low = mid + 1;\n    }\n    return low;\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"momogir":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/61#issuecomment-1667177564","body":"```\r\n空间复杂度 O（n*n*k）\r\n时间复杂度 O（n*n*k）\r\n定义dp[step][i][j] 表示骑士从棋盘上的点（i，j）出发，走了step步时仍然留在棋盘的概率。\r\n当点(i,j)不在棋盘上时候，dp[step][i][j]=0\r\n当点(i,j)在棋盘上且step=0的时候，dp[step][i][j]=1\r\n其他，dp[step][i][j]=1/8 * all dp[step-1][i+di][j+dj],即每个分支的概率之和\r\n‘’‘\r\nclass Solution:\r\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\r\n        dp=[[[0]*n for _ in range(n)] for _ in range(k+1)]\r\n        for step in range(k+1):\r\n            for i in range(n):\r\n                for j in range(n):\r\n                    if step == 0:\r\n                         dp[step][i][j] = 1\r\n                    else:\r\n                        for di, dj in ((-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)):\r\n                            ni,nj=i+di,j+dj\r\n                            if 0<=ni<n and 0<=nj<n:\r\n                                dp[step][i][j]+=dp[step-1][ni][nj]/8\r\n        return dp[k][row][column]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/62#issuecomment-1669687341","body":"#使用dfs方法\r\n#记录当前已经使用的数字集合usedNumbers(使用0,1的数字序列表示.0表示未使用,1表示使用)\r\n#记录当前的所有数字的和desiredTotal\r\n\r\n#时间复杂度O(2^n x n)\r\n#空间复杂度O(2^n)\r\n```\r\nclass Solution:\r\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\r\n        @cache\r\n        def dfs(usedNumbers: int, currentTotal: int) -> bool:\r\n            for i in range(maxChoosableInteger):\r\n                if (usedNumbers >> i) & 1 == 0:\r\n                    if currentTotal + i + 1 >= desiredTotal or not dfs(usedNumbers | (1 << i), currentTotal + i + 1):\r\n                        return True\r\n            return False\r\n\r\n        return (1 + maxChoosableInteger) * maxChoosableInteger // 2 >= desiredTotal and dfs(0, 0)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/63#issuecomment-1671315099","body":"```\r\n#要分割成两个相等的子集，说明一个数组的元素和要为s=sum(nums)/2\r\n# if  如果s is float，那么在整数数字列表中肯定无法得到一个整数\r\n# else 枚举所有和为s的子集\r\n# 暴力枚举的话复杂度为O(n * 2^n),其中系数n是sum计算的线性复杂度，空间复杂度为O(n),就是子集的长度\r\nimport numpy as np\r\n#可以看成0-1背包问题的变形\r\nclass Solution:\r\n    def canPartition(self, nums: List[int]) -> bool:\r\n        n=len(nums)\r\n        s=sum(nums)\r\n        #是奇数\r\n        if s&1 : return False\r\n        target=int(s/2)\r\n        print(target)\r\n        dp=[[False]*(target+1) for _ in range(n)]\r\n        print(len(dp),len(dp[0]))\r\n        #对于dp[i][j]状态的含义\r\n        #考虑坐标区间为[0,i]的所有整数,在它们当中是否能选出一些数字，能使得这些数字之和恰好为j\r\n        \r\n        if nums[0]<=target: dp[0][nums[0]]=True\r\n        for i in range(1,n):\r\n            for j in range(target+1):\r\n                # print(i,j)\r\n                #如果不考虑当前元素,则dp[i-1][j]的值跟上一行的值一样\r\n                try:dp[i][j]=dp[i-1][j]\r\n                except:print('error1',i,j)\r\n\r\n                #如果考虑当前元素，且当前元素就为j\r\n                try:\r\n                    if (nums[i]==j): dp[i][j]=True\r\n                except:print('error2',i,j)\r\n\r\n                #如果考虑当前元素，且当前元素<j\r\n                if nums[i]<j: dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]\r\n        return dp[n-1][target]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/64#issuecomment-1673501554","body":"```\r\n记neg为负数之和，pos为正数之和\r\n# pos + neg = target\r\n# pos - neg = sum\r\n# pos = (target+sum)/2\r\n# 转换成从数值列表里面找到n个数字，使得和为pos\r\nclass Solution:\r\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\r\n        pos=(sum(nums)+target)/2\r\n        if pos - int(pos)!=0:return 0\r\n        else: pos=int(pos)\r\n\r\n        n=len(nums)\r\n\r\n        dp=[[0]*(pos+1) for _ in range(n)]\r\n        \r\n        #dp[i][j]表示第[0,i]个位置中有n种方法能找到数字使得和为j\r\n        #初始化边界条件\r\n        #当j=0,对应的方案为1,表示不取任何元素\r\n        for i in range(n): dp[i][0]=1\r\n        # 当i=0时,当nums[0]=j时候，dp[i][j]=1\r\n        for j in range(pos+1):\r\n            if j==nums[0]:\r\n                dp[0][j]=1\r\n\r\n        for i in range(1,n):\r\n            for j in range(1,pos+1):\r\n                if nums[i]<=j:\r\n                     dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j]\r\n                else:dp[i][j]=dp[i-1][j]\r\n        print(dp)\r\n        return dp[-1][-1]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/65#issuecomment-1674890323","body":"```python\n#时间复杂度O(n*amount),空间复杂度O(n*amount)\n#F(s)为总问题，表示当金额为s时候，选取的最少硬币数目\n#F(s1),F(s2),F(s3)...为子问题\n#关键在于初始化dp矩阵的x轴和y轴\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n=len(coins)\n        dp=[[float('inf')]*(amount+1) for _ in range(n)]\n        for i in range(n):dp[i][0]=0\n        for j in range(amount+1):\n            if coins[0]==j: \n                dp[0][j]=1\n\n        for i in range(n):\n            for j in range(amount+1):\n                if coins[i]<=j:\n                    dp[i][j]=min(dp[i-1][j],dp[i][j-coins[i]]+1)\n                else:\n                    dp[i][j]=dp[i-1][j]\n        # print(dp)\n        return dp[-1][-1] if dp[-1][-1]!=float('inf') else -1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/66#issuecomment-1675931079","body":"```python\r\n#时间复杂度O(n*amount),空间复杂度O(n*amount)\r\n#F(s)为总问题，表示当金额为s时候，选取的最多组合数字\r\n#F(s1),F(s2),F(s3)...为子问题\r\n#关键在于初始化dp矩阵的x轴和y轴\r\nclass Solution:\r\n    def coinChange(self, coins: List[int], amount: int) -> int:\r\n        n=len(coins)\r\n        dp=[[float('inf')]*(amount+1) for _ in range(n)]\r\n        for i in range(n):dp[i][0]=0\r\n        for j in range(amount+1):\r\n            if coins[0]==j: \r\n                dp[0][j]=1\r\n\r\n        for i in range(n):\r\n            for j in range(amount+1):\r\n                #使用当前coins[i]\r\n                if coins[i]<=j:\r\n                    dp[i][j]=dp[i-1][j]+dp[i][j-coins[i]]\r\n                else:\r\n                    #不使用当前coins[i]\r\n                    dp[i][j]=dp[i-1][j]\r\n        # print(dp)\r\n        return dp[-1][-1]\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/67#issuecomment-1676363186","body":"```python\r\n#假设胃口 m,n=len(g),len(s)\r\n#时间复杂度为排序的时间O(nlogn+mlogm)+遍历复杂度O(m+n)\r\n#空间复杂度为排序的空间O(logm+logn)\r\nclass Solution:\r\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\r\n        #基本思想，用最大的饼干满足胃口最大的孩子\r\n        s.sort(reverse=True)\r\n        g.sort(reverse=True)\r\n        cnt = 0\r\n        i,j = 0,0 \r\n        while i<len(g) and j<len(s):\r\n            if g[i]<=s[j]:\r\n                cnt+=1\r\n                j+=1\r\n            i+=1\r\n        return cnt","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/68#issuecomment-1677614624","body":"```python\r\n#基本思想 选择右端点最小的区间1作为左侧区间，再选择与区间1不重合的右侧端点最小的区间，剩余部分主要在代码实现上\r\n#时间复杂度排序O（nlogn）+遍历O（n）=O（nlogn）\r\n#空间负责度排序O（nlogn）\r\nclass Solution:\r\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\r\n       intervals.sort(key=lambda x: [x[1],x[0]])\r\n       head=intervals[0]\r\n       cnt=1\r\n\r\n       n=len(intervals)\r\n       for i in range(1,n):\r\n           if intervals[i][0]>=head[1]:\r\n               cnt+=1\r\n               head=intervals[i]\r\n       return n-cnt\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/69#issuecomment-1679195149","body":"```python\n#第0个位置能跳到的最大长度是否 >= n\n# => 第n-1个位置能跳的最大长度\n# => 第n-2个位置能跳的最大长度\n#...\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        n=len(nums)\n        if n==1 : return True\n\n        dp=[0]*n\n        for i in range(n)[::-1]:\n            if i==n-1:\n                dp[i]=nums[i]\n            else:\n                dp[i]=max(1+dp[i+1],nums[i]) if nums[i]>0 else 0\n            # print(i,dp[i])\n        print(dp)\n        return dp[0]>=n-1","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/70#issuecomment-1680871947","body":"class Solution:\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        G = [0]*(n+1)\n        G[0], G[1] = 1, 1\n\n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                G[i] += G[j-1] * G[i-j]\n        return G[n]","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/74#issuecomment-1685308799","body":"```python\r\n#时间复杂度。子集个数，O(2^n)个,从头计算O(n),合并O(n*2^n)\r\n#空间复杂度。每次存储的子集,O(n)\r\n#使用dfs树搜索子集\r\nclass Solution:\r\n    def subsets(self, nums: List[int]) -> List[List[int]]:\r\n        ans=[]\r\n        #i表示以nums[i]开头构造子集,j表示已经选取到nums[j]\r\n        def f(nums,i,j,subset):\r\n            if i==len(nums):return \r\n            if j==len(nums):\r\n                #用判断语句去重\r\n                if subset not in ans:\r\n                    ans.append(subset)\r\n                return\r\n            \r\n            f(nums,i,j+1,subset+[nums[j]])\r\n            f(nums,i,j+1,subset)\r\n        \r\n        #主程序\r\n        for i in range(len(nums)):\r\n            f(nums,i,i,[])\r\n        return ans","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/80#issuecomment-1694394764","body":"class Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        if len(connections) < n - 1:\n            return -1\n        \n        edges = collections.defaultdict(list)\n        for x, y in connections:\n            edges[x].append(y)\n            edges[y].append(x)\n        \n        seen = set()\n\n        def dfs(u: int):\n            seen.add(u)\n            for v in edges[u]:\n                if v not in seen:\n                    dfs(v)\n        \n        ans = 0\n        for i in range(n):\n            if i not in seen:\n                dfs(i)\n                ans += 1","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null],"jamjid":[{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/2#issuecomment-1585694528","body":"思路\n使用逐位相加的思路解决，同时考虑A和K的长度比较\n\n代码\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        n = len(A)\n        ans = []\n\n        for i in range(n-1, -1, -1):\n            total = A[i] + K % 10\n\n            K //= 10\n            \n            if total >= 10:\n                #当前位相加结果大于 10 时，进位 1 加入下一位计算\n                K += 1\n\n            ans.append(total % 10)\n            \n        # 这里考虑数组 A 的长度小于整数 K 位数个数的情况\n        while K > 0:\n            ans.append(K % 10)\n            K //= 10\n        # 因为添加进来是由低位往高位，输出时进行逆序输出\n        return ans[::-1]\n\n复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/3#issuecomment-1586192759","body":"思路\n首先应该获取到该字符在字符串 s 中的所有下标位置，遍历一次字符串，并将等于目标字符的下标添加至动态数组arr中，使用指针比较下标间的最短距离。\n\n代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res, p, arr = [], 0, [i for i in range(len(s)) if s[i] == c]\n        for i, j in enumerate(s):\n            if p < len(arr) - 1 and abs(arr[p] - i) > abs(arr[p + 1] - i):\n                p += 1\n            res.append(abs(arr[p] - i))\n        return res\n\n复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/4#issuecomment-1587511888","body":"思路\n创建两个数组stack和nums 添加一个指针p\n\n代码\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.stack = [0] * maxSize\n        self.nums = [0] * maxSize\n        self.size = maxSize - 1\n        self.p = -1\n\n    def push(self, x: int):\n        if self.p != self.size:\n            self.p += 1\n            self.stack[self.p] = x\n\n    def pop(self):\n        if self.p == -1:\n            return -1\n        x, val = self.stack[self.p], self.nums[self.p]\n        self.nums[self.p] = 0\n        self.p -= 1\n        if self.p != -1:\n            self.nums[self.p] += val\n        return x + val\n\n    def increment(self, k: int, val: int):\n        if self.p >= 0:\n            k = min(self.p, k - 1)\n            self.nums[k] += val\n\n复杂度\n时间复杂度O(1)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/5#issuecomment-1589095858","body":"思路\n遍历给定字符串，遇到非 ] 入栈\n\n代码\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in s:\n            if i == ']':\n                strs = ''\n                repeat = ''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop() + repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n\n复杂度\n时间复杂度O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/6#issuecomment-1591366307","body":"思路\n队列是一种先入先出的数据结构，而栈是一种后入先出的数据结构，所以一个栈绝对满足不了队列的特性，因此这里需要两个栈，分别是输入栈和输出栈：输入栈来反转元素的入队顺序，元素入只能从输入栈进。输出栈用来存储元素的正常顺序，元素出只能从输出栈出。\n\n代码\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        # 初始化输入栈和输出栈\n        self.inStack = []\n        self.outStack = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        # 有新元素进来，进入输入栈\n        self.inStack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        # 如果为空\n        if self.empty():\n            return None\n\n        # 如果输出栈不为空，返回输出栈中的元素\n        if self.outStack:\n            return self.outStack.pop()\n        # 输出栈为空,将输入栈的元素压入输出栈\n        else:\n            while self.inStack:\n                val = self.inStack.pop()\n                self.outStack.append(val)\n            return self.outStack.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        # 使用已有的函数 pop\n        res = self.pop()\n        # pop 函数弹出了 res，所以要再添加回去\n        self.outStack.append(res)\n\n        return res\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        # 两个栈都为空，队列才为空\n        if not(self.inStack or self.outStack):\n            return True\n\n        return False\n\n复杂度\n时间空间均为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/7#issuecomment-1593124261","body":"思路\n分割点的左边与右边各自排序后依然是升序的，每一次割点以及左边的最大值小于等于右边数组的最小值\n\n代码\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        n = len(arr)\n        # 生成后缀的最小值\n        post = [arr[-1]]\n        for i in range(n-2, -1, -1):\n            post.append(min(post[-1], arr[i]))\n        post = post[::-1]\n\n        # 从前往后判断割点\n        ans = 0\n        pre = float('-inf')\n        for i in range(n):\n            pre = max(pre, arr[i])\n            if i+1 < n and pre <= post[i+1]:\n                ans += 1\n                pre = float('-inf')\n        ans += 1\n        return ans\n\n复杂度\n时间空间均为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-11-daily-check/issues/8#issuecomment-1594845895","body":"思路\n求链表长度 找出倒数第 k+1k+1k+1 个节点 将链表的倒数第 k+1k+1k+1 个节点和倒数第 kkk 个节点断开，并把后半部分拼接到链表的头部\n\n代码\nclass Solution:\n    def rotateRight(self, head, k):\n        if not head or not head.next: return head\n        # 求链表长度\n        _len = 0\n        cur = head\n        while cur:\n            _len += 1\n            cur = cur.next\n        # 对长度取模\n        k %= _len\n        if k == 0: return head\n        # 让 fast 先向后走 k 步\n        fast, slow = head, head\n        while k:\n            fast = fast.next\n            k -= 1\n        # 此时 slow 和 fast 之间的距离是 k；fast 指向第 k+1 个节点\n        # 当 fast.next 为空时，fast 指向链表最后一个节点，slow 指向倒数第 k + 1 个节点\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        # newHead 是倒数第 k 个节点，即新链表的头\n        newHead = slow.next\n        # 让倒数第 k + 1 个节点 和 倒数第 k 个节点断开\n        slow.next = None\n        # 让最后一个节点指向原始链表的头\n        fast.next = head\n        return newHead\n\n复杂度\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}