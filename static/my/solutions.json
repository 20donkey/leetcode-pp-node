{"577961141":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085986299","body":"## 题目思路\n解法一：假如，需要计算的数组为[1,2,3]和数字1095；首先向1095取余（以10），那么得到5再和数组3相加，得到8，将结果加入到新的数组；再将1095向下取整，再取余，得到9，在和数组的2相加，会发现得到的结果超过了10，那么就要将结果减10后加入新的数组，109还需要加一。重复以上步骤即可。\n\n解法二： 假如，需要计算的数组为[1,2,3]和数字1095；我们可以直接向1095加上数组的末尾的数，即1095+3然后取余，得到8，加入到新的数组中去，一直重复这个步骤即可。\n\n## 题目的题解code\n解法1：\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer[] $num\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function addToArrayForm($num, $k) {\n        $res = [];\n        for ($i = count($num) -1; $i >=0; $i--) {\n            $remainder = $k % 10;\n            $addVal = $remainder + $num[$i];\n\n            if ($addVal >= 10) {\n                $addVal = $addVal % 10;\n                $k = floor($k /10) + 1;\n            }else {\n                $k = floor($k /10);\n            }\n            $res[] = $addVal;\n        }\n        while($k) {\n            $res[] = $k % 10;\n            $k = floor($k /10);\n        }\n        return array_reverse($res);\n    }\n}\n```\n\n解法2：\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer[] $num\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function addToArrayForm($num, $k) {\n        $res = [];\n        for ($i = count($num) -1; $i >=0; $i--) {\n            $k = $num[$i] + $k;\n            $res[] = $k % 10;\n            $k = floor($k / 10);\n        }\n        while($k) {\n            $res[] = $k % 10;\n            $k = floor($k /10);\n        }\n        return array_reverse($res);\n    }\n}\n```\n\n## 时间和空间复杂度\n时间复杂度：O(max(n,logk)),其中n为数组的长度，k为数值的长度\n空间复杂度：O(1),除了返回值之外，其余全是常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086643481","body":"## 题目思路\n1. 先遍寻左边，记录上一次字符C出现的位置```prev```,那么答案就是```i-prev```\n2. 再遍寻右边，记录上一次字符C出现的位置```prev```,那么答案就是```prev-i```\n3. 最后比较相同位置的数值，谁小取谁\n\n## 题目的题解code\n```PHP\n<?php\n\nclass Solution {\n\n    /**\n     * @param String $s\n     * @param String $c\n     * @return Integer[]\n     */\n    function shortestToChar($s, $c) {\n        $ans = [];\n        $len = mb_strlen($s);\n\n        // 计算左边\n        $prev = PHP_INT_MIN / 2;\n        for ($i = 0; $i < $len; $i++) {\n            if ($s[$i] == $c) {\n                $prev = $i;\n            }\n\n            $ans[] = $i - $prev;\n        }\n\n        // 计算右边\n        $prev = PHP_INT_MAX / 2;\n        for ($j = $len - 1; $j >= 0; $j--) {\n            if ($s[$j] == $c) {\n                $prev = $j;\n            }\n\n            $ans[$j] = min($ans[$j], $prev - $j);\n        }\n\n        return $ans;\n    }\n}\n```\n\n\n## 时间和空间复杂度\n时间复杂度： O(N),N是字符串的长度，我们需要遍历两次\n空间复杂度： O(N),ans的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086858899","body":"## 题目思路\n额。思路没有挺简单的\n\n## 题目的题解code\n```PHP\n<?php\n\nclass CustomStack {\n    public $maxSize;\n    public $stack = [];\n    /**\n     * @param Integer $maxSize\n     */\n    function __construct($maxSize) {\n        $this->maxSize = $maxSize;\n    }\n\n    /**\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n        if  (count($this->stack) < $this->maxSize) {\n            array_push($this->stack, $x);\n        }\n\n        return null;\n    }\n\n    /**\n     * @return Integer\n     */\n    function pop() {\n        if (count($this->stack) <= 0) {\n            return -1;\n        }\n\n        return array_pop($this->stack);\n    }\n\n    /**\n     * @param Integer $k\n     * @param Integer $val\n     * @return NULL\n     */\n    function increment($k, $val) {\n        for ($i = 0; $i < $k && $i < count($this->stack); $i++) {\n            $this->stack[$i] += $val;\n        }\n\n        return null;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * $obj = CustomStack($maxSize);\n * $obj->push($x);\n * $ret_2 = $obj->pop();\n * $obj->increment($k, $val);\n */\n```\n\n## 时间和空间复杂度\n时间复杂度：所有操作的渐进时间复杂度均为O(1)。\n空间复杂度：这里用到了两个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为O(maxSize)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087609034","body":"## 题目思路\n用栈的方式进行题解\n1. 将`数字`、`字母`、`[`一个一个加入到栈中；\n2. 如果遇到`]`,就从栈中取出字母，直到遇到`[`\n3. 将`[`去掉，然后从栈中取出数字（判断是否为数字，因为可能有多个）\n4. 重复这些字母\n5. 重复上面的步骤\n\n## 题目的题解code\n```PHP\nclass Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function decodeString($s) {\n        $stack = [];\n        for ($i = 0; $i < mb_strlen($s); $i++) {\n             if ($s[$i] === \"]\") {\n                 $repeatStr = \"\";\n                 $repeatCount = \"\";\n\n                 while ($stack && end($stack) !== \"[\") {\n                     $repeatStr = array_pop($stack).$repeatStr;\n                 }\n\n                 // 去掉[\n                 array_pop($stack);\n\n                 while ($stack && is_numeric(end($stack))) {\n                     $repeatCount = array_pop($stack).$repeatCount;\n                 }\n\n                 $repeatStr = str_repeat($repeatStr, (int)$repeatCount);\n                 array_push($stack, $repeatStr);\n            } else {\n                 array_push($stack, $s[$i]); // 加入栈中\n             }\n        }\n        return implode('', $stack);\n    }\n}\n```\n\n\n## 时间和空间复杂度\n时间复杂度：O(N)，其中 N 为解码后的 s 的长度。\n空间复杂度：O(N)，其中 N 为解码后的 s 的长度。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1973719588":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085541708","body":"思路：将int型的数字变为str字符串型的就很好处理了\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        i = ''\r\n        for x in num:\r\n            i = i + str(x)\r\n        numi = int(i)\r\n        xx = numi + k\r\n        ls = []\r\n        for s in str(xx):\r\n            ls.append(int(s))\r\n\r\n        return ls\r\n```\r\n\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zacherycao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085303351","body":"## Idea\nScan the array from end to begin. Use an extra variable to record the carry number.\n\n## Code\n```python 3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = k\n        for i in range(len(num) - 1, -1, -1):\n            total = (num[i] + carry)\n            carry = total // 10\n            A = total % 10\n            num[i] = A\n        if carry:\n            return [int(i) for i in str(carry)] + num\n        return num\n                \n```\n\n## Complexity:\nTime: O(N). N = max(len(num), len(k))\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086642145","body":"## Idea\nDeque q for the index of character c. For each index i in s check whether abs(i - q[0])>abs(i - q[1]) and q has more than 1 element. If it is, pop the most front element from the q. \n\n## Code\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        position = collections.deque()\n        for i in range(len(s)):\n            if s[i] == c:\n                position.append(i)\n        ans = []\n        for i in range(len(s)):\n            if len(position)>1 and abs(i-position[0])>abs(i-position[1]):\n                position.popleft()\n            ans.append(abs(i-position[0]))\n        return ans\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086894362","body":"## Idea\nSimulation\n\n## Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.cap = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.cap:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n\n```\n\n## Complexity:\nTime: Increment: O(k.) Others: O(1)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087668420","body":"## Idea\nStack\n\n## Code\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        l=[]\n        for i in s:\n            if i!=']':\n                l.append(i)\n            else:\n                if len(l)==0:\n                    break\n                temp=''\n                while l[-1]!='[':\n                    temp=l.pop()+temp\n                l.pop()\n                temp2=''\n                while len(l)>0 and l[-1].isdigit():\n                    temp2=l.pop()+temp2\n                res=temp*int(temp2)\n                l.append(res)\n        \n        ans=''\n        for i in l:\n            ans+=i\n        return ans\n```\n\n## Compexity:\nTime: O(maxK^Countk * N)\nSpace: O(sum(maxK ^CountK*n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088734659","body":"## Idea\nTwo stacks. One for push, one for peek and pop\n\n## Code\n\n```python\nclass MyQueue:\n    def __init__(self):\n        self.instack = []\n        self.outstack = []\n\n    def push(self, x: int) -> None:\n        self.instack.append(x)\n\n    def pop(self) -> int:\n        if not self.outstack:\n            while self.instack:\n                self.outstack.append(self.instack.pop())\n        return self.outstack.pop()\n\n    def peek(self) -> int:\n        if not self.outstack:\n            while self.instack:\n                self.outstack.append(self.instack.pop())\n        return self.outstack[-1]\n\n    def empty(self) -> bool:\n        return len(self.instack)==0 and len(self.outstack) == 0\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n## Complexity:\nSapce: O(N)\nTime: PushL O(1). Pop & peek: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freedom0123":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085327382","body":"> 实现思路\n\n实际上就是一个模拟人工加法的过程\n\n> 复杂度分析\n1. 时间复杂度：O(n)\n2. 空间复杂度：O(n)\n\n> 代码实现\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> ans = new ArrayList<>();\n        num[n-1] += k;\n        int t  = 0;// 用 t 来表示进位 \n        for(int i = n - 1; i >=0 ; i--) {\n            // 比如说 now = 11， ans 的当前位就是 1，进位为 10\n            int now = num[i] + t; // 当前位 + 进位之后的结果\n            ans.add(now % 10);// ans 中当前位的结果是 now 的个位\n            t = now / 10; // 进位就是 除了个位 以上的为\n        }\n        if(t > 0){\n            while(t != 0) {\n                ans.add(t % 10);\n                t /= 10;\n            }\n        }\n        Collections.reverse(ans); \n        return ans;\n    }\n}\n\n```\n> [高精度加法](https://www.acwing.com/problem/content/description/793/)\n> Acwing\n\n```markdown\n给定两个正整数（不含前导 0），计算它们的和。\n\n # 输入格式\n \n共两行，每行包含一个整数。\n\n # 输出格式\n共一行，包含所求的和。\n\n# 数据范围\n1≤ 整数长度 ≤100000\n```\n\n```c\n#include<iostream>\n#include<cstring>\n#include<vector> \nusing namespace std;\nvector<int> add(vector<int> A,vector<int> B) {\n    if(A.size() < B.size()) return add(B,A);\n    vector<int> C;\n    int t = 0;// 表示进位\n    for(int i = 0 ;i < A.size(); i++) {\n        t += A[i];\n        if(i < B.size()) t+= B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n    if(t > 0) {\n        while(t !=0 ) C.push_back(t % 10), t/=10;\n    }\n    return C;\n    \n}\nint main() {\n    string a,b;\n    vector<int> A,B;\n    cin>>a>>b;\n    for(int i = a.size()-1; i >=0 ;--i) {\n        A.push_back(a[i] - '0');\n    }\n    for(int i = b.size() - 1; i >= 0; --i) {\n        B.push_back(b[i] - '0');\n    }\n    auto C = add(A,B);\n    for(int i = C.size() - 1; i >= 0; i--){\n        cout<<C[i];\n    }\n    return 0;\n    \n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086474703","body":"[原题链接](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n> 算法一\n1. 时间复杂度为：O(n ^ 2)\n2. 思路：暴力枚举，对于每个位置都向左右两个方向进行搜索，判断每个位置上的字符是否是c，如果是，进行相应的计算即可\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        for(int i = 0; i < n; i++){\n            int left = i;\n            int right = i+1;\n            int res  = Integer.MAX_VALUE;\n            while(left >= 0) {\n                if(s.charAt(left) == c) res = Math.min(res, Math.abs(i - left));\n                left --;\n            }\n            while(right < n) {\n                if(s.charAt(right) == c) res = Math.min(res, Math.abs(i - right));\n                right ++;\n            }\n            ans[i] = res;\n        }\n        return ans;\n    }\n}\n```\n> 算法二\n \n\n  - 时间复杂度：O(n)\n-  思路： 在算法一中，对于每个位置我们都要向左 和向右搜索距离这个位置最近的c，这种算法的时间复杂度很高，并且在做很多无用功。对于每个位置，我们如果说知道了他的前一位，距离最近的c    的位置，我们就不需要每个位置都进行枚举\n-  通过这种思想，我们只需要向左扫一遍，记住每个位置上，左边距离它最近的c的距离；在向右扫一遍，记住每个位置上，右边距离它最近的c的位置，就行。\n- 这里pre 除以2 的目的是为了，防止越界 \n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        int pre = Integer.MIN_VALUE / 2;\n        for(int i = 0; i < n; i++) {\n            if(s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for(int i = n -1; i >= 0; i--) {\n            if(s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i],pre- i);\n        }\n        return ans;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086787651","body":"[原题链接](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n@[toc]\n# 思路\n题目中已经确切的告诉了我们，数组中会放入多少个元素，这种情况并且只有添加操作，这种情况之下，使用数组模拟效率会更高一点。\n# 代码\n> 用数组模拟栈,击败100%\n```java\nclass CustomStack {\n    private int[] stack;\n    private int tt;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(tt == stack.length) return;\n        stack[tt++] = x;\n    }\n    \n    public int pop() {\n        if(tt == 0) return -1;\n        return stack[--tt];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i < tt; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n#  用数组来模拟栈\n> 用一个数组来表示栈结构，并且加一个索引来方便操作,这里的 tt 指向的是 下一次要放的位置 \n\n```c\nconst int N  = 10010;\nint stack[N];\nint tt;\n// 向栈中添加元素\nstack[tt++] = x;\n// 弹出栈顶元素\n--tt;\n// 判断栈是否是空\ntt == 0;\n// 栈顶\nint top = tt;\nstack[top--];\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087502634","body":"```\nclass Solution {\n    public String decodeString(String s) {\n        //定义结果\n        StringBuffer buffer = new StringBuffer();\n        //用来 定义字符栈\n        LinkedList<String> listString = new LinkedList<>();\n        // 用来定义数字栈\n        LinkedList<Integer> listInt = new LinkedList<>();\n        for(int i = 0;i<s.length();){\n            if(s.charAt(i)!=']'){\n                char a = s.charAt(i);\n                if(a>'9' || a<'0'){\n                    //进入字符栈中\n                    listString.add(a+\"\");\n                    i++;\n                }else{\n                    //就是数字，进入数字栈中\n                    int j  = i+1;\n                    int tem = a-'0';\n                    while(s.charAt(j)<='9' && s.charAt(j)>='0' && j<s.length()){\n                        tem = tem *10 + (s.charAt(j)-'0');\n                        j++;\n                    }\n                    i = j;\n                    listInt.add(tem);\n                }\n            }else{\n                //用来取出字符栈中的元素\n                String temString = new String();\n                //用来拿出栈顶的数字\n                int temInt = listInt.getLast();\n                listInt.removeLast();\n                // 循环拿出 字符\n                while(!listString.isEmpty() && !listString.getLast().equals(\"[\")){\n                    temString = listString.getLast()+temString;\n                    listString.removeLast();\n                }\n                listString.removeLast();\n                StringBuffer sb = new StringBuffer();\n                for(int k = 1;k<=temInt;k++){\n                    sb.append(temString);\n                }\n                //如果说listInt不是空的，就将结果压在listString栈中\n                if(!listInt.isEmpty()){\n                    listString.add(sb.toString());\n                }else{\n                    //反之，加到结果中\n                    String ss = \"\";\n                    while(!listString.isEmpty()){\n                        ss = listString.getLast()+ss;\n                        listString.removeLast();\n                    }\n                    buffer.append(ss);\n                    buffer.append(sb);\n                }\n                i++;\n            }\n        }\n        if(!listString.isEmpty()){\n            for(int i =0;i<listString.size();i++){\n                buffer.append(listString.get(i));\n            }\n        }\n        return buffer.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088670739","body":"\n# 思路\n栈的特点是先进后出， 队列的特点是先进先出。 我们可以设计两个栈， 一个栈`stackPush`用来存放数据， 另一个栈`stackPop`用来存放`stackPush`栈中元素的倒序结果， 利用栈的特点，删除`stackPop`的栈顶， 就相当于进行了出队操作。 比如说：\n\n- `stackPush`: 栈底 1 2 3 4 5  栈头\n- `stackPop`:  栈底 5 4 3 2 1   栈头\n\n按照队列的顺序` 1 2 3 4 5 `。出队的话，就是出 1，相当于就是 `stackPop`的队头。\n\n\n\n> 向栈中添加元素\n\n- 向`stackPush`中添加即可\n\n> 删除队头元素\n - 当`stackPop`中仍然有元素的时候，直接返回头即可\n - 如果上一步没有执行，说明`stackPop`中没有元素，先判断一下 ，有没有向`stackPush`中添加元素，如果说没有，返回 -1\n - 最后，说明`stackPush`中有元素，但是没有倒在`stackPop`中，倒入\n - 返回 `stackPop`的栈顶\n\n# 代码\n```java\nclass MyQueue {\n    private LinkedList<Integer> stackPush;\n    private LinkedList<Integer> stackPop;\n    private int size;\n    public MyQueue() {\n        size = 0;\n        stackPop = new LinkedList<>();\n        stackPush = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        size++;\n        stackPush.add(x);\n    }\n    \n    public int pop() {\n        size--;\n        //移除队列开头的元素\n        if(!stackPop.isEmpty()) return stackPop.removeLast();\n        if(stackPush.isEmpty()) return -1;\n        while(!stackPush.isEmpty()) {\n            stackPop.addLast(stackPush.removeLast());\n        }\n        return stackPop.removeLast();\n    }\n    \n    public int peek() {\n        // 返回队列开头的元素\n        if(!stackPop.isEmpty()) return stackPop.getLast();\n        if(stackPush.isEmpty()) return -1;\n        while(!stackPush.isEmpty()) {\n            stackPop.add(stackPush.removeLast());\n        }\n        return stackPop.getLast();\n\n    }\n    \n    public boolean empty() {\n        return size == 0;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tonylee017":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085338085","body":"#### 思路\n\n直接把k加到num[i]上，保留个位数在num[i]，k取为其他位数。\n\n#### 代码实现\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\ti = len(num)-1\n        while k:\n            num[i] += k\n            k, num[i] = num[i]//10, num[i]%10\n            i -= 1\n            if i<0 and k:\n                num.insert(0,0)\n                i = 0 \n        return num\n```\n#### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088864782","body":"#### 思路\n利用双栈进行模拟队列，stack_push作为输入的栈，保存所有元素，stack_pop作为输出的栈。\n\n#### 代码\nclass MyQueue:\n\n    def __init__(self):\n        # 使用两个栈. 一个用来push stack_push, 一个用来pop stack_pop.\n        self.stack_push = []\n        self.stack_pop = []\n\n    def push(self, x: int) -> None:\n        self.stack_push.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return -1\n        self.peek()\n        return self.stack_pop.pop()\n\n    def peek(self) -> int:\n        if not self.stack_pop:\n            while self.stack_push:\n                self.stack_pop.append(self.stack_push.pop())\n        return self.stack_pop[-1]\n\n    def empty(self) -> bool:\n        return not self.stack_push and not self.stack_pop\n\n#### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youxucoding":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085341434","body":"### 思路\r\n\r\n模拟加法，类似链表两数相加那题，所以我使用的LinkedList。\r\n\r\n\r\n### 代码实现\r\n```java \r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int vaild = 0;\r\n        int i = num.length-1;\r\n        while(i >= 0 || k > 0){\r\n            int cur = 0;\r\n            if(i < 0){\r\n                cur = (k % 10) + vaild;\r\n            }else if(k == 0){\r\n                cur = num[i] + vaild;\r\n            }else{\r\n                cur = num[i] + (k % 10) +vaild;\r\n            }\r\n            vaild = cur/10;\r\n            cur = cur % 10;\r\n            k = k / 10;\r\n            i--;\r\n            res.addFirst(cur);\r\n        }\r\n        if(vaild > 0){\r\n            res.addFirst(vaild);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086568629","body":"> 4月2日\n\n- 【day02】\n\n### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n难度简单218\n\n给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。\n\n返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。\n\n两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。\n\n \n\n**示例 1：**\n\n```java\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n```\n\n\n\n### 思路：\n\n1. 暴力解法：得到所有目标字符的下标，遍历字符串一一比较，获得最近距离\n2. 滑动窗口：按照目标字符重复出现的位置，将字符串划分为若干窗口，在窗口内就可以计算出当前下标与目标字符最近距离。\n\n### 代码实现：\n\n- 暴力解法：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> list = new ArrayList<>();\n        int res[] = new int[s.length()];\n        for(int i = 0;i < s.length();i++){\n            if(s.charAt(i) == c){\n                list.add(i);\n            }\n        }\n        for(int j = 0;j < s.length();j++){\n            res[j] = Integer.MAX_VALUE;\n            for(Integer i : list){\n                res[j] = Math.min(res[j],Math.abs(j-i));\n            } \n        }\n        return res;\n    }\n}\n```\n\n- 滑动窗口：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int cur = 0;\n        int left = Integer.MAX_VALUE;\n        int right = -1;\n        int res[] = new int[s.length()];\n        while(cur < s.length()){\n            right++;\n            while((s.charAt(right) == c || right == s.length() - 1)&&cur <= right){\n               if((right == s.length() - 1) && (s.charAt(right) != c)){\n                   res[cur] = Math.abs(cur - left);\n                   cur++;\n               }else{\n                    res[cur] = Math.min(Math.abs(cur-left),Math.abs(cur-right));\n                    if(cur == right){\n                        left = cur;\n                    }\n                    cur++;\n                }\n                \n            }\n\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 暴力解法：\n  - 时间复杂度：O(m*n)\n  - 空间复杂度：O(n)\n- 滑动窗口：\n  - 时间复杂度：O(n)\n  - 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086783707","body":"> 4月3日\r\n\r\n- 【day03】\r\n\r\n#### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n难度  中等\r\n\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 `CustomStack` ：\r\n\r\n- `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\r\n- `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 `x` 添加到栈顶。\r\n- `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 **-1** 。\r\n- `void inc(int k, int val)`：栈底的 `k` 个元素的值都增加 `val` 。如果栈中元素总数小于 `k` ，则栈中的所有元素都增加 `val` 。\r\n\r\n### 思路：\r\n\r\n看到题目上的前缀和标签就尝试了使用差分数组思想，构建原数组（也就是本题中的栈）的差分数组。在差分数组目标区间起点增加值，在终点后一位减值。最后通过差分数组更新原数组。\r\n\r\n\r\n\r\n### 代码实现：\r\n\r\n```java\r\nclass CustomStack {\r\n    private int stack[];\r\n    private int top;\r\n    private int diff[];\r\n    public CustomStack(int maxSize) {\r\n        this.stack = new int[maxSize];\r\n        this.top = -1;\r\n        this.diff = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < stack.length - 1){\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top > -1){\r\n            return stack[top--];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        diff[0] = stack[0];\r\n        for(int i = 1;i <= top;i++){\r\n            diff[i] = stack[i] - stack[i-1];\r\n        }\r\n        if(k > top+1){\r\n            diff[0] += val;\r\n        }else{\r\n        diff[0] += val;\r\n        diff[k] -= val;\r\n        }\r\n\r\n        stack[0] = diff[0];\r\n        for(int i = 1;i <= top;i++){\r\n            stack[i] = diff[i] + stack[i-1];\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析：\r\n\r\n- 时间复杂度：O(N) N为题中方法 increment 参数k\r\n- 空间复杂度：O(N) N = maxSize\r\n\r\nps:使用差分数组思想不是最优解","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087489461","body":"> 4月3日\n>\n> - 【day03】\n\n#### [leetcode.394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n难度   中等\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n \n\n**示例 1：**\n\n```java\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n```\n\n**示例 2：**\n\n```java\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n```\n\n\n\n### 思路：\n\n使用栈辅助，数字字符也就是倍数需要一个栈维护，要重复的字符串需要一个栈维护，本题难点在于字符串中存在嵌套方括号，需要从里向外一层层抽丝剥茧一般解决问题，类似于递归，因此需要使用栈。\n\n细节：遍历字符串，每当遇到数字或字符记录到数字变量和字符串变量中，每个数字字符出现也意味着左括号的出现，每当遇到左括号时，数字变量和字符串变量压入相应的栈中，当遇到右括号时就是真正“解码”的时刻，当遍历到第一个右括号，此时计算的是 **最内层的结果** : 当前字符串变量重复刚刚入栈的倍数（也就是处于**栈顶的倍数**）再连接上当前左括号与前一个左括号中的字符串（**此字符串应在对应的字符串辅助栈顶**） 到此最内层括号中“解码”完毕，向外的每一层同理即可。\n\n\n\n### 代码实现：\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n\t\tDeque<Integer> num_stack = new LinkedList();\n        Deque<StringBuffer> string_stack = new LinkedList();\n        int num = 0;\n        StringBuffer res = new StringBuffer();\n        for(Character c : s.toCharArray()){\n            if(c == '['){\n                num_stack.push(num);\n                string_stack.push(res);\n                num = 0;\n                res = new StringBuffer();\n            }else if(c == ']'){\n                StringBuffer temp = new StringBuffer();\n                Integer cur_num = num_stack.pop();\n                for(int i = 0;i < cur_num;i++){\n                    temp.append(res);\n                }\n                res = string_stack.pop().append(temp);\n            }else if(c >= '0' && c <= '9'){\n             \tnum = num * 10 + Integer.parseInt(c+\"\");\n            }else{\n                res.append(c);\n            }\n        }\n        return res.toString();\n\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088233081","body":"\n> 4月5日 【day05】\n\n### [leetcode.232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n难度  简单\n\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n\n实现 `MyQueue` 类：\n\n- ``void push(int x)`` 将元素 x 推到队列的末尾\n- `int pop()` 从队列的开头移除并返回元素\n- `int peek()` 返回队列开头的元素\n- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n\n**说明：**\n\n- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n**示例 1：**\n\n```java\n输入：\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n```\n\n\n\n### 思路：\n\n题目中明确需要使用**两个栈** 实现队列，队列的特点是先进先出，队尾进队头出，队尾进入我们可以使用压栈实现（栈头即队尾），关键点在于队头出队怎么实现？\n\n使用两个栈，一个称为stack_tail 即栈头是队尾，另一个成为stack_head 即栈头是队头，实现push() 直接向stack_tail压栈即可，当实现pop()时，将stack_tail栈中元素逐个弹出，并逐个压入stack_head，此时``stack_head.pop()``将弹出队头元素，再将此栈逐个弹出并压入stack_tail中，至此pop实现完成，stack_tai栈中的栈底元素（即队头）已经弹出。\n\n\n\n### 代码实现：\n\n```java\nclass MyQueue {\n    private Stack<Integer> stack_head;\n    private Stack<Integer> stack_tail;\n    public MyQueue() {\n        stack_head = new Stack<Integer>();\n        stack_tail = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        stack_tail.push(x);\n    }\n    \n    public int pop() {\n        int res = 0;\n        if(!stack_tail.empty()){\n            while(!stack_tail.empty()){\n                stack_head.push(stack_tail.pop());\n            }\n            res = stack_head.pop();\n            while(!stack_head.empty()){\n                stack_tail.push(stack_head.pop());\n            }\n        }\n        return res;\n    }\n    \n    public int peek() {\n        int res = 0;\n        if(!stack_tail.empty()){\n            while(!stack_tail.empty()){\n                stack_head.push(stack_tail.pop());\n            }\n            res = stack_head.peek();\n            while(!stack_head.empty()){\n                stack_tail.push(stack_head.pop());\n            }\n        }\n        return res;\n    }\n    \n    public boolean empty() {\n        return stack_tail.empty();\n    }\n}\n\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：\n  - push：O(1)\n  - pop：O(N)\n  - peek：O(N)\n  - empty：O(1)\n- 空间复杂度：\n  - push：O(1)\n  - pop：O(N)\n  - peek：O(N)\n  - empty：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forestie9":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085353261","body":"### Idea\nConvert int item in list to get the first value, and add up with k. Then convert the final value to item in a list.\n\n### Code\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = ''.join([str(i) for i in num])\n        summ = str(int(s) + k)\n        return [int(i) for i in summ]\n```\n### Complexity\nTime O(n) <br>\nSpace O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086719398","body":"## Ideas\nUse addition array to make `increment` O(1)\n\n## Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.len = maxSize\n        self.s = []\n        self.inc = []\n        \n    def push(self, x: int) -> None:\n        if len(self.s) < self.len:\n            self.s.append(x)\n            self.inc.append(0)\n        \n    def pop(self) -> int:\n        if not self.inc: return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        return self.s.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, len(self.inc)) - 1] += val\n```\n## Complexity\nO(1) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086905383","body":"## Ideas\nUse stack to track letter and count, reset values in every left bracket\n## Code\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        num = 0\n        string = ''\n        stack = []\n        for i in s:\n            if i.isdigit():\n                num = num*10 + int(i)                                \n            elif i == '[':\n                stack.append((string, num))\n                string = ''\n                num = 0\n            elif i == ']':\n                pre, k = stack.pop()\n                string = pre + k * string\n            elif i.isalpha():\n                string += i\n        return string\n```\n## Complexity\nO(n) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087860594","body":"### Ideas\nUse two stacks. Push to one stack, in peek and pop, reversely push element in first stack to second to get O(1).\n### Code\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.top = []\n        \n    def push(self, x: int) -> None:\n        self.stack.append(x)        \n\n    def pop(self) -> int:\n        self.peek()\n        return self.top.pop()\n        \n    def peek(self) -> int:\n        if not self.top:\n            while self.stack:\n                self.top.append(self.stack.pop())\n        return self.top[-1]\n        \n    def empty(self) -> bool:\n        return not self.stack and not self.top \n```\n### Complexity\nO(1) time and space","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"houmk1212":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085369488","body":"# 思路\n用数组模拟加法运算，注意进位和数组的长度。\n\n# 代码\npublic class ClockIn20220401 {\n    public static void main(String[] args) {\n  \n    }\n\n    public static void swap(int[] nums, int i, int j) {\n        if (i != j) {\n            nums[i] = nums[i] ^ nums[j];\n            nums[j] = nums[i] ^ nums[j];\n            nums[i] = nums[i] ^ nums[j];\n        }\n    }\n    public static int[] solution(int[] nums, int k) {\n        int upper = 0;\n        int exp = 1;\n        int n = nums.length;\n        int kLeng = 0;\n        // 先找最大的范围\n        for (int e = 1; k / e > 0; e *= 10) {\n            kLeng ++;\n        }\n        int maxLeng = Math.max(n , kLeng);\n        int[] result = new int[maxLeng + 1];\n        int i = 0;\n        int j = n-1;\n        while (i < n / 2) {\n            swap(nums, i , j);\n            i ++;\n            j --;\n        }\n        i = 0;\n        while (i < maxLeng || upper == 1) {\n            int left = i < n ? nums[i] : 0;\n            int right = k / exp > 0 ? (k / exp) % 10 : 0;\n            result[i] = (left + right + upper) % 10;\n            upper = left + right + upper >= 10 ? 1 : 0;\n            exp *= 10;\n            i ++;\n        }\n        int[] ans = new int[i];\n        int p = 0;\n        for (int q = i - 1; q >= 0; q--) {\n            ans[p ++] = result[q];\n        }\n        return ans;\n    }\n}\n\n# 复杂度\n时间复杂度: O(n + e)   n是数组的长度， e是k的位数;\n\n空间复杂度：O(max(n,e))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086508946","body":"# 思路\r\n因为是找左右侧距离目标字符的最短距离，想到类似单调栈的找右侧最小或者最大值的做法。左侧的目标字符的下表可以用一个变量存，右侧的目标距离可以用单调栈来得到。当目标元素入栈时，弹出所有栈中非目标字符，并得到他们的结果。\r\n# 代码\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        int[] ans = new int[s.length()];\r\n        int pre = - 1;\r\n        for (int i = 0 ; i < s.length(); i ++) {\r\n            if (s.charAt(i) == c) {\r\n                while (!stack.isEmpty() && s.charAt(stack.peek()) != c) {\r\n                    int p = stack.pop();\r\n                    ans[p] = pre >= 0 ? Math.min(Math.abs(p - i) , Math.abs(p - pre)) : Math.abs(p - i);\r\n                }\r\n                pre = i;\r\n            }\r\n            stack.push(i);\r\n        }\r\n        while (!stack.isEmpty()) {\r\n            int p = stack.pop();\r\n            ans[p] = s.charAt(p) == c ? 0 : Math.abs(p - pre);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n# 复杂度\r\n时间复杂度： 每个字符串s中的字符都要入栈一次，出栈一次，所以时间复杂度是O（N）， N是字符串的长度。\r\n空间复杂度：栈的大小，是O（N）。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086760827","body":"# 思路\n需要实现方便按索引存取的栈结构，所以用数组。\n\n# 代码\n```\nclass CustomStack {\n    int[] stack;\n    int top = 0;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top >= stack.length) return;\n        stack[top ++] = x;\n    }\n\n    public int pop() {\n        if (top == 0) return -1;\n        int peek = stack[top - 1];\n        top --;\n        return peek;\n    }\n\n    public void increment(int k, int val) {\n        int tmp = Math.min(top, k);\n        for (int i = 0; i < tmp; i++) {\n            sta ck[i] += val;\n        }\n    }\n}\n```\n\n# 复杂度分析\n时间复杂度： push和pop  都是O(1)  inc是O(K)\n\n空间复杂度： O(N)  N是数组的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087030986","body":"# 思路\n类似于括号匹配。遇到数字、左括号、字母入栈，遇到右括号，把到上一个左括号之间的内容弹出，并重复最后弹出的数字次数，并将结果重新入栈。最后结果会放在栈中。\n\n# 代码\n```\nclass Solution {\n    public boolean isNumber(char c) {\n        return c >= '0' && c <= '9';\n    }\n\n    public boolean isWord(char c) {\n        return c >= 'a' && c <= 'z';\n    }\n\n    public String decodeString(String s) {\n        int index = 0;\n        Stack<String> stack = new Stack();\n        int n = s.length();\n        while (index < n) {\n            if (isNumber(s.charAt(index))) {\n                int to = s.indexOf('[', index);\n                stack.push(s.substring(index, to));\n                index = to - 1;\n            } else if (isWord(s.charAt(index))) {\n                stack.push(s.substring(index, index + 1));\n            } else if (s.charAt(index) == '[') {\n                stack.push(\"[\");\n            } else { // s.charAt(index) == ']'\n                String tmp = \"\";\n                while (!stack.peek().equals(\"[\")) {\n                    tmp = stack.pop() + tmp;\n                }\n                stack.pop(); //弹出'['\n                int times = Integer.parseInt(stack.pop()) ;  // 弹出数字 也就是重复次数\n                String result = \"\";\n                for (int i = 0; i < times; i++) {\n                    result += tmp;\n                }\n                stack.push(result);\n            }\n            index++;\n        }\n        String ans = \"\";\n        while (!stack.isEmpty()) {\n            ans = stack.pop() + ans;\n        }\n        return ans;\n    }\n}\n```\n\n# 复杂度\n时间复杂度：O(N)， N是字符串长度\n\n空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088196696","body":"# 思路\n使用两个栈，来实现队列的操作；入队时候，可以不管，直接入栈1。出队的时候，为了获得栈低的元素，需要把栈1中的元素出栈，并依次入栈2.  当栈2不空的时候，出队需要从栈2中弹栈。\n\n# 代码\n```\nclass MyQueue {\n    private ArrayDeque<Integer> stack1;\n    private ArrayDeque<Integer> stack2;\n    public MyQueue() {\n        stack1 = new ArrayDeque<Integer>();\n        stack2 = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        int ans = stack2.pop();\n        while (!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        return ans;\n    }\n\n    public int peek() {\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        int ans = stack2.peek();\n        while (!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        return ans;\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n# 复杂度\n时间复杂度：入队O(1)  peek和pop  O(N)\n\n空间复杂度：O（N）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kelving-611":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085375480","body":"### 思路\n\n思路1: 把A转化成数字. 再跟K求和. 最后把输出结果转化成数组. (这种方法感觉没什么意思, 就是来回调用几个函数)\n思路2: 双指针. 从A, K的\"尾巴\"开始, 从后往前移动, 然后每次把得到的和放进数组里(不要忘记carry). 返回数组颠倒过来之后的结果. 注意: 时刻要注意carry. 如果双指针最后走到头, 还需要考虑carry的情况. \n\n### 代码\n\n思路2\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        carry = 0\n        i, j = len(A) - 1, len(str(K)) - 1\n        res = []\n\n        while i >= 0 or j >= 0: \n            val_1 = A[i] if i >= 0 else 0\n            val_2 = int(str(K)[j]) if j >= 0 else 0\n            i -= 1\n            j -= 1\n            val = val_1 + val_2 + carry\n            carry = val // 10\n            val %= 10\n            res.append(val)\n\n        if carry: \n            res.append(carry)\n        return res[::-1]\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(len(A), len(str(K)))) 也就是 O(A, str(K)之间较长的长度)\n- 空间复杂度：O(max(len(A), len(str(K)))) . 由于算法不是原地算法, 所以需要重新开辟空间. \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086658104","body":"# 思路\n分别记录两个数组: \n1. 当前位置到右边最近的c的距离\n2. 当前位置到左边最近的c的距离\n\n# 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        occurrence = deque()\n        for idx, i in enumerate(s): \n            if i == c: \n                occurrence.append(idx)\n\n        # print(occurrence)\n        occ_1, occ_2 = copy.deepcopy(occurrence), copy.deepcopy(occurrence)\n\n        dis_right = []  # 当前距离右边最近的c的距离\n        right_pos = occurrence[0]\n        for idx, char in enumerate(s): \n            if char == c: \n                right_pos = occ_1.popleft()\n                dis_right.append(0)\n            else: \n                dis_right.append(abs(idx - occurrence[0]))\n        # print(dis_right)\n\n        dis_left = []  # 当前距离左边最近的c的距离\n        left_pos = inf\n        for idx, char in enumerate(s): \n            if char == c: \n                left_pos = occ_2.popleft()\n                dis_left.append(0)\n            else: \n                dis_left.append(abs(idx - left_pos))\n\n        res = []\n        for i in range(len(dis_left)): \n            res.append(min(dis_left[i], dis_right[i]))\n        # print(dis_left)\n        return res\n\n```\n# 复杂度\n时间. 空间复杂度: 都是O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086705756","body":"## 思路\r\n模拟栈操作. \r\n\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.cur_size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size == self.maxSize: \r\n            return\r\n        self.stack.append(x)\r\n        self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack: return -1\r\n        res = self.stack.pop()\r\n        self.cur_size -= 1\r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(self.cur_size, k)): \r\n            self.stack[i] += val\r\n```\r\n## 复杂度分析\r\n时间复杂度: \r\n`push`: O(1)\r\n`pop`: O(1)\r\n`increment`: O(N)\r\n空间复杂度: \r\n`push`: O(1)\r\n`pop`: O(1)\r\n`increment`: O(1). 由于是原地算法所以不占空间. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086957495","body":"## 思路\n用栈来解决. 思路: 从头到尾遍历s, 只要当前不是`]`, 就往stack里面放. 当遇到`]`时, 开始pop, 在遇见stack里面的数字之前, 一直往外弹并且记录下来. 碰到数字后, 把得到的结果重新stack里. 最后把stack里面的值转化成字符串. \n\n重点1 🔴 : 怎么想到用栈来解决这个问题? \nTODO: 没有一个方法论. 只是手动模拟的时候感觉用stack容易些. \n\n\n重点2 🔴 : 一说到用栈, 我们接下来就要想 **什么时候push?** **什么时候pop?**\n1.  **什么时候push?** : 只要当前不是`]`, 就往stack里面放 (细节: 需要处理类似`100[leetcode]`里面的`100`)\n2.  **什么时候pop?**: 当前遇到`]`. \n\n**这道题的思路不重要, 只要动手试一试. 人脑是怎么得出答案的, 我们只需要把人脑的步骤翻译成代码就好了**\n\n## 代码\n```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = []\n        stack = []\n        for i in range(len(s)): \n            if s[i] == \"]\":\n                tmp = []\n                while not stack[-1].isnumeric(): \n                    cur = stack.pop()\n                    if cur == \"[\": \n                        continue\n                    else: \n                        tmp.append(cur)\n                times = stack.pop()\n                tmp_str = \"\".join(tmp[::-1])\n                for _ in range(int(times)): \n                    stack.append(tmp_str)\n            else: \n                # 专门处理 100[leetcode] 里面的\"100\"\n                if stack and s[i].isnumeric() and stack[-1].isnumeric(): \n                    tmp = stack.pop()\n                    stack.append(tmp + s[i])\n                else: \n                    stack.append(s[i])\n        return \"\".join(stack)\n```\n## 复杂度分析\n### 时间复杂度\n算法需要从头到尾遍历一遍. O(字符串长度)\n### 空间复杂度\n因为用了栈, 所以最差情况我们需要存全量的字符到stack中. 比如 `s = \"abcd\"`. O(字符串长度)\n\n## 反思\n1. 这个用例是真的绝了\"`100[leetcode]`\"! 🫡  学到了! 在push时不能无脑往里push. \n2. 栈操作push pop的逻辑中, 细节是魔鬼. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087814440","body":"## 思路\r\n> Tip: stack其实是一个**操作受限**的数据结构. 既只能对最后一个数(i.e.: 栈顶)进行pop, append操作. 如果我们解题用到list时, 操作stack[0]就有点不讲武德了. \r\n\r\n\r\n使用两个栈. 一个用来push `stack_push`, 一个用来pop `stack_pop`. \r\n\r\n\r\n1️⃣ push策略: 直接往stack_push里面append. 理论上, 你想怎么push都可以, 只要后面的pop, peek方法都正确就行. \r\n\r\n\r\n2️⃣ pop 策略: stack_pop里面的最后一个数 (也就是栈顶)一定是queue的第一个数. 所以我们需要确保`stack_pop`里面时刻\"有数可弹\". \r\n1. 如果`stack_pop`不为空, 我们就把最后一个(i.e.: 栈顶元素)取出来. \r\n2. 如果stack_pop为空, 我们就需要把stack_push里面的数一边弹出, 一边弹入. 操作结束后, 把`stack_pop`里面最后一个(i.e.: 栈顶元素)pop出来并且返回. \r\n\r\n\r\n3️⃣ peek策略: 核心理念跟pop相同. 我们需要确保`stack_pop`里面时刻\"有数可弹\". \r\n思路与`pop()`相同\r\n\r\n## 代码\r\n```python3\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stack_push = []\r\n        self.stack_pop = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_push.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if not self.stack_pop: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n        res = self.stack_pop.pop()\r\n        return res\r\n        \r\n\r\n    def peek(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if self.stack_pop: \r\n            return self.stack_pop[-1]\r\n\r\n        else: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n            return self.stack_pop[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack_push and not self.stack_pop\r\n```\r\n## 复杂度分析\r\n### 时间复杂度\r\npush - O(1)\r\npop  - max(O(1) or O(当前stack_push的大小)) = O(N)\r\npeek - 跟pop一样 O(N)\r\n### 空间复杂度\r\n用到了两个stack. O(最终队列的大小)\r\n\r\n## 反思\r\n🫡 不过不知道这道题的实际意义是什么? 没有办法把题目跟生产环境联系在一起. \r\n\r\n题解中有提到: \r\n>其实使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作。一个栈是用来读的，另一个是用来写的。当且仅当读栈满时或者写栈为空时，读写操作才会发生冲突。\r\n\r\n> 当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个栈的实现中，只要写入栈不为空，那么push操作的锁就不会影响到pop。\r\n\r\nTODO: 可能需要改一下自己的code. 我的代码只有在pop, peek时, 才会进行\"倒腾\"","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lqyt2012":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085378454","body":"## 思路\n将数组转换成整数，然后与整数K做加法，之后再转换成数组返回\n## 代码\n```python\nclass Solution:\n    def add_array_with_num(self, num: List[int], k: int) -> List[int]:\n        sum = 0\n        digit = 1\n        for i in range(len(num)-1, -1, -1):\n            sum += num[i]*digit\n            digit *= 10\n        sum += k\n        result = [0]*len(str(sum))\n        for i in range(len(result)-1, -1, -1):\n            result[i] = sum % 10\n            sum //= 10\n        return result\n```\n## 复杂度分析\n空间复杂度：O(N)  \n时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086634529","body":"## 思路\n两次遍历字符串，取其中较短的距离作为返回值\n## 代码\n```python\nclass Solution:\n    def find_smallest_dist(self, s:str, c:str) -> List[int]:\n         nearest_dist = len(s)\n         result = [0]*len(s)\n         for i in range(len(s)):\n             nearest_dist = 0 if s[i] == c else nearest_dist + 1\n             result[i] = nearest_dist\n         nearest_dist = len(s)\n         for i in range(len(s)-1, -1, -1):\n             nearest_dist = 0 if s[i] == c else nearest_dist + 1\n             result[i] = min(nearest_dist, result[i])\n         return result\n```\n## 复杂分析\n空间复杂度：O(N)  \n时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086864051","body":"## 思路\n用数组来模拟栈，因为increment函数涉及到随机读取\n## 代码\n```python\nclass CustomStack:\n    def __init__(self, Max_Size=None):\n        self.stack = []\n        self.size = Max_Size\n        self.length = len(self.stack)\n    \n    def push(self, val:int) -> None:\n        if self.length < Max_Size:\n            self.stack.append(val)\n            self.length += 1\n        return None\n    \n    def pop(self) -> int:\n        if self.length > 0:\n            self.length -= 1\n            return self.stack.pop(-1)\n        return -1\n    \n    def increment(self, k:int, val:int) -> None:\n        if self.length > 0:\n            for i in range(min(k,self.length)):\n                self.stack[i] += val\n        return None\n```\n## 负责度分析\n空间复杂度：O(N)  \n时间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087601018","body":"## 思路\n左边中括号之前出现的数字字符是倍数，因为括号可能嵌套，所以需要倍数栈，用于存储倍数。右边括号出现时，从倍数栈去除栈顶元素，用于重复字符串。\n## 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        number_stack = []\n        encoded_string_stack = []\n        number_string = ''\n        result = ''\n        encoded_string = ''\n        for char in s:\n            if char in '0123456789':\n                number_string += char\n            elif 'a' <= char and char <= 'z':\n                encoded_string += char\n            elif char == '[':\n                number_stack.append(int(number_string))\n                number_string = ''\n                encoded_string_stack.append(encoded_string)\n                encoded_string = ''\n            else:\n                number = number_stack.pop()\n                temp_string = encoded_string_stack.pop()\n                encoded_string = temp_string + number * encoded_string\n        result += encoded_string\n        return result\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088693712","body":"## 思路\n用两个栈模拟队列，stack模拟队尾，进行push，在队尾添加元素。help_stack模拟队头，用于peek操作和pop操作，查看队头和队头出队。\n## 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.help_stack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if self.help_stack:\n            return self.help_stack.pop()\n        else:\n            while self.stack:\n                self.help_stack.append(self.stack.pop())\n            return self.help_stack.pop()\n\n\n    def peek(self) -> int:\n        if self.help_stack:\n            return self.help_stack[-1]\n        else:\n            while self.stack:\n                self.help_stack.append(self.stack.pop())\n            return self.help_stack[-1]\n\n    def empty(self) -> bool:\n        if len(self.stack) == 0 and len(self.help_stack) == 0:\n            return True\n        else:\n            return False\n```\n## 复杂度分析\n空间复杂度：O(N)  \n时间复杂度：push：O(1),pop：O(N),peek：O(N),empty：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yz3516":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085380660","body":"### **思路**\r\n把k当做carry，从后往前遍历，每次加k的个位数值进res的头部并更新k；\r\n\r\n### **代码**\r\n```java\r\n    public List<Integer> addToArrayForm(int[] nums, int k) {\r\n        List res = new LinkedList<>();\r\n        for (int i = nums.length - 1; i >= 0 || k > 0; --i) { //这里可以用三元运算符简化；\r\n\t        if(i >= 0){\r\n\t\t\tres.add(0, (nums[i] + k) % 10);\r\n\t\t\tk = (nums[i] + k) / 10;\r\n\t\t} else {\r\n\t\t\tres.add(0, k % 10);\r\n\t\t\tk /= 10;\r\n\t\t}   \r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n### **复杂度**\r\nTime: O(n), n is the length of nums;\r\nSpace: O(n), the res List uses extra space ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086526568","body":"### 思路\n先从左边往右扫，记录每个字符离C的距离；\n然后从右边往左扫，如果比第一次扫的距离小则替换掉，这样最后剩下的就是每个字符距离C最短的距离；\n\n### 代码\n```java\n        int[] result = new int[S.length()];\n        int currDist = S.length(); \n        for (int i = 0; i < S.length(); ++i) {\n            currDist = S.charAt(i) == C ? 0 : currDist + 1;\n            result[i] = currDist;\n        }\n\n        currDist = S.length();\n        for (int i = S.length() - 1; i >= 0; --i) {\n            currDist = S.charAt(i) == C ? 0 : currDist + 1;\n            result[i] = Math.min(result[i], currDist);\n        }\n        return result;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)， N 为数组长度;\n- 空间复杂度：O(N)，创建了新的array result;","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086734511","body":"### 思路\n一般思路下increment的时间复杂度很高，每次inc的时候都要遍历inc对应的值；\\\n优化思路：只有在pop出来的时候才increment历史inc的值，这样inc是O(1)时间；这样需要一个inc array来储存历史上inc的值；\\\ninc[i]对应是的栈顶需要在pop时候inc的值，每次pop的时候需要更新inc[i - 1] = inc[i];\n\n### 代码\n```java\nclass CustomStack {\n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n    \n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (stack.size() < n)\n            stack.push(x);\n    }\n\n    public int pop() {\n        int i = stack.size() - 1;\n        if (i < 0)\n            return -1;\n        if (i > 0)\n            inc[i - 1] += inc[i];\n        int res = stack.pop() + inc[i];\n        inc[i] = 0;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if (i >= 0)\n            inc[i] += val;\n    }\n}\n```\n**复杂度分析**\\\n初始化时空均为O(N)，push, pop, increment 时空均为 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086947266","body":"### 思路 & 复杂度\r\n1. 两个stack的做法，一个intStack存遇到的数字，一个strStack存需要decode的string，这样空间复杂度是O(m+n)，m为字母数n为数字数； \r\n2. Recursion的做法，base case是完成遍历整个string s 或者 遇到 ] 括号，空间复杂度是O(n)， n是string s 的长度；两个做法时间复杂度都是O(maxK*n), k是nested[]的数量；\r\n\r\n### 代码\r\ntwo stacks:\r\n```java\r\n    public String decodeString(String s) {\r\n        Stack<Integer> intStack = new Stack<>();\r\n        Stack<StringBuilder> strStack = new Stack<>();\r\n        StringBuilder cur = new StringBuilder();\r\n        int k = 0;\r\n        for (char ch : s.toCharArray()) {\r\n            if (Character.isDigit(ch)) {\r\n                k = k * 10 + ch - '0';\r\n            } else if ( ch == '[') {\r\n                intStack.push(k);\r\n                strStack.push(cur);\r\n                cur = new StringBuilder();\r\n                k = 0;\r\n            } else if (ch == ']') {\r\n                StringBuilder tmp = cur;\r\n                cur = strStack.pop();\r\n                for (k = intStack.pop(); k > 0; --k) cur.append(tmp);\r\n            } else cur.append(ch);\r\n        }\r\n        return cur.toString();\r\n    }\r\n```\r\nrecursion:\r\n```java\r\n    int index = 0;\r\n    public String decodeString(String s) {\r\n        StringBuilder result = new StringBuilder();\r\n        while(index < s.length() && s.charAt(index) != ']'){\r\n            if(!Character.isDigit(s.charAt(index)))\r\n                result.append(s.charAt(index++));\r\n            else {\r\n                int k = 0;\r\n                //build k while next character is a digit\r\n                while(index < s.length() && Character.isDigit(s.charAt(index)))\r\n                    k = k * 10 + s.charAt(index++) - '0';\r\n                \r\n                //ignore the opening bracket '['\r\n                index++;\r\n                String decodedString = decodeString(s);\r\n                //ignore the closing bracket ']'\r\n                index++;\r\n                //build k[decodedString] and append to the result\r\n                while(k-- > 0)\r\n                    result.append(decodedString);\r\n            }\r\n        }\r\n        return new String(result);\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087982640","body":"### 思路\n用两个stack，一个inStack无脑存push进queue的element，另一个outStack负责pop和peek method；\n\n###代码\n```java\nclass MyQueue {\n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n        \n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if(outStack.isEmpty()){\n            while(!inStack.isEmpty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n```\n###复杂度\n空间复杂度都是O(1)；\\\n时间：\\\npush: O(1), 只需要push到inStack里\\\npop: O(1), worst case O(n)，需要call一次peek然后return outStack栈顶的元素\\\npeek: O(1), worst case O(n)\\\nemptu：O(1), 查看两个stack是否都为空都是O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085383015","body":"## 思路 \n把num转换成整数后加上k，再转换成数组\n\n## 代码\n    class Solution(object):\n        def addToArrayForm(self, num, k):\n            \"\"\"\n            :type num: List[int]\n            :type k: int\n            :rtype: List[int]\n            \"\"\"\n            temp = 0\n            for item in num:\n                temp = temp * 10 + item\n            res = []\n            sumNum = temp + k\n            while sumNum != 0:\n                last = sumNum % 10\n                sumNum //= 10\n                res.insert(0, last)\n            return res\n## 复杂度\ntime O(max(num和k的长度))\nspace O(max(num和k的长度))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085387672","body":"### 思路\n将k加到最后一位，取余放在当前位，接着/10继续向前加\n### 代码\n``` c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n       //将K加到最后一位，依次向前\n       vector<int> res;\n       for(int i=num.size()-1;i>=0 || k>0;i--,k/=10){\n           //if(i>=0){\n           //    int sum=num[i]+k;\n           //    res.push_back(sum%10);\n           //}\n           //else{\n           //    res.push_back(k%10);\n          // }\n          //上面这一段还是没想清楚\n          if(i>=0){\n              k+=num[i];\n          }\n          res.push_back(k%10);\n       }\n       reverse(res.begin(),res.end());\n       return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O（n）遍历一遍数组\n* 空间复杂度：O（n），建立了数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086537714","body":"### 思路\n两次遍历，从左到右更新一遍，从右到左更新一遍\n### 代码\n``` C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int>res(s.size());\n        //方法二，只遍历两次，先从左到右，再从右到左\n        int prev=INT_MAX/2;//防止越界，所以除以2\n        for(int i=0;i<s.size();i++){\n            if(s[i]==c){\n                prev=i;\n            }\n            res[i]=i-prev;\n        }\n        prev=INT_MAX/2;\n        for(int i=s.size()-1;i>=0;i--){\n            if(s[i]==c){\n                prev=i;\n            }\n            res[i]=min(abs(res[i]),prev-i);\n        }\n    return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O（n）\n* 空间复杂度：O（n）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086767470","body":"### 思路\n利用数组，使用了三个参数，分别表示最大容量，当前栈顶位置和指向栈的指针\n### 代码\n``` C++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        size=maxSize;\n        arr=new int[size];\n        top=-1;\n    }\n    ~CustomStack(){//析构函数\n        delete [] arr;\n    }\n    void push(int x) {\n        if(top==size-1){//栈满\n            return ;\n        }\n        arr[++top]=x;\n    }\n    int pop() {\n        if(top==-1){//栈空\n            return -1;\n        }\n        return arr[top--];//弹出栈顶元素，并--\n    }\n    void increment(int k, int val) {\n        if(top+1<k){//所有元素都增加val\n            for(int i=0;i<=top;i++){\n                arr[i]+=val;\n            }\n        }\n        else{\n            for(int i=0;i<k;i++){\n                arr[i]+=val;\n            }\n        }\n    }\nprivate:\n    int size;//栈的最大容量\n    int top;//当前元素数量,栈顶\n    int* arr;//指向栈的指针\n};\n```\n### 复杂度分析\n* 时间复杂度：push,pop O(1)\n* 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087283863","body":"### 思路\n利用数组vector<string>构造栈，利用栈先进先出的结构来处理[],学习的leetcode题解\n### 代码\n``` C++\nclass Solution {\npublic:\n    string GetDigit(string& s,size_t& ptr){\n        string ret=\"\";\n        while(isdigit(s[ptr])){\n            ret.push_back(s[ptr++]);//此处要对Ptr做出改动，因此传入&\n        }\n        return ret;//将字符数字转化为字符串数字\n    }\n    string GetString(vector<string>& sub){\n        string tmp=\"\";\n        for(string& s:sub){\n            tmp+=s;\n        }\n        return tmp;\n    }\n    string decodeString(string s) {\n        //啊，好难啊，解法一，利用栈先进先出的特点来处理【】\n        //首先建立一个栈（使用数组）vector<string>\n        vector<string> stk;\n        size_t ptr=0;//size_t=unsigned_int\n        while(ptr<s.size()){//遍历字符串\n            char ch=s[ptr];\n            //1、处理数字\n            if(isdigit(ch)){\n                //取出的是字符，要压入的是string\n                stk.push_back(GetDigit(s,ptr));\n            }\n            //2、处理字母和\"[\",继续将字符转为string,压入栈中\n            else if(isalpha(ch) || ch=='['){\n                stk.push_back(string(1,s[ptr++]));\n            }\n            //3、处理‘]’开始弹栈\n            else{\n                ++ptr;\n                //建立处理子字符串的vector<string>\n                vector<string> sub;\n                while(stk.back()!=\"[\"){\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                //去掉\"[\"\n                stk.pop_back();\n                //逆转sub顺序\n                reverse(sub.begin(),sub.end());\n                //得到字符串\n                string tmp_0=GetString(sub);\n                //取出栈中数量,stoi函数将字符串转化为十进制\n                int repTime=stoi(stk.back());\n                stk.pop_back();//弹出数字\n                //新字符串\n                string tmp_1;\n                //构造字符串\n                while(repTime--){\n                    tmp_1+=tmp_0;\n                }\n                //将构造好的字符串压入栈中\n                stk.push_back(tmp_1);\n            }\n        }\n    return GetString(stk);\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O(n)，遍历字符串+一些额外操作\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088273931","body":"### 思路\n两个栈，一个进，一个出\n### 代码\n```C++\nclass MyQueue {\nprivate:\n    stack<int> instack;\n    stack<int> outstack;\n    void inout(){\n        //此处不可以用pop，pop是删除栈顶元素，无返回值，使用top返回\n        while(!instack.empty()){//empty空返回true,不空返回false\n            outstack.push(instack.top());\n            instack.pop();//删除\n        }\n    }\npublic:\n    //使用两个栈，一个instack,一个outstack\n    MyQueue() {\n        //stack栈后进先出，队列先进先出\n    }\n    //析构可以省略，因为数据都是容器，只有析构函数；\n    void push(int x) {\n        instack.push(x); \n    }\n    \n    int pop() {\n        if(outstack.empty()){\n            inout();\n        }\n        int temp=outstack.top();//读取栈顶元素\n        outstack.pop();//删除栈顶\n        return temp;//返回元素\n    }\n    \n    int peek() {\n        //返回队列开头元素\n        if(outstack.empty()){\n            inout();\n        }\n        return (outstack.top());//读取栈顶元素\n    }\n    \n    bool empty() {\n        return (instack.empty() && outstack.empty());\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：push-o(1),pop-o(n)\n* 空间复杂度：o(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kite-fly6618":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085387840","body":"### 思路： \n模拟加法，从后往前逐位相加\n\n### 代码：\n```js\nvar addToArrayForm = function(num, k) {\n    let res = []\n    let len = num.length\n    for (let i = len-1;i>=0;i--) {\n        let sum = num[i] + k%10\n        k = Math.floor(k/10)\n        if (sum >=10) {\n            k++\n            sum = sum-10\n        }\n        res.unshift(sum)\n    }\n    // k > 0 往数组上继续添加高位\n    while(k>0) {\n        res.unshift(k%10)\n        k = Math.floor(k/10)\n    }\n    return res\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086647422","body":"### 思路： \n两头遍历，取较小值\n\n### 代码：\n```js\nvar shortestToChar = function(s, c) {\n    let len = s.length\n    let left = []\n    let right = []\n    for (let i = 0;i <len;i++) {\n        if (s.indexOf(c,i)==-1) {\n            left.push(Infinity)\n        } else {\n            left.push(s.indexOf(c,i)-i)\n        }  \n    }\n    for (let i = len-1;i >= 0;i--) {\n        if (s.lastIndexOf(c,i)==-1) {\n            right.unshift(Infinity)\n        } else {\n            right.unshift(i-s.lastIndexOf(c,i))\n        }\n        \n    }\n    for (let i = 0;i < len;i++) {\n        left[i] = Math.min(left[i],right[i])\n    }\n    return left\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086772995","body":"### 思路： \n数组模拟栈\n\n### 代码：\n```js\nvar CustomStack = function(maxSize) {\n    this.size = maxSize\n    this.data = []\n};\n\nCustomStack.prototype.push = function(x) {\n    if (this.data.length < this.size) {\n        this.data.push(x)\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if(this.data.length!=0) {\n        return this.data.pop()\n    }else {\n        return -1\n    }\n\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    let len = Math.min(k,this.data.length)\n    for (let i = 0;i < len;i ++) {\n        this.data[i] = this.data[i] + val\n    }\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087215010","body":"### 思路： \n两个栈分别保存字符和倍数\n\n### 代码：\n```js\nvar decodeString = function(s) {\n    let numStack = []\n    let strStack = []\n    let res = '' // 当前字符串\n    let num = 0  // 倍数\n    for (let c of s ) {\n        if (!isNaN(c)) {\n            num = num*10 + (c-'0')\n         }\n        else if (c == '[') {\n            numStack.push(num)\n            strStack.push(res)\n            num = 0\n            res = ''\n        }\n        else if (c == ']') {\n            res = strStack.pop()+res.repeat(numStack.pop())\n        } else {\n            res +=c\n        }\n    }\n    return res\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088383482","body":"### 思路： \n两个栈实现队列，辅助栈翻转主栈中的元素，获取队列首部的元素，实现pop\n\n### 代码：\n```js\nvar MyQueue = function() {\n    this.stack1 = []\n    this.stack2 = []\n};\n\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x)\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.stack2.length) {\n        while(this.stack1.length) {\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2.pop()\n};\n\nMyQueue.prototype.peek = function() {\n    return this.stack2[this.stack2.length-1] || this.stack1[0]\n};\n\nMyQueue.prototype.empty = function() {\n    return this.stack2.length == 0 && this.stack1.length == 0\n};\n\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085396374","body":"### 思路\r\n\r\n从最后一位开始模拟加法进位计算， 注意不可以直接转化成数字相加会溢出 - Integer\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int len = num.length - 1;\r\n        //先将最后一位加入list，此时list为倒序\r\n        int sum = num[len] + k;\r\n        result.add(sum % 10);\r\n        int carry = sum / 10;\r\n        \r\n        //从倒数第二位开始循环\r\n        for(int i = len - 1; i >= 0; i --) {\r\n            sum = num[i] + carry;\r\n            result.add(sum % 10);\r\n            carry = sum / 10;\r\n        }\r\n        \r\n        //如果carry还有进位\r\n        while(carry > 0) {\r\n            result.add(carry % 10);\r\n            carry /= 10;\r\n        }\r\n        \r\n        //反转数组\r\n        Collections.reverse(result);\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N, log k))，其中 N 为数组num长度。\r\n- 空间复杂度：O(max(N, log k)), 储存结果的新数组\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086552671","body":"### 思路\n\n前序遍历数组找出与左侧的字母的最短距离，后序遍历数组找出与右侧字母的最短距离，两者取其最小为最终结果。\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] result = new int[len];\n        int max = len - 1;\n        \n        int cur = max;\n        for(int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                result[i] = 0;\n                cur = 0;\n            } else {\n                result[i] = Math.min(max, ++cur);\n            }\n        }\n        \n        cur = max;\n        for(int i = len - 1; i >= 0 ; i--) {\n            if (s.charAt(i) == c) {\n                cur = 0;\n            } else {\n                result[i] = Math.min(result[i], ++cur);\n            }\n        }\n        \n        return result;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为String的长度。\n- 空间复杂度：O(N), 其中 N 为String的长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086709764","body":"### 思路\n\n用数组模拟栈操作\n\n### 代码\n\n\n```java\nclass CustomStack {\n    private int[] arr;\n    private int top;\n    \n\n    public CustomStack(int maxSize) {\n        arr = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top < arr.length - 1) {\n            arr[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        return top == -1 ? -1 : arr[top--];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i <= top ; i++) {\n            arr[i] += val; \n        }\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：\npush: O(1)\npop: O(1)\nincrement: O(K)\n- 空间复杂度：\npush: O(1)\npop: O(1)\nincrement: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087236725","body":"### 思路\n\n维护一个栈来进行括号匹配，当遇到右括号开始pop计算后形成新字符串，然后重新入栈。\n\n### 代码\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stack = new Stack<String>();\n        int k = 0;\n        for(char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                k = k * 10 + Character.getNumericValue(c);\n            } else if (c == '[') {\n                stack.push(String.valueOf(k));\n                stack.push(\"[\");\n                k = 0;\n            } else if (c == ']') {\n                StringBuilder sb = new StringBuilder();\n                while(stack.peek() != \"[\") {\n                    sb.insert(0, stack.pop());\n                }\n                String str = sb.toString(); // Get string inside []\n                stack.pop(); // pop '['\n                int times = Integer.parseInt(stack.pop()); // Get times\n                \n                sb = new StringBuilder();\n                for(int i = 0; i < times; i++) {\n                    sb.append(str);\n                }\n                stack.push(sb.toString());// Push string: k[encoded_string] to stack\n            } else {\n                stack.push(String.valueOf(c));\n            }\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        while(!stack.isEmpty()) {\n            sb.insert(0, stack.pop());\n        }\n        \n        return sb.toString();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为String长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088333805","body":"### 思路\n\n用两个栈来实现队列。\n\n### 代码\n\n\n```java\nclass MyQueue {\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<Integer>();\n        stack2 = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        while(!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        int pop = stack2.pop();\n        while(!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        return pop;\n    }\n    \n    public int peek() {\n        while(!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        int peek = stack2.peek();\n        while(!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        return peek;\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：\n\t◦\tpush：O(1)\n\t◦\tpop：O(N)\n\t◦\tpeek：O(N)\n\t◦\tempty：O(1)\n\n- 空间复杂度：\n\t◦\tpush：O(1)\n\t◦\tpop：O(N)\n\t◦\tpeek：O(N)\n\t◦\tempty：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"venchyluo":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085407589","body":"从尾到头 一位一位计算。 可以另开list 倒叙存 ｜｜ 直接修改原数组，多位的从头插入。\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # brute force, convert to int then to list\r\n        carry, i = 0, len(num) -1\r\n        while carry or i >= 0 or k:\r\n            temp = (num[i] if i >= 0 else 0) + (k % 10 if k else 0) +  carry            \r\n            carry = temp // 10\r\n            \r\n            if i >= 0:\r\n                num[i] = temp % 10\r\n            else:\r\n                num.insert(0,temp % 10)\r\n            \r\n            k //= 10\r\n            i -= 1\r\n\r\n        return num\r\n```\r\ntime complexity: O(N)   \r\nspace complexity: O(N) （不考虑返回值，额外使用O(1))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ballerjay":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085407797","body":"### 解题思路\n\n默认人工计算的过程，k与数组最后一位相加，然后k去掉个位的数字；然后k与倒数第二位相加，也就是十位，然后去掉十位的数组；依次循环。。。\n\n还有一些特殊的情况就是数组循环结束之后，k还存在值，所以需要继续往res中添加\n\n\n\n```JavaScript\nfunction solution(num,k) {\n  // 默认人工计算的过程，k与数组最后一位相加，然后k去掉个位的数字；然后k与倒数第二位相加，也就是十位，然后去掉十位的数组；依次循环。。。\n  // 还有一些特殊的情况就是数组循环结束之后，k还存在值，所以需要继续往res中添加\n  const res = []\n  const len = num.length\n  for(let i = len - 1;i >= 0 || k > 0;i --, k = Math.floor(k / 10)) {\n    if(i >= 0) {\n      k += num[i]\n    }\n    res.unshift(k % 10)\n  }\n  return res\n}\n```\n\n### 时间复杂度\n\nO(max(n,k)),n为数组的长度,k为数字的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086658551","body":"``` js\nvar shortestToChar = function(s, c) {\n    // 中心扩散法，从当前元素为中心，寻找左右两边的c值，然后找出最短距离\n    const res = [] \n    for(let i = 0;i < s.length;i ++) {\n    let l = r = i\n    while(l >= 0) {\n        if(s[l] == c) break\n        l--\n    }\n    while(r < s.length) {\n        if(s[r] == c) break\n        r++\n    }\n    if(l < 0) l = -10000\n    if(r === s.length) r = 10000\n    res.push(Math.min(i - l, r - i))\n    }\n    return res\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088609608","body":"### 思路\n在js中利用数组的方法实现队列\n### 代码\nfunction MyQueue() {\n  this.items = [];\n  this.push = function (x) {\n    this.items.push(x);\n  };\n  this.pop = function () {\n    this.items.shift();\n  };\n  this.peek = function () {\n    return this.items[0];\n  };\n  this.empty = function () {\n    return this.items.length == 0 ? true : false;\n  };\n}\n\nlet queue = new MyQueue();\nqueue.push(1);\nqueue.push(2);\nqueue.peek(); // 返回 1\nqueue.pop(); // 返回 1\nqueue.empty(); // 返回 false","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"magua-hub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085412418","body":"思路\n模拟加法，本质上是以到高精度加法。先把数组翻转，从最后一位开始加，最后在翻转过来\n\n代码实现\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n\n        for(auto& x : num) {\n            k += x;\n            x = k % 10;\n            k /= 10;\n        }\n\n        while(k) num.push_back(k % 10), k /= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n```\n复杂度分析:\n\n时间复杂度O(n)\n\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086550335","body":"思路\n分析一下可知，只有两种情况，即c在这个数的左边或者右边，所以我们遍历两次，一次从前向后，一次从后向前，最后把两次遍历的结果取min\n\n代码\n```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, INT_MAX);\n        for(int i = 0, j = -1; i < n;  i ++){\n            if(s[i] == c) j = i;\n            if(j != -1) res[i] = i - j;\n        }\n        for(int i = n , j = -1; i >= 0; i --) {\n            if(s[i] == c) j = i;\n            if(j != -1) res[i] = min(res[i], j - i);\n        }\n        return res;\n\n    }\n};\n```\n复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)结果数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086762515","body":"思路\n使用数组实现栈\n\n代码\n```C++\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int mx;\n    CustomStack(int maxSize) {\n       // stk.resize(maxSize);\n        mx = maxSize;\n    }\n    \n    void push(int x) {\n        if(stk.size() < mx)\n            stk.push_back(x);\n    }\n    \n    int pop() {\n        if(!stk.empty()){\n            int val = stk.back();\n            stk.pop_back();\n            return val;\n        }else {\n            return -1;\n        }\n        \n        \n    }\n    \n    void increment(int k, int val) {\n        if(stk.size() < k) {\n            for(int i = 0; i < stk.size(); i ++)\n                stk[i] += val;\n        }else if(stk.size() >= k){\n            for(int i = 0; i < k; i ++)\n                stk[i] += val;\n        }\n    }\n};\n\n\n复杂度分析\n时间复杂度： push:O(1)、pop：O(1)\n空间复杂度 O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087041845","body":"思路\n使用递归，遇见数字就递归进去，遇见字母就加到res后面\n\n代码\n```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int u = 0;\n        return dfs(s, u);\n    }\n\n    string dfs(string& s, int& u) {\n        string res;\n        while(u < s.size() && s[u] != ']') {\n            if(s[u] >= 'a' && s[u] <= 'z' || s[u] >= 'A' && s[u] <= 'Z') res += s[u ++];//\n            else if(s[u] >= '0' && s[u] <= '9') {\n                int k = u;\n                while(s[k] >= '0' && s[k] <= '9') k ++;\n                int x = stoi(s.substr(u, k - u));//stoi string转换成int类型\n                u = k + 1;//去掉左括号\n                string y = dfs(s, u);//进一步递归，确认括号里的字符串\n                u ++;\n                while(x --) res += y;\n            }\n        }\n        return res;\n    }\n};\n\n复杂度\n空间：O(2^n) ?指数级别，具体表达式不清楚\n时间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088198934","body":"思路\n用两个stack模拟\n\n代码\n```C++\nclass MyQueue {\npublic:\n    stack<int> stk, num;\n\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stk.push(x);\n    }\n    \n    int pop() {\n        if(!stk.empty() && num.empty()) {\n            while(!stk.empty()) {\n                num.push(stk.top());\n                stk.pop();\n            }\n        }\n        int res = num.top();\n            num.pop();\n            return res;\n    }\n    \n    int peek() {\n        if(!stk.empty() && num.empty()) {\n            while(!stk.empty()) {\n                num.push(stk.top());\n                stk.pop();\n            } \n        }\n        int res = num.top();\n\n            return res;\n    }\n    \n    bool empty() {\n        if(stk.empty() && num.empty()) \n            return true;\n        else return false;\n    }\n};\n复杂度\n空间复杂度都是O(n)；\n时间：\npush: O(1),\npop: O(n) \npeek: O(n)\nemptu：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085420206","body":"```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n    int resLen = fmax(numSize + 1, 5); // k 的取值范围 [1, 10^4]，加上进位最多是 5 位数\n    int* res = malloc(sizeof(int) * resLen);\n    int r, w;\n\n    w = resLen - 1;\n    r = numSize - 1;\n\n    while (k || r >= 0) {\n        if (r >= 0) k += num[r--];\n        res[w--] = k % 10;\n        k /= 10;\n    }\n\n    int realStart = w + 1;\n    *returnSize = resLen - realStart;\n    return res + realStart;\n}\n```\n- ****Time:**** $O(max(N,logk))$\n- ***Space:** $O(1)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086484326","body":"```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* shortestToChar(char * s, char c, int* returnSize) {\n    int len = strlen(s);\n    int* res = malloc(sizeof(int) * len);\n\n    res[0] = s[0] == c ? 0 : len;\n\n    for (int i = 1; i < len; ++i)\n        res[i] = s[i] == c ? 0 : res[i - 1] + 1;\n\n    for (int i = len - 2; i >= 0; --i)\n        res[i] = fmin(res[i], res[i + 1] + 1);\n\n    *returnSize = len;\n    return res;\n}\n```\n\n- ****Time:**** $O(N)$，N 是 S 的长度。\n- ****Space:**** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086883763","body":"```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) : maxSize_(maxSize), top_(-1) {\n        stack_.resize(maxSize);\n        inc_.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (top_ < maxSize_ - 1) stack_[++top_] = x;\n    }\n    \n    int pop() {\n        if (top_ == -1) return -1;\n        if (top_ > 0) inc_[top_ - 1] += inc_[top_];\n        int val = stack_[top_] + inc_[top_];\n        inc_[top_--] = 0;\n        return val;\n    }\n    \n    void increment(int k, int val) {\n        int idx = min(k - 1, top_);\n        if (idx >= 0) inc_[idx] += val;\n    }\nprivate:\n    vector<int> stack_;\n    vector<int> inc_;\n    int maxSize_;\n    int top_;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087473885","body":"```cpp\nclass Solution {\npublic:\n    bool isNumber(const string& str) {\n        for (char const &c : str) {\n            if (std::isdigit(c) == 0) return false;\n        }\n        return true;\n    }\n\n    string repeat(const string& s, int t) {\n        string res;\n        while (t-- > 0) res += s;\n        return res;\n    }\n\n    string decodeString(string s) {\n        string res;\n        stack<string> stk;\n\n        for (char c : s) {\n            if (c != ']') {\n                stk.push(string(1, c));\n                continue;\n            }\n\n            string p = \"\";\n            while (!stk.empty() && stk.top() != \"[\") {\n                p = stk.top() + p; stk.pop();\n            }\n            stk.pop(); // pop out '['\n\n            string t = \"\";\n            while (!stk.empty() && isNumber(stk.top())) {\n                t = stk.top() + t; stk.pop();\n            }\n            stk.push(repeat(p, stoi(t)));\n        }\n\n        while (!stk.empty()) {\n            res = stk.top() + res; stk.pop();\n        }\n        return res;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dzwhh":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085428758","body":"### 思路\n逐位相加,当数组不为空或者k不为0，从末位数字开始，加k当前位(k%10)+进位(carry初始是0),加和后push到开辟的数组去同时只push当前位，循环结束最后判断一次是否还有进位，如果有再push一次，最后反转数组得到最终结果\n\n### 关键点\n- 处理当前位是 num % 10\n- 处理进位是 num / 10\n- 需要判断数组是空，或者k是0的情况\n\n### 代码\n- js版本\n```js\nconst addToArrayForm = (num, k) => {\n  let res = []; // 最终输出结果数组\n  let carry = 0; // 标记进位\n  let tail = num.length - 1; // 数组末位元素，代表各个位的数字\n  let sum = 0; // 各个位加和的结果\n\n  while(tail >= 0 || k != 0) {\n    let x = tail >= 0 ? num[tail] : 0;\n    let y = k != 0 ? k % 10 : 0;\n    sum = x + y + carry; //num数组当前位+k当前位+进位\n    res.push(sum % 10); //sum 可能有进位 取模 10 剔除掉进位数字\n    tail--; //数组向前挪动\n    k = Math.floor(k/10);  // k向高位数字挪动\n    carry = Math.floor(sum / 10); //记录进位数字\n  }\n  if(carry === 1)\n    res.push(carry); //最后一次加和如果有进位最后的1push到数组\n  return res.reverse(); // 从后往前添加的数组，需要反转得到最终结果\n}\n\n```\n### 复杂度分析\n时间复杂度: O(max(n,k))\n空间复杂度: O(max(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086588218","body":"### 思路\n先把字符串中等于c字符的对应下标存到数组res中，作为对比项使用，同时设置指向c字符下标数组的指针p，然后在遍历字符串每个字符，把每个字符的下标数值与res的c字符下标相减，得到距离，每次只比较c字符下标当前值和后继值，如果发现当前值的差值比后继值的差值大，那就把p指针向后挪一位，因为这时候当前值不需要在以后的判断中使用，因为肯定比后面的c字符位置要远,同时把字符串当前字符位置和c字符下标数组对应位置的差异存到dist最终结果数组中\n\n### 关键点\n- 下标差值的比较\n- 当前字符位置与c字符前后2个位置的距离比较，大的代表距离远，需要移动指针\n\n### 代码\n\n- js 版本\n\n```js\nconst shortestToChar = (s, c) => {\n  let res = []; // c字符下标数组\n  let p = 0; // 指向c字符下标数组的指针\n  let dist = []; // 最终结果\n\n  // 把字符串中等于c字符的对应下标存在res数组中\n  for(let i = 0; i < s.length; i++) {\n    if (s[i] ===  c)\n      res.push(i)\n  }\n  \n  // 遍历字符串字符，比较每个字符下标与对应c字符下标的差值\n  for(let j = 0; j < s.length; j++) {\n    // 数组元素和c下标数组前后两个值对比,如果前一个比较值比后一个比较值大，p指针向后挪一位\n    if (p < res.length && Math.abs(j - res[p]) > Math.abs(j - res[p+1])) \n      p++; \n    dist.push(Math.abs(j - res[p]));\n  }\n  return dist;\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(m+n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086839940","body":"## 1381. Design a Stack With Increment Operation「设计一个支持增量操作的栈」\n- 题目地址: https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n### 题目描述\n请你设计一个支持下述操作的栈。\n实现自定义栈类 CustomStack ：\n- CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\n- void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\n- int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n- void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n### 前置知识\n- 数组、栈\n\n### 思路\n用数组模拟栈操作，maxSize 数组容量也是栈容量，设置一个top指针，作为指向栈顶的指针，每次向栈增加一个元素就是向top位置下标添加一个元素，同时top向后挪一位,pop栈顶操作就是返回top前一位元素; inc 操作可以判断k和top谁小，就遍历范围定到谁作为边界添加val\n\n### 关键点\n- top指针的前后移动，如果初始值为0，那push是先添加元素在挪动top，pop是返回top-1位置的元素\n\n### 代码\n- js 版本\n```js\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n  this.stack = new Array(maxSize);\n  this.top = 0;\n};\n\n/** \n* @param {number} x\n* @return {void}\n*/\nCustomStack.prototype.push = function(x) {\n  if (this.top === this.stack.length)\n      return;\n  else   \n      this.stack[this.top++] = x;\n};\n\n/**\n* @return {number}\n*/\nCustomStack.prototype.pop = function() {\n  if (this.top === 0)\n    return -1\n  return this.stack[--this.top];\n  \n};\n\n/** \n* @param {number} k \n* @param {number} val\n* @return {void}\n*/\nCustomStack.prototype.increment = function(k, val) {\n  let len = Math.min(k,this.top)\n  for(let i = 0; i < len; i++){\n      this.stack[i] += val\n  }\n};\n```\n\n### 复杂度分析\n时间复杂度: O(n)\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087652609","body":"## 394.Decode String「字符串解码」\n- 题目地址: https://leetcode-cn.com/problems/decode-string/\n\n### 题目描述\n> 给定一个经过编码的字符串，返回它解码后的字符串。\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n**示例 1:**\n>输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n**示例 2:**\n>输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n**示例 3:**\n>输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n### 前置知识\n- 栈\n\n### 思路\n从左往右遍历，遇到\"[\"代码前面如果有数字就是重复次数，把数字压入数字栈， 如果遍历到是字符，把字符压入字符栈中，直到遇到“[”, 把数字和字符临时变量清零，最后遇到\"]\"时，先出栈数字栈，得到要repeat字符串的次数，然后构建子字符串\n\n\n\n### 代码\n- js 版本\n```js\nconst decodeString = s => {\n  let numStack = [];\n  let strStack = [];\n  let num = 0;\n  let res = '';\n\n  for(let c of s) {\n    if (!isNaN(c)){\n      num = num * 10 + Number(c);\n    } else if(c === '[') {\n      strStack.push(res);\n      res = '';\n      numStack.push(num);\n      num = 0;\n    }else if (c === ']') {\n      let repeatTimes = numStack.pop();\n      res = strStack.pop() + res.repeat(repeatTimes);\n\n  }else {\n    res += c;\n  }\n}\nreturn res;\n```\n\n### 复杂度分析\n时间复杂度： O(n)\n空间复杂度：O(n)\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088543061","body":"## DAY 5 232. Implement Queue using Stacks「用栈生成队列」\n\n- 题目地址: https://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n### 题目描述\n\n> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n> 实现 MyQueue 类：\n> void push(int x) 将元素 x 推到队列的末尾\n> int pop() 从队列的开头移除并返回元素\n> int peek() 返回队列开头的元素\n> boolean empty() 如果队列为空，返回 true ；否则，返回 false\n> 说明：\n> 你 只能 使用标准的栈操作 —— 也就是只有  push to top, peek/pop from top, size, 和  is empty  操作是合法的。\n> 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n**示例 1:**\n\n> 输入：\n> [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n> [[], [1], [2], [], [], []]\n> 输出：\n> [null, null, null, 1, 1, false]\n> 解释：\n> MyQueue myQueue = new MyQueue();\n> myQueue.push(1); // queue is: [1]\n> myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\n> myQueue.peek(); // return 1\n> myQueue.pop(); // return 1, queue is [2]\n> myQueue.empty(); // return false\n\n### 前置知识\n\n- 栈\n\n### 思路\n\n使用两个栈，通过组合使用 FIFO 的特征，从第一个栈 push 进去，然后 pop 出第一个栈的元素，再 push 到第二栈，最后从第二个栈 pop 出去所有元素，这样就实现了先进先出的逻辑\n\n### 关键点\n\n- pop 需要判断第二个栈是否是空，如果是空需要先进行栈 1 导入栈 2 的操作\n\n### 代码\n\n- js 版本\n\n```js\nvar MyQueue = function () {\n  this.inStack = [];\n  this.outStack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.inStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  if (this.outStack.length === 0) {\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n  return this.outStack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  if (this.outStack.length === 0) {\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n  return this.outStack[this.outStack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return this.inStack.length === 0 && this.outStack.length === 0;\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lyuliangliu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085434802","body":"\n### 思路\nAdding from rear to front until both num and k are exhausted.\n### Code\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> result = new LinkedList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int digitFromK = k % 10;\n            int currentDigit = digitFromK + (i >= 0 ? num[i] : 0) + carry;\n            if (currentDigit >= 10) {\n                carry = 1;\n                currentDigit -= 10;\n            } else {\n                carry = 0;\n            }\n            result.add(0, currentDigit);\n            k /= 10;\n            i--;\n        }\n        if (carry == 1) {\n            result.add(0, 1);\n        }\n        return result;\n    }\n}\n```\n### 复杂度\n* Time: O(N) \n* Space: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086543333","body":"### Idea\n* Go forward: record the distance between each letter and the latest c in its left;\n* Go backward: update the distance if a letter is closer to the latest c in its right\n### Code\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        int lastIndexC = Integer.MAX_VALUE;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                ans[i] = 0;\n                lastIndexC = i;\n            } else if (lastIndexC == Integer.MAX_VALUE) {\n                ans[i] = Integer.MAX_VALUE;\n            } else {\n                ans[i] = i - lastIndexC;\n            }\n        }\n        lastIndexC = Integer.MAX_VALUE;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                lastIndexC = i;\n            } else if (lastIndexC - i < ans[i]) {\n                ans[i] = lastIndexC - i;\n            }\n        }\n        return ans;\n    }\n}\n```\n### Complexity\n* Time: 2N\n* Space: N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086707378","body":"###Idea\nInitialize an array of size maxSize. Use a pointer top to indicate current stack top.\n### Code\n```\nclass CustomStack {\n    \n    int[] stack;\n    int top;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if (top < this.maxSize - 1) {\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        return top == -1 ? -1 : stack[top--];\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i <= top; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\nComplexity:\n* Time: push/pop O(1), inc O(K)\n* Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087235208","body":"### Idea\nUse one stack. Push both number and string. When meets ']', pop and calculate. Always push the results back to the stack. If the next peek is a string, append to it and put it at the top.\n### Code\n```\nclass Solution {\n    public String decodeString(String s) {\n        \n        StringBuilder result = new StringBuilder();\n        Stack<String> stack = new Stack<>();\n        for (int i = 0; i < s.length(); i ++) {\n            char c = s.charAt(i);\n            if (c >= '0' && c <= '9') {\n                int end = i;\n                while (end < s.length() && s.charAt(end) >= '0' && s.charAt(end) <= '9') {\n                    end ++;\n                }\n                stack.push(s.substring(i, end));\n                i = end - 1;\n            } else if (c >= 'a' && c <= 'z') {\n                int end = i;\n                while (end < s.length() && s.charAt(end) >= 'a' && s.charAt(end) <= 'z') {\n                    end ++;\n                }\n                if (!stack.isEmpty() && isLetterSeq(stack.peek())) {\n                    stack.push(stack.pop() + s.substring(i, end));\n                } else {\n                    stack.push(s.substring(i, end));\n                }\n                i = end - 1;\n            } else if (c == '[') {\n                continue;\n            } else if (c == ']') {\n                String top = stack.pop();\n                int count = Integer.valueOf(stack.pop());\n                String cur = \"\";\n                for (int j = 0; j < count; j ++) {\n                    cur += top;\n                }\n                if (!stack.isEmpty() && isLetterSeq(stack.peek())) {\n                    stack.push(stack.pop() + cur);\n                } else {\n                    stack.push(cur);\n                }\n            }\n        }\n        return stack.pop();\n    }\n    \n    private boolean isLetterSeq(String s) {\n        if (s.charAt(0) >= 'a' && s.charAt(0) <= 'z') {\n            return true;\n        }\n        return false;\n    }\n}\n```\n### Complexity\n* time: 2N\n* space: N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088344631","body":"### Idea\nPush to stack1: O(1); Pop: reversely move all from stack1 to stack2. For every n pops, only the first takes O(N), the rest take O(1) each.\n### Code\n```\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n    \n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n### Complexity\n* push: O(1)\n* pop: amortized O(1)\n* empty(): O(1)\n* peek(): If use another variable to keep track of the front: O(1); Otherwise amortized O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085443568","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\r\n\r\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\r\n\r\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：num = [1,2,0,0], k = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：num = [2,7,4], k = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：num = [2,1,5], k = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= num.length <= 104\r\n0 <= num[i] <= 9\r\nnum 不包含任何前导零，除了零本身\r\n1 <= k <= 104\r\n```\r\n\r\n## 前置知识\r\n\r\n数组 取模 取余 列表相加\r\n\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  见代码\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        # 从低位到高位进行加法\r\n        # 判断是否需要进位\r\n        # 如果num比k大 就可以结束了\r\n        for i in range(len(num)-1,-1,-1):\r\n            num[i],carry  = (num[i] + k%10 + carry)%10,(num[i] + k%10 + carry)//10\r\n            k //= 10\r\n        # 如果num比k小 考虑继续进位\r\n        high = []\r\n        k = k + carry\r\n        if k:\r\n            high = [int(i) for i in str(k)]\r\n        return high + num\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086516918","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n窗口的左右边界\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n将字符c作为窗口的边界 每次记录窗口的左右边界 然后开始计算距离\r\n\r\n## 关键点\r\n\r\n-  如何确定第一个窗口？\\\r\n  由于第一个窗口可能不存在左边界，因此先从索引位置0开始判断左边界是否存在，如果不存在可以将左边界置为n，那么第一个窗口可以不考虑左边界\r\n- 如何更换窗口？\\\r\n  随着对字符串的遍历，一定会遍历到窗口右边界，那么新窗口的左边界就是当前索引i\r\n- 如何使用字符串查找函数？ \\\r\n  s.find(c,beg=i,end=n)，该函数会从字符串s中查找字符c，然后beg表示开始的索引，end表示结束的索引（左闭右开）；如果找不到返回-1\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \"\"\"寻找距离最近的字符的长度 \r\n\r\n        Args:\r\n            s(str):字符串\r\n            c(str):字符\r\n        \r\n        Returns:\r\n            ans(List[int]):返回结果列表\r\n\r\n        \"\"\"\r\n        n = len(s)\r\n        ans = [0] * n\r\n        \r\n        # 寻找左边界 如果没有左边界 那么直接将左边界设置为字符串长度\r\n        l = 0 if s[0] == c else n\r\n        # 从索引位置1开始搜索字符c\r\n        r = s.find(c,1) \r\n\r\n        for i in range(n):\r\n            # 取距离两个边界的最小距离\r\n            ans[i] = min(abs(i-l),abs(r-i))\r\n            # 考虑移动边界的问题\r\n            if i == r:\r\n                l = i\r\n                r = s.find(c,i+1)\r\n        return ans\r\n        \r\n\r\n\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086815684","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n设置三个类的成员变量，分别存储栈，栈的最大长度以及栈的当前长度，然后实现push、pop以及inc操作\r\n\r\n## 关键点\r\n\r\n-  用到列表的append函数，向后添加元素\r\n-  用到列表的pop()函数，可以返回列表中对应索引的元素\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.size = maxSize\r\n        self.len = len(self.stack)\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.size:\r\n            self.stack.append(x)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.len > 0:\r\n            self.len -= 1\r\n            return self.stack.pop(-1)\r\n        else:\r\n            return -1 \r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.len < k:\r\n            self.stack = [i+val for i in self.stack]\r\n        else:\r\n            self.stack[:k] = [i+val for i in self.stack[:k]]\r\n        \r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$ O(1) $\r\n- 空间复杂度：$ O(n) $ \r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087051498","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n\r\n\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= s.length <= 30\r\ns 由小写英文字母、数字和方括号 '[]' 组成\r\ns 保证是一个 有效 的输入。\r\ns 中所有整数的取值范围为 [1, 300] \r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n解码时会遇到四种情况，'[',']','数字','字符'  \r\n遇到右括号就去匹配左括号   \r\n匹配左括号过程中，就需要维护两个变量，一个是重复字符串，另一个是重复次数\r\n## 关键点\r\n\r\n-  注意判断重复的字符串以及重复次数的条件\r\n- 得到重复子字符串后，可以加入栈，然后继续处理后面的']'\r\n- ''.join() 列表拼接成字符串的用法\r\n- list[-1].isnumeric()判断当前元素是否是数字类型\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        \"\"\"解码字符串\r\n        Args:\r\n            s(str):编码后的字符串\r\n        Returns:\r\n            res(str):解码后的字符串\r\n        \"\"\"\r\n        stack = []\r\n        for char in s:\r\n            if char == ']':\r\n                # 进行括号匹配\r\n                reapetStr = ''\r\n                reapetCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    reapetStr = stack.pop() + reapetStr\r\n                # 找到左括号\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    reapetCount = stack.pop() + reapetCount\r\n                # 匹配好字符串后 重新入栈\r\n                stack.append(reapetStr * int(reapetCount))\r\n            else:\r\n                stack.append(char)\r\n        return ''.join(stack)\r\n            \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n## 思路\r\n\r\n采用递归的解法  \r\n遇到数字开始计算重复次数；  \r\n遇到左括号开始新的递归；  \r\n遇到右括号开始结束一次递归；  \r\n遇到字符添加在重复字符子串  \r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        \"\"\"解码字符串\r\n        Args:\r\n            s(str):编码后的字符串\r\n        Returns:\r\n            res(str):解码后的字符串\r\n        \"\"\"\r\n        def dfs(start):\r\n            reapteStr,reapteCount = '',''\r\n            while start < len(s):\r\n                if s[start].isnumeric():\r\n                    reapteCount += s[start]\r\n                elif s[start] == '[':\r\n                    start, t_str = dfs(start+1)\r\n                    reapteStr += t_str * int(reapteCount)\r\n                    reapteCount = ''\r\n                elif s[start] == ']':\r\n                    return start, reapteStr\r\n                else:\r\n                    reapteStr += s[start]\r\n                start += 1\r\n            return reapteStr\r\n        return dfs(0)\r\n        \r\n            \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088273433","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n\r\n说明：\r\n\r\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= x <= 9\r\n最多调用 100 次 push、pop、peek 和 empty\r\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\r\n\r\n \r\n\r\n进阶：\r\n\r\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\r\n```\r\n\r\n\r\n\r\n## 思路\r\n由于栈是先进后出的特性，一个栈无法实现队列操作，因此需要两个栈。  \r\n其中一个栈用于进入队列，栈依然保持了入队的顺序  \r\n出队时，如果出栈为空，将入栈的元素反向放入出栈；如果出栈不为空，输入出栈的栈顶元素  \r\n判空条件就是两个栈同时为空  \r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass MyQueue:\r\n    \"\"\"\r\n    使用两个栈来实现队列的操作，将两个栈分为输入栈和输出栈\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None \r\n        if self.outstack:\r\n            return self.outstack.pop()\r\n        else:\r\n            self.outstack = self.instack[::-1]\r\n            self.instack = []\r\n        return self.outstack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outstack:\r\n            return self.instack[0]\r\n        else:\r\n            return self.outstack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if not self.instack and not self.outstack:\r\n            return True\r\n        return False \r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085447103","body":"## 思路\n    将数组的最后一位加到k上，然后k对10取余，得到的结果放到linkedList的第一位。数组长度不足时则只操作k。直到k小于0并且数组遍历结束。\n## 复杂度分析\n    时间复杂度O(n) 空间复杂度O(n)\n## 代码\n```\npublic List<Integer> addToArrayForm2(int[] num, int k) {\n    LinkedList<Integer> ans = new LinkedList<>();\n    int i = num.length - 1;\n    while (k >= 1 || i >= 0) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        i--;\n        ans.addFirst(k % 10);\n        k /= 10;\n    }\n    return ans;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086581512","body":"##   思路\r\n    预设一个初始为0的k来记录上一次c出现的下标，循环将i-k当做答案。\r\n    当c再次出现的时候 只需要将(i+k)/2到i的下标重新赋值即可。\r\n    使用flag标记来解决当0下标为c的时候只会对0到下一个下标之前的全部数据赋值的错误\r\n##   复杂度\r\n    时间复杂度O(n) 空间复杂度O(n)\r\n##  代码\r\n```\r\npublic int[] shortestToChar(String s, char c) {\r\n    int k = 0;\r\n    int[] ans = new int[s.length()];\r\n    boolean flag = false;\r\n    for (int i = 0; i < s.length(); i++) {\r\n        if (s.charAt(i) == c) {\r\n            for (int j = i; flag && j > (i + k) >> 1 || !flag && j >= k; j--) {\r\n                ans[j] = i - j;\r\n            }\r\n            k = i;\r\n            flag = true;\r\n        }\r\n        ans[i] = i - k;\r\n    }\r\n    return ans;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086764486","body":"##   思路\n      数组实现，使用两个值分别保存最大长度和当前长度，添加和移除的时候就从当前长度位上操作\n##  代码\n```\nclass CustomStack {\n    int[] value;\n    int maxSize;\n    int current = 0;\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.value = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(current==maxSize){\n            return;\n        }\n        value[current++]=x;\n    }\n    \n    public int pop() {\n        if(current==0){\n            return -1;\n        }\n        return value[--current];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k&&i<current;i++){\n            value[i]+=val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087232122","body":"## 思路\n    双栈思路，将倍数放入倍数栈内，对应层级的字符串放在对应的字符串栈中，当遇到]时处理这一对中括号之间的数据，从倍数栈中取出倍数，将当前的字符串扩展到倍数长，再讲对应的字符串栈中的字符串拼接到扩展之后的字符串之前。\n\n## 复杂度\n    时间复杂度O(n) 空间复杂度O(n)\n\n## 代码\n\n```\npublic String decodeString(String s) {\n        Deque<Integer> stackNumber = new LinkedList<>();\n        Deque<String> stackString = new LinkedList<>();\n        StringBuilder stringBuilder = new StringBuilder();\n        int number = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '[') {\n                stackNumber.push(number);\n                number = 0;\n                stackString.push(stringBuilder.toString());\n                stringBuilder = new StringBuilder();\n            } else if (s.charAt(i) == ']') {\n                StringBuilder temp = new StringBuilder();\n                int curr_number = stackNumber.pop();\n                for (int j = 0; j < curr_number; j++) {\n                    temp.append(stringBuilder);\n                }\n                stringBuilder = temp.insert(0, stackString.pop());\n            } else if (s.charAt(i) > 47 && s.charAt(i) < 58) {\n                number = 10 * number + (s.charAt(i) - '0');\n            } else {\n                stringBuilder.append(s.charAt(i));\n            }\n        }\n        return stringBuilder.toString();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088295111","body":"##  思路\n    向其中一个栈推数据会出现在栈顶，如果需要读取的时候，需要读取最后一个，这时候只需要将栈翻转即可。\n    在队列的先进先出规则上，只会操作栈的最后一个，所以将栈翻转之后保存即时队列的操作顺序。\n    当用于输出的栈数据为空的时候，将用于保存的栈的数据翻转给输出栈。\n\n##  复杂度\n    时间复杂度O(1) 对于双栈中的每个数据 均进行两次入栈 两次出栈的操作  空间复杂度O(1)除双栈外不需要额外的空间 \n\n##  代码\n```\nclass MyQueue {\n        private Stack<Integer> headStack = new Stack<>();\n        private Stack<Integer> tailStack = new Stack<>();\n        \n        public MyQueue() {\n        }\n\n        public void push(int x) {\n            headStack.push(x);\n        }\n\n        public int pop() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.pop();\n        }\n\n        public int peek() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.peek();\n        }\n\n        public boolean empty() {\n            return headStack.empty() && tailStack.empty();\n        }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085449145","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n \n\n示例 1：\n\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n \n\n提示：\n\n1 <= num.length <= 104\n0 <= num[i] <= 9\nnum 不包含任何前导零，除了零本身\n1 <= k <= 104\n```\n\n## 前置知识\n\n- 数组遍历、逐位相加的方法\n\n\n## 思路\n1、数组输出，需要通过for循环将数组输出\n2、将数组和整数依次相加，整数获取位数上的数可通过依次进行求余运算\n\n## 关键点\n\n-  熟悉整数获取位数上的方法\n- 熟悉数组的API，push（）、reverse（）\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let res = [];\n    let n = num.length;\n    for(let i = n -1; i >= 0; i--)\n    {\n        let sum = num[i] + k%10;\n        k = Math.floor(k/10);\n        if(sum>=10)\n        {\n            k++;\n            sum = sum -10;\n        }\n        res.push(sum);\n    }\n    for(;k>0;k = Math.floor(k/10))\n    {\n        res.push(k%10);\n    }\n    res.reverse();\n    return res;\n\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，\n- 空间复杂度：$O(1)$，没有额外增加空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086657535","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 前置知识\n\n- 数组的API\n- 双指针\n\n\n## 思路\n（本题参考了其他人的代码）\n- 主要需要解决的问题是取离c最小的距离\n\n## 关键点\n\n-  判断离c最小的距离\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let num = [];\n    num.length === s.length;\n    let indexNext=s.indexOf(c);//indexNext表示下一个c的下标， \n    let index=indexNext;//index表示前一个c的坐标\n    //index也在当前字符的右边，否则在左右都有C字符的时候，当前字符必在index和indexNext的中间。\n       for(let i = 0; i < s.length; i++){\n            if(s[i] == c){//每当遍历到C就更新index和indexNext\n                num[i] = 0;\n                index = i;\n                indexNext = s.indexOf(c, i+1);\n            }else{\n                num[i] = Math.min(Math.abs(index - i), Math.abs(indexNext - i));\n            }\n        }\n    return num;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086888061","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 前置知识\n\n- 栈\n\n\n## 思路\n主要难点在于void inc(int k, int val)，但暂时只会使用for循环进行完成，但复杂度较高\n\n## 关键点\n\n-  需要考虑个数需求以及栈的元素是否为0\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.Stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.Stack.length >= this.maxSize)\n    {\n        return;\n    }\n    this.Stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.Stack.length == 0)\n    {\n        return -1;\n    }\n    return this.Stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(this.Stack.length <= k)\n    {\n        for(let i = 0; i < this.Stack.length ;i++)\n    {\n            this.Stack[i] += val;\n    }\n    }\n    else\n    {\n        for(let j = 0; j < k ; j++)\n        {\n            this.Stack[j] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087727938","body":"\n## 题目地址(394. 字符串解码)\n\nhttps://leetcode-cn.com/problems/decode-string/\n\n## 题目描述\n\n```\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n \n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n\n示例 3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n示例 4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n\n\n \n\n提示：\n\n1 <= s.length <= 30\ns 由小写英文字母、数字和方括号 '[]' 组成\ns 保证是一个 有效 的输入。\ns 中所有整数的取值范围为 [1, 300] \n```\n\n## 前置知识\n\n- 栈前后匹配的运行\n\n\n## 思路\n- 本题最初的思路仅有本题与栈有关，而其余毫无思路，通过讲义知道应该使用栈的匹配方法将此题目进行完成\n\n## 关键点\n\n-  数字只运用于重复的倍数，而字符串则代表重复的字符串内容\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst decodeString = (s) => {\n    let numStack = [];        // 存倍数的栈\n    let strStack = [];        // 存 待拼接的str 的栈\n    let num = 0;              // 倍数\n    let result = '';          // 字符串\n    for (const char of s) {   // 逐字符扫描\n        if (!isNaN(char)) {   // 遇到数字\n            num = num * 10 + Number(char); // 算出倍数\n        } else if (char == '[') {  // 遇到 [\n            strStack.push(result); // result串入栈\n            result = '';           // 入栈后清零\n            numStack.push(num);    // 倍数num进入栈等待\n            num = 0;               // 入栈后清零\n        } else if (char == ']') {  // 遇到 ]，两个栈的栈顶出栈\n            let repeatTimes = numStack.pop(); // 获取拷贝次数\n            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\n        } else {                   \n            result += char;        // 遇到字母，追加给result串\n        }\n    }\n    return result;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088860064","body":"\n## 题目地址(232. 用栈实现队列)\n\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n## 题目描述\n\n```\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\n实现 MyQueue 类：\n\nvoid push(int x) 将元素 x 推到队列的末尾\nint pop() 从队列的开头移除并返回元素\nint peek() 返回队列开头的元素\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n说明：\n\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n示例 1：\n\n输入：\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n\n\n \n\n提示：\n\n1 <= x <= 9\n最多调用 100 次 push、pop、peek 和 empty\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\n\n \n\n进阶：\n\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\n```\n\n## 前置知识\n\n- 栈（先进后出）、队列（先进先出）\n\n\n## 思路\n通过两个栈进行实现队列，解决的关键在于数据进与出的问题\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar MyQueue = function() {\n    //使用两个栈实现队列，创建栈\n    this.stack1 = [];//将一个栈当作输入栈，用于push操作，通过push 传入数据\n    this.stack2 = [];//将一个栈当作输出栈，用于pop 和peek操作\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\n //将元素x推到队列的末尾\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\n //从队列的开头移除并返回元素\n //碰到pop/peek，把所有输入栈的内容放到输出栈去\nMyQueue.prototype.pop = function() {\n    if(!this.stack2.length)\n    {\n        while(this.stack1.length)\n        {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\n //返回队列开头的元素\nMyQueue.prototype.peek = function() {\n    if(!this.stack2.length)\n    {\n        while(this.stack1.length)\n        {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2[this.stack2.length-1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function(){\n    if(this.stack1.length == 0 && this.stack2.length == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：push-O（1）pop-O（n） peek-O（n）empty-O（1）\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085454092","body":"### 思路\n\n- 将整型列表拼接为字符串后，再转为int型与k相加\n- 将相加后的结果转为字符串后遍历，生成整型列表\n\n### 代码\n\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num = int(\"\".join(list(map(str, num))))\n        return [int(i) for i in str(num + k)]\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086650955","body":"### 思路\n\n1. 先遍历列表s，找到每一个元素c的索引位置，并添加到一个c_pos列表中\n2. for循环len(s)，如果当前位置的索引i小于c_pos[0]，即在c_pos[0]的左侧， 那么就往ans列表中添加“c_pos[0] - i“\n3. 如果当前的位置索引i大于c_pos[-1]，机在c_pos[-1]的右侧，那么就往ans列表中添加“i - c_pos[-1]”\n4. 如果当前的位置索引等于c_pos[p], p=0, 即当前的索引对于的就是元素c，那么就往ans列表中添加“0”, 同时p+=1\n5. 否则，如果恰巧当前位置前后都有元素c的索引，那么就判断离着谁更近，就往ans列表中“min(c_pos[p]-i, i-c_pos[p-1])”\n\n### 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        c_pos, ans = [], []\n        for idx, i in enumerate(s):\n            if i == c:\n                c_pos.append(idx)\n        \n        p = 0\n        for i in range(len(s)):\n            if i < c_pos[0]:\n                ans.append(c_pos[0] - i)\n            elif i > c_pos[-1]:\n                ans.append(i - c_pos[-1])\n            elif i == c_pos[p]:\n                ans.append(0)\n                p += 1\n            else:\n                ans.append(min(c_pos[p] - i, i - c_pos[p-1]))\n        return ans\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086763675","body":"### 代码\n\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        self.length = 0\n        \n\n    def push(self, x: int) -> None:\n        if self.length < self.maxSize:\n            self.stack.append(x)\n            self.length += 1\n\n    def pop(self) -> int:\n        if self.length > 0:\n            self.length -= 1\n            return self.stack.pop()\n        \n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(self.length, k)):\n            self.stack[i] += val\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1) / O(K)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087687918","body":"### 思路\n1. 遇到的元素不是]，那么就先压入栈中\n2. 遇到 ] 时，逐个弹栈，直到遇到 [\n3. 继续弹出 [ 前的数字\n4. 将 string 重复 num次压入栈中\n5. 重复上述过程，直到栈空\n\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        \n        stack = []\n        \n        for c in s:\n            if c != ']':\n                stack.append(c)\n            else:\n                string = \"\"\n                while len(stack) > 0 and stack[-1] != '[':\n                    string = stack.pop() + string\n                # 弹出左括号\n                stack.pop()\n                \n                # 弹出重复数字\n                num_string = \"\"\n                while len(stack) > 0 and stack[-1].isdigit():\n                    num_string = stack.pop() + num_string\n                    \n                num = int(num_string)\n                stack.append(string * num)\n        return \"\".join(stack)\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088850661","body":"### 思路\n- 用两个堆栈 stack1 和 stack2 来模拟队列\n- 入队列时：向 stack1 中压入元素\n- 出队列时：将 stack1 中的元素依次弹出堆栈，并压入 stack2 中，最后弹出 stack2 的栈顶元素\n\n### 代码\n\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            while self.stack1:\n                tmp = self.stack1.pop()\n                self.stack2.append(tmp)\n            return self.stack2.pop()\n\n    def peek(self) -> int:\n        if self.stack2:\n            return self.stack2[-1]\n        else:\n            while self.stack1:\n                tmp = self.stack1.pop()\n                self.stack2.append(tmp)\n            return self.stack2[-1]\n\n    def empty(self) -> bool:\n        if len(self.stack1)==0 and len(self.stack2)==0:\n            return True\n        else:\n            return False\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maggiexie00":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085454513","body":"### 思路\r\n\r\n从尾部开始，原地更新num中的数值，k处理完则break\r\n\r\n***把k当作carry\r\n***题目已知num长度最多10^4，k最多5位数，若开辟新数组，则极大增加时间复杂度（遍历num），因而选择原地更新num数组，最坏情况是进行6次操作。\r\n*** key point 是k处理完就停止，无需遍历num。\r\n\r\n### 代码\r\n\r\n\r\n    def addToArrayForm(self, num, k) :\r\n\r\n        p=len(num)-1\r\n        while p>-1 and k!=0:\r\n            tmp=num[p]+k%10\r\n            num[p]=tmp%10\r\n            k=k//10+tmp//10\r\n            p-=1    \r\n\r\n        while k:\r\n            num=[k%10]+num\r\n            k//=10\r\n\r\n        return num\r\n\r\n### 复杂度\r\n空间复杂度 O(1)\r\n时间复杂度 O(N）其中N为k的位数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086642755","body":"### 思路\r\n\r\n两次遍历\r\n\r\n记录上一个字符c出现的位置，从头走一遍，计算距离，再从尾部走一遍，更新距离为两次计算中的较小值。\r\n\r\n### 代码\r\n\r\n\r\n    def shortestToChar(self, s, c):\r\n        last=-10000\r\n        ans=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                last=i\r\n            ans.append(i-last)\r\n        last=10000\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i]==c:\r\n                last=i\r\n            ans[i]=min(ans[i],last-i)\r\n        return ans\r\n            \r\n\r\n\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086716724","body":"### 思路\r\n一句话总结：只有pop操作时才真正进行增量操作，使得increment操作时间复杂度也是O(1)。\r\n\r\npush操作时，用[x，y]代替x。y用于increment操作，初始值均为0。\r\nincrement操作时，找到最后一个需要更新数值的位置，将该数值对应的y加上val。\r\npop操作时，返回x+y，并更新栈顶元素的y。\r\n### 代码\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack=[]\r\n        self.size=0\r\n        self.maxSize=maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size<self.maxSize:\r\n            self.stack.append([x,0])\r\n            self.size+=1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        self.size-=1\r\n        a,b=self.stack.pop(-1)\r\n        if self.stack:\r\n            self.stack[-1][1]+=b\r\n        return a+b\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        idx=min(k,self.size)-1\r\n        if idx>-1:\r\n            self.stack[idx][1]+=val\r\n\r\n### 复杂度\r\n时间 O(1)\r\n空间 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087126743","body":"### 思路\r\nkey point: 栈中保存的是last_res（上个 [ 与当前 [ 之间的字符串）与cur_multi（当前 [ 与 ] 中字符串的重复次数）\r\n\r\ndetail：\r\n遇到字母，直接加到res后；\r\n遇到数字，计算multi；\r\n遇到左括号，将[multi，res]入栈，并重置multi，res；\r\n遇到右括号，出栈并进行拼接：将当前字符串乘上multi，拼接至之前字符串后。\r\n\r\nthinking: 因为遇到括号嵌套时，需要从内向外解码，即需要先入后出，因而想到用栈。值得注意的是，并非无脑入栈。手动解码的过程是先乘再拼接，因此入栈也是保存 [ 当前的倍数，待拼接的之前字符串 ]。\r\n\r\n### 代码\r\n    def decodeString(self, s: str) -> str:\r\n        stack,multi,res=[],0,''\r\n        for c in s:\r\n            if c.isdigit():\r\n                multi=10*multi+int(c)\r\n            elif c=='[':\r\n                stack.append([multi,res])\r\n                multi,res=0,''\r\n            elif c==']':\r\n                curr_multi,last_res=stack.pop()\r\n                res=last_res+curr_multi*res\r\n            else:\r\n                res+=c\r\n        return res\r\n### 复杂度\r\n时间 O(N) \r\n空间 O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088870974","body":"### 思路\r\n入队：新的元素总是压入stack1栈顶，第一个进入的元素赋值给记录队首元素的front变量。\r\n出队：当stack2为空，将stack1内元素全部弹出，再压入stack2。若非空，则直接返回stack2栈顶元素。\r\n取队首元素：若stack2非空，返回stack2栈顶元素值。否则返回front变量值。\r\n### 代码\r\n    def __init__(self):\r\n        self.stack1=[]\r\n        self.stack2=[]\r\n        self.front=None\r\n\r\n    def push(self, x: int) -> None:\r\n        if not self.stack1:\r\n            self.front=x\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.stack2:\r\n            return self.stack2[-1]\r\n        else:\r\n            return self.front\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2\r\n### 复杂度\r\n入队：时间O(1)    空间O(N)\r\n出队：平均时间复杂度O(1)    空间O(1)\r\n判空：时间O(1)    空间O(1)\r\n队首：时间O(1)    空间O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bigboom666":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085464204","body":"## 思路\n低位往高位加。\n进位放到k里处理。\n## code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> resultSta = new ArrayList<>();\n        \n        //进位放到k里处理\n        for(int i=num.length-1; i>=0;i--){\n\n            int sum =  num[i] +k%10;\n            k = k/10;\n\n            if(sum >= 10){\n                k++;\n                sum -= 10;\n            }\n\n\n            resultSta.add(sum);\n        }\n\n        while(k!=0){\n            resultSta.add(k%10);\n            k = k/10;\n        }\n\n        Collections.reverse(resultSta);\n        return resultSta;\n    }\n}\n```\n\n## 复杂度\n时间：o(n+k)\n控件：o(n+k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086558958","body":"## 思路\n同时正向和反向遍历\n## code\n```java\nclass Solution {\n    //同时正向和反向遍历\n    public int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        for(int i=0;i<s.length();i++){\n            int head = i;\n            int tail = i;\n            while(true){\n                if(head>=0 && s.charAt(head) == c) break;\n                if(tail<s.length() && s.charAt(tail) == c) break;\n                head--;\n                tail++;\n            }\n            result[i] = (i-head)<(tail-i)?(i-head):(tail-i);\n        }\n        return result; \n\n    }\n}\n```\n\n## 复杂度\n时间：o(n^2)\n空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086885319","body":"```java\nclass CustomStack {\n    int[] mStack;\n    int top = -1;\n    public CustomStack(int maxSize) {\n        mStack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(top < mStack.length-1){\n            mStack[++top] = x;\n        }\n       \n    }\n    \n    public int pop() {\n        if(top>=0){\n            return mStack[top--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int temp = top<k-1?top:k-1;\n        for(int i=0;i<=temp;i++){\n            mStack[i] +=val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087732939","body":"##思路  \n\n双栈，存放数组和字符串\n\n\n##code\n```java\npublic String decodeString(String s) {\n    Deque<Integer> stack_digit = new LinkedList<>();\n    Deque<StringBuilder> stack_string = new LinkedList<>();\n    int digit = 0;\n    StringBuilder res = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n        char ch = s.charAt(i);\n        if (ch == '[') {\n            stack_digit.push(digit);\n            stack_string.push(res);\n            digit = 0;\n            res = new StringBuilder();\n        }else if (ch == ']') {\n            StringBuilder temp = stack_string.poll();\n            int count = stack_digit.poll();\n            for (int j = 0; j < count; j++) {\n                temp.append(res.toString());\n            }\n            res = temp;\n        }else if (Character.isDigit(ch)) {\n            digit = digit*10 + ch - '0';\n        }else {\n            res.append(ch);\n        }\n    }\n    return res.toString();\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088814153","body":"## 思路 \n双栈  \npush：先检查pop栈中是否有元素，如果有，先倒到push栈再进行新元素的push操作  \npop：先检查push栈中是否有元素，如果有，先倒到pop栈再进行新元素的pop操作  \n\n## 代码\n```java\nclass MyQueue {\n    Deque<Integer> stackIn;\n    Deque<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new ArrayDeque<>();\n        stackOut = new ArrayDeque<>();\n    }\n\n    //push时检查out栈里是否为空，否则倒到in栈里再进行push\n    public void push(int x) {\n        while(stackOut.size()>=1){\n            stackIn.addFirst(stackOut.removeFirst());\n        }\n        stackIn.addFirst(x);\n    }\n    \n    //pop同理\n    public int pop() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.removeFirst();\n        return res;\n    }\n    \n    public int peek() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.getFirst();\n        return res;\n    }\n    \n    public boolean empty() {\n        return stackIn.size()==0 && stackOut.size()==0;\n    }\n}\n```\n\n## 复杂度  \n空间：O(n)  \n时间：O(n)  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carrieyqzhang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085470672","body":"### 思路\r\n从个位数求两数之和，carry= 1 如果sum大于10.\r\nsum % 10 得到的结果就是当位数的值\r\nwhile 结束loop如果num[]里没有元素，而且k 等于0\r\n\r\n### 代码\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry = 0;\r\n        int l1 = num.length -1;\r\n        while (l1 >= 0 || k != 0){\r\n            int a = l1 < 0 ? 0 : num[l1]; //get last element in num[]\r\n            int b = k <= 0 ? 0 : k % 10; //get last digit in k            \r\n            int sum = a + b + carry;\r\n            res.add(0, sum % 10);\r\n            carry = sum / 10;\r\n            \r\n            l1--;\r\n            k /= 10;\r\n        }\r\n        if (carry != 0) res.add(0,carry);\r\n    \r\n        return res;     \r\n    }\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086667323","body":"### 思路\n左右遍历一遍\n\n### 代码\n```java\npublic int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] out_arr = new int[n];\n        int cPos = -n;\n        \n        for(int i =0; i <n; i++){\n            if(s.charAt(i) == c){\n                cPos = i;\n            }\n            out_arr[i] = i - cPos;\n        }\n        for(int i = n-1; i >=0; i--){\n            if(s.charAt(i) == c){\n                cPos = i;\n                \n            }\n            out_arr[i] = Math.min(out_arr[i], Math.abs(i-cPos));\n        }\n        return out_arr;\n        \n    }\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086790288","body":"### 思路\n用stack实现CustomStack\ninc[] 用来存储increment value,每pop一个值，加上inc[i]的值返回，inc[i-1]=inc[i],以便后面pop时可以加上increment value值\n\n### 代码\n\n```Java\nclass CustomStack {\n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n\n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack =  new Stack<>();\n    }\n    \n    public void push(int x) {\n        if( stack.size() < n){\n            stack.push(x);\n        }\n    }\n    \n    public int pop() {\n        int i = stack.size() - 1;\n        if(i < 0 )return -1;\n        if(i > 0){\n            inc[i-1] += inc[i]; //store the increment value for bottom use\n        }\n        int res = stack.pop() + inc[i];\n        inc[i] = 0; //set current increment to 0 since its poped\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if(i >= 0)\n            inc[i] += val; //inc[i] means increment val for all stack[0]-> stack[i]\n        \n    }\n}\n\n```\n\n时间/空间复杂度： O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087146894","body":"### 思路\n用栈存所有不是】的character， 等遇到后括号开始pop存在栈里characters, 遇到数字就append multiple times of substr\n\n### code\n\n``` python\ndef decodeString(self, s: str) -> str:\n        stack = []\n        \n        for i in range(len(s)):\n            if s[i] != \"]\":\n                stack.append(s[i])\n            else:\n                substr = \"\"\n                while stack[-1] != \"[\":\n                    substr = stack.pop() + substr\n                stack.pop()\n                    \n                k = \"\"\n                while stack and stack[-1].isdigit():\n                    k = stack.pop() + k\n                stack.append(int(k) * substr)\n                    \n        return \"\".join(stack)\n```\n\n时间空间复杂度： O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088282981","body":"### 思路\n\n用两个栈来实现，push的时候用input stack, pop的时候如果output栈有元素，直接pop,如果为空，把input栈所有元素push到output栈再pop\npeek()也先检查output栈是否为空，不为空直接peek,空的话把input栈所有元素push到output栈再peek\n如果两个栈都为空的话那么empty（）返回空\n\n### 代码\n\n\n```java\nclass MyQueue {\n    Stack<Integer> input;\n    Stack<Integer> output;\n\n    public MyQueue() {\n        input = new Stack<>();\n        output = new Stack<>();\n        \n    }\n    \n    public void push(int x) {\n        input.push(x);\n        \n    }\n    \n    public int pop() {\n        if(output.isEmpty()){   //must check if it's empty   \n            while(!input.isEmpty()){\n                output.push(input.pop());\n            }     \n        }\n          return output.pop();\n        \n    }\n    \n    public int peek() {\n        if(output.isEmpty()){//must check empty\n            while(!input.isEmpty()){\n                output.push(input.pop());\n            }\n        }\n        return output.peek();\n    }\n    \n    public boolean empty() {\n        return output.isEmpty() && input.isEmpty();\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"l-sui":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085485310","body":"/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let len = num.length-1;\n    while(len>=0&&k>0){\n        const sum = k+num[len]\n        num[len] = sum%10\n        k=~~(sum/10)\n        len--\n    }\n    if(k>0) return [...k.toString().split(''),...num]\n    return num\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086770679","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.queue = [];\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.queue.length<this.maxSize) this.queue.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.queue.length==0) return -1;\n    return this.queue.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=0;i<k&&i<this.queue.length;i++)this.queue[i] += val\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xil324":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085491089","body":"思路: 先把数组转换为正数,然后再把两个数相加，最后再把得到的整数转换为数组。 时间复杂度o(n), 空间复杂度O(n) , n取决于num 和结果数组的最大值。 \r\n```\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        number = self.convert_array_to_integer(num);\r\n        print(number)\r\n        sum_two_numbers = number + k\r\n        res = [];\r\n        while sum_two_numbers >= 10:\r\n            res.append(sum_two_numbers % 10);\r\n            sum_two_numbers = sum_two_numbers // 10; \r\n        res.append(sum_two_numbers)\r\n        return res[::-1]; \r\n        \r\n            \r\n    \r\n    def convert_array_to_integer (self, arr):\r\n        result = 0;\r\n        for i in range(len(arr)):\r\n            if arr[i] == '0': \r\n                result - result * 10;\r\n            else:\r\n                result = result * 10 + arr[i]; \r\n            \r\n        return result; \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086540900","body":"```\r\nclass Solution(object):\r\n    #数组的遍历(正向遍历和反向遍历)\r\n    #思路： 遍历两次，每次遍历，更新target到i的距离， 取两次遍历的最小值，也就是查看，左右target哪一个离i更近，更新result（返回数组）\r\n    #result[target] = 0\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        \r\n        result = [float('inf')] * len(s); \r\n        target = -len(s);\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                target = i; \r\n            result[i] = min(result[i], abs(target-i)); \r\n        for i in range(len(s)-1, -1,-1):\r\n            if s[i] == c:\r\n                target = i; \r\n            result[i] = min(result[i], abs(target-i));\r\n        return result;\r\n```\r\n时间复杂度： o(n)\r\n空间复杂度： o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086776798","body":"```\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize; \r\n        self.stack = []; \r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x);\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.stack) != 0:\r\n            temp = self.stack[-1];\r\n            self.stack.pop(); \r\n            return temp;\r\n        else:\r\n            return -1; \r\n        \r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        i = 0; \r\n        while i < k and i < len(self.stack):\r\n            self.stack[i] += val;\r\n            i+=1; \r\n    \r\n        \r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086938297","body":"使用栈， 对于给定的数组，把元素依次入栈，遇到 \"]”， 则将元素依次出栈直到遇到\"[\"， 把得到的string放回栈，然后处理\"[\"前的数字。 在处理数字（重复的次数时），要注意多位数的情况(>=10). 时间复杂度： O(n). 空间复杂度:O(n)\r\n```\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []; \r\n        for i in range(len(s)):\r\n            if s[i] == ']':\r\n                temp = []; \r\n                while stack[-1] != '[':\r\n                    temp.append(stack.pop());\r\n                stack.pop(); \r\n                counter = 0\r\n                base = 1\r\n                while stack and stack[-1].isdigit():\r\n                    counter += (ord(stack.pop()) - ord('0')) * base\r\n                    base *= 10\r\n                print('counter is', counter)\r\n                str = ''.join(temp[::-1])\r\n                stack.append(str * counter); \r\n            else:\r\n                stack.append(s[i]); \r\n        return ''.join(stack);\r\n                    \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088316192","body":"思路： 使用两个栈，栈A正常操作，在pop的时候，看栈B是否为空，如果为空，则将元素依次pop出，然后加入栈B， 这样栈B的元素就是先进先出\n\n···\n\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = [];\n        self.stack2 = [];\n        \n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x); \n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.peek(); #check if self.stack2 is empty \n        return self.stack2.pop(); \n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack2) == 0:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop()); \n        return self.stack2[-1]; \n        \n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return len(self.stack1)==0 and len(self.stack2)==0; \n  ···","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085491869","body":"/* 求和的方法始终会溢出，故不可采取\r\n        size_t sum = 0, max_size = num.size();\r\n        // get the sum\r\n        for(int i(0); i < max_size; ++i)\r\n            // sum += num[i] * pow(10, max_size-i-1);\r\n            sum  = sum * 10 + num[i];\r\n        sum += k;\r\n        // int count(1), level(0);\r\n        // while(sum % count) {\r\n        //     level++;\r\n        //     count *= 10;\r\n        // }\r\n        // vector<int> tmp_vec[level];\r\n        // int i(0);\r\n        // while(level){\r\n        //     tmp_vec.push_back(sum / power(10, level-1));\r\n            \r\n        //     --level;\r\n        // }\r\n\r\n        // 对于数值的位的操作有：移位操作，不过基于十进制的移位可能需要重新设计；\r\n        // 转化为string类型；\r\n        // 通过for循环取余或除提取\r\n\r\n        string str_sum = to_string(sum);  //将int型转化为string，从而可以单独操作每一位；\r\n        const size_t length = str_sum.size();\r\n        vector<int> tmp_vec;\r\n        for(int i(0); i < length; ++i)\r\n            tmp_vec.push_back(str_sum[i]-48);\r\n\r\n        return tmp_vec;\r\n        */\r\n\r\n        string str_k = to_string(k);\r\n        size_t length_num = num.size();\r\n        size_t length_k = str_k.size();\r\n        int i = length_num-1;\r\n        int j = length_k-1;\r\n        int carry = 0;\r\n        while((i+1) && (j+1)){\r\n            num[i] = num[i] + str_k[j] - 48 + carry;\r\n            carry = 0;\r\n            if(num[i] >= 10){\r\n                carry = 1;\r\n                num[i] %= 10;\r\n            }\r\n            --i;\r\n            --j;\r\n        }\r\n\r\n        if(carry){\r\n            \r\n        }\r\n    }\r\n\r\n只能说 尝试了相加的方法，但是用了size_t后还是溢出，又采取了逐位相加，结果在判断上理解还是不够到位，对情况的分析很卡。最后没忍住看了官方题解，那么这题也就作废了。留此记录。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pfyyh":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085499940","body":"### 思路\r\n\r\n模拟加法\r\n\r\n按照低位求和，大于等于十则进一。\r\n\r\n\r\n\r\n存储结构，使用的是LinkedList。底层是链表结构，往链表头插入元素。低位先进入链表，高位最后。减少一次反转\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //以num数组为基准\r\n        LinkedList<Integer> deque = new LinkedList<>();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            //计算当前位\r\n            int value = num[i] + k % 10;\r\n            //丢弃最低位\r\n            k /= 10;\r\n            //如果结果大于10，k进1\r\n            if (value >= 10) {\r\n                k += 1;\r\n                value -= 10;\r\n            }\r\n            deque.addFirst(value);\r\n        }\r\n        //如果数组用完了，将K剩下的高位放进去\r\n        for (; k > 0; k /= 10) {\r\n            deque.addFirst(k % 10);\r\n        }\r\n        return deque;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(N+M,N))，其中 N 为数组长度,M=K长度-N长度。\r\n- 空间复杂度：O(max(N+M,N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086630219","body":"### 思路\n\n借鉴了滑动窗口算法，找到第一个和第二个出现字符的位置。\n\n比较下标-头的距离和尾巴-下标的距离，填入数组。\n\n当下标到达尾巴的时候，说明已经\n\n当S字符串只有一个符合的c的时候，从符合位置点往两边填充距离。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        //存储结果\n        int[] result = new int[s.length()];\n        //判断滑动窗口\n        int head = s.indexOf(c);\n        int tail = s.indexOf(c, head + 1);\n        //说明没有窗口，直接填充两边值即可\n        if(tail==-1){\n            int absLength = 0;\n            int lP = head;\n            int rP = head;\n            //从唯一的下标开始往两边扩展\n            while(lP>=0||rP<s.length()){\n                if(lP>=0){\n                    result[lP]=absLength;\n                    lP--;\n                }\n                if(rP<s.length()){\n                    result[rP]=absLength;\n                    rP++;\n                }\n                absLength++;\n            }\n            return result;\n\n        }\n        char[] chars = s.toCharArray();\n        \n        for (int i = 0; i < chars.length; i++) {\n            result[i] = Math.min(Math.abs(head - i), Math.abs(tail - i));\n            //遍历到了尾巴，尾巴变头，找下一个尾巴。\n            if (i == tail) {\n                head = tail;\n                //如果尾巴没了，tail = -1 tail-i的绝对值永远大于head-i的绝对值,永远是head-i\n                tail = s.indexOf(c, tail + 1);\n            }\n        }\n        return result;\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086863323","body":"### 思路\n\n最开始想的是直接使用LinkedList，用着用着越不对劲。\n\n用数组重写，重要的就是当前栈顶所在位置的管理。\n\n### 代码\n\n```java\nclass CustomStack {\n    int[] stack;\n    int iPoint;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        iPoint = -1;\n    }\n    \n    public void push(int x) {\n        //如果到了最后\n        if (iPoint == stack.length-1) {\n            return;\n        }\n        //向右偏移一位\n        iPoint++;\n        //存值\n        stack[iPoint] = x;\n    }\n    \n    public int pop() {\n        //栈底\n        if (iPoint == -1) {\n            return iPoint;\n        }\n        --iPoint;\n        //直接返回即可，后面直接覆盖\n        return stack[iPoint + 1];\n    }\n    \n    public void increment(int k, int val) {\n        //影响数量\n        int num = Math.min(k, iPoint + 1);\n        //修改值\n        for (int i = 0; i < num; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n### 时间复杂度\n\npush和pop都是栈顶直接操作，O(1)\n\nincrement遍历的数组O(num),num为临时的空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087376958","body":"### 思路\n\n使用一个LinkedList作为栈，依次遍历S\n\n情况1：数字，如果是数字，有可能接下来几位都是数字，遍历到不是数字为止。\n\n情况2：字母和\"[\",直接入栈即可。\n\n情况3：\"]\",出栈到临时栈，直到出现\"[\"。然后再出一次必定是数字n。把栈转字符串循环n次。然后在放进linkedList。\n\n### 代码\n\n```java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            //如果是数字接下来几位都有可能是数字\n            if (Character.isDigit(cur)) {\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n\n```\n\n### 复杂度分析\n\n时间复杂度：解析后的字符串长度O(n)\n\n空间复杂度：没有多余的空间，存储解析后的字符串长度。O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088657676","body":"### 思路\n\n就有点类似于最开始学编程的时候，两个塔，左边塔321，右边空。然后依次取出放到右边的塔就是123。\n\n### 代码\n\n```java\nimport java.util.LinkedList;\nimport java.util.List;\n\nclass MyQueue {\n\n\n    int head = -1;\n    LinkedList<Integer> result;\n\n    public MyQueue() {\n        result = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        if (result.isEmpty()) {\n            head = x;\n        }\n        LinkedList<Integer> integers = new LinkedList<>();\n        while (!result.isEmpty()) {\n            integers.push(result.pop());\n        }\n        integers.push(x);\n        while (!integers.isEmpty()) {\n            result.push(integers.pop());\n        }\n    }\n\n    public int pop() {\n        int value = result.pop();\n        if (!result.isEmpty()) {\n            head = result.peek();\n        }\n        return value;\n    }\n\n    public int peek() {\n//        不能使用 result.getFirst();\n        return head;\n    }\n\n    public boolean empty() {\n        return result.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n### 复杂度分析\n\n时间复杂度：\n\n1. push:O(n)\n2. pop:O(1)\n3. peek:O(1)\n4. empty:(1)\n\n空间复杂度：\n\n1. push用了额外空间，*O*(*n*)\n2. pop:O(1)\n3. peek:O(1)\n4. empty:(1)\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"judyzhou95":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085515819","body":"```python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        p = len(num) - 1\n        while k:\n            k += num[p]            \n            v = k % 10    \n            num[p] = v\n            \n            k //=10\n            p -= 1\n        \n            if p < 0:\n                break\n        \n        while k:\n            v = k % 10\n            num = [v] + num\n            k //= 10\n        \n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086570363","body":"```python\nclass Solution:\n    def shortestToChar(self, S, C):\n        def letter_get(letter, dr):\n            n = len(S)\n            res, cur = [0]*n, -n\n            for i in range(n)[::dr]:\n                if S[i] == letter: cur = i\n                res[i] = abs(i - cur)\n            return res\n        \n        return [min(x,y) for x,y in zip(letter_get(C, 1), letter_get(C, -1))]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086797319","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.inc = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.inc:\n            return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        \n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:        \n        if self.inc:\n            self.inc[min(k, len(self.inc)) - 1] += val\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087138877","body":"1. recursion\n\n``` python\n\nclass Solution:\n    \n    def decodeString(self, s: str) -> str:  \n        closePos = {}   \n        stack = []\n        for i, c in enumerate(s):\n            if c == '[':\n                stack.append(i)\n            elif c == ']':\n                closePos[stack.pop()] = i\n\n        def solve(l, r):\n            num = 0\n            ans = []\n\n            while l <= r:\n                c = s[l]\n                if c.isdigit():\n                    num = num * 10 + int(c)\n                elif c == '[':\n                    ans.append(num * solve(l + 1, closePos[l] - 1))\n                    num = 0\n                    l = closePos[l]\n                else:\n                    ans.append(c)\n                l += 1\n            return \"\".join(ans)\n        return solve(0, len(s) - 1)\n\n```\n\n2. stack\n\n``` python\nclass Solution:\n    def decodeString(self, s: str) -> str:        \n        stack = []\n        num = 0\n    \n        stack.append(\"\")\n        \n        for c in s:\n            #print(c)\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '[':\n                stack.append(num)\n                num = 0\n                stack.append(\"\")\n            elif c == ']':\n                str2 = stack.pop()\n                n = stack.pop()\n                str1 = stack.pop()                \n                stack.append(str1 + n * str2)                \n                \n            else:               \n                stack[-1] += c\n            \n            #print(tmp)\n            #print(stack)\n        return stack[0]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088258264","body":"### Analysis\nUse two stacks to reverse output order. Only move elements from input stack to output stack when previous elements in output are all popped out. \n### Code\n``` Python\nclass MyQueue:\n\n    def __init__(self):\n        self.input = []\n        self.output = []\n\n    def push(self, x: int) -> None:\n        self.input.append(x)\n    \n    def pop(self) -> int:\n        self.move()\n        return self.output.pop()\n\n    def peek(self) -> int:\n        self.move()\n        return self.output[-1]\n        \n    def empty(self) -> bool:\n        return not self.input and not self.output\n    def move(self):\n        if not self.output:\n            while self.input:\n                self.output.append(self.input.pop())\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### Complexity:\nTime Complexity: O(1) \nSpace Complexity: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085517916","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num[-1] += k\r\n        for i in range(len(num)-1, -1, -1):\r\n            carry, num[i] =divmod(num[i], 10)\r\n            if i:\r\n                num[i-1] += carry \r\n        if carry:\r\n            num = [int(i) for i in str(carry)] + num\r\n        return num\r\n```\r\nspace `O(M+N)` time `O(N)`","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086798751","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.add = []\r\n        self.size = 0\r\n        self.max_size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n            self.add.append(0)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            v = self.stack.pop()\r\n            i = self.add.pop()\r\n            self.size -= 1\r\n            if self.size > 0:\r\n                self.add[-1] += i\r\n            return v+i\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        n = min(k, len(self.stack))\r\n        if n >= 1:\r\n            self.add[n-1] += val\r\n```\r\ntime `O(1)`, space `O(N)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086969087","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c != ']':\r\n                stack.append(c)\r\n            else:\r\n                seg = \"\"\r\n                while True:\r\n                    if stack:\r\n                        val = stack.pop()\r\n                        if val != \"[\":\r\n                            seg += val\r\n                        else:\r\n                            break\r\n                k = \"\"\r\n                while True:\r\n                    if stack and stack[-1] in \"0123456789\":\r\n                        k += stack.pop()\r\n                    else:\r\n                        break\r\n                for i in range(int(k[::-1])):\r\n                    for s in seg[::-1]:\r\n                        stack.append(s)\r\n        return \"\".join(stack)\r\n```\r\ntime `O(N)` space `O(N)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087904031","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        self.push_stack.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        self.peek()\r\n        return self.pop_stack.pop()\r\n        \r\n        \r\n\r\n    def peek(self) -> int:\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack[-1]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        if self.pop_stack or self.push_stack:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\ntime `O(1)` space `O(N)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"davont":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085528745","body":"## 代码\n```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086470126","body":"## 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const sArr = s.split('');\r\n    const keyArr = [];\r\n    const ans = [];\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        const ele = sArr[i];\r\n        if(ele === c){\r\n            keyArr.push(i);\r\n        }\r\n    }\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        const ele = sArr[i];\r\n        let minLen = sArr.length;\r\n        for (let j = 0; j < keyArr.length; j++) {\r\n            const keyEle = keyArr[j];\r\n            minLen = Math.min(minLen,Math.abs(keyEle - i));\r\n        }\r\n        ans.push(minLen);\r\n    }\r\n    return ans;\r\n\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086839680","body":"## 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.length = maxSize;\n  this.stack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.stack.length < this.length) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  return this.stack.pop() || -1;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  for (let i = 0; i < k; i++) {\n    if (!this.stack[i]) {\n      break;\n    }\n    this.stack[i] += val;\n  }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087183681","body":"## code\n```js\nvar decodeString = function(s) {\n    const stack = [];\n    const strArr = s.split('');\n    while(strArr.length){\n        if (strArr[strArr.length-1] !== '[') {\n            stack.push(strArr.pop());\n        }else {\n            strArr.pop() // 去除 '['\n            let num = '';\n            while(!Number.isNaN(Number(strArr[strArr.length-1]))){\n                num = strArr.pop() + num;\n            }\n            let str = '';\n            while(stack[stack.length-1] !== ']'){\n                str = str + stack.pop();\n            }\n            stack.pop() // 去除 ']'\n            stack.push(str.repeat(Number(num)));\n        }\n    }\n    return stack.reverse().join('');\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088634322","body":"## code\n\n```js\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085530541","body":"## 思路\n1. 比较intuitive的想法就是先转换成字符串-> 数字+k ->字符串 \n2.  \n## 代码\n1. \n’‘’\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n                \n        int_str = ''\n\n        for i in num:\n            int_str += str(i)\n        \n        int_str = str(int(int_str) + k)\n\n        res=[int(i) for i in int_str]\n\n        return res\n‘’‘\n## 复杂度分析\n1. Time complexity: On; Space complexity On.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086603805","body":"## 思路\n先建造一个index list 存储target character相应的index\n\n在用index list 里面的值分别减去字符串单个的index，取最小值\n\n## 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        index = [i for i, j in enumerate(s) if j==c]\n\n        result = []\n        for i in range(len(s)):\n            a=[]\n            for ind in index:\n                b = abs(ind - i)\n                a.append(b)\n            min_num = min(a)\n            result.append(min_num)\n\n        return result\n\n```\n\n## 复杂度分析\n时间：最差On^2, 正常O(mn)    m 为index list 长度(最差m=n)  \\\n空间： On, index list 的worst case, On, result index 也是On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086742469","body":"## 思路一：暴力求解\n\n## 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack= []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.stack))):\n            stack[i] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 复杂度分析\nTIME COMPLEXITY:  push 和 pop 都为O(1)，increment 为O(k),最差为O1 \\\nSPACE COMPLEXITY: O(maxSize)\n\n## 思路二：优化思路一的increment\n这里是参考了答案和评论区\n## 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack= []\n        self.max_size = maxSize\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        if len(self.inc)>1:\n            self.inc[-2] +=self.inc[-1]\n           \n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k,len(self.inc))-1] += val\n```\n## 复杂度分析\nTIME COMPLEXITY: 都为O1 \\\nSPACE COMPLEXITY:  O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086937390","body":"## 思路 使用Stack和匹配括号的思想\npush value 进stack 直到碰到 ']', pop出value 进行相应数字的操作\n需要注意k的大小，不一定是个位数\n\n主要是string的需要很多细节处理，append pop出来的值什么时候需要reverse，pop出来的数字是以string形式出现，怎么转换成数字，reversed 不能和数字直接相乘，需要‘’。join()等等\n## 代码\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n\n        for char in s:\n            if char !=']':\n                stack.append(char)\n                continue\n\n            string = []\n            # 把 需要重复的值 pop出来，这个while循环结束之后stack.peek()是'['\n            while stack and stack[-1]!='[':\n                string.append(stack.pop())\n\n            # 去掉 '['    \n            stack.pop()\n\n\n            #这里我们要考虑k的值是多位数的情况, 第一个pop出来的的是个位数，再是十位数，百位数\n            #用repeat记录最终要repeat的次数\n            #用base记录有几位数，第一个数字 + 10 * 第二个数字 + 100* 第三个数字.....\n            repeat = 0\n            base = 1\n\n\n            #stack.pop()出来是数字的string形式，所以用ord()方法得到相应的数字\n            # ‘’join() 之后才能以string的形式进行运算\n            while stack and stack[-1].isdigit():\n                repeat = repeat + (ord(stack.pop())-ord('0')) * base\n                base = base * 10\n            stack.append(''.join(reversed(string))*repeat)\n\n            #现在得到的stack是 分开的 string element 例如 ['aaa', 'bcbc']\n\n\n        return ''.join(stack)\n        \n```\n## 复杂度分析\n不怎么会算复杂度，这里猜的 \\\n时间：O(n)\\\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087948715","body":"## 思路：第一次只用了一个stack，不符合题目要求两个stack\n还是先把想法留下\n\n## 代码\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.queue = []\n\n    def push(self, x: int) -> None:\n        self.queue.append(x)\n\n    def pop(self) -> int:\n        return self.queue.pop(0)\n\n    def peek(self) -> int:\n        return self.queue[0]\n\n    def empty(self) -> bool:\n        return self.queue ==[]\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n\n## 思路二：两个stack\noutqueue stack 直接 append inqueue pop 出来的值\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.inqueue = []\n        self.outqueue =[]\n\n    def push(self, x: int) -> None:\n        self.inqueue.append(x)\n        self.outqueue.append(self.inqueue.pop())\n\n    def pop(self) -> int:\n        return self.outqueue.pop(0)\n\n    def peek(self) -> int:\n        return self.outqueue[0]\n\n\n    def empty(self) -> bool:\n        return (not self.inqueue) and (not self.outqueue)\n        \n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n## 复杂度分析 \n时间：\\\nPush - On \\\nPop - On \\\nPeek - O1 \\\nempty -O1 \\\n空间： \\\nPush - On \\\nPop - O1 \\\nPeek - O1 \\\nempty -O1 ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuyingliu2021":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085533007","body":"三种方法\n```\n暴力\n时间复杂度O(n)\n空间复杂度O(n)\n先把k转为字符串 然后转成int 和k相加再慢慢转回来\n```\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        return list(map(int,str(int(''.join(map(str,num))) + k)))\n```\n\n```\n模拟\n时间复杂度O(n)\n空间复杂度O(n)\n模板真好用hh\n```\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        lstk = list(int(i) for i in str(k))\n        i = len(num) -1\n        j = len(lstk) -1\n        carry = 0\n        \n        res = []\n        while i >=0 or j >=0:\n            x = num[i] if i >=0 else 0\n            y = lstk[j] if j >=0 else 0\n            \n            sum = x + y + carry  \n            \n            keep = sum % 10\n            carry = sum // 10\n    \n            res.append(keep)\n               \n            i = i -1\n            j = j -1\n            \n        if carry != 0:\n            res.append(carry)\n        return res[::-1]\n```\n\n```\n把k加进去 这个和模拟差不多 \n看了别人的答案 感觉也不错\n```\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k:\n                num.insert(0,0)\n                i = 0\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086542553","body":"两种方法\r\n```\r\n暴力\r\n把s中和c相等的index取出来 之后一个个和s中的index相减 max(abs(差))\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n```\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        lst = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                lst.append(i)\r\n        res= []\r\n        for i in range(len(s)):\r\n            dis = [] \r\n            for j in lst:\r\n                dis.append(abs(i-j))\r\n            res.append(min(dis)) \r\n        return res \r\n```\r\n\r\n```\r\n一个指针\r\n当满足两个条件p+=1\r\n1. p还没有走完\r\n2. i 到  p 的绝对距离 > 到p + 1的绝对距离\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n\r\n```\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        p = 0\r\n        lst = list(i for i in range(len(s)) if s[i] == c)\r\n\r\n        for i, j in enumerate(s):\r\n            if p < len(lst) -1 and abs(lst[p] -i) > abs((lst[p+1]) -i):\r\n                p+=1\r\n            res.append(abs(lst[p]-i))\r\n            \r\n        return res\r\n        \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086744260","body":"```\r\n时间复杂度：O(1)\r\n空间复杂度：O(maxSize)\r\n```\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.length = 0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.length < self.maxSize:\r\n            self.stack.append(x)\r\n            self.length +=1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.length == 0:\r\n            return -1\r\n        else:\r\n            self.length -= 1\r\n            return self.stack.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.length)):\r\n            self.stack[i] += val\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087213701","body":"```\r\n#时间复杂度 O(N)\r\n#空间复杂度 O(N)\r\n```\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        #注意可能有嵌套的中括号\r\n        stack = []\r\n        res = \"\"\r\n        mul = 0\r\n        \r\n        for ch in s:\r\n            if ch == \"[\":\r\n                stack.append([mul, res])\r\n                mul, res = 0, \"\"\r\n            elif ch == \"]\":\r\n                cur_mul, last_res = stack.pop()\r\n                res = last_res + cur_mul *res\r\n            elif \"0\" <= ch <= \"9\":\r\n                mul = mul * 10 + int(ch)\r\n            else:\r\n                res += ch\r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088171826","body":"```\r\n时间复杂度:  O(N)\r\n空间复杂度:  O(N)\r\n```\r\n```\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.outstack) == 0:\r\n            while len(self.instack) !=0:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack.pop()\r\n            \r\n    def peek(self) -> int:\r\n        if len(self.outstack) == 0:\r\n            while len(self.instack) !=0:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack[-1]\r\n        \r\n    def empty(self) -> bool:\r\n        if len(self.instack) == 0 and len(self.outstack) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"futurefields":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085538554","body":"Idea:high precision addition\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n    reverse(num.begin(), num.end());\n        for(auto&t : num){\n            k+= t;\n            t= k % 10;\n            k/= 10;\n        }\n        while(k) num.push_back(k % 10), k/= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\nSpace O(n) Time O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086576973","body":"Idea: scan from left to right, and reverse\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> answer(s.size());\r\n        int prev = -100000;\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) {\r\n                prev = i;\r\n            }\r\n            answer[i] = i - prev;\r\n        }\r\n        prev = 20000;\r\n        for (int i = s.size() - 1; i >= 0; i--) {\r\n            if (s[i] == c){\r\n                prev = i;\r\n            }\r\n            answer[i] = min(answer[i], prev - i);\r\n        }\r\n        return answer;\r\n    }\r\n};\r\n\r\nspace O(N), time O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087047463","body":"Idea: Stack\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        int len = s.size();\r\n        int num = 0;\r\n        stack<int> numstack;\r\n        stack<string> strstack;\r\n        string cur = \"\";\r\n        string result = \"\";\r\n        for(int i=0; i<len; ++i)\r\n        {\r\n            if(s[i]>='0' && s[i]<='9')\r\n            {\r\n                num = 10*num + s[i] - '0';\r\n            }\r\n            else if(s[i] == '[')\r\n            {\r\n                numstack.push(num);\r\n                strstack.push(cur);\r\n                num = 0;\r\n                cur.clear();\r\n            }\r\n            else if((s[i]>='a' && s[i]<='z') || (s[i]>='A' && s[i]<='Z'))\r\n                cur += s[i];\r\n            else if(s[i] == ']')\r\n            {\r\n                int k = numstack.top();\r\n                numstack.pop();\r\n                for(int j=0; j<k; ++j)\r\n                    strstack.top() += cur;\r\n                cur = strstack.top();\r\n                strstack.pop();\r\n            }\r\n        }\r\n        result = result + cur;\r\n        return result;     \r\n    }\r\n};\r\nSpace: O(n), Time: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088206006","body":"Idea: Stack push and pop\r\n\r\n\r\nclass MyQueue {\r\n    private:\r\n    stack<int> a;\r\n    stack<int> b;\r\npublic:\r\n    MyQueue() {\r\n    }\r\n   void push(int x) {\r\n        a.push(x);\r\n    }\r\n    int pop() {\r\n        int num = 0;\r\n        if (b.empty())\r\n        {\r\n            while(!a.empty())\r\n            {\r\n                b.push(a.top());\r\n                a.pop();\r\n            }\r\n        }\r\n        if (!b.empty())\r\n        {\r\n            num = b.top();\r\n            b.pop();\r\n        }\r\n        return num;\r\n    }    \r\n int peek() {\r\n        int num = 0;\r\n        if (b.empty())\r\n        {\r\n            while(!a.empty())\r\n            {\r\n                b.push(a.top());\r\n                a.pop();\r\n            }\r\n        }\r\n        if (!b.empty())\r\n            num = b.top();\r\n         return num;\r\n    }  \r\nbool empty() {\r\n        if (a.empty() && b.empty())\r\n            return true;\r\n        return false;\r\n    }\r\n};\r\n\r\nspace: O(1), time: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwang4768":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085550862","body":"***Idea***  \nTo convert the int k to string, and then can leverage math functions to add. Finally converting the result back to list. However this is very brute force. \n\n***Code***\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        numInt = int(''.join((str(i) for i in num)))\n       \n        temp = numInt + k\n        result = [int(j) for j in str(temp)]\n        \n        return result\n```\n\n***Complexity***  \nTime: O(n)  \nMemory usage: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665384","body":"***Idea***\n1) Loop through the string s and note down and note down the index of occurance of target char c \n2) Loop through s and array of all c occurance index again, create a temp int that stores the distance between current digit and each c occurance. If there is a shorter distance, update temp ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088816676","body":"***Idea***  \nTo use the two helper functions to implement pop() and push()\n\n***Code***  \n\n***Complexity***  \nTime complexity:   \nMemory complexity","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085553826","body":"- ### 思路\n\t- 将数组转换成字符串，然后转换成整数\n\t- 然后做加法\n\t- 然后再将结果转换成数组\n- ### Code\n\t  ```python\t  \t  \n              class Solution:\n\t  \t      def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t  \t          str1 = ''.join([str(x) for x in num])\n\t  \t          number = int(str1)\n\t  \t          newNumber = number + k\n\t  \t          newList = list(map(int,str(newNumber)))\n\t  \t          return newList\n\t  ```\n- ### 复杂度\n\t- 时间复杂度 O(n)\n\t- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086648516","body":"- Name: Leetcode No.821 字符的最短距离\n- ### 题目描述\n  ```\n  对给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n  \n  返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n  \n  两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n  \n  \n  示例 1：\n  输入：s = \"loveleetcode\", c = \"e\"\n  输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n  解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n  距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n  距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n  对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n  距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n  \n  \n  示例 2：\n  输入：s = \"aaab\", c = \"b\"\n  输出：[3,2,1,0]\n  \n  提示：\n  \t1 <= s.length <= 104\n  \ts[i] 和 c 均为小写英文字母\t\n  \t题目数据保证 c 在 s 中至少出现一次\n  ```\n- ### 思路\n\t- 遍历字符串，双指针，同时计算正反两个方向的字符的距离\n\t- 然后将得到的两个数组，对应位置进行比较，选择小的留下来\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**字符的遍历**。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def shortestToChar(self, s: str, c: str) -> List[int]:\n\t  \t          prev1, prev2 = 2*len(s), 2*len(s)\n\t  \t          ans1,ans2 = [len(s)]*len(s), [len(s)]*len(s)\n\t  \t          j = len(s)-1\n\t  \t          for i in range(len(s)):\n\t  \t              if s[i] == c:\n\t  \t                  prev1 = i\n\t  \t              ans1[i] = abs(i - prev1)\n\t  \t              if s[j] == c:\n\t  \t                  prev2 = j\n\t  \t              ans2[j] = abs(j - prev2)\n\t  \t              j -= 1\n\t  \t          for i in range(len(s)):\n\t  \t              ans1[i] = min(ans1[i],ans2[i])\n\t  \t          return ans1\n\t  ```\n- ### 复杂度\n\t- 时间复杂度 $O(n)$\n\t- 空间复杂度 $O(n)$\n- ### 知识汇总\n\t- #### `min`\n\t\t- min选两个数中小的","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086830285","body":"- ### 题目描述\n- 请你设计一个支持下述操作的栈。\n 实现自定义栈类`CustomStack`  ：\n `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\n  `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 x 添加到栈顶。\n  `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n  `void inc(int k, int val)`：栈底的 k 个元素的值都增加 `val` 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 `val` 。\n 请你设计一个支持下述操作的栈。\n    \n  实现自定义栈类 CustomStack ：\n    \n  CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\n  void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\n  int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n  void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n    \n    \n  示例 1：\n  输入：\n  [\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n  [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n  输出：\n  [null,null,null,2,null,null,null,null,null,103,202,201,-1]\n  解释：\n  - CustomStack customStack = new CustomStack(3); // 栈是空的 []\n  - customStack.push(1);                          // 栈变为 [1]\n  - customStack.push(2);                          // 栈变为 [1, 2]\n  - customStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\n  - customStack.push(2);                          // 栈变为 [1, 2]\n  - customStack.push(3);                          // 栈变为 [1, 2, 3]\n  - customStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\n  - customStack.increment(5, 100);                // 栈变为 [101, 102, 103]\n  - customStack.increment(2, 100);                // 栈变为 [201, 202, 103]\n  - customStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\n  - customStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\n  - customStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\n  - customStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n    \n    \n    \n  提示：\n  1 <= maxSize <= 1000;\n  1 <= x <= 1000;\n  1 <= k <= 1000;\n  0 <= val <= 100;\n  每种方法 increment，push 以及 pop 分别最多调用 1000 次\n- ### 思路\n\t- 设计初始函数，传入所需的变量数组的`maxSize`\n\t- 然后写入入栈，出栈，对栈中元素进行操作的函数\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**栈**这种数据结构的相关概念。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class CustomStack:\n\t  \t  \n\t  \t      def __init__(self, maxSize: int):\n\t  \t          self.maxSize = maxSize\n\t  \t          self.customStack = []\n\t  \t  \n\t  \t      def push(self, x: int) -> None:\n\t  \t          if len(self.customStack) < self.maxSize:\n\t  \t              self.customStack.append(x)\n\t  \t  \n\t  \t      def pop(self) -> int:\n\t  \t          if self.customStack == []:\n\t  \t              return -1\n\t  \t          else:\n\t  \t              return self.customStack.pop(-1)\n\t  \t  \n\t  \t      def increment(self, k: int, val: int) -> None:\n\t  \t          for i in range(min(len(self.customStack), k)):\n\t  \t              self.customStack[i] += val\n\t  \t  \n\t  \t  \n\t  \t  \n\t  \t  # Your CustomStack object will be instantiated and called as such:\n\t  \t  # obj = CustomStack(maxSize)\n\t  \t  # obj.push(x)\n\t  \t  # param_2 = obj.pop()\n\t  \t  # obj.increment(k,val)\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: `push`: O(1); `pop`: O(1); `increment`: $O(min(k, maxSize))$\n\t- 空间复杂度 $O(maxSize)$ 我们产生了一个额外的 $maxSize$ 维的空间\n- ### 知识汇总\n\t- #### `类`\n\t\t- 类是抽象的概念，是一类东西的抽象化表述\n\t\t- 类的具体化实例化就是具体对象\n\t\t- 实例化对象可以调用类中所有函数\n\t\t- 在类中还有一个初始化函数，将一些特殊的属性值（变量），传入类","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087717362","body":"- ### 题目描述\n\t- 给定一个经过编码的字符串，返回它解码后的字符串。\n\t  编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n\t  你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n\t  此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n- ### 思路\n\t- 在字符串编码的过程中因为[]中的运算是先算里后外，也就是先进去的后出来。因此，可以利用**栈**这种数据结构。\n\t- 题目中的字符串，可以分成四种类型：数字，左中括号, 右中括号，字母\n\t- 遍历字符串\n\t\t- 如果字母存在临时变量res中\n\t\t- 数字存在Multi变量中\n\t\t- 如果遇到左中括号，将Multi和res入栈\n\t\t- 如果遇到右中括号，将顶端的数据出栈\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**栈-先入后出**，**子组合-递归**。\n- ### Code\n\t\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def decodeString(self, s: str) -> str:\n\t  \t          stack, res, multi = [], \"\", 0\n\t  \t          for c in s:\n\t  \t              if c == '[':\n\t  \t                  stack.append([multi, res])\n\t  \t                  res, multi = \"\", 0\n\t  \t              elif c == ']':\n\t  \t                  cur_multi, last_res = stack.pop()\n\t  \t                  res = last_res + cur_multi * res\n\t  \t              elif '0' <= c <= '9':\n\t  \t                  multi = multi * 10 + int(c)            \n\t  \t              else:\n\t  \t                  res += c\n\t  \t          return res\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n)$\n\t- 空间复杂度 $O(n)$\n- ### 知识汇总\n\t- #### `栈`\n\t\t- 栈是实现深度遍历的基础，栈在实例中有很多应用：\n\t\t\t- 函数调用栈\n\t\t\t- 浏览器前进后退\n\t\t\t- 匹配括号\n\t\t\t- 单调栈用来寻找下一个更大（更小）元素 推荐题目：Every-Sublist-Min-Sum","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088903262","body":"- ### 题目描述\n\t- 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\t  实现 MyQueue 类：\n\t  void push(int x) 将元素 x 推到队列的末尾\n\t  int pop() 从队列的开头移除并返回元素\n\t  int peek() 返回队列开头的元素\n\t  boolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n\t  说明：\n\t  你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n\t  你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n- ### 思路\n\t- 这个题必修要用两个栈，来构造一个队列的结构。\n\t- 想法就是将第一个栈，出栈进入到第二个栈。这样的话第一个栈的栈顶就变成了第二个栈的栈底，此时，我们让第二个栈的数据出栈，就能达到整体数据先进先出的效果。\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**栈-先入后出**，**队列-先进先出**。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class MyQueue:\n\t  \t  \n\t  \t      def __init__(self):\n\t  \t          self.stack1 = []\n\t  \t          self.stack2 = []\n\t  \t  \n\t  \t      def push(self, x: int) -> None:\n\t  \t          self.stack1.append(x)\n\t  \t  \n\t  \t      def pop(self) -> int:\n\t  \t          if len(self.stack2) == 0:\n\t  \t              for i in range(len(self.stack1)):\n\t  \t                  self.stack2.append(self.stack1.pop(-1))\n\t  \t          pop_number = self.stack2.pop(-1)\n\t  \t          return pop_number\n\t  \t  \n\t  \t      def peek(self) -> int:\n\t  \t          if len(self.stack2) == 0:\n\t  \t              for i in range(len(self.stack1)):\n\t  \t                  self.stack2.append(self.stack1.pop(-1))\n\t  \t          peek_number = self.stack2[-1]\n\t  \t          return peek_number\n\t  \t  \n\t  \t      def empty(self) -> bool:\n\t  \t          return  len(self.stack1)==0 and len(self.stack2)==0\n\t  \t  \n\t  \t  \n\t  \t  \n\t  \t  # Your MyQueue object will be instantiated and called as such:\n\t  \t  # obj = MyQueue()\n\t  \t  # obj.push(x)\n\t  \t  # param_2 = obj.pop()\n\t  \t  # param_3 = obj.peek()\n\t  \t  # param_4 = obj.empty()\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(2n)$ ，n是push的次数\n\t- 空间复杂度 $O(2n)$\n- ### 知识汇总\n\t- #### `栈`\n\t\t- 栈是实现深度遍历的基础\n\t\t\t- 函数调用栈\n\t\t\t- 浏览器前进后退\n\t\t\t- 匹配括号\n\t\t\t- 单调栈用来寻找下一个更大（更小）元素 推荐题目：Every-Sublist-Min-Sum\n\t\t- 对栈的操作\n\t\t\t- push\n\t\t\t- pop\n\t\t\t- top\n\t\t\t- 读取栈内元素","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo660":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085579178","body":"* ### 思路\n\n最开始想着将num数组变为数字，再加K，但是数组的长度最大为1w，变量接收不了这么大的数。\n\n最后用数组从后向前遍历，加上k的值，注意进位与整除。\n\n* ### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        for (int i=num.size()-1; i>=0 ;i--){\n            int temp = 0;\n            temp = (num[i] + k)%10;\n            k = (num[i] + k)/10;\n            res.insert(res.begin(), temp);\n        }\n        while (0 != k){\n            res.insert(res.begin(), k%10);\n            k /= 10;\n        }\n        return res;\n    }\n};\n```\n\n* ### 复杂度\n    * 时间复杂度O(max(n,c)) n为num的长度，c为k的位数\n    * 空间复杂度O(max(n,c)) n为num的长度，c为k的位数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086519518","body":"### 思路\n先从左向右遍历，再从右向左遍历取最小值\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> answer(s.size());\n        int pre = INT32_MIN/2;\n        for (int i = 0; i < s.size() ; i++){\n            if (s[i] == c) pre = i;\n            answer[i] = i - pre;\n        }\n        pre = INT32_MAX;\n        for (int i = s.size()-1 ; i >= 0 ; i--){\n            if (s[i] == c) pre = i;\n            if (answer[i] > (pre - i))\n                answer[i] = pre - i;\n        }\n        return answer;\n    }\n};\n```\n### 复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086890399","body":"```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        top = maxSize;\r\n        now = -1;\r\n    }\r\n\r\n    void push(int x) {\r\n        if (now < top-1){\r\n            ++now;\r\n            stack[now] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (-1 == now) return -1;\r\n        int popNum = stack[now];\r\n        --now;\r\n        return popNum;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k, now+1);\r\n        for (int i = 0; i < k; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\nprivate:\r\n    vector<int> stack;\r\n    int top;\r\n    int now;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087652562","body":"### 思路\n递归\n\n### 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string r;\n        for (int i = 0; i < s.size(); i++){\n            int move = 0;\n            if (isdigit(s[i])){\n                i += cString(&s[i],r);\n            }else if(']' != s[i]){\n                r.push_back(s[i]);\n            }\n        }\n        return r;\n    }\n\n    int cString(string s, string &r){\n        int count = 0;\n        int num = 0;\n        int renum = 0;\n        while (isdigit(s[count])){\n            num = num*10 + (s[count] - '0');\n            count++;\n        }\n        count++;//'['计数加一\n        for (int i = 0; i < num; i++){\n            renum = count;\n            while (']' != s[renum]){\n                if (isdigit(s[renum])) {\n                    renum += cString(&s[renum],r);\n                }else{\n                    r.push_back(s[renum]);\n                }\n                renum++;\n            }\n        }\n        return renum;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088806024","body":"### 思路\r\n使用两个栈，一个进栈一个出栈，push时直接放入进栈，pop时若出栈为空，就将进栈全部push进入出栈。\r\n\r\n### 代码\r\n```c++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> stkin,stkout;\r\n    void in2out(){\r\n        while (!stkin.empty())\r\n        {\r\n            int a = stkin.top();\r\n            stkout.push(a);\r\n            stkin.pop();\r\n        }\r\n    }\r\npublic:\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        stkin.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        int topNum = 0;\r\n        if (stkout.empty()) in2out();\r\n        topNum = stkout.top();\r\n        stkout.pop();\r\n        return topNum;\r\n    }\r\n    \r\n    int peek() {\r\n        int topNum = 0;\r\n        if (stkout.empty()) in2out();\r\n        topNum = stkout.top();\r\n        return topNum;\r\n    }\r\n    \r\n    bool empty() {\r\n        return ((stkin.empty()) & (stkout.empty()));\r\n    }\r\n};\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085584434","body":"## 思路\n将数组转换成整数，然后与整数K做加法，之后再转换成数组返回\n## 代码\nclass Solution:\n    def add_array_with_num(self, num: List[int], k: int) -> List[int]:\n        sum = 0\n        digit = 1\n        for i in range(len(num)-1, -1, -1):\n            sum += num[i]*digit\n            digit *= 10\n        sum += k\n        result = [0]*len(str(sum))\n        for i in range(len(result)-1, -1, -1):\n            result[i] = sum % 10\n            sum //= 10\n        return result\n## 复杂度分析\n空间复杂度：O(N) 时间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086566322","body":"```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        Stack<Integer> stack = new Stack<>();\n        int[] ans = new int[s.length()];\n        int pre = - 1;\n        for (int i = 0 ; i < s.length(); i ++) {\n            if (s.charAt(i) == c) {\n                while (!stack.isEmpty() && s.charAt(stack.peek()) != c) {\n                    int p = stack.pop();\n                    ans[p] = pre >= 0 ? Math.min(Math.abs(p - i) , Math.abs(p - pre)) : Math.abs(p - i);\n                }\n                pre = i;\n            }\n            stack.push(i);\n        }\n        while (!stack.isEmpty()) {\n            int p = stack.pop();\n            ans[p] = s.charAt(p) == c ? 0 : Math.abs(p - pre);\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085594873","body":"```\r\nimport java.util.*;\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n      List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum =sum% 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n空间复杂度：O(N) 时间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087227648","body":"```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n         String res = \"\";\r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resStack = new Stack<>();\r\n        int idx = 0;\r\n        while (idx < s.length()) {\r\n            if (Character.isDigit(s.charAt(idx))) {\r\n                int count = 0;\r\n                while (Character.isDigit(s.charAt(idx))) {\r\n                    count = 10 * count + (s.charAt(idx) - '0');\r\n                    idx++;\r\n                }\r\n                countStack.push(count);\r\n            }\r\n            else if (s.charAt(idx) == '[') {\r\n                resStack.push(res);\r\n                res = \"\";\r\n                idx++;\r\n            }\r\n            else if (s.charAt(idx) == ']') {\r\n                StringBuilder temp = new StringBuilder (resStack.pop());\r\n                int repeatTimes = countStack.pop();\r\n                for (int i = 0; i < repeatTimes; i++) {\r\n                    temp.append(res);\r\n                }\r\n                res = temp.toString();\r\n                idx++;\r\n            }\r\n            else {\r\n                res += s.charAt(idx++);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088300622","body":"```\r\nclass MyQueue {\r\n    private Stack<Integer> s1 = new Stack<>();\r\n    private Stack<Integer> s2 = new Stack<>();\r\n\r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        while (!s2.isEmpty()) {\r\n            s1.push(s2.pop());\r\n        }\r\n        s1.push(x);           \r\n    }\r\n    \r\n    public int pop() {   \r\n        while (!s1.isEmpty()) {\r\n       s2.push(s1.pop());\r\n       }\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        while(!s1.empty())\r\n       { s2.push(s1.pop());} \r\n        \r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s2.empty()&&s1.empty();\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wychmod":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085602602","body":"### 思路\n大体上是先将数组遍历一遍，将其转换为数字，然后与k相加，再将数字转换为数组\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sum = ''.join([str(n) for i, n in enumerate(num)])\n        sum = int(sum) + k\n        return [int(i) for i in str(sum)]\n```\n### 时间复杂度\n空间复杂度：O(n) 在将数字转换为数组的时候创建了数组\n\n时间复杂度：O(n) 遍历了有限次的数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086544108","body":"### 思路\n（比较暴力）先把所有的e找出来下标放入数组中，然后将原数组的每一个点与所有e的下标对比取最小的那个。\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        el = []\n        for i, n in enumerate(s):\n            if n == c:\n                el.append(i)\n        res = [0]*len(s)\n        for i in range(len(s)):\n            less = abs(i-el[0])\n            for j in el:\n                less = min(abs(i-j), less)\n            res[i] = less\n        return res\n```\n### 复杂度分析\n时间复杂度：O(n*目标字符在数组中出现的次数)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086888495","body":"### 思路\n数组进行模拟，同时设置两个变量当前长度（不设也行）和最大长度，然后数组天生有pop函数\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.length = 0\n        self.maxSize = maxSize\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        if self.length < self.maxSize:\n            self.stack.append(x)\n            self.length += 1\n\n\n    def pop(self) -> int:\n        if self.length > 0:\n            self.length -= 1\n            return self.stack.pop()\n        return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        k = min(self.length, k)\n        for i in range(k):\n            self.stack[i] += val\n```\n### 复杂度分析\n时间复杂度：push O1 popO1 incOk\n\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087070949","body":"### 思路\n使用栈来进行括号匹配，遇到右括号将数字字母弹出，然后形成字符串，然后重新入栈。\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = ''\n        for i in s:\n            if i == ']':\n                tmp = stack.pop()\n                sem = ''\n                while tmp != '[':\n                    sem = tmp + sem\n                    tmp = stack.pop()\n                \n                num = ''\n                while stack and stack[-1].isdigit():\n                     tmp = stack.pop()\n                     num = tmp + num\n\n                res = int(num) * sem\n                stack.append(res)\n                \n            else:\n                stack.append(i)\n\n        return ''.join(stack)\n```\n### 复杂度分析\n时间复杂度：On\n\n空间复杂度：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088196794","body":"### 思路\n两个栈来回倒\n### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        self.stack2 = self.stack1[::-1]\n        res = self.stack2.pop()\n        self.stack1 = self.stack2[::-1]\n        return res\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack1[0]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return True if len(self.stack1) == 0 else False\n```\n### 复杂度分析\n时间复杂度pop On 其他O1\n空间复杂度 On\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085608090","body":"\n### 题目：\n\n【Day 1】989. 数组形式的整数加法 \n\n[力扣地址：989](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 思路：\n\n用的 python 语言\n\n- 用 c 作为进位记录值，用当前的 num 作为结果数组\n- 当 num 和 k 都没有结束的时候，进行 num[i] + 个位数 + 进位值\n- 当 k 没有结束的时候，进行将 k 剩下的转为 数组进行想加\n- 当 num 没有结束的时候，将当前的 i 和进位值加起来然后前面数组保留\n- 当 进位值 还未归 0 的时候，将 进位值增加到 数组最前面\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        c = 0  #进位\n        i = len(num) - 1 #数组位置\n\n       # 当num没结束 and k 没结束\n        while(k and i > -1):\n            n = num[i] + (k % 10) + c \n            k //= 10\n            c = n // 10\n            num[i] = n % 10\n            i = i - 1\n        \n        # 当 k 没有结束的时候\n        while(k): \n            num = [(k % 10 +c)%10] + num \n            c = (k % 10 +c) // 10   \n            k = k // 10 \n           \n        # 当 数组没有结束的时候\n        while(i > -1):\n            n = c + num[i]\n            c = n // 10\n            num[i] = n % 10\n            i = i - 1  \n        # 当进位没有结束的时候\n        while(c):\n            num = [c] + num \n            c = 0\n\n        return num\n```\n\n\n\n### 时间复杂度：O（N）\n\n### 空间复杂度：O（N）\n\n反思：我可太笨了，思维不够缜密，最终还是写出垃圾冗长的代码，还得再学习一下...","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665920","body":"### 题目：【Day 2】821. 字符的最短距离\n[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n### 思路1\n1. 新建列表存放字符 c 存在的位置\n2. 在 result 列表中，存放两次循环找出的最小 diff 距离\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        L = []\n        result = []\n        for i in range(len(s)):\n            if s[i] == c:\n                L.append(i)\n        for i in range(len(s)):\n            diff = 10000\n            for j in L:\n                if (abs(j - i)) < diff:\n                    diff = abs(j - i)\n            result.append(diff)\n        return result\n```\n### 复杂度\n时间复杂度：O(N^2)\n空间复杂度：O(N)\n\n\n### 思路2\n1. 循环找到字符 c 存在的位置\n2. 前后循环找到最短的距离\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        result = [99999 for i in s]\n        n = len(s)\n        for i in range(n):\n            if s[i] != c:\n                continue\n            result[i] = 0\n            for j in range(i-1, -1, -1):\n                if s[j] == c:\n                    result[j] = 0\n                    break\n                result[j] = min(abs(i-j), result[j])\n            if i == n-1:\n                break\n            for j in range(i+1, n):\n                if s[j] == c:\n                    result[j] = 0\n                    break\n                result[j] = min(abs(i-j), result[j])\n        return result\n```\n\n### 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086780406","body":"### 题目：【Day 3】1381. 设计一个支持增量操作的栈\n\n[1381.设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n### 思路：\n\n用列表模拟栈的操作\n\n### 代码：\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.L = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if(len(self.L)<self.maxSize):\n            self.L.append(x)\n\n    def pop(self) -> int:\n        if(len(self.L) > 0):\n            return self.L.pop(-1)\n        else:\n            return -1\n        \n            \n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i >= len(self.L):\n                break\n            self.L[i] += val\n```\n\n### 复杂度\n\n时间复杂度：O(N)  主要是在 increment()中用了一次循环\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087676518","body":"### 394.字符串的解码\n\n[394.字符串的解码](https://leetcode-cn.com/problems/decode-string/)\n\n### 思路\n\n用栈来模拟，首先除了 ] 都全部入栈，遇到 ] ，查找直到 [ ，之间需要重复的字符串，然后进行重复，重复变量 k（此处有坑，数字不一定是个位数）。\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = []\n        for i in s:\n            if i == ']':\n                # 重复的字符串\n                s = ''\n                # 重复变量\n                k = '' \n                while(res[-1] != '['):\n                    s = res.pop() + s\n                res.pop()\n                while(res and res[-1].isdigit()):\n                    k = res.pop() + k\n                res.append(int(k) * s) #此处有坑\n                continue\n            res.append(i)\n        return ''.join(res)\n     \n```\n\n\n\n### 复杂度\n\n时间复杂度：O(N) 遍历一遍，但是里面重复次数的时间不太确定\n\n空间复杂度：O(N) 列表\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088738141","body":"### 232. 用栈实现队列\n\n[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n### 思路\n\n用列表模拟栈，再模拟队列\n\n### 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.L = []\n\n    def push(self, x: int) -> None:\n        self.L.append(x)\n\n    def pop(self) -> int:\n        print(self.L)\n        return self.L.pop(0)\n\n    def peek(self) -> int:\n        return self.L[0]\n\n\n    def empty(self) -> bool:\n        if(len(self.L) == 0):\n            return True\n        else:\n            return False\n\n```\n\n\n\n### 复杂度\n\n时间：O(1)\n\n空间：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tensorstart":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085612304","body":"### 思路\n类似于第二题，按位倒叙相加，注意进位\n\n### 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    res=[];\n    l=num.length;\n    for (let i = l-1; i >=0 ; i--) {\n        let pos_num=0;\n        pos_num=num[i]+k%10;\n        k=Math.floor(k/10);\n        if (pos_num>=10){\n            pos_num-=10;\n            k+=1;\n        }\n        res.push(pos_num);\n    }\n    while (k){\n        res.push(k%10);\n        k=Math.floor(k/10);\n    }\n    res.reverse();\n    return res;\n};\n\n```\n**复杂度分析**\n- 时间复杂度：$O(k,n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086664861","body":"### 思路\n用的双指针循环部分有待优化\n### 代码\n\n\n```javascript\n\nvar shortestToChar = function(s, c) {\n    const res=[];\n    let l=0,r=0,pos=0;\n    let length=s.length;\n    for (let i = 0; i < length; i++) {\n        let array_abs=0;\n        l=r=pos=i;\n        for (let j = r; j < length; j++) {\n            if (s[j]===c) {\n                r=j;\n                break;\n            }\n        }\n        for (let j = l; j >=0 ; j--) {\n            if (s[j]===c){\n                l=j;\n                break;\n            }\n        }\n        if (s[l]===c && s[r]===c)\n            array_abs=Math.min(Math.abs(l-pos),Math.abs(r-pos));\n        else if (s[l]===c && s[r]!==c)\n            array_abs=Math.min(Math.abs(l-pos));\n        else\n            array_abs=Math.min(Math.abs(r-pos));\n        res.push(array_abs);\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：$O(N^2)$\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086892427","body":"### 思路\njs刚开始学，还是用的不好，java的思路写的\n### 代码\n\n\n```javascript\n/**\n * @param {number} maxSize\n */\nlet stack;//创建栈\nlet pos;//创建指针\nvar CustomStack = function(maxSize) {\n    stack=new Array(maxSize);\n    pos=-1;\n};\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (pos!==stack.length-1){\n        pos++;\n        stack[pos]=x;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (pos !== -1) {\n        let pos_value = stack[pos];\n        stack[pos] = undefined;\n        pos--;\n        return pos_value;\n    } else return -1;\n}\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if (k>pos+1){\n        for (let i = 0; i <=pos; i++) {\n            stack[i]+=val;\n        }\n    }else {\n        for (let i = 0; i < k; i++) {\n            stack[i]+=val;\n        }\n    }\n};\n\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087454057","body":"### 思路\n使用栈往里存数，使用正则判断数字和字母是不是连续，遇到]弹出来做拼接，最后将栈里面的数据倒出来拼接\n\n### 代码\n\n\n```java（此处换成你的语言，比如js，py 等）\nclass Solution {\n    public static String decodeString(String s) {\n    String res = \"\";\n    Stack<String> stack = new Stack<>();\n    for (int i = 0; i < s.length(); i++) {\n    String middle = s.substring(i, i + 1);\n    if (middle.matches(\"[0-9]\")) {\n    String num = middle;\n    while (i + 1 < s.length() && s.substring(i + 1, i + 2).matches(\"[0-9]\")) {//判断是不是个连续的数\n    num += s.substring(i + 1, i + 2);\n    i++;\n}\nstack.add(num);\n\n} else if (middle.matches(\"[a-z]\") || middle.equals(\"[\") || middle.matches(\"[A-Z]\")) {//使用正则表达式\n    if (middle.equals(\"[\"))\n        stack.add(middle);\n    else {\n        String ele = middle;\n        while (i + 1 < s.length() && s.substring(i + 1, i + 2).matches(\"[a-z]\") ||\n        i + 1 < s.length() && s.substring(i + 1, i + 2).matches(\"[A-Z]\")) {//判断是不是个连续的数\n            ele += s.substring(i + 1, i + 2);\n            i++;\n        }\n        stack.add(ele);\n    }\n\n} else if (middle.equals(\"]\")) {\n    String temp = \"\";//中间变量\n    while (!stack.peek().equals(\"[\"))\n        temp = stack.pop()+temp;\n    stack.pop();\n    int count = Integer.parseInt(stack.pop());\n    String mid = temp;\n    for (int j = 0; j < count - 1; j++) {\n        temp += mid;\n    }\n    stack.add(temp);\n\n}\n}\nwhile (!stack.empty()) { //最后把栈里的东西倒出来\n    String middle2 = \"\";\n    middle2 = stack.pop() + middle2;\n    res = middle2 + res;\n}\n\nreturn res;\n}\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：$O(N)$\n- 空间复杂度：$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088741684","body":"## 思路\n使用两个栈，一个存，一个取\n## 代码\n```javascript\nvar MyQueue = function() {\n    this.in_stack=[];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.in_stack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    this.out_stack=[];\n    while (this.in_stack.length>0){\n        this.out_stack.push(this.in_stack.pop());\n    }\n    for (let i = this.out_stack.length-2; i >-1; i--) {\n        this.in_stack.push(this.out_stack[i]);\n    }\n    return this.out_stack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.in_stack[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.in_stack.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n复杂度分析\n时间$O(n)$\n空间$O(n)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"physicshi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085682784","body":"## 思路\n按位求和，用flag保存进位，加到下一轮\n## 代码\n```js\nvar addToArrayForm = function (num, k) {\n  const res = [];\n  let order = num.length - 1;\n  // 进位\n  let flag = 0;\n  while (order >= 0 || k != 0) {\n    let x = order >= 0 ? num[order] : 0;\n    let y = k != 0 ? k % 10 : 0;\n    let sum = x + y + flag;\n    // 保存余数\n    res.push(sum % 10);\n    flag = Math.floor(sum / 10);\n    k = Math.floor(k / 10);\n    order--;\n  }\n  if (flag) res.push(flag);\n  return res.reverse();\n};\n```\n## 复杂度\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665965","body":"## 思路\r\n中心扩展\r\n## 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    const res=Array(s.length).fill(0);\r\n    for(let i=0;i<s.length;i++){\r\n        if(s[i]===c) continue\r\n        let l=i,r=i,shortest=Infinity;\r\n        while (l>=0){\r\n            if(s[l]===c){\r\n                shortest=Math.min(shortest,i-l)\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        while(r<s.length){\r\n            if(s[r]===c){\r\n                shortest=Math.min(shortest,r-i);\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        res[i]=shortest;\r\n    }\r\n    return res\r\n};\r\n```\r\n## 复杂度\r\n- 时间复杂度：O(n^2)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086823118","body":"## 思路\r\n\r\n直接按着题意即可。\r\n\r\n## 代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.stack = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.stack.length === this.maxSize) {\r\n    return null;\r\n  }\r\n  this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  var x = this.stack.pop();\r\n  return x === undefined ? -1 : x;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < k && i < this.stack.length; i++) {\r\n    this.stack[i] = this.stack[i] + val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：push 操作和 pop 操作的渐进时间复杂度为 O(1)，inc 操作的渐进时间复杂度为 O(k)\r\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087098004","body":"## 思路 \n维护一个栈，遍历判断\n## 代码\n```js\n// 维护一个栈\nvar decodeString = function (s) {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] != \"]\") {\n      stack.push(s[i]);\n      continue;\n    }\n    let str = \"\";\n    let cur = stack.pop();\n    while (cur != \"[\") {\n      // 加在当前的后面\n      str = cur + str;\n      cur = stack.pop();\n    }\n    let num = \"\";\n    // 排除 \"[\"\n    cur = stack.pop();\n    // 对于数字\n    while (!isNaN(cur)) {\n      // 字符串相加\n      num = cur + num;\n      cur = stack.pop();\n    }\n    // 字母 或者 \"[\"\n    stack.push(cur);\n    stack.push(str.repeat(num));\n  }\n  return stack.join(\"\");\n};\n```\n\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087800339","body":"## 思路\nrust 双栈实现队列\n## 代码\n```rust\nstruct MyQueue {\n    input: Vec<i32>,\n    output: Vec<i32>,\n}\n\n\nimpl MyQueue {\n\n    fn new() -> Self {\n        Self {\n            input: vec![],\n            output: vec![],\n        }\n    }\n    \n    fn push(&mut self, x: i32) {\n        self.input.push(x);\n    }\n    \n    fn pop(&mut self) -> i32 {\n        self.peek();\n        self.output.pop().unwrap()\n    }\n    \n    fn peek(&mut self) -> i32 {\n        if self.output.is_empty() {\n            while self.input.len() > 0 {\n                self.output.push(self.input.pop().unwrap());\n            }\n\n        }\n        self.output.last().cloned().unwrap()\n    }\n    \n    fn empty(&mut self) -> bool {\n        self.input.is_empty() && self.output.is_empty()\n    }\n}\n```\n## 复杂度\npush ：\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n\npop ：\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)\n\npeek：\n- 时间复杂度：最好的情况O(1) 最坏的情况O(n)\n- 空间复杂度：O(1)\n\nempty：\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"m908":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085689040","body":"### 思路\n从后往前遍历数组，按位与K相加\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        for(int i = num.size() - 1; i >= 0; i--)\n        {\n            int curNumber = num[i] + k % 10;\n            k /= 10;\n            if(curNumber >= 10)\n            {\n                curNumber -= 10;\n                k += 1;\n            }\n            result.push_back(curNumber);\n        }\n        \n        for (; k > 0; k /= 10) {\n            result.push_back(k % 10);\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n```\n### 复杂度\n- 时间复杂度：O(max(n,logk))\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086597840","body":"### 思路\r\n\r\n先保存目标字符出现的所有位置，逐个与字符串比对距离\r\n\r\n### 代码\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> result(s.size());\r\n        vector<int> targetChars;\r\n\r\n        for(int i = 0; i < s.size(); i++)\r\n        {\r\n            if(s[i] == c)\r\n                targetChars.push_back(i);\r\n        }\r\n\r\n        for(int i=0; i < result.size(); i++)\r\n        {\r\n            int minDistance = INT_MAX;\r\n            for(int j=0; j < targetChars.size(); j++)\r\n            {\r\n                if(minDistance > abs(i - targetChars[j]))\r\n                    minDistance = abs(i - targetChars[j]);\r\n            }\r\n            result[i] = minDistance;\r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度：O(m * n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086887598","body":"```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        mMaxSize=maxSize;\n    }\n    \n    void push(int x) {\n        if(mNumbers.size()<mMaxSize)\n        {\n            mNumbers.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if(!mNumbers.empty())\n        {\n        int result=mNumbers.back();\n        mNumbers.pop_back();\n        return result;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        if(mNumbers.size()<k)\n        {\n            for(int i=0;i<mNumbers.size();i++)\n            {\n                mNumbers[i]+=val;\n            }\n        }\n        else\n        {\n            for(int i=0;i<k;i++)\n            {\n                mNumbers[i]+=val;\n            }\n        }\n    }\n    \nprivate:\n    vector<int> mNumbers;\n    int mMaxSize;     \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087651573","body":"```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string result;\n        int num;\n        stack<int> numbers;\n        stack<string> strs; \n        for(int i=0;i<s.size();i++)\n        {\n            if(s[i] <= '9' && s[i] >= '0')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if(s[i] >= 'a' && s[i] <= 'z')\n            {\n                result += s[i];\n            }\n            else if(s[i] == '[')\n            {\n                numbers.push(num);\n                num = 0;\n                strs.push(result);\n                result = \"\";\n            }\n            else\n            {\n                int loop = numbers.top();\n                numbers.pop();\n                for(int j = 0; j<loop; j++)\n                {\n                    strs.top() += result;\n                }\n                result = strs.top();\n                strs.pop();\n            }\n        }\n        return result;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088345808","body":"### 思路\n一个栈保存输入数据，一个栈作为输出，当需要输出时判断输出栈是否为空，不为空直接输出栈顶，为空则从输入栈中获取数据\n### 代码\n``` c++\nclass MyQueue {\npublic:\n    MyQueue() {    \n    }\n    \n    void readFromInput() {\n        int index = mStackInput.size();\n        for(int i = 0; i < index; i++)\n        {\n            mStackOutput.push(mStackInput.top());\n            mStackInput.pop();\n        }\n    }\n\n    void push(int x) {\n        mStackInput.push(x);\n    }\n    \n    int pop() {\n        int result = -1;\n        if(!mStackOutput.empty())\n        {\n            result = mStackOutput.top();\n            mStackOutput.pop();\n        }\n        else if(mStackOutput.empty() && !mStackInput.empty())\n        {\n            readFromInput();\n            result = mStackOutput.top();\n            mStackOutput.pop();\n        }\n        return result;\n    }\n    \n    int peek() {\n        if(!mStackOutput.empty())\n        {\n            return mStackOutput.top();\n        }\n        else if(mStackOutput.empty() && !mStackInput.empty())\n        {\n            readFromInput();\n            return mStackOutput.top();\n        }\n        else\n            return -1;\n    }\n    \n    bool empty() {\n        if(mStackOutput.empty() && mStackInput.empty())\n            return true;\n        else\n            return false;\n    }\n\nprivate:\n    stack<int> mStackInput;\n    stack<int> mStackOutput;\n};\n```\n### 复杂度\n#### 时间复杂度\n- push() :O(1)\n- pop():O(n)\n- peek():O(n)\n- empty():O(1)\n#### 空间复杂度\nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085691561","body":"思路\n\n    二者从低位相加，满10进位即可\n\n代码\n\n    class Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<Integer>();\n            int n = num.length;\n            for (int i = n - 1; i >= 0; --i) {\n                int sum = num[i] + k % 10;\n                k /= 10;\n                if (sum >= 10) {\n                    k++;\n                    sum -= 10;\n                }\n                res.add(sum);\n            }\n            for (; k > 0; k /= 10) {\n                res.add(k % 10);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086620620","body":"思路\n\n    左右两次遍历，找出最小值即可\n\n代码\n\n    class Solution {\n        public int[] shortestToChar(String S, char C) {\n            int N = S.length();\n            int[] ans = new int[N];\n            int prev = Integer.MIN_VALUE / 2;\n    \n            for (int i = 0; i < N; ++i) {\n                if (S.charAt(i) == C) prev = i;\n                ans[i] = i - prev;\n            }\n    \n            prev = Integer.MAX_VALUE / 2;\n            for (int i = N-1; i >= 0; --i) {\n                if (S.charAt(i) == C) prev = i;\n                ans[i] = Math.min(ans[i], prev - i);\n            }\n    \n            return ans;\n        }\n    }\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085696335","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 思路\n\n- 从后向前逐位相加\n\n## 关键点\n\n-  不能直接把num转成数字相加，数字过大时会越界被截取\n-  考虑进位\n-  考虑k的长度大于num\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let add = k\n    for (let i=num.length-1;i>=0;i--) {\n        if(!add) {\n          break;\n        }\n        let sum = num[i] + add%10\n        add = Math.floor(add/10)\n        if (sum >= 10) {\n            add++\n            num[i] = sum%10\n        } else {\n          num[i] = sum\n        }\n    }\n    while(add > 0) {\n        num.unshift(add%10)\n        add = Math.floor(add/10)\n    }\n    return num\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"timmmyang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085699745","body":"## 思路\r\n从低位相加，`num`结束后继续判断`k`即可。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry = 0\r\n        for digit in num[::-1]:\r\n            if k > 0:\r\n                add = k % 10\r\n                k = k // 10\r\n                digit = digit + add + carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n            else:\r\n                digit += carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n        if k > 0:\r\n            while k > 0:\r\n                add = k % 10\r\n                k = k // 10\r\n                digit = add + carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n        if carry == 1:\r\n            res.append(1)\r\n        return res[::-1]\r\n```\r\n## 复杂度\r\n时间：O(n)，n为数组长度\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086534623","body":"### 思路\r\n\r\n正反两次遍历，分别记录当前字符是`c`的index，初始值使用`inf`。第二次遍历时比较存入最小值。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        idx = -float('inf')\r\n        res = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i\r\n            res.append(i - idx)\r\n        idx = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            res[i] = min(res[i], idx - i)\r\n        return res \r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n)，n为`s`长度\r\n\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086850004","body":"## 方法一\r\n\r\n### 思路\r\n\r\n直观做法，定义`self.stack`来作为这个栈。每次增加时index为0～min(k, len(self.stack))的元素增加`val`.\r\n\r\n### 代码\r\n\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) == self.maxSize:\r\n            return\r\n        self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else: \r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        n = min(k, len(self.stack))\r\n        for i in range(n):\r\n            self.stack[i] += val\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：初始，push, pop 为O(1)；increment为O(k)\r\n\r\n空间复杂度：O(maxSize)\r\n\r\n## 方法二\r\n\r\n### 思路\r\n\r\n为了减小方法一中的increment的时间复杂度，设计一个增量数组，只记录增加值的边界，在pop时一并加上作为返回值，之后将增量向栈底进行传递。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stack) - 1:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        res = self.stack[self.top] + self.add[self.top]\r\n        self.stack[self.top] = 0\r\n        if self.top > 0:\r\n            self.add[self.top-1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1 \r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        tmp = min(k-1, self.top)\r\n        if tmp > -1:\r\n            self.add[tmp] += val\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：全部操作都为O(1)\r\n\r\n空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087078688","body":"### 思路\r\n\r\n数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        i = 0\r\n        while i < len(s):\r\n            if s[i] != ']':\r\n                stack.append(s[i])\r\n                i += 1\r\n            else:\r\n                tmp = ''\r\n                mul = ''\r\n                while stack and stack[-1] != '[':\r\n                    tmp = stack.pop() + tmp\r\n                if stack:\r\n                    stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    mul = stack.pop() + mul\r\n                tmp *= int(mul)\r\n                stack.append(tmp)\r\n                i += 1\r\n        return ''.join(stack)\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n)，n为解码出来后的字符串长度\r\n\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085702964","body":"## 思路\r\n转换为字符串后再进行处理\r\n![image](https://user-images.githubusercontent.com/30134501/161241442-d66bc6e2-aaee-41a4-ba25-072de0f524be.png)\r\n\r\n## 代码（python）\r\n\r\n```python\r\nclass Solution:\r\n  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n      return list(map(int, list(str(int(''.join(list(map(str, num))))+k))))\r\n```\r\n**复杂度分析**\r\n- 时间复杂度： O(n) , n 为数组长度。\r\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086539562","body":"## 思路\r\n暴力解法，遍历找到index；将`answer`里的值设置很大，循环`range(0, len(s))`+循环`index`，作差求绝对值，跟`answer[i]`比较大小\r\n\r\n## 代码 （python3）\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        index = [i for i,si in enumerate(s) if si==c]\r\n        answer = [len(s)]*len(s)\r\n        for i in range(0, len(s)):\r\n            for j in index:\r\n                if abs(i-j)<answer[i]:\r\n                    answer[i] = abs(i-j) \r\n        return answer\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度： O(n^2)， n为`s`长度, 套了两个循环\r\n- 空间复杂度： O(n)，n为`answer`数组长度\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086792048","body":"- ## 思路\r\n\t- 正常list操作，push对应append()，pop对应pop()\r\n- ### 代码（python3）\r\n``` python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack) > 0: \r\n            for i in range(min(k, len(self.stack))):\r\n                self.stack[i] += val\r\n```\r\n- ### 复杂度分析\r\n  - 时间复杂度：O(n), n是`stack`长度\r\n  - 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087685866","body":"### 思路\r\n- 遍历`s`，往栈内不断push\r\n  * 如果遇到`]`，就开始一直pop，直到遇到`[`（用一个数组来存pop出来的字母）\r\n  * pop出`[`后，再继续pop，直到遇到非数字 or 栈为空 （用一个数组来存pop出来的数字）\r\n  * 解码这部分字符串，然后放入栈内\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stk = []\r\n        stemp = []\r\n        ntemp = []\r\n        for si in s:\r\n            if si != ']':\r\n                stk.append(si)\r\n            else:\r\n                while True:\r\n                    # get letters in []\r\n                    if stk[-1] == '[':\r\n                        # remove [\r\n                        stk.pop()\r\n                        break\r\n                    else:\r\n                        # append letters\r\n                        stemp.append(stk.pop())\r\n                while True:\r\n                    # get numbers before [\r\n                    if stk:\r\n                        if not stk[-1].isnumeric():\r\n                            break\r\n                        else:\r\n                            # append numbers\r\n                            ntemp.append(stk.pop())\r\n                    else:\r\n                        break\r\n                stk.extend(list(reversed(stemp)) * int(''.join(reversed(ntemp))))\r\n                stemp = []\r\n                ntemp = []\r\n        return ''.join(stk)\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：O(n^2), n为`s`长度，外循环遍历一遍`s`push到栈内，内循环又pop出来\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088251957","body":"### 思路\r\n- push: 新数据来了就 push 到 栈1，\r\n- pop: 需要 pop 的时候（如果 栈2 不为空），就把 栈1 反转（等价于pop后再append）存到 栈2，从栈2 pop\r\n\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack2 == []:\r\n            self.stack2 = list(reversed(self.stack1))\r\n            self.stack1 = []\r\n        return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.stack2 == []:\r\n            return self.stack1[0]\r\n        else:\r\n            return self.stack2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return self.stack2 == [] and self.stack1 == []\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1), python中reversed的时间复杂度好像是O(1)\r\n- 空间复杂度：O(n), n为stack长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yinhaoti":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085717791","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \"\"\"\n        Idea:\n            case1: len(num) > len(str(k)):\n                add two digital -> get result & carry\n                left move 1 digital of k\n            case2: len(num) < len(str(k)):\n                k += carry\n                while: add k to new array / convert k to array\n        Topic: Array enumerate\n        TC: O(N + max(0, (K-N)^2)\n        SC: O(max(1,K-N))\n        \"\"\"\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            add_result = carry + num[i] + k % 10\n            num[i] = add_result % 10\n            carry = add_result // 10\n            k = k // 10\n        \n        re = []\n        k = k + carry\n        while k:\n            re.insert(0, k % 10)\n            k = k // 10\n        \n        return re + num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086549709","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \"\"\"\n        Brute-force\n        TC: O(n^2)\n        SC: O(n)\n        \"\"\"\n        re = [-1] * len(s)\n\n                \n        for i in range(len(s)):\n            shortest = float('inf')\n            count = 0\n            for j in range(i, -1, -1):\n                if s[j] != c:\n                    count += 1\n                if s[j] == c:\n                    shortest = min(shortest, count)\n            \n            count = 0\n            for k in range(i, len(s)):\n                if s[k] != c:\n                    count += 1\n                if s[k] == c:\n                    shortest = min(shortest, count)\n            re[i] = shortest\n        \n        return re\n    \n    \n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \"\"\"\n        Topic: Array enumerate\n        Idea: enumerate 3times\n            [-1] * n\n            1st: put 0\n            2nd: left->right, 0+1\n            3rd: right->left, 0+1\n        \n        TC: O(n)\n        SC: O(n)\n        \"\"\"\n        l = len(s)\n        re = [-1] * l\n        \n        for i in range(l):\n            if s[i] == c:\n                re[i] = 0\n        \n        cur_d = -1\n        for i in range(l):\n            print(re[i], cur_d)\n\n\n            if re[i] == 0:\n                cur_d = 0\n            re[i] = cur_d\n            if cur_d != -1:\n                cur_d += 1\n\n        # reversed enumerate\n        cur_d = float('inf')\n        for i in range(l-1, -1, -1):\n            if re[i] == 0:\n                cur_d = 0\n                \n            if cur_d < re[i] or re[i] == -1:\n                re[i] = cur_d\n            if cur_d != -1:\n                cur_d += 1\n\n\n        return re\n\n                \n                \n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086868202","body":"```python\nclass CustomStack:\n    \"\"\"\n    Topic: Stack\n    Idea: \n        init: []-> stack, n->size\n        push: append\n        pop: pop()\n        increment: for -> increase\n    TC:\n        push: O(1)\n        pop: O(1)\n        increment: O(min(k, len(self.stack)))\n    SC: O(1)\n    \n    Improve: prefix-sum -> make increment O(1)\n    \"\"\"\n    \n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        \n        \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.max_size:\n            return\n        self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if len(self.stack) == 0: return -1\n        return self.stack.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i == len(self.stack):\n                break\n            self.stack[i] += val\n\n            \nclass CustomStack:\n    \"\"\"\n    Topic: Stack\n    Improve: prefix-sum -> make increment O(1)\n    Idea: \n        prefix-sum to record\n    TC:\n        push: O(1)\n        pop: O(1)\n        increment: O(1)\n    SC: O(n)\n    Improve: SC -> O(size of stack)\n    \"\"\"\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        self.incrementals = [0] * maxSize\n     \n           \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.max_size:\n            return\n        self.stack.append(x)\n    \n    def pop(self) -> int:\n        if len(self.stack) == 0: return -1\n        n = len(self.stack)\n        if n >= 2:\n            self.incrementals[n-2] += self.incrementals[n - 1]\n        re = self.stack.pop()\n        re += self.incrementals[n - 1]\n        self.incrementals[n - 1] = 0\n        return re\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) > 0:\n            self.incrementals[min(k, len(self.stack)) - 1] += val\n        \n\nclass CustomStack:\n    \"\"\"\n    Topic: Stack\n    SC -> O(size of stack)\n    Idea: \n        prefix-sum to record\n    TC:\n        push: O(1)\n        pop: O(1)\n        increment: O(1)\n    SC: O(size of stack)\n    \"\"\"\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        self.incrementals = []\n     \n           \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.max_size:\n            return\n        self.stack.append(x)\n        self.incrementals.append(0)\n    \n    def pop(self) -> int:\n        if len(self.stack) == 0: return -1\n        n = len(self.stack)\n        if n >= 2:\n            self.incrementals[n-2] += self.incrementals[n - 1]\n        re = self.stack.pop() + self.incrementals.pop()\n        return re\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) > 0:\n            self.incrementals[min(k, len(self.stack)) - 1] += val\n        \n        \n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085768414","body":"## 思路\n新建一个数组，长度为num和k的长度的最大值，从num和k的末尾开始相加，得到的值赋值到新数组中，注意进位。\n\n## 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n  let size = Math.max(num.length, (k + '').length);\n  let res = new Array(size);\n  let j = num.length - 1;\n  for (let i = res.length - 1; i >= 0; i--) {\n    let sum = k % 10;\n    if (j >= 0) sum += num[j];\n    if (res[i]) sum += res[i];\n    if (i === 0) {\n      res[i] = sum;\n    } else {\n      res[i] = sum % 10;\n      res[i - 1] = Math.floor(sum / 10);\n    }\n    k = Math.floor(k / 10);\n    j--;\n  }\n  if (res[0] >= 10) {\n    let s = res[0];\n    res[0] = s % 10;\n    res.unshift(Math.floor(s /10));\n  }\n  return res;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086627537","body":"## 思路\n两遍循环，先从左到右遍历s, 找到值左边第一个c的距离。再从右到左遍历，找到值右边第一个c的距离。取两个值中的最小值。\n\n## 代码\n```javascript\nvar shortestToChar = function(s, c) {\n  let res = [];\n  let cIndex = -Infinity;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) cIndex = i;\n    res[i] = i - cIndex;\n  }\n  let rcIndex = Infinity;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) rcIndex = i;\n    res[i] = Math.min(res[i], rcIndex - i);\n  }\n  return res;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086786982","body":"## 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.arr = [];\n  this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.arr.length < this.maxSize) this.arr.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.arr.length === 0) return -1;\n  else return this.arr.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (i >= this.arr.length) break;\n    this.arr[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087143843","body":"## 思路\n栈，遇到 ']' 开始出栈，直到遇到 '[' 时停止，此时获取到字符串c，再出栈获取重复数量n，c.repeat(parseInt(n))得到重复之后的数，入栈\n\n## 代码\n```javascript\nvar decodeString = function(s) {\n  let stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === ']') {\n      let c = '';\n      let pre = stack.pop();\n      while(pre !== '[') {\n        c = pre + c;\n        pre = stack.pop();\n      }\n      let n = '';\n      let preN = stack.pop();\n      while(!isNaN(preN)) {\n        n = preN + n;\n        preN = stack.pop();\n      }\n      stack.push(preN);\n      stack.push(c.repeat(parseInt(n)));\n    } else {\n      stack.push(s[i]);\n    }\n  }\n  return stack.join('');\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088277164","body":"## 思路\n定义两个栈，pop的时候，将stack1的数据全部pop到stack2，返回stack2栈顶的值，再将stack2全部pop回stack1\n\n## 代码\n```javascript\n\nvar MyQueue = function() {\n  this.stack1 = [];\n  this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  while (this.stack1.length > 0) {\n    this.stack2.push(this.stack1.pop());\n  }\n  let res = this.stack2.pop();\n  while (this.stack2.length > 0) {\n    this.stack1.push(this.stack2.pop());\n  }\n  return res;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  return this.stack1[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.stack1.length === 0;\n};\n\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sallyrubyjade":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085802765","body":"### 思路\n从数组最后一位开始遍历，并取出k的个位数进行相加，再对k进行除10处理来保证每次取出的都是最末位，然后对判断相加数是否大于10，是的话要进一位（记得把这个进位带进下一次数组循环里），把相加数的个位数放在要返回数组的开头。最后判断k或者进位是否处理干净，因为可能k的位数比num数组长度大，进行循环，直到k为0。\n\n### 代码\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let ans = [];\n    let carry = 0;\n    for (let i = num.length - 1; i >= 0; i--) {\n        let temp = num[i] + (k % 10) + carry;\n        k = Math.floor(k / 10);\n        if (temp >= 10) {\n            temp = temp % 10;\n            carry = 1;\n        }else {\n            carry = 0;\n        }\n        ans.unshift(temp);\n    }\n\n    while (carry != 0 || k > 0){\n        let temp = carry + (k % 10);\n        k = Math.floor(k / 10);\n        if (temp >= 10) {\n            temp = temp % 10;\n            carry = 1;\n        }else {\n            carry = 0;\n        }\n        ans.unshift(temp);\n    }\n\n    return ans;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086623359","body":"### 思路\n遍历字符串，对每一个字符元素，使用左右指针思想，分别向左和向右寻找最近的字符c，使用Math.min()进行对比，找到最短距离，把值放进数组中，再对下一个字符元素进行相同操作，直到遍历结束。\n\n### 代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let ans = [];\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) {\n            ans.push(0);\n            continue;\n        }\n\n        let left = i;\n        let right = i;\n        let shortest = Number.MAX_VALUE;\n\n        while(left >= 0) {\n            if(s[left] === c) {\n                shortest = Math.min(shortest, i - left);\n                break;\n            }\n            left--;\n        }\n\n        while(right <= s.length - 1) {\n            if (s[right] === c) {\n                shortest = Math.min(shortest, right - i);\n                break;\n            }\n            right++;\n        }\n        ans.push(shortest);\n    }\n    return ans;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086792767","body":"### 思路\n用数组模拟栈，push和pop直接用数组的原生方法，但要对数组的长度进行判断，increment方法要比较数组长度大小与k值大小，选择偏小值对这个范围内的数组元素加上增量。\n\n### 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.list = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.list.length < this.maxSize) this.list.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.list.length > 0) {\n        return this.list.pop();\n    }else {\n        return -1;\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(this.list.length <= k) {\n        for(let i = 0; i < this.list.length; i++) {\n            this.list[i] += val;\n        }\n    }else {\n        for(let i = 0; i < k; i++) {\n            this.list[i] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度分析\n- 时间复杂度：初始化对象CustomStack O(1)，push操作 O(1)，pop操作 O(1)，increment操作 O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087584892","body":"### 思路\n遇到`]`字符之前所有元素都入栈，碰到`]`之后，一个个出栈判断，构建好内层顺序\n\n### 代码\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = [];\n    for(let char of s) {\n        if(char !== ']') {\n            stack.push(char);\n            continue;\n        }\n        // 当遇到‘]’后\n        let temp = stack.pop();\n        let str = '';\n        while(temp !== '[') {\n            str = temp + str;\n            temp = stack.pop();\n        }\n        let number = '';\n        temp = stack.pop();\n        while(!isNaN(temp)) {\n            number =  temp + number;\n            temp = stack.pop();\n        }\n        stack.push(temp);\n        stack.push(str.repeat(Number(number)));\n    }\n    return stack.join('');\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088635019","body":"### 思路\n利用两个栈实现队列，javascript中没有栈结构，用数组模拟栈。重点在于peek和pop操作时，两个栈怎么互动：将之前push到一个栈中的元素，依次弹出，放入另一个空的栈中，就可以保证最先加进的元素，在第一个栈的栈底变成另一个栈的栈顶，达到先出的效果。\n\n### 代码\n```javascript\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    this.peek();\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.stack2.length) {\n        while (this.stack1.length) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2[this.stack2.length-1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    let ans1 = true;\n    let ans2 = true;\n    if (this.stack1.length) {\n        ans1 = false;\n    }\n    if(this.stack2.length) {\n        ans2 = false;\n    }\n\n    return ans1 && ans2;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n### 复杂度分析\n- 时间复杂度：pop操作和peek操作为O(n)，push和empty为O(1)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"meemx":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085804058","body":"### 思路\r\n从最低位（num数组最后一位开始），逐位相加\r\n\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        length = len(num)\r\n        result = []\r\n\r\n        for i in range(length - 1, -1, -1):\r\n            sum = num[i] + k % 10\r\n            k = k // 10\r\n            if sum >= 10:\r\n                k = k + sum // 10\r\n                sum = sum % 10\r\n            result.append(sum)\r\n\r\n        # 若A长度小于整数K\r\n        while k > 0:\r\n            sum = k % 10\r\n            k = k // 10\r\n            result.append(sum)\r\n\r\n        # 逆序输出\r\n        return result[::-1]\r\n```\r\n\r\n### 复杂度分析\r\n- 时间：O(n)\r\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086569073","body":"### 思路\r\n\r\n- 第一遍：从左向右遍历\r\n- 第二遍：从右向左遍历，同时取最小值\r\n\r\n### 代码\r\n\r\n```pthon3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n        # 第一遍 从左向右遍历\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n\r\n        # 第二遍 从右向左遍历 同时取最小值\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086883737","body":"### 思路\r\n\r\n使用数组进行模拟，操作即较为简单与高效\r\n\r\n### 代码\r\n\r\n```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n```\r\n\r\n### 时间复杂度\r\n\r\n- 时间复杂度：push是O(1)、pop是O(1)、increment是O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087195117","body":"### 思路\r\n\r\n使用栈\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in s:\r\n            if i == ']':\r\n                strs = ''\r\n                repeat = ''\r\n                while stack[-1] != '[':\r\n                    strs = stack.pop() + strs\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    repeat = stack.pop() + repeat\r\n                stack.append(int(repeat) * strs)\r\n                continue\r\n            stack.append(i)\r\n        return ''.join(stack)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088189776","body":"### 思路\r\n\r\n使用两个栈，如同两个杯子倒水一样进行操作\r\n\r\n### 代码\r\n\r\n```python3\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stack_push = []\r\n        self.stack_pop = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_push.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if not self.stack_pop: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n        res = self.stack_pop.pop()\r\n        return res\r\n        \r\n\r\n    def peek(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if self.stack_pop: \r\n            return self.stack_pop[-1]\r\n\r\n        else: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n            return self.stack_pop[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack_push and not self.stack_pop\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(1) O(N)\r\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moonlee001":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085808810","body":"## 思路\n将k转化为数组，利用双指针倒序相加。\n## 代码\nvar addToArrayForm = function(num, k) {\n    const arrK = k.toString().split('');\n    const n = num.length;\n    const m = arrK.length;\n    let p1 = n - 1, p2 = m - 1;\n    let res = [];\n    let carry = 0;\n    while (p1 >= 0 || p2 >= 0) {\n        const num1 = p1 < 0 ? 0 : num[p1];\n        const num2 = p2 < 0 ? 0 : arrK[p2] - 0;\n        const sum = num1 + num2 + carry;\n        const mode = sum % 10;\n        carry = Math.floor(sum / 10);\n        res.unshift(mode);\n        p1--;\n        p2--;\n    }\n    if (carry) {\n        res.unshift(carry);\n    }\n    return res;\n};\n\n## 复杂度\n时间：O(n)\n空间： O(m) m为数字个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086597227","body":"### 思路\n两次遍历字符串，取最小值。\n\n### 代码\n\n\n```js\nvar shortestToChar = function(S, C) {\n  let n = S.length;\n  let prev = -Infinity;\n  let ans = [];\n  for (let i = 0; i < n; i++) {\n    if (S.charAt(i) == C) {\n      prev = i;\n    }\n    ans[i] = i - prev;\n  }\n  \n  prev = Infinity;\n  for(let i = n - 1; i >= 0; i--) {\n    if (S.charAt(i) == C) {\n      prev = i;\n    }\n    ans[i] = Math.min(prev - i, ans[i]);\n  }\n  \n  return ans;\n\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086797204","body":"### 思路\n使用数组模拟栈，inc使用空间换取时间，存储增量，如果需要pop的时候再将增量加到对应的值\n\n### 代码\n\n```javascript\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = stack;\n  this.map = new Map();\n}\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length < this.maxSize) {\n    this.stack.push(x);\n  }\n}\n\nCustomStack.prototype.pop = function() {\n  if (this.stack.length === 0) {\n    return -1;\n  } \n  const inc = this.map.get(this.stack.length) || 0;\n  this.map.set(this.stack.length - 1, (this.map.get(this.stack.length - 2) || 0) + inc);\n  this.map.set(this.stack.length, 0);\n  return this.stack.pop() + inc;\n}\n\nCustomStack.prototype.increment = function(k, val) {\n  const index = Math.min(k, this.stack.length) - 1;\n  if (index < 0) {\n    return;\n  }\n  this.map.set(index, (this.map.get(index) || 0) + val);\n}\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(1)\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087492216","body":"### 思路\r\n使用栈存储S，如果遇到右括号，则栈出，然后将处理好的字符在存入栈。\r\n\r\n### 代码\r\n```javascript\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    const n = s.length;\r\n    let res = '';\r\n    for (let i = 0; i < n; i++) {\r\n        const cur = s.charAt(i);\r\n        if (cur == ']') {\r\n            let str = '';\r\n            while (stack.length && stack[stack.length - 1] !== '[') {\r\n                str = stack.pop() + str;\r\n            }\r\n            stack.pop();\r\n            let num = '';\r\n            while(stack.length && !isNaN(stack[stack.length - 1])) {\r\n                num = stack.pop() + num;\r\n            }\r\n            console.log(str, num);\r\n            stack.push(str.repeat(num));\r\n        } else {\r\n            stack.push(cur);\r\n        }\r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(N)\r\n- 空间复杂地：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088366994","body":"### 思路\n使用两个数组实现\n\n### 代码\n\n```javascript\nvar MyQueue = function() {\n  this.in = [];\n  this.out = [];\n}\nMyQueue.prototype.push = function (x) {\n  this.in.push(x);\n}\nMyQueue,prototypt.peek = function() {\n  if (this.out.length == 0) {\n    const n = this.in.length;\n    for (let i = 0; i < n; i++) {\n      this.out.push(this.in.pop());\n    }\n  }\n  return this.out[this.out.length - 1];\n}\nMyQueue,prototypt.pop = function() {\n  if (this.out.length == 0) {\n    const n = this.in.length;\n    for (let i = 0; i < n; i++) {\n      this.out.push(this.in.pop());\n    }\n  }\n  return this.out.pop();\n}\nMyQueue,prototypt.empty = function() {\n  return this.in.length === 0 && this.out.length === 0;\n}\n```\n\n### 复杂度分析\n- 时间复杂度： push: O(1) peek: O(n) pop: O(n) empty: O(1)\n- 空间复杂度： O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085811348","body":"# 思路\r\n先将数组转换成数字 再将结果转换为数组\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = 0\r\n        digit = 1\r\n        for i in num[::-1]:\r\n            sum += i * digit\r\n            digit *= 10\r\n        sum += k\r\n        res = []\r\n        while sum:\r\n            res.append(sum % 10)\r\n            sum = sum // 10\r\n        return res[::-1]\r\n        \r\n```\r\n# 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086538280","body":"# 思路\r\n先正序遍历 再倒着遍历一遍 \r\n# 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        idx = -float(\"inf\")\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i \r\n            # i - 负无穷 = 正无穷\r\n            res.append(i - idx)\r\n        idx = float(\"inf\")\r\n        for i in range(len(s) - 1, -1 , -1):\r\n            if s[i] == c:\r\n                idx = i \r\n            res[i] = min(idx - i, res[i])\r\n        return res\r\n```\r\n# 时间复杂度\r\n时间：0(n)\r\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"momomoi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085818993","body":"**思路** \r\n把num列表数据合并为数字和k相加然后再拆分还原\r\n\r\n**时间复杂度** \r\n单循环O(N)\r\n\r\n**代码实现**\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n       cmt_num = ''.join((str(i) for i in num))\r\n       add_sum = int(cmt_num) + k\r\n       split_sum = [int(l) for l in str(add_sum)]\r\n       return split_sum\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086651671","body":"# 思路\r\n### 第一次遍历进行位置确认，第二次遍历进行选最小值\r\n\r\n# 复杂度\r\n### 时间复杂度O(N)\r\n### 空间复杂度O(N)\r\n# 代码\r\n```\r\nclass demo:\r\n    def test(self, S:str, C:str) -> List[int]:\r\n         sums = -1\r\n         zero_sums = [0]*len(S)\r\n         for i in range(len(S)):\r\n            if S[i] == C:\r\n                 sums = 0\r\n            else:\r\n                sums += 1\r\n            zero_sums[i] = sums\r\n         sums = -1\r\n         for j in range(len(S)-1, -1, -1):\r\n            if S[j] == C:\r\n                 sums = 0\r\n            else:\r\n                sums +=1\r\n            zero_sums[j] = min(sums, zero_sums[j])\r\n         return sums\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086874668","body":"###看了题解和评论，因为在外面没法写就直接复用一下了\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, size: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = size\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(self.cnt, k)):\r\n            self.st[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087578922","body":"\n### 代码\n```\ndef decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == \"]\":\n                repeatStr = \"\"\n                repeatCount = \"\"\n                while stack and stack[-1] != \"[\":\n                    repeatStr = stack.pop() + repeatStr\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```\n### 复杂度\n#### 时间 O(N)\n#### 空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088572928","body":"### 思路：\n刚开始觉得题目很简单，写了下代码，但是随后看了下题解的思路，发现push这块没考虑清楚，复用了下代码\n\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.stack_1 = []\n        self.stack_2 = []\n\n    def push(self, sum):\n\n        while self.stack_1:\n            self.stack_2.append(self.stack_1.pop())\n        self.stack_2.append(sum)\n        while self.stack_2:\n            self.stack_1.append(self.stack_2.pop())\n\n    def pop(self):\n        return self.stack_1.pop()\n\n    def peek(self):\n        return self.stack_1[-1]\n\n    def empty(self):\n        return False if not bool(self.stack_1) else True\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085860307","body":"#### 解题思路\n  1. 低位到高位逐位将数字加在一起\n  2. 若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中\n#### 代码实现\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度: O(max(n,logk), 其中 nn 为数组的长度\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086639221","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086876043","body":"### 思路\n  用数组模拟栈，用数组原生方法pop、push方法实现\n  \n### 代码\n\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const length = Math.min(k, this.stack.length);\n  for (let i = 0; i < length; i++) {\n    this.stack[i] += val;\n  }\n};\n```\n### 复杂度\n- 时间复杂度 \n\n  push: O(1)\n\n  pop：O(1)\n  \n  increment：O(K) \n \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087643862","body":"### 思路\n1. 将字符串从末尾开始遍历\n2. 遇到“]”入栈\n3. 拼接要出栈的字符串，遇到\"[\"出栈\n4. \"[\"后紧跟数据，累计最终的数字\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\n\n### 代码\n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // 定义存储字符串的栈\n    let str = \"\"; // 定义最终返回的字符串\n    let num = \"\"; // 定义字符串重复的次数\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // 解析出连续的数字\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // 拼接字符\n        str = \"\";\n        num = \"\"; //清空计数\n        i++;\n      } else if (s[i] === \"[\") {\n        // 遇到\"[\"时，将后续字符出栈\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\n        }\n      } else {\n        // 将字符 或 \"]\"入栈\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### 复杂度分析\n- 时间复杂度：O(n),循环遍历一遍\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088800545","body":"### 解题思路\n    定义两个栈，\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\n\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$, N为队列元素个数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quieter2018":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085861308","body":"**思路**\r\n从num的个位开始与k逐个相加，与10相除，余数为当前位的数值，商为下次循环的k，求完后再倒序即可。\r\n\r\n**代码实现**\r\n```C++\r\nclass Solution {\r\n  public:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> out;\r\n        int sum = 0;\r\n        for(int i = num.size()-1; i >= 0 || k > 0; i--) {\r\n            if(i >= 0){\r\n                sum = k + num[i];\r\n                out.push_back(sum % 10);\r\n                k = sum /10;\r\n            }else{\r\n                out.push_back(k % 10);\r\n                k = k /10;\r\n            }\r\n        }\r\n        reverse(out.begin(),out.end());\r\n        return out;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n时间复杂度：O(max(n,k))  n：num的数据长度；k：k的数据长度\r\n空间复杂度：同上","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhulin1110":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085873537","body":"## 题目\n数组形式的整数加法\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n## 思路\n首先想到的是将数组转换成数，再和K相加，但会发生内存溢出的情况。\n- **改进** \n从个位数开始考虑，依次与 k 相加，（和 % 10） 存入输出数组 ，（和 / 10）取出进位位（更新后的k包含进位）。最后考虑 k 超出数组长度的部分，依次加到输出数组里即可。\n## 代码(JavaScript)\n```JavaScript\nvar addToArrayForm = function(num, k) {\n    var res = [];\n    for (let i = num.length - 1; i >= 0; i--) {\n        res.push((num[i] + k) % 10);  //个位数存入数组\n        k = Math.floor((num[i] + k) / 10);  //更新k, 进位位包含在k中\n    }\n    // 对超出数组长度的 k 进行处理\n    while (k > 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    return res.reverse();\n};\n```\n## 复杂度\n- 时间复杂度\n> O(n) ，for循环遍历数组长度n，后面的可以忽略不计\n- 空间复杂度\n> O(n) ， 创建一个新的数组res存放结果，后面有循环但是没有分配新的内存空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646686","body":"## 题目\n\n字符的最短距离 https://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 思路1（菜鸡的我自己写的，吐了）\n\n找到 s 中所有与 c 相同的字符，并将其索引存放到一个数组中。将数组中的元素索引依次与相同字符的索引做差，并比较得出最小值。值得注意的是，当 s 中与 c 相同的字符只有一个时，无需比较，直接做差即可。\n\n## 代码1（JavaScript）\n\n```javascript\nvar shortestToChar = function(s, c) {\n    var curr = [];\n    var res = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            curr.push(i);\n        }\n    }\n    if (curr.length == 1) {\n        for (let i = 0; i < s.length; i++) {\n            res[i] = Math.abs(i - curr[0]);\n        }\n        return res;\n    }\n    for (let i = 0; i < s.length; i++) {\n        let j = 0;\n        let data = Math.abs(curr[j] - i);\n        while (curr && (j < curr.length - 1)) {\n            data = Math.min(data, (Math.abs(curr[j + 1] - i)));\n            j++;\n            res[i] = data;\n        }\n    }\n    return res;\n};\n```\n\n \t\t### 代码1改进（看了题解，稍稍改进）\n\n```javascript\nvar shortestToChar = function(s, c) {\n    var curr = [];\n    var res = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            curr.push(i);\n        }\n    }\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            res[i] = 0;\n            continue;\n        }\n        for (const j of curr) {\n            const dist = Math.abs(j - i);\n            if (dist >= res[i]) break; // 小小剪枝，跟上次存的比较，j是不断增大的，目的就是为了找最小值，设置阈值\n            res[i] = dist;\n        }  \n    }\n    return res;\n};\n```\n\n\n\n## 复杂度1\n\n- 时间复杂度\n\n  > O(n * n) 前面for循环是n，后面for循环嵌套while，while内最大是n，时间复杂度就是n*n，前面的n可以忽略不记\n\n- 空间复杂度\n\n  > O(n) res 和 curr \n\n## 思路2 （看了题解-贪心算法）\n\n两遍循环，先从左到右遍历s，找到左边第一个c的距离。再从右到左遍历，找到值右边第一个c的距离。最后，取两个值中的最小值。\n\n## 代码2 （评论区大佬的）\n\n```javascript\nvar shortestToChar = function(s, c) {\n  let res = [];\n  let lcIndex = -Infinity;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) lcIndex = i;\n    res[i] = i - lcIndex;\n  }\n  let rcIndex = Infinity;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) rcIndex = i;\n    res[i] = Math.min(res[i], rcIndex - i);\n  }\n  return res;\n};\n```\n\n## 复杂度2\n\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086837506","body":"## 题目\n\n设计一个支持增量操作的栈 https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 思路1\n\n根据题目要求的直觉栈操作\n\n## 代码1（JavaScript）\n\n```javascript\nvar CustomStack = function(maxSize) {\n    this.max = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n   if (this.stack.length < this.max) {\n        this.stack.push(x); \n   }\n\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    let res = this.stack.pop();\n    if (res == null) {\n        return -1;\n    } else {\n        return res;\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < this.stack.length; i++) {\n        if (i < k) {\n            this.stack[i] += val;\n        }\n    }\n   \n};\n```\n\n## 复杂度1\n\n- 时间复杂度\n\n  > O(n ) \n\n- 空间复杂度\n\n  > O(1)  未定义新的数组存放结果\n\n## 思路2 （题解学习）\n\n前缀和（没看懂，待补充）。。。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087573823","body":"## 题目\n\n字符串解码 https://leetcode-cn.com/problems/decode-string/\n\n## 思路1\n\n定义两个栈，一个用来存放倍数，一个用来存放字符串。具体操作看程序注释\n\n## 代码1（JavaScript）\n\n```javascript\nvar decodeString = function(s) {\n   // 存倍数的栈\n    let numStack = [];\n    // 存待拼接的str的栈     \n    let strStack = [];\n    // 倍数   \n    let num = 0;\n    // 字符串\n    let result = '';\n    //  逐字符扫描\n    for (let char of s) {\n        // 遇到数字\n        if (!isNaN(char)) {\n            // 算出倍数\n            num = num * 10 + Number(char); \n        } \n        // 遇到 [\n        else if (char === '[') {\n            // 将result已经拼接完成的放到strStack当中\n            strStack.push(result);\n            // 入栈后清零 \n            result = '';\n            // 倍数num进入栈等待\n            numStack.push(num);\n            // 入栈后清零\n            num = 0;\n            \n        } \n        // 遇到 ]，两个栈的栈顶出栈\n        else if (char === ']') {\n            // 获取拷贝次数\n            let repeatTimes = numStack.pop();\n            // 构建子串\n            result = strStack.pop() + result.repeat(repeatTimes); \n        } \n        // 遇到字母，追加给result串\n        else {\n            result += char;\n        }\n    }\n    // 最终返回结果\n    return result;\n};\n```\n\n## 复杂度1\n\n- 时间复杂度\n\n  > O(n ) \n\n- 空间复杂度\n\n  > O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088752873","body":"## 题目\r\n\r\n用栈实现队列 https://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 思路1\r\n\r\n用两个栈实现队列：将一个栈当做输入栈，另一个栈当做输出栈。注意输出栈不为空的情况的处理。\r\n\r\n## 代码1（JavaScript）\r\n\r\n```javascript\r\nvar MyQueue = function() {\r\n    this.stack1 = [];\r\n    this.stack2 = [];\r\n    this.res = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(this.stack2.length == 0) {\r\n        while (this.stack1.length !== 0) {\r\n            this.stack2.push(this.stack1.pop());\r\n        }\r\n    }\r\n    return this.stack2.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(this.stack2.length == 0) {\r\n        while (this.stack1.length !== 0) {\r\n            this.stack2.push(this.stack1.pop());\r\n        }\r\n    }\r\n    return this.stack2[this.stack2.length - 1];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    if (this.stack1.length !== 0 || this.stack2.length !== 0) {\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度1\r\n\r\n- 时间复杂度\r\n\r\n  > O(n) \r\n\r\n- 空间复杂度\r\n\r\n  > O(n) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lizimu0709":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085873737","body":"- 思路\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\nAB两数都加完后判断进位 , 进位不为 0 加在前面。\r\n\r\n- 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] res, int K) {\r\n        List<Integer> Arr = new ArrayList<>();\r\n        int n = res.length;\r\n        int i = n-1;\r\n        int carry = 0;\r\n        int sum = 0;\r\n        while(i >= 0 || K != 0){\r\n            int x = i >= 0 ? res[i] : 0;\r\n            int y = K >= 0 ? K%10 : 0;\r\n            sum = x + y +carry;\r\n            carry = sum / 10;\r\n            K = K / 10;\r\n             --i;\r\n             Arr.add(0,sum%10);\r\n        }\r\n        if(carry != 0)\r\n            Arr.add(0,carry);\r\n        return Arr;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085898822","body":"## Idea\r\nIterate through the number array backwards. Add each element to k, remove the last digit from k and add it to the list.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        while (k > 0) {\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086368202","body":"## Idea\r\nIterate through the string for 3 times. Locate all occurrences of c in the first iteration. Update distance based on distance on the left side in the second iteration and update distance based on distance on the right side in the third iteration.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] str = s.toCharArray();\r\n        int[] ans = new int[str.length];\r\n        Arrays.fill(ans, Integer.MAX_VALUE);\r\n        for (int i = 0; i < str.length; i++) {\r\n            if (str[i] == c) {\r\n                ans[i] = 0;\r\n            }\r\n        }\r\n        \r\n        for (int i = 0; i < str.length - 1; i++) {\r\n            if (ans[i] != Integer.MAX_VALUE) {\r\n                ans[i+1] = Math.min(ans[i] + 1, ans[i+1]);\r\n            }\r\n        }\r\n        \r\n        for (int i = str.length-1; i > 0; i--) {\r\n            if (ans[i] != Integer.MAX_VALUE) {\r\n                ans[i-1] = Math.min(ans[i] + 1, ans[i-1]);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086866023","body":"## Idea\r\nStore the element in an array and use an int variable to represent the actual size.\r\n\r\n## Code\r\n```\r\nclass CustomStack {\r\n    int[] arr;\r\n    int cur = 0;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (cur < arr.length) {\r\n            arr[cur++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (cur == 0) {\r\n            return -1;\r\n        }\r\n        return arr[--cur];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, cur); i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: push: O(1); pop: O(1); increment: O(min(k, cur))\r\nSpace: O(maxSize)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087575778","body":"## Idea\r\nUse a queue and delegate the nested encoded string to recursion\r\nUse a int variable to store k and delegate decoding to recursion when there is a '[', and a ']' indicates that the job is done and should continue.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        char[] str = s.toCharArray();\r\n        Queue<Character> q = new LinkedList<>();\r\n        for (char c : str) {\r\n            q.add(c);\r\n        }\r\n        return process(q);\r\n    }\r\n    \r\n    public String process(Queue<Character> q) {\r\n        int num = 0;\r\n        StringBuilder sb = new StringBuilder();\r\n        while (!q.isEmpty()) {\r\n            char c = q.poll();\r\n            if (Character.isDigit(c)) {\r\n                num *= 10;\r\n                num += c - '0';\r\n            }\r\n            else if (c == '[') {\r\n                String s = process(q);\r\n                for (int i = 0; i < num; i++) {\r\n                    sb.append(s);\r\n                }\r\n                num = 0;\r\n            }\r\n            else if (c == ']') {\r\n                break;\r\n            }\r\n            else {\r\n                sb.append(c);\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088690453","body":"## Idea\r\nuse stack s1 for push and stack s2 for pop and peek\r\nWhenever pop or peek is invoked, we pop all elements from s1 into s2 if s2 is empty.\r\n\r\n## Code\r\n```\r\nclass MyQueue {\r\n    public Stack<Integer> s1;\r\n    public Stack<Integer> s2;\r\n    \r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    private void update() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        update();\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        update();\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n\r\n```\r\n\r\n## Complexity\r\nTime: \r\npush O(1)\r\npop O(n)\r\npeek O(n)\r\nempty O(1)\r\n\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiayuhui231":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085901627","body":"## 题目\n数组形式的整数加法\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/submissions/\n## 思路\n   - 由于直接循环将数组取出来相加长度可能会超出，所以按倒序取出数组，依次相加取余放进数组\n   - 可能会出现加完后k值为个位数的情况，所以多加个判断，将剩余数也加入数组\n## C++代码\n``` class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        int t = k, idx=0;\n        vector<int> ans;\n        while(t)\n        {\n            if(idx<num.size()) t+=num[idx++];\n            ans.push_back(t%10);\n            t /= 10;\n        }\n        while(idx<num.size()) ans.push_back(num[idx++]);\n        reverse(ans.begin(), ans.end());\n        return ans;\n\n    }\n};\n```\n## 复杂度\n     时间：O(n）\n     空间：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086558705","body":"## 题目\n字符的最短距离\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n## 思路\n- 前后各遍历一次，找最短距离\n## 代码\n``` class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n            vector<int> pos(s.size(),-1);\n        int pre = -1;\n        for(int i = s.size() -1;i >= 0;i--)\n            if(s[i] == c){\n                pre = i;\n                pos[i] = 0;\n            }else if(pre != -1) pos[i] = pre - i;\n        pre = -1;\n        for(int i = 0;i < s.size();i++){\n            if(s[i] == c){\n                pre = i;\n        }else if(pos[i] == -1 && pre != -1){\n            pos[i] = i - pre;\n        }else if(pos[i] != -1 && pre != -1){\n            pos[i] = min( i - pre, pos[i]);\n        }\n        }\n        return pos;\n    }\n};\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086872513","body":"# 代码\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int top;\n\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if (top != stk.size() - 1) {\n            ++top;\n            stk[top] = x;\n        }\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stk[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int lim = min(k, top + 1);\n        for (int i = 0; i < lim; ++i) {\n            stk[i] += val;\n        }\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087671554","body":"## 题目\n字符串解码\nhttps://leetcode-cn.com/problems/decode-string/\n## 思路\n     可以结合分配律，先将括号里的字母结合起来\n\n## 代码\n``` \nclass Solution {\npublic:\n    string decodeString(string s) {\n         int len = s.size();\n        int num = 0;\n        stack<int> numstack;\n        stack<string> strstack;\n        string cur = \"\";\n        string result = \"\";\n        for(int i=0; i<len; ++i)\n        {\n            if(s[i]>='0' && s[i]<='9')\n            {\n                num = 10*num + s[i] - '0';\n            }\n            else if(s[i] == '[')\n            {\n                numstack.push(num);\n                strstack.push(cur);\n                num = 0;\n                cur.clear();\n            }\n            else if((s[i]>='a' && s[i]<='z') || (s[i]>='A' && s[i]<='Z'))\n                cur += s[i];\n            else if(s[i] == ']')\n            {\n                int k = numstack.top();\n                numstack.pop();\n                for(int j=0; j<k; ++j)\n                    strstack.top() += cur;\n                cur = strstack.top();\n                strstack.pop();\n            }\n        }\n        result = result + cur;\n        return result;     \n    }\n};\n```\n\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088804924","body":"## 代码\n```\nclass MyQueue {\npublic:\n    stack<int> stIn;\n    stack<int> stOut;\n    /** Initialize your data structure here. */\n    MyQueue() {\n\n    }\n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stIn.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）\n        if (stOut.empty()) {\n            // 从stIn导入数据直到stIn为空\n            while(!stIn.empty()) {\n                stOut.push(stIn.top());\n                stIn.pop();\n            }\n        }\n        int result = stOut.top();\n        stOut.pop();\n        return result;\n    }\n\n    /** Get the front element. */\n    int peek() {\n        int res = this->pop(); // 直接使用已有的pop函数\n        stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去\n        return res;\n    }\n\n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return stIn.empty() && stOut.empty();\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085906678","body":"# Plan:\r\n```\r\niterate from end of num, last digit of k, insert to the head of the linkedlist, update carry, curSum\r\n\r\nedge cases: k is longer, num is longer, carry == 1 in the end\r\n```\r\n\r\n# Code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> sum = new LinkedList<>();\r\n        int numIndex = num.length - 1;\r\n        int curSum = 0, carry = 0;\r\n        \r\n        while (numIndex >= 0) {\r\n            curSum = num[numIndex] + k % 10 + carry;\r\n            carry = curSum / 10;\r\n            curSum %= 10;\r\n            sum.addFirst(curSum);\r\n            k /= 10;\r\n            numIndex--;\r\n        }\r\n        \r\n        while (k > 0) {\r\n            curSum = k % 10 + carry;\r\n            carry = curSum / 10;\r\n            curSum %= 10;\r\n            sum.addFirst(curSum);\r\n            k /= 10;\r\n        }\r\n        \r\n        if (carry == 1) sum.addFirst(carry);\r\n        return sum;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity:\r\n```\r\nTime: O(max(num.length, log_10_k))\r\nSpace: O(max(num.length, log_10_k)) for the linkedlist\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086537211","body":"# Plan & Complexity: \n\n```\nIt is guaranteed that c occurs at least once in s.\n1 <= s.length <= 10^4\n\ns = \"loveleetcode\", c = \"e\"\n\nl o v e l e e t c o d e\nm m m 0 1 0 0 1 2 3 4 0\n3 2 1 0 1 0 0 1 2 2 1 0\n\nidea: two traversals, left-> right, right -> left\n\nTime: O(s.length())\nSpace: O(s.length()) for the distances array\n```\n\n# Code:\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] distances = new int[s.length()];\n        int toCompare = Integer.MAX_VALUE;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                distances[i] = 0;\n                toCompare = i;\n            } else {\n                distances[i] = Math.abs(toCompare - i);\n            }\n        }\n        \n        \n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                distances[i] = 0;\n                toCompare = i;\n            } else {\n                distances[i] = Math.min(distances[i], Math.abs(toCompare - i));\n            }\n        }\n        \n        return distances;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086897041","body":"```java\n/*\nBruteforce:\nsimulate with an array\n\n\nOptimization:\nprefix sum\n\nwhen pop, adjust the inc for the previous cell\n\ninc list and stack list\n\nTime: O(1) \nSpace: O(1) per element\n\n*/\n\nclass CustomStack {\n\tint capacity;\n\tint size;\n\tList<Integer> stack = new ArrayList<>();\n\tList<Integer> inc = new ArrayList<>();\n\n\tpublic CustomStack(int maxSize) {\n\t\tcapacity = maxSize;\n\t\tsize = 0;\n\t}\n\n\tpublic void push(int x) {\n\t\tif (size < capacity) {\n\t\t\tstack.add(x);\n\t\t\tinc.add(0);\n\t\t\tsize++;\n\t\t}\n\t}\n\n\tpublic int pop() {\n\t\tif (size == 0) return -1; // empty check\n\t\tint ans = stack.get(size - 1) + inc.get(size - 1);\n\t\tif (size >= 2) {\n\t\t\tinc.set(size - 2, inc.get(size - 2) + inc.get(size - 1));\n\t\t}\n\t\tinc.remove(size - 1);\n\t\tstack.remove(size - 1);\n\t\tsize--;\n\t\treturn ans;\n\t}\n\n    // index - > inc at that index\n\tpublic void increment(int k, int val) {\n\t\tif (size > 0) { \n\t\t\tinc.set(Math.min(k, size) - 1, inc.get(Math.min(k, size) - 1) + val);\n\t\t}\n\t}\n\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087730751","body":"# Logic:\ntwo stacks, one for freq, one for str\n[: push cur freq, str to each stack, reset\n]: pop freq, str from each stack, pass curStr to temp and append\n\n# Complexity:\nTime: O(n), n = decoded len\nSpace: O(n), for two stacks and output\n\n# Code:\n```java\nclass Solution {\n    public String decodeString(String s) {\n        if (s.length() == 1) return s;\n        \n        StringBuilder decoded = new StringBuilder();\n        Stack<Integer> numStack = new Stack<>();\n        \n        Stack<StringBuilder> stack = new Stack<>();\n        int index = 0;\n        int curNum = 0;\n        StringBuilder curS = new StringBuilder();\n        \n        while (index < s.length()) {\n            if (Character.isDigit(s.charAt(index))) {             \n                curNum = curNum * 10 + s.charAt(index) - '0';\n                index++;\n            }\n            else if(s.charAt(index) == '[') {\n                numStack.push(curNum);\n                curNum = 0;\n                \n                stack.push(curS);\n                curS = new StringBuilder();\n                \n                index++;\n            }\n            else if (Character.isLetter(s.charAt(index))) {\n                curS.append(s.charAt(index));\n                index++;\n            }\n            else if (s.charAt(index) == ']') {\n                \n                StringBuilder temp = curS;\n                int freq = numStack.pop();\n                curS = stack.pop();\n                \n                for (int i = 0; i < freq; i++) {\n                    curS.append(temp);\n                }\n                index++;\n            }\n            \n        }\n        return curS.toString();\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088905443","body":"# Plan:\r\ntwo stacks, one for pop only, one for push only, transfer elements before each operation\r\n\r\n# Complexity:\r\n```\r\nTime: O(N), N = total number of elements\r\nSpace: O(N) for N elements\r\n```\r\n# Code:\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> pushStack = new Stack<>();\r\n    Stack<Integer> popStack = new Stack<>();\r\n    \r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        while (!popStack.isEmpty()) {\r\n            pushStack.push(popStack.pop());\r\n        }\r\n        pushStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return popStack.isEmpty() && pushStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bin214":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085914856","body":"####思路\n\n按位取出数字k，依次加到数组A内，需注意产生的进位，如果数组首位仍有进位，则数组首部加一位\n\n\n\n#### 代码\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> ans = new ArrayList<>();\n    int n = num.length;\n    int sum = 0, flag = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        sum = (k % 10) + num[i] + flag;\n        k = k / 10;\n        if (sum >= 10) {\n            sum = sum % 10;\n            flag = 1;\n        } else {\n            flag = 0;\n        }\n        ans.add(sum);\n    }\n    while (k != 0){\n        ans.add(k % 10 + flag);\n        k = k / 10;\n        if(flag != 0) flag = 0;\n    }\n    if(flag != 0)\n        ans.add(1);\n    Collections.reverse(ans);\n    return ans;\n}\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：O(m + n)\n\n空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oision-hub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085926377","body":"### 思路\n逐位相加，若大于10则进位。\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        int len = num.size();\n        for (int i = len - 1; i >= 0; i--) {\n            int temp = num[i] + k % 10;\n            k = k / 10;\n            if (temp >= 10) {\n                k += 1;\n                temp = temp % 10;\n            }\n            result.push_back(temp);\n        }\n        while (k != 0) {\n            result.push_back(k % 10);\n            k = k / 10;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n```\n### 复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086650727","body":"### 思路\n将两边遍历的结果存入数组，留下较小的值\n### 解答\n``` c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans(s.size(), 0);\n        int left = INT_MAX;\n        int right = INT_MAX;\n        for(int i = 0; i < s.size(); i ++) {\n            if (s[i] == c) {\n                left = i;\n            }\n            ans[i] = i - left;\n        }\n        for(int i = s.size() - 1; i >= 0; i --) {\n            if (s[i] == c) {\n                right = i;\n            }\n            ans[i] = min(abs(ans[i]), right - i);\n        }\n        return ans;\n    }\n};\n```\n###  复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085927113","body":"func addToArrayForm(num []int, k int) []int {\n    for i := len(num) - 1; i >= 0; i-- {\n        num[i] += k % 10\n        k /= 10\n\n        // if overflow\n        if num[i] > 9 {\n            k++\n            num[i] -= 10\n        }\n    }\n\n    // if k length more than num length\n    for k > 0 {\n        num = append([]int{k % 10}, num...)\n        k /= 10\n    }\n\n    return num\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086666125","body":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestShortestDistanceToACharacter(t *testing.T) {\n\ts := \"loveleetcode\"\n\tvar c byte = 'e'\n\n\tchars := shortestDistanceToACharacter(s, c)\n\n\tfor _, v := range chars {\n\t\tfmt.Print(v, \"\\t\")\n\t}\n\tfmt.Println()\n\n}\n\nfunc shortestDistanceToACharacter(s string, c byte) []int {\n\tres := make([]int, len(s))\n\n\t// prevent overflow\n\tleft, right := math.MinInt32/2, math.MaxInt32/2\n\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == c {\n\t\t\tleft = i\n\t\t}\n\t\tres[i] = i - left\n\t}\n\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\tif s[i] == c {\n\t\t\tright = i\n\t\t}\n\t\tres[i] = min(res[i], right-i)\n\t}\n\n\treturn res\n}\n\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086868863","body":"```go\r\ntype CustomStack struct {\r\n    stack []int\r\n    size int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack {\r\n        make ([]int, 0),\r\n        maxSize,\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if len(this.stack) < this.size {\r\n        this.stack = append(this.stack, x)\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n   if len(this.stack) > 0  {\r\n       res := this.stack[len(this.stack) - 1]\r\n       this.stack = this.stack[:len(this.stack) - 1]\r\n       return  res\r\n   } else {\r\n      return -1 \r\n   }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > len(this.stack) {\r\n        k = len(this.stack)\r\n    } \r\n\r\n    for i := 0; i < k; i++ {\r\n        this.stack[i] += val\r\n    }\r\n}\r\n```\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * obj := Constructor(maxSize);\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * obj.Increment(k,val);\r\n */","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088720831","body":"```go\ntype MyQueue struct {\n    inStack, outStack []int\n}\n\n\nfunc Constructor() MyQueue {\n    return MyQueue{\n        inStack : make([]int, 0),\n        outStack : make([]int, 0),\n    }\n}\n\n\nfunc (q *MyQueue) Push(x int)  {\n    q.inStack = append(q.inStack, x)\n}\n\n\nfunc (q *MyQueue) Pop() int {\n    if len(q.outStack) == 0 {\n        for len(q.inStack) > 0 {\n            q.outStack = append(q.outStack, q.inStack[len(q.inStack) - 1])\n            q.inStack = q.inStack[:len(q.inStack) - 1]\n        }\n    }\n    x := q.outStack[len(q.outStack) - 1]\n    q.outStack = q.outStack[:len(q.outStack) - 1]\n\n    return x\n}\n\n\nfunc (q *MyQueue) Peek() int {\n    if len(q.outStack) == 0 {\n        for len(q.inStack) > 0 {\n            q.outStack = append(q.outStack, q.inStack[len(q.inStack) - 1])\n            q.inStack = q.inStack[:len(q.inStack) - 1]\n        }\n    }\n    x := q.outStack[len(q.outStack) - 1]\n    return x\n}\n\n\nfunc (q *MyQueue) Empty() bool {\n    return len(q.outStack) == 0 && len(q.inStack) == 0\n}\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Peek();\n * param_4 := obj.Empty();\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhishinaigai":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085936068","body":"### 思路\r\n浅抄一手答案\r\n\r\n### 代码\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector <int> ans;\r\n        int len=num.size();\r\n        \r\n        for(int i=len-1;i>=0;i--){\r\n            int s=num[i]+k%10;\r\n            k/=10;\r\n            if(s>=10){\r\n                k++;\r\n                s-=10;\r\n            }\r\n            ans.push_back(s);\r\n        }\r\n        while(k>0){\r\n            ans.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(ans.begin(),ans.end());\r\n        return ans;\r\n    }\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086652806","body":"### 思路\r\n今天也是抄答案的一天呢\r\n### 代码\r\n```\r\nvector<int> shortestToChar(string s, char c) {\r\n        vector<int> ans(s.size(),-1);\r\n        int len=s.size();\r\n        int p=-1;\r\n        for(int i=0;i<len;i++){\r\n            if(s[i]==c){\r\n                p=i;\r\n                ans[i]=0;\r\n            } \r\n            else if(p!=-1) ans[i]=i-p;\r\n        }\r\n        p=-1;\r\n        for(int i=len-1;i>=0;--i){\r\n            if(s[i]==c) p=i;\r\n            if(p!=-1) ans[i]=min(ans[i],p-i);\r\n            if(ans[i]==-1) ans[i]=p-i;\r\n             \r\n        }\r\n        return ans;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086847912","body":"### 思路\r\n使用vector实现\r\n### 代码\r\n```c\r\nclass CustomStack {\r\npublic:\r\n    vector <int> stk;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        top=-1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top!=stk.size()-1){\r\n            ++top;\r\n            stk[top]=x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if(top==-1) return -1;\r\n        --top;\r\n        return stk[top+1];\r\n\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim=min(k,top+1);\r\n        for(int i=0;i<lim;++i){\r\n            stk[i]+=val;\r\n        }\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087532217","body":"思路\r\n---\r\n\r\n抄答案都没看懂哇，字符串一生之敌\r\n\r\n代码\r\n---\r\n```c\r\nstring getDigits(string &s,size_t &ptr){\r\n        string ret=\"\";\r\n        while(isdigit(s[ptr])){\r\n            ret.push_back(s[ptr++]);\r\n        }\r\n        return ret;\r\n    }\r\n    string getString(vector<string> &v){\r\n        string ret;\r\n        for(const auto &s:v){\r\n            ret+=s;\r\n        }\r\n        return ret;\r\n    }\r\n    string decodeString(string s) {\r\n        int len=s.size();\r\n        vector <string> stk;\r\n        size_t i=0;\r\n\r\n        while(i<len){\r\n            char cur=s[i];\r\n            if(isdigit(cur)){\r\n                string digits=getDigits(s,i);\r\n                stk.push_back(digits);\r\n            }\r\n            else if(isalpha(cur)||cur=='['){\r\n                stk.push_back(string(1,s[i++]));\r\n            }\r\n            else{\r\n                ++i;\r\n                vector<string> sub;\r\n                while(stk.back()!=\"[\"){\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(),sub.end());\r\n                stk.pop_back();\r\n                int reptime=stoi(stk.back());\r\n                stk.pop_back();\r\n                string t,o=getString(sub);\r\n                while(reptime--) t+=o;\r\n                stk.push_back(t);\r\n            }\r\n        }\r\n        return getString(stk);\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088858579","body":"思路\r\n---\r\n\r\n两个栈一个in一个out\r\n\r\n代码\r\n---\r\n\r\n```c\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> ins,outs;\r\n    void in2out(){\r\n        while(!ins.empty()){\r\n            outs.push(ins.top());\r\n            ins.pop();\r\n        }\r\n    }\r\npublic:\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        ins.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(outs.empty()){\r\n            in2out();\r\n        }\r\n        int x=outs.top();\r\n        outs.pop();\r\n        return x;\r\n    }\r\n    \r\n    int peek() {\r\n        if(outs.empty()){\r\n            in2out();\r\n        }\r\n        return outs.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return ins.empty() && outs.empty();\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jasonhe-wq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938194","body":"思路：将列表中的数转化为整数，与k相加，再转化为可迭代对象，加入数组输出\n代码：\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s=''.join(str(i) for i in num)\n        n = str(eval(s)+k)\n        l = []\n        for i in n:\n            l.append(eval(i))\n        return l\n        \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086649828","body":"思路：\n对于每一个等于c的字符，在其两侧分别计算距离，而对于每个字符，距离取最小值\n优化方向：\n将等于c的字符分为首个，中间，末尾，分别控制不同的区域\n代码：\n'''\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        l = len(s)\n        ans = [l for i in range(l)]\n        for i in range(l):\n            if s[i] == c:\n                for j in range(l):\n                    ans[j]=min(ans[j],abs(i-j))\n        return ans\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086877618","body":"思路：\n构建数组作为栈，再用一个额外的变量存储maxsize，对于每个要相加的值，先判断长度是否小于k，再遍历\n```\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.num = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.num:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) <= k:\n            for i in range(len(self.stack)):\n                self.stack[i] += val\n        else:\n            for i in range(k):\n                self.stack[i] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087712391","body":"思路：\n每次遇到[记录下来位置，遇到]则将片段重复mul次，并将指针重新移动到最左端，重复操作\n对于数字，每次遇到时判断，如果与[相邻，则记为mul，否则舍去\n最后通过列表将序列中的数字全部去除\n代码：\n```class Solution:\n    def decodeString(self, s: str) -> str:\n        left = []\n        num = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        n = \"\"\n        s0 = \"\"\n        mul = 0\n        i = 0\n        ans =\"\"\n        nu = \"\"\n        while i <len(s):\n            if s[i] == \"[\":\n                left.append(i)\n                n = s[:i]\n                for j in n:\n                    if j in num:\n                        nu += j\n                    else:\n                        nu =\"\"\n                mul = eval(nu)\n                nu = \"\"\n                i += 1\n            elif s[i] == \"]\":\n                s0 = s[:left[-1]]+s[left[-1]+1:i] * mul+s[i+1:]\n                s = s0\n                i = 0\n            else:\n                i +=1\n        l = list(s)\n        for i in range(len(l)):\n            if l[i] in num:\n                pass\n            else:\n                ans += l[i]\n        return ans\n复杂度：O(n)还是O(n^2)我也不知道","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088377130","body":"思路：\n创建入栈和出栈列表，向入栈队列添加元素，当都为空时返回空，当出栈为空时，依次将入栈元素压入，再返回\n代码：\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.inStack = []\n        self.outStack = []\n\n\n    def push(self, x: int) -> None:\n        self.inStack.append(x)\n\n    def pop(self) -> int:\n        if not self.empty():\n            if self.outStack:\n                return self.outStack.pop()\n            else:\n                while self.inStack:\n                    self.outStack.append(self.inStack.pop())\n                return self.outStack.pop()\n        else:\n            return 0\n\n    def peek(self) -> int:\n        if self.empty():\n            return 0\n        if not self.outStack:            \n            while self.inStack:\n                self.outStack.append(self.inStack.pop())\n        val = self.pop()\n        self.outStack.append(val)\n        return val\n\n\n\n    def empty(self) -> bool:\n        if not (self.inStack or self.outStack):\n            return True\n        return False","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938263","body":"## 989. Add to Array-Form of Integer\n### 1. 思路\n- 基础思考点：transform a number to an int array\n```C\n// 代码实现\nvar array = [];\nvar k = 123;\nwhile (k >= 1) {\n  array.push(Math.floor(k % 10));\n  k /= 10;\n}\n// array: [1, 2, 3]\n```\n拓展上述代码，思路变为：\n> k 或 num 还有剩余位数时，resultArray 不断添加剩余数位\n### 2. 细节处理\n- 相加的结果会进位（这里我用了 num 来存储进位数据）\n  - 如果 num 数组还有数字，给数组的最后一位+1\n  - 如果 num 数组没有数字了，将数组的最后一位赋为 1\n- num 代表的数字，其位数和 k 的位数不一致\n  - 判断一下，确保 getK 和 getN 不会越位\n\n### 3. 复杂度\n- 时间：O(n)  \n  - while 的长度为 max(k的位数，num的位数);  \n  - while 内部涉及的数组操作:     \narray.pop(), array.push(), array[i] =，三者的时间复杂度为 O(1)\n- 空间：O(n)\n  - 新开了一个数组，O(n)\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nconst addToArrayForm = (num, k) => {\n  let temp = 0;\n  const resultArray = [];\n  while (k >= 1 || num.length) {\n    temp = getK(Math.floor(k % 10)) + getN(num);\n    resultArray.push(handleTemp(temp, num));\n\n    temp = 0;\n    k /= 10;\n  }\n  return resultArray.reverse();\n};\n\nconst getK = (kNum) => kNum >= 1 ? kNum : 0;\nconst getN = (num) => num.length ? num.pop() : 0;\nconst handleTemp = (temp, num) => {\n  if (temp >= 10) {\n    temp -= 10;\n    if (num.length) {\n      num[num.length - 1] += 1;\n    } else {\n      num[0] = 1;\n    }\n  }\n  return temp;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086504869","body":"821. Shortest Distance to a Character\n### 1. 思路\n- 基础思路\n  - 求数组中两个元素 i, j 的距离: i - j\n- 拓展\n  - 求 i 到左右两边 j、h 的最短距离  \n### 2. 细节\n  - j 的位置未知：\n    - 开一个线性数据结构，记录 j 的位置\n  - 离 i 最近的元素不一定是 j，i 可能还有左相邻、且距离更近的元素 h：\n    - 求最短距离时，比较 Math.min(Math.abs(i - j), Math.abs(i - h))\n  - i - j、i - h，索引不应越界  \n### 3. 复杂度\n- 时间：O(n)\n  - 遍历 s，且遍历内部无 O(n) 及以上层级的操作\n- 空间：O(n)\n  - 新开了 resultArr 数组\n\n```javascript\nvar shortestToChar = function(s, c) {\n  const cHash = new Array(s.length).fill(0);\n  let cHashStart = 0;\n  const resultArr = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      cHash[cHashStart] = i;\n      cHashStart++;\n      resultArr[i] = 0;\n    }\n  }\n  cHashStart = 0;\n  cHashPrev = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (i !== cHash[cHashStart]) {\n      cHashPrev = cHashStart > 0 ? cHashStart - 1 : 0;\n      const shortestGap = Math.min(\n        Math.abs(cHash[cHashPrev] - i),\n        Math.abs(cHash[cHashStart] - i)\n      );\n      resultArr[i] = shortestGap;\n    } else {\n      cHashStart++;\n    }\n  }\n  return resultArr;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086889454","body":"```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length < this.maxSize) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.pop() || -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (this.stack[i]) { this.stack[i] += val; }\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n### Complexity\n- time\n  - inc: O(n), pop/push: O(1)\n- space\n  - O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088214516","body":"## 232. 用栈实现队列\n\n## 思路\n- 基本思路\n  - 问题：删除数组开头元素，时间复杂度相对较高\n  - 解决办法：用两个栈实现队列\n- 两个栈实现队列细节\n  - 栈 2、栈 1 的作用\n    - 栈 1 用于入栈，栈 2 用于出栈\n  - 栈 2 、栈 1 的关系\n    - 栈 2 即倒过来的栈 1：栈 1 最前面的元素，会被推到栈 2 末尾\n  - 栈 2 和栈 1 联合，对消减时间复杂度的贡献\n    - 删除栈 1 的开头元素，即变为删除栈 2 的末尾元素，O(N) => O(1)\n\n## 复杂度\n- 空间复杂度 O(N)\n- 时间复杂度\n  - 摊还时间复杂度 O(1)\n    - 最坏情况 O(N)：栈 2 为空，需要 for loop 挤压栈 1 时 \n    - 最好情况 O(1)\n\n## 摊还分析\n- 摊还分析的核心\n  - 高频次操作的时间复杂度小 + 低频次操作的时间复杂度高，二者均摊了每次操作的代价\n  - 即，每 n 次入队才能产生一次代价为 n 的出队操作\n- 所有操作的总时间复杂度\n  >  O(2N) = n(所有的入队操作产生） + 2 * n(第一次出队操作产生） + n - 1(剩下的出队操作产生）\n- 综上所述，每次操作的平均时间复杂度为 O(2N/2N)=O(1)\n\n## 代码\n```\nvar MyQueue = function() {\n  this.queue1 = [];\n  this.queue2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.queue1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  this.cleanQ1();\n  return this.queue2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  this.cleanQ1();\n  return this.queue2[this.queue2.length - 1];\n};\n\nMyQueue.prototype.cleanQ1 = function() {\n  if (this.queue2.length === 0) {\n    const q1Len = this.queue1.length;\n    for (let i = 0; i < q1Len; i++) {\n      this.queue2.push(this.queue1.pop());\n    }\n  }\n}\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.queue1.length === 0 && this.queue2.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"divingcub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938282","body":"## Idea\r\nBackward iteration, 考虑位进.\r\n\r\n## Code \r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> sum = new ArrayList<Integer>();\r\n        int length = num.length;\r\n        num[length - 1] += k;\r\n        for (int i = length - 1; i > 0; i--) {\r\n            int curNum = num[i];\r\n            if (curNum > 9) {\r\n                num[i - 1] += curNum / 10;\r\n                num[i] %= 10;\r\n            }\r\n            sum.add(num[i]);\r\n        }\r\n        do {\r\n            sum.add(num[0] % 10);\r\n            num[0] /= 10;\r\n        } while (num[0] > 0);\r\n        Collections.reverse(sum);\r\n        return sum;\r\n    }\r\n}\r\n\r\n## Complexity\r\nTime:O(n)\r\nSpace: O(1)\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087690980","body":"## 思路\n\n遇见非 ']' 都直接进行进栈操作，见 ']' 则进行扫描栈内，和上面一个匹配 ']' 的 '['，然后统计出匹配括号内的所有字符，接着将 匹配到 '[' 最近的数字出栈，然后再按照数字倍数 重新将统计到的字符进行进栈操作，最后只要依次出战所有元素。\n\n##代码\n\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c == ']'){\n          \n                StringBuilder temp = new StringBuilder();\n                while(!stack.isEmpty() && Character.isLetter(stack.peek())){\n                    temp.insert(0,stack.pop());\n                }\n            \n                String tempString = temp.toString();\n                stack.pop();\n            \n                temp = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    temp.insert(0,stack.pop());\n                }\n                int count = Integer.parseInt(temp.toString());\n              \n                while(count > 0){\n                    for(char ch : tempString.toCharArray()){\n                        stack.push(ch);\n                    }\n                    count--;\n                }\n            }else{\n            \n                stack.push(c);\n            }\n        }\n    \n        StringBuilder ans = new StringBuilder();\n        while(!stack.isEmpty()){\n            ans.insert(0,stack.pop());\n        }\n        return ans.toString();\n    }\n}\n\n\n##复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088900557","body":"## 思路部分\n\n双栈实现的思想\n\n## 代码实现部分\n\n```\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        while (!stack1.isEmpty()){\n            stack2.push(stack1.pop());\n        }\n        stack1.push(x);\n        while (!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n    }\n\n    public int pop() {\n        return stack1.pop();\n    }\n\n    public int peek() {\n        return stack1.peek();\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n\n## 复杂度\n\n1. O(N)  -- 时间复杂度\n2. O(N) --  空间复杂度\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaru-zhang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085944030","body":"# 思路\r\n- 由于直接循环将数组取出来相加长度可能会超出，所以按倒序取出数组，依次相加取余放进数组\r\n- 可能会出现加完后k值为个位数的情况，所以多加个判断，将剩余数也加入数组\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        n = len(A)\r\n        ans = []\r\n\r\n        for i in range(n-1, -1, -1):\r\n            total = A[i] + K % 10\r\n\r\n            K //= 10\r\n            \r\n            if total >= 10:\r\n                #当前位相加结果大于 10 时，进位 1 加入下一位计算\r\n                K += 1\r\n\r\n            ans.append(total % 10)\r\n            \r\n        # 这里考虑数组 A 的长度小于整数 K 位数个数的情况\r\n        while K > 0:\r\n            ans.append(K % 10)\r\n            K //= 10\r\n        # 因为添加进来是由低位往高位，输出时进行逆序输出\r\n        return ans[::-1]\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086878823","body":"# 思路\r\n使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置。\r\n# 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087655547","body":"# 思路\r\n将数字、字母、[一个一个加入到栈中；\r\n如果遇到],就从栈中取出字母，直到遇到[\r\n将[去掉，然后从栈中取出数字（判断是否为数字，因为可能有多个）\r\n重复这些字母\r\n重复以上\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```\r\n# 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088709573","body":"# 思路\r\n采用辅助栈\r\n# 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.help_stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack)\r\n```\r\n# 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cshowww":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085951022","body":"## 代码\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int n = num.length;\n        for(int i=n-1;i>=0;i--){\n            int sum = k%10 + num[i];\n            k = k/10;\n            if(sum >= 10){\n                sum = sum-10;\n                k++;\n            }\n            res.add(0,sum);\n        }\n\n        while(k > 0){\n            res.add(0,k%10);\n            k = k/10;\n        }\n        return res;\n    }\n}\n```\n\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661223","body":"## 代码\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int prev = Integer.MIN_VALUE/2;\n        int n = s.length();\n        int ans[] = new int[n];\n\n        for(int i=0;i<n;i++){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = i-prev;\n        }\n        prev = Integer.MAX_VALUE/2;\n        for(int i=n-1;i>=0;i--){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i],prev-i);\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(n)\n\n## 思路\n双指针，两次遍历，一次从头到尾，一次从尾到头。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086896699","body":"## 代码\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top<stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top==-1){\n            return -1;\n        }else{\n            return stack[top--];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k;i++){\n            if(i<=top){\n                stack[i] += val;\n            }else{\n                break;\n            }\n        }\n    }\n}\n\n\n## 复杂度\n时间： O(1)  \n空间： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086899934","body":"## 思路\n使用栈，遇到‘]’弹出元素，对字母和数字分别转成string和int，然后再运算结果压栈。\n\n## 代码\n```\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c != ']'){\n                stack.push(c);\n            }\n            else{\n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek()!='['){\n                    sb.insert(0,stack.pop());\n                }\n                String sub = sb.toString();\n\n                stack.pop();\n\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    sb.insert(0,stack.pop());\n                }\n                int count = Integer.parseInt(sb.toString());\n\n                while(count > 0){\n                    for(char ch : sub.toCharArray()){\n                        stack.push(ch);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty()){\n            res.insert(0,stack.pop());\n        }\n        return res.toString();\n    }\n}\n```\n\n## 复杂度\n空间：O(n)  \n时间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kesucaso":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085955510","body":"#思路\n\nnum数组中的每个数字与k中的对应位置的数字相加，然后如果对应位置相加大于10，则进位到高位的位置上去。\n\n#代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        for i in range(len(num)-1,-1,-1):\n            n = num[i]+k%10\n            k=k//10\n            if n>=10:\n                ans.append(n%10)\n                k+=1\n            else:\n                ans.append(n)\n        while k>=1:\n            ans.append(k%10)\n            k=k//10\n        return ans[::-1]\n```\n\n#复杂度分析\n\n时间复杂度：O(n) （遍历数组）\n\n空间复杂度：O(n) （返回的数组大小）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661051","body":"# 思路\n\n从后往前遍历，遇到等于C的字符就把pre指针置为当前的索引，然后对答案数组进行修改。再从前往后遍历，也是遇到等于C的字符就把pre指针置为当前的索引，对答案数组修改的时候需要对比刚刚已经修改的值和当前赋的值的中选最小值。\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [0]*len(s)\n        pre = float(\"inf\")\n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                pre = i\n            ans[i]=pre-i\n        pre = float(\"-inf\")\n        for i in range(len(s)):\n            if s[i]==c:\n                pre = i\n            ans[i]=min(abs(pre-i),ans[i])\n        return ans\n```\n\n# 复杂度分析\n\n时间：O(n)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086886054","body":"# 思路\n\n因为栈的大小固定，所以可以根据索引方便定位每个元素。简单模拟就行。\n\n# 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            x = self.stack.pop()\n            return x\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i>=len(self.stack):\n                break\n            else:\n                self.stack[i]+=val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087716035","body":"# 思路\n\n使用栈。如果遇到”[“，那就把之前的字符和数字压入栈中，然后将字符置零，任何遇到”]“就把刚刚存在栈里面的字符加上括号里的字符。依次这样做。\n\n# 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        num = 0\n        ans = \"\"\n        for i in s:\n            if i.isdigit():\n                num = num*10+int(i)\n            elif i==\"[\":\n                stack.append([ans,num])\n                # print(stack)\n                ans = \"\" #保存了之后就清零，开始存储括号里面的字符\n                num = 0\n            elif i==\"]\":\n                content = stack.pop()\n                ans = content[0]+content[1]*ans\n            else:\n                ans+=i\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088876125","body":"# 思路\n\n用两个栈来实现队列。一个栈用来push，一个栈用来pop。\n\n# 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.pushstack = []\n        self.popstack = []\n\n    def push(self, x: int) -> None:\n        self.pushstack.append(x)\n\n    def pop(self) -> int:\n        if self.popstack:\n            ans = self.popstack.pop()\n            return ans\n        while self.pushstack:\n            temp = self.pushstack.pop()\n            self.popstack.append(temp)\n\n        return self.popstack.pop()\n\n    def peek(self) -> int:\n        if self.popstack:\n            ans = self.popstack[-1]\n            return ans\n        while self.pushstack:\n            temp = self.pushstack.pop()\n            self.popstack.append(temp)\n\n        return self.popstack[-1]\n\n    def empty(self) -> bool:\n        return self.pushstack==[] and self.popstack==[]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testeducative":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085957096","body":"```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int tmp = 0;\n        for(int i = num.size() - 1; i >= 0; i--){\n            tmp = num[i] + k % 10;\n            k /= 10;\n            if(tmp >= 10){\n                tmp = tmp % 10;\n                k++;\n            }\n            res.push_back(tmp);\n        }\n\n        for( ; k > 0; k/=10){\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088755614","body":"\n```c++\nclass MyQueue {\nprivate:\n    stack<int> s1;\n    stack<int> s2;\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        if(s2.empty()){\n            while(!s1.empty()){\n                int tmp = s1.top();\n                s1.pop();\n                s2.push(tmp);\n            }\n        }\n        int top_v = s2.top();\n        s2.pop();\n        return top_v;\n    }\n    \n    int peek() {\n        if(s2.empty()){\n            while(!s1.empty()){\n                int tmp = s1.top();\n                s1.pop();\n                s2.push(tmp);\n            }\n        }\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hzhengzhi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085962315","body":"##思路\r\nnum从后向前进行运行，每次都用k和对应位置上数字进行相加，若相加结果大于10，则携带进位前往下一位。\r\n如果num结束后，k中仍然剩余部分数字，直接进行求余即可。\r\n```\r\n public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans= new ArrayList<>();\r\n        for(int i=num.length-1;i>=0;i--)\r\n        {\r\n            ans.add(0,(num[i]+k)%10);\r\n            k=(k+num[i])/10;\r\n        }\r\n        while(k!=0)\r\n        {\r\n            ans.add(0,k%10);\r\n            k=k/10;\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n##复杂度\r\n时间复杂度O(n)\r\n空间复杂度O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085969554","body":"**Thoughts**\nAdding up by digits.\nIn the array, we start from the last element.\nFor the integer k, each time we use the last digit (k % 10),\nif the sum is bigger than 9, add 1 to k(so we don't need another var to record it).\nAfter the loop, deal with the case k > 0 (maybe k is too big or we have addup).\n\n**Code**\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum > 9) {\n               k += 1;\n               sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n**Time Complexity**\nTime: O(N), one for loop\nSpace: O(1), use one arraylist as result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086529915","body":"**Thoughts**\n1. Get all indices of c, go through s to compare i with indices of c\n2. Traverse s from left side and right side, record the last index of c , so `i - prev` and `prev - i` is the distance for each traverse, at last compare and select the smaller one\n\n**Code**\n```jave\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        ArrayList<Integer> list = new ArrayList<>();\n        int[] res = new int[n];\n        int p = 0; \n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                list.add(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p < list.size() - 1 && Math.abs(list.get(p) - i) > Math.abs(list.get(p + 1) - i)) {\n                p++;\n            }\n            res[i] = Math.abs(list.get(p) - i);\n        }\n        return res;\n    }\n```\n**Time Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086767250","body":"**Thoughts**\n\nUse an array to simulate the stack, top var to record the index of the top value\nAlso, use another array to record the value needed to be added. Addition only happens with Popping, if PoP() is called, we start from the top value, add stack\\[top] with add\\[top], then we add the val in add\\[top] to the previous one add\\[top - 1], make sure the index in two array are  consistent\n\n**Code**\n```java\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if (top != 0) {\n            add[top - 1] += add[top];\n        }\n        add[top] = 0; \n        top--;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k - 1, top);\n        if (limit >= 0) {\n            add[limit] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n**Complexity**\nTime: O(1) for all operations\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086926037","body":"**Thoughts**\n1. Using two stacks to record the number and characters\n2. Traversing s, when it's number(digit), push(c);\n\t\t\twhen it's `[`, save current sb to stack;\n\t\t\twhen it's `]`, do the multiplication;\n\t\t\twhen it's char, append to sb\n\t\t\t\n**Code**\n```java\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        int multi = 0;\n        Deque<Integer> stack = new LinkedList<>();\n        Deque<StringBuilder> sbStack = new LinkedList<>();\n        for (Character c: s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                multi = multi * 10 + c - '0';\n            } else if (c == '[') {\n                stack.push(multi);\n                sbStack.push(sb);\n                multi = 0;\n                sb = new StringBuilder();\n            } else if (c == ']') {\n                StringBuilder tmp = sbStack.pop();\n                int count = stack.pop();\n                for (int i = 0; i < count; i++) {\n                    tmp.append(sb.toString());\n                }\n                sb = tmp;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087854700","body":"**Thoughts**\nUsing two stacks to stimulate the FIFO sequence, one var to record the front element of the queue\n\n**Code**\n```java\nclass MyQueue {\n    Stack<Integer> stack1 = new Stack<>();\n    Stack<Integer> stack2 = new Stack<>();\n    int front;\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        if (stack1.isEmpty()) {\n            front = x;\n        }\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        stack2.push(x);\n        while(!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n    }\n    \n    public int pop() {\n        int top = stack1.pop();\n        if (!stack1.isEmpty()){\n            front = stack1.peek();\n        }\n        return top;\n    }\n    \n    public int peek() {\n        return front;\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n**Complexity**\n* Time: O(1), Push and Pop are constant time\n* Space: O(1) no extra space used","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"antmup":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085970492","body":"### 思路\n1、首先将数组转换为对应的数字；\n2、将两个数字相加；\n3、将最终的数字拆解为数组；\n\n### 代码\n\n``` js\nfunction intSumOfArray(initNumArray, Addend) {\n  // 第一步\n  const initNum = +initNumArray.join('');\n\n  // 第二步\n  const tempSum = String(initNum + Addend);\n  console.log(tempSum, 'tempSum');\n  // 第三步\n  return  tempSum.split('').map(Number);\n}\n\nconsole.log(intSumOfArray([1, 2, 0, 0], 34));\nconsole.log(intSumOfArray([2, 7, 4], 181));\nconsole.log(intSumOfArray([2, 1, 5], 806));\n\n```\n\n** 复杂度分析 **\n- 时间复杂度：O(n)，\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086651757","body":"### 思路\n1、首先找到字符在数组中的下标数组；\n2、先处理第一个字符之前的，以及最后一个字符之后；\n3、如果当前元素等于目标字符，在数组中 push 0；\n4、处理两个字符中间的距离问题；\n\n### 代码\n\n``` js\nfunction beelineOfCharacter(targetString, targetCharacter) {\n  // 判断目标字符是否处在数组字符串的末尾\n  const isEnd = targetString[targetString.length - 1] === targetCharacter;\n  console.log(isEnd);\n\n  // 寻找目标字符在数组当中的位置\n  let targetCharIndex = [];\n  for (let i = 0; i < targetString.length; i++) {\n    if (targetString[i] === targetCharacter) {\n      targetCharIndex.push(i);\n    }\n  }\n  console.log(targetCharIndex, 'targetCharIndex');\n\n  let finalArray = [];\n  for (let j = 0; j < targetString.length; j ++) {\n    const item = targetString[j];\n    console.log(targetString[j], '1111');\n    // 等于目标元素就push0\n    if (item === targetCharacter) {\n      finalArray.push(0);\n    }\n\n    // 处理第一个目标字符之前的元素\n    const firstCharIndex = targetCharIndex[0];\n    if (j < firstCharIndex) {\n      const tempArray = numberToIndex(firstCharIndex);\n      finalArray.concat(tempArray);\n    }\n    \n  }\n  \n}\n\nfunction numberToIndex(number) {\n  let indexArray = [];\n  for (let i = 0; i < number; i++) {\n    indexArray.unshift(i);\n  }\n  indexArray.pop()\n\n  return indexArray;\n}\n\n\nbeelineOfCharacter('acd', 'c')\n\n```\n\n** 复杂度分析 **\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jax-van":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085972190","body":"## idea\n从低位往高位相加，并处理进位，可以用k同时存储进位信息，每次迭代有 k = (num[i] + k) / 10\n## code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            res.add(0, (num[i] + k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k != 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n```\n## complexity\n- time: O(max(len(num), digit(k))\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646210","body":"## idea\n左右遍历数组\n## code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = Math.min(res[i], pre - i);\n        }\n        return res;\n    }\n}\n```\n## complexity\n- time: O(n)\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086874987","body":"## idea\n数组实现栈\n## code\n```java\nclass CustomStack {\n    int[] stack;\n    int top = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (top < stack.length) {\n            stack[top++] = x;\n        }\n    }\n    \n    public int pop() {\n        return top != 0 ? stack[--top] : -1;\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < top; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n## complexity\n- time: push, pop = O(1), increment = O(min(k, top))\n- space: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087174643","body":"## 辅助栈\n解码顺序是由内向外，先解码里面的括号再解码外面的括号，而遍历字符串是先遇到外面的括号再遇到里面的括号，符合栈先进后出原则，需要用到两个辅助栈multiStack、resStack，一个由存字符串，一个存数字，两个变量mutil、res存储将要存进栈的元素，则遍历思路为：\n1. 遇到 \\[ 将multi、res存进栈待用，变量重置\n2. 遇到 \\] 从multiStack获取解码倍数，从resStack获取解码字符串的前缀，得到的解码字符串 tmp = resStack.pop() + res * multiStack.pop()，再将解码字符串存储在res中\n3. 遇到数字，作为multi的最低位 \n4. 遇到其他，添加到res的尾部\n5. 遍历结束后res，即最终解码字符串就是答案\n## 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<String> resStack = new LinkedList<>();\n        Deque<Integer> multiStack = new LinkedList<>();\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '[') {\n                multiStack.push(multi);\n                multi = 0;\n                resStack.push(res.toString());\n                res = new StringBuilder();\n            } else if (ch == ']') {\n                StringBuilder tmp = new StringBuilder();\n                tmp.append(resStack.pop());\n                int curMulti = multiStack.pop();\n                for (int i = 0; i < curMulti; i++) {\n                    tmp.append(res);\n                }\n                res = tmp;\n            } else if (Character.isDigit(ch)) {\n                multi = multi * 10 + ch - '0';\n            } else {\n                res.append(ch);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n## 复杂度\n- 时间：O(len(s))\n- 空间：栈空间，O(len(s))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088293928","body":"## idea\n双辅助栈实现队列\n## code\n```java\nclass MyQueue {\n    Deque<Integer> pushStack = new LinkedList<>();\n    Deque<Integer> popStack = new LinkedList<>();\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n## complexity\n- time: O(n)\n- space: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"webcoder-hk":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085977131","body":"```python\r\n# 都转成整数相加，再转成数组\r\nfrom typing import *\r\nfrom functools import reduce\r\n\r\ndef solution(a:List[int], b:int)->List[int]:\r\n    x = reduce(lambda x,y:x*10+y, a)\r\n    x += b\r\n    result = []\r\n    r = x%10\r\n    x //= 10\r\n    while x or r:\r\n        result.append(r)\r\n        r = x%10\r\n        x //= 10\r\n    result.reverse()\r\n    return result\r\n```\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086565255","body":"```python\r\n# 先正向遍历数组标出不等于C得字符，再反向遍历数组利用正向遍历留下得信息算出所需结果。\r\nclass Solution:\r\n    def shortestDistance(self, S:str, C:str)-> List[int]:\r\n        n = len(S)\r\n        result = [0 for _ in range(n)]\r\n        j = 0\r\n        for i in range(n):\r\n            if S[i]!=C:\r\n                j += 1\r\n                result[i] = j\r\n            else:\r\n                j = 0\r\n        j = 0\r\n        for i in range(n-1, -1, -1):\r\n            if S[i] != C:\r\n                j += 1\r\n                if i-result[i]>=0 and result[i-result[i]]==0:\r\n                    result[i] = min(result[i], j)\r\n                else:\r\n                    result[i] = j\r\n            else:\r\n                j = 0\r\n        return result\r\n```\r\ntime: O(2n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086866910","body":"```python\nclass CustomStack:\n    def __init__(self, maxSize):\n        self.maxSize = maxSize\n        self.data = []\n        \n    def push(self, x):\n        if len(self.data) < self.maxSize:\n            self.data.append(x)\n            \n    def pop(self):\n        if len(self.data) > 0:\n            return self.data.pop()\n        else:\n            return -1\n\n    def increment(self, k, v):\n        n = min(len(self.data), k)\n        for i in range(n):\n            self.data[i] += v\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087459907","body":"```python\nclass Solution(object):\n    def decodeString(self, s):\n        stack, res, n = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append((n, res))\n                res, n = \"\", 0\n            elif c == ']':\n                cur_n, last_res = stack.pop()\n                res = last_res + cur_n * res\n            elif '0' <= c <= '9':\n                n = n * 10 + int(c)            \n            else:\n                res += c\n        return res\n```\ntime: O(n)\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088518859","body":"```python\nclass MyQueue(object):\n    def __init__(self):\n        self.stack = MyStack()\n        self.tmp = MyStack()\n\n    def push(self, x):\n        while self.stack.size()>0:\n            self.tmp.push(self.stack.pop())\n        self.stack.push(x)\n        while self.tmp.size()>0:\n            self.stack.push(self.tmp.pop())\n\n    def pop(self):\n        if self.stack.size()>0:\n            return self.stack.pop()\n\n    def peek(self):\n        if self.stack.size()>0:\n            return self.stack.peek()\n\n    def empty(self):\n        return self.stack.empty()\n    \nclass MyStack(object):\n    def __init__(self):\n        self.data = []\n\n    def push(self, x):\n        self.data.append(x)\n\n    def pop(self):\n        if len(self.data)>0:\n            return self.data.pop()\n            \n    def peek(self):\n        if len(self.data)>0:\n            return self.data[-1]\n\n    def empty(self):\n        return len(self.data)==0\n    \n    def size(self):\n        return len(self.data)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bluerui":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085981416","body":"# Problem [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/)\n## Algorithm\n1. Add *k* to each digit of num from the lowest digit.\n2. Then *k%10* is saved to result as the new digit, and *k/10* is used as the new *k* for next digit.\n3. The drawback of this method is if *k* is very close to MAX_VALUE (within 10), then there could be overflow.\n\n## Complexity\n* Time complexity: O(max(num.length, logK))\n* Space complexity: O(max(num.length, logK))\n\n## Code\nLanguage: Java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> result = new ArrayList<>();\n    int cur = k;\n    int i = num.length - 1;\n    while (i >= 0 || cur > 0) {\n        if (i >= 0) {\n            cur += num[i];\n        }\n        result.add(cur % 10);\n        cur /= 10;\n        i--;\n    }\n    Collections.reverse(result);\n    return result;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665460","body":"# Problem [821. Shortest Distance to a Character](https://leetcode.com/problems/shortest-distance-to-a-character/)\r\n\r\n## Algorithm\r\n1. Walk through the array from the left to find the closest char c to the right of each char in s.\r\n2. Then work through the array from the right to find the closest char c to the left of each char in s.\r\n3. Find the min distance of step 1 and 2.\r\n4. Step 2 and 3 can be combined.\r\n\r\n## Complexity\r\n* Time Complexity: We are going over the array exactly twice. O(N)\r\n* Space Complexity: We can use the same output array, so no extra space. O(1)\r\n\r\n## Code\r\nLanguage: Java\r\n```Java\r\npublic int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] result = new int[n];\r\n        Arrays.fill(result, n);\r\n        // Find closest c on the right of each char\r\n        int cur = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) != c) {\r\n                continue;\r\n            }\r\n            while (cur <= i) {\r\n                result[cur] = i - cur;\r\n                cur++;\r\n            }\r\n        }\r\n\r\n        // Update to get the closest c from both sides by comparing left side\r\n        cur = n - 1;\r\n        for (int i = n - 1; i >=0; i--) {\r\n            if (s.charAt(i) != c) {\r\n                continue;\r\n            }\r\n            while (cur >= i) {\r\n                result[cur] = Math.min(result[cur], cur - i);\r\n                cur--;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086891831","body":"# Problem: [1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n## Algorithm\n* Use an array to implement ths stack\n* Use *index* to track the current number of elements in the array and the top of the stack.\n\n## Complexity\n* *push* operation time complexity is O(1) since we simply assign one value to the current index of the array.\n* *pop* operation time complexity is O(1).\n* *inc* operation time complexity is O(k) where k is the number of elements to increment.\n* Total space complexity of the stack is O(n) where n is the maxSize.\n\n## Code\nLanguage: Java\n```java\nclass CustomStack {\n    private int[] stack;\n    private int index = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (index == stack.length) {\n            return;\n        }\n        stack[index++] = x;\n    }\n    \n    public int pop() {\n        if (index == 0) {\n            return -1;\n        }    \n        return stack[--index];\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k; i++) {\n            if (i + 1 > index) {\n                return;\n            }\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087060502","body":"# Problem [394. Decode String](https://leetcode.com/problems/decode-string/)\n\n## Algorithm\n* Iterate over each character in the string and use a stack to keep track of visited character.\n  1. Keep pushing to the stack until we hit a ']' in string.\n  2. When we hit a ']' in string.\n     1. Keep popping from stack and form a substring until we get a '[' from stack.\n     2. Keep popping digits from stack until it is no longer a digit.\n     3. Convert popped out digits to a multiplier of the substring.\n     4. Decode the substring and push the decoded substring to the stack.\n\n## Complexity\nTime Complexity: O(N) where N is the length of the decoded string.\nSpace Complexity: O(N) where N is the length of the decoded string.\n\n## Code\nLanguage: Java\n\n``` Java\npublic String decodeString(String s) {\n   Deque<Character> stack = new ArrayDeque<>();\n   for (char c : s.toCharArray()) {\n       if (c != ']') {\n           stack.addFirst(c);\n           continue;\n       }\n       List<Character> decodedStr = new ArrayList<>();\n       while (stack.peekFirst() != '[') {\n           decodedStr.add(stack.removeFirst());\n       }\n       // Remove '['\n       stack.removeFirst();\n       \n       // Get multiplier\n       int num = 0;\n       int base = 1;\n       // Important to check if stack is empty first\n       while (!stack.isEmpty() && Character.isDigit(stack.peekFirst())) {\n           // It is very important to keep track of base, as the lower digits may be 0s like \"100\"\n           // Simply using num = num * 10 + stack.removeFirst() - '0' won't work.\n           num = num + (stack.removeFirst() - '0') * base;\n           base *= 10;\n       }\n       \n       // Put decoded string back to stack\n       for (int i = 0; i < num; i++) {\n           for (int j = decodedStr.size() - 1; j >= 0; j--) {\n               stack.addFirst(decodedStr.get(j));\n           }\n       } \n   }\n   char[] result = new char[stack.size()];\n   for (int i = stack.size() - 1; i >= 0; i--) {\n       result[i] = stack.removeFirst();\n   }\n   return new String(result);        \n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088222950","body":"# Problem [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)\r\n\r\n## Algorithm\r\n* Use two stacks to implement the queue: inStack and outStack.\r\n* Each element will be first pushed into inStack.\r\n* If outStack is not empty, we will pop from outStack. If outStack is empty, when pop/peek is called on the queue, we pop all elements in inStack and push them to outStack. After this, the head of the queue is at the top of outStack.\r\n\r\n## Complexity\r\n* *push()*: time complexity O(1).\r\n* *pop()*: amortized time complexity O(1). Each element will only be moved from inStack to outStack once with a total time of O(n). If we pop *n* times, the amortized time for each *pop()* is O(1).\r\n* *peek()*: same as *pop()*.\r\n\r\n## Code\r\nLanguage: Java\r\n\r\n``` Java\r\nclass MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inStack = new ArrayDeque<>();\r\n        outStack = new ArrayDeque<>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inStack.addFirst(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            top();\r\n        }\r\n        return outStack.removeFirst();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            top();\r\n        }\r\n        return outStack.peekFirst();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void top() {\r\n        // move all elements from inStack to outStack\r\n        while (!inStack.isEmpty()) {\r\n            outStack.addFirst(inStack.removeFirst());\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mrorz0914":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086000216","body":" public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans= new ArrayList<>();\n        for(int i=num.length-1;i>=0;i--)\n        {\n            ans.add(0,(num[i]+k)%10);\n            k=(k+num[i])/10;\n        }\n        while(k!=0)\n        {\n            ans.add(0,k%10);\n            k=k/10;\n        }\n        return ans;\n    }\n##复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duantao74520":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086000316","body":"### 思路：\n\n小学加法，大于10进一，从个位开始加，将结果塞到数组，最终返回数组时，翻转一下数组。\n\n例如【2,1,5】 与 806\n\n1. 遍历数组，初始化进位为0\n\n   5 + 8 + 0 = 11 ，塞1， 进位1。\n\n   1 + 0 + 1 = 2    ，塞2， 进位0\n\n   2 + 8 + 0 = 10  ，塞0， 进位1\n\n   关键在遍历完数组后，k 有可能为0 ，但是进位可能为1.\n\n2. 特殊处理以上情况\n\n   k += 进位\n\n   这样的话，k为0 ，构造成1， k非0，刚好可以进位\n\n3. 遍历剩余的k，每次除10\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ret_vec;\n        int up = 0;\n        // 遍历num\n        for (int pos = num.size() - 1 ; pos >= 0; pos--) {\n            int a = num[pos];\n            int b = k % 10;\n            k = k / 10;\n            ret_vec.emplace_back((a + b + up) % 10);\n            up = (a + b + up) /10;\n        }\n        k = k + up; // 防止有进位 k 还等于0的情况\n        while (k > 0) {\n            ret_vec.emplace_back(k % 10 );\n            k = k /10;\n        }\n         std::reverse(ret_vec.begin(), ret_vec.end());\n         return ret_vec;\n    }\n};\n```\n\n### 复杂度：\n\n1. 空间复杂度 O(1)\n\n2. 时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086631015","body":"### 思路：\n\n维护两个指针，一个代表着离左边的c的位置，一个代表着离右边的c的位置\n\n遍历数组：\n\n1. 从左往右遍历s1，直到找到c，然后赋值左右c。\n2. 再次从左往右遍历s2，开始记录离左右两边最近的c。\n3. 直到s2遍历到c的位置，继续遍历上一个遍历队列s1,直到数组尽头\n4. 继续遍历s2，输出位置\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n       int c_l = -1, c_r = -1;\n        int i = 0, j = 0;\n        vector<int> ret_vec;\n        while (j < s.size()) {\n            for (i ; i < s.size(); i++) {\n                if (s[i] == c) {\n                    c_l = c_r;\n                    c_r = i;\n                    if (c_l == -1) { // 第一个c\n                        c_l = c_r;\n                    }\n\t\t\t\t\ti++;\n                    break;\n                }\n                if (i == s.size()-1) { // 最后一个c\n                    c_l = c_r;\n                }\n            }\n            for (j ; j < i; j++) {\n                ret_vec.emplace_back(min(abs(j - c_l) , abs(j-c_r)));\n            }\n\t\t\tcout << c_l << c_r << i << j <<endl;\n        }\n        return ret_vec;\n    }\n};\n```\n\n### 复杂度：\n\n时间： o(n)\n\n空间： o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086849106","body":"### 思路：\n\n正常模拟栈的操作，用top代表栈顶，maxSize代表着最大的数组长度\n\n### 代码：\n\n```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        my_stack =  new vector<int>(maxSize);\n        top = -1;\n        max_size = maxSize;\n    }\n    \n    void push(int x) {\n        if (top < max_size - 1) {\n            top ++;\n            (*my_stack)[top] = x;\n        } else {\n            return;\n        }\n    }\n    \n    int pop() {\n        if (top >= 0) {\n            top --;\n            return (*my_stack)[top+1];\n        } else {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i <= top && i < k; i++) {\n            (*my_stack)[i] += val;\n        }\n    }\nprivate:\n    vector<int>* my_stack;\n    int max_size;\n    int top;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n### 复杂度：\n\n时间： add/top: O(1)  inc:O(N)\n\n空间复杂度： O(N);\n\n### 改进一：\n\n由于只有pop的时候才会取数，那么我们可以存一个add的数组，代表着所有增加的值。\n\n比如：\n\n- 调用了 increment(3, 2)，就把 increment[3] 增加 2。\n- 继续调用 increment(2, 5)，就把 increment[2] 增加 5。\n\n![img](https://tva1.sinaimg.cn/large/0081Kckwly1glwx1ryzxpj31jq0hijte.jpg)\n\n而当我们 pop 的时候：\n\n- 只需要将栈顶元素**加上 increment[cnt - 1]** 即可， 其中 cnt 为栈当前的大小。\n- 另外，我们需要将 increment[cnt - 1] 更新到 increment[cnt - 2]，并将 increment[cnt - 1] 重置为 0。\n\n### 代码：\n\n```\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        my_stack.resize(maxSize);\n        add_vec.resize(maxSize);\n        top = -1;\n        max_size = maxSize;\n    }\n    \n    void push(int x) {\n        if (top < max_size - 1) {\n            top ++;\n            my_stack[top] = x;\n        } else {\n            return;\n        }\n    }\n    \n    int pop() {\n        if (top >= 0) {\n            // s[top] + add[top]\n            int val = my_stack[top] + add_vec[top];\n            // add[top-1] += add[top]\n            if (top >= 1) {\n                add_vec[top -1] += add_vec[top];\n            }\n            add_vec[top] = 0;\n            top --;\n            return val;\n        } else {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int limit = min(k -1, top);\n        if (limit >= 0) {\n            add_vec[limit] += val;  // 只需要记录需要加的数\n        }\n    }\nprivate:\n    vector<int> my_stack;\n    vector<int> add_vec;\n    int max_size;\n    int top;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n### 复杂度：\n\n空间 O(N)\n\n时间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087464857","body":"### 思路：\n\n双指针，用一个指针指向【的后一个， 前面的数字代表的循环的次数，每次从'【'遍历到'】'。\n\n用递归解决多重括号。\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    bool IsWord(const char& c) {\n        return c >= 'a' && c <= 'z';\n    }\n    bool IsNum(const char& c) {\n        return c >= '0' && c <= '9';\n    }\n    string decodeString(string s) {\n        string ret_str;\n        for(size_t i =0 ; i < s.size(); i++) {\n            // 如果是字母直接塞, 循环终止条件\n            if (IsWord(s[i])) {\n                ret_str += s[i];\n                continue;\n            }\n            // 如果是数字，则循环填写\n            int j = i;\n            if (IsNum(s[i])) {\n                int loop_times = s[i] - '0';\n                // 计算遍历次数\n                while(IsNum(s[++j])) {\n                    loop_times = loop_times*10 + (s[j] -'0');\n                }\n                cout << \"loop_times = \" << loop_times << endl;\n                // 找出 【】里面的字母\n                int first_p = j;\n                int num_left_brackets = 1;\n                while(num_left_brackets) {\n                    ++j;\n                    if (s[j] == '[') {\n                        num_left_brackets++;\n                    }\n                    if (s[j] == ']') {\n                        num_left_brackets--;\n                    }\n                }// 退出循环时，j = ]所在的位置\n                cout << \"j = \" << j << endl;\n                // 开始递归遍历\n                for (int k = 0; k < loop_times; k++) {\n                    cout << \"sub_str = \" << s.substr(first_p+1, j-first_p-1) << endl;\n                    ret_str += decodeString(s.substr(first_p+1, j-first_p-1));\n                    cout << \"k = \" << k << endl;\n                    cout << \"ret_str = \" << ret_str << endl;\n                }\n            }\n            i = j; // 防止多塞\n        }\n        return ret_str;\n    }   \n};\n```\n\n### 复杂度：\n\n时间： O(n)\n\n空间： O(1）\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088618574","body":"### 思路：\n\n两个栈，push的时候push到s1， pop的时候从s2出，s2没有的时候，将所有的s1push到s2。\n\n### 代码：\n\n```c++\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        if (s2.empty()) {\n            while(!s1.empty()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int ret_val = s2.top();\n        s2.pop();\n        return ret_val;\n    }\n    \n    int peek() {\n        if (s2.empty()) {\n            while(!s1.empty()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n    stack<int> s1 , s2;\n};\n```\n\n复杂度：\n\n空间：O(N)\n\n时间:  O(1);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"omegalzx":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086006617","body":"~~~java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int[] num2 = convertNumToArray(k);\n        List<Integer> result = new ArrayList<>();\n        int i = num.length - 1;\n        int j = num2.length - 1;\n        int carry = 0;\n        while (i >= 0 || j >= 0) {\n            int sum = carry;\n            if (i >= 0) {\n                sum += num[i];\n            }\n            if (j >= 0) {\n                sum += num2[j];\n            }\n            result.add(sum % 10);\n            carry = sum / 10;\n            i--;\n            j--;\n        }\n        if (carry > 0) {\n            result.add(carry);\n        }\n        Collections.reverse(result);\n        return result;\n    }\n\n\n    private int[] convertNumToArray(int num) {\n        List<Integer> result = new LinkedList<>();\n        while (num > 0) {\n            result.add(num % 10);\n            num /= 10;\n        }\n        Collections.reverse(result);\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}\n~~~\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086682692","body":"~~~java\r\nclass CustomStack {\r\n\r\n    private final int maxSize;\r\n    private final int[] stack;\r\n    private final int[] inc;\r\n    private int top = -1;\r\n    private final int bottom = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        stack = new int[maxSize];\r\n        inc = new int[maxSize];\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (top == maxSize - 1) {\r\n            return;\r\n        }\r\n        stack[++top] = x;\r\n    }\r\n\r\n    public int pop() {\r\n        if (top < bottom) {\r\n            return -1;\r\n        }\r\n        int res = stack[top] + inc[top];\r\n        if (top > bottom) {\r\n            inc[top - 1] += inc[top];\r\n        }\r\n        inc[top] = 0;\r\n        top--;\r\n        return res;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int i = Math.min(k - 1, top);\r\n        if (i >= bottom) {\r\n            inc[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087645644","body":"~~~java\nint ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                stk.addLast(String.valueOf(s.charAt(ptr++)));\n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                stk.removeLast();\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuilder t = new StringBuilder();\n                String o = getString(sub);\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuilder ret = new StringBuilder();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(List<String> v) {\n        StringBuilder ret = new StringBuilder();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088766445","body":"~~~java\r\nclass MyQueue {\r\n\r\n    private final Stack<Integer> stack1 = new Stack<>();\r\n    private final Stack<Integer> stack2 = new Stack<>();\r\n\r\n    public MyQueue() {\r\n\r\n    }\r\n\r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        int size = stack2.size();\r\n        if (size == 0) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        int size = stack2.size();\r\n        if (size == 0) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n~~~\r\n- pop O(n)\r\n- peek O(n)\r\n- push O(1)\r\n- empty O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vivixu-qiqi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086007071","body":"```\r\nvar addToArrayForm = function(num, k) {\r\n    let sum = k;\r\n    let index = num.length - 1;\r\n    let result = '';\r\n    let resultArr = [];\r\n    while(index >= 0 || sum > 0) {\r\n        if(index >= 0) {\r\n            sum += num[index];\r\n        }\r\n        result += sum % 10;\r\n        sum = Math.floor(sum / 10);\r\n        index--;\r\n    }\r\n    for(let i = result.length - 1; i >= 0; i--) {\r\n        resultArr.push(+result[i]);\r\n    }\r\n    return resultArr;\r\n};\r\n```\r\nTime Complexity：O(max(n,logk))\r\nSpace Complexity：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646668","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [];\r\n        for i in range(len(s)):\r\n            if (s[i] == c):\r\n                result.append(0)\r\n                continue\r\n            for left in range(i, -1, -1):\r\n                dist1 = 0\r\n                if (s[left] == c):\r\n                    dist1 = i - left\r\n                    break\r\n            for right in range(i, len(s)):\r\n                dist2 = 0\r\n                if (s[right] == c):\r\n                    dist2 = right - i\r\n                    break\r\n            if (dist1 == 0):\r\n                result.append(dist2)\r\n            if (dist2 == 0):\r\n                result.append(dist1)   \r\n            if (dist1 <= dist2 and dist1 != 0):\r\n                result.append(dist1)\r\n            if (dist1 > dist2 and dist2 != 0):\r\n                result.append(dist2)    \r\n\r\n        return result;\r\n```\r\nTime Complexity: O(N)\r\nSpace Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086874419","body":"```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.maxSize = maxSize\r\n  this.size = 0\r\n  this.stack = []\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.size < this.maxSize) {\r\n    this.stack.push(x)\r\n    this.size++\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  if (this.size === 0) {\r\n    return -1\r\n  } else {\r\n    this.size--\r\n    return this.stack.pop()\r\n  }\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < Math.min(k, this.size); i++) {\r\n    this.stack[i] += val\r\n  }\r\n};\r\n```\r\nO(1) for time and space complexity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087690400","body":"```\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    let res = '';\r\n    let i = 0;\r\n\r\n    while (i < s.length) {\r\n        if (s[i] !== ']') {\r\n            stack.push(s[i++]);\r\n            continue;\r\n        }\r\n\r\n        let str = '', n = '', segment = '';\r\n        while (stack[stack.length-1] !== '[') {\r\n            str = stack.pop() + str;\r\n        }\r\n\r\n        stack.pop();\r\n        while (!isNaN(stack[stack.length-1])) {\r\n            n = stack.pop() + n;\r\n        }\r\n        for (let j = 0; j < Number(n); j++) {\r\n            segment = str + segment;\r\n        }\r\n        stack.push(segment);\r\n        i++;\r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\nO(n) for time and space complexity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088839886","body":"```\r\nvar MyQueue = function() {\r\n    s1 = []\r\n    s2 = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    s1.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(s2.length === 0) while(s1.length != 0) s2.push(s1.pop())\r\n    return s2.pop()\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return s2.length === 0 ? s1[0] : s2[s2.length - 1] \r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return s1.length === 0 && s2.length === 0\r\n};\r\n```\r\nO(n) for time and space complexity","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kwdfw":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086007092","body":"Day1\n\n[989、数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n#javascript\n## 思路\n1、类似现实中的加法题，取数组和数字的对应位相加并加上进位\n\n2、若相加和大于9，则用carry记录下进位为1\n\n3、算完一直就输入到数组中一位\n\n4、不断循环，从最后一位一直到第一位\n\n5、反转数组\n\n#### 处理特殊示例\n1、相加的结果比原来的位数多一位，如990+100=1090，需要在循环结束后单独判断再加一位\n\n2、数组的位数比数字的位数少，如0+23，按照循环会造成数组越界，需要加判断条件，越界就将值置为0\n## 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    let carry=0//记录进位\n    let ru=[]//最终返回的数组\n    let i=num.length-1//循环计数器\n    let result//每一位的结果\n    while(i>-1||k!=0){//||条件保证任意位数的情况下都可以进入循环\n        const x= i>=0? num[i]:0//解决数组和数字位数不同的问题\n        const y=k!=0 ? k%10:0\n        result=x+y+carry//得到某位的值\n        if(result>9){//若大于9，则保留进位，并输入到数组中\n            carry=1\n            ru.push(result%10)\n        }\n        else{//若小于等于9，则不保留进位，并输入到数组中\n            carry=0\n            ru.push(result)\n        }\n        k=Math.floor(k/10)//下取整，有时会自动进位\n        i--//推进循环\n    }\n    if(carry==1) ru.push(1)//解决相加结果比原来多一位\n    return ru.reverse()//反转数组\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086653607","body":"Day2\n\n[821、数组形式的整数加法](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n#javascript\n## 思路\n1、遍历数组\n\n2、对于每个字符都分别向左和右查找c\n\n3、对比左和右的长度，取最小值填入数组中\n\n## 代码\n```javascript\nvar shortestToChar = function(s, c) {\n    var answer=Array(s.length).fill(0);//将数组中填满0\n    for(let i=0;i<s.length;i++){\n      if (s[i] === c) continue;//若该位置与字符相同，则不用管\n      let short=Infinity\n      for(let j=i;j<s.length;j++){\n          if(s[j]===c){\n              short=Math.min(short,j-i)\n              break\n          }\n      }  \n      for(let k=i;k>-1;k--){\n          if(s[k]===c){\n               short=Math.min(short,i-k)\n               break\n          }\n      }\n      answer[i]=short\n    }\n    return answer\n};\n```\n## 复杂度分析\n时间复杂度：O(n2)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086894389","body":"Day3\n\n[1381、设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/submissions/)\n\n#javascript\n## 思路\n1、设置一个辅助数组inc\n\n2、调用增量函数的时候，用inc记录增加的数和值\n\n3、执行pop操作的时候，通过inc实现增加的值(利用栈的操作特性，减少了时间复杂度)\n\n## 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nlet increments=[]//记录inc函数的传入值\n\n\nvar CustomStack = function(maxSize) {\n    this.max=maxSize\n    this.stack=[]\n    increments=Array(this.max).fill(0)//把数组的所有元素填满为0\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.max>this.stack.length)\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length==0) return -1\n    else{\n        increments[this.stack.length-2]+=increments[this.stack.length-1]\n        //inc数组的栈顶加到栈顶的下一个\n        const res=increments[this.stack.length-1]+this.stack.pop()\n        //将inc数组的栈顶加到原栈的栈顶\n        increments[this.stack.length]=0\n        //inc数组的栈顶置0\n        return res\n        //注意：stack.length的值一直在变\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(k>this.stack.length) increments[this.stack.length-1]+=val\n    //如果栈中元素总数小于k，赋值到inc数组的栈顶\n    else increments[k-1]+=val\n    //对应inc数组的栈加上增加的值\n};\n```\n## 复杂度分析\n时间复杂度：O(1)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087644890","body":"Day4\n\n[394、字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n#javascript #栈\n## 思路\n1、从头到尾遍历字符串\n\n2、数字存入数字的栈中，字符存入字符的栈中\n\n3、出栈时，按照规定对数字和字符进行运算\n\n## 代码\n```javascript\nvar decodeString = function(s) {\n    let arrNum=[],arrStr=[]//定义两个存放的栈\n    let num=0,str=''//定义两个暂存的点\n    for(let n of s){//遍历字符串\n        if(!isNaN(n)){//如果是数字，就存到数字中\n            num=num*10+Number(n)\n        }\n        else if(n=='['){//如果是[，则将数字和字符都压入栈中，并将暂存点清空\n            arrNum.push(num)\n            num=0\n            arrStr.push(str)\n            str=''\n        }\n        else if(n==']'){//如果是]，则将数字和字符都出栈，并做对应的运算\n            str=arrStr.pop()+str.repeat(arrNum.pop())\n        }\n        else{//如果是字符，就存到字符中\n            str+=n\n        }\n    }\n    return str\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088661569","body":"Day5\n\n[232、用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n#javascript #队列\n## 思路\n1、设置两个栈，一个负责入队，一个负责出队，倒换之后刚好符合队列的性质\n\n## 代码\n```javascript\nvar MyQueue = function() {\n    this.arr1=[]//入队的栈\n    this.arr2=[]//出队的栈\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.arr1.push(x)//入队\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.arr2.length==0){\n        while(this.arr1.length!=0){\n            this.arr2.push(this.arr1.pop())\n        }\n        return this.arr2.pop()\n    }//如果出队的队列没有元素，就把入队的队列都拿过来\n    else return this.arr2.pop()//出队\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.arr2.length==0){\n        while(this.arr1.length!=0){\n            this.arr2.push(this.arr1.pop())\n        }\n        return this.arr2[this.arr2.length-1]\n    }//如果出队的队列没有元素，就把入队的队列都拿过来\n    else return this.arr2[this.arr2.length-1]//返回队头元素，即数组的最后一个元素\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    while(this.arr1.length!=0){\n        this.arr2.push(this.arr1.pop())\n    }//把入队队列全拿过来\n    if(this.arr2.length==0) return true\n    else return false\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mozro0327":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086012990","body":"### lc989 数组形式的整数加法\n\n#### 解法一\n\n##### 思路\n\n+ 先将数组翻转\n+ 在将 k 全部加在数组最后一位上\n+ 计算数组最后一位的进位，并作为下一次运算的 k\n+ 直到 k 为 0 且 数组遍历完成\n+ 最后将数组重新翻转\n\n##### 代码实现\n\n~~~ c++\nclass Solution1 {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size();\n        reverse(num.begin(), num.end());\n\n        for (int i = 0; i < len; i++) {\n            num[i] += k;\n            k = num[i] / 10;\n            num[i] %= 10;\n        }\n\n        while (k > 0) {\n            num.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n~~~\n\n##### 复杂度\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(1)\n\n\n\n#### 解法二\n\n##### 思路\n\n+ 将数组和 k 逐位相加\n+ 计算进位，并加在 k 的下一位上\n+ 直到 k 为 0 且数组遍历完成\n\n##### 代码实现\n\n~~~ c++\nclass Solution2 {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size();\n        vector<int> result;\n\n        for (int i = len - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum > 9) {\n                k++;\n                sum -= 10;\n            }\n            result.push_back(sum);\n        }\n        while (k > 0) {\n            result.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n~~~\n\n##### 复杂度\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086018719","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       List<Integer> res= new ArrayList<Integer>();\n       Integer n = num.length;\n       for(int i = n-1 ;i>=0||k>0;--i,k/=10)\n       {\n           if(i>=0)\n           {\n               k+=num[i];\n           }\n           res.add(k%10);\n       }\n       Collections.reverse(res);\n        return res;\n    }\n}\n\n思路：将整个加数 k 加入数组表示的数的最低位。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086664444","body":"### 【Day 2】821. 字符的最短距离\n#### 思路：分别比较左边和右边距离最近的值，取最小。\n从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\n从右想做遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int pre = -10000; //最大数据范围是10000\n        int[] ans = new int[n];\n        for (int i = 0; i < s.length(); i++) { //计算左段与c最近的距离\n            if (s.charAt(i) == c) pre = i;\n            ans[i] = i - pre;\n        }\n        pre = 10000;\n        for (int i = s.length() - 1; i >= 0; i--) { //计算右段与c最近的距离,同时与之前记录的左段进行比较\n            if (s.charAt(i) == c) pre = i;\n            ans[i] = Math.min(ans[i], pre - i);\n        }\n        return ans;\n    }\n}\n```\n###\n时间复杂度：O(N)O(N)，其中 NN 是 S 的长度，我们需要遍历字符串两次。\n空间复杂度：O(N)O(N)，ans 数组的大小。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086897344","body":"### 【Day 3】1381. 设计一个支持增量操作的栈\n方法1：模拟\n```\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087116500","body":"### 【Day 4】394. 字符串解码\n####  思路：构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n当 c 为字母时，在 res 尾部添加 c；\n当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\n记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\n记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n进入到新 [ 后，res 和 multi 重新记录。\n当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\nlast_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\ncur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n返回字符串 res。\n\n```\npublic String decodeString(String s) {\n        // 思路: 乘法和 递推公式 前一个和作为下一个加法的加数\n        // 3[a]2[bc] = 3a+2bc = (3a + \"\") + 2bc\n        // 3[a2[c]] = 3(2c + a) = 3(2c + a) + \"\"\n        \n        // 1. 初始化倍数和res 及其对应栈\n        int multi = 0;\n        StringBuilder res = new StringBuilder();\n        Deque<Integer> multi_stack = new LinkedList<>();\n        Deque<String> res_stack = new LinkedList<>();\n\n        // 2. 遍历字符\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            // 3. 统计倍数\n           //只有在碰到'['时才会入栈。比如'12[a]',初始状态muti=0；c='1'，muti=0*10+1=1;c='2',muti=1*10+2=12;c='[',muti=12入栈，然后muti=0.\n            if (ch >= '0' && ch <= '9')\n                multi = multi * 10 + (ch - '0');\n            // 4. 统计res\n            else if (ch >= 'a' && ch <= 'z') \n                res.append(ch);\n            // 5. 入栈并重置临时变量\n            else if (ch == '[') {\n                multi_stack.push(multi);\n                res_stack.push(res.toString());\n                // 重置开始下一轮重新统计\n                multi = 0;\n                res = new StringBuilder();\n            // 6. 出栈做字符串乘法和加法\n            } else {\n                int cur_multi = multi_stack.pop();\n                StringBuilder temp = new StringBuilder();\n                // 乘以当前统计字符串res\n                for (int i = 0; i < cur_multi; i++)\n                    temp.append(res);\n                // 加上前一个统计字符串作为当前res\n                res = new StringBuilder(res_stack.pop() + temp);\n            }\n        }\n        return res.toString();\n    }\n```\n####\n时间复杂度 O(N)O(N)，一次遍历 s；\n空间复杂度 O(N)O(N)，辅助栈在极端情况下需要线性空间，例如 2[2[2[a]]]。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088812452","body":"## 【Day 5】232. 用栈实现队列\n```\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n\n```\n## 复杂度分析\n\n时间复杂度：O(1)。\n\n空间复杂度：O(n)。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086021602","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sums = 0\n        for i,j in enumerate(num):\n            sums += j*10**(len(num)-i-1)\n        sums += k\n        ans = []\n        while sums:\n            temp = sums %10\n            sums = sums//10\n            ans.insert(0,temp)\n        return ans\n            \n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086548738","body":"```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        dic = []\n        for i,j in enumerate(s):\n            if j == c:\n                dic.append(i)\n        ans = []\n        \n        for i in range(len(s)):\n            temp = []\n            for j in dic:\n                temp.append(abs(j-i))\n            ans.append(min(temp))\n        return ans\n```\n                \n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086898887","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        \n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.maxSize:\n            #self.stack.insert(0,x)\n            self.stack.append(x)\n        \n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n        \n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack)<=k:\n            self.stack = [i+val for i in self.stack]\n        else:\n            for i in range(k):\n                self.stack[i] += val\n        \n```      ","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lskong":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086022222","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n\n        vector<int> res;\n        res.reserve(A.size() + 5);\n\n        int i = A.size() - 1;\n        int carry = 0;\n\n        while (i >= 0 || K > 0)\n        {\n            int n1 = i >= 0 ? A.at(i) : 0;\n            int n2 = K > 0 ? K % 10 : 0;\n            int sum = n1 + n2 + carry;\n            carry = sum / 10;\n            res.push_back(sum % 10);\n            --i;\n            K /= 10;\n        }\n\n        if (carry)\n        {\n            res.push_back(1);\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086585016","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> pos;\n        vector<int> res;\n        for(int i = 0; i < s.size(); i++) {\n            if(s[i] == c) {\n                pos.push_back(i);\n            }\n        }\n        for(int i = 0; i < s.size(); i++) {\n            int tmp = 100000000000000;\n            for(int j = 0; j < pos.size(); j++) {\n                tmp =min(tmp, abs(i -pos[j]));\n            }\n            res.push_back(tmp);\n        } \n    return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mapo0102":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086022435","body":"思路：\n创建一个链表，获取数组长度\n逆序从最低位开始，进行链表的加和。\n完成加和后，判断k值是否完成，如果未完成，继续向链表头部加k值，然后k/10，消耗尽k的所有位数。\n\n代码：\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> res = new LinkedList<>();\n        int n = num.length;\n\n        for (int i = n - 1; i >= 0 ; i--) {\n            int sum = k%10 + num[i];\n            k = k / 10;\n            if(sum >= 10){\n                sum -= 10;\n                k++;\n            }\n            res.add(0,sum);\n        }\n        while(k>0){\n            res.add(0,k%10);\n            k=k/10;\n        }\n        return res;\n    }\n\n    }\n\n\n复杂度：\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646897","body":"思路：\n首先先从左向右遍历一遍，将ans数组中的所有元素标志成对应位。\n再从右往左遍历一遍，再比较大小，将ans对应位置中更小的数放入对应ans。\n\n代码：\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n\n时间复杂度：O（n）\n空间复杂度：O（n）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086913613","body":"思路：将数字和char先压入栈中，把字符一个个压入栈中，遇到]符号就执行循环赋值操作。\n代码：class Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c != ']'){\n                stack.push(c);\n            }else{\n                StringBuilder sb = new StringBuilder();\n\n                while(!stack.isEmpty() && stack.peek() != '['){\n                    sb.insert(0,stack.pop());\n                }\n\n                String sub = sb.toString();//获得一个[]的字段\n\n                stack.pop();//去掉[\n\n                sb = new StringBuilder();//清理掉sb当前的内容\n\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    sb.insert(0,stack.pop());//获得[]前的系数\n                }\n\n                int count = Integer.parseInt(sb.toString());\n            \n                while(count > 0){\n                    for(char ch:sub.toCharArray()){\n                        stack.push(ch);\n                    }\n                    count--;//将一整个重复的字符串压入栈中\n            }\n        }\n    }\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty()){\n            res.insert(0,stack.pop());\n        }\n        return res.toString();\n    }\n}\n\n复杂度：\n空间复杂度：O(n)\n时间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086024431","body":"### 思路\n\n数组num转换为字符串与k相加后再转换为List\n\n### 代码\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        tostr = ''.join([str(i) for i in num])\n        res = str(int(tostr)+ k)\n        reslist = [int(i) for i in res]\n        return reslist\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，其中 n 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086897297","body":"\n### 代码\n\n\n```\nclass CustomStack {\n    int[] stack;\n    int size;\n    int[] increment;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        increment = new int[maxSize + 1];\n        size = 0;\n    }\n    \n    public void push(int x) {\n        if(size == stack.length){\n            return;\n        }\n        stack[size++] = x;\n    }\n    \n    public int pop() {\n        if(size == 0){\n            return -1;\n        }\n        int res = stack[size - 1];\n        if(increment[size] != 0){\n            res += increment[size];\n            increment[size - 1] += increment[size];\n            increment[size] = 0;\n        }\n        size--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        increment[Math.min(k, size)] += val;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(maxSize)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088736837","body":"### 思路\n【Day 5】232. 用栈实现队列\n\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n使用双栈\n将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\n\n### 代码\n\n\n```java\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1=new Stack<>();\n        stack2=new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty())\n                stack2.push(stack1.pop());\n        }\n        return stack2.pop();\n    }\n\n    public int peek() {\n        if(stack2.isEmpty()){\n            while(!stack1.isEmpty()){\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oneline-wsq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086026979","body":"### 思路\n\n将num数组计算为一个数，然后再与k相加，最后再返回数组。\n\n### 代码\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n\n        sum1=0\n        n=len(num)\n        for i in range(n):\n            sum1=sum1+pow(10,n-i-1)*num[i]\n\n        sum2=sum1+k\n\n        return [int(x) for x in str(sum2)]\n```\n\n### 复杂度分析\n\nTime: O(n)\n\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086597093","body":"### 思路\n\n首先在s中找到所有等于c的索引；再从0开始循环，计算与索引集合相减绝对值最小的值。\n\n### 代码\n\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n\n        ans=[]\n        # 首先找出所有的c的索引\n        tmp=[]\n        k=0\n        for i in s:\n            if i==c:\n                tmp.append(k)\n            k+=1\n        \n        for i in range(len(s)):\n            tmp2=[abs(j-i)for j in tmp]\n            ans.append(min(tmp2))\n\n        return ans\n```\n\n### 复杂度分析\n\n时间复杂度：O(n*m)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086844229","body":"### 思路\n\n用python的list实现。\n\n### 代码\n\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxsize=maxSize\n        self.stack=[]\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack)<self.maxsize:\n            self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack)==0:\n            return -1\n        else:\n            ans=self.stack[-1]\n            self.stack=self.stack[0:-1]\n            return ans\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        n=len(self.stack)\n        addn=min(k,n)\n        for i in range(addn):\n            self.stack[i]=self.stack[i]+val\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### 复杂度分析\n\n时间复杂度: O(N)\n\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087073420","body":"### 思路\n利用栈来实现\n### 代码\n```python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # 本题的核心思路是在栈里面每次存储两个信息：（左括号前的字符串，左括号前的数字）\n        stack=[] # (str,int)记录左括号之前的字符串和左括号外的上一个数字\n        num=0\n        res=\"\" # 实时记录当前可以提取出来的字符串\n        for c in s:\n            if c.isdigit():\n                num=num*10+int(c)\n            elif c==\"[\":\n                stack.append((res,num))\n                res,num=\"\",0\n            elif c==\"]\":\n                top=stack.pop()\n                res=top[0]+res*top[1]\n            else:\n                res+=c\n        return res\n```\n### 复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088586552","body":"# ****[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)****\n\n### 思路\n\n### 代码\n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.data=list()\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n\n        return self.data.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        pdata=self.data[0]\n        self.data=self.data[1:]\n        return pdata\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n\n        return self.data[0]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if len(self.data)==0:\n            return True\n        else:\n            return False\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### 复杂度分析\n\n时间复杂度： O(1)\n\n空间复杂度： O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuguang520-lab":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086037440","body":"##思路\n模拟加法运算，注意将数组反转\n\n##code\n```cpp\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {//判断是否有进位\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);//判断k是否比数组的长度要长\n        }\n        reverse(res.begin(), res.end());\n        return res;\n```\n##复杂度分析\n- 实践复杂度O(n)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646031","body":"#思路\n使用的是暴力解法没有使用官方的前后遍历所以时间复杂度和空间复杂度比较高\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> result;\n        vector<int > index;\n        int len = s.length();\n        for(int i = 0; i< len; i++)\n        {\n            if(s.at(i) == c)//将字符串转换成字符在进行比较\n            {\n                index.push_back(i);\n            }\n        }\n        int len_index = index.size();\n        for(int i = 0; i < len; i++)\n        {\n            int dis_min = len;//初始化为len\n            for(int j =0; j<len_index; j++)\n            {\n                dis_min = min(abs(i-index[j]),dis_min);\n            }\n            result.push_back(dis_min);\n        }\n    return result;\n    }\n};\n```\n#复杂度分析\n- 时间复杂度O(cN) c表示c字符出现的数量，n为字符串的长度\n-空间复杂度O(2N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086816450","body":"# 思路\n使用数组模拟栈的用法，定义一个容量，栈顶和栈底就很容易实现\n# code\n```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        element = new int[maxSize];\n        top_stack = -1;\n        maxsize = maxSize;\n    }\n    \n    void push(int x) {\n        if(top_stack == maxsize - 1)\n        {\n            return;//超过容量，不进行操作\n        }\n        element[++top_stack] = x;\n    }\n    \n    int pop() {\n        if(top_stack < 0)\n        {\n            return -1;\n        }\n        return element[top_stack--];\n    }\n    \n    void increment(int k, int val) {\n        if(top_stack < k - 1) //按照最短长度进行累加\n        {\n            for(int i = 0; i <= top_stack; i++)\n            {\n                element[i] += val;\n            }\n        }\n        else\n        {\n            for(int i = 0; i < k; i++)\n            {\n                element[i] +=val;\n            }\n        }\n    }\nprivate:\n    int* element;//数组\n    int top_stack;//栈顶\n    int maxsize;//最大容量\n};\n```\n# 时间复杂度分析\n- 空间复杂度O(N)\n\n- 时间复杂度O(N) 利用了一个数组进行模拟","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088440527","body":"# 思路\n利用两个栈来实现队列的功能，一个栈用来接受输入，一个栈接受是输出，如果输出栈没有数字了就从输入栈中添加\n# code\n```cpp\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1_input.push(x);\n    }\n    \n    int pop() {\n        if(s1_input.size() == 0 &&s2_output.size() == 0)\n        {//判断队列中是否有元素\n            exit(0);\n        }\n        if(!s2_output.empty())//输出栈有元素就直接从输出栈输出\n        {\n            int i = s2_output.top();\n            s2_output.pop();\n            return i;\n        }\n        else\n        {\n            while(!s1_input.empty())\n            {\n                s2_output.push(s1_input.top());\n                s1_input.pop();\n            }\n            int i = s2_output.top();\n            s2_output.pop();\n            return i;\n        }\n    }\n    \n    int peek() {//和pop函数一样，少了删除\n        if(s1_input.size() == 0 &&s2_output.size() == 0)\n        {\n            exit(0);\n        }\n        if(!s2_output.empty())\n        {\n            int i = s2_output.top();\n            return i;\n        }\n        else\n        {\n            while(!s1_input.empty())\n            {\n                s2_output.push(s1_input.top());\n                s1_input.pop();\n            }\n            int i = s2_output.top();\n            return i;\n        }\n    }\n    \n    bool empty() {\n        return (s1_input.empty() && s2_output.empty());\n    }\nprivate:\n    stack<int> s1_input;\n    stack<int> s2_output;\n};\n```\n# 复杂度分析\n- 时间复杂度 O（1）\n- 空间复杂度O(n) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086037807","body":"# 思路：两次遍历，两次转换\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        array_num = 0\n        for i in range(n):\n            array_num += num[i] * (10 ** (n-i-1))\n        total = array_num + k\n        ans = []\n        for s in str(total):\n            ans.append(int(s))\n        return ans \n```\n时间复杂度:O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086594925","body":"#思路:笨蛋解法，第一次遍历找位置，第二次遍历求距离最小值\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        position = []\n        for i,item in enumerate(s):\n            if item == c:\n                position.append(i)\n\n        for i in range(len(s)):\n            dis = []\n            for p in position:\n                dis.append(abs(i-p))\n            ans.append(min(dis))\n        return ans\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087688854","body":"# 思路：遍历字符串，遇到]之前一直入栈，遇到[之后出栈，找到重复的字符和次数后再入栈。最后栈内就是最终结果\n```python \nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for item in s :\n            if  item == ']':\n                repeatstr = ''\n                repeatcount = ''\n                while stack and stack[-1] != '[':\n                    repeatstr = stack.pop() + repeatstr\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatcount = stack.pop() + repeatcount\n                stack.append(repeatstr * int(repeatcount))\n            else:\n                stack.append(item)\n        ans = ''.join(stack)\n        return ans\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088657357","body":"# 思路：\n在push 的时候将先入队的元素放到后面\n```pyhon\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack =[]\n        self.aux_stack = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        while self.stack:\n            self.aux_stack.append(self.stack.pop())\n        self.aux_stack.append(x)\n        while self.aux_stack:\n            self.stack.append(self.aux_stack.pop())\n    \n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.stack.pop()\n        \n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.stack[-1] \n        \n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if len(self.stack) == 0:\n            return True\n        else:\n            return False\n\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bruceleeqaq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086039762","body":"思路:  模拟加法，先将数组转换成数字 再将结果转换为数组\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\ti = len(num)-1\n        while k:\n            num[i] += k\n            k, num[i] = num[i]//10, num[i]%10\n            i -= 1\n            if i<0 and k:\n                num.insert(0,0)\n                i = 0 \n        return num\n\n\n复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661332","body":"\n\n```class Solution:\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        c_pos, ans = [], []\n        for idx, i in enumerate(s):\n        class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        c_pos, ans = [], []\n        for idx, i in enumerate(s):\n            if i == c:\n                c_pos.append(idx)\n        \n        p = 0\n        for i in range(len(s)):\n            if i < c_pos[0]:\n                ans.append(c_pos[0] - i)\n            elif i > c_pos[-1]:\n                ans.append(i - c_pos[-1])\n            elif i == c_pos[p]:\n                ans.append(0)\n                p += 1\n            else:\n                ans.append(min(c_pos[p] - i, i - c_pos[p-1]))\n        return ans    if i == c:\n                c_pos.append(idx)\n        \n        p = 0\n        for i in range(len(s)):\n            if i < c_pos[0]:\n                ans.append(c_pos[0] - i)\n            elif i > c_pos[-1]:\n                ans.append(i - c_pos[-1])\n            elif i == c_pos[p]:\n                ans.append(0)\n                p += 1\n            else:\n                ans.append(min(c_pos[p] - i, i - c_pos[p-1]))\n        return ans\n```\n\n复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086895082","body":"\n\n```python\nclass CustomStack {\n    int[] mStack;\n    int top = -1;\n    public CustomStack(int maxSize) {\n        mStack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(top < mStack.length-1){\n            mStack[++top] = x;\n        }\n       \n    }\n    \n    public int pop() {\n        if(top>=0){\n            return mStack[top--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int temp = top<k-1?top:k-1;\n        for(int i=0;i<=temp;i++){\n            mStack[i] +=val;\n        }\n    }\n}\n```\n\n复杂度\n\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088767021","body":"\nclass MyQueue:\n\n    def __init__(self):\n        self.L = []\n\n    def push(self, x: int) -> None:\n        self.L.append(x)\n\n    def pop(self) -> int:\n        print(self.L)\n        return self.L.pop(0)\n\n    def peek(self) -> int:\n        return self.L[0]\n\n\n    def empty(self) -> bool:\n        if(len(self.L) == 0):\n            return True\n        else:\n            return False\n\n### 复杂度\n\n时间：O(1)\n\n空间：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086041856","body":"## 思路\n从最低位想相加开始计算起\n\n\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n## 复杂度\ntime O(N)\nspace O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086660724","body":"## 思路\n左右遍历 问题在于初始的c位置怎么算,算到数组中间好了\n对于prev\n因为如果不除以2的话，INT_MIN= -2^31，而刚开始的时候i-INT_MIN=i+2^31就会发生溢出，但是INT_MAX-i就不会发生溢出了，所以INT_MAX就没必要除以2了，为了看起来舒服点都除以2了\n```\nclass Solution {\npublic:\n   vector<int> shortestToChar(string S, char C) {\n       vector<int> distance(S.size(), 0);\n       int prev = INT_MIN/2;\n       for(int i = 0; i < S.size(); i ++){\n           if(S[i] == C) prev = i;\n           distance[i] = i - prev;\n       }\n       prev = INT_MAX/2;\n       for(int i = S.size() - 1; i >= 0; i --){\n           if(S[i] == C) prev = i;\n           distance[i] = min(distance[i], prev - i);\n       }\n       return distance;\n   }\n};\n```\n## 复杂度\n时空O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087668469","body":"# idea\n multiStack for num\n'['  将当前结果串resultStr 与 multi 的值进行入栈操作；\n']'，进行出栈操作 同时复制相应的倍数加入尾部\n```cpp\nclass Solution {\n    public:\n    string decodeString(string s) {\n        std::stack<int> multiStack;\n        std::stack<string> stringStack;\n        string resultStr;\n        int curMulti = 0;\n\n        for (int i = 0; i < s.size(); i++) {\n            char c = s[i];\n            if(c == '[') {\n                multiStack.push(curMulti);\n                stringStack.push(resultStr);\n                curMulti = 0;\n                resultStr.clear();\n            }\n            else if(c == ']') {\n                int tmp = multiStack.top();\n                multiStack.pop();\n                string tmpStr;\n                for( int i = 0; i < tmp; i++ ) {\n                    tmpStr.append(resultStr);\n                }\n                resultStr = (stringStack.top() +tmpStr);\n                stringStack.pop();\n\n            }\n            else if (c >='0' && c <= '9') {\n                curMulti = curMulti* 10 + (c-'0');\n            }\n            else {\n                resultStr.append({c});\n            }\n        }\n        return resultStr;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liyubin117":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086054479","body":"思路在注释里\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        // 初始化参数\n        List<Integer> res = new ArrayList<Integer>();\n        int n = A.length;\n\n        // 1. 从后往前逐位相加\n        for(int i = n - 1;i >= 0;i--){\n            // 1.1 逐位相加\n            int sum = A[i] + K % 10;         // 每次重置sum\n            K /= 10;    \n            // 1.2 处理两位相加 进位的情况\n            if(sum >= 10){\n                K++;                        // 进位到K的末尾\n                sum -= 10;                  // 进位清掉\n            }\n            // 1.2 当前相加的结果 添加到结果集\n            res.add(sum);\n        }\n\n        // 2. K的数字长度大于数组的数字长度\n        for(;K > 0;K /= 10){                // 每次K左移一位\n            res.add(K % 10);                // 添加到结果集\n        }\n\n        // 3. 将结果集翻转即是所求答案\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n复杂度\n空间：O(N)\n时间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663042","body":"思路：\r\n从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\r\n从右想做遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\r\n这两个值取最小就是答案。\r\n```\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n```\r\n复杂度\r\n时间复杂度：O(N)，其中 N 是 S 的长度，我们需要遍历字符串两次。\r\n空间复杂度：O(N)，ans 数组的大小。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"houyanlu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086055675","body":"### 思路\n\n从最低位开始跟k的个位相加，大于10则进一位，\n\n\n### 代码\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        int n = num.size();\n\n        // 从个位开始跟k的个位相加，大于10则进一位\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            result.push_back(sum);\n        }\n\n        // 最后剩下的k， 说明k是比原数组很大很大，应该是放在加和后的高位\n        for (; k > 0; k /= 10) {\n            result.push_back(k % 10);\n        }\n\n        std::reverse(result.begin(), result.end());\n\n        return result;\n    }\n};\n\n**复杂度分析**\n- 时间复杂度：O(N)，一次遍历\n- 空间复杂度：O(N) 同等大小的一个vector","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646499","body":"### 思路\n\n先从后往前遍历一遍，\n再从前往后遍历一遍，查漏补缺以及比较出最近的值\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int length = s.length();\n        vector<int> resultVector(length, -1);\n\n        int preIndex = -1;\n\n        for (int i = length - 1; i >= 0; i--) {\n            if (s.at(i) == c) {\n                preIndex = i;\n                resultVector[i] = 0;\n            }\n\n            if (preIndex != -1) {\n                resultVector[i] = preIndex - i;        \n            }\n\n        }\n\n        preIndex = -1;\n        for (int i = 0; i < length; i++) {\n            if (s.at(i) == c) {\n                preIndex = i;\n            } else if (resultVector.at(i) == -1 && preIndex != -1) {\n                 resultVector[i] = i - preIndex;        \n            } else if (resultVector.at(i) != -1 && preIndex != -1) {\n                resultVector[i] = std::min(i - preIndex, resultVector[i]);\n            }\n        }\n\n        return resultVector;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086895800","body":"### 思路\n\n使用数组模拟栈，用一个变量 m_topIndex 来记录当前栈顶的位置.\n\npush 操作，先判断是否到达栈顶，没有就 m_topIndex 自增1，数组的相应位置 赋值。\n\npop 操作，先判断是否为空，空返回−1， 否则m_topIndex 自减后返回自减前位置的值。\n\ninc 操作，直接对栈底的最多 k 个元素加上 val。\n\n### 代码\n\n\n```cpp\n\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        m_vector.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (m_topIndex != m_vector.size() - 1) {\n            m_topIndex++;\n            m_vector[m_topIndex] = x; \n        }\n\n        \n        \n    }\n    \n    int pop() {\n        if (m_topIndex == -1) {\n            return -1;\n        }\n\n        m_topIndex--;\n        return m_vector[m_topIndex + 1];\n    }\n    \n    void increment(int k, int val) {\n        int limit = std::min(k, m_topIndex + 1);\n\n        for (int i = 0; i < limit; i++) {\n            m_vector[i] += val;\n        }\n    }\n\nprivate:\n    vector<int> m_vector;\n    int m_topIndex {-1};\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n- 时间复杂度：因为数组支持随机访问，push和pop都是O(1), inc是O(k)\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087624824","body":"### 思路\n\n因为需要从里到外的展开[]对，需要增加一个辅助栈 **multiStack** 用于存储紧挨着[ 的倍数\n每当遇到左方括号时，将当前结果串**resultStr** 与 **multi** 的值进行入栈操作；\n当遇到右方括号时，进行出栈操作\n\n#### 代码实现\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        std::stack<int>  multiStack;   // \n        std::stack<string> strignStack;\n        string resultStr;\n        int curMulti = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s[i];\n            if (c == '[') { \n                // 如果是“[”, 先存放当前记录的次数和字符串入辅助栈, 再清空两者的值\n                multiStack.push(curMulti);\n                strignStack.push(resultStr);\n                curMulti = 0;\n                resultStr.clear();\n            } else if (c == ']') {\n                // 取出次数，说明需要重复栈顶记录次数的resultStr,也就是这个数字后跟着的[]之间的字符\n                int tmp = multiStack.top();\n                multiStack.pop();\n                string tmpStr;\n                for (int i = 0; i < tmp; i++) {\n                    tmpStr.append(resultStr);\n                }\n                resultStr = (strignStack.top() + tmpStr);\n                strignStack.pop();\n            } else if (c >= '0' && c <= '9') {\n                // 数字可能几十 几百\n                curMulti = curMulti * 10 + (c - '0');\n            } else {\n                resultStr.append({c});\n            }\n        }\n\n        return resultStr;\n    }\n};\n```\n\n#### 复杂度分析\n\n+ 时间复杂度 *O*(*N*)，一次遍历字符串`s`；\n+ 空间复杂度 *O(N)*，辅助栈在极端情况下需要线性空间，例如 `2[3[aaaaaa]]`。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086056841","body":"### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n\t\tList<Integer> result = new ArrayList<>();\n\t\tfor(int i = num.length - 1; i >= 0; i--) {\n\t\t\tint temp = (num[i] + k) % 10;\n\t\t\tk = (k + num[i])/10;\n\t\t\tresult.add(temp);\n\t\t}\n\t\twhile(k!=0) {\n\t\t\tresult.add(k%10);\n\t\t\tk = k/10;\n\t\t}\n\t\tCollections.reverse(result);\n\t\treturn result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663153","body":"### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n\t\tint N = s.length();\n\t\tint[] ans = new int[N];\n\t\tint pre = -N;\n\t\tfor(int i = 0; i<N;i++) {\n\t\t\tif(s.charAt(i) == c) pre = i;\n\t\t\tans[i] = i-pre;\n\t\t}\n\t\tpre = 2*N;\n\t\tfor(int i = N-1; i>=0;i--) {\n\t\t\tif(s.charAt(i) == c) pre = i;\n\t\t\tans[i] = Math.min(ans[i],pre-i);\n\t\t}\n\t\treturn ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086891512","body":"```java\npublic class CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top =-1;\n    }\n    public void Push(int x) {\n        if(top!=stack.Length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    public int Pop() {\n        if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    public void Increment(int k, int val) {\n        int limit = Math.Min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"w-will":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086057669","body":"## Idea:\nGo through the num array, accumulate the sum of each digits. Then sum with k and convert into a list.\n\n## Code:\n'''\n\n\tclass Solution:\n\t\tdef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\t\tsumArr = 0\n\t\t\tfor i, e in enumerate(num[::-1]):\n\t\t\t\tsumArr += e if i == 0 else e * (10 ** i)\n\n\t\treturn map(int, list(str(sumArr + k)))\n'''\n\nTime: O(n)\nSpace: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086936836","body":"## Idea\r\nUsing stack LIFO and nitrate through the string and process the char \r\n\r\n\r\n## Code\r\n\r\n```py\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, ret, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append((multi, ret))\r\n                ret, multi = \"\", 0\r\n            elif '0' <= c <= '9':\r\n                # 处理多位数字：一个空只会有一个数字，利用数字特性 n * 10 + c\r\n                multi = multi * 10 + int(c)\r\n            elif c == ']':\r\n                cur_multi, last_ret = stack.pop()\r\n                ret = last_ret + cur_multi * ret\r\n            else:\r\n                ret += c\r\n        return ret\r\n\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088049019","body":"## Code\n```java\nclass MyQueue {\n    private Stack<Integer> s1 = new Stack<>();\n    private Stack<Integer> s2 = new Stack<>();\n    private int front;\n        \n    public MyQueue() {\n        \n    }\n    \n    // 每次S1空都更新front\n    public void push(int x) {\n        if (s1.empty())\n            front = x;\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if (s2.empty()) {\n            // s1搬空 下次push更新front\n            while(!s1.empty())\n                s2.push(s1.pop());\n        }\n        return s2.pop();\n    }\n    \n    // peek是两部分逻辑 S2相当于队列如不为空直接返回peek 否则S1最底就是peek值\n    public int peek() {\n        if (!s2.empty()) \n            return s2.peek();\n        return front;\n    }\n    \n    public boolean empty() {\n        return s1.empty() && s2.empty();\n    }\n}\n```\n\n## Complexity\nTime: amortized O(1) pop <br>\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hohojii":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086058735","body":"##思路\n逐位相加\n##代码\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n##复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665804","body":"##左右遍历\n##code\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> ans(n, 1e6);\n        int last = -1e6;\n        for(int i = 0; i < n; i++) {\n            if(s[i] == c) {\n                ans[i] = 0;\n                last = i;\n            }\n            else ans[i] = min(ans[i], i - last);\n        }\n        last = 1e6;\n        for(int i = n - 1; i >= 0; i--) {\n            if(s[i] == c) last = i;\n            else ans[i] = min(ans[i], last - i);\n        }\n        return ans;\n    }\n};\n##复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088860479","body":"‘’‘’class MyQueue {\n    Deque<Integer> stackIn;\n    Deque<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new ArrayDeque<>();\n        stackOut = new ArrayDeque<>();\n    }\n\n    //push时检查out栈里是否为空，否则倒到in栈里再进行push\n    public void push(int x) {\n        while(stackOut.size()>=1){\n            stackIn.addFirst(stackOut.removeFirst());\n        }\n        stackIn.addFirst(x);\n    }\n    \n    //pop同理\n    public int pop() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.removeFirst();\n        return res;\n    }\n    \n    public int peek() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.getFirst();\n        return res;\n    }\n    \n    public boolean empty() {\n        return stackIn.size()==0 && stackOut.size()==0;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxjo":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086060234","body":"## 思路\nnum与k从右向左逐位相加，遇到进位则加到下一位上\n\n## 代码\n```\nvar addToArrayForm = function(num, k) {\n    let res = [];\n    for(let i = num.length - 1; i >= 0; i--){\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if(sum >= 10){\n            sum -= 10;\n            k += 1;\n        }\n        res.push(sum);\n    }\n    //解决k位数大于数组长度\n    while(k > 0){\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n## 复杂度分析\n时间复杂度： O(max(num.length, lgk))  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086652531","body":"## 思路\n\n使用不定长滑动窗口，边界字符为c，left和right维护窗口`\n\n## 代码\n```\nvar shortestToChar = function(s, c) {\n    let res = [];\n    let left = -Infinity;\n    let right = s.indexOf(c);\n    for(let i = 0; i < s.length; i++){\n        res.push(Math.min(Math.abs(i - left), Math.abs(i -right)));\n        if(i === right){\n            left = right;\n            right = s.indexOf(c, right + 1);\n        }\n    }\n    return res;\n};\n```\n\n## 复杂度分析\n\n\n时间复杂度:O(n)\n空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086886549","body":"## 思路\n使用数组，并用原生的push、pop方式实现\n\n## 代码\n\n```\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length < this.maxSize){\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.length > 0 ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < this.stack.length; i++){\n        if(i < k){\n            this.stack[i] += val;\n        }\n    }\n};\n```\n## 复杂度分析\n时间复杂度： push(): O(1); pop():O(1); increment:O(n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087716526","body":"## 思路\n使用非\"]\"的字符入栈，遇到\"]\"时，字符出栈，在遇到\"[\"之前出栈的字符拼接得repeatString，随后数字字符出栈拼接转化成对应数字就是repeatNum，根据上述两个变量，得到重复的完整字符串，随后压入栈重复上述操作。\n\n## 代码\n```\n var decodeString = function(s) {\n    let stack = [];\n    for(let c of s){\n        if(c !== ']'){\n            stack.push(c);\n            continue;\n        }\n        let repeatString = '';\n        while(stack.length > 0 && stack[stack.length - 1] != '['){\n            repeatString = stack.pop() + repeatString;\n        }\n    \n        /* 弹出[ */\n        stack.pop();\n    \n        let repeatNum = '';\n        while(stack.length > 0 && !isNaN(stack[stack.length - 1])){\n            repeatNum = stack.pop() + repeatNum;\n        }\n        stack.push(repeatString.repeat(Number(repeatNum)));\n    }\n    return stack.join('');\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088852525","body":"## 思路\nstack1作为输入栈，stack2作为输出栈，只有当stack2为空时，才将stack1中的数据移到stack2中\n\n## 代码\n```\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.stack2.length === 0){\n        while(this.stack1.length > 0){\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.stack2.length === 0){\n        while(this.stack1.length > 0){\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stack2.length == 0 && this.stack1.length == 0 ? true : false;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ha0cheng":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086068703","body":"思路：\r\n实现数组形式的加法，逐位相加，保存进位\r\n\r\n代码：\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        Next= 0\r\n        p = len(num)- 1\r\n        while p>=0:\r\n            x = num[p]+k%10+Next\r\n            num[p] = x%10\r\n            Next = x//10\r\n\r\n            k//=10\r\n            p-=1\r\n            if k==0 and Next ==0:\r\n                break\r\n\r\n        while k>0 or Next>0:\r\n            x = k%10+Next\r\n            num.insert(0,x%10)\r\n            Next = x//10\r\n            k//=10\r\n        return num\r\n```\r\n\r\n\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086159354","body":"思路：\r\n遍历两遍，第一遍确定字符的位置，第二遍确定距离每个字符位置最近的字符区间，输出结果\r\n\r\n代码：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        P = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n              P.append(i)\r\n        r = []\r\n        left = 0\r\n        for i in range(len(P)):\r\n            if i==len(P)-1:\r\n                right = len(s)-1\r\n            else:\r\n                right = (P[i]+P[i+1]-1)//2\r\n            j = P[i] - left \r\n            while j>0:\r\n                r.append(j)\r\n                j-=1\r\n            while j<=right-P[i]:\r\n                r.append(j)\r\n                j+=1\r\n        \r\n            left = right+1\r\n        \r\n        return r\r\n```\r\n时间复杂度：需要遍历两遍，每次均是原字符数组的长度，所以复杂度为O(N)\r\n空间复杂度：需要一个空间来存储字符位置，最坏情况下是N，复杂度为O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086886712","body":"思路：\r\n\r\n入栈和出栈都是基础操作，主要要实现的是第三个功能，栈底前k个元素增加值，要访问栈底，想到使用数组，最开始的思路是循环增加前k个值，复杂度是O(k)，看了参考答案，如果用数组add来保存每个位置的增加量，并且在pop的过程中传递倒数第二个值，便可实现增加量的传递，实现复杂度为O(1)的方法\r\n\r\n代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.Stack = [] \r\n        self.add = []\r\n        self.maxSize = maxSize\r\n        self.length = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.length < self.maxSize:\r\n            self.Stack.append(x)\r\n            self.add.append(0)\r\n            self.length +=1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.length == 0:\r\n            return -1\r\n        else:\r\n            if self.length>1:\r\n                self.add[self.length-2] += self.add[self.length-1]\r\n            self.length-=1\r\n            return self.Stack.pop()+self.add.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        idx = min(k-1,self.length-1)\r\n        if idx>=0:\r\n            self.add[idx] += val\r\n```\r\n\r\n复杂度分析：\r\n时间复杂度：入栈，出栈和增加值的复杂度都是O(1)\r\n空间复杂度：设当前栈长度是cnt，那么需要额外存储的add数据需要空间是O(cnt)，复杂度是O(cnt)，最坏情况下复杂度是O(maxSiz)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joewx21":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086071168","body":"### 思路\n\n将k加到num的低位，大于10就取余留下个位，整除取出个位得到进位，每位循环直到最高位并且 k 为0或者i<0。如果 i 小于0，数字长度加一，再循环上过程。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int i = num.size() - 1;\n        while(k > 0){\n            num[i] += k;\n            k = num[i] / 10;\n            num[i--] %= 10;\n            if(i < 0 && k > 0){\n                num.insert(num.begin(), 0);\n                i = 0;\n            }\n        }\n        return num;\n    }\n};\n```\n\n**复杂度分析**\n\\- 时间复杂度：O(n)\n\\- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663863","body":"### 思路\n\n先把s中所有等于c的元素的下标值存入到数组sc中，然后利用双重循环遍历s，比较s中各个下标值与sc中元素值的大小，将当前下标值与sc[j]的差的绝对值最小值存入scret中\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> sc; // 与c相同的值得索引\n        vector<int> scret; // 距离结果\n        for(int i =0; i<s.size(); i++){\n            if(s[i] == c){\n                sc.push_back(i);\n            }\n        }\n        if(sc.size() == 1){\n            for(int i = 0; i < s.size(); i++){\n                scret.push_back(abs(i-sc[0]));\n            }\n        }\n        for (int i = 0; i<s.size(); i++){\n            for(int j = 0; j<sc.size()-1; j++){\n                if(i<=sc[j]){\n                    scret.push_back(abs(sc[j]-i));\n                    break;\n                }\n                if(i>sc[j]&&i<=sc[j+1]){\n                    scret.push_back(min(abs(i-sc[j]), abs(i-sc[j+1])));\n                    break;\n                }\n                if(i>sc[sc.size()-1]){\n                    scret.push_back(abs(i-sc[sc.size()-1]));\n                    break;\n                }\n            }\n        }\n        return scret;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086858315","body":"### 思路\n\n这里使用数组来进行栈的模拟，方便执行inc(int k, int val)操作\n\n### 代码\n\n```cpp\nclass CustomStack {\npublic:\n    int maxSize;\n    vector<int> stack;\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;\n    }\n    \n    void push(int x) {\n        if(stack.empty()||stack.size()<maxSize){\n            stack.push_back(x);\n            return ;\n        }\n    }\n    \n    int pop() {\n        if(stack.empty()){\n            return -1;\n        }\n        int val = stack.back();\n        stack.pop_back();\n        return val;\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < k&&i<stack.size(); i++){\n            stack[i] += val;\n        }\n        return ;\n    }\n};\n```\n\n**时间复杂度**：O(min(k, stak.size()))\n\n**空间复杂度**：O(maxsize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087568418","body":"### 思路\n\n用两个栈，一个存字符串一个存数字，遇到数字就把之前的字符串压入字符串栈，再把数字压入数字栈，因为数字后必是`[`，使用`str`记录的字符串是`[`之前的，将其压入栈，重新记录`str`，遇到`]`时，弹出数字栈顶元素k，并重复`str`k次。之后将字符串栈栈顶元素弹出来并与当前字符串拼接，作为新的当前正在累积的字符串。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> str_stk;//字符串栈\n        stack<int> num_stk;//数字栈\n        string str;\n        for(int i=0;i<s.size();i++){\n            if(isdigit(s[i])){\n                int n=s[i]-'0';\n                while(isdigit(s[++i])){\n                    n=10*n+s[i]-'0';\n                }\n                num_stk.push(n);\n                i--;\n            }\n            else if(s[i]=='['){\n                str_stk.push(str);\n                str=\"\";\n            }\n            else if(s[i]==']'){\n                string tmp;\n                for(int i=0;i<num_stk.top();i++){\n                    tmp+=str;\n                }\n                str=tmp;\n                num_stk.pop();\n                str=str_stk.top()+str;\n                str_stk.pop();\n            }\n            else{\n                str+=s[i];\n            }\n        }\n        return str;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088900438","body":"### 思路\n\n用两个栈来模拟队列，当需要出队时，直接取出tmp栈里面的元素，若tmp为空将stk栈的元素依次放入即可。\n\n### Code\n\n```cpp\nclass MyQueue {\npublic:\n    stack<int> stk, tmp;\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        stk.push(x);\n    }\n    void get() {\n        if(tmp.empty()) {\n            while(!stk.empty()){\n                tmp.push(stk.top());\n            stk.pop();\n            }\n        }\n    }\n\n    int pop() {\n        int t;\n        get();\n        t = tmp.top();\n        tmp.pop();\n        return t;\n    }\n    \n    int peek() {\n        get();\n        return tmp.top();\n    }\n    \n    bool empty() {\n        return tmp.empty() && stk.empty();\n    }\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zetavi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086072595","body":"## 思路\n\n从Num数组的**右侧开始往左遍历**数组,将遍历到的数**直接与K相加**,相加的结果取**最低位**插入到List输出链表的**头部**\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        int i;\n        for (i = num.length - 1; k > 0 || i >= 0; k /= 10, i--) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            list.add(0, k % 10);\n        }\n        return list;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(max(num.length(),logK))$\n\n​\t\t\t\t\t\t\t时间复杂度跟输入Num的长度和K的位数有关,又因为List的插入时间复杂度为$O(1)$所以插入可以忽略不计.\n\n- 额外空间复杂度: $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086667405","body":"## 思路(法一)\n\n利用库函数**indexOf(c)**来找到**后一个出现字母的位置**,比较前一个出现和后一个出现的距离,取最小值\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n   public int[] shortestToChar_1(String s, char c) {\n        int[] ans = new int[s.length()];\n        int fir = -1, sec = Integer.MAX_VALUE / 2, cur = 0;\n        fir = s.indexOf(c);\n        for (int i = 0; i < ans.length; i++) {\n            if (fir > i) {\n                ans[i] = fir - i;\n            } else if (fir == i) {\n                ans[i] = 0;\n                sec = s.indexOf(c, fir + 1) == -1 ? Integer.MAX_VALUE / 2 : s.indexOf(c, fir + 1);\n            } else if (i < sec) {\n                ans[i] = Math.min(Math.abs(fir - i), Math.abs(sec - i));\n            } else {\n                ans[i] = 0;\n                fir = sec;\n                sec = s.indexOf(c, fir + 1) == -1 ? Integer.MAX_VALUE / 2 : s.indexOf(c, fir + 1);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(N^2)$\n\n​\t\t\t\t\t\t\t因为String类中indexOf()方法是暴力匹配方法时间复杂度为$O(N*M)$,而我们这里M=1,所以综上总的时间复杂度为$O(N^2)$\n\n- 额外空间复杂度: $O(N)$\n\n## 思路(法二)\n\n对于每个字符 S[i]，通过**顺序遍历和逆序遍历两次**,试图找出距离向左和向右下一个字符 C 的距离。答案就是这两个值的较小值。\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n    public int[] shortestToChar_2(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        //假设上一个出现的位置为Integer.MIN_VALUE / 2\n        int prev = Integer.MIN_VALUE / 2;\n\n        //记录s[i]与前一个字符c的距离\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        //假设最后一个出现的位置为Integer.MAX_VALUE / 2\n        prev = Integer.MAX_VALUE / 2;\n\n        //计算s[i]与后一个字符c的距离,与原来的距离比较取最小值\n        for (int i = N - 1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(N)$\n\n- 额外空间复杂度: $O(N)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086885823","body":"## 思路\n\n同样用数组来模拟实现栈,但是对increment()方法进行优化\n\n再用一个辅助数组add来记录increase的值, 利用==差分思想==, 在每次pop()时把add数组和原数组arr==相加输出==\n\n## 语言\n\njava\n\n## 代码\n\n```java\nclass CustomStack_PrefixSum {\n    private int[] arr;\n    private int[] add;\n    private int top;\n\n    public CustomStack_PrefixSum(int maxSize) {\n        arr=new int[maxSize];\n        add=new int[maxSize];\n        top=-1;\n    }\n\n    public void push(int x) {\n        if (top < arr.length-1 ) {\n            arr[++top]=x;\n        }\n    }\n\n    public int pop() {\n        if (top >= 0) {\n            int res=arr[top]+add[top];\n            if (top>=1){\n                add[top-1]+=add[top];\n            }\n            add[top--]=0;\n            return res;\n        }return -1;\n    }\n\n    public void increment(int k, int val) {\n        int end= Math.min(k-1, top);\n        if (end>=0){\n            add[end]+=val;\n        }\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:CustomStack(),push(),pop(), increment()时间复杂度为都为$O(1)$\n- 空间复杂度:$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087732150","body":"## 思路\n\n栈操作\n\n- 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\n- 如果当前的字符为字母或者左括号，直接进栈\n- 如果当前的字符为右括号，开始出栈,一直到左括号出栈\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic String decodeString(String s) {\n        Stack<Integer> add=new Stack<>();\n        Stack<String> str=new Stack<>();\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i)>=48&&s.charAt(i)<=57){\n                int j=i;\n                while(s.charAt(j+1)>=48&&s.charAt(j+1)<=57){\n                    j++;\n                }\n                int num=Integer.parseInt(s.substring(i,j+1));\n                add.push(num);\n                i=j;\n            }else if(s.charAt(i)==91){\n                int j=i+1;\n                String temp = new String(\"\");\n                while (s.charAt(j)>=97&&s.charAt(j)<=122){\n                    temp+=(s.charAt(j));\n                    j++;\n                }\n                i=j-1;\n                str.push(temp);\n            }else if(s.charAt(i)==93){\n                int time=add.pop();\n                String base=str.pop();\n                StringBuilder builder1 = new StringBuilder();\n                while (time>0){\n                    builder1.append(base);\n                    time--;\n                }\n                if (!str.isEmpty()){\n                    base=str.pop();\n                }\n                else base=\"\";\n                base+=builder1.toString();\n                str.push(base);\n            }else {\n                String t=new String(\"\");\n                if (!str.isEmpty()){\n                    t = str.pop();\n                }\n                t+=s.charAt(i);\n                str.push(t);\n            }\n        }\n        return str.peek();\n    }\n```\n\n## 复杂度分析\n\n- 时间复杂度: $O(S)$,S表示解码后字符串长度\n- 空间复杂度:$O(S)$,S表示解码后字符串长度,维护栈,栈的总大小最终与S相同\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088897408","body":"## 思路\n\n使用两个栈,一个栈负责存储新Push()进来的数据,当需要==访问\\弹出队列头==时,把原栈的数据放到另一个栈中,实现==逆序==\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic class MyQueue {\n    LinkedList<Integer> stack  ;\n    LinkedList<Integer> queue ;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack = new LinkedList<>();\n        queue = new LinkedList<>();\n    }\n\n    /**\n     * Push element x to the back of queue.\n     * @复杂度分析\n     *      时间复杂度:O(1)\n     *      空间复杂度:O(n)\n     * */\n    public void push(int x) {\n        stack.push(x);\n    }\n\n    /**\n     * Removes the element from in front of queue and returns that element.\n     * @复杂度分析\n     *      时间复杂度:摊还时间复杂度为O(1)\n     *      空间复杂度:O(1)\n     * */\n    public int pop() {\n        if (queue.isEmpty()){\n            while (!stack.isEmpty()){\n                queue.push(stack.poll());\n            }\n        }\n        return queue.pop();\n    }\n\n    /**\n     * Get the front element.\n     * 时间复杂度:\n     *      摊还时间复杂度:O(1)\n     *      空间复杂度:O(1)\n     * */\n    public int peek() {\n        if (queue.isEmpty()){\n            while (!stack.isEmpty()){\n                queue.push(stack.poll());\n            }\n        }\n        return queue.peek();\n    }\n\n    /**\n     * Returns whether the queue is empty.\n     *时间复杂度:\n     *      时间复杂度:O(1)\n     *      空间复杂度:O(1)\n     * */\n    public boolean empty() {\n        if (stack.isEmpty()&&queue.isEmpty()){\n            return true;\n        }return false;\n    }\n}\n\n```\n\n## 复杂度分析\n\n- push()\n    - 时间复杂度:O(1)\n    - 空间复杂度:O(n)\n- pop()\n    - 摊还时间复杂度:O(1)\n    - 空间复杂度:O(1)\n- empty()\n    - 时间复杂度:O(1)\n    - 空间复杂度:O(1)\n- peek()\n    - 摊还时间复杂度:O(1)\n    - 空间复杂度:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086074254","body":"### Idea\r\nLet carry = k; Add k with each digit of num form right to left, \r\nput units digit into res, update carry \r\nreverse res\r\n\r\n### Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int carry = k;\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        while (i >= 0 || carry > 0) {\r\n            if (i >= 0) {\r\n                carry += num[i];\r\n            }\r\n            res.add(carry % 10);\r\n            carry /= 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### Complexity\r\nTime: O(N)  N refers to the length of num. (reach each element once) \r\nSpace: O(1)  (no extra space except result)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086670553","body":"## Idea\r\nTwo-pass: \r\n1st left to right, find shortest distant to character on left.\r\n2nd right to left, find shortest distant to character on right, and pick shorter one.\r\n\r\n## Code\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int position = -n;\r\n        int[] res = new int[n];\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                position = i;   \r\n            }\r\n            res[i] = i - position;\r\n            System.out.print(res[i]);\r\n        }\r\n        System.out.print(\" \");\r\n        for (int i = position - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                position = i;   \r\n            }\r\n            res[i] = Math.min(res[i], position - i);\r\n            System.out.print(res[i]);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(N)  N refers to the length of string. Traverse string twice\r\nSpace: O(N) extra space for output","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087754257","body":"## Idea\nUse two stack: \nOne intStack to store temp number k until reach to a '['\nOne strStack to store temp string until reach to a ']'\nThe peek item of strStack will record the current temp string, \nand the after-process string is after that\n\n# Code\n```\nclass Solution {\n    public String decodeString(String s) {\n        Deque<StringBuilder> strStack = new ArrayDeque<>();\n        Deque<Integer> intStack = new ArrayDeque<>();\n        \n        int k = 0;\n        strStack.offerFirst(new StringBuilder());\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                k = k * 10 + c - '0';\n            }\n            else if (c == '[') {\n                strStack.offerFirst(new StringBuilder());\n                intStack.offerFirst(k);\n                k = 0;\n            }\n            else if (c == ']') {\n                String preStr = strStack.pollFirst().toString();\n                int preK = intStack.pollFirst();\n                for (int i = 0; i < preK; i++) {\n                    strStack.peekFirst().append(preStr);\n                }\n            }\n            else {\n                strStack.peekFirst().append(c);\n            }\n        }\n        return strStack.pollFirst().toString();\n    }\n}\n```\n## Complexity\nTime: O(N)  N refers to length of input String\nSpace: O(N) ","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raingolee":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086081768","body":"### 思路\n从低位开始（从右到左），两个位置的数相加，如果超过10，则增加一个标记位，下一个位置的数字相加之后加一，因为是不等长的，所以存在相同位置的数字为空时候则设置为0，切不需要设置标记位。\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"all-sunday":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086082274","body":"### 思路\n遍历数组，把k加到最后一个元素num[n]，把num[n]对10取余的余数加到结果res数组，对10取整后的结果重新赋给k；\n\n循环上一步操作倒数第二个元素，直至数组遍历完或k值不大于0，则把剩下的数组元素或k加到res数组;\n\n最后反转数组即可。\n\n\n### 代码\n\n\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        while(true){\n                if(n>0 && k>0){\n                    num[--n] += k;\n                    res.add(num[n] % 10);\n                    k = num[n] / 10;\n                }else if(n>0){\n                    res.add(num[--n]);\n                    \n                }else if(k>0){\n                    res.add(k%10);\n                    k /= 10;\n                    \n                }else{\n                    break;\n                }    \n\n            }\n            Collections.reverse(res);\n            return res;\n        }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(n,k))，其中 n 为数组长度，k为k的位数。\n- 空间复杂度：O(max(n,k))，开辟了新数组\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086641183","body":"### 思路\r\n先遍历一次字符串s，获得字符串s种所有c的小标，并存在cIndexs数组；\r\n\r\n双层循环，外层遍历字符串s，内层遍历cIndexs数组，即将字符串s种每一个字字符的小标与所有的字符c小标分别求绝对值，所得值中最小的即为所求目标，存入结果answer数组。\r\n\r\n暂没有其他思路，就暴力求解了。😥\r\n### 代码\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] answer = new int[n];\r\n        int[] cIndexs = new int[n];\r\n        int cNum = 0;\r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                cIndexs[cNum++] = i;\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < s.length(); i++){\r\n            int minDistance = n;\r\n            for(int j = 0; j < cNum; j++){\r\n                int distance = Math.abs(i - cIndexs[j]);\r\n                if(distance < minDistance){\r\n                    minDistance = distance;\r\n                }\r\n            }\r\n            answer[i] = minDistance;\r\n        }\r\n\r\n        return answer;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N^2)，双重循环，其中N为字符串s的长度。\r\n- 空间复杂度：O(N)，使用了额外的大小为字符串长度N的数组。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086893650","body":"### 思路\n用数组模拟栈的操作，top记录栈顶的位置。\n### 代码\n```\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top < stack.length - 1){\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top > -1){\n            int res = stack[top];\n            stack[top--] = 0;\n            return res;\n        }else{\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        if(top < k - 1){\n            k = top + 1;\n        }\n        for(int i = 0; i < k; i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：初始化、push、pop操作均为O(1)，inc操作为O(k)。\n- 空间复杂度：O(maxSize)，使用了额外长度为maxSize的数组stack。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087733546","body":"### 思路\r\n每个左括号对应一个子问题，通过递归调用函数解决；\r\n\r\n遇到'['，则递归调用，返回得到的字符串和当前处理到的下标，根据数字mutil得到新的res，并根据返回的下标i继续解析剩余字符串。\r\n### 代码\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        return dfs(s, 0)[0];\r\n    }\r\n\r\n    private String[] dfs(String s, int i){\r\n        StringBuilder res = new StringBuilder();\r\n        int mutil = 0;\r\n        while(i < s.length()){\r\n            char c = s.charAt(i);\r\n            if(c >= '0' && c <= '9'){\r\n                mutil = mutil * 10 + Integer.parseInt(String.valueOf(c));\r\n            }else if(c == '['){\r\n                String[] temp = dfs(s, i + 1);\r\n                i = Integer.parseInt(temp[0]);\r\n                while(mutil > 0){\r\n                    res.append(temp[1]);\r\n                    mutil--;\r\n                }\r\n            }else if(c == ']'){\r\n                return new String[] {String.valueOf(i), res.toString()};\r\n            }else{\r\n                res.append(String.valueOf(c));\r\n            }\r\n            i++;\r\n        }\r\n        return new String[] {res.toString()};\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，实际上还是遍历。\r\n- 空间复杂度：O(N)，极端情况下，递归深度达到N。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088939342","body":"### 思路\n双栈，输入栈专门用于输入；\n\n输出栈用于pop和peek操作，如果输出栈为空，则将输入栈的元素全部压入输出栈，此时输出栈的输出顺序即为队列顺序；\n\n输入、输出栈均为空，则队列为空。\n### 代码\n```\nclass MyQueue {\n    private Stack<Integer> in;//输入栈\n    private Stack<Integer> out;//输出栈\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n       if(out.isEmpty()){\n           while(!in.isEmpty()){\n               out.push(in.pop());\n           }\n       }\n       return out.pop(); \n    }\n    \n    public int peek() {\n        if(out.isEmpty()){\n            while(!in.isEmpty()){\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(1)。\n- 空间复杂度：O(N)。","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086082862","body":"public List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> result = new ArrayList<>();\n    int cur = k;\n    int i = num.length - 1;\n    while (i >= 0 || cur > 0) {\n        if (i >= 0) {\n            cur += num[i];\n        }\n        result.add(cur % 10);\n        cur /= 10;\n        i--;\n    }\n    Collections.reverse(result);\n    return result;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663613","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = Math.min(res[i], pre - i);\n        }\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086083587","body":"## 思路\n\n- 直接把k加到A中\n\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n        int i = A.size()-1;\n        while(K > 0){\n            A[i] += K;\n            K = A[i] / 10;\n            A[i--] %= 10;\n            \n            if(i < 0 && K > 0){\n                A.insert(A.begin(),0);\n                i = 0;\n            }\n        }\n        \n        return A;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hulichao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086084672","body":"思路\n遍历数组，把k加到最后一个元素num[n]，把num[n]对10取余的余数加到结果res数组，对10取整后的结果重新赋给k；\n\n循环上一步操作倒数第二个元素，直至数组遍历完或k值不大于0，则把剩下的数组元素或k加到res数组;\n\n最后反转数组即可。\n\n代码\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        while(true){\n                if(n>0 && k>0){\n                    num[--n] += k;\n                    res.add(num[n] % 10);\n                    k = num[n] / 10;\n                }else if(n>0){\n                    res.add(num[--n]);\n                    \n                }else if(k>0){\n                    res.add(k%10);\n                    k /= 10;\n                    \n                }else{\n                    break;\n                }    \n\n            }\n            Collections.reverse(res);\n            return res;\n        }\n}\n复杂度分析\n\n时间复杂度：O(max(n,k))，其中 n 为数组长度，k为k的位数。\n空间复杂度：O(max(n,k))，开辟了新数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086667513","body":"### 思路\n关键点在于加一个变量，用来指出距离当前遍历到的字符的最左的目标字符的下标，和距离当前遍历到的字符的最右的目标字符的下标。\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int[] ans = new int[S.length()];\n        int pre = -100001;\n        //从左到右\n        for (int i = 0; i < S.length(); i++) {\n            if (S.charAt(i) == C)\n                pre = i;\n            ans[i] = i - pre;\n        }\n\n        pre = 100001;\n        for (int i = S.length() - 1; i >=0 ; i--) {\n            if (S.charAt(i) == C)\n                pre = i;\n            ans[i] = Math.min(ans[i], pre -i);\n        }\n\n        return ans;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086896250","body":"### 思路\n用个数组模拟栈就好了。\n\n### 代码\n\n\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top<stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top==-1){\n            return -1;\n        }else{\n            return stack[top--];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k;i++){\n            if(i<=top){\n                stack[i] += val;\n            }else{\n                break;\n            }\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087681468","body":"### 思路\n使用两个栈 分别用来记录 数字 和 其他所有字符\n\n### 代码\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n\n        // 使用两个栈 分别用来记录 数字 和 其他所有字符\n        Stack<Integer> stack_num = new Stack<>();\n        Stack<String> stack_string = new Stack<>();\n\n        char[] chars = s.toCharArray();\n        for(char ch: chars){\n            // 如遇到数字 进入数字栈\n            if (Character.isDigit(ch))\n                stack_num.push(ch - '0');\n\n            // 如遇到字母 进入其他栈\n            else if (Character.isAlphabetic(ch))\n                stack_string.push(String.valueOf(ch));\n\n            // 如遇到 [ 进入其他栈 并在数字栈做标记\n            else if (ch == '['){\n                stack_num.push(-1);\n                stack_string.push(String.valueOf(\"[\"));\n            }\n\n            // 遇到 ] 开始出栈进行拼接 后入栈\n            else{\n\n                // 新建一个 StringBuilder 来记录一次解码\n                StringBuilder tmp = new StringBuilder();\n\n                // 当栈不为空且 没有到本次解码的头 即 左括弧 [ 时 在 tmp 前面插入该字符（串）保证顺序\n                while (!stack_string.isEmpty() && !\"[\".equals(stack_string.peek()))\n                    tmp.insert(0, stack_string.pop());\n\n                // 遇到左括弧 弹出一次\n                stack_string.pop();\n\n                // 同时弹出数字栈的 标记 -1\n                stack_num.pop();\n\n                // cnt 用于计数括弧前的数字来判断括弧里面的字符串重复几次\n                int cnt = 0;\n                StringBuilder cntString = new StringBuilder();\n\n                // 求出重复次数\n                while (!stack_num.isEmpty() && -1 != stack_num.peek())\n                    cntString.insert(0, stack_num.pop());\n                cnt = Integer.parseInt(cntString.toString());\n\n                // 根据 cnt 次数来重复字符串\n                StringBuilder pushBack = new StringBuilder();\n                while(cnt-- > 0)\n                    pushBack.append(tmp);\n\n                // 重复以后再压入栈\n                stack_string.push(pushBack.toString());\n            }\n        }\n\n        // 当字符串遍历结束以后再用插入的方式汇总\n        StringBuilder sb = new StringBuilder();\n        while(!stack_string.isEmpty())\n            sb.insert(0, stack_string.pop());\n        return sb.toString();\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shin-guid":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086085454","body":"## 思路\r\n将A、K格式化为数组，反转，从低位开始相加，一直到最高位，注意处理进位\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const numArr = num.reverse();\r\n    const kArr = String(k).split('').reverse().map(Number);\r\n\r\n    let result = [];\r\n    let i = 0;\r\n    let curr = 0;\r\n    let carry = 0;\r\n    while(i < numArr.length || i < kArr.length || carry > 0) {\r\n        sum = (numArr[i] || 0) + (kArr[i] || 0) + carry;\r\n        curr = sum % 10;\r\n        carry = parseInt(sum / 10);\r\n        result[i] = curr;\r\n        i++;\r\n    }\r\n    return result.reverse();\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661461","body":"## 思路\n1. 遍历字符串，找出所有c的索引，成为索引数组\n2. 遍历字符串，每个字符串遍历索引数组求绝对值，取最小\n\n## code\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    // 转换为数组\n    // 遍历找出所有c的索引\n    // 遍历数组，比较距离，取最小值\n    const strArray = s.split('');\n    let cIndexArray = [];\n\n    strArray.forEach((s, i) => {\n        if (s === c) {\n            cIndexArray.push(i);\n        }\n    })\n    let result = [];\n    strArray.forEach((s, i) => {\n        let diff = Infinity;\n        cIndexArray.forEach((cIndex) => {\n            diff = Math.min(diff, Math.abs(cIndex - i));\n        })\n\n        result.push(diff);\n    })\n\n    return result;\n};\n\n## 复杂度\n\n- 时间复杂度：O(n2)\n- 空间复杂度：O(n)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086101381","body":"var addToArrayForm = function (num, k) {\r\n    let k_array = [];\r\n    let length_cal = 0;\r\n    let cal_array = [];\r\n    while (k > 0) {\r\n        let yu = k % 10;\r\n        k_array.unshift(yu);\r\n        k = (k - yu) / 10;\r\n    }\r\n\r\n    if (k_array.length < num.length) {\r\n        length_cal = num.length;\r\n        const len = k_array.length\r\n        for (let index = 0; index < length_cal - len; index++) {\r\n            k_array.unshift(0);\r\n        }\r\n    } else {\r\n        length_cal = k_array.length;\r\n        const len = num.length\r\n        for (let index = 0; index < length_cal - len; index++) {\r\n            num.unshift(0);\r\n        }\r\n    }\r\n\r\n    for (let index = 0; index < length_cal; index++) {\r\n        const m = num.pop();\r\n        const n = k_array.pop();\r\n        if (m + n >= 10) {\r\n            cal_array.unshift((m + n) % 10);\r\n            k_array[k_array.length - 1] = k_array[k_array.length - 1] + 1;\r\n            if (index === length_cal - 1) {\r\n                cal_array.unshift(1);\r\n            }\r\n        } else {\r\n            cal_array.unshift(m + n)\r\n        }\r\n    }\r\n\r\n    return cal_array;\r\n};\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086639124","body":"\n\n```JavaScript\nvar shortestToChar = function (s, c) {\n    let arr = s.split('');\n    for (let iterator in arr) {\n        if (arr[iterator] == c) {\n            arr[iterator] = 0\n        } else {\n            arr[iterator] = null;\n        }\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n        for (let j = 0; j < arr.length; j++) {\n            if (arr[j] === i) {\n                if (j > 0) {\n                    if (arr[j - 1] == null || arr[j - 1] > i + 1) {\n                        arr[j - 1] = i + 1;\n                    }\n                }\n                if (j < arr.length - 1) {\n                    if (arr[j + 1] == null || arr[j + 1] > i + 1) {\n                        arr[j + 1] = i + 1;\n                    }\n                }\n            }\n        }\n    }\n    return arr;\n};\n```\n\n**复杂度分析**\n\\- 时间复杂度：O(N^2)\n\\- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086896296","body":"\n\n```JavaScript\nvar CustomStack = function (maxSize) {\n\n    this.stack = [];\n    this.maxSize = maxSize;\n\n    //for loop create array, value default null, size = maxSize\n    for (let index = 0; index < maxSize; index++) {\n        this.stack[index] = null;\n    }\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n\n    // stack's last one is not null, do not push\n    if (this.stack[this.maxSize - 1] !== null) {\n        return;\n    }\n\n    // for loop find the first index is null, push parameter at index\n    const indexCanPush = this.stack.findIndex(element => element === null);\n    this.stack[indexCanPush] = x;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    // find the first one (called lastOne) is not null from the tail of stack\n    const { lastOne, lastOneIndex } = this.lastOne();\n\n    // the index value of lastOne set to null, return last one\n    if (lastOne !== -1) {\n        this.stack[lastOneIndex] = null\n    }\n\n    return lastOne;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n\n    // from tail to head, find the first one is not null\n    const { lastOne, lastOneIndex } = this.lastOne();\n\n    for (let index = lastOneIndex; index >= 0 && k > 0; index--, k--) {\n        this.stack[lastOneIndex] += val;\n    }\n};\n\nCustomStack.prototype.lastOne = function () {\n\n    // from tail to head, find the first one is not null\n    let lastOne = -1;\n    let lastOneIndex = -1;\n    for (let tail = this.maxSize - 1; tail >= 0; tail--) {\n        if (this.stack[tail] !== null) {\n            lastOne = this.stack[tail];\n            lastOneIndex = tail;\n            return { lastOne, lastOneIndex };\n        }\n    }\n\n    return { lastOne, lastOneIndex };\n\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087640793","body":"```javascript\nvar decodeString = function(s) {\n\n    let numStack = []; \n    let strStack = []; \n    let temp = ''; \n    let num = 0; \n    for(let i = 0; i < s.length; i++) { \n        const c = s[i];\n        if(/\\d/.test(c)) { \n            num = num * 10 + (c.charCodeAt() - '0'.charCodeAt()); \n        } else if(c === '[') {\n            strStack.push(temp); \n            numStack.push(num); \n            num = 0;\n            temp = '';\n        } else if(c ===']') { \n            let repeatTimes = numStack.pop();\n            temp = strStack.pop() + temp.repeat(repeatTimes); \n        } else {\n            temp += c; \n        }\n    }\n\n    return temp;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088540596","body":"```javascript\nclass MyQueue {\n    stack: number[] = [];\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.stack.push(x);\n    }\n\n    pop(): number {\n        const top = this.stack[0];\n        // this.stack.splice(0, 1);\n        for (let index = 1; index < this.stack.length; index++) {\n            this.stack[index - 1] = this.stack[index];\n        }\n        this.stack.pop();\n        return top;\n    }\n\n    peek(): number {\n        return this.stack[0]\n    }\n\n    empty(): boolean {\n        if (this.stack.length <= 0) {\n            return true;\n        }\n        return false;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nancychien":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086268399","body":"思路：\r\n1. 找出目標 index 位置並 save to a target list\r\n2. loop through 原來的字串和target list 並計算最小距離\r\n`\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        target = []\r\n        output = []\r\n\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                target.append(i)\r\n\r\n        for i in range(len(s)):\r\n            output.append(min(abs(i-x) for x in target))\r\n\r\n        return output\r\n`\r\n\r\nTime complexity: O(n^2)\r\nSpace complexity:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086768346","body":"思路：\r\n用 list 去模擬出 stack 的操作\r\n`\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize  = maxSize\r\n        self.cur_size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size == self.maxSize: \r\n            return -1\r\n        self.stack.append(x)\r\n        self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack: \r\n            return -1\r\n        res = self.stack.pop()\r\n        self.cur_size -= 1\r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(self.cur_size, k)): \r\n            self.stack[i] += val\r\n`\r\nTime Complexity:\r\n- push: O(1)\r\n- pop: O(1)\r\n- increment: O(N)\r\nSpace Complexity:\r\n- push: O(1)\r\n- pop: O(1)\r\n- increment: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088111025","body":"### 思路\r\nUse two stacks. One for pushing (stack_push), one for popping (stack_pop)\r\n`\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stack_push = []\r\n        self.stack_pop = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_push.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        # stack_pop is empty\r\n        if not self.stack_pop: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n        result = self.stack_pop.pop()\r\n        return result\r\n        \r\n    def peek(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if self.stack_pop: \r\n            return self.stack_pop[-1]\r\n        else: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n            return self.stack_pop[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack_push and not self.stack_pop\r\n`\r\n\r\nTime complixiety:\r\npush - O(1)\r\npop  - O(n)\r\npeek - O(n)\r\nempty - O(1)\r\nSpace complixiety:\r\npush - O(n)\r\npop  - O(1)\r\npeek - O(1)\r\nempty - O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lannyx":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086420045","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()]; //create new array to store answer\r\n        int dummy = Integer.MIN_VALUE/2; // initiate a variable as the min value to store \r\n\r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c) dummy = i;\r\n            res[i] = i - dummy;\r\n        }\r\n\r\n        dummy = Integer.MAX_VALUE;\r\n        for(int i = s.length() - 1; i >= 0; i--){\r\n            if(s.charAt(i) == c) dummy = i;\r\n            res[i] = Math.min(res[i], dummy - i);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087119592","body":"### 代码\n```java\nclass Solution {\n    int index = 0;\n    public String decodeString(String s) {\n        String str = recursive(s);\n        return str;\n    }\n\n    public String recursive(String s){\n        StringBuilder sb = new StringBuilder();\n        while(index < s.length()){\n            char cur = s.charAt(index);\n            index++;\n            if(cur >= '0' && cur <= '9'){\n                int num = cur - '0';\n                while(s.charAt(index) >= '0' && s.charAt(index) <= '9'){\n                    num = num * 10 + s.charAt(index) - '0';\n                    index++;\n                }\n                String str = recursive(s);\n                for(int i = 0; i < num; i++){\n                    sb.append(str);\n                }\n            }else if(cur == '['){\n                \n            }else if(cur == ']'){\n                break;\n            }else{\n                sb.append(cur);\n            }\n        }\n        return sb.toString();\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pureryudo":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086506715","body":"### 思路\n\n进行两次遍历\n\n使用prev记录上一次出现的c的位置，初始值设为极小的负数。\n\n第一次从左到右遍历，记录当前位置i到prev的绝对值。\n\n第二次从右到左遍历，记录当前位置i到prev的绝对值，并与第一次遍历的结果取min存入结果数组，\n\n### 代码\n\n```java\npublic int[] shortestToChar(String s, char c) {\n    int[] result = new int[s.length()];\n    char[] chars = s.toCharArray();\n    /*记录当前遍历中上一个c出现的位置\n        初始值设置为极小的负数用于在比较时获得正确的值*/\n    int prev = Integer.MIN_VALUE/2;\n    /*第一次遍历 从左到右 记录与上一个c的距离*/\n    for (int i = 0; i < chars.length; i++){\n        //还没有出现过c\n        if (chars[i] == c){\n            prev = i;\n        }\n        result[i] = Math.abs(i-prev);\n    }\n    /*第二次遍历 从右到左 记录与上一个c的距离*/\n    prev = -1;\n    for (int i = chars.length-1; i >= 0; i--){\n        if (chars[i] == c){\n            prev = i;\n        }\n        result[i] = Math.min(result[i],Math.abs(prev-i));\n    }\n    return result;\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(N) N为数组长度\n\n额外空间复杂度：O(N) 新建了一个长度为N的数组用于存放结果","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoliz":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086560188","body":"思路:   先查遍历找出C值对应的下标索引存储includesIndex中， 在进行一次循环 当前值等于C那么距离直接为0，内部进行二次循环 includesIndex arr 进行绝对值计算 \n\n\nvar shortestToChar = function(s, c) {\n\n    let includesIndex = [];\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) {\n            includesIndex.push(i)\n        }\n    }\n\n    var res = Array(s.length).fill(0);\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            res[i] = 0;\n            continue;\n        }\n\n        for(let val of includesIndex ) {\n            const dist = Math.abs(val - i)\n            \n            if (dist >= res[i]) break;\n            res[i] = dist;\n        }\n    }\n    return res;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086754886","body":"### 思路\r\n数组实现栈\r\n\r\n### 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.number = maxSize\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.number > this.stack.length) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(!this.stack.length) return -1;\r\n    return this.stack.pop();\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for( let i = 0; i < this.stack.length; i++) {\r\n        if (i < k) {\r\n            this.stack[i] += val\r\n        }   \r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度： push:O(1)、pop：O(1)  O(N)  N:  是k，需增量元素个数\r\n- 空间复杂度  O(N)   N: maxSize\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088188139","body":"### 思路\n看到这个题型首先想到数组增删改查\n\n### 代码\n```javascript\nvar MyQueue = function() {\n    this.tasck = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    return this.tasck.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.tasck.shift()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.tasck.slice(0, 1)\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n   return !this.tasck.length;\n};\n```\n\n### 复杂度分析\n- 时间复杂度: O(1)\n- 空间复杂度: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenliangchen":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086565399","body":"## 思路：\r\n先从左边遍历，每次遍历中 先找到对应的目标的下标，在过程中利用i的下标去减去最小值的二分之一，（目的是在没找到的情况下，通过减去最小值留下一个最大数值，最小值为负数 i - -则变为加法）。之后进行右边遍历，同理，在过程中进行大小的比较。对比两次遍历最小的值是哪个，这样即可得到正确答案。\r\n\r\n用最小值的目的是为了避免溢出\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int len = S.length();\r\n        int[] ans = new int[len];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = len-1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n - 时间复杂度：O(N)\r\n - 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086770200","body":"## 思路\r\n利用数组进行数据的存储，在push和pop时判断情况，并记录下标和最大容量\r\n\r\n## 代码\r\n\r\n```\r\npublic class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top =-1;\r\n    }\r\n    public void Push(int x) {\r\n        if(top!=stack.Length-1)\r\n        {\r\n            top++;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n    public int Pop() {\r\n        if(top==-1)\r\n        {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    public void Increment(int k, int val) {\r\n        int limit = Math.Min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i)\r\n        {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：push 和 pop 操作的时间复杂度为 O(1)，其余为O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087238550","body":"## 思路\r\n维护一个栈 和临时链表来进行括号匹配和字符串储存，当遇到右括号开始pop计算后形成新字符串，然后重新入栈\r\n\r\n\r\n## 代码\r\n```\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int len = s.length();\r\n        StringBuilder sb = new StringBuilder();\r\n        Stack<Character> st = new Stack<>();\r\n        for(int i = 0; i < len;i++){\r\n            \r\n            char t = s.charAt(i);\r\n            if(t == ']'){                   \r\n                List<Character> temp = new ArrayList<>();\r\n                while(st.peek()!='['){\r\n                    temp.add(st.pop());\r\n                   } \r\n                \r\n                    st.pop(); // remove the '['\r\n                    int base =1;\r\n                    int k = 0;\r\n                    while( !st.empty() && Character.isDigit(st.peek() )){\r\n                         k = k + (st.pop() - '0' ) * base;\r\n                         base *= 10;\r\n                    }\r\n\r\n                    while(k!=0){\r\n                        for(int j = temp.size() -1; j >=0;j--){\r\n                            st.push(temp.get(j));\r\n                        }\r\n                        k--;\r\n                    }\r\n                \r\n            }else{\r\n                st.push(t);\r\n            }\r\n        \r\n        }\r\n        char[] ans = new char[st.size()];\r\n        int j = st.size()-1;\r\n        while(!st.empty()){\r\n            ans[j] = st.pop();\r\n            j--;\r\n        }\r\n\r\n        \r\n        return new String(ans);\r\n    }\r\n}\r\n\r\n```\r\n## 复杂度\r\n - 时间 O(K*K *N) \r\n - 空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088372686","body":"## 思路\r\n维护两个栈，一个专门用来入，另一个在出时负责倒一下。\r\n\r\n## 代码\r\n\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> st;\r\n    Stack<Integer> ans;\r\n    int f;\r\n\r\n    public MyQueue() {\r\n        st = new Stack<>();\r\n        ans = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(st.empty()){\r\n            f =x;\r\n        }\r\n        \r\n        st.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(ans.empty()){\r\n            while(!st.empty()){\r\n                ans.push(st.pop());\r\n            }\r\n        }\r\n        return ans.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(!ans.empty()) return ans.peek();\r\n        \r\n        return f;\r\n    }\r\n    \r\n    public boolean empty() {\r\n\r\n        \r\n        return ans.empty() && st.empty();\r\n    }\r\n    \r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间  push: O(1) peek: O(n) pop: O(n) empty: O(1)\r\n- 空间   O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086566581","body":"4.2算法题：\nIdea：\n1.找到指定字符在目标字符串的下标并放进一个数组记录。\n2.循环比较字符串中每个字符距离和指定字符的距离，记录下较小的一个，放入另一个数组。\n\nCode：\n\nvar shortestToChar = function(s, c) {\n    var nearstXb = [];\n    var absDis = [];\n\n    for(var i=0;i<s.length;i++){\n      if(s[i] == c){\n      nearstXb.push(i);}    \n    };\n\n    for(var i=0;i<s.length;i++){\n        var min2 = s.length;\n        for(var j=0;j<nearstXb.length;j++){\n            var min1 = Math.abs(i-nearstXb[j])\n            if(min1<min2){\n               min2 = min1;}\n        }\n        absDis.push(min2);\n    }\n\n    return absDis;\n\n}\n \n时间复杂度：O(N^2)\n空间复杂度：（1）\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088765863","body":"Idea: 双栈对放思路，彼此为镜像，出栈时先将1栈的数压入2栈，再将2栈打印，即可实现。\n\nCode:\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n\n\n  \nComplexity:\n时间：O(n）,空间：O（1）\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086582373","body":"### 思路\n\n第一想法是以当前字符为中心，然后向左右两边搜索，搜索到的第一个C即可得到当前字符到C的最小距离。\n但是这样的算法复杂度是O(N^2)\n\n第二想法是首先将C在S中的索引全部找出来，这样就可以用当前字符的索引直接减到C的索引，从而得到一个最小值\n这样的算法复杂度就是O(N)。下面的代码是这个想法的实现。\n\n后来又看了一下官方的题解，发现是遍历正、反二次就可以解决了。果然是我太菜了。。。。。。\n\n### 代码\n\n\n```Go\nfunc shortestToChar(s string, c byte) []int {\n\tvar cIdx []int\n\tvar ret []int\n\n\tinitCIdx := func() {\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tif s[i] == c {\n\t\t\t\tcIdx = append(cIdx, i)\n\t\t\t}\n\t\t}\n\t}\n\n\tgetDistance := func(idx int) int {\n\t\tmin := math.MaxInt32\n\t\tfor _, ii := range cIdx {\n\t\t\ttmp := int(math.Abs(float64(ii - idx)))\n\t\t\tif tmp < min {\n\t\t\t\tmin = tmp\n\t\t\t}\n\t\t}\n\t\treturn min\n\t}\n\n\tinitCIdx()\n\tfor i := 0; i < len(s); i++ {\n\t\tret = append(ret, getDistance(i))\n\t}\n\n\treturn ret\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)，最坏时，C和S的长度一样","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086797464","body":"### 思路\n粗看还蛮简单的，直接使用数组来模拟，push和pop操作都在数组尾操作，时间上都是O(1)，inc操作是O(k)\n按此实现并提交，发现只击败40%，看来还有改进空间。\n\npush和pop都已经是O(1)了，那就只有inc可以改进。一时想不出来，查看是解后，发现只记录增量及位置，\n直到需要返回的栈顶元素的时候才计算真实的值，这样每个pop操作也只计算一次，不影响pop的执行效率。\n按此方法，inc的执行效率也改进为O(1)。\n\n### 代码\n\n\n```Go\ntype CustomStack struct {\n    data []int\n    add []int\n    idx int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{data: make([]int, maxSize), add: make([]int, maxSize), idx: 0}\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if this.hasSpace() {\n        this.data[this.idx] = x\n        this.idx++\n    }\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if !this.hasElement() {\n        return -1\n    }\n    \n    this.idx--\n    element := this.data[this.idx] + this.add[this.idx]\n\n    if this.idx > 0 {\n        this.add[this.idx - 1] += this.add[this.idx]\n    }\n    this.add[this.idx] = 0\n\n    return element\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    // for i := 0; i < this.idx && i < k; i++ {\n        // this.data[i] += val\n    // }\n    if !this.hasElement() {\n        return\n    }\n\n    if k >= this.idx {\n        this.add[this.idx - 1] += val\n    } else {\n        this.add[k - 1] += val\n    }\n}\n\nfunc (this *CustomStack) hasSpace() bool {\n    return this.idx < cap(this.data)\n}\n\nfunc (this *CustomStack) hasElement() bool {\n    return this.idx > 0\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(N), N为栈最大空间。因为需要一个额外的辅助数组add","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087604329","body":"### 思路\n一开始没看到有嵌套的情况，我还想这个题还蛮简单的，写出来的第一版当然不通过。\n第二版将待解析的字符串先入栈，碰到右括号才弹出，这样可以解析出最内层的字符串。\n若还有外层的字符串未解析，则继续将解析出来内层字符串写回到栈中，若已经到达最\n外层了，则可以将此解析后字符串写到结果中\n\n### 代码\n\n\n```Go\n\nfunc decodeString(s string) string {\n\tvar ret bytes.Buffer\n\tvar cache []byte\n\n\tfindRepeatNumString := func() (int, int, int, int) {\n\t\tnumBegin, numEnd, sBegin, sEnd  := -1, -1, -1, -1\n\n\t\tsEnd = len(cache) - 1\n\t\tfor j := sEnd; j >=0; j-- {\n\t\t\tif numEnd == -1 && cache[j] >= '0' && cache[j] <= '9' {\n\t\t\t\tsBegin = j + 2\n\t\t\t\tnumEnd = j + 1\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif numEnd != -1 && (cache[j] < '0' || cache[j] > '9') {\n\t\t\t\tnumBegin = j + 1\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif numBegin == -1 {\n\t\t\tnumBegin = 0\n\t\t}\n\n\t\treturn numBegin, numEnd, sBegin, sEnd\n\t}\n\n\tdecodeSubString := func() {\n\t\tvar subString bytes.Buffer\n\n\t\tnumBegin, numEnd, sBegin, sEnd := findRepeatNumString()\n\t\tnum, _ := strconv.Atoi(string(cache[numBegin:numEnd]))\n\t\tfor i := 0; i < num; i++ {\n\t\t\tsubString.Write(cache[sBegin:sEnd])\n\t\t}\n\n\t\tif numBegin == 0 {\n\t\t\tret.Write(subString.Bytes())\n\t\t\tcache = cache[:0]\n\t\t} else {\n\t\t\tcache = append(cache[:numBegin], subString.Bytes()...)\n\t\t}\n\t}\n\n\tfor i := 0; i < len(s); i++ {\n\t\tif len(cache) == 0 && s[i] >= 'a' && s[i] <= 'z' {\n\t\t\tret.WriteByte(s[i])\n\t\t\tcontinue\n\t\t}\n\n\t\tcache = append(cache, s[i])\n\t\tif s[i] == ']' { decodeSubString() }\n\t}\n\n\treturn ret.String()\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：如果没有嵌套的情况，时间复杂度应该是O(S)，即解码后的长度。嵌套的情况我也不太确定\n- 空间复杂度：O(S)，即解码后的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088203400","body":"### 思路\n\n见代码\n\n### 代码\n\n\n```Go\ntype MyQueue struct {\n\tinput *MyStack\n\toutput *MyStack\n}\n\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tinput: new(MyStack),\n\t\toutput: new(MyStack),\n\t}\n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n\tthis.input.Push(x)\n}\n\n\nfunc (this *MyQueue) Pop() int {\n\t// 题目保证不会在空的栈上面调用pop/peek\n\tif this.output.IsEmpty() {\n\t\tthis.inputToOutput()\n\t}\n\treturn this.output.Pop()\n}\n\n\nfunc (this *MyQueue) Peek() int {\n\tif this.output.IsEmpty() {\n\t\tthis.inputToOutput()\n\t}\n\treturn this.output.Peek()\n}\n\n\nfunc (this *MyQueue) Empty() bool {\n\tif this.input.Size() != 0 || this.output.Size() != 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (this *MyQueue) inputToOutput() {\n\tfor !this.input.IsEmpty() {\n\t\tthis.output.Push(this.input.Pop())\n\t}\n}\n\ntype MyStack struct {\n\tdata []int\n}\n\nfunc (receiver *MyStack) Pop() int {\n\tif receiver.IsEmpty() {\n\t\treturn -1\n\t}\n\n\tv := receiver.data[len(receiver.data) - 1]\n\treceiver.data = receiver.data[:len(receiver.data) - 1]\n\treturn v\n}\n\nfunc (receiver *MyStack) Peek() int {\n\tif receiver.IsEmpty() {\n\t\treturn -1\n\t}\n\n\treturn receiver.data[len(receiver.data) - 1]\n}\n\nfunc (receiver *MyStack) Push(v int) {\n\treceiver.data = append(receiver.data, v)\n}\n\nfunc (receiver *MyStack) Size() int {\n\treturn len(receiver.data)\n}\n\nfunc (receiver *MyStack) IsEmpty() bool {\n\treturn len(receiver.data) == 0\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：push和empty是O(1)。pop和peek由于有一个遍历动作，看上去是N(N), 但是随后的pop/peek就是O(1)了，所以，平摊一下的话，应该就是O(1)。综上，平均时间复杂度为O(1)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winrunwang":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086593212","body":"思路:\n遍历一次，用2个临时变量存储指针信息。中间第二个for循环调整距离问题\npublic int[] shortestToChar(String s, char c) {\n        int first = -1;\n        int temp = -1;\n        int n  = s.length();\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            char t = s.charAt(i);\n            if(t == c){\n                res[i] = 0;\n                if(first == -1){\n                    first = i;\n                }\n                if(temp!= -1){\n                    for (int j = temp; j < i; j++) {\n                        res[j] = Math.min(i-j,res[j]);\n                    }\n                }\n                temp = i;\n            }\n            if(first != -1){\n                res[i] = i-temp;\n            }\n        }\n        for (int i = 0; i < first; i++) {\n            res[i] = first - i;\n        }\n        return res;\n    }\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088756960","body":"设立头尾。每次更新的时候头尾做个转换即可\n\n\nStack<Integer> head,tail;\n\n    public Solution232() {\n        head = new Stack<>();\n        tail = new Stack<>();\n\n    }\n\n    public void push(int x) {\n          tail.push(x);\n    }\n\n    public int pop() {\n         peek();\n         return head.pop();\n    }\n\n    public int peek() {\n        if (head.isEmpty())\n            // 把 s1 元素压入 s2\n            while (!tail.isEmpty())\n                head.push(tail.pop());\n        return head.peek();\n    }\n\n    public boolean empty() {\n      return head.isEmpty() && tail.isEmpty();\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carterrr":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086601300","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n            char[] array = s.toCharArray();\n            int len = s.length();\n            int[] res = new int[len];\n            Arrays.fill(res, len);\n            int idx_c = -1;\n            for(int i = 0; i < len ; i++) {\n                if(array[i] == c) {\n                    idx_c = i;\n                    res[i] = 0;\n                    continue;\n                }\n                if(idx_c != -1) {\n                    res[i] = i - idx_c;\n                }\n            }\n            for(int i = len - 1; i >= 0 ; i--) {\n                if(array[i] == c) {\n                    idx_c = i;\n                    continue;\n                }\n                if(idx_c > i) {\n                    res[i] = Math.min(res[i], idx_c - i);\n                }\n                \n            }\n            return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086802767","body":"class CustomStack {\n\n    int[] data;\n    int[] add;\n    int maxSize;\n    int curSize;\n\n    public CustomStack(int maxSize) {\n        data = new int[maxSize];\n        add = new int[maxSize];\n        this.maxSize = maxSize;\n        this.curSize = 0;\n    }\n    \n    public void push(int x) {\n        if(curSize == maxSize){\n            return;\n        }\n        data[curSize++] = x;\n    }\n    \n    public int pop() {\n        if(curSize == 0) return -1;\n        int res = data[curSize - 1] + add[curSize - 1];\n        if(curSize > 1) {\n            add[curSize - 2] += add[curSize - 1]; \n        }\n        add[curSize - 1] = 0;\n        curSize--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        if(curSize == 0) return;\n        add[Math.min(k, curSize) - 1] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087293757","body":"class Solution {\n    public String decodeString(String s) {\n        // 碰到【 入栈字母  碰到 】出栈字母并计算\n        Deque<String> cStack = new LinkedList<>();   // 存储的是[ 后  数字前的字符串  如  2[ab3[cd4[ef]]] 中的ab  cd  依次入栈  \n        Deque<Integer> nStack = new LinkedList<>();  // 存储的是[ 前的数字  如上例中的 2 3 4\n        char[] arr = s.toCharArray();\n        // 难点  数字可能不止一位数\n        int num = 0;\n        String piece = \"\";\n        for(char c : arr) {\n            if ( c >= '0' && c <= '9') {\n                num = num * 10 + (c - '0');\n            } else if (c == '[') {\n                nStack.push(num);\n                cStack.push(piece);\n                num = 0;\n                piece = \"\";\n            } else if (c == ']') {\n                String inner = piece;\n                int cnt = nStack.pop() - 1;\n                for(int i = 0 ; i < cnt; i ++) {\n                    piece += inner;\n                }\n                piece = cStack.pop() + piece;\n            } else {\n                piece += c;\n            }\n        }\n        return piece;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088220824","body":"class MyQueue {\n\n    Deque<Integer> pushStack;\n    Deque<Integer> popStack;\n\n    public MyQueue() {\n        pushStack = new LinkedList<>();\n        popStack = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        if(popStack.isEmpty()){\n            transfer();\n        }\n        if(popStack.isEmpty()) \n        return -1;\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        if(popStack.isEmpty()){\n            transfer();\n        }\n        if(popStack.isEmpty()) \n        return -1;\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n\n    private void transfer() {\n        while(!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ethanwlx":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086617041","body":"思路：先从左往右，找每个index离左边最近的距离，再从右边往左，最后取左右的最小值。\n时间：O(n)\n空间：O(n)\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans_l = [float(inf)] * len(s)\n        ans_r = [float(inf)] * len(s)\n        ans = [0] * len(s)\n       \n        for i in range(len(s)):\n            if i == 0:\n                if s[i] == c:\n                    ans_l[i] = 0   \n            else:\n                ans_l[i] = ans_l[i-1] + 1 if s[i] != c else 0\n\n        for i in range(len(s) - 1, -1, -1):\n            if i == len(s) - 1:\n                if s[i] == c:\n                    ans_r[i] = 0          \n                ans[i] = min(ans_l[i], ans_r[i])\n            else:\n                ans_r[i] = ans_r[i+1] + 1 if s[i] != c else 0\n                ans[i] = min(ans_l[i], ans_r[i])\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086767347","body":"难点在于用O(1)时间处理增加量，假设我们记录增加量的值，指令分别为（1,20） （2,40） （4，40） （4，60）\n并画出图\n1##\n2####\n3\n4##########\n对于4 增加量就是 100\n对于3也是100\n对于2就是100+40=140\n对于1就是140+20= 160\n对于 i 位置就是上一个位置的值+自己本身的值\n把这张表格记录下来我们就可以做到线性时间得到每一个位置的增加量值\n时间： O（1）\n空间： O(maxsize)\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.addition = []\n        self.maxSize = maxSize\n        self.size = 0\n\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.addition.append(0)\n            self.size += 1\n\n\n    def pop(self) -> int:\n        if self.size > 0:\n            if self.size > 1:\n                self.addition[-2] += self.addition[-1]\n            st = self.stack.pop() + self.addition.pop()\n            self.size -= 1\n            return st\n        return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.size > 0:\n            self.addition[min(k,self.size)-1] += val\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"babbomax98":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086650773","body":"### 思路\n使用双指针，然后遍历字符串\n\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] result=new int[N];\n        int indexNext=S.indexOf(C);//双指针，indexNext表示下一个C的下标， \n        int index=indexNext;//index表示前一个C的坐标\n    // 通过这里的赋值使在只有左边有C字符的时候（此时index = indexNext）的时候\n    //index也在当前字符的右边，否则在左右都有C字符的时候，当前字符必在index和indexNext的中间。\n       for(int i = 0; i < S.length(); i++){\n            if(S.charAt(i) == C){//每当遍历到C就更新index和indexNext\n                result[i] = 0;\n                index = i;\n                indexNext = S.indexOf(C, i+1);\n                //这里如果当前是最后一个C时，此时indexNext为-1，这也保证了上面的情况\n            }else{\n                result[i] = Math.min(Math.abs(index - i), Math.abs(indexNext - i));\n            }\n        }\n       return result;\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O（n）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086854030","body":"### 思路\n使用栈实现\n### 代码\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack=new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top!=stack.length-1){\n            ++top;\n            stack[top]=x;\n        }\n\n    }\n    \n    public int pop() {\n        if(top==-1)\n            return -1;\n        --top;\n        return stack[top+1];\n\n    }\n    \n    public void increment(int k, int val) {\n        int li=Math.min(k,top+1);\n        for(int i=0;i<li;i++){\n            stack[i]+=val;\n        }\n\n    }\n}\n```\n### 复杂度分析\n时间复杂度：push和pop是0（1）,inc是O(k)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088759764","body":"### 思路\n使用双栈进行实现\n### 代码\n```java\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack=new LinkedList<>();\n        outStack=new LinkedList<>();\n\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if(outStack.isEmpty()){\n            inout();\n        }\n    return outStack.pop();\n    }\n \n    public int peek() {\n        if(outStack.isEmpty()){\n            inout();\n        }\n    return outStack.peek();\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tt-fantastic":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086653492","body":"public int[] shortestDistance(String s, char c) {\n        int[] arr = new int[s.length()];\n        int distance = Integer.MIN_VALUE；\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                distance = i;\n            }\n            arr[i] = i - distance;\n        }\n\n        distance = Integer.MAX_VALUE;\n        for (int j = s.length() - 1; j >= 0; j--) {\n            if (s.charAt(j) == c) {\n                distance = j;\n            }\n            arr[j] = Math.min(arr[j], distance - j);\n        }\n       return arr;","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyh331":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086658067","body":"### **Day2**  思路  \n\n两边都遍历，最后留下较小的值  \n\n### 代码  \n\n```\nc++\nclass Solution \n{\npublic:\n    vector<int> shortestToChar(string s, char c) \n    {\n        vector<int> ans(s.size(), 0);\n        int left = INT_MAX;\n        int right = INT_MAX;\n        for(int i = 0; i < s.size(); i ++) \n        {\n            if (s[i] == c) \n            {\n                left = i;\n            }\n            ans[i] = i - left;\n        }\n        for(int i = s.size() - 1; i >= 0; i --) \n        {\n            if (s[i] == c) \n            {\n                right = i;\n            }\n            ans[i] = min(abs(ans[i]), right - i);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086862033","body":"### Day3 思路\n考虑用vector(本质为单端动态数组)容器实现。\n1. 构造函数中用m_Maxsize接收传入进来的maxSize。\n2. void push中判断数组元素个数<m_Maxsize？然后_.push_back(x)将x压入堆栈\n3. void pop中用_.empty()判断容器是否为空,不为空时先用**int top=_.back();保留引用，后续返回top**，再进行出栈操作。\n4. increment中for保证i < k && i < _.size()就可以\n### 代码\n```c++\nclass CustomStack {\npublic:\n    vector<int> stack;\n    int m_Maxsize;\n    //构造函数\n    CustomStack(int maxSize) {\n        m_Maxsize=maxSize;\n        //stack.resize(maxSize);\n    }\n    //入栈函数\n    void push(int x) {\n        if(stack.size()<m_Maxsize){\n            stack.push_back(x);\n        }\n    }\n    //出栈函数,弹出栈顶元素，并返回栈顶的值，栈为空时返回-1\n    int pop() {\n        if(stack.empty()){\n            return -1;\n        }\n        else{\n            //要返回的是出栈前的栈顶，所以需要先把栈顶保留引用，用 int top=stack.back();接收一下\n            int top = stack.back();\n            stack.pop_back();\n            return top;\n        }\n\n    }\n    //栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val\n    void increment(int k, int val) {\n        for(int i=0 ; i<k && i<stack.size();i++){\n            stack[i]+=val;\n        }\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度\npush:O(1)\npop:O(1)\nincr:O(k)\n- 空间复杂度\npush:O(1)\npop:O(1)\nincr:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087681416","body":"### Day3 思路\n用栈来解决问题\n### 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        stack <int> nums;\n        stack <string> strs;\n        int num = 0;\n        int len = s.size();\n        for(int i = 0; i < len; ++ i)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[') //将‘[’前的数字压入nums栈内， 字母字符串压入strs栈内\n            {\n                nums.push(num);\n                num = 0;\n                strs.push(res); \n                res = \"\";\n            }\n            else //遇到‘]’时，操作与之相配的‘[’之间的字符，使用分配律\n            {\n                int times = nums.top();\n                nums.pop();\n                for(int j = 0; j < times; ++ j)\n                    strs.top() += res;\n                res = strs.top(); //之后若还是字母，就会直接加到res之后，因为它们是同一级的运算\n                                  //若是左括号，res会被压入strs栈，作为上一层的运算\n                strs.pop();\n            }\n        }\n        return res;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088375886","body":"\n### Day5 思路\n使用两个栈来实现队列，一个是输入栈，一个是输出栈。\n1. push操作直接压入输入栈即可。输入栈的元素顺序是和队列相反的。\n2. pop操作需要先判断输出栈是否为空，然后将输入栈全部放入到输出栈，此时输出栈的**栈顶到栈底的元素排列**就和**队列中队头到队尾的元素排列**一致。\n3. peek操作，使用2中已有的pop函数,注意最后要将出栈的元素放回去。\n3. empty，只需判断两个栈是否为空即可\n### 代码\n```c++\nclass MyQueue {\npublic:\n    stack<int> StkIn, StkOut;\n    MyQueue() {\n\n    }\n    //入队，直接将数据x压入StkIn即可\n    void push(int x) {\n        StkIn.push(x);\n    }\n    //出队，\n    int pop() {\n        //当StkOut栈为空时，将StkIn的元素全部放入StkOut，\n        //这样做StkOut中从栈顶到栈底元素的排列就和队列中从队头到队尾一致。\n        if(StkOut.empty()){\n            while(!StkIn.empty()){\n                StkOut.push(StkIn.top());\n                StkIn.pop();\n            }\n        }\n        int result=StkOut.top();\n        StkOut.pop();\n        return result;\n    }\n    //返回队列首部的元素。\n    int peek() {\n        int res=this->pop();//直接使用已经写好的pop函数\n        StkOut.push(res);//pop函数中弹出了res，所以要添加回去\n        return res;\n\n    }\n    //返回队列是否为空，只需判断两个栈是否都为空即可\n    bool empty() {\n        return StkIn.empty()&&StkOut.empty();\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：push和empty是O(1)，pop和peek是O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kennethalgol":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086659398","body":"# 思路\r\n双指针\r\n# 语言\r\njava\r\n\r\n```java\r\npublic int[] shortestToChar(String S, char C) {\r\n        \r\n        int[] res = new int[S.length()];\r\n        int cur = S.indexOf(C), pre = cur;\r\n        for(int i = 0; i < S.length(); i++){\r\n            if(S.charAt(i) == C){//其实就是每当遍历到C就更新cur和pre\r\n                res[i] = 0;\r\n                pre = i;\r\n                cur = S.indexOf(C, i+1);//注意：这里如果当前是最后一个C时，此时cur为-1，这也保证了上面的情况3\r\n\r\n            }else{\r\n                res[i] = Math.min(Math.abs(pre - i), Math.abs(cur - i));//\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n# 复杂度分析\r\n时间 O(n) 空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086660008","body":"# 思路\r\n模拟\r\n\r\n```java\r\nclass CustomStack {\r\n    \r\n    private int[] array;\r\n    private int maxSize;\r\n    private int curSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.array = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        this.curSize = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(this.curSize < this.maxSize){\r\n            array[curSize++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(this.curSize > 0){\r\n            return array[--curSize];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(curSize > 0){\r\n            for(int i = 0; i < k && i < curSize; i++){\r\n                array[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dtldtt":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086666626","body":"### 思路\n\n把原数组str中的c的下标取出来单独放在一个数组中，作为判断的边界。相当于几个分割点，除了开头和末尾的特殊情况，每次只需要判断离前一个分界点近还是离后一个分界点近就可以了。\n\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n#define MIN(x,y) ((x)<(y) ? (x) : (y))\n    vector<int> shortestToChar(string str, char c) {\n        vector<int> flags;\n        vector<int> answer;\n        for(int i=0;i<str.size();i++){\n            if(str[i]==c) flags.push_back(i);\n        }\n        //print_vector(flags);\n        //cout<<\"end\\n\";\n        int current_flag=0;\n        for(int i=0;i<str.size();i++){\n            if(current_flag==flags.size()){\n            answer.push_back(i-flags[current_flag-1]);\n            continue;\n            }\n            if(i>flags[current_flag]) {current_flag++; i--; continue;}\n            else if(current_flag==0){\n            answer.push_back(flags[current_flag]-i);\n            continue;\n            }\n            answer.push_back(MIN(i-flags[current_flag-1],flags[current_flag]-i));\n        }\n        return answer;\n            }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086819738","body":"### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n\n### 思路\n\n就是用数组实现一个栈，标记对栈顶元素做好标记就好\n\n### 代码\n\n\n```cpp\n\nclass CustomStack {\nprivate:\n    int maxSize;\n    int *stack;\n    int num; //当前有几个数在栈中\npublic:\n    CustomStack(int maxSize) {\n        this->maxSize=maxSize;\n        this->stack = new int[maxSize];\n        num=-1;\n    }\n    ~CustomStack(){\n        delete [] this->stack;\n    }\n    bool is_empty()\n{\n    return num==-1;\n}\n    \n    void push(int x) {\n        if(num<maxSize-1) stack[++num]=x;\n        else return;\n    }\n    \n    int pop() {\n        if(is_empty()) return -1;\n        return stack[num--];\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<k && i<=num;i++){\n          stack[i]+=val;\n        }\n    }\n};\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(1)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087720258","body":"### [394. 字符串的解码](https://leetcode-cn.com/problems/decode-string/)\n\n\n### 思路\n\n用栈保存字符串，然后遇到中括号进行相应的处理\n\n### 代码\n\n\n```cpp\n\nstring decodeString(string s) {\n  stack<char> str_stack, tmp_stack;\n  for(int i=0;s[i];i++){\n    if(s[i]!=']') str_stack.push(s[i]);\n    else {\n      while(str_stack.top()!='['){\n        tmp_stack.push(str_stack.top());\n        str_stack.pop();\n      }\n      str_stack.pop();\n      string tmp_str=\"\";\n      while(!tmp_stack.empty()){\n        tmp_str+=tmp_stack.top();\n        tmp_stack.pop();\n      }\n      string single_str=\"\";\n      short times=str_stack.top()-'0';\n      str_stack.pop();\n      string final_str=\"\";\n      for(int j=0;j<times;j++){\n        final_str+=tmp_str;\n      }\n      for(int j=0;j<final_str.length();j++){\n        str_stack.push(final_str[j]);\n      }\n    }\n  }\n  string ret=\"\",ret_reverse=\"\";\n  while(!str_stack.empty()){\n    ret+=str_stack.top();\n    str_stack.pop();\n  }\n  for(int i=ret.length()-1;i>=0;i--){\n    ret_reverse+=ret[i];\n  }\n  return ret_reverse;\n}\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N2)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088699390","body":"### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n\n### 思路\n\n在push操作的时候处理一下，再使用一个临时栈，把栈中的内容反过来，这样永远保证栈是队列的反向，这样执行pop和peek都可以直接调用栈的pop和top。\n\n### 代码\n\n\n```cpp\n\n\nclass MyQueue {\nstack<int> my_queue;\npublic:\n    MyQueue() {\n      \n    }\n    \n    void push(int x) {\n      if(my_queue.empty()) my_queue.push(x);\n      else {\n        stack<int> tmp_queue;\n        while(!my_queue.empty()){\n          tmp_queue.push(my_queue.top());\n          my_queue.pop();\n        }\n        my_queue.push(x);\n        while(!tmp_queue.empty()){\n          my_queue.push(tmp_queue.top());\n          tmp_queue.pop();\n        }\n      }\n    }\n    \n    int pop() {\n      int ret=my_queue.top();\n      my_queue.pop();\n      return ret;\n    }\n    \n    int peek() {\n      return my_queue.top();\n    }\n    \n    bool empty() {\n      return my_queue.empty();\n    }\n};\n\n\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james20141606":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086761350","body":"# Day 3: 1381. Design a Stack With Increment Operation (stack)\n\n- Problem Link\n  - [1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n- Ideas\n  -  We could either use vanilla way to implement, or use an array to store the information. Use an additional array to record the increment value. inc[i] means for all elements stack[0] ~ stack[i], we should plus inc[i] when popped from the stack. Then inc[i-1]+=inc[i], so that we can accumulate the increment inc[i] for the bottom elements and the following pops.\n  \n- Complexity: hash table and bucket\n  - Time: O(1)\n  - Space: O(N)\n\n- Code\n\n```python\nclass CustomStack:\n    \n    def __init__(self, maxSize: int):\n        self.list = []\n        self.inc = [] #log inc value and add to the number when poping a number\n        self.maxsize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.maxsize:\n            self.list.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.inc: return -1\n        if len(self.inc) >1:\n            self.inc[-2] += self.inc[-1]\n        return self.list.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, len(self.inc)) -1] +=val\n```\n\n- other resources:\n    - ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087073148","body":"# Day 4: 394. Decode String (stack, dfs, bracket)\n\n- Problem Link\n  - [394. Decode String](https://leetcode.com/problems/decode-string/)\n  - Other useful links:\n\n- Ideas\n  -  ideas are from [official solution](https://leetcode-solution.cn/solutionDetail?type=3&id=4&max_id=2). We could use stack to store the information before the first ']'. When we meet the first ']' we will get the string before it, then get all the numbers before the string. \n  -  Note the += might cause error since it is reversed order. and not that `stack[-1] != '[':` is required to avoid [ in the string.\n\n- Complexity: \n  - Time: O(len(decoded_string))\n  - Space:  O(len(decoded_string))\n\n- Code\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c ==']':\n                string_to_repeat = ''\n                repeat_times = ''\n                while stack and stack[-1] != '[':\n                    string_to_repeat  =stack.pop() + string_to_repeat\n                stack.pop()  #pop out [\n                while stack and stack[-1].isnumeric():\n                    repeat_times  = stack.pop() + repeat_times\n                stack.append(string_to_repeat * int(repeat_times))\n            else:\n                stack.append(c)\n        return ''.join(stack)\n```\n\n- other resources:\n  - [official solution](https://leetcode-solution.cn/solutionDetail?type=3&id=4&max_id=2)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"floatingstarlight":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086764343","body":"class CustomStack {\n\n    private final int maxSize;\n    private final int[] stack;\n    private final int[] inc;\n    private int top = -1;\n    private final int bottom = 0;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new int[maxSize];\n        inc = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top == maxSize - 1) {\n            return;\n        }\n        stack[++top] = x;\n    }\n\n    public int pop() {\n        if (top < bottom) {\n            return -1;\n        }\n        int res = stack[top] + inc[top];\n        if (top > bottom) {\n            inc[top - 1] += inc[top];\n        }\n        inc[top] = 0;\n        top--;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int i = Math.min(k - 1, top);\n        if (i >= bottom) {\n            inc[i] += val;\n        }\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086775193","body":"### 代码\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.stack = []\n        self.cnt = 0\n        self.size = maxSize\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if self.cnt < self.size:\n            self.stack.append(x)\n            self.cnt += 1\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.cnt != 0:\n            self.cnt -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(k, self.cnt)):\n            self.stack[i] += val\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"currybeefer":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086781771","body":"题目：【Day 3】1381. 设计一个支持增量操作的栈\r\n思路： 利用数组和一个指向数组顶部的指针就可以完成。但是注意边界条件的细节问题。\r\n我这里定义的cur指针指向的是下一个需要入栈的值应该存在的位置，所以初始值为0\r\n代码：\r\n```\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) \r\n    {\r\n        max=maxSize;\r\n        arr=new int[maxSize];\r\n        cur=0;\r\n    }\r\n    \r\n    void push(int x) \r\n    {\r\n        if(cur>=max) return;\r\n        arr[cur]=x;\r\n        cur++;\r\n    }\r\n    \r\n    int pop() \r\n    {\r\n        if(cur==0) return -1;\r\n        cur--;\r\n        return arr[cur];\r\n    }\r\n    \r\n    void increment(int k, int val) \r\n    {\r\n        int count=0;\r\n        if(cur<=k-1)\r\n            count=cur;\r\n        else\r\n            count=k;\r\n        \r\n        for(int i=0;i<count;i++)\r\n            arr[i]+=val;\r\n    }\r\npublic:\r\n    int* arr;\r\n    int cur;\r\n    int max;\r\n};\r\n```\r\n\r\n复杂度：\r\n时间复杂度：O(N) 主要是在 increment()中用了一次循环\r\n空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087057406","body":"思路：使用dfs递归，将字符串分解成字母序列+数字*[字母序列]的形式进行递归求解。括弧里边的表达式都需要放入递归里\r\n代码参考了一位老哥的结构\r\n代码：\r\n`string decodeString(string s) \r\n    {\r\n        int index=0;\r\n        return dfs(s, index);\r\n    }\r\n\r\n    string dfs(string& s, int& index)\r\n    {\r\n        string res;\r\n        while (index < s.size() && s[index] != ']')\r\n        {\r\n            if (s[index] >= 'a' && s[index] <= 'z' || s[index] >= 'A' && s[index] <= 'Z')\r\n            {\r\n                res += s[index];\r\n                index++;\r\n            }\r\n            else if (isdigit(s[index]))\r\n            {\r\n                int k = index;\r\n                while (isdigit(s[k]))\r\n                    k++;\r\n                int num = stoi(s.substr(index, k - index));//stoi string转换成int类型\r\n                index = k + 1;//去掉左括号\r\n                string val = dfs(s, index);//进一步递归，确认括号里的字符串\r\n                index++;\r\n                while (num > 0)\r\n                {\r\n                    res += val;\r\n                    num--;\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }   `\r\n复杂度：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088092050","body":"思路：这题的思路就是用两个栈模拟就好啦\r\n代码：\r\n` stack<int> stk1;\r\n    stack<int> stk2;\r\n    MyQueue() \r\n    {\r\n        \r\n    }\r\n    \r\n    void push(int x) \r\n    {\r\n        stk1.push(x);\r\n    }\r\n    \r\n    int pop() \r\n    {\r\n        int res;\r\n        while(!stk1.empty())\r\n        {\r\n            int x = stk1.top();\r\n            stk1.pop();\r\n            stk2.push(x);\r\n        }\r\n        res=stk2.top();\r\n        stk2.pop();\r\n        while(!stk2.empty())\r\n        {\r\n            int x = stk2.top();\r\n            stk2.pop();\r\n            stk1.push(x);\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    int peek() \r\n    {\r\n        int res;\r\n        while(!stk1.empty())\r\n        {\r\n            int x = stk1.top();\r\n            stk1.pop();\r\n            stk2.push(x);\r\n        }\r\n        res=stk2.top();\r\n        while(!stk2.empty())\r\n        {\r\n            int x = stk2.top();\r\n            stk2.pop();\r\n            stk1.push(x);\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    bool empty() \r\n    {\r\n        return stk1.empty();\r\n    }`\r\n复杂度：\r\npeek()和pop()的时间复杂度是O(n)，其他都是O(1)\r\n空间复杂度为O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oldfashioneddog":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086831280","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087248552","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        res=\"\"\n        multi=0\n        for c in s:\n            if c=='[':\n                stack.append([multi,res])\n                res,multi=\"\",0\n            elif c==']':\n                cur_multi,last_res=stack.pop()\n                res=last_res+res*cur_multi\n            elif '0'<= c <='9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088636936","body":"class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        # for i in range(0,n):\n        #     nums1[m+i]=nums2[i]#nums1[m:]=nums2\n        # nums1.sort()\n        # return nums1\n        k = m + n - 1  # 目标数组总长度\n        while m > 0 and n > 0:  # 只要两个数组任意一个遍历完\n            if nums1[m - 1] > nums2[n - 1]:  # 一数组最后一个比二最后一个大\n                nums1[k] = nums1[m - 1]  # 将一数组最后一个移到目标数组最后一个\n                m -= 1  # 一数组的指针左移\n            else:\n                nums1[k] = nums2[n - 1]  # 将二数组最后一个移到目标数组最后一个\n                n -= 1  # 将二数组的指针左移\n            k -= 1  # 目标数组指针左移\n        nums1[:n] = nums2[:n]  # 如果第二个数组未遍历完，说明一数组已排序好，将二数组剪切过来","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingchen77":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086877050","body":"#### 思路\n用两个数组模拟栈，一个存放每次push的数字，另外一个存放increment的内容，注意要更新increment出栈后的内容\n\n#### 代码\n```python\n    def __init__(self, maxSize: int):\n        self.st = []\n        self.incremental = []\n        self.cur = 0\n        self.size = maxSize\n    def push(self, x: int) -> None:\n        if self.cur < self.size:\n            self.st.append(x)\n            self.cur += 1\n            self.incremental.append(0)\n    def pop(self) -> int:\n        if self.cur == 0:\n            return -1\n        if self.cur >= 2:\n            self.incremental[-2] += self.incremental[-1]\n        self.cur -= 1\n        return self.st.pop() + self.incremental.pop()\n    def increment(self, k: int, val: int) -> None:\n        if self.cur > 0:\n            self.incremental[min(self.cur, k) - 1] += val\n```\n#### 空间复杂度\n时间 O(1) \\\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087081672","body":"#### 思路\n使用栈，通过对 “]” 的判断，进行出栈操作\n#### 代码\n```python\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == \"]\":\n                repeatStr = \"\"\n                repeatCount = \"\"\n                while stack and stack[-1] != \"[\":\n                    repeatStr = stack.pop() + repeatStr\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```\n#### 复杂度\n时间 O(n) \\\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088566405","body":"#### 思路\n通过两个栈颠倒数据\n#### 代码\n```python\n    def __init__(self):\n        self.stack = []\n        self.help_stack = []\n    def push(self, x: int) -> None:\n        while self.stack:\n            self.help_stack.append(self.stack.pop())\n        self.help_stack.append(x)\n        while self.help_stack:\n            self.stack.append(self.help_stack.pop())\n    def pop(self) -> int:\n        return self.stack.pop()\n    def peek(self) -> int:\n        return self.stack[-1]\n    def empty(self) -> bool:\n        if not self.stack:\n            return True\n        else:\n            return False \n```\n#### 复杂度\n时间 O(n) \\\n空间 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eggeggliu":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086884935","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.size = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.size) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length != 0) {\n        let tmp = this.stack.pop();\n        return tmp;\n    } else {\n        return -1;\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < this.stack.length && i < k; ++i) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087517926","body":"## 思路\n栈。除了']'一律入栈，遇']'开始出栈处理\n## 代码\n```js\nvar decodeString = function(s) {\n    let stack = [];\n    for (let char of s) {\n        if (char != ']') {\n            stack.push(char);\n        } else {\n            let repeatStr = stack.pop();\n            let tmpC = stack.pop();\n            while (tmpC != '[') {\n               repeatStr = tmpC + repeatStr;\n               tmpC = stack.pop();\n            }\n            let repeatTime = \"\";\n            while (stack.length && !isNaN(stack.slice(-1))) {\n                repeatTime = stack.pop() + repeatTime;\n            }\n            stack.push(repeatStr.repeat(+repeatTime));\n        }\n    }\n    return stack.join(\"\");\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088640899","body":"```js\n// 直接模拟\nvar MyQueue = function() {\n    this.stack = [];\n    this.helperStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    while (this.stack.length) {\n        this.helperStack.push(this.stack.pop());\n    }\n    let ret = this.helperStack.pop();\n    while (this.helperStack.length) {\n        this.stack.push(this.helperStack.pop());\n    }\n    return ret;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    while (this.stack.length) {\n        this.helperStack.push(this.stack.pop());\n    }\n    let ret = this.helperStack.slice(-1);\n    while (this.helperStack.length) {\n        this.stack.push(this.helperStack.pop());\n    }\n    return ret;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stack.length;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okbug":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086967880","body":"代码：\nJavaScript\n\n```js\nvar decodeString = function(s){\n    const stack = [];\n\n    for (let char of s) {\n        if (char !== ']') {\n            stack.push(char);\n            continue;\n        }\n\n        let cur = stack.pop();\n        let str = '';\n        while (cur !== '[') {\n            str = cur + str;\n            cur = stack.pop();\n        }\n\n        // now get the number here\n        cur = stack.pop();\n        let num = '';\n        // be careful here, how we count the number\n        while (cur >= '0' && cur <= '9') {\n            num = cur + num;\n            cur = stack.pop();\n        }\n        stack.push(cur);\n        stack.push(str.repeat(num));\n    }\n    return stack.join('');\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"geek-lx":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087052946","body":"思路：\n\n该题难点是括号嵌套括号，如：2[2[a]c]，应该输出aacaac，因为需要**从内向外**打开，所以可以使用stack FILO解题\n\n\n\n算法流程：见代码，已经很清晰了\n\n代码：\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c #当c为字母时，res尾后添加c\n        return res\n```\n\n复杂度：\n\nTime：O（n）\n\nSpace：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088185063","body":"思路：\n\nUse two stacks\n\n代码：\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.help_stack = []\n\n    def push(self, x: int) -> None:\n            while self.stack:\n                self.help_stack.append(self.stack.pop())\n            self.help_stack.append(x)\n            while self.help_stack:\n                self.stack.append(self.help_stack.pop())\n\n    def pop(self) -> int:\n        return self.stack.pop()\n\n    def peek(self) -> int:\n        return self.stack[-1]\n\n    def empty(self) -> bool:\n        return not bool(self.stack)\n\n```\n\n复杂度：\n\nTime complixiety:\npush - O(n)\npop - O(1)\npeek - O(1)\nempty - O(1)\nSpace complixiety:\npush - O(n)\npop - O(1)\npeek - O(1)\nempty - O(1)\n\n疑问：\n\n[->int 在Python函数定义中是什么意思？](https://stackoverflow.com/questions/14379753/what-does-mean-in-python-function-definitions)\n\n只是告诉 返回一个整数（但它不会强制函数返回整数）。它被称为*返回批注*\n\n来自 <https://stackoverflow.com/questions/14379753/what-does-mean-in-python-function-definitions> \n\n \n\n 峰顶的索引是-1，那栈的索引是怎样的呢？\n\n  def peek(self) -> int:\n\n​    return self.stack[-1]\n\n//我认为首先看stack是怎样实现的？\n\nList可以实现stack，dict更适合链表\n\n但是list可没有-1的索引？\n\n5.1.1. 將 List 作為 Stack（堆疊）使用\n\n来自 <https://docs.python.org/zh-tw/3/tutorial/datastructures.html#using-lists-as-stacks> ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087203278","body":"```go\r\nfunc decodeString(s string) (res string) {\r\n\tvar stack []string\r\n\tgetDigits := func(ptr *int) (ret string) {\r\n\t\tfor ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\r\n\t\t\tret += string(s[*ptr])\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\tgetStrings := func(strs []string) (ret string) {\r\n\t\tfor _, str := range strs {\r\n\t\t\tret += str\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\tptr := 0\r\n\tfor ptr < len(s) {\r\n\t\tchr := s[ptr]\r\n\t\tif chr >= '0' && chr <= '9' {\r\n\t\t\tdigits := getDigits(&ptr)\r\n\t\t\tstack = append(stack, digits)\r\n\t\t} else if chr >= 'a' && chr <= 'z' || chr == '[' {\r\n\t\t\tstack = append(stack, string(chr))\r\n\t\t\tptr++\r\n\t\t} else {\r\n\t\t\tptr++\r\n\t\t\tvar sub []string\r\n\t\t\tfor stack[len(stack)-1] != \"[\" {\r\n\t\t\t\tsub = append(sub, stack[len(stack)-1])\r\n\t\t\t\tstack = stack[:len(stack)-1]\r\n\t\t\t}\r\n\t\t\tn := len(sub)\r\n\t\t\tfor i := 0; i < n/2; i++ {\r\n\t\t\t\tsub[i], sub[n-i-1] = sub[n-i-1], sub[i]\r\n\t\t\t}\r\n\t\t\tstack = stack[:len(stack)-1]\r\n\t\t\trepTimes, _ := strconv.Atoi(stack[len(stack)-1])\r\n\t\t\tstack = stack[:len(stack)-1]\r\n\t\t\tst := strings.Repeat(getStrings(sub), repTimes)\r\n\t\t\tstack =append(stack, st)\r\n\t\t}\r\n\t}\r\n\tres = getStrings(stack)\r\n\treturn\r\n}\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maybetoffee":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087276903","body":"思路：需要从里到外获得substring和substring对应的次数，符合栈先进后出的特点。为什么需要讲左括号也推进去？因为我们压栈遇到右括号的时候就说明一个substring已经结束，可以弹出了，什么时候结束弹出？就是遇到左括号的时候。弹完substring之后，在弹出一次栈顶，就是将左括号弹出，然后如果当前栈顶是数字，那就是substring对应的次数。\npublic String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c != ']'){\n                stack.push(c);\n            }else{\n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek()!='['){\n                    sb.insert(0,stack.pop());\n                }\n                String sub = sb.toString();//one of the subStr need to be multiplied\n                stack.pop();//should be a [\n                sb = new StringBuilder();//clean current sb\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    sb.insert(0, stack.pop());\n                }    \n                int count = Integer.parseInt(sb.toString());\n                while(count != 0){\n                    for(char elem: sub.toCharArray()){\n                        stack.push(elem);\n                    }\n                    count--;\n                }\n            }\n        }\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty()){\n            res.insert(0, stack.pop());\n        }\n        return res.toString();\n    }\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087917880","body":"class MyStack {\n    private Queue<Integer> q;\n    private int top_elem;\n\n    public MyStack() {\n        q = new LinkedList<>();\n        top_elem = 0; \n    }\n    \n    public void push(int x) {\n        q.offer(x);\n        top_elem = x;\n    }\n    \n    public int pop() {\n        int size = q.size();\n        while(size > 2){\n            q.offer(q.poll());\n            size--;\n        }\n        top_elem = q.peek();\n        q.offer(q.poll());\n        return q.poll();\n    }\n    \n    public int top() {\n        return top_elem;\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088086201","body":"用两个stack\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack.pop()\r\n        else:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n            if self.outStack:\r\n                return self.outStack.pop()\r\n            else:\r\n                return -1\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack[-1]\r\n        else:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n            if self.outStack:\r\n                return self.outStack[-1]\r\n            else:\r\n                return -1\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.inStack and not self.outStack\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\nTime: O(1)\r\n\r\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fhuang5":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088158191","body":"(Java). Used helper function to avoid repeated code. O(1) amortized time and O(1) auxiliary space.\n```\nclass MyQueue {\n    \n    private Stack<Integer> pushStack = new Stack<Integer>();\n    private Stack<Integer> popStack = new Stack<Integer>();\n    \n    private void updatePopStack() {\n        if(popStack.isEmpty()) {\n            while(!pushStack.isEmpty()){\n                popStack.push(pushStack.pop());\n            }\n        }\n    }\n\n    public void push(int x) {\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        updatePopStack();\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        updatePopStack();\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return ( popStack.isEmpty() && pushStack.isEmpty() );\n        \n    }\n    \n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088190548","body":"```python\r\nclass MyQueue(object):\r\n\r\n    \"\"\"\r\n    Queue is fifo stack is lifo\r\n    \r\n    [1, 2, 3]\r\n    [3, 2, 1]\r\n    \r\n    [4] -> push\r\n    [3,2,1] -> peak and pop\r\n    if not queue:\r\n        push elem from first stack to sec\r\n    else:\r\n        pop or peek from the other    \r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        self.pushStack = []\r\n        self.popStack = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.pushStack.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.popStack:\r\n            return self.popStack.pop()\r\n        while self.pushStack:\r\n            self.popStack.append(self.pushStack.pop())\r\n        return self.popStack.pop()\r\n            \r\n            \r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        print(self.pushStack)\r\n        if self.popStack:\r\n            return self.popStack[-1]\r\n        while self.pushStack:\r\n            self.popStack.append(self.pushStack.pop())\r\n        print(self.popStack)\r\n        return self.popStack[-1]\r\n        \r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        return len(self.pushStack) == 0 and len(self.popStack) == 0\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanjyumoso":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088280937","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stackpush = []\n        self.stackpop = []\n        \n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stackpush.append(x)\n        \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        while not self.stackpop:\n            while self.stackpush:\n                self.stackpop.append(self.stackpush.pop())\n        return self.stackpop.pop()\n            \n        \n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        while self.stackpop:\n            self.stackpush.append(self.stackpop.pop())\n        return self.stackpush[0]\n    \n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not(bool(self.stackpop) or bool(self.stackpush))\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kbfx1234":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088371802","body":"```cpp\n// 4-5 cpp\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    stack<int> stIn;\n    stack<int> stOut;\n\n    MyQueue() {\n\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stIn.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if (stOut.empty()) {\n            while(!stIn.empty()) {\n                stOut.push(stIn.top());\n                stIn.pop();\n            }\n        }\n        int result = stOut.top();\n        stOut.pop();\n        return result;\n\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        int res = this->pop();\n        stOut.push(res);\n        return res;\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return stIn.empty() && stOut.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zuoduozhongguo":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088712753","body":"# 思路\r\n\r\n用列表来作为栈的存储空间，先入栈，后出栈入第二个栈，当需要输出时再从第二个栈输出，即可实现队列功能\r\n\r\n# 代码\r\n\r\n\r\n```Python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.a = []\r\n        self.b = []\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.b:\r\n            self.a.append(self.b.pop())\r\n        self.a.append(x)\r\n        while self.a:\r\n            self.b.append(self.a.pop())\r\n\r\n    def pop(self) -> int:\r\n        return self.b.pop()\r\n\r\n    def peek(self) -> int:\r\n        return self.b[-1] \r\n\r\n    def empty(self) -> bool:\r\n        return len(self.b) == 0\r\n```\r\n\r\n# 复杂度\r\n时间：O(1)，空间：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bey11-h":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088779331","body":"class MyQueue {\n    Stack<Integer> stack1 = new Stack<>();\n    Stack<Integer> stack2 = new Stack<>();\n    int front;\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        if (stack1.isEmpty()) {\n            front = x;\n        }\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        stack2.push(x);\n        while(!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n    }\n    \n    public int pop() {\n        int top = stack1.pop();\n        if (!stack1.isEmpty()){\n            front = stack1.peek();\n        }\n        return top;\n    }\n    \n    public int peek() {\n        return front;\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aibotao":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088859289","body":"class MyQueue {\n    Deque<Integer> stackIn;\n    Deque<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new ArrayDeque<>();\n        stackOut = new ArrayDeque<>();\n    }\n\n    //push时检查out栈里是否为空，否则倒到in栈里再进行push\n    public void push(int x) {\n        while(stackOut.size()>=1){\n            stackIn.addFirst(stackOut.removeFirst());\n        }\n        stackIn.addFirst(x);\n    }\n    \n    //pop同理\n    public int pop() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.removeFirst();\n        return res;\n    }\n    \n    public int peek() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.getFirst();\n        return res;\n    }\n    \n    public boolean empty() {\n        return stackIn.size()==0 && stackOut.size()==0;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dqhe":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088948032","body":"# 思路\n将第一个栈的数字倒入第二个栈\n\n# 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack_push=[]\n        self.stack_pop=[]\n\n    def push(self, x: int) -> None:\n        self.stack_push.append(x)\n\n    def pop(self) -> int:\n        while self.stack_push:\n            self.stack_pop.append(self.stack_push.pop())\n        return self.stack_pop.pop()\n\n    def peek(self) -> int:\n        while self.stack_push:\n            self.stack_pop.append(self.stack_push.pop())\n        return self.stack_pop[-1]\n\n    def empty(self) -> bool:\n        while self.stack_push:\n            self.stack_pop.append(self.stack_push.pop())\n        return not bool(self.stack_pop)\n```\n# 复杂度分析\n\n时间复杂度O(N)\n空间复杂度O(N)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}