{"965682575":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916838838","body":"#### 思路\r\n\r\n​\t从数组的最后一位及k的个位开始计算，carry变量表示进位，将每次计算的sum值放入新的数组中，最后将数组倒置。\r\n\r\n​\t**注意**：两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在数组中\r\n\r\n#### 代码\r\n\r\n``` c++\r\npublic:\r\n\r\n vector<int> addToArrayForm(vector<int>& A, int K) {\r\n\r\n\tvector<int> res;\r\n\tint i = A.size() - 1;\r\n\tint carry = 0;\r\n\tint sum = 0;\r\n\t\r\n\twhile (i > -1 || K != 0) {\r\n        int x = i > -1 ? A[i] : 0;\r\n        int y = K != 0 ? (K % 10) : 0;\r\n        sum = x + y + carry;\r\n\r\n        carry = sum / 10;\r\n        sum %= 10;\r\n        i--;\r\n        K /= 10;\r\n        res.push_back(sum);\r\n    }\r\n\r\n\tif (carry) {\r\n\t\tres.push_back(carry);\r\n\t}\r\n\r\n\treverse(res.begin(), res.end());\r\n\treturn res;\r\n  }\r\n\r\n};\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：O(max(N, log k))\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruohai0925":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916226878","body":"## 思路\r\n\r\n从个位开始加，用carry表示进位\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n# from typing import List\r\nfrom collections import deque\r\nclass Solution:\r\n    def addToArrayForm(self, A, K):\r\n        if K == 0:\r\n            return A\r\n\r\n        i = len(A) - 1\r\n        carry = 0\r\n\r\n        # d = []\r\n        d = deque()\r\n\r\n        while i >= 0 and K > 0:\r\n            temp = A[i] + carry + K % 10\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            K = K // 10\r\n            i -= 1\r\n\r\n        while i < 0 and K > 0:\r\n            temp = K % 10 + carry\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            K = K // 10\r\n\r\n        while i >= 0:\r\n            temp = A[i] + carry\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            i -= 1\r\n\r\n        if carry > 0:\r\n            #d.insert(0, carry)\r\n            d.appendleft(carry)\r\n\r\n        #return d\r\n        return list(d)\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ImSingee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916251691","body":"```rust\r\nimpl Solution {\r\n    pub fn add_to_array_form(num: Vec<i32>, mut k: i32) -> Vec<i32> {\r\n        let mut result = Vec::new();\r\n        for i in (0..num.len()).rev() {\r\n            result.push({\r\n                let result = num[i] + k;\r\n                let x = result % 10;\r\n                k = result / 10;\r\n                x\r\n            })\r\n        }\r\n\r\n        while k > 0 {\r\n            result.push({\r\n                let x = k % 10;\r\n                k = k / 10;\r\n                x\r\n            })\r\n        }\r\n\r\n        result.reverse();\r\n        result\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度 O(len(num)) [logk约等于1 忽略] \r\n额外空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilyzhaoyilu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916253690","body":"### 思路\r\n按照官方题解\r\n\r\n### CPP代码\r\n```Cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int n = num.size();\r\n        for(int i = n - 1; i >= 0; --i){\r\n            int curSum = num[i] + k % 10;\r\n            k /= 10;\r\n            if(curSum >= 10){\r\n                k++;\r\n                curSum -=10;\r\n            }\r\n            res.push_back(curSum);\r\n        }\r\n        while(k > 0){\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n + logk + resLength)，其中 n 为数组的长度；resLength是res这个vector的长度，来自于reverse的时间消耗\r\n- 空间复杂度：O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Dana-Dai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916255452","body":"## 思路\n直接对数组操作，但要注意进位，尤其是K > A的情况，要在数组开头插入以进位\n\n## 语言\ncpp\n\n## 代码\n···\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        //把K直接加到数组num上\n        int len = num.size() - 1;\n        while (k > 0) {\n            num[len] += k;\n            k = num[len] / 10;\n            num[len] %= 10;\n            len --;\n\n            if (len < 0 && k > 0) {\n                num.insert(num.begin(), 0);\n                len = 0;\n            }\n        }\n        return num;\n    }\n};\n```\n## 复杂度分析\n时间复杂度：$O（N）$即需要遍历一遍数组，故为N\n空间复杂度：$O（1）$不需要额外开辟空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"last-Battle":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916257585","body":"## 思路\n\n## 关键点\n\n-  从个位开始往前面推算，每计算一位就放入vector结果中，并通过carry维护进位，最后再反转\n- 注意数组下标和k的位数要保证有效，防止越界\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int carry = 0, len = num.size() - 1;\n        int tmparr = 0, tmpk = 0, sum = 0;\n        int i = len;\n        while (i >= 0 || k != 0) {\n            tmparr = 0;\n            tmpk = 0;\n            if (k != 0) {\n                tmpk = k % 10;\n                k /= 10;\n            }\n            if (i >= 0) {\n                tmparr = num[i];\n                --i;\n            }\n\n            sum = tmparr + tmpk + carry;\n            carry = sum / 10;\n            res.emplace_back(sum % 10);    \n        }\n        \n        if (carry) {\n            res.emplace_back(carry);\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mm12344":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916262628","body":"## 思路\r\n简单数值解法\r\n## 代码\r\n\r\n```py3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        x = 0\r\n        ans=[]\r\n        if len(num)==1 and num[0]==0 and k==0: return[0]\r\n        for i in num:\r\n            x = x*10 + i\r\n        x = x + k\r\n        while x!=0:\r\n            ans.append(x%10)\r\n            x=x//10\r\n        return ans[::-1]\r\n```\r\n\r\n## 复杂度\r\n时间：O(2n)\r\n空间：O(ans)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzehan123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916267006","body":"\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> ans = new LinkedList<>();\n        int temp=0;\n        for (int i = num.length-1; i >=0 ; i--) {\n            temp = k%10;\n            k/=10;\n            if (temp+num[i]>=10){\n                k++;\n                ans.addFirst((temp+num[i])%10);\n            }else {\n                ans.addFirst(temp+num[i]);\n            }\n            if (i==0){\n                while (k>0){\n                    temp = k%10;\n                    k/=10;\n                    ans.addFirst(temp);\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(max(n,logk))$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erik7777777":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916274001","body":"## 思路 \n从低位往高位顺着加\n### 代码 ： java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int cur = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry;\n            k = k > 0 ? k / 10 : 0;\n            i = i >= 0 ? i - 1 : -1;\n            carry = cur / 10;\n            cur = cur % 10;\n            res.add(cur);\n        }\n        if (carry == 1) res.add(carry);\n        Collections.reverse(res);\n        return res;\n    }\n```\n\n### 复杂度分析\n - 时间复杂度：O(n)，其中 n 为数组的长度\n - 空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yachtcoder":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916275711","body":"\n从低到高递归处理每一位以及前面的进位\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num = num[::-1]\n        k = [int(x) for x in str(k)][::-1]\n        ret = []\n        def add1(l1, l2, carry, idx):\n            nonlocal ret\n            if carry == 0 and idx >= len(l1) and idx >= len(l2): return\n            n1 = 0 if idx >= len(l1) else l1[idx]\n            n2 = 0 if idx >= len(l2) else l2[idx]\n            ret.append((n1+n2+carry) % 10)\n            carry = (n1+n2+carry)//10\n            add1(l1, l2, carry, idx+1)\n        add1(num, k, 0, 0)\n        return ret[::-1]\n```\nTime: O(n)\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chang-you":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916277083","body":"## 代码\r\nJava:\r\n\r\n```java\r\n// Space = O(n) / O(1) 数组/k长度\r\n// Time = O(Math.max(n, log(k)) / O(1): num或k长度中较大的\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //用LinkedList不断从头将位数和加入index 0\r\n        List<Integer> res = new LinkedList<>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            //从末尾往前扫，加和取余的值\r\n            res.add(0, (num[i] + k) % 10);\r\n            //更新k存进位carry\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        \r\n        // post-possing: 处理k位数大于num的情况剩下的部分\r\n        // Time = O(log(k))\r\n        while (k > 0) {\r\n            res.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n##  复杂度分析\r\nSpace = O(n) / O(1) ：数组/k长度\r\n\r\nTime = O(Math.max(n, log(k)) / O(1): num或k长度中较大的","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mmboxmm":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916278377","body":"## 思路\nAddition from right to left\n\n## 代码\n\n```Kotlin\nfun addToArrayForm(num: IntArray, k: Int): List<Int> {\n  val res = mutableListOf<Int>()\n  var carry = 0\n  var index = num.size - 1\n  var tmp = k\n\n  while (index >= 0 || tmp > 0 || carry > 0) {\n    var sum = carry\n    if (index >= 0) sum += num[index--]\n    if (tmp > 0) sum += tmp % 10\n\n    res.add(sum % 10)\n\n    carry = sum / 10\n    tmp /= 10\n  }\n  return res.reversed()\n}\n```\n\n## 复杂度分析\n- Time：O(len(num))\n- Space：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangwiitao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916281347","body":"#### JS\n\n```js\nvar addToArrayForm = function (num, k) {\n    const ret = [];\n    let i = num.length - 1, carry = 0;\n    while (i >= 0 || k != 0) {\n        let x = i >= 0 ? num[i] : 0;\n        let y = k !== 0 ? k % 10 : 0;\n\n        const sum = x + y + carry;\n\n        ret.push(sum % 10);\n        carry = Math.floor(sum / 10);\n\n        i--;\n        k = Math.floor(k / 10);\n    }\n    if (carry) {\n        ret.push(carry);\n    }\n    return ret.reverse();\n};\n```\n#### 复杂度分析\n- 时间复杂度：O（n），再具体不会了\n- 空间复杂度：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916284826","body":"# LC989. Add to Array-Form of Integer\r\n## Main Idea\r\nFirst, it looks like we can convert the array `num` to integer and add it to `k`, but `num.length <= 1E+4` so this approach will cause integer overflow. So we will have to do the addition in array form.\r\n\r\nThen the idea is to simulate the entire process, add each digit of `num` and `k` with a `carry` bit. We will terminate the loop when we run out of digits for both `num` and `k` and `carry == 0`.\r\n\r\n## Code\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length, carry = 0, i = n - 1;\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        while (i >= 0 || k > 0 || carry > 0) {\r\n            int kDigit = k % 10;\r\n            k /= 10;\r\n            int sum = i >= 0 ? carry + kDigit + num[i] : carry + kDigit;\r\n            res.add(sum % 10);\r\n            carry = sum >= 10 ? 1 : 0;\r\n            --i;\r\n        }\r\n      \r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity Analysis\r\nTime: `O(max(N, log(K)))`\r\n* Given a number `K`, its length will be `log_{2}(K)`, the time complexity depends on the length of `N` and `K`, whichever is longer.\r\n* Notice we want to insert digits at the end of the array and then reverse it after we finish the addition. If we insert at the head of array, then it will take `O(n^2)` of time.\r\n\r\nSpace: `O(1)`, as we didn't use additional spaces except the return array.","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ai2095":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916293322","body":"## LC 989 Add to Array-Form of Integer\n\nhttps://leetcode.com/problems/add-to-array-form-of-integer/\n\n### Topics  \n\n- Array\n- Math\n\n### Similar Questions\n\nMedium\n- https://leetcode.com/problems/add-two-numbers/\n\nEasy\n- https://leetcode.com/problems/plus-one/\n- https://leetcode.com/problems/add-binary/\n- https://leetcode.com/problems/add-strings/\n\n\n### 思路 \nAdd the number K to the array from right to left.\n\n#### 代码 Python\n\n```Python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carrier = 0\n        num_len = len(num)\n        i = num_len -1\n        # Add all matching digit        \n        while i >= 0 and k > 0:\n            cur_k, k = k%10, k//10\n            t_carrier = (num[i] + cur_k + carrier) // 10\n            num[i] = (num[i] + cur_k + carrier) % 10\n            carrier = t_carrier\n            i -= 1\n        \n        # Check whether num or k is left\n        if i >= 0:\n            while i >= 0:\n                t_carrier = (num[i] + carrier) // 10\n                num[i] = (num[i] + carrier) % 10\n                carrier = t_carrier\n                if carrier == 0:\n                    break\n                i -= 1\n            \n        if k > 0:\n            while k > 0:\n                cur_k, k = k%10, k//10\n                t_carrier = (cur_k + carrier) // 10\n                num = [(cur_k + carrier) % 10] + num\n                carrier = t_carrier\n\n        # Deal with carrier\n        if carrier > 0:\n            return [carrier] + num\n        else:\n            return num\n            \n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(N) </br>\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanglr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916293869","body":"## 思路\r\n\r\n双指针 + 进位加法逻辑\r\n\r\n双指针, 让两个数的末位对齐, 两个指针 i, j均从各自字符串的末尾开始走。\r\n\r\n定义一个数组来存放结果, 一个int值carry来记录每位的进位值, 初始值设为0。\r\n算当前位置的数时, sum = a[i] + b[j] + carry, 每趟都要记得更新carry的值。\r\n\r\n循环结束时, 由于低位的数字字符先加到了结果字符串中, 最后还需要 reverse 一次, 让位置恢复正常。\r\n\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int k) {\r\n        if (k == 0) return A;\r\n        vector<int> res;\r\n        int n = A.size();\r\n        // 对位相加\r\n        int carry = 0;\r\n        int sum = 0;      \r\n        int i = n - 1; \r\n        while (k > 0 || i >= 0)\r\n        {\r\n            sum = carry + (k % 10);\r\n            if (i >= 0) // 保证访问A[i]前不越界\r\n                sum += A[i];\r\n\r\n            carry = (sum <= 9) ? 0 : 1;\r\n            res.push_back(sum % 10);            \r\n            k = k / 10;\r\n            \r\n            i--;\r\n        }\r\n        if (carry == 1) res.push_back(1);\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n\r\n代码已上传到: [leetcode-ac/91algo - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(max(n, k))，其中 n 为数组长度, k为数K的长度。\r\n- 空间复杂度：O(n), 主要是结果数组用的空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZiyangZ":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916314383","body":"- Talk about how to make an easy problem complicated:\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int size = Math.max(num.length, String.valueOf(k).length());\n        int dif = size - num.length; \n        int[] ans = new int[size];\n        int carry = 0;\n        for (int i = ans.length - 1; i >= 0; i--) {\n            int n = (i - dif) < 0 ? 0:num[i - dif];\n            int m = k % 10;\n            k = k / 10;\n            ans[i] = (n + m + carry) % 10;\n            carry = (n + m + carry) / 10;\n        }\n        \n        List<Integer> list = new ArrayList<>();\n        if (carry == 1) list.add(1);\n        for (int i: ans) list.add(i);\n        \n        return list;\n    }\n}\n```\n\n- So turns out all we need to do is adding digits from the last position and reverse the list.\n- Time and space O(max(n, m)) where n is the length of num and m is the number of digits in k.","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cicihou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916314749","body":"``` python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res = []\r\n        for i in num:\r\n            res.append(str(i))\r\n        res = str(int(''.join(res)) + k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n        \r\n```\r\n\r\n\r\ntime: O(n)\r\nspace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shixinlovey1314":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916315048","body":"# ***Title:989. Add to Array-Form of Integer***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/add-to-array-form-of-integer/)\n\n## ***Solution***\n1. Revert the array, so that we only need to manipulate the end of the array.\n2. Extract the lowest digit of K and add into the array ascendingly. \n3. After each addition, if the item at the given index excceds 10, then only keep the lowest digit part and add 1 to the next item in the array (Watch out the array boundary and expand the array by 1 if needed..\n4. After processed K, check if there still exist delta > 0, if so keep on repeating the process similar to step 2 until delta equals 0.\n5. Revert the array back.\n\n## ***Code***\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int index = 0;\n        int delta = 0;\n        \n        std::reverse(num.begin(), num.end());\n        \n        while (k > 0) {\n            delta += k % 10 + num[index];\n            k /= 10;\n            \n            num[index++] = delta % 10;\n            delta /= 10;\n            \n            if (index == num.size() && (k > 0 || delta > 0))\n                num.push_back(0);\n        }\n        \n        while (delta > 0) {\n            delta += num[index];\n            num[index++] = delta % 10;\n            delta /= 10;\n            \n            if (index == num.size() && (delta > 0))\n                num.push_back(0);\n        }\n            \n        std::reverse(num.begin(), num.end());\n        \n        return num;\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(max(N, M)), N is the size of the array, while M is the size of the virtual array form of K, which is logarithm of base 10 -> log10(K).\n\n### ***Space Complexity and Explaination***\nO(1) since we reuse the input array and didn't need any extra space","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916317988","body":"## 思路\r\n### 模版\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n### 代码\r\n- 语言： Python3\r\n\r\n```python\r\nfrom collections import deque\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) -1\r\n        res = []\r\n        carry = 0\r\n\r\n        while i >=0 or k != 0:\r\n            if i >= 0:\r\n                curr_num = num[i]\r\n            else:\r\n                curr_num = 0\r\n            if k != 0:\r\n                curr_k = k % 10 \r\n            else:\r\n                curr_k = 0\r\n\r\n            total = curr_num + curr_k + carry\r\n            curr_total = total % 10\r\n            carry = total // 10\r\n            res.append(curr_total)\r\n            i -= 1\r\n            k = k // 10\r\n\r\n        if carry != 0:\r\n            res.append(carry)\r\n\r\n        return res[::-1]\r\n```\r\n\r\n### 复杂度：\r\n- 时间复杂度：$O(n)$ 遍历\r\n- 空间复杂度：$O(n)$ 新创立了一个ans list","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luojiamun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916322388","body":"### 思路\n\nDeque, Array遍历；\n\n注意题目要求，1 <= A.length <= 10000，所以直接做加法是不可能的。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int pos = 0;\n        int carry = 0;\n        Deque<Integer> res = new LinkedList<>();\n        while(pos < num.length || k >= Math.pow(10, pos) || carry > 0){\n            int fromNum = pos < num.length?num[num.length - 1 - pos]:0;\n            int fromK = (k / (int)Math.pow(10, pos)) % 10;\n            int sum = fromNum + fromK + carry;\n            res.addFirst(sum % 10);\n            carry = sum > 9?1:0;\n            pos++;\n        }\n                \n        return new ArrayList<>(res);\n    }\n}\n```\n\n### 复杂度\n\nO(MAX(num.length, Integer.valueOf(k).toString.length()))\nO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yiwchen":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916330275","body":"思路：\nadd with carry\n\nPython:\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        n = len(num)\n        while(n > 0 or k > 0):\n            if n > 0:\n                k += num[n - 1]\n            k, r = divmod(k, 10)\n            res.append(r)\n            n -= 1\n        return res[::-1]\n```\nC++:\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        int sum;\n        for (int i = n - 1; i >=0; --i){\n            \n            /*Calculation of current digit*/\n            \n            sum = num[i] + k % 10;\n            k /= 10;\n            \n            /*Add the carry to k if there is any*/\n            \n            if (sum >= 10){\n                k++;\n                sum -= 10;\n            }\n            \n            /*Append the sum to the end*/\n            \n            res.push_back(sum);\n        }\n        \n        /* Append the rest of k to the end if k is bigger than n*/\n        \n        for (k = k; k > 0; k/= 10){\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n复杂度分析:\n\n时间复杂度：O(len(A) + len(str(k)) + len(res)) = O(max(len(A), len(str(k))))\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qixuan-code":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916334960","body":"[LC 989. Add to Array-Form of Integer](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n**思路**\n- 把num list转化成数字\n- 数字和k相加\n- 相加的和转化成list\n\n**python代码**\n```class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        true_number = 0\n        result = []\n        if k == 0 and len(num) == 1:\n            return num\n        for i in range(n):\n            true_number = true_number + num[i]*10**(n-i-1)\n\n        add_up = true_number + k\n        while add_up:\n            result.append(add_up%10)\n            add_up = add_up//10\n\n        return result[::-1]\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JiangyanLiNEU":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916335257","body":"### Two ideas hit me when I saw this problem.\n* convert array num to integer --> add k to the integer --> convert new integer to array --> return this array\n* Use k as carry on number, and keep adding it to the elements in num until k is 0. Note that, we might  need to insert elements into num array.\n\n### Here is my implement:\n* #### Convert idea ( Runtime = O( len(num) ), Space = O( len(num) ) )\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        # convert array num into string version\n        num_string = ''\n        for n in num:\n            num_string += str(n)\n\n        # add num and k, and convert it to string version\n        num_add_k_string = str(int(num_string) + k)\n\n        # convert result into array of int version\n        toReturn = [ int(i) for i in num_add_k_string ]\n        return toReturn\n```\n\n* #### carry k idea ( Runtime = O( len(num) ), Space = O(1) )\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        # add k into the last digit of num, and check if there should be a carryOn number\n        num[-1] += k\n        if num[-1] < 10:\n            return num\n        # if no carryOn number, then just return num, otherwise, we keep adding carry on into previous digit and update carryOn\n        carryOn = num[-1]//10\n        num[-1] = num[-1]%10\n        index = -2\n        while carryOn != 0:\n            # when there are enough digits for us to add\n            if index >= -len(num):\n                num[index] += carryOn\n            # we need to insert new digit at the beginning of the array\n            else:\n                num.insert(0, carryOn)\n            carryOn = num[index] // 10\n            num[index] %= 10\n            index -= 1\n        return num\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZT4188":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916338863","body":"思路：\n历遍数组\n\nPython:\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        K = list(map(int,str(K)))\n        \n        res = []\n        i,j = len(A)-1,len(K)-1\n        carry = 0\n\n        while i >= 0 and j >= 0:\n            res.append(A[i] + K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n            j -= 1\n        while i >= 0:\n            res.append(A[i] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n        while j >= 0:\n            res.append(K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            j -= 1\n\n        if carry:\n            res.append(1)\n\n        return res[::-1]\n\n时间复杂度：O(N+max(0,K−N) \n空间复杂度：O(1)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Jackielj":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916352332","body":"### LC 989. Add to Array-Form of Integer\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        int i = num.length - 1;\n        int carry = 0;\n        while (i >= 0 || k > 0 || carry > 0) {\n            int fromNum = i >= 0 ? num[i] : 0;\n            int fromK = k % 10;\n            int val = fromNum + fromK + carry;\n            list.add(0, val % 10);\n            carry = val > 9 ? 1 : 0;\n            k = k / 10;\n            i--;\n        }\n        return list;\n    }\n}\n\n```\n### 时空复杂度：\n时间：O(Math.max(len(num), len(k.toString()))\n\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Daniel-Zheng":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916354433","body":"### 思路\r\n从末位开始，向vector里添加各对应位置数字与进位之和。如原数组里各位置已加完，则需处理K中剩余数字与进位之和。\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int carry = 0;\r\n        vector<int> res;\r\n        for (int i = num.size() - 1; i >= 0; i--) {\r\n            res.push_back((carry + num[i] + k % 10) % 10);\r\n            carry = (carry + num[i] + k % 10) / 10;\r\n            k /= 10;\r\n        }\r\n        carry = carry + k;\r\n        while (carry) {\r\n            res.push_back(carry % 10);\r\n            carry /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N + logN + Max(0, K - N)^2)，N为数组A的长度，K为K的长度。 \r\n- 空间复杂度：O(Max(1, K - N))，N为数组A的长度，K为K的长度。 ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916360004","body":"# 思路\r\n从后往前加，直到没有为止\r\n\r\n# 代码(Python3)\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        add1 = 0\r\n        add2 = 0\r\n        stop1Flag = False\r\n        stop2Flag = False\r\n        \r\n        resultStack = []\r\n        \r\n        k_int = list(map(int,str(k)))\r\n        \r\n        index = -1\r\n        while(True):\r\n            try:\r\n                add1 = num[index]                \r\n            except:\r\n                stop1Flag = True\r\n                add1 = 0\r\n                \r\n            try:\r\n                add2 = k_int[index]\r\n            except:\r\n                stop2Flag = True\r\n                add2 = 0\r\n            \r\n            index -= 1\r\n            \r\n            if(stop1Flag and stop2Flag):\r\n                if carry != 0:\r\n                    resultStack.append(carry)\r\n                break\r\n            else:\r\n                resultStack.append((add1 + add2 + carry)%10)\r\n                carry = (add1 + add2 + carry)//10\r\n        return (list(resultStack[::-1])\r\n```\r\n# 复杂度分析\r\n时间复杂度：O(N + Max(0, K - N)^2)，N为数组A的长度，K为K的长度。\r\n空间复杂度：O(Max(1, K + N))，N为数组A的长度，K为K的长度。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RonghuanYou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916378066","body":"按照加法的运算顺序从后往前遍历，r是余数，也就是做完加法后的当前位的值\nk是除去最后一位的值\n结束循环，如果k>0，就要一直处理最后的carry，就是k%10放入output array\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sumArr = []\n        for i in range(len(num) - 1, -1, -1):\n            r = (num[i] + k) % 10\n            k = (num[i] + k) // 10\n            sumArr.append(r)\n            \n        while k > 0:\n            sumArr.append(k % 10)\n            k = k // 10\n        return sumArr[::-1]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pophy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916379125","body":"## Java代码\r\n\r\n```java\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Stack<Integer> stack = new Stack<>();\r\n        int borrow = 0;\r\n        int i = num.length - 1;\r\n\r\n        while (k != 0 || i >= 0 || borrow != 0) {\r\n            int currentNumber;\r\n           if (i >= 0 && k != 0) {\r\n                currentNumber = num[i] + k % 10;\r\n           } else if (i >=0) {\r\n               currentNumber = num[i];\r\n           } else {\r\n               currentNumber = k % 10;\r\n           }\r\n            stack.add((currentNumber + borrow) % 10);\r\n            borrow = (currentNumber + borrow) / 10;\r\n            k = k / 10;\r\n            i--;\r\n        }\r\n\r\n        while (!stack.isEmpty()) {\r\n            res.add(stack.pop());\r\n        }\r\n        return res;\r\n    } \r\n```\r\n\r\n## 时间复杂度\r\n\r\nO(n)\r\n\r\n## 空间复杂度\r\n\r\nO(n)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ninghuang456":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916390741","body":"JAVA code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int carry = 0;\r\n        int index = A.length - 1;\r\n        while(K > 0 || index >= 0){\r\n            int curK = K % 10;\r\n            int curA = index >= 0 ? A[index]: 0;\r\n            int curDigitSum = curK + curA + carry;\r\n            int toBeAdded = curDigitSum % 10;\r\n            carry = curDigitSum / 10;\r\n            index --;\r\n            K /= 10;\r\n            res.addFirst(toBeAdded);\r\n        }\r\n        if(carry != 0){\r\n            res.addFirst(1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\nTime: O(n);\r\nSpace: O(n);\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916408530","body":"Python 3 code:\r\n     \r\n    class Solution:\r\n         def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n              if num[0] == 0 and k == 0:\r\n                 return [0]\r\n              inputnum = 0\r\n              for number in num:\r\n                   inputnum = inputnum * 10 + number\r\n              summ = inputnum + k \r\n              res = []\r\n              while summ > 0:\r\n                      digit = summ % 10\r\n                      res.append(digit)\r\n                      summ = summ // 10\r\n              return res[::-1]\r\n\r\nTime Complexity: O(n) because we run through the given array one time\r\nSpace Complexit: O(n) because we created a new array res to record the sum","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qyw-wqy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916408891","body":"## 代码\nJava:\n```\n public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int i = num.length-1;\n        int carry = k;\n        while (i >= 0 || carry > 0) {\n            int n = i >= 0 ? num[i--] : 0;\n            carry += n;\n            list.add(carry % 10);\n            carry /= 10;\n        }\n        \n        Collections.reverse(list);\n        return list;\n    }\n```\nTime：O(n)     \nSpace：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skinnyh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916409263","body":"# Solution1\n\nUse while loop to add K to num digit by digit. Maintain the carry and end the loop when carry is 0 and all digits from K has been added. Note that inserting to the list head is not efficient.\n\n# Code\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry, idx = 0, len(num) - 1\n        while k > 0 or carry > 0:\n            digit = k % 10\n            k = k // 10\n            if idx < 0:\n                num.insert(0, 0)\n                i = 0\n            else:\n                i = idx\n            tmp = num[i] + digit + carry\n            num[i] = tmp % 10\n            carry = tmp // 10\n            idx -= 1\n        return num\n```\n\nTime complexity: O(N + max(0, K - N)^2), K is length of k and N is length of num\n\nSpace complexity: O(max(1, K - N))\n\n# Solution2\n\nCreate another result array and always append the digit sum to the result end to avoid insert to head. Reverse the result list before return. The while loop end condition will also need to check if it has traversed all the num list.\n\n# Code\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry, idx = 0, len(num) - 1\n        res = []\n        while idx >= 0 or k > 0 or carry > 0:\n            digit = k % 10\n            k = k // 10\n            n = num[idx] if idx >= 0 else 0\n            res.append((n + digit + carry) % 10)\n            carry = (n + digit + carry) // 10\n            idx -= 1\n        return reversed(res)\n```\n\nTime complexity: O(N)\n\nSpace complexity: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leo173701":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916409706","body":"很笨的办法， 请忽略  \n时间复杂度 o(n),\n空间复杂度o(n)\n\n  `def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        n = len(num)\n        temp = 0\n        for i in range(n):\n            temp +=num[i]* (10**(n-1-i))     \n        b = temp + k\n        res = []\n        while b>9:\n            d = b%10\n            b = b//10\n            res.append(d)\n        res.append(b)\n        res.reverse()        \n        return res`\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kidexp":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916420802","body":"## Thinking\nassume  num length is n, k has m digits\n\nTake [1,2,3]+999 as an example\n\nFirst convert [1,2,3] into 123 which takes O(m)\n\nThen add 123 with 999 = 1122, which takes O(1)\n\nFinally convert 1122 to [1,1,2,2] which is O(max(m,n)+1)  = O(max(m,n)\n\n\n## Code\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        m = 0\n        for digit in num:\n            m = m * 10 + digit\n        sum_ = m + k\n        result = []\n        while sum_:\n            result.append(sum_ % 10)\n            sum_ //= 10\n        return result[::-1] if result else [0]\n\n```\n\n## Complexity\nTime: O(n)+O(1)+O(max(m,n) = O(m+n)\n\nSpace Complexity: O(max(m,n))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falconruo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916424749","body":"**思路:**\r\n1. 数组num的第1个元素num[0]表示整数的最高位数字, 第n个元素num[n - 1]代表整数的个位数字\r\n2. 新的整数的每一位数字由三个部分决定：num[i], 整数k的当前位(k % 10), 进位(carry)->sum = val + k % 10 + carry\r\n\r\n**复杂度分析:**\r\n- 时间复杂度: O(max(N, lgk))，N为数组num的长度, k为给定整数k\r\n- 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size() - 1;\r\n        vector<int> res;\r\n        int carry = 0, val = 0, sum = 0;\r\n        while (n >= 0 || k != 0) {\r\n            val = (n >= 0) ? num[n] : 0;\r\n            sum = val + k % 10 + carry;\r\n            res.push_back(sum % 10);\r\n            carry = sum / 10;\r\n            k /= 10;\r\n            n--;\r\n        }\r\n\r\n        if (carry)\r\n            res.push_back(carry);\r\n        \r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"florenzliu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916425383","body":"**Explanation**\r\n\r\n- Convert k to its array-form. \r\n- Add the array-forms of num and k by digit from the end to the beginning and save it in the result array. \r\n- Reverse the array-form of the result. \r\n\r\nUse the quotient and remainder divided by 10: set the current position as the remainder and update the quotient for the next position.\r\n\r\n**Python**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        newK = []\r\n        for i in str(k):\r\n            newK.append(int(i))\r\n        \r\n        result = []\r\n        i, j = len(num)-1, len(newK)-1\r\n        quotient, remainder = 0, 0\r\n        while i >= 0 or j >= 0:\r\n            currI = num[i] if i >= 0 else 0\r\n            currJ = newK[j] if j >= 0 else 0\r\n            curr = currI + currJ + quotient\r\n            result.append(curr % 10)\r\n            quotient = curr // 10\r\n            i -= 1\r\n            j -= 1\r\n            \r\n        if quotient != 0:\r\n            result.append(quotient)\r\n        return result[::-1]\r\n```\r\n\r\n**Complexity**\r\n\r\n- Time Complexity: ```O(max(N, logk))``` where N is the length of the ```num``` array.\r\n- Space Complexity: ```O(max(N, logk))``` \r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916426832","body":"## Ripple Adder\r\nSimilar to the implementation of ripple adder, The adder will add numbers at the same position, output the sum of the current position, and pass the carry to the next bit.\r\n \r\n## Python\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], k: int) -> List[int]:\r\n        curSum = 0\r\n        carry = 0\r\n\r\n        # This can be achieved through continuing division, but I am lazy\r\n        if not A:\r\n            return [int(i) for i in str(k)]\r\n        elif not k:\r\n            return A\r\n\r\n        K = [int(i) for i in str(k)]\r\n        LA = len(A)-1\r\n        LK = len(K)-1\r\n\r\n        if LA <= LK:\r\n            target = K\r\n            idx = LK\r\n        else:\r\n            target = A\r\n            idx = LA\r\n        while LA >= 0 and LK >= 0:\r\n            curSum = A[LA] + K[LK] + carry\r\n            if curSum < 10:\r\n                target[idx] = curSum\r\n                carry = 0\r\n            else:\r\n                carry = curSum //10\r\n                target[idx] = curSum % 10\r\n            LA-=1\r\n            LK-=1\r\n            idx-=1\r\n        if LK != LA:\r\n            while idx >=0:\r\n                curSum = target[idx] + carry\r\n                if curSum < 10:\r\n                    target[idx] = curSum\r\n                    carry = 0\r\n                else:\r\n                    carry = curSum // 10\r\n                    target[idx] = curSum%10\r\n                idx-=1\r\n        if carry > 0:\r\n            target[0:0] = [carry]\r\n        return target\r\n```\r\n\r\nTime Complexity: O(max(K,A))\r\nSpace Complexity: O(max(K,A))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZhuMengCheng":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916429301","body":"思路:\r\n从末尾相加后截取末尾存储进位,, 测试用例: [2,1,5]  806  \r\n 比如806和5相加等于811 ,保存末尾1,\r\n继续相加为81+1=82. 保存2 类推,\r\n 8会和下一个2相加为10,  \r\n整个数组的值变成[10,2,1] 截取10的情况,可能计算次数超过数组长度.需要添加额外条件判断计算次数\r\n`/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let res = []\r\n    // k>0 如果遇到合为10需要多一次计算 ,查询条件不能限制为只有num数组的长度\r\n    for(let i = num.length-1 ;i>=0 || k > 0;--i){\r\n        // 大于0的位数直接相加后取余数进位\r\n        if(i >= 0){\r\n            k += num[i]\r\n        }\r\n        res.push(k % 10)\r\n        // 计算是否有等于10 或者大于0的情况,在执行下次进位\r\n        k  =   (k - k  % 10) / 10\r\n    }\r\n    return res.reverse()\r\n}`\r\n\r\n时间复杂度：O(max(n,log k))\r\n空间复杂度:  O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lllouiselao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916434574","body":"[989. Add to Array-Form of Integer](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n#### 想法：最brutal way： traverse list->str->int->list \n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        str_turple = ''\n        for i in num:\n            str_turple += str(i)\n\n        str_int = int(str_turple) + k\n        int_str = str(str_int)\n\n        output = []\n        for n in int_str:\n            output.append(int(n))\n        return output\n```\n#### complexcity O(n^2) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen445":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916452724","body":"### 思路: \n\nFirst, we should convert k to list and iterate from back of the list. If the sum of two digits at the same position plus carry is greater than 10, then we set the carry to 1. The modulo of the sum is the result at that position. \n\n### 代码：\n```\n  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        k=[int(x) for x in str(k)]\n        i=len(num)-1\n        j=len(k)-1\n        carry=0\n        result=deque([])\n        while i>=0 or j>=0:\n            a=num[i] if i >=0 else 0 \n            b=k[j] if j>=0 else 0\n            s=a+b+carry\n            carry=s//10\n            result.appendleft(s%10)\n            i-=1\n            j-=1\n        if carry != 0:\n            result.appendleft(carry)\n        return result\n```\n**复杂度分析**\n\nTime Complexity: O(n) n is the largest length of two numbers\n\nSpace Complexity: O(n) \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JachinM":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916481597","body":"## Java\n#### 解题思路\n+ 整型数组开始与k相应的位上的数字相加（从个位开始，整型数组的个位是num[num.length-1]），并将每位上相加的结果添加到一个整型的Array数组中。\n+ 这里需要注意如果相对应位置上的数相加大于10时，我们应该有进位操作，即 让k+1，number-10（ps：这里的number代表整型数组与k的相应位置上的数相加后得到的结果）\n+ 最后如果k>0,这说明最高位上有进位，最后得到的数组少最高位，我们应该再把k的每个位置的数取出来加入到数组中。\n+ 由于低数位先加入我们最终得到的Array数组中，所以我们需要翻转一下得到的数组，在java中可以调用Collections.reverse()函数来实现。\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        List<Integer> resultList = new ArrayList<>();\n        int sum =0;\n        for(int i=len-1;i>=0;i--){\n            sum = num[i]+k%10;\n            k=k/10;\n            if(sum>=10){\n                k++;\n                sum-=10;\n            }\n            resultList.add(sum);\n        }\n        while(k>0){\n            resultList.add(k%10);\n            k=k/10;\n        }\n        Collections.reverse(resultList);\n        return resultList;\n    }\n}\n```\n#### 时间复杂度\nO(n)\n#### 空间复杂度\nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyalei1026":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916481742","body":"### 思路\r\n convert a list of integers into a number\r\n update this number by adding k \r\n convert back the result into a list of integers\r\n### 代码\r\n```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_str = \"\"\r\n        for n in num:\r\n            num_str += str(n)\r\n        output = []\r\n        for n in str(int(num_str) + k):\r\n            output.append(int(n))\r\n        return output\r\n```\r\n**复杂度分析**\r\nTime Complexity：O(n)\r\nSpace Complexity：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangzz2015":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916499894","body":"\n\n\n## 思路\n- 把K按照位转换成vector。则求解方法和求解两个vector 数相加相同，从后往前遍历。注意carry。时间复杂度 k的位数N，A的位数位M, O(N) + O(max(N,M)) 空间复杂度为 O(N + max(N,M)) \n\n\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        \n        vector<int> veck;  \n        while(k)\n        {\n            veck.push_back(k%10);\n            k =k /10; \n        }\n        bool next = false; \n        int left =num.size()-1; \n        int right =0; \n        vector<int> ret; \n        while(left>=0 && right < veck.size())\n        {\n            int sum = num[left] + veck[right] + (next? 1:0);\n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            left--; \n            right++; \n        }\n        while(left>=0)\n        {\n            int sum = num[left] + (next? 1:0); \n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            left--;                 \n        }\n        while(right < veck.size())\n        {\n            int sum = veck[right] + (next? 1 : 0);\n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            right++;             \n        }\n        if(next)\n            ret.push_back(1);\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongxw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916507442","body":"### 思路\r\n\r\nwhile num[i]存在 或者 k不为0:\r\n    当前位sum = 进位 + nums[i](如果存在) + k mod 10 (如果k不为0)；\r\n    倒序遍历num，同时k = k /10;\r\n    进位 carry = sum / 10;\r\n    当前位 digit = sum mod 10;\r\n    输出数组记录digit;\r\n如果最后一位有进位，添加到输出数组中;\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    i = num.length - 1;\r\n    carry = 0;\r\n    ans = [];\r\n    while(i >= 0 || k != 0) {\r\n      sum = carry;\r\n      if (i >= 0) {\r\n        sum += num[i];\r\n        i--;\r\n      }\r\n      if (k != 0) {\r\n        sum += k % 10;\r\n        k = Math.floor(k / 10);\r\n      }\r\n\r\n      carry = Math.floor(sum / 10);\r\n      ans.unshift(sum % 10);\r\n    }\r\n\r\n    if (carry > 0) {\r\n      ans.unshift(carry);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。 k <= 10^4 不计\r\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okbug":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916511474","body":"JS 占坑\r\n其实可以用力扣第二题（两数之和） 类似的解法\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    for (let i = num.length - 1; i >= 0 || k > 0; i--) {\r\n\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n\r\n        res.push(k % 10); // 当时个位上的数\r\n        k = (k - k % 10) / 10;\r\n    }\r\n\r\n    return res.reverse();\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan0327":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916531466","body":"思路：\n1.数组从个位开始[即从后往前计数]，用一个sum保存位和[加数+被加数+低位进位],一个pre保存进位\n重新设置一个输出数组out。\n2.数组从后往前遍历，每位与k%10相加、与低位进位相加，获得sum 。 sum%10加入数组，sum/10为进\n位值，运算完记得把k/10.\n3.若数组跑完k还有值或进位有值，则再跑一遍循环处理完剩余的数据\n4.最后对整个数组首尾交换即可\n代码：\n```Go\nfunc largestRectangleArea(heights []int) int {\n    stack := []int{}\n    N := len(heights)\n    st, result := make([]int,N+2), 0\n    for i:=0; i< N+2;i++{\n        if i == 0 || i == N+1{\n            st[i] = 0\n        }else{\n            st[i] = heights[i-1]\n        }\n    }\n    for i:=0; i < N+2;i++{\n        for len(stack) > 0 &&st[i] < st[stack[len(stack)-1]]{\n            mid := stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            w := i - stack[len(stack)-1] - 1\n            h := st[mid]\n            result = max(result, w*h)\n        }\n            stack = append(stack, i)\n    }\n    return result\n}\n\nfunc max(x, y int) int{\n    if x > y{\n        return x\n    }else{\n        return y\n    }\n}\n```\n时间复杂度：O(n)\n空间复杂度:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916534184","body":"### 解题思路\n因为数组num的长度太大，会越界，所以每一数位单独运算。把k先用字符串方法转换为各个数位的数组。用`carry`记录进位，每一个对应数位进行加法运算，结果存到链表头部。注意循环结束后再查看一下最终进位`carry`是否为0，不为0的话存到链表中。\n\n### 代码（java）\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        String str = String.valueOf(k); // Convert k to string, can also use Integer.toString(k)\n        String[] elements = str.split(\"\"); // Get individual digits as String format\n        int klen = elements.length;\n\n        int carry = 0;\n        LinkedList<Integer> result = new LinkedList<>();\n        int nlen = num.length;\n        int length = nlen > klen ? nlen : klen;\n\n        for (int i = 0; i < length; i++) {\n            int knum = i < klen ? Integer.parseInt(elements[klen - 1 - i]) : 0;\n            int cur = nlen - 1 - i;\n            int n = i < nlen ? num[cur] : 0;\n            result.addFirst((n + knum + carry) % 10);\n            carry = (n + knum + carry) / 10;\n        }\n\n        if (carry != 0) result.addFirst(carry);       \n        return result;\n    }\n}\n```\n\n**复杂度分析**\n\n令n为nums数组长度，字符串数组的长度为logk\n- 时间复杂度：O(max(n, logk)), 两个数组长度的最大值（最终循环次数）\n- 空间复杂度：O(n), 创建链表储存结果","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZJP1483469269":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916534668","body":"#### 思路\n对数组与k进行按位加 保留进位位，并与下一位的k和数组相加 最后判断k是否加完，若没有则直接加进队列\n#### 代码\n    class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        int c=0;\n        int a=0;\n        LinkedList<Integer> ans = new LinkedList<>();\n        for(int i=len-1;i>=0;i--){\n            a = (num[i] + k%10 + c )%10;\n            c = (num[i] + k%10 + c)/10;\n            k = k/10;\n            ans.addFirst(a);\n        }\n        if(c!=0){\n            k=k+c;\n        }\n        if(k!=0){\n            while(k!=0){\n                ans.addFirst(k%10);\n                k/=10; \n            }\n        }\n        return ans;\n    }\n}; \n\n####复杂度分析\n时间复杂度：O(n) n为数组长度\n空间复杂度：O(n) n为数组长度\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mozro0327":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916536901","body":"## 思路\r\n\r\n+ 当前位 = 数字A + 数字B + 进位\r\n+ 利用 k 作为进位和数字B的和\r\n\r\n## 代码\r\n\r\n~~~ cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> result;\r\n        int size = num.size(), sum = 0;\r\n        for (int i = size - 1; i >= 0 || k > 0; i--, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            result.push_back(k % 10);\r\n        }\r\n        reverse(result.begin(), result.end());\r\n        return result;\r\n    }\r\n};\r\n\r\n~~~\r\n\r\n## 复杂度分析\r\n\r\n+ 空间复杂度 `O(n)`\r\n+ 时间复杂度`O(max(n, logk))`\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916539064","body":"## 989. Add to Array-Form of Integer\n\nThe **array-form** of an integer `num` is an array representing its digits in left to right order.\n\n- For example, for `num = 1321`, the array form is `[1,3,2,1]`.\n\nGiven `num`, the **array-form** of an integer, and an integer `k`, return *the **array-form** of the integer* `num + k`.\n\n**Example 1:**\n\n```\nInput: num = [1,2,0,0], k = 34\nOutput: [1,2,3,4]\nExplanation: 1200 + 34 = 1234\n```\n\n## Note\n\n1. O(n), O(n), `n is max(n.length,k.digitsNum)`\n   1. **From right to left**, pick the digits from the num array and k to construct the result array; Reverse the result array when returning.\n   2. CurrentValue is comprised of value from num, k and carry;Keep running the loop **as long as there is a value in num, k or carry**;\n2. Problems:\n   1. The num array could be too big to perform normal addition which leads to a totally wrong answer. \n   2. The summation of num array could be less than k which means that we may run out of the num array first.\n   3. Never forget carry.\n   4. The division in JS won’t give you an Int, please use `Math.floor()`.\n\n```js\nvar addToArrayForm = function(num, k) {\n    let res=[];\n    let carry=0;\n    let rightIndex=num.length-1;\n    \n    while(rightIndex>=0 || k>0 || carry>0){\n        let currentSum=rightIndex>=0?num[rightIndex]+carry+ k%10:carry+ k%10;\n        k=Math.floor(k/10);\n        carry=Math.floor(currentSum/10)\n        res.push(currentSum%10);\n        rightIndex--;\n    }\n  \n    return res.reverse();\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"NorthSeacoder":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916540032","body":"```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n    const res = [];\n    let carry = 0;\n    num.reverse();\n    const strK = String(k).split('').reverse().join('');\n    const maxLen = Math.max(num.length, strK.length)\n    for (let index = 0; index < maxLen; index++) {\n        let value = Number(strK[index] ? strK[index] : 0) + (num[index] ? num[index] : 0) + carry;\n        if (value >= 10) {\n            value %= 10;\n            carry = 1\n        } else {\n            carry = 0\n\n        }\n        res.push(value);\n    }\n    if (carry) res.push(carry)\n    return res.reverse()\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurallalala":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916541347","body":"### 代码\n```\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        num_k = []\n        while k > 0:\n            num_k.insert(0, k%10)\n            k = k // 10\n        l, lk = len(num), len(num_k)\n        if l < lk:\n            num, num_k = num_k, num\n            l, lk = lk, l\n        carry = 0\n        for i in range(max(l, lk)):\n            s = carry\n            l_idx, lk_idx = l-i-1, lk-i-1\n            s += num[l_idx]\n            if lk_idx >= 0:\n                s += num_k[lk_idx]\n            if s >= 10:\n                carry = s // 10\n                s = s % 10\n            else:\n                carry = 0\n            num[l_idx] = s\n        if carry > 0:\n            num.insert(0, carry)\n        return num\n```\n### 复杂度分析\n* 时间复杂度O(N)\n* 空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingliufilms":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916548236","body":"##  当前的问题：\r\n\r\n### 题目 run 的时候被 accept 了，但是 submit 的时候说是答案是错的。新手不知道该怎么改进。先把卡打了再说。如果有大佬看到，可以指点迷津吗？谢谢。我会继续改进。\r\n\r\n##  思路: \r\n\r\n- 先把当前 array 中转 string 再转回 integer, numInt；\r\n- 把 numInt 和 k 加起来成和, sum；\r\n- 利用 sum 除以 10 的余数来加入到新 array 的尾部\r\n\r\n## 代码 Javascript \r\n\r\n```\r\nconst addToArrayForm = function(num, k) {\r\n    const numInt = parseInt(num.join(''));\r\n    let sum = numInt + k;\r\n    const resultArray = [];\r\n    while (sum >= 0) {\r\n           let el = sum % 10 ;\r\n           sum = Math.floor(sum / 10);\r\n           resultArray.splice(0, 0, el);\r\n           }\r\n    return resultArray;\r\n```\r\n\r\n##  复杂度分析\r\n\r\n时间与空间均为 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jin03041209":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916558714","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> list = new LinkedList<>();\n        int i = num.length-1;\n        while(i>=0||k>0){\n            if(i>=0){\n                k +=num[i];\n            }\n            list.addFirst(k%10);\n            k /= 10;\n            i--;\n        }\n        return list;\n    }\n}\n复杂度分析：\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"agentzzz":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916559464","body":"两个思路：\n\n1.将数组元素转化为数字，然后数字相加，返回数组【但是，数字表示范围容易超限】\n\n2.按位相加\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        long long n = 0;\n        for (int i = 0; i < num.size(); ++i)\n        {\n            n = n * 10 + num[i];\n        }\n        n += k;\n        vector<int>res;\n        if(n==0) return {0};\n        while (n != 0)\n        {\n            res.push_back(n % 10);\n            n /= 10;\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n\n超出数字表示范围\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        \n        int i = num.size()-1;\n        vector<int>res;\n        while(i>=0)\n        {\n            int temp = num[i] + k;\n            res.push_back(temp%10);\n            k = temp/10;\n            i--;\n        }\n        while(k>0) {\n\t\t\tres.push_back(k%10);\n\t\t\tk/=10;\n\t\t}\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n\n时间复杂度O（N）\n\n空间复杂度O（N）\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916559576","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n## S1: 逐位相加\r\n\r\n将数字逐位相加，从低位到高位。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> ans;\r\n        int i = num.size() - 1;\r\n        int carry = 0;\r\n        while (i >= 0 || k > 0 || carry > 0) {\r\n            int a = i >= 0 ? num[i--] : 0;\r\n            int b = k > 0 ? k % 10 : 0;\r\n            k /= 10;\r\n            int sum = a + b + carry;\r\n            ans.push_back(sum % 10);\r\n            carry = sum / 10;\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(max(N,logk))$，N 是 num 的长度，logk 是 k 的位数。进行逐位相加以及最后 reverse 数组的时间分别都是 $O(max(N,logk))$。\r\n- ***Space:** $O(1)$，*除返回值外，使用的是常数空间。\r\n\r\n## S2: 相加\r\n\r\n将 k 从低位到高位直接加到数组的每一位。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> ans;\r\n        int i = num.size() - 1;\r\n        while (i >= 0 || k > 0) {\r\n            k += i >= 0 ? num[i--] : 0;\r\n            ans.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(max(N,logk))$\r\n- ***Space:** $O(1)$*","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingyingchu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916561783","body":"```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]: \r\n        # if k is 0, do an early return\r\n        if k == 0:\r\n            return num\r\n        # convert the array into an integer\r\n        temp = 0\r\n        for i in range(len(num)):\r\n            temp = temp * 10 + num[i]\r\n        # get the updated integer\r\n        temp = temp + k\r\n        # convert it back to an array by appending digits of the integer backwards to the result array\r\n        result = []\r\n        while temp > 0:\r\n            result.append(temp%10)\r\n            temp = temp // 10\r\n        return result[::-1]\r\n\r\n\r\ntime: O(n) - n is the length of num\r\nspace: O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SunStrongChina":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916563357","body":"> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> ```\r\n\r\n### 官方求解方法\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        result1=[]\r\n        for i in range(len(num)-1,-1,-1):\r\n            r1=num[i]+k%10\r\n\r\n            remain1=k//10+r1//10\r\n            if r1>=10:\r\n                r1=r1%10\r\n            result1.insert(0,r1)\r\n            k=remain1\r\n        if k>0:\r\n            while k:\r\n                result1.insert(0,k%10)\r\n                k=(k-k%10)//10\r\n        return result1\r\n```\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)\r\n### 字符串求解\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        str1=''\r\n        for num1 in num:\r\n            str1+=str(num1)\r\n        result1=int(str1)+k\r\n        return [int(s1) for s1 in str(result1)]\r\n```\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuyangqiQAQ":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916566326","body":"### 一位一位相加即可\n````java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int x = 0;\n        LinkedList<Integer> list = new LinkedList<>();\n        for (int i = 0; i < num.length; i++) {\n            int num1 = num[num.length - i - 1];\n            int num2 = k % 10;\n            k /= 10;\n            int sum = num1 + num2 + x;\n            if(sum >= 10) {\n                sum = sum - 10;\n                x = 1;\n            }else {\n                x = 0;\n            }\n            list.addFirst(sum);\n        }\n        while (k > 0 || x == 1) {\n            int num1 = k % 10 + x;\n            k /= 10;\n            if(num1 >= 10) {\n                num1 -= 10;\n                x = 1;\n            }else {\n                x = 0;\n            }\n            list.addFirst(num1);\n        }\n\n        return list;\n    }\n}\n````\n### 复杂度分析\n时间复杂度: O(max(n, logk))\n空间复杂度: O(max(n, logk)) 存储需要返回的结果","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"newbeenoob":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916566437","body":"## 思路\r\n\r\n---\r\n\r\n从数组末尾（个位）开始，逐位相加，并计算进位，因为是从低位开始计算，每次结果都要添加到结果数组的头部\r\n\r\n## 代码：JavaScript\r\n\r\n---\r\n\r\n```JavaScript\r\nvar addToArrayForm = function(num, k) {\r\n    const ans = [];\r\n    let carry = 0;\r\n    let cur;\r\n    let Addres;\r\n    let item;\r\n    let pos = num.length - 1;\r\n    do {\r\n        cur = k % 10;\r\n        k = ~~(k / 10); // ~~ 用于下取整\r\n        item = num[pos] ?? 0;\r\n        Addres = (cur + carry + item) % 10;\r\n        carry = ~~((cur + carry + item) / 10);\r\n        ans.unshift(Addres);\r\n        --pos;\r\n    } while( (k || carry) || pos >= 0)\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n---\r\n\r\n- 时间复杂度： `O(n + logk)`  n 为输入数组长度，k为非负整数大小\r\n\r\n- 额外空间复杂度： `O(1)`  \r\n\r\n## 标签\r\n\r\n---\r\n\r\n`数组` , `模拟`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samaritan1998":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916568209","body":"### 思路：\n\n和链表相加一样，while后面的条件是 || 然后循环里面再去判断\n\n### 代码：\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n=len(num)\n        i=n-1\n        res=[]\n        carry=0\n        while i>=0 or k!=0  or carry:\n            temp=0\n            if(i>=0):\n                temp+=num[i]\n                i-=1\n            if(k!=0):\n                temp+=k%10\n                k//=10\n                \n            res.append((temp+carry)%10)\n            carry=(temp+carry)//10\n        return res[::-1]\n```\n\n### 时间复杂度\n\nO(max（n，log(k)）) n为数组长度\n\n拓展一下链表加法\n\n```python\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        p=ListNode(0)\n        head=p\n        carry=0\n        while (l1 or l2 or carry):\n            if l1:\n                carry+=l1.val\n                l1=l1.next\n            if l2:\n                carry+=l2.val\n                l2=l2.next\n            p.next=ListNode(carry%10)\n            p=p.next\n            carry=carry//10\n        return head.next\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ginnydyy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916568816","body":"## Problem\nhttps://leetcode.com/problems/add-to-array-form-of-integer/\n\n## Notes\n- Cannot solve the problem by converting `num` to int then do the addition and convert it back to int array. Because `1 <= num.length <= 104` and Integer.MAX_VALUE is smaller than that, the conversion or addition will cause overflow.\n- When doing addition, need to consider when the sum is larger than `9`, need to do the `k++` and `sum -= 10` to carry `1`, after `k /= 10`.\n- The length of `num` may be shorter than the length of `k`, the first loop condition should use the length of `num`. Use the second loop to convert the remain of `k`.\n- The length of `num` may be longer than the length of `k`, since `k%10` and `k/10` will be always 0 after `k` becomes 0, so it's ok to use the length of `num` in the first loop.\n- The original length of ArrayList is `10`, and the solution can always add the new digit at index 0 of the List, perhaps using LinkedList as the returned List would have better performance.\n\n## Solution\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new LinkedList<>();\n        for(int i = num.length - 1; i >= 0; i--){\n            int sum = num[i] + k%10;\n             k /= 10;\n            if(sum > 9){\n                k++;\n                sum -= 10;\n            }\n            result.add(0, sum);\n        }\n        while(k > 0){\n            result.add(0, k%10);\n            k /= 10;\n        }\n        return result;\n    }\n}\n```\n\n## Complexity\n- Time: The solution processes each element of `num` and each digit of `k`. So it's O(max(n, `the number of digits of k`)). And the `the number of digits of k` is `logk` (https://brilliant.org/wiki/finding-digits-of-a-number/). So it's O(max(n, logk)) (n is the length of `num`).\n- Space: Except the returned List, the extra space used is O(1).","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GemZq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916569778","body":"### 代码\n```python \nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        A_list = [str(i) for i in num ]\n        A_number = int(''.join(A_list))\n        result_number = A_number + k\n        result = [int(i) for i in str(result_number)]\n        return result\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlemoon-zh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916571164","body":"## day 1\n\n简单粗暴的解法：\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = 0\n        for number in num:\n            n = n * 10 + number\n        return [int(ch) for ch in str(k + n)]\n```\n复杂度：`O(n)`\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xbhog":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916571254","body":"# 989.数组形式的整数加法\n\n## 思路：\n\n首先的思路是：\n\n1. 遍历数组整合成整数\n2. 与k值相加\n\n刚开始前三个测试样例平安无事，从测4后开始疯狂溢出。\n\n把int 改成Long，短暂解决，测96后，又开始了一轮溢出.....\n\n解决方式：\n\n数组的最后一位与k的最后一位相加，注意进位量。\n\n思考缺点：\n\n1. 对数据不敏感\n2. 思考不完整\n3. 读题不明确就上手做\n\n## 代码段：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for(int i = n-1; i >= 0; i--){\n            //数组最后一个与k的最后一位相加\n            int sum = num[i]+k%10;\n            k /= 10;\n            if(sum >= 10){\n                sum -=10;\n                //进位设置\n                k++;\n            }\n            res.add(sum);\n        }\n        //防止k的位数大于num\n        for(;k >0; k/=10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n## 复杂度分析：\n\n无嵌套,除返回值以外，操作空间为O(1)\n\n- 时间复杂度 O(N)\n- 空间复杂度 O(1)\n\n如果解释有所错误，欢迎朋友指正，感谢！\n\n## ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"st2yang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916573727","body":"## 思路\r\n- k 添加到末尾\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        res = []\r\n\r\n        i = n - 1\r\n        while i >= 0 or k > 0:\r\n            if i >= 0:\r\n                k += num[i]\r\n            res.append(k % 10)\r\n            i -= 1\r\n            k //= 10\r\n        \r\n        return res[::-1]\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiezhengyun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916575375","body":"# 思路\n- 把k转数组，变成两个数组相加\n- 生成res数组。长度要比num 和 kArr 最大长度 + 1\n- 个位数相加，添加到res 数组\n- 判断进位carry，返回结果\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  var l1 = num.length - 1;\n  var kArr = String(k).split('');\n  var l2 = kArr.length - 1;\n  var resLen = (l1 > l2 ? l1 : l2) + 1;\n  var res = new Array(resLen + 1).fill(0);\n  var carry = 0;\n\n  while (l1 > -1 || l2 > -1) {\n    var val1 = l1 > -1 ? num[l1] : 0;\n    var val2 = l2 > -1 ? kArr[l2] : 0;\n\n    var sum = val1 + Number(val2) + carry;\n    var carry = Math.floor(sum / 10);\n    res[resLen] = Math.floor(sum % 10);\n\n    resLen--;\n    if (l1 > -1) l1--;\n    if (l2 > -1) l2--;\n  }\n\n  if (carry) {\n    res[resLen] = carry;\n  } else {\n    res.shift();\n  }\n  return res;\n};\n```\n# 复杂度分析\nN是数组nums的长度，K是数字k的长度\n- 时间复杂度  O(max(N,K) + shift) shift 是数组删除第一个元素\n- 空间复杂度 O(max(N,K)+1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916575768","body":"### 思路\n列表转成数值，加上k，然后倒着一位一位加到列表，然后反转列表\n### 代码（Python3）\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        inta = 0\n        for i in A:\n            inta = inta*10 + i\n        inta = inta+K\n        res = []\n        while inta!=0:\n            res.append(inta%10)\n            inta//=10\n        if not res:\n            res.append(0)\n        return res[::-1]\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Toms-BigData":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916577408","body":"# 思路\n将数组中的数字转化为字符拼接成字符串，将字符串转化为int类型与K相加后再次转化为字符串，通过list()和map()函数将字符串拆分成int数组\n# 代码：Python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_str = \"\".join('%s' %id for id in num)\n        num_data = str(int(num_str) + k)\n        return list(map(int,num_data))\n# 时间复杂度\n时间复杂度为O(n)\n空间复杂度为O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ymkymk":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916579966","body":"# **思路**\n\n从低位开始相加，大于10就进位\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n    public List<Integer> addToArrayForm(int[] num, int k){\n        List<Integer> res = new ArrayList<Integer>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10){\n                //进一位\n                k++;\n                //减去10才是需要的数\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n\n        /**\n         * 如果k位数比数组多\n         */\n        for(; k > 0; k /= 10){\n            res.add(k % 10);\n        }\n\n        //链表反转\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(max(n, logk))，如果n>k，那么复杂度就是O(n)，如果k比n大，那么复杂度就是O(logk)\n\n空间复杂度：O(1)，每次使用的空间都为常数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HackBL":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916580190","body":"```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        while (k > 0) {\r\n            list.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        return list;\r\n    }\r\n}\r\n```\r\n* 时间复杂度: O(Max(n, k))\r\n* 空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"TimmmYang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916580399","body":"## 思路\n从低到高逐位相加。如果k的位数比X多，就继续执行一遍。可以把两个循环合并，给结果单开一个list逆序返回。\n## 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            summ = num[i] + k % 10 + carry\n            k //= 10\n            carry = 0\n            if summ >= 10:\n                carry = 1\n                summ -= 10\n            num[i] = summ\n        if carry == 1 and k == 0:\n            num.insert(0, 1)\n            return num\n        while k != 0:\n            summ = k % 10 + carry\n            k //= 10\n            carry = 0\n            if summ >= 10:\n                carry = 1\n                summ -= 10\n            num.insert(0, summ)\n        if carry == 1:\n            num.insert(0, 1)\n        return num\n```\n## 复杂度\n时间：O(max(n, log(k)))，n为num长度\n\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AnhTom2000":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916581198","body":"## 思路\r\n遍历数组并且拆分k进行诸位相加，过程中注意如果两者的和超过了个位数，需要累计进位。\r\n## Java\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        int i = num.length - 1;\r\n        while( i >= 0 || k > 0){\r\n          if( i >= 0){\r\n          int sum = num[i] + k % 10;\r\n          k/=10;\r\n          if(sum >=10){\r\n            k++;\r\n            sum-=10;\r\n          }\r\n          list.addFirst(sum);\r\n          i--; \r\n        }else {\r\n          list.addFirst(k%10);\r\n          k/=10;\r\n        }\r\n      }\r\n        return list;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度：`O(n+logk)`,n为数组长度\r\n空间复杂度：`O(max(n,k))`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"15691894985":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916582098","body":"day  01  989　　数组形式的整数加法\r\n\r\n- 思路：\r\n  1. 遍历数组，取出合成整数\r\n  2. 合成整数与Ｋ求和\r\n  3. 把求和后的整数再反向分解为数组\r\n\r\n- 代码段：\r\n```python\r\n  def add_to_array(arrya,k):\r\n       n = len(arrya)\r\n       x=0\r\n       y =[]\r\n      for i in range(n):\r\n          x = x+ arrya[i] * 10**(n-i-1)\r\n       x = x +k\r\n       if len(x)>n:\r\n          for i in range(len(x)):\r\n              y.append( x//(10**(len(x)-i-1)))\r\n              x = x -y[i]*(10**(len(x)-i-1))\r\n       else:\r\n          for i in range(n):\r\n              y.append( x//(10**(n-i-1)))\r\n              x = x -y[i]*(10**(n-i-1))\r\n      return y\r\n  \r\n\r\n\r\n- 复杂度分析\r\n  1. 时间复杂度 O(N)\r\n  2. 空间复杂度O(1)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MonkofEast":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916582275","body":"# Algo\n1. Loop the array in a reversing way.\n   1. **Add current int directly to the current loc**\n   2. **Cal quo and res. Save quo as new int to next iter; save res as current item**\n   > (Optional) Leave the loop if no int should be added\n2. Attach the rest of quo in front of the array\n   >**DO remember to split out the quo since quo might not be single-digit**\n\n# Code\n```py\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # there is a same question for linked list\n        \n        # xrange(start, stop[not included], step) is not a list but a generator\n        for i in range(len(num) - 1, -1, -1):\n            # if reach the highest digit, if still have k, save and add\n            # else, just keep adding\n            num[i] += k\n            # carry along\n            k, num[i] = divmod(num[i], 10)\n            # no carry, leave\n            if not k: break\n        \n        # use map to broadcast for corners like \"[0], 100\"\n        # map(func, iterable), return an iterator\n        if k: num = list(map(int, str(k))) + num\n        return num\n```\n\n# Comp\n> T: O(N)\n> \n>S: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916583583","body":"## 思路\n\n通过算盘模拟大数加法\n\n```js\n/**\n * @param {number[]} A\n * @param {number} K\n * @return {number[]}\n */\nvar addToArrayForm = function (A, K) {\n  // K 也转换为数组\n  K = K.toString().split('').map(v => +v)\n\n  // 保证A的长度 > K的长度\n  if (A.length < K.length) {\n    [A, K] = [K, A]\n  }\n\n  A.reverse()\n  K.reverse()\n\n\n  let carry = 0\n  for (let i = 0; i < A.length; i++) {\n    // A 长度大于 K, K[i] 可能越界\n    let b = K[i] === undefined ? 0 : K[i]\n    let curSum = A[i] + b + carry\n    A[i] = curSum % 10\n    carry = Math.floor(curSum / 10)\n  }\n\n  // 处理最后的进位\n  if (carry) {\n    A.push(carry)\n  }\n\n  return A.reverse()\n};\n```\n\n+ 时间复杂度: $O(max(n, m)), n 为数组A的长度, m 为数字K转字符后的长度\n+ 空间复杂度: $O(m)$, m 为数字K转字符后的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xj-yan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916584126","body":"# 思路\n从右向左遍历数组，并依次取k的最低位进行相加，如果结果大于10，则需要进位。\n\n# Java\n\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        boolean isCarried = false;\n        List<Integer> list = new ArrayList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0 || isCarried){\n            if (i >= 0 && k == 0 && !isCarried){\n                list.add(num[i]);\n                i--;\n                continue;\n            }\n            int val = (i >= 0 ? num[i--] : 0) + k % 10 + (isCarried ? 1 : 0);\n            if (val >= 10) {\n                val %= 10;\n                isCarried = true;\n            }else isCarried = false;\n            list.add(val);\n            k /= 10;\n            \n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n\n```\n\n# 复杂度分析\n\n时间复杂度：O(max(n, log k)),  n为数组长度\n空间复杂的：O(1) 如果不考虑输出结果占用的空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ychen8777":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916584445","body":"### 思路\n一开始看到 1 <= num.length <= 10^4 ，理解成 num 所代表的数最大为 10^4，就用了把 num 转成整数，加上 k, 再转回 arrayform 的方法，结果 num 很长的test case应该是出现overflow了\n而实际上 k 才是最大值比较小的参数，于是，从个位开始一位一位加，形成 arraylist，再反转\n\n### Java\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        \n        List<Integer> arrayForm = new ArrayList<>();\n        \n        int p = num.length - 1;\n        while (p >= 0 || k > 0) {\n            if (p >= 0) {\n                k += num[p];\n            }\n            \n            arrayForm.add(k % 10);\n            k = k / 10;\n            p--;\n        }\n        \n        Collections.reverse(arrayForm);\n        return arrayForm;\n   }\n}\n```\n### 复杂度\ntime: O(max(num的长度，k的位数))\nspace: O(max(num的长度，k的位数))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"L-SUI":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916585903","body":"思路：字符串相加，大位数相加，从后往前算\r\njs\r\n\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilixikun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916586596","body":"## 思路如下\n数组从末尾、数字从个位开始依次累加、最好记得要注意头是否是 1\n## 代码如下\n```js\n  let len = num.length,\n    add = 0,\n    res = [];\n  while (len >= 0 || k > 0) {\n    const num1 = k % 10 || 0;\n    const num2 = num.length ? num.pop() : 0;\n    let sum = num1 + num2 + add;\n    if (sum > 9) {\n      sum %= 10;\n      add = 1;\n    } else add = 0;\n    res.unshift(sum);\n    len--;\n    k = parseInt(k / 10);\n  }\n  if (add) res.unshift(add);\n  return res\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Zhang6260":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916586641","body":"## JAVA版本\n\n## 思路：\n\n从数组的最后一位，当然数组的数+进位数，余数就是当前该位置的数，除以10的商便是进位数。（最后遍历完数组还有判断，进位数是否为0的情况，例如为:arr【9,9,9,9】，K为1的情况）\n\n## 代码\n\n> ```\n>    public static int[]fun(int[]arr,int K){\n>    LinkedList<Integer> list=new LinkedList<>();\n>     for(int i=arr.length-1;i>=0;i--){\n>         int temp=arr[i]+K;\n>         if(temp>=10){\n>\n>             list.add(0,temp%10);\n>             K=temp/10;\n>         }else {\n>             list.add(0,temp);\n>             K=0;\n>         }\n>     }\n>     while (K>0){\n>         list.add(K%10);\n>         K=K/10;\n>     }\n>     int[]res=new int[list.size()];\n>     for(int i=0;i<list.size();i++){\n>         res[i]=list.get(i);\n>     }\n>\n>     return  res;\n> }\n> ```\n\n__时间复杂度__：O(N)\n\n__空间复杂度__：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JK1452470209":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916587656","body":"**思路**\r\n从个位往后相加(处理进位情况)并存进list中，最后将list反转\r\n**Java**\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ret = new ArrayList<Integer>();\r\n        for (int i = num.length - 1; i >= 0; i--){\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10){\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            ret.add(sum);\r\n        }\r\n        //k>num.length情况\r\n        for (;k > 0;k /= 10){\r\n            ret.add(k % 10);\r\n        }\r\n        Collections.reverse(ret);\r\n        return ret;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度 :O(max(num.length,k))\r\n\r\n- 空间复杂度 :O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"peteruixi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916589529","body":"### 思路\n\n先算出总和 再转换成列表\n\n### 代码\n\n```python\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = 0\n        for i in num:\n            temp = temp*10+i\n        temp += k\n        res = []\n        for i in str(temp):\n            res.append(int(i))\n        return res\n```\n\n### 复杂度\n\n- 时间复杂度: O(2N)\n- 空间复杂度: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user1689":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590008","body":"## 思路\n模拟竖式加法\n\n## python3\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        # 将k转化成数组\n        num2 = []\n        strK = str(k)\n        for element in strK:\n            num2.append(element)\n        \n        # 直接相加 \n        res = []\n        addCarry = 0\n        i, j = len(num) - 1, len(num2) - 1\n        while i >= 0 and j >= 0:\n            sum_ = num[i] + int(num2[j]) + addCarry\n            digit = sum_ % 10\n            addCarry = sum_ // 10\n            res.append(digit)\n            i -= 1\n            j -= 1\n\n        # 如果多出digit另外处理\n        while i >= 0:\n            sum_ = num[i] + addCarry\n            digit = sum_ % 10\n            addCarry = sum_ // 10\n            res.append(digit)\n            i -= 1\n        \n        # 如果多出digit另外处理\n        while j >= 0:\n            sum_ = int(num2[j]) + addCarry\n            digit = sum_ % 10\n            addCarry = sum_ // 10\n            res.append(digit)\n            j -= 1\n\n        # 如果有进位 则加1\n        if addCarry:\n            res.append(1)\n        \n        # 因为append的原因，最后得反转\n        return res[::-1]\n\n        # print(res)\n```\n## 复杂度分析\n* time max(n, logk) n为数组长度\n* space n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xieyj17":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590188","body":"# 1. 模拟加法逻辑\r\n\r\n把 `num` 和 `k` 都转换成array， 然后逆序从最后一位开始相加，如果大于10 就向下一位进1\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # res stores the final solution\r\n        res = []\r\n        # reverse order of num\r\n        num = num[::-1]\r\n        # convert k to an arry and reverse the order\r\n        sk = [int(i) for i in str(k)]\r\n        sk = sk[::-1]\r\n\t\t# padding 0s to the shorter array\r\n        if len(num) >= len(sk):\r\n            sk = sk + [0]*(len(num) - len(sk))\r\n        else:\r\n            num = num + [0]*(len(sk) - len(num))\r\n\t\t# t stores the result of floor division \r\n        t = 0\r\n     \r\n        for i in range(len(num)):\r\n            n = num[i]\r\n            k = sk[i]\r\n            # add residual to the final solution\r\n            res = res + [(n+k+t) % 10]\r\n            t = (n+k+t) // 10\r\n            \r\n        # if the last addition results a modulo > 0, add to the end of res\r\n        if t > 0:\r\n            res = res + [1]\r\n        return res[::-1]\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度： O(n)\r\n\r\n# 2. Why bother ¯\\\\_(ツ)_/¯\r\n\r\n使用python 内置函数，把 `num` 转换成 int\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sn = [str(i) for i in num]\r\n        sn = int(''.join(sn))\r\n        res = str(sn+k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shamworld":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590720","body":"# 思路\n从末尾遍历num，取出值和k%10的余相加，然后把k除以10取余，这个时候就判断a的值是不是大于等于10，如果是，就处理a的值和k++，把处理的a放入数组，这里要判断k的边界，如果num循环完了，k还有值，那么就处理k，在加入数组中，最后把数组反转\n```js\nvar addToArrayForm = function (num, k) {\n    let m, res = [];\n    for (let i = num.length - 1; i >= 0; i--) {\n        m = num[i] + k % 10;//取末尾和k除以10的余相加\n        k = Math.floor(k / 10);\n        if (m >= 10) {\n            k++;//相加最大也是19 所以k+1就行\n            m = m - 10;//拿到当前位的值\n        }\n        res.push(m);\n    }\n    //k的长度大于num的长度的情况\n    while (k != 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    return res.reverse();\n};\n```\n# 复杂度分析\n- 时间复杂度:O(max(num.length,k))\n- 空间复杂度:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"learning-go123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590825","body":"## 思路\n在原有num上操作数据，进位在num前面插入数据\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc addToArrayForm(num []int, k int) []int {\n    for i:=len(num)-1;i>=0;i--{\n        val := num[i] + k %10\n        k /= 10\n\n        num[i] = val % 10\n        if val > 9 {\n            if i - 1 >= 0 {\n                num[i-1] += 1\n            } else {\n                num =  append([]int{1}, num...)\n                i++\n            }\n        } \n    }\n\n    for k !=0 {\n        num =  append([]int{k%10}, num...)\n        k /= 10\n    }\n\n    return num\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a244629128":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590955","body":"```javascript\nvar addToArrayForm = function(A, K) {\n    //start from the last Index\n    let flag = A.length - 1\n    //if k <=0 jump out the loop\n    while(K) {\n        // if flag < 0 mean we still have carry left and K is not zero yet\n        if(flag < 0) {\n            //put the carray to the front\n            A.unshift(K % 10)\n        } else {\n            // k plus the last index value\n            K += A[flag]\n            // update the last index value by K % 10,if k is bigger than 9 we only take the units digit(个位数）\n            A[flag] = K % 10\n            //flag mins one for each loop\n            flag--;\n        \n        }\n        \n        K = Math.floor(K / 10)\n        \n    }\n    return A\n}\n// time O(n);\n//space O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhousibao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916592720","body":"```ts\nfunction addToArrayForm(arr: number[], k: number): number[] {\n    let n = arr.length - 1\n    const list = []\n    while( n >= 0 || k){\n        k += (arr[n] || 0)\n        list.push(k%10)\n        k = Math.floor(k/10)\n        n--\n    }\n    return list.reverse()\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RocJeMaintiendrai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916592795","body":"## 题目\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/submissions/\n## 思路\n从最低位开始两两相加，如果计算结果大于10，需要进一位，在高一位的计算中加1。需要注意的是k是有可能比num的位数多，不要忽略这种情况。还有就是不能将num转为integer与k相加后再转为数组形式，因为可能会越界。\n## 代码\n``` java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n\t\tfinal int len = num.length;\n\t\tfor(int i = len - 1; i >= 0; i--) {\n\t\t\tint sum = num[i] + k % 10;\n\t\t\tk /= 10;\n\t\t\tif(sum >= 10) {\n\t\t\t\tk++;\n\t\t\t\tsum -= 10;\n\t\t\t}\t\n\t\t\tres.add(0, sum);\n\t\t}\n\t\tfor(; k > 0; k /= 10) {\n\t\t\tres.add(0, k % 10);\n\t\t}\n\t\treturn res;\n    }\n}\n```\n## 复杂度分析\n#### 时间复杂度\nn为num的长度，k为k的长度，如果k比n小，则时间复杂度为O(n),如果k的长度大于n，则复杂度应为O(k),所以时间复杂度应为O(max(n, k)).\n#### 空间复杂度\n除result外没有开辟新的空间，因此复杂度应为O(1).","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ysy0707":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916593071","body":"```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int n = A.length;\n        List<Integer> res = new ArrayList<>();  // 可以用 LinkeList，或者 ArrayList 往后加，最后反转\n        int i = n - 1, sum = 0, carry = 0;\n        while (i >= 0 || K != 0) {  // 循环条件：两个数有一个没完\n            int x = i >= 0 ? A[i]: 0;\n            int y = K != 0 ? K % 10 : 0;\n                        \n            sum = x + y + carry;\n            carry = sum / 10;\n            K = K / 10;\n\n            i--;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AstrKing":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916593572","body":"## 思路\n\n~~~bash\n直接从后往前加，然后最低位留对10的余数即可。\n~~~\n\n## 代码\n\n~~~java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n~~~\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JadeQi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916595505","body":"# 思路\n\n遍历数组整合成整数\n与k值相加\n刚开始前三个测试样例平安无事，从测4后开始疯狂溢出。\n\n把int 改成Long，短暂解决，测96后，又开始了一轮溢出.....\n\n# 解决方式：\n\n数组的最后一位与k的最后一位相加，注意进位量。\n\n# java\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for(int i = n-1; i >= 0; i--){\n            //数组最后一个与k的最后一位相加\n            int sum = num[i]+k%10;\n            k /= 10;\n            if(sum >= 10){\n                sum -=10;\n                //进位设置\n                k++;\n            }\n            res.add(sum);\n        }\n        //防止k的位数大于num\n        for(;k >0; k/=10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunupdong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916599149","body":"## 思路：\n\n* 官方题解思路\n* 数组从后往前遍历，数组最后一位与K个位数相加，以此类推\n  * 需要判断相加大于10的情况\n  * 需要判断当k大于数组num时，数组遍历完，k值还有的情况\n  * 最后push进数组，返回时需反转\n\n``` js \n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  const numLength = num.length\n  let res = []\n\n  for (let i = numLength - 1; i >= 0; --i) {\n    // 每一位相加\n    let sum = num[i] + k % 10\n    // 得到除去参与相加的数\n    k = Math.floor(k / 10)\n\n    // 如果相加大于9，结果取个位数，十位数给k，参与下一次循环\n    if (sum > 9) {\n      sum -= 10\n      k++\n    }\n    res.push(sum)\n  }\n\n  /**\n   *  如果k的值大于数组num值，还要将剩余的k的每一位push到数组里\n   *  由于上面执行的操作，k会不断减少一位，如果到这里还剩余，说明大于数组num值，所以此次判断条件为k>0\n   *  for(k=k; k>0; k=Math.floor(k/10))\n   */\n  for (; k > 0; k = Math.floor(k / 10)) {\n    res.push(k % 10)\n  }\n\n  // 由于前面数组是push，个位数在第一个，所以数组要反转一下\n  res.reverse()\n  return res\n};\n```\n\n## 复杂度分析\n\n* 时间复杂度：O(max(n, log k))，其中n为数组的长度\n* 空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Laurence-try":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916599312","body":"### 思路\r\n从k的个位开始，每一位加到num里面，用carry记录进位，并在下一位计算的时候算上carry值并更新carry值。需要对于num和k的长度difference的情况，分别讨论。\r\n### 代码\r\n使用代码: Python3\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        if not num:\r\n            return list(str(k))\r\n        if not k:\r\n            return num\r\n        c = 0\r\n        n_len = len(num)\r\n        pointer = n_len - 1\r\n        res = []\r\n        while pointer >= 0 or k > 0:\r\n            if pointer >= 0:\r\n                k_c = k % 10\r\n                k = k // 10\r\n                new_dig = (num[pointer] + k_c + c) % 10\r\n                c = (num[pointer] + k_c + c) // 10\r\n                num[pointer] = new_dig\r\n                pointer -= 1\r\n            else:\r\n                k = k + c\r\n                k_c = k % 10\r\n                k = k // 10\r\n                res.append(k_c)\r\n                c = 0\r\n        res = res[::-1]\r\n        if c > 0:\r\n            return [c] + num\r\n        else:\r\n            return res + num\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(max(num_len, k_len))， 其中num_len为num的长度， k_len为str(k)的长度\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"machuangmr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916600573","body":"### 思路\n-  1、将数组的最后一个元素和k的个位开始相加，\n-  2、大于等于10 就向前进一位（k的前一位 + 1）\n-  3、 重复以上步骤知道数组和k的位数结束\n\n### 代码\n- 语言：Java\n```java\nclass Solution {\n    // 思路： 1、将数组的最后一个元素和k的个位开始相加，\n    //       2、大于10 就向前进一位（k的前一位 + 1）\n     //        3、 重复以上步骤知道数组和k的位数结束\n    public List<Integer> addToArrayForm(int[] num, int k) {\n     List<Integer> rest = new LinkedList<>();\n    int len = num.length - 1;\n    for(int i = len;i >= 0;i--) {\n        int total = num[i] + k % 10;\n        //取除过后一位的前面的值\n        k /= 10;\n        if(total >= 10) {\n            //大于10，则前面的值需要进1\n            k++;\n            total = total % 10;\n        }\n        rest.add(total);\n    }\n    while(k > 0) {\n        rest.add(k % 10);\n        k /=10;\n    }\n     Collections.reverse(rest);\n     return rest;\n    }\n}\n\n````\n### 复杂度\n- 空间复杂度：O(1)\n- 时间复杂度 O max(num.length, k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gaozizhong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916600638","body":"# 思路\r\n把K从个位数开始分解成单个值与num从个位开始（倒序）相加，存入数组。\r\n要注意K位数高于num的情况。\r\n最后把结果数组进行反转即可得到正确答案。\r\n\r\n# 代码：Go\r\n```\r\nfunc addToArrayForm(num []int, k int) (result []int) {\r\n\tfor  i := len(num) - 1 ; i >= 0 ; i--{\r\n\t\tsum := num[i] + k % 10\r\n\t\tk /= 10\r\n\t\tif sum >= 10{\r\n\t\t\tk ++\r\n\t\t\tsum -= 10\r\n\t\t}\r\n\t\tresult = append(result, sum)\r\n\t}\r\n\tfor ; k > 0; k /= 10 {\r\n\t\tresult = append(result, k % 10)\r\n\t}\r\n\treverse(result)\r\n\treturn result\r\n}\r\n\r\nfunc reverse(result []int) {\r\n\tfor i, n := 0, len(result); i < n/2; i++{\r\n\t\tresult[i], result[n-1-i] = result[n-1-i], result[i]\r\n\t}\r\n}\r\n```\r\n\r\n# 时间复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wang-hejie":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916601021","body":"## <font color=#A0522D>思路</font>\r\n\r\n从数组末尾开始往前遍历，每一位先和 k 相加。\r\n相加的和 %10 就是这一位应有的数值，相加的和 整除10 就是下一位的 k 。\r\n\r\n<font color=red>**注意：**</font>如果数组遍历结束后， k 仍然不为 0 ，那么需要将剩下的 k 加入到数组开头\r\n\r\n## <font color=#A0522D>复杂度</font>\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n\r\n## <font color=#A0522D>代码(Python3)</font>\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for i in range(len(num)-1, -1, -1):\r\n            k_add_num = num[i] + k\r\n            num[i] = k_add_num % 10\r\n            k = k_add_num // 10\r\n            # 提前退出循环的trick\r\n            if not k:\r\n                break\r\n        \r\n        if k:\r\n            while k:\r\n                num.insert(0, k % 10)\r\n                k = k // 10\r\n        \r\n        return num\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Francis-xsc":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916601314","body":"### 思路\n\n模拟加法，从个位开始加，如有进位，k--（用变量表示进位有点复杂）\n最后反转\n\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len=num.size();\n        vector<int>ans;\n        for(int i=len-1;i>=0;--i)\n        {\n            int t=num[i]+(k%10);\n            k/=10;\n            if(t>=10)\n            {\n                t%=10;\n                k++;\n            }\n            ans.push_back(t);\n        }\n        while(k)\n        {\n            ans.push_back(k%10);\n            k/=10;\n        };\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)，其中 N 为数组长度。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iambigchen":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916602214","body":"### 思路\n大数相加 每个位置相加，如果大于9，向前进一位\n\n### 代码\n```js\nvar addToArrayForm = function(num, k) {\n    k = String(k).split('')\n    var length = Math.max(num.length, k.length)\n    var res = new Array(length).fill(0)\n    for (let index = length-1; index >= 0; index--) {\n        var a = num.length > 0 ? num.pop() : 0\n        var b  = k.length > 0 ?  k.pop() : 0\n        var sum = res[index] + a + +b\n        res[index] = sum % 10\n        if (sum > 9) {\n            if (index-1 >= 0) {\n                res[index - 1] = 1\n            } else {\n                res.unshift(1)\n            }\n        }\n    }\n    return res\n};\n```\n\n### 复杂度\n\n时间： O(n)\n空间： O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Cartie-ZhouMo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916605114","body":"### 思路\r\n从低位到高位遍历num、k，求和，注意进位。如果 k > A，需将剩余数字转换并插到num前。\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        if k == 0: return num\r\n        flag = 0\r\n        for i in range(len(num)-1, -1, -1):\r\n            k, b = k//10, k%10\r\n            num[i], flag = (num[i] + b + flag)%10, (num[i] + b + flag)//10\r\n        tmp = []\r\n        k += flag\r\n        while k:\r\n            k, n = k//10, k%10\r\n            tmp.append(n)\r\n        return tmp[::-1] + num\r\n```\r\n**复杂度分析**\r\n- 时间：O(max(n, K)) K = k的位数, N = len(num)\r\n- 空间：O(max(1, K-n))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ningli12":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916605335","body":"### **思路**\r\n- 从k的个位开始，从num最后一位开始加，用carry记录进位\r\n- 在下一位计算的时候算上carry值并更新carry值, k也需要更新。\r\n- 需要处理carry > 0的情况，在高一位的计算中加carry\r\n- 反转结果\r\n\r\n### **代码**\r\n\r\n- 使用代码: Java\r\n\r\n```\r\nclass Solution {\r\n        public List<Integer> addToArrayForm(int[] num, int k) {\r\n            List<Integer> res = new ArrayList<>();\r\n            if(num == null) return res;\r\n            int carry = 0;\r\n            int size = num.length -1;\r\n            while(k > 0 || size >= 0){\r\n                int curNum = size >= 0? num[size] : 0;\r\n                int curK = k % 10;\r\n                int curSum = curNum + curK + carry;\r\n                int curAdd = curSum % 10;\r\n                carry = curSum / 10;\r\n                size--;\r\n                k = k/10;\r\n                res.add(curAdd);\r\n            }\r\n            if(carry > 0) {\r\n                res.add(carry);\r\n            }\r\n            Collections.reverse(res);\r\n            return res;\r\n        }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n- 时间复杂度：O(max(n, log k))，其中n为数组的长度\r\n- 空间复杂度：O(max(n, log k)。使用的空间为数组和k的最大长度。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YQYCS":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916605762","body":"### 思路：\r\n        将K逐位分解，加入到A中\r\n### 代码\r\n```\r\nclass Solution:\r\n  def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        i = len(A) - 1\r\n        while K:\r\n            A[i] += K\r\n            K, A[i] = A[i] // 10, A[i] % 10\r\n            i -= 1\r\n            if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n        return A\r\n```\r\n### 复杂度分析\r\n        时间复杂度：O（N），需要遍历一遍数组，故为N\r\n        空间复杂度：O（1），不需要额外开辟空间\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916608620","body":"\n#idea: two iterations to add and decompose the num\n# time and space o(N)\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        nums = 0\n        length = len(num)\n        \n        for i in range(length):\n            nums += num[i] * (10**(length-1-i))\n        print(nums)\n        nums2= nums+k\n        list1 = []\n        if nums2 == 0:\n            return[0]\n        while nums2:\n            a= nums2%10\n            nums2 //= 10\n            list1.insert(0,a)\n        return list1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"siyuelee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916610263","body":"## 思路：\n将K先加到数组最后一位，再从后向前遍历数组，依次进位\n## 代码\n```Python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n\n        num[-1] += k\n        for i in range(len(num) - 1, -1, -1):\n            carry, num[i] = divmod(num[i], 10)\n            if i > 0:\n                num[i-1] += carry\n        while carry:\n            num = [carry%10] + num\n            carry = carry//10\n        return num\n```\n## 复杂度分析\n    时间复杂度：O（N），需要遍历一遍数组，故为N\n    空间复杂度：O（1），不需要额外开辟空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916612541","body":"````\nvar addToArrayForm = function(num, k) {\n  let arr = [];\n  while (k !== 0) {\n    arr.unshift(k % 10);\n    k = Math.floor(k / 10);\n  }\n  let res = num.length > arr.length ? num : arr;\n  let i = 1;\n  while (i <= res.length) {\n    let add1 = num.length - i >= 0 ? num[num.length - i] : 0;\n    let add2 = arr.length - i >= 0 ? arr[arr.length - i] : 0;\n    let sum = add1 + add2;\n    if (sum >= 10) {\n      res[res.length - i] = sum % 10;\n      if (res.length - i - 1 >= 0) res[res.length - i - 1] += 1;\n      else res.unshift(1);\n    } else {\n      res[res.length - i] = sum;\n    }\n    i++;\n  }\n  return res;  \n};\n````\n时间复杂度：O(n), n为num和k长度较长的那个\n\n空间复杂度：O(n), n为k的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SnowBallBears":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916612816","body":"## **题目**\n989. Add to Array-Form of Integer\n\n## **思路**\n\nPretty straightforward thoughts, adding up an array and a number, use carry and another array to take care of the all cases.\n\n## **代码**\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        \n        for i in range(len(num)-1,-1,-1):\n            curr = num[i] + k%10 + carry\n            k = k//10\n            carry = curr//10     \n            num[i] = curr % 10\n    \n        k = k + carry\n        prenum = []\n        \n        while(k>0):\n            prenum.insert(0, k%10)\n            k = k//10\n        \n        return prenum + num\n        \n```\n\n## **复杂度**\n\nSpace: O(max(1, K-N))\nTime: O(N + max(0,(K-N)^2)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BlueRui":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916613826","body":"# Algorithm\nI use a more general approach to handle cases when k is longer than num, and when overflow may happen.\n1. Convert k to an array of digits\n2. Iterate from the lowest digit to highest one to add num[i] and k[i]. Get the sum of num[i], k[i] and carry. Add sum % 10 to list, and set sum / 10 to the new value of carry. End iteration when we reach the length of the shorter one of num and k\n3. Iterate over the remaining length of num or k in the same way. \n\n# Complexity\n* Time complexity: O(max(num.length, k.length)) \n* Space complexity: O(max(num.length, k.length))\n\n# Code\nLanguage: Java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        \n        char[] kDigits = Integer.toString(k).toCharArray();\n        int[] numK = new int[kDigits.length];\n        for (int i = 0; i < kDigits.length; i++) {\n            numK[i] = kDigits[i] - '0';\n        }        \n        \n        int carry = 0;\n        int index = 0;\n        while (index < num.length && index < numK.length) {\n            int sum = num[num.length - 1 - index] + numK[numK.length - 1 - index] + carry;\n            result.add(sum % 10);\n            carry = sum / 10;\n            index++;\n        }\n        \n        while (index < num.length) {\n            int sum = num[num.length - 1 - index] + carry;\n            result.add(sum % 10);\n            carry = sum / 10;\n            index++;\n        }\n        \n        while (index < numK.length) {\n            int sum = numK[numK.length - 1 - index] + carry;\n            result.add(sum % 10);\n            carry = sum / 10;\n            index++;\n        }\n        \n        if (carry != 0) {\n            result.add(carry);\n        }\n        \n        Collections.reverse(result);\n        return result;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doveshnnqkl":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916614606","body":"# 思路\n* 从末尾开始遍历数组，最后一位与k最后一位相加，将K除以10取整，有进位加进位，循环\n* 数组遍历完  k还大于0，将k取余放入List, k除以10取整，循环\n* * *\n# 代码\n* 语言：Java\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       LinkedList<Integer> ret = new LinkedList();\n       int index  = 0 ;\n       for(int i = num.length - 1; i >= 0 ; i--){\n          int   sum =  num[i];\n         \n                sum +=  k % 10 + index;\n                 k = k/10;\n          \n          if(sum >= 10){\n              sum =  sum - 10;\n              k++;\n          }\n          ret.addFirst(sum);\n       }\n       while(k > 0){\n           ret.addFirst(k%10);\n           k = k/10;\n       }\n     \n       return ret;\n    }\n}\n```\n* * *\n# 复杂度\n* 时间复杂度O(n)\n* 空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916615519","body":"# Understand:\n```\n1 <= num.length <= 10^4\n0 <= num[i] <= 9\nnum does not contain any leading zeros except for the zero itself.\n1 <= k <= 10^4\n\nmost significant -> least significant digit\n```\n\n# Plan: \n```\ngo backward, track carry and sum for the current digit\nuse LinkedList for result\n```\n\n# Review:\n```\nnum = [9, 9, 9], k = 1 -> 1000\n\n999\n  1\n \n1000\n\nnum = [1], k = 999\n\n  1\n999\n\n\nnum = [1], k = 9\n```\n\n# Evaluate:\n```\nm = num.length, n = number of digits in k, log(10)k\n\nTime: O(max(m, n))\n\nSpace: O(max(m, n)) for the output list\n```\n\n# Code: \n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> sum = new LinkedList<>();\n        int carry = 0, curDigit = 0;\n        \n        for (int i = num.length - 1; i >= 0; i--) {\n            curDigit = k % 10 + num[i] + carry;\n            carry = curDigit / 10;\n            curDigit = curDigit % 10;\n            k /= 10;\n            sum.addFirst(curDigit);\n        }\n        \n        while (k > 0) {\n            curDigit = k % 10 + carry;\n            carry = curDigit / 10;\n            curDigit = curDigit % 10;\n            k /= 10;\n            sum.addFirst(curDigit);\n        }\n        \n        if (carry == 1) {\n            sum.addFirst(carry);\n        }\n        \n        return sum;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuWF":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916616395","body":"- convert num to int\n- add num to k\n- iterate through total by making it a string, add to res list\n- time complexity: O(N), N is the num list length\n- space complexity: O(M), M is the num list length\n\n\n\nCode:\n\n```python\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n    total = 0\n    index = 0\n    \n    for n in num[::-1]:\n        total += (10 ** index) * n\n        index += 1\n    \n    total += k\n    \n    res = []\n    for digit in str(total):\n        res.append(int(digit))\n    \n    return res\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JoeyChengTor":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916620734","body":"### 思路\n\n从数组最后一位到第一位进行遍历, 每次与 k % 10 和 carry 相加, carry = k // 10\n\n每次加完 i 往前退一位, k // 10\n\n所有数组里的数加完有两种情况\n\n1. k 还有剩余\n2. carry 还有剩余\n\n因为 carry 也是加在 k 的最后一位, 所以 k = k + carry 一起处理\n\n每次向数组前面添加 k % 10, 之后 k 取 k // 10\n\n### 代码\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        carry = 0\n        # reverse loop through num and add with each digit of k\n        for i in range(len(num) - 1, -1, -1):\n            val = carry + num[i] + k % 10\n            carry, num[i] = val // 10, val % 10\n            k = k // 10\n        \n        # if there's carry or k left need to add to front of array\n        k = carry + k\n        \n        while k > 0:\n            num = [k % 10] + num\n            k = k // 10\n\n        return num\n```\n\n\n\n### 复杂度\n\n时间复杂度: O(n) 遍历数组\n\n空间复杂度: O(1) 不使用额外空间\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ForLittleBeauty":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916622948","body":"## 思路\n\n***\n\n将给定的list反转后遍历，遍历的每一位与k的最低位，进位数相加，记录进位，并把个位加入最终的结果数组。之后更新k。有两种情况：\n\n- list遍历完了k还有值，那么后面继续把k没用完的位数加入结果数组，这样总体时间复杂度由logk决定\n- k先到0，list还没遍历完，那么其实继续遍历list，并不需要做任何处理，因为k一直是0，相当于每次把list新的一位添加到最终结果数组后面\n\n最后判断一下进位数是否还有值即可。\n\n***\n\n## 代码\n\n***\n\n\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        result = []\n        carry = 0\n        for digit in num[::-1]:\n            temp = digit+k%10+carry\n            k=k//10 #下一轮的k值\n            carry = temp//10 #下一轮的进位\n            temp = temp%10 #当前这一位数\n            result.append(temp)\n\n        #如果k还没耗尽的话\n        while k>0:\n            temp = k%10+carry\n            k=k//10\n            carry = temp//10\n            temp = temp%10\n            result.append(temp)\n        \n        #如果进位值还没耗尽的话\n        if carry>0:\n            result.append(carry)\n        \n        return result[::-1]\n```\n\n\n\n***\n\n时间复杂度: O(max(logk,n))\n\n空间复杂度: O(1)\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"septasset":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916623473","body":"### **思路**\n\n1. 观察到A最大为10^10000,远超出long上限，因此不可把A转成数字后与k相加再写入结果数组\n2. 模拟手算，使用carry进位\n\n### **关键点**\n\n1. 从整数k中取出倒数第i位数字: k % (int)Math.pow(10, (i+1)) / (int)Math.pow(10, i)\n2. 循环次数取决于A,k中较大数的位数\n\n### **代码(Java)**\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> sumList = new LinkedList<Integer>();\n    Boolean carry = false;\n    int noDigits = Math.max(num.length, Integer.toString(k).length());\n    for (int i = 0; i<noDigits; ++i){\n        int k_digit = k % (int)Math.pow(10, (i+1)) / (int)Math.pow(10, i);\n        int num_digit = i<=num.length-1? num[num.length-1-i]:0;\n\n        int res = carry? k_digit + num_digit + 1 : k_digit + num_digit;\n        if (res>9){\n            res = res - 10;\n            carry = true;\n        }else{\n            carry = false;\n        }\n        sumList.add(0, res);\n    }\n    if (carry) sumList.add(0, 1);\n    return sumList;\n\n}\n```\n\n### **复杂度分析**\n\nm,n为A,k的位数时:\n\n- 时间：O（max(m,n)）\n- 空间：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DoubleW2w":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916623658","body":"## 思路\n\n1. 当前位 = `(carry + a + b) % 10` \n2. 进位处理： 当前位 % 10\n3. 调整： `k /= 10`  \n4. 最后要判断是否还有进位  `215 + 806 = 1021`  多了一位  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<>();\n        int i = num.length - 1;\n        int carry = 0, sum = 0;\n        while(i>=0 || k > 0){\n            int a = i>=0 ? num[i] : 0;\n            int b = k!=0 ? k%10: 0;\n\n            //得到和\n            sum = carry + a + b;\n\n            //得到进位\n            carry = sum / 10;\n\n            //得到当前位\n            sum %= 10;\n\n            //调整两个加数\n            k /= 10;\n            i--;\n            ans.add(sum);\n        }\n        if(carry != 0) ans.add(carry);\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(max(n,logk))\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"WeilanTao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916628293","body":"### 989 Easy\n\n### 思路\n\n这道题是一个模拟计算的题目。首先想到用一个变量carry来记录进位。获得个位：n%10；获得其他：n/0\n\n用一个while loop 遍历所有--只要`carry` 或 `num[]`或 `k` 没有用完， while loop 就对 carry 进行迭代, 并将此次迭代结果的个位存入结果集合`res`。\n\n在 Java 集合中选择 LinkedList 来储存结果，因为 Java 中 `LinkedList` 提供了接口 `addFirst()`。 LinkedList 在头尾插入复杂度都是O(1)。 若采用ArrayList 则需要调用接口`add(0, nums[i])` 或`Collections.reverse()` ； 相比之下都会降低性能。\n\n### 代码 Java\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        \n        int carry = 0;\n        \n        int len = num.length;\n        int i  =len-1;\n\n        LinkedList<Integer> res = new LinkedList<>();\n        \n        while(carry != 0  || k > 0 || i >= 0 ){\n         \n            if(i>=0){\n                carry += num[i];\n                i--;\n            }\n            \n            if(k>0){\n                int a = k%10;\n                carry+=a;\n                k=(k-a)/10;\n            }\n            \n            res.addFirst(carry % 10);\n            carry = carry/10;\n\n        }\n        \n        return res;\n    }\n}\n```\n\nRuntime: 2 ms, faster than 99.68% of Java online submissions for Add to Array-Form of Integer.\n\nMemory Usage: 41.2 MB, less than 35.41% of Java online submissions for Add to Array-Form of Integer.\n\n### 复杂度分析\n\n时间复杂度：O(max(nums[], k)+1) =>O(n)\n\n空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kennyxcao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916629214","body":"# 989. Add to Array-Form of Integer\r\n\r\n## Intuition\r\n\r\n1. Start from least significant digit in num and current sum as k.\r\n2. Compute digit sum at each position from right to left.\r\n3. Push least significant digit to the answer array.\r\n4. Shift current sum to right by 1 position.\r\n5. Repeat until all digits in both num and k are processed.\r\n6. Reverse the answer array for the final output.\r\n\r\n## Code\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nconst addToArrayForm = function(num, k) {\r\n  const n = num.length;\r\n  const ans = [];\r\n  let curr = k;\r\n  let i = n - 1;\r\n  while (i >= 0 || curr > 0) {\r\n    if (i >= 0) {\r\n      curr += num[i];\r\n    }\r\n    ans.push(curr % 10);\r\n    curr = ~~(curr / 10);\r\n    i -= 1;\r\n  }\r\n  return ans.reverse();\r\n};\r\n```\r\n\r\n## Complexity Analysis\r\n\r\n- Time: O(max(N, K))\r\n- Space: O(max(N, K)) for answer array\r\n- N = len(num)\r\n- K = len(k)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james20141606":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916632276","body":"# Day 1 989. Add to Array-Form of Integer\n\n- Problem Link\n  - [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/submissions/)\n  - Other useful links:\n\n\n- Ideas\n  - convert list to string, then to int, add with k, convert back to list. \n- Complexity: \n  - Time: O(num.length)\n  - Space: O(num.length)\n\n- Code\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_str = ''.join([str(i) for i in num])\n        sum = int(num_str) + k\n        return [int(i) for i in str(sum)]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"muimi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916632424","body":"### 思路\n从后向前（从个位开始）遍历数组num，依次和K相加。\n\n相加的结果：个位数部分（取余）保存在返回结果里；十位之上部分（取模）作为新的K。\n\n当数组全部遍历之后，K不等于0时，将K的每一位插入结果的头部。\n\n生成结果时，每次插入都是0号位，使用LinkedList而不是ArrayList是为了获得更好的插入效率。\n\n### 代码\n\n```java\nclass Solution {\n  public List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> res = new LinkedList<>();\n    for (int i = num.length - 1; i >= 0; i--) {\n      res.add(0, (num[i] + k) % 10);\n      k = (num[i] + k) / 10;\n    }\n    while (k > 0) {\n      res.add(0, k % 10);\n      k /= 10;\n    }\n    return res;\n  }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N), 确切地说是max(N, log10(K))\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Mahalasu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916633989","body":"### 思路\r\n从后往前遍历，每一位都和k相加取个位，其他位继续与更前面的数字相加。如果遍历一边之后k仍大于0，说明所得结果位数大于num的长度，则将k中所有位的数字变成一个新的数组然后与num进行连接合并。\r\n\r\n##\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for idx in range(len(num) - 1, -1, -1):\r\n            temp = num[idx] + k\r\n            k = temp // 10\r\n            num[idx] = temp % 10\r\n        \r\n        if k:\r\n            return [int(i) for i in str(k)] + num\r\n        else:\r\n            return num\r\n```\r\n##\r\nTime: O(max(n, k))\r\nSpace: O(max(n, k))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZETAVI":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916634607","body":"## 思路\r\n\r\n从Num数组的**右侧开始往左遍历**数组,将遍历到的数**直接与K相加**,相加的结果取**最低位**插入到List输出链表的**头部**\r\n\r\n## 语言\r\n\r\nJava\r\n\r\n## 代码\r\n\r\n```java\r\npublic class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList<>();\r\n        int i;\r\n        for (i = num.length - 1; k > 0 || i >= 0; k /= 10, i--) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            list.add(0, k % 10);\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:\t$O(max(num.length(),logK))$\r\n\r\n​\t\t\t\t\t\t\t时间复杂度跟输入Num的长度和K的位数有关,又因为List的插入时间复杂度为$O(1)$所以插入可以忽略不计.\r\n\r\n- 额外空间复杂度: $O(1)$\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crystallili":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916642169","body":"### 思路\n把k当作carry 从num的末位开始做加法（做余），不断update k（做除）做为新的carry。最后判断k是否为0，不是为0就用相同方法把k的值放到linkedlist中。\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        for (int i = num.length-1; i>=0; i--) {\n            ans.add(0, (num[i]+k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k > 0) {\n            ans.add(0, k % 10);\n            k = k / 10;\n        }\n        return ans;\n    }\n}\n```\n### 复杂度\n- 空间只要生成linkedlist就行，所以是O(n)\n- 时间的话，因为一直insert在头部，所以每次是o(1), 做n次，所以也是o(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"benngfour":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916643778","body":"### 思路\r\n\r\n從 Array 尾部開始相加，然後計算剩下的；最後檢查 carryOver 的數字\r\n\r\n### 語言\r\n\r\nJavaScript\r\n\r\n### Code Solution\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let result = [];\r\n    let carryOver = 0;\r\n    const arrK = k.toString().split('');\r\n    let numLen = num.length;\r\n    let kLen = arrK.length;\r\n    if (kLen >= numLen) {\r\n        for (let j = numLen - 1; j >= 0; j--) {\r\n                let kNum = Number(arrK[kLen - 1]);\r\n                let sum = kNum + num[j] + carryOver;\r\n                if (sum < 10) {\r\n                    result.push(sum);\r\n                    carryOver = 0;\r\n                } else {\r\n                    result.push(sum - 10);\r\n                    carryOver = 1;\r\n                }\r\n                kLen--;\r\n        }\r\n        for (let i = kLen - 1; i >= 0; i--) {\r\n            let kNum = Number(arrK[i]);\r\n            if (kNum + carryOver >= 10) {\r\n                result.push((kNum + carryOver) - 10);\r\n                carryOver = 1;\r\n            } else {\r\n                result.push(kNum + carryOver);\r\n                carryOver = 0;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = kLen - 1; i >= 0; i--) {\r\n            let kNum = Number(arrK[i]);\r\n                let sum = kNum + num[numLen - 1] + carryOver;\r\n                if (sum < 10) {\r\n                    result.push(sum);\r\n                    carryOver = 0;\r\n                } else {\r\n                    result.push(sum - 10);\r\n                    carryOver = 1;\r\n                }\r\n            numLen--;\r\n        }\r\n        for (let j = numLen - 1; j >= 0; j--) {\r\n            if (num[j] + carryOver >= 10) {\r\n                result.push((num[j] + carryOver) - 10);\r\n                carryOver = 1;\r\n            } else {\r\n                result.push(num[j] + carryOver);\r\n                carryOver = 0;\r\n            }\r\n        }\r\n\r\n    }\r\n    if (carryOver > 0) {\r\n        result.push(1);\r\n    }\r\n    return result.reverse();\r\n};\r\n```\r\n\r\n### 複雜度分析\r\n\r\n- 時間複雜度 O(N): 沒有 nested for loop， 時間取決於最大的那個 Array length\r\n- 空間複雜度 O(1): 只佔用 result array","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ergwang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916643891","body":"### 思路\r\n\r\n1. 看到题首先想到，变成整数然后直接加再变成数组返回，然后觉得要数组—整数—数组，要遍历两次，肯定时间复杂度高，**倒是没想到整数超范围，看了大家评论才发现**\r\n2. 然后想到直接从末尾加，满十进位就行，准备开整，看了题目给的返回值类型是list，又给提醒了，数组直接进位会出现溢出的情况\r\n3. List搞起来，跑通了，发现还要逆序，用到了Collections.reverse(list);  成了（相当于又遍历了一次）。用时超过38%的人，肯定不完美\r\n4. 去评论区找到了LinkedList ，直接调用双向链表的addFirst，一次遍历出结果，舒服了。\r\n\r\n\r\n\r\n\r\n\r\n### 代码\r\n\r\n\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        int over;\r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            // 获取进位值\r\n            over = (num[i] + k) / 10;\r\n            // 得当当前位的值\r\n            num[i] = (num[i] + k) % 10;\r\n            k = over;\r\n            list.addFirst(num[i]);\r\n        }\r\n        // 数组遍历完了，可能进位值是大于0，甚至大于十、百、千，继续进位\r\n        while (k > 0){\r\n            list.addFirst(k % 10);\r\n            k = k / 10;\r\n        }\r\n        return list;\r\n    }\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n—  时间复杂度：O(n)，其中n为数组长度。\r\n\r\n—  空间复杂度：O(n)，新建了一个链表","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"A-PolarBear":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916649889","body":"### 思路\n逐位相加，并通过carry保存进位。需要注意K和num的长度关系。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int len = num.size();\n        int carry = 0;\n        int temp = 0;\n        int i=len-1;\n        while(i>=0||k!=0){\n            int A = i>=0?num[i]:0;\n            temp = A +k%10+carry;\n            carry = temp/10;\n            res.push_back(temp%10);\n            k/=10;\n            i--;\n        }\n        if(carry > 0){\n            res.push_back(carry);\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mixtureve":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916652757","body":"思路：把 k 分成单个的数位，和 nums 的各个数字从后往前依次两两相加，同时注意进位\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> listK = new LinkedList<>();\r\n        int kIdx = 3;\r\n        while (k > 0) {\r\n            int digit = k % 10;\r\n            k = k / 10;\r\n            listK.add(0, digit);\r\n        }\r\n        int carryOver = 0;\r\n        int i = num.length - 1;\r\n        int j = listK.size() - 1;\r\n        List<Integer> result = new LinkedList<>();\r\n\r\n        while (i >= 0 || j >= 0) {\r\n\r\n            int a = i >= 0? num[i]: 0;\r\n            int b = j >= 0? listK.get(j): 0;\r\n\r\n            int curDigit = a + b + carryOver;\r\n\r\n            if (curDigit >= 10) {\r\n                carryOver = 1;\r\n            } else {\r\n                carryOver = 0;\r\n            }\r\n\r\n            result.add(0, curDigit % 10);\r\n             i--;\r\n            j--;\r\n        }\r\n\r\n        if (carryOver == 1) {\r\n            result.add(0, 1);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}`\r\nspace complexity: O(X) X指k的位数\r\ntime complexity: O(max(n, X))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freedom0123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916654651","body":"#  989、数组形式的整数加法\n\n## 思路\n\n本质上就是 手动模拟加法的过程\n\n这种思路同时适用于高精度加法\n\n```java\nclass Solution {\n    List<Integer> res = new ArrayList();\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> resTem = new ArrayList<>() ;\n        List<Integer> res  =new ArrayList<>();\n        int i = num.length-1;\n        int tem  = 0;//用来表示进位\n        while(i>=0 || k!=0){\n            if(i>=0){\n                tem+=num[i];\n                i--;\n            }\n            if(k!=0){\n                tem+=(k%10);\n                k= k/10;\n            }\n            resTem.add(tem%10);\n            tem = tem/10;\n        }\n        if(tem>0){\n            resTem.add(tem);\n        }\n        //最后将res 倒叙输出\n        for(int j  = resTem.size()-1;j>=0;j--){\n            res.add(resTem.get(j));\n        }\n        return  res;\n    }\n\n}\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leolisgit":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916654773","body":"### 思路\n1. 看到这道题，想到一个类似的题目，是两个list相加。然后有点类似于merge sort中merge这一步。\n从末尾一直加到开头，如果有一个数组没有到头，就加到结果上。这种方法可以做，但是写起来比较繁琐，因为需要把int转化为数组先。\n2. 因为数据范围限制，没有办法把int 数组转换为数值相加。\n3. 其实每次我们只需要求得该位的余数即可。这样可以直接把k拿来用。使用k和数组每一位求和，取余数，然后除以10。这样就可以得到每一位的余数。\n需要注意如果最后和不为0，需要把每一位取出加入list中。\n\n### 代码\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        \n        int sum = k;\n        for (int i = num.length - 1; i >= 0; i--) {\n            sum += num[i];\n            list.add(0, sum % 10);\n            sum /= 10;\n        }\n        \n        while (sum > 0) {\n            list.add(0, sum % 10);\n            sum /= 10;\n        }\n        \n        return list;\n    }\n}\n```\n\n### 复杂度分析\n时间：O(N)  \n空间：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuliangyu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916655204","body":"'''\r\nGiven: array form number\r\nreturn: array form number + k \r\n\r\nsample: \r\nnum = [1,2,0,0], k = 34\r\n1200 + 34 = 1234\r\n[1, 2, 3, 4]\r\n\r\n1: \r\ngenerate a integer from array form\r\n[1, 2, 0, 0] => 1200\r\n''\r\n'1'\r\n'12'\r\n'120'\r\n'1200'\r\n\r\n2: k added\r\n1200 + 34 = 1234\r\n\r\n3.\r\nfn generateForm(1234) => return [1, 2, 3, 4]\r\n1234 % 10 = 4 \r\nappend to list res [4]\r\n\r\n1234 // 10 = 123\r\n123 % 10 = 3\r\n[4, 3]\r\n123 // 10 = 12\r\n...\r\n[4, 3, 2]\r\n[4, 3, 2, 1]\r\n\r\n4. \r\nreverse list !!!!\r\n[4, 3, 2, 1] => [1, 2, 3, 4]\r\n\r\ntime O(n)\r\nspace O(n)\r\n\r\n'''\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        if not num: return []\r\n        if k == 0: return num\r\n        \r\n        s = ''\r\n        for ele in num: \r\n            s = s + str(ele)\r\n        newNums = int(s) + k\r\n\r\n        res = self.generateForm(newNums)\r\n        return res[::-1]\r\n    \r\n    def generateForm(self, nums):\r\n        res = []\r\n        while nums:\r\n            digit = nums % 10\r\n            res.append(digit)\r\n            nums = nums // 10\r\n        \r\n        return res\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kirito1017":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916655676","body":"## 思路 \n###### 从最后一位 一位一位往上相加 并考虑是否有carry 如果长短不一样也没关系 判断一下就行。如果while loop结束后考虑下是否要最后append一个carry \n###### 每次都insert到第一个元素\n\n## 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] nums, int k) {\n        List<Integer> res = new ArrayList<>();\n        int i = nums.length - 1;\n        int carry = 0;\n        while (i >= 0 || k > 0) {\n            int two = k > 0 ? k % 10 : 0;\n            int one = i >= 0 ? nums[i] : 0;\n            int total = two + one + carry;\n            \n            carry = total / 10;\n            res.add(0, total % 10);\n            \n            i--;\n            k = k / 10;\n        }\n        \n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```\n## 复杂度\n###### 时间复杂度O(n), 空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"FullStackH":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916657808","body":"# 思路\n逐位相加，carry保存进位\n\n# 代码\n\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    int len = num.length;\n    int count = 0;\n    int flag = 0;\n    List<Integer> ans = new ArrayList<>();\n    while (k > 0) {\n        int tmpNum = len - count - 1 < 0 ? 0: num[len - count - 1];\n        int sum = k % 10 + tmpNum + flag;\n        flag = sum / 10;\n        k /= 10;\n        count++;\n        ans.add(flag == 1 ? sum % 10 : sum);\n    }\n    for(int i = len - count - 1; i > -1; i--) {\n        int sum = num[i] + flag;\n        flag = sum / 10;\n        ans.add(flag == 1 ? sum % 10 : sum);\n    }\n    if (flag == 1) {\n        ans.add(1);\n    }\n    Collections.reverse(ans);\n    return ans;\n}\n\n# 复杂度\n时间复杂度O(n)\n空间复杂度O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chun1hao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916659493","body":"```js\nvar addToArrayForm = function (num, k) {\n  let idx = num.length - 1;\n  let c = 0;\n  while (c || k) {\n    let curK = k % 10;\n    let curNum = idx >= 0 ? num[idx] : 0;\n    let sum = c + curK + curNum;\n    c = Math.floor(sum / 10);\n    sum %= 10;\n    if (idx >= 0) {\n      num[idx--] = sum;\n    } else {\n      num.unshift(sum);\n    }\n    k = Math.floor(k / 10);\n  }\n  return num;\n};\n```\n\n时间：O(N)\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"m-z-w":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916661368","body":"```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let newArr = []\r\n    let numK = String(k).split('')\r\n    let maxLen = Math.max(num.length, numK.length)\r\n    let flag = 0\r\n    let cur = 0\r\n    while (cur < maxLen) {\r\n        console.log(cur)\r\n        if (num[cur] === undefined) {\r\n            num.unshift(0)\r\n        }\r\n        if (numK[cur] === undefined) {\r\n            numK.unshift(0)\r\n        } else {\r\n            numK[cur] = Number(numK[cur])\r\n        }\r\n        cur++\r\n    }\r\n    for (let i = maxLen - 1; i >= 0; i--) {\r\n         let n = num[i] + numK[i] + flag\r\n        flag = n >= 10 ? 1 : 0\r\n        n = n >= 10 ? n - 10 : n\r\n        newArr.unshift(n)\r\n    }\r\n    if (flag === 1) {\r\n        newArr.unshift(1)\r\n    }\r\n    return newArr\r\n};\r\n```\r\n时间：O(n)\r\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"KennethAlgol":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916664966","body":"思路: 将整个加数 k加入数组表示的数的最低位\n\n    class Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<Integer>();\n            int n = num.length;\n            for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n                if (i >= 0) {\n                    k += num[i];\n                }\n                res.add(k % 10);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n\n复杂度分析\n\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Richard-LYF":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916665554","body":"def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n=0\n        for i in range(len(num)):\n            n=n*10+num[i]\n        n=str(n+k)\n        out=[]\n        for i in n:\n            out.append(int(i))\n        return out\n\n分享一个自己的思路，代码比较短，容易理解，但是好像用时和内存消耗没有很优秀\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinmenghan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916667562","body":"\n## 题目地址()\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n\n## 题目描述\n\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<Integer>();\n        for (int i = num.length - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            list.add(k % 10);\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lxy030988":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916671424","body":"# 思路\n\n- 从末尾开始循环逐个相加，把结果存到一个数组里\n- 返回 翻转的数组\n\n# 代码 js\n\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  let len = num.length,\n    res = [],\n    next = 0,\n    ks = k.toString().split('').map(Number),\n    klen = ks.length,\n    maxlen = len > klen ? len : klen\n\n  for (let i = 0; i < maxlen; i++) {\n    let cur = num[len - 1 - i] || 0,\n      kcur = ks[klen - 1 - i] || 0\n\n    cur = cur + kcur + next\n    next = parseInt(cur / 10)\n    cur = cur % 10\n\n    res.push(cur)\n  }\n\n  if (next > 0) {\n    res.push(next)\n  }\n\n  return res.reverse()\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n) 数组的长度\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"52HzEcho":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916675882","body":"#### 思路：类型转换\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n    return String(BigInt(num.join('')) + BigInt(k)).split('')\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HarryPangPang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916676513","body":"地位到高位逐位相加，最后的时候需要判断是否溢出\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\n var addToArrayForm = function(num, k) {\n    let res = []\n    let n = num.length\n    for(let i=n-1;i >=0; i--){\n        let sum = num[i]+ k%10\n        k = Math.floor(k/10)\n        if(sum>=10){\n            k++\n            sum -= 10\n        }\n        res.push(sum)\n    }\n\tfor(; k>0;k= Math.floor(k/10)){\n\t\tres.push(k%10)\n\t}\n    res.reverse()\n    return res\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iamtheUsername":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916676823","body":"### 思路\n\n```markdown\n1.由低位到高位逐位相加\n2.进行取余和整数除法\n3.判断进位是否大于0\n```\n\n### 代码(CPP)\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> array;\n\n        for(int i = num.size()-1;i >= 0;i --){\n            int r = num[i] + k;\n            array.push_back(r % 10);\n            k = r / 10;\n        }\n        //判断进位值\n        while(k > 0){\n            array.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(array.begin(),array.end());\n        return array;\n    }\n};\n```\n\n#### 复杂度分析\n\n$$\n时间复杂度：O(n)\n$$\n\n$$\n空间复杂度：O(n)\n$$\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HondryTravis":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916681677","body":"## 思路\r\n\r\n已知 k 不是 bigint 的情况下\r\n\r\n1. 通过对 k 不断累加 nums 的低位来维护 k\r\n2. 通过对 k 不断求模得到当前位，不断求商得到进位，维护 k 即可\r\n\r\n### 代码[javascirpt] Q & A\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n  const { floor } = Math\r\n  const n = num.length, ret = []\r\n\r\n  let i = n - 1\r\n\r\n  while (i >= 0 || k) {\r\n      // 出现 undefined 就要进位默认值 0\r\n      // num: [0], k = 23\r\n      k += (num[i] || 0)\r\n      ret.push(k % 10)\r\n      k = floor(k / 10)\r\n      i--\r\n  }\r\n\r\n  return ret.reverse()\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Abby-xu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916682817","body":"### 思路\n\n- 列表转换为整数\n- 数字相加\n- 数字拆分成列表\n\n### 代码 （Python）\n\n~~~python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        if num == [0] and k == 0: return [0] \n        x = 0\n        out = []\n        for i in num:\n            x = x*10 + i \n        x += k\n        while x > 0:\n            out.append(x % 10)\n            x //= 10\n        return out[::-1]\n~~~\n\n### 复杂度\n\nTime: $O(n)$\n\nSpace: $O(n)$\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwpanda":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916683150","body":"**思路:**\n\nNumber和String的类型转换\n\n\n**代码：JavaScript**\n\n\n```\nconst addToArrayForm = (numArr, k) => {\n    if (numArr.length < 1) return [];\n​\n    //convert numArr to string integer\n    let numArrString = numArr.join('');\n  // convert the string integer into number\n    let num = BigInt(numArrString)+BigInt(k);\n​\n  //convert the number to array of strings\n    let strArr = num.toString().split('');\n  \n  //convert it back to integer\n    return strArr.map(i=>parseInt(i));\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Nina1031":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916683771","body":"# 思路\n\n数组变为整数，求和，变为数组\n变整数 int(), 'sep'.join(str)\n变数组[int()]\n遍历数组 for item in list\n\n# 代码\n\n```python\nclass Solution(object):\ndef addToArrayForm(self, num, k):\n\"\"\"\n:type num: List[int]\n:type k: int\n:rtype: List[int]\n\"\"\"\np = int(''.join(str(item) for item in num)) # num为int array，需2str\nsum = p+k\nreturn [int(i) for i in str(sum)]\n```\n\n# 复杂度\n\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n空间复杂度用来估量程序运行时占用的临时空间大小，此问题中，占用内存取决于数组长度\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fengchen321":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916689310","body":"# 思路\r\n参考题解\r\n从低位到高位计算，将数组低位与K值求和依次得到末位进行前向插入得到result。\r\n考虑k值太大，K值高位需再同一处理插入result\r\n# 代码\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int K) {\r\n        vector<int> result;\r\n        for (int i = A.size() - 1; i >= 0; i --) {\r\n            int num = A[i];\r\n            K += num; //得到末位和\r\n            int remind = K % 10;\r\n            result.insert(result.begin(), remind);  \r\n            K /= 10;\r\n        }\r\n        if (K) {\r\n            while (K > 9) { //如果K 比较大，那么此时还需要把K循环放进去\r\n                int remind = K % 10;\r\n                result.insert(result.begin(), remind);\r\n                K /= 10;\r\n            }\r\n            result.insert(result.begin(), K);\r\n        }\r\n        return result;\r\n\r\n    }\r\n}; \r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n )\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maqianxiong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916690979","body":"### 思路\n\n逐位相加，从最低位加到最高位，若是大于10，进位\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for(int i = n-1;i >= 0;i--){\n            int sum  = num[i] + k%10;\n            k/=10;\n            if(sum >=10){\n                k++;\n                sum -=10;\n            }\n            res.add(sum);\n        }\n        while(k > 0){\n            res.add(k%10);\n            k/=10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(maxlength(num,k))$\n- 空间复杂度 $O(1)$\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Menglin-l":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916691806","body":"### 思路\r\n---\r\n从低位往高位做加法，为避免最后结果需要反转，可选用LinkedList存储数字。\r\n\r\n### 代码\r\n---\r\n```Java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int leng = num.length - 1;\r\n\r\n        while (leng >= 0 || k != 0) {\r\n\r\n            if (leng >= 0) {\r\n                k += num[leng];\r\n                leng--;\r\n            }\r\n\r\n            res.addFirst(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n---\r\nTime: O(max(N, K)), 由数组num长度和数字k的位数两者中的较大值决定\r\n\r\nSpace: O(1), 在原数组中操作，没有额外开销\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hewenyi666":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916699491","body":"## 题目名称\n\n**989. 数组形式的整数加法**\n\n\n### 题目思路\n\n1.将 数字型数组 -> 字符串型数组  \n2.将数组中的字符串拼接, 用eval函数取出字符串中的数字 和 k 取和, 然后转为字符串  \n3.将字符串 -> 数字型的数组\n\n### code for python\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        list_str = [str(i) for i in num]\n        final_str = str(eval(\"\".join(list_str)) + k)\n        return [int(j) for j in final_str]\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JinMing-Gu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916700002","body":"【思路】\r\n要注意给定的数组位数过大时，数据大小超出整型数据范围。\r\n【代码】\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k)\r\n    {\r\n        int n = num.size();\r\n        long long a;\r\n        long long b = 0;\r\n        for(int i = 1; i <= n; i++)\r\n        {\r\n            double m = pow(10, n - i);\r\n            a = num[i - 1] * m;\r\n            b = b + a;\r\n        }\r\n        cout << b << endl;\r\n        cout << k << endl;\r\n        long long c = b + k;\r\n        cout << c << endl;\r\n        num.clear();\r\n        vector<int> rnum;\r\n        while(1)\r\n        {\r\n            if(c >= 10)\r\n            {\r\n                long long d = c % 10;\r\n                rnum.push_back(d);\r\n                c = c - d;\r\n                c = c / 10;\r\n            }\r\n            if(c < 10)\r\n            {\r\n                rnum.push_back(c);\r\n                break;\r\n            }\r\n        }\r\n        vector<int>::reverse_iterator riter;\r\n        for (riter = rnum.rbegin(); riter != rnum.rend(); riter++)\r\n            num.push_back(*riter);\r\n        for(auto it = num.begin(); it != num.end(); it++)\r\n            cout << *it << endl;\r\n        return num;\r\n        // reverse(rnum.begin(), rnum.end());\r\n        // for(auto it = rnum.begin(); it != rnum.end(); it++)\r\n        //     cout << *it << endl;\r\n        // return rnum;\r\n    }\r\n};\r\n```\r\n【复杂度】\r\n\r\n【参考】\r\nhttps://www.cnblogs.com/vranger/p/3502885.html","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Bingbinxu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916700923","body":"**思路**\n将整数K作为移动的部分，不断与A的最后一位叠加，从而更新数组\n注意点：边界条件存在A>=K,和A<K的情况\n**代码**\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size()-1;\n        while(len>=0)\n        {\n            k = k + num[len];\n            num[len] = k % 10;\n            k = k / 10;\n            len--;\n        }\n        while(k>0)\n        {\n            num.insert(num.begin(),0);\n            num[0] = k % 10;\n            k = k /10;\n        }\n        return num;       \n    }\n};\n```\n**复杂度**\n时间复杂度O（N+max（0，K-N））\nwhile函数遍历N遍，若K超过N，还需要遍历K-N遍\n空间复杂度O（N+max（0，K-N））","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flame0409":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916703356","body":"### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n**思路：**\n\n1. 尝试了转整数进行相加后再次转回数组，遇到了越界问题。\n2. 按位相加\n\n**Java代码**\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n       List<Integer> res = new ArrayList<>();\n       for(int i = num.length-1; i >= 0 || k > 0 ; i--){\n           if(i >=0 ){\n               k = k + num[i];\n           }\n           res.add(0,  k % 10);\n           k = k / 10;\n       }\n       return res;\n    }\n```\n\n时间复杂度：*O(max(n,k)*n)*\n\n空间复杂度：*O(1)*\n\n优化：\n\n1.res尾插入，在返回前进行reverse\n\n时间复杂度：O(max(*n*,*k*))\n\n2.使用LinkedList\n\n时间复杂度：O(max(*n*,*k*))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Zhi22":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916705363","body":"# 题目名称：989. 数组形式的整数加法\n## 题目链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer/\n## 思路\n1. 将k转成和num格式一致的数组\n2. 从后向前将两个数组按位相加，并将结果保存至一个新建的数组的末尾，并用变量保存是否进位\n3. 将新建数组逆转并返回\n## 代码\n* python3\n```python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        k_str = str(k)\n        k_arr = []\n        for ch in k_str:\n            k_arr.append(int(ch))\n        addOne = 0\n        ret = []\n        while num or k_arr or addOne:\n            ret.append(0)\n            if k_arr:\n                ret[-1] += k_arr[-1]\n                k_arr.pop()\n            if num:\n                ret[-1] += num[-1]\n                num.pop()\n            ret[-1] += addOne\n            addOne = 1 if ret[-1] > 9 else 0\n            ret[-1] %= 10\n        ret.reverse()\n        return ret\n```\n## 算法复杂度\n- 时间：O(N)\n- 空间：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dongzegithub":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916708579","body":"# [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n## 思路\r\n思路主要体现在加法模板：\r\n1. 和 = A的当前位 + B的当前位 + 进位\r\n2. 当前值 = 和 % 10\r\n3. 进位 = 和 / 10\r\n4. 循环条件： A/B所有位都遍历完成\r\n5. 最后检查一次进位，若不为0，则需要单独加一位\r\n\r\n## 代码\r\n```java\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int i = num.length - 1;\r\n        int carry = 0;\r\n        int sum = 0;\r\n        while (i >= 0 || k > 0) {\r\n            int n = i >= 0 ? num[i] : 0;\r\n            int m = k > 0 ? k % 10 : 0;\r\n            k = k/10;\r\n            i--;\r\n\r\n            sum = n + m + carry;\r\n            carry = sum / 10;\r\n            res.add(sum % 10);\r\n        }\r\n        if (carry != 0) {\r\n            res.add(carry);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```\r\n\r\n## 复杂度分析\r\n**复杂度为O(N)**\r\nwhile循环的复杂度为  `O(n + m)`  \r\n最后反转复杂度为 `O(x/2)` \r\n综合起来算法复杂度为O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916714070","body":"### 思路\r\n两数和按位相加的思路\r\n### js代码\r\n```JavaScript\r\n    let n = num.length-1,carry=0,res=[]\r\n    while(n>=0||k!=0){\r\n        const a = n>=0?num[n]:0\r\n        const b = k!=0?k%10:0\r\n        const sum = a+b+carry\r\n        carry = Math.floor(sum / 10)\r\n        res.push(sum%10)\r\n        n--\r\n        k = Math.floor(k / 10)\r\n    }\r\n    if (carry) res.push(carry)\r\n    return res.reverse()\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n + logk +reverse的长度 )，其中 n 为数组的长度；k以10为底的对数操作次数，来自于reverse的时间消耗\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GReyQT":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916716466","body":"## 思路\r\n直接在数组中相加，标记进位符号，对进位处进行处理\r\n\r\n\r\n## cpp\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n\r\n        bool up = false;    //进位标识符\r\n\r\n        vector<int> numk;\r\n        while (k > 0)\r\n        {\r\n            numk.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        reverse(numk.begin(), numk.end());  //逆转，尾部为个位数\r\n\r\n        vector<int> res;\r\n        num.size() >= numk.size() ? res = num: (res = numk,numk=num);\r\n\r\n        for (auto it = res.rbegin(); it != res.rend(); ++it)    //从个位开始相加\r\n        {\r\n            if (up)\r\n            {\r\n                *(it - 1) %= 10;\r\n                if ((*it += 1) >= 10)\r\n                {\r\n                    up = true;\r\n                }\r\n                else\r\n                {\r\n                    up = false;\r\n                }\r\n                \r\n            }\r\n\r\n            if (numk.size() > 0)\r\n            {\r\n                if ((*it += numk.back()) >= 10) \r\n                {\r\n                    up = true;\r\n                }\r\n\r\n                numk.pop_back();        //尾出\r\n            }\r\n\r\n        }\r\n\r\n\r\n        if (up) //表示头部需要进位\r\n        {\r\n            reverse(res.begin(), res.end());    //将头部置尾\r\n\r\n            auto it = res.end()-1;\r\n\r\n            *it %= 10;  //求余\r\n\r\n            res.push_back(1);   //尾插\r\n\r\n            reverse(res.begin(), res.end());    //恢复\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度分析\r\n-     时间复杂度：O(n + logk +reverse的长度 )，其中 n 为数组的长度；k以10为底的对数操作次数，来自于reverse的时间消耗\r\n-     空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916722801","body":"## 思路\n\n-\t从后往前加，记录进位，注意 k > n 的情况\n\n\n## 代码\n\n\n```\nvector<int> addToArrayForm_0(vector<int> &num, int k)\n{\n    vector<int> res;\n    // 从后往前加，记录进位\n    int flag = 0;\n    int i = num.size() - 1;\n    while(k || (i >= 0))\n    {\n        int tmp;\n        if (i >= 0)\n            tmp = num[i] + k % 10 + flag;\n        else\n        {\n            tmp = k % 10 + flag;\n        }\n        k = k / 10;\n        if(tmp > 9)\n        {\n            tmp = tmp % 10;\n            flag = 1;\n        }\n        else\n        {\n            flag = 0;\n        }\n        res.push_back(tmp);\n        i--;\n    }\n    if (flag)\n        res.push_back(1);\n\n    for (int i = 0; i < res.size() / 2; i++)\n    {\n        int tmp;\n        tmp = res[i];\n        res[i] = res[res.size() - i - 1];\n        res[res.size() - i - 1] = tmp;\n    }\n    return res;\n}\n\n```\n-\t时间复杂度: O(N)，空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Huangxuang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916726896","body":"# 题目：[989. 数组形式的整数加法]([https://leetcode.com/problems/add-to-array-form-of-integer/](https://leetcode.com/problems/add-to-array-form-of-integer/))\r\n\r\n### 思路\r\n\r\n- 如果转换成int在相加会越界\r\n- 先转换成 array 然后再用array 相加\r\n- 今天来不及了，明天改进一下，直接用arry 和数字相加\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        \r\n        //convert K to array type\r\n        ArrayList k_array = intToArray(k);\r\n        //add two arry together and return \r\n        return arraySum (num, k_array);\r\n    }\r\n    \r\n    private ArrayList<Integer> intToArray(int k) {\r\n        ArrayList <Integer> res = new ArrayList();\r\n        if (k == 0) {\r\n            res.add(0);\r\n            return res;\r\n        }\r\n        while (k > 0) {\r\n            int reminder = k % 10;\r\n            res.add(reminder);\r\n            k /= 10;\r\n        }\r\n        //reverse \r\n        ArrayList<Integer> reversed = new ArrayList();\r\n        for (int i = res.size() - 1; i >= 0; i--) {\r\n            reversed.add(res.get(i));\r\n        }\r\n        \r\n        return reversed;\r\n    }\r\n    \r\n    private ArrayList<Integer> arraySum(int[] num, ArrayList<Integer> x) {\r\n        ArrayList<Integer> res = new ArrayList();\r\n        int N = num.length; \r\n        int L = x.size();\r\n        int carray = 0;\r\n        for (int i = 0; i < Math.min(N, L); i++) {\r\n            int sum = num[N - 1 - i] + x.get(L -1 -i)+ carray;\r\n            res.add(sum % 10);\r\n            carray = sum / 10;\r\n            //carray = sum > 9 ? 1 :0;          \r\n        }\r\n        // add all other numbers directly, count carray in \r\n        if (N > L) {\r\n            //num[N - L - 1]  += carray;\r\n            for (int i = N - L - 1; i >= 0; i--) {\r\n                int sum = num[i] + carray;\r\n                res.add(sum % 10);\r\n                carray = sum / 10;\r\n            }\r\n        } \r\n        if (N < L) {\r\n            for (int i = L - N - 1; i >= 0; i--) {\r\n                int sum =  x.get(i) + carray;\r\n                res.add(sum % 10);\r\n                carray = sum / 10;\r\n            }\r\n        }      \r\n        if (carray == 1) {\r\n            res.add(1);\r\n        }\r\n    \r\n        \r\n        Collections.reverse(res);\r\n        return res;\r\n        \r\n    } \r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- \r\n\r\n### attention！\r\n\r\n**int 是2进制的32bit, 10位十进制的数，long是64位，20位10进制的数**","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Wu-zonglin":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916730474","body":"### 思路\n数据类型转换\n### 代码\n~~~ python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sum = int(''.join(map(str, num)))+k\n        return list(map(int,str(sum)))\n~~~\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JAYWX":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916738912","body":"# 思路\nK与num转化为列表  \n准备一个接收列表\n\n两列表同时从末尾往前根据索引取值  \n两值相加的结果c,  \n\n如果 c大于等于10,  \n十位用sum记录，为前一位计算做记录\n\n如果 c小于10，  \nsum记得清零\n\nc的个位加入接收列表\n\n注：循环结束记得把不为0的sum加入接收列表\n\n接收列表末尾为结果首位，最后把列表reverse一次\n\n\n# 代码\n```python\nfrom typing import List\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        A = num\n        a_len = len(A)\n        B = list(int(i) for i in str(k))\n        b_len = len(B)\n        big_num = max(a_len, b_len)\n\n        sum = 0\n        index_sum = 0\n        res = []\n        for i in range(big_num):\n            index_sum -= 1\n            a = 0 if a_len < abs(index_sum) else A[index_sum]\n            b = 0 if b_len < abs(index_sum) else B[index_sum]\n            c = a + b + sum\n            if c >= 10:\n                sum = c // 10 % 10\n                c = c // 1 % 10\n            else:\n                sum = 0\n            res.append(c)\n\n        if sum:\n            res.append(sum)\n\n        res.reverse()\n        return res\n```\n## 复杂度分析\n令 n 为数组长度。\n\n时间复杂度：$O(n)$  \n空间复杂度：$O(n)$  \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowenhe":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916747421","body":"```CPP\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int n = num.size() - 1;\n        int cur = k;\n        vector<int> result;\n        while(n >= 0 || cur)\n        {\n            if(n>=0)\n            {\n                cur = cur + num[n];\n            }\n            result.push_back(cur%10);\n            cur = cur / 10;\n            n--;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n\n    }\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mglslg":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916756192","body":"时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n```java\r\n    /**\r\n     * 先前试图抖机灵将数组转换为数字然后加k再转回来\r\n     * 结果分分钟被测试用例[9,9,9,9,9,9,9,9,9,9]教做人\r\n     * 数组越界，只能乖乖按位相加了哎~~~\r\n     * 技巧：线性表从左向右增长使用Array，从右向左增长使用LinkedList::addFirst\r\n     * 这样就不必使用stack倒来倒去\r\n     */\r\n    class Solution {\r\n        public List<Integer> addToArrayForm(int[] num, int k) {\r\n            if (num.length == 0) {\r\n                return numToList(k);\r\n            }\r\n            LinkedList<Integer> result = new LinkedList<>();\r\n            int carry = 0;\r\n            int size = num.length;\r\n            LinkedList<Integer> kNum = numToList(k);\r\n            while (!kNum.isEmpty()) {\r\n                if (size > 0) {\r\n                    int x = kNum.pollLast() + num[size - 1];\r\n                    result.addFirst((x + carry) % 10);\r\n                    carry = (x + carry) / 10;\r\n                    size--;\r\n                } else {\r\n                    int x = kNum.pollLast();\r\n                    result.addFirst((x + carry) % 10);\r\n                    carry = (x + carry) / 10;\r\n                }\r\n            }\r\n            while (size > 0) {\r\n                int x = num[size - 1];\r\n                result.addFirst((x + carry) % 10);\r\n                carry = (x + carry) / 10;\r\n                size--;\r\n            }\r\n            if (carry > 0) {\r\n                result.addFirst(1);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        private LinkedList<Integer> numToList(int num) {\r\n            LinkedList<Integer> list = new LinkedList<>();\r\n            while (num / 10 > 0) {\r\n                list.addFirst(num % 10);\r\n                num = num / 10;\r\n            }\r\n            list.addFirst(num % 10);\r\n            return list;\r\n        }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HouHao1998":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916760585","body":" public List<Integer> addToArrayForm(int[] num, int k) {\n\t\tList<Integer> sumList =new ArrayList<>();\n    \tif(num.length==1&&num[0]==0&&k==0){\n\t\t\tsumList.add(0);\n    \t\treturn sumList;\n\t\t}\n\t\tList<Integer> kList =new ArrayList<>();\n\t\twhile (k/10!=0){\n\t\t\tkList.add(k%10);\n\t\t\tk = k/10;\n\t\t}\n\t\tkList.add(k%10);\n\t\tint nl =num.length;\n\t\tint[] num2 = new int[nl];\n\t\tfor (int a:num) {\n\t\t\tnum2[--nl]=a;\n\t\t}\n\t\tnl =num.length-1;\n\t\tint kl =kList.size()-1;\n\t\tint go =0;\n\t\tint sun =0;\n\t\tint[] sum;\n\t\tsum =new int[Math.max(nl,kl)+2];\n\t\tfor (int i = 0; i <= Math.max(nl,kl); i++) {\n\t\t\tif(i<=nl&&i<=kl){\n\t\t\t\tsun = kList.get(i)+num2[i]+go;\n\t\t\t}else {\n\t\t\t\tsun = nl>kl?num2[i]+go:kList.get(i)+go;\n\t\t\t}\n\t\t\tsum[i]=sun%10;\n\t\t\tgo=sun/10;\n\t\t}\n\t\tif(go!=0){\n\t\t\tsum[sum.length-1]= go;\n\t\t}\n\n\t\tboolean a= true;\n\t\tfor (int i = sum.length-1; i >=0; i--) {\n\t\t\tif(sum[i]==0&&a){\n\t\t\t\tcontinue;\n\t\t\t}else {\n\t\t\t\ta=false;\n\t\t\t}\n\t\t\tsumList.add(sum[i]);\n\t\t}\n\treturn sumList;\n    }\n## 思路\n把数字变成倒叙数组，数组也直接倒叙，进位相加，再次倒叙\n复杂度分析\n\n数字或数组最长为n\n复杂度O（N）\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AruSeito":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916761326","body":"## 思路\r\n将k拆成数组，按照竖式相加的方式进行每位相加，如果相加和大于等于10，那么当前位取10的余数，前一位进1。如果是最后一位大于10，要在前面进行补加一位。\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  let kArray = k\r\n    .toString()\r\n    .split(\"\")\r\n    .map((kNum) => Number(kNum));\r\n  let flag = false;\r\n  const maxLength = Math.max(num.length, kArray.length);\r\n  while (kArray.length < maxLength) kArray.unshift(0);\r\n  while (num.length < maxLength) num.unshift(0);\r\n  for (let i = maxLength - 1; i >= 0; i--) {\r\n    let tmpSum = num[i] + kArray[i];\r\n    if (tmpSum >= 10) {\r\n      if (i - 1 < 0) {\r\n        flag = true;\r\n        kArray.unshift(0);\r\n      }\r\n      kArray[i - 1 < 0 ? i : i - 1] += 1;\r\n      tmpSum = tmpSum % 10;\r\n    }\r\n    kArray[flag ? i + 1 : i] = tmpSum;\r\n  }\r\n\r\n  return kArray;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(3m-n+Max(m,n))$ m代表k的位数，n代表num的长度，对k进行拆分的时候split是一个m，map又一个m，再两个位数补全的时候是|m-n|\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BreezePython":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916762658","body":"## 思路\r\n\r\n数学题…\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num, k) :\r\n        n = reduce(lambda x, y: x * 10 + y, num) + k\r\n        return [0] if n == 0 else [int(i) for i in str(n)]\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HZHENGZHI":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916763651","body":"**思路** \n模拟手算加法过程。当两数之和小于10，则直接加入到list中，当遇到两数之和大于10的时候，需要将1带入进行运算\n\n**代码**\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> linkedList=new LinkedList<>();\n        int temp=0;\n        for (int i = num.length-1; i >=0; i--) {\n            temp=k%10;\n            k=k/10;\n            if(num[i]+temp>=10)\n            {\n                k++;\n                linkedList.addFirst((temp+num[i])%10);\n            }\n            else\n            {\n                linkedList.addFirst(temp+num[i]);\n            }\n            if(i==0)\n            {\n                while (k!=0)\n                {\n                    temp=k%10;\n                    k=k/10;\n                    linkedList.addFirst(temp);\n                }\n            }\n        }\n        return linkedList;\n    }\n```\n**复杂度分析**\nn为num长度，m为k的长度\n+ 空间复杂度$O(n)$\n+ 空间复杂度$O(max(n,m-n))$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"max-qaq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916766187","body":"## 思路\n\n从个位开始，向高位加\n\n## 关键点\n\n- \n\n## 代码\n\n- \n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        int i = n - 1;\n        int carry = 0;\n        List<Integer> list = new ArrayList<>();\n        while(i>=0 || k > 0){\n            int sum = 0;\n            int num1 = i>=0? num[i] : 0;\n            int num2 = k>0? k%10 : 0;\n            sum = num1 + num2 + carry;\n            carry = sum / 10;\n            list.add(sum % 10);\n            i--; k/=10;\n        }\n        if(carry != 0) list.add(carry);\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916768752","body":"# 思路\n类型转换+数位迭代计算\n\n# 代码\n``` python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:    \n        a_ = ''\n        for i in num:\n            a_ += str(i)\n        a_ = ''.join(a_)\n        sum_result = int(a_) + k\n        \n        res_array = []\n        while(sum_result>0):\n            res_array.insert(0, sum_result%10)\n            sum_result = sum_result // 10\n        if len(res_array) == 0:\n            res_array.append(0)\n        return res_array    \n```\n\n# 复杂度分析\n* 时间复杂度O(N)\n* 空间复杂度O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BpointA":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916771959","body":"### 思路\n模拟竖式的运算。首先将两个数转化为长度相同的数组，再从末位向前计算，依次进位。\n### python3代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        add=[int(i) for i in str(k)]\n        if len(add)>len(num):\n            a=[0]+add\n            b=[0]*(len(add)-len(num)+1)+num\n        else:\n            a=[0]+num\n            b=[0]*(len(num)-len(add)+1)+add\n        res=[0]*len(a)\n        for i in range(len(a)-1,0,-1):\n            k=a[i]+b[i]+res[i]\n            res[i]=k%10\n            res[i-1]=k//10\n        if res[0]==0:\n            return res[1:]\n        return res\n```\n### 复杂度\n时间复杂度：O(n) n为较长数组的长度\n\n空间复杂度：O(n)  n为答案数组的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sxr000511":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916776310","body":"\n\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n \n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n \n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 思路\n模仿加法计算过程，通过商和余数完成进位\n\njs里没整型数据，需要Math.floor()向下取整，要不然`/`得到的是小数\n\n## 关键点\n有几个边界条件要考虑\n\n1. 输入[0] 23 或者  [0],10000---》数组短，数据长，不能在数组结束就跳出循环\n\n```javascript\n        const x = i >= 0 ? A[i] : 0\n        const y = K != 0 ? K % 10 : 0\n```\n2. 输入 [2,1,5],806   ---》最高位有进位，不能跳出循环\n\n```javascript\n if (carry) res.push(carry)\n```\n3. 循环的条件是：(i >=0 || K != 0)，K不为零用来处理数组短的情况\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(A, K) {\n    const res = []\n    let i = A.length - 1, carry = 0\n    while (i >=0 || K != 0) {\n        //处理边界条件\n        const x = i >= 0 ? A[i] : 0\n        const y = K != 0 ? K % 10 : 0\n\n        const sum = x + y + carry\n        res.push(sum % 10)\n        carry = Math.floor(sum / 10)\n\n        i--\n        K = Math.floor(K / 10)\n    }\n    //处理最高位进位\n    if (carry) res.push(carry)\n    return res.reverse()\n};\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"july-aha":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916798881","body":"# 思路\nJavaScript api解决\n\n# 代码\n```javascript\nvar addToArrayForm = function (num, k) {\n    return (BigInt(num.join(\"\")) + BigInt(k)).toString().split('')\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xyinghe":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916799914","body":"#### 链接：\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n#### 思路：\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/jian-dan-yi-dong-javacpythonjs-pei-yang-a8ofe\n\n数组从右往左遍历每一个元素（i--)；\n\n整数每次个位数用到后去掉；\n\n用carry记录进位；\n\n反转结果集；\n\n#### 题解：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int carry = 0;\n        int l1 = num.length -1 ;\n\n        while(l1 >= 0 || k != 0){\n            int x = l1 < 0 ? 0 : num[l1];\n            int y = k == 0 ? 0 : k % 10;\n\n            int sum = x + y + carry;\n            res.add(sum % 10);\n            carry = sum / 10;\n\n            l1--;\n            k = k / 10;\n        }\n        if(carry != 0){\n            res.add(carry);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916802793","body":"# 思路\n先将k转成数组，再利用双指针分别从k和num的最后一位开始按位计算。注：需要考虑最后一次进位的情况。\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=989 lang=javascript\n *\n * [989] 数组形式的整数加法\n */\n\n// @lc code=start\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  const kArr = (k + '').split('')\n  let temp = 0\n  const ret = []\n  let i = num.length - 1\n  let j = kArr.length - 1\n  while(i >= 0 || j >= 0) {\n    const sum = (num[i] || 0) + parseInt(kArr[j] || 0) + temp\n    ret.unshift(sum % 10)\n    temp = parseInt(sum / 10)\n    i--\n    j--\n  }\n  if (temp) {\n    ret.unshift(temp)\n  }\n\n  return ret\n};\n// @lc code=end\n\n```\n\n# 复杂度分析\n时间复杂度：O(max(n, log k))，其中 n 为数组的长度。log k为k的位，即log 10(k)，10为底k的对数。\n空间复杂度：O(max(n, log k))。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"OASans":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916809316","body":"### 思路\n逐位相加，直接加到num里面。如果加后大于10则在k上进行调整\n\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k % 10\n            if num[i] >= 10:\n                k = k // 10 + num[i] // 10\n                num[i] = num[i] % 10\n            else:\n                k = k // 10\n            i -= 1\n            if i < 0 and k:\n                num.insert(0, 0)\n                i = 0\n        return num\n```\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cy-sues":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916817098","body":"# 思路\n\n从末位开始将数组和k的每一位相加，若大于10则在下一步运算中进一位，ArrayList添加这些数字，最后反转。\n\n# 代码\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> arr = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            arr.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            arr.add(k % 10);\n        }\n        Collections.reverse(arr);\n        return arr;\n    }\n}\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shenzhengkang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916818186","body":"思路\n1. 当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n2.AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\n伪代码\nwhile ( A 没完 || B 没完)\n    A 的当前位\n    B 的当前位\n    和 = A 的当前位 + B 的当前位 + 进位carry\n    当前位 = 和 % 10;\n    进位 = 和 / 10;\n    判断还有进位吗；\n\n代码\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize) {\n    int* res = malloc(sizeof(int) * fmax(10, numSize + 1));\n    *returnSize = 0;\n    for (int i = numSize - 1; i >= 0; --i) {\n        int sum = num[i] + k % 10;\n        k /= 10;\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res[(*returnSize)++] = sum;\n    }\n    for (; k > 0; k /= 10) {\n        res[(*returnSize)++] = k % 10;\n    }\n    for (int i = 0; i < (*returnSize) / 2; i++) {\n        int tmp = res[i];\n        res[i] = res[(*returnSize) - 1 - i];\n        res[(*returnSize) - 1 - i] = tmp;\n    }\n    return res;\n}\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linrAx":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916825233","body":"# 思路\r\n\r\n将数组从低位到高位加到k上,最后反转\r\n\r\n# 代码\r\n\r\n语言支持:java\r\n\r\n```java\r\nclass Solution {`\r\n\r\n  public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n​    List<Integer> res = new ArrayList<>();\r\n\r\n​    for(int i = num.length-1;i >= 0|| k >0;i--,k/=10){\r\n\r\n​      if(i>=0){\r\n\r\n​        k+=num[i];\r\n\r\n​      }\r\n\r\n​      res.add(k%10);\r\n\r\n​    }\r\n\r\n​    Collections.reverse(res);\r\n\r\n​    return res;\r\n\r\n  }\r\n\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n\r\n时间复杂度  O(max(n,log k)) , n为数组长度\r\n\r\n空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"L-mx-wq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916826948","body":"思路:逐位相加，大于10加到下一位\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n\n复杂度分析\n时间复杂度：O(max⁡(n,logk))\n其中 n 为数组的长度。\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Okkband":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916827469","body":"### 思路\r\n面向测试用例的编程\r\n\r\n``` CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size();\r\n        int cnt = 0;\r\n        int pre = 0;\r\n        int tmp = 0;\r\n        while(k / 10 || k % 10 || cnt < n){\r\n            cnt += 1;\r\n            if (cnt > n){\r\n                tmp = pre + 0 + k % 10;\r\n            } else {\r\n                tmp = pre + num[n - cnt] + k % 10;\r\n            }\r\n            k /= 10;\r\n            pre = 0;\r\n            if (tmp >= 10){\r\n                pre = 1;\r\n                tmp -= 10;\r\n            }\r\n            if (cnt > n){\r\n                num.insert(num.begin(), tmp);\r\n            } else {\r\n                num[n - cnt]  = tmp;\r\n            }\r\n            \r\n        }\r\n        if (pre == 1) num.insert(num.begin(), 1);\r\n        return num;\r\n    }\r\n};\r\n```\r\n#### 时间复杂度\r\nO(n, m), 其中n, 为num的长度，m为k的位数\r\n#### 空间复杂度\r\nO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryzhao5":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916830080","body":"# 思路\r\n从后往前遍历数组，同时取出非负整数的个位数，与其相加，传入新的数组中\r\n# 代码\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> result = new LinkedList<>();\r\n        int temp = 0;\r\n        for(int i = num.length - 1; i >= 0; i--){\r\n            temp = k%10;\r\n            k = k/10;\r\n            if(num[i] + temp >= 10){\r\n                k++;\r\n                result.addFirst((num[i] + temp) % 10);\r\n            }\r\n            else{\r\n                result.addFirst((num[i] + temp) % 10);\r\n            }\r\n\r\n            if(i == 0){\r\n                while(k != 0){\r\n                    temp = k % 10;\r\n                    k = k / 10;\r\n                    result.addFirst(temp);\r\n                     \r\n                }\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n# 时间复杂度\r\nO(max(m,n))\r\n\r\n# 空间复杂度\r\nO(max(m,n))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mosihan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916836424","body":"## 题目\n\n989. [数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 思路\n\n提取数组的数字，加K，加完后转为string，将string拆分为list填充\n\n### code\n\n```python\nA = [9,9,9,9,9,9,9,9,9,9]\nK = 1\n\nA_sum=0\nfor i in range(len(A)):\n  A_part=A[i]*10**(len(A)-i-1)\n  A_sum=A_sum+A_part\n\nprint(A_sum)\n\nak=A_sum+K\nlist1=[]\nak_s=str(ak)\nfor j in range(len(ak_s)):\n  list1.append(int(ak_s[j]))\n\nprint(ak_s)\n```\n\n### 复杂度\n\n+ 时间复杂度\n\n  O(max(m,n))\n\n+ 空间复杂度\n\n  O(max(m,n))\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"babbomax98":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916838767","body":"#### 思路\n因为是数据形式的相加，那么首先考虑因为LinkedList的add的时间复杂度是1，AyyayList的add的时间复杂度是N，所以此处选用LinkedList，\n然后以数组的下标作为循环的条件，每次给传入的int值除以10来去除最后一位数，当坐标i>=0时，加上k和10取余的值，通过LinkedList的add(int index, E element)方法插入到链表头\n最后返回即可\n#### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        List<Integer> res = new LinkedList<Integer>();\n        int n = A.length;\n        for (int i = n - 1; i >= 0 || K > 0; --i, K /= 10) {\n            if (i >= 0) {\n                K += A[i];\n            }\n            res.add(0,K % 10);\n        }\n        return res;\n    }\n}\n```\n#### 复杂度分析\n时间复杂度：O（N）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"EggEggLiu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916840372","body":"# 思路\n取num和k的低位，逐级相加\n\n# 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ret;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            ret.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            ret.push_back(k % 10);\n        }\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n};\n```\n\n# 复杂度分析\n时间O(max(n, logk))\n\n空间O(max(n, logk))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carinSkyrim":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916845902","body":"## 代码\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        left = int(''.join(list(map(str, num))))\n        return [int(i) for i in str(left+k)]\n\n```\n## 复杂度\n时间复杂度 O(n)   \n空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Brandylulu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916862006","body":"## 思路\nlist→string→int→list\n## 代码\nclass Solution:\n\n       def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n\n             n = len(A)\n\n             x = 0\n\n             for i in range(n):\n\n                  x = x + A[i] * (10**(n-i-1))\n\n             return str(x+k)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ivalkshfoeif":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916863413","body":"```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int i = num.length - 1;\n        int carry = 0;\n        List<Integer> ans = new ArrayList();\n        while(k !=0 || i >= 0){\n            //int n1 = (i >=0)? num[i]: 0;\n            int n = k % 10;\n            n += (i >=0)? num[i]: 0;\n            n += carry;\n            int temp = n%10;\n            carry = n / 10;\n            ans.add(temp);\n            k /= 10;\n            i--;\n        }\n        if (carry != 0){\n            ans.add(carry);\n        }\n        Collections.reverse(ans);\n        return ans;\n        \n    }\n}\n```\nO(N) O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Socrates2001":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916864816","body":"- 时间：2021年9月10日13:34:46\n- 题目：[989.数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n- 思路：逐位相加（最低位开始），将结果逐个放入动态分配的数组中。若某两位相加大于10，则只和的将个位放入数组，十位在适当的数中(k)进1。最后将得到的数组内的数倒置，即为所求。\n\n## c\n\n```c\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n   int *res = (int *)malloc(sizeof(int) * fmax(10, numSize+1));\n   *returnSize = 0;\n   int i, sum, temp;\n\n   for(i=numSize-1; i>=0; i--)\n   {\n       sum = num[i] + k%10;\n       k /= 10;\n       if(sum >= 10)\n       {\n           k++;\n           sum -= 10;\n       }\n       res[(*returnSize)++] = sum;\n   }\n\n   for(; k>0; k/=10)\n   {\n       res[(*returnSize)++] = k % 10;\n   }\n\n   for(i=0; i < (*returnSize)/2; i++)\n   {\n       temp = res[i];\n       res[i] = res[(*returnSize)-1-i];\n       res[(*returnSize)-1-i] = temp;\n   }\n\n    return res;\n}\n```\n\n\n\n- 时间复杂度：O(max(n, lgk)) 其中n为数组长度\n\n- 空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Just-focus":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916865049","body":"## 代码\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n) n为较长数组的长度\r\n空间复杂度：O(n) n为答案数组的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916865936","body":"思路\n\n平铺直叙\n\n\n\n代码（Python）\n\n    class Solution:\n        def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n            List=num[:]\n            res=[]\n            sum=0\n            Len=len(List)\n            i=Len-1\n            q=1\n            while i>=0:\n                sum=sum+List[i]*q\n                i-=1\n                q*=10\n            sum+=k\n            while sum!=0:\n                res.append(sum%10)\n                sum//=10\n            res.reverse()\n            if len(res)==0:\n                res.append(0)\n            return res\n\n\n\n复杂度\n\n时间：O(n)\n\n空间：O(n)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ray-hr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916875507","body":"# 思路   \r\n输出位=x+y+carry   \r\n将A设为LinkedList双向链表   \r\n# 代码  \r\n\r\n````java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        int n = A.length;\r\n        LinkedList<Integer> res = new LinkedList<>();  // 使用双向链表 LinkeList，或者 ArrayList 最后反转\r\n        int i = n - 1, sum = 0, carry = 0;\r\n        while (i >= 0 || K != 0) {  // 循环条件：两个数有一个没完\r\n            int x = i >= 0 ? A[i]: 0;\r\n            int y = K != 0 ? K % 10 : 0;\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            K = K / 10;\r\n            i--;\r\n            res.add(0, sum % 10);\r\n        }\r\n        if (carry != 0) res.add(0, carry);\r\n        return res;\r\n    }\r\n}    \r\n````\r\n# 复杂度  \r\n时间复杂度：O(max(n, lgk))  其中n为数组长度   \r\n空间复杂度：\r\n\r\n\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"PearlCoastal":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916884534","body":"## 思路\n- 从末尾开始做加法\n- 注意处理进位的方式\n    ·新建一个数组b=[]来处理进位，当 [2] + 998 时， carry = 100，b = [1, 0, 0]\n- 取模运算 **%**，和取整运算 **//**的区别\n    · 86 % 10 = 6 \n    · 86 // 10 = 8\n- 数组的加法运算：把两个数组连在一起\n    · A = [1, 2, 3], B = [2, 3, 4]\n    · A + B = [1, 2, 3, 2, 3, 4]\n## 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: [int], k: int) -> [int]:\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            curr_sum = num[i] + k % 10 + carry\n            num[i] = curr_sum % 10\n            carry = curr_sum // 10\n            k //= 10\n        \n        carry += k\n        b = []\n        while carry:\n            b = [(carry % 10)] + b\n            carry //= 10\n\n        return b + num\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nekomoon404":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916884660","body":"【思路——数组模拟加法过程】\n\n类似用数组模拟大数加法，即模拟人手算的过程，从低位开始，逐位相加，逢十进一，即：\n\n 当前位 = (数A的当前位 + 数B的当前位 + 低位的进位carry) % 10。\n \n 当最后的进位不为0时，需要添加到答案数组的起始位置，可以用 `vector` 的 `insert` 函数，如 `res.insert(res.begin(), carry)`；\n \n 或者我们可以在存答案数组时，从低位到高位存，即`res[0]`表示最低位，这样在运算过程中一直向数组的尾部插入元素即可，最后再将数组翻转。\n\n【C++代码】\n\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    int n = num.size();\n    vector<int> res;\n\n    int i = n - 1, sum = 0, carry = 0;\n    while(i >= 0 || k != 0) {\n        int a = i >= 0 ? num[i] : 0;\n        int b = k != 0 ? k % 10 : 0;\n\n        sum = a + b + carry;\n        carry = sum / 10;\n        res.push_back(sum % 10);\n\n        i--;\n        k /= 10;\n    }\n\n    if(carry != 0)\n        res.push_back(carry);\n    reverse(res.begin(), res.end());\n\n    return res;\n}\n```\n\n时间复杂度： $O(N)$，记 $N= \\max(n, \\log k)$，即表示答案数组的长度， `while` 遍历是 $O(N)$ 的复杂度，翻转数组也是 $O(N)$ 的复杂度。\n\n空间复杂度： $O(N)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen-ds":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916884680","body":"# 思路\n\n从最低位开始相加，按逆序存储在vector中，最后把vector逆序一下就可以。\n\n# 代码\nC++\n```\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    vector<int> res;\n    int carry = 0;\n    int i = num.size() - 1;\n    while (i >= 0 || k || carry) {\n        int tmp = i >= 0 ? num[i--] + carry + k%10 : carry + k%10;\n        carry = tmp /10;\n        k /= 10;\n        res.push_back(tmp%10);\n    }\n    reverse(res.begin(), res.end());\n    return res;\n}\n```\n\n# 复杂度\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"minuet-red":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916889747","body":"标准加法模板\r\n时间复杂度O(n),空间复杂度O(n)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\tvector<int> addToArrayForm(vector<int>& num, int k) {\r\n\t\treverse(num.begin(), num.end());\r\n\t\tvector<int>res;\r\n\t\tint carry = 0;\r\n\t\tfor (int i = 0; i < num.size() || k>0; i++) {\r\n\t\t\t// num的当前位\r\n\t\t\tint a = (i < num.size() ? num[i] : 0);\r\n\t\t\t// 模拟加法公式\r\n\t\t\tint sum = a + k % 10 + carry;\r\n\t\t\tres.emplace_back(sum % 10);\r\n\t\t\tk /= 10;\r\n\t\t\tcarry = sum / 10;\r\n\t\t}\r\n\t\tif (carry > 0) {\r\n\t\t\tres.emplace_back(carry);\r\n\t\t}\r\n\t\treverse(res.begin(), res.end());\r\n\t\treturn res;\r\n\t}\r\n};\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LAGRANGIST":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916891700","body":"## 思路\r\n\r\n* 用 carry 记录上一位是否有进位， carry =  ( A[i]+B[i]+carry ) **>=** 10 ? 1 : 0  （注意这里是大于等于而不是大于）\r\n* 当前位 cur 可以表示为 ( A[i]+B[i]+carry ) % 10 \r\n* 处理完 num 的所有数字后，再处理k（如果k的位数比 num 大）\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n## 代码\r\n\r\n```c++\r\n#include <bits./stdc++.h>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nvector<int> addToArrayForm(vector<int> &num, int k)\r\n{\r\n    int carry = 0;\r\n    int cur = 0;\r\n    vector<int> res;\r\n    while (!num.empty())\r\n    {\r\n\r\n        cur = (num.back() + k % 10 + carry) % 10;\r\n        carry = (num.back() + k % 10 + carry) >= 10 ? 1 : 0;//看看这一位是否要进位到下一位\r\n        k /= 10;//去除k最后一位数字\r\n        res.push_back(cur);//res先反向保存，之后调用reverse调转之后再返回\r\n        num.pop_back();//去除num最后一位数字\r\n    }\r\n\r\n    while(k!= 0)//k位数比num大\r\n    {\r\n        cur = (k % 10 + carry) % 10;\r\n        carry = (k % 10 + carry) >= 10 ? 1 : 0;\r\n        k /= 10;\r\n        res.push_back(cur);\r\n    }\r\n\r\n    if(carry)//最后一次还要进位\r\n    {\r\n        res.push_back(1);\r\n    }\r\n\r\n    reverse(res.begin(), res.end()); //反转输出才是正确的\r\n    return res;\r\n}\r\n\r\n//TestDrive\r\nint main()\r\n{\r\n    vector<int> num = {2,1,5};\r\n    int k = 806;\r\n    vector<int> ans = addToArrayForm(num,k);\r\n    for (auto it = ans.begin(); it != ans.end();it++)\r\n    {\r\n        cout << *it << \" \";\r\n    }\r\n}\r\n```\r\n\r\n***\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n\r\n\r\n### 时间复杂度\r\n\r\n此方法需要遍历一个 num 和 int类型数字 k 的每一位\r\n\r\n所以时间复杂度是：O( max(N , K ) ) , 其中N和K分别是 num 和 k 的位数 \r\n\r\n\r\n\r\n### 空间复杂度\r\n\r\n利用了一个辅助 `vector<int> res` 其大小为max（N , K)\r\n\r\n所以空间复杂度是O( max(N, K ) )","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}