{"372354984":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916976831","body":"### 思路\n\n从末位相加，取余留下尾数，剩下部分与下一位相加，直至 k 和 num 都用完\n\n### 代码\n\n```js\nconst addToArrayForm = function (num, k) {\n  const res = []\n  const n = num.length\n  for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n    if (i >= 0) {\n      k += num[i]\n    }\n    res.push(k % 10)\n  }\n  res.reverse()\n  return res\n}\n\n```\n### 复杂度\n\n- 时间复杂度:O(Max(n,logk))\n- 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917430288","body":"### 思路\r\n\r\n- 首先要取得目标字符串的位置数组A\r\n- 遍历原目标字符串\r\n  - A数组只有一个，直接计算位置\r\n  - 否则计算前A数组两位中谁位置最近\r\n    - 判断A数组已经计算到第二位时，去掉第一位\r\n\r\n### 代码\r\n\r\n``` js\r\nlet shortestToChar = function(s, c) {\r\n  s = s.split('')\r\n  let cIdx = s.reduce((pre, item, idx) => {\r\n    if (item === c)pre.push(idx)\r\n    return pre\r\n  }, [])\r\n\r\n  let answer = []\r\n  s.reduce((pre, i, idx) => {\r\n    if (pre.length === 1) {\r\n      answer.push(Math.abs(pre[0] - idx))\r\n    } else {\r\n      answer.push(Math.min(Math.abs(pre[0] - idx), Math.abs(pre[1] - idx)))\r\n      if (idx >= pre[1])pre.shift()\r\n    }\r\n    return pre\r\n  }, cIdx)\r\n  return answer\r\n}\r\n\r\n```\r\n时间：n*k, n为字符串s的长度，k为c在s中出现的次数\r\n空间：k\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661727","body":"### 思路\n用数组模拟\n\n### 代码\n\n```js\n\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    return this.stack.length > 0 ? this.stack.pop() : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    let length = Math.min(k, this.stack.length);\n    for (let i = 0; i < length; i++) {\n        this.stack[i] += val;\n    }\n};\n\n```\n\n### 复杂度\n\n- 时间复杂度：O(1)push pop, O(n)inc\n- 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918328544","body":"### 思路\n用栈接入字符串，遍历字符串，当匹配到字母和'['的时候就入栈保存，当匹配到']'的时候则保存当前的结果，最后得出结果\n\n### 代码\n```js\nconst isNumber = (str: string) => /\\d/.test(str);\nconst isLetter = (str: string) => /[a-z]/.test(str);\n\nfunction decodeString(str: string): string {\n  if (str.length === 0) return \"\";\n  const stack = [];\n  const len = str.length;\n  let index = 0;\n  let repeatStr = \"\";\n  while (index < len) {\n    if (isLetter(str[index]) || str[index] === \"[\") {\n      stack.push(str[index]);\n    } else if (isNumber(str[index])) {\n      if (isNumber(stack[stack.length - 1])) {\n        stack[stack.length - 1] += str[index];\n      } else {\n        stack.push(str[index]);\n      }\n    } else if (str[index] === \"]\") {\n      let prevValue = stack.pop();\n      while (prevValue !== \"[\") {\n        repeatStr = prevValue + repeatStr;\n        prevValue = stack.pop();\n      }\n      if (isNumber(stack[stack.length - 1])) {\n        stack[stack.length - 1] = repeatStr.repeat(stack[stack.length - 1]);\n      } else {\n        stack.push(repeatStr);\n      }\n      repeatStr = \"\";\n    }\n    index++;\n  }\n  return stack.join(\"\");\n}\n```\n### 复杂度\n- 时间复杂度: O(n)\n- 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"965682575":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916838838","body":"#### 思路\r\n\r\n​\t从数组的最后一位及k的个位开始计算，carry变量表示进位，将每次计算的sum值放入新的数组中，最后将数组倒置。\r\n\r\n​\t**注意**：两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在数组中\r\n\r\n#### 代码\r\n\r\n``` c++\r\npublic:\r\n\r\n vector<int> addToArrayForm(vector<int>& A, int K) {\r\n\r\n\tvector<int> res;\r\n\tint i = A.size() - 1;\r\n\tint carry = 0;\r\n\tint sum = 0;\r\n\t\r\n\twhile (i > -1 || K != 0) {\r\n        int x = i > -1 ? A[i] : 0;\r\n        int y = K != 0 ? (K % 10) : 0;\r\n        sum = x + y + carry;\r\n\r\n        carry = sum / 10;\r\n        sum %= 10;\r\n        i--;\r\n        K /= 10;\r\n        res.push_back(sum);\r\n    }\r\n\r\n\tif (carry) {\r\n\t\tres.push_back(carry);\r\n\t}\r\n\r\n\treverse(res.begin(), res.end());\r\n\treturn res;\r\n  }\r\n\r\n};\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：O(max(N, log k))\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruohai0925":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916226878","body":"## 思路\r\n\r\n从个位开始加，用carry表示进位\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n# from typing import List\r\nfrom collections import deque\r\nclass Solution:\r\n    def addToArrayForm(self, A, K):\r\n        if K == 0:\r\n            return A\r\n\r\n        i = len(A) - 1\r\n        carry = 0\r\n\r\n        # d = []\r\n        d = deque()\r\n\r\n        while i >= 0 and K > 0:\r\n            temp = A[i] + carry + K % 10\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            K = K // 10\r\n            i -= 1\r\n\r\n        while i < 0 and K > 0:\r\n            temp = K % 10 + carry\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            K = K // 10\r\n\r\n        while i >= 0:\r\n            temp = A[i] + carry\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            i -= 1\r\n\r\n        if carry > 0:\r\n            #d.insert(0, carry)\r\n            d.appendleft(carry)\r\n\r\n        #return d\r\n        return list(d)\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917105068","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  正反遍历\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        n = len(S)\r\n        dis = 10001\r\n        res = []\r\n        for i in range(0, n):\r\n            if S[i] == C:\r\n                dis = 0\r\n            res.append(dis)\r\n            dis += 1\r\n\r\n        dis = 10001\r\n        for i in range(n - 1, -1, -1):\r\n            if S[i] == C:\r\n                dis = 0\r\n            res[i] = min(res[i], dis)\r\n            dis += 1\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917499666","body":"\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.items = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.items) < self.maxSize:\r\n            self.items.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.items == []:\r\n            return -1\r\n        else:\r\n            # length = len(self.items)\r\n            # items_top = self.items[length - 1]\r\n            return self.items.pop()\r\n            # return items_top\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.items))):\r\n            self.items[i] += val\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\nTime and Space Complexity\r\nTime: O(1) for push and pop, O(Math.min(k, top + 1)) for increment\r\nSpace: O(MaxSize)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917695283","body":"\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':  # 处理>10的数字\r\n                multi = multi * 10 + int(c)\r\n            else:\r\n                res += c\r\n        return res\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\nO(N)，循环体会从头到尾遍历s.length();\r\nO(N)，要维护一个栈；\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918468166","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n时间复杂度：O(1)，均是push和pop的组合\r\n\r\n空间复杂度：O(n)，n为栈长度，共利用了两个栈\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919545281","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        sortedarr = sorted(arr)\r\n        netSum = 0\r\n        cnt = 0\r\n        for i in range(0,len(arr)):\r\n            netSum += (arr[i] - sortedarr[i])\r\n            if netSum == 0:\r\n                cnt += 1\r\n        return cnt\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n时间复杂度：$O(nlogn)$\r\n\r\n空间复杂度：O(n)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920556429","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def rotateRight(self, head: 'ListNode', k: 'int') -> 'ListNode':\r\n        # base cases\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return head\r\n\r\n        # close the linked list into the ring\r\n        old_tail = head\r\n        n = 1\r\n        while old_tail.next:\r\n            old_tail = old_tail.next\r\n            n += 1\r\n        old_tail.next = head\r\n\r\n        # find new tail : (n - k % n - 1)th node\r\n        # and new head : (n - k % n)th node\r\n        new_tail = head\r\n        for i in range(n - k % n - 1):\r\n            new_tail = new_tail.next\r\n        new_head = new_tail.next\r\n\r\n        # break the ring\r\n        new_tail.next = None\r\n\r\n        return new_head\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n时间复杂度：$O(n)$\r\n\r\n空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921369517","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Recursion\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n\r\n        if head == None or head.next == None:\r\n            return head\r\n\r\n        one = head\r\n        two = one.next\r\n        three = two.next\r\n\r\n        two.next = one\r\n        one.next = self.swapPairs(three)\r\n\r\n        return two\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n时间复杂度：$O(n)$\r\n\r\n空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922062024","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        \r\n        def getMedian(left: ListNode, right: ListNode) -> ListNode: # right包含了None的情况\r\n            fast = slow = left # 标准快慢指针的模板\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        \r\n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\r\n            if left == right:\r\n                return None\r\n            mid = getMedian(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n        \r\n        return buildTree(head, None)\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n时间复杂度：$O(nlogn)$\r\n\r\n空间复杂度：$O(logn)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922414239","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        pa, pb = headA, headB\r\n        while pa != pb:\r\n            pa = pa.next if pa else headB\r\n            pb = pb.next if pb else headA\r\n        return pa\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\nTime: O(len(A) + len(B) - len(common(A, B))\r\n\r\nSpace: O(1)\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ImSingee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916251691","body":"```rust\r\nimpl Solution {\r\n    pub fn add_to_array_form(num: Vec<i32>, mut k: i32) -> Vec<i32> {\r\n        let mut result = Vec::new();\r\n        for i in (0..num.len()).rev() {\r\n            result.push({\r\n                let result = num[i] + k;\r\n                let x = result % 10;\r\n                k = result / 10;\r\n                x\r\n            })\r\n        }\r\n\r\n        while k > 0 {\r\n            result.push({\r\n                let x = k % 10;\r\n                k = k / 10;\r\n                x\r\n            })\r\n        }\r\n\r\n        result.reverse();\r\n        result\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度 O(len(num)) [logk约等于1 忽略] \r\n额外空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917026640","body":"```go\r\nfunc min(a, b int) int {\r\n    if a < b { return a } else { return b}\r\n}\r\n\r\nfunc shortestToChar(s string, c byte) []int {\r\n    result := make([]int, len(s))\r\n\r\n    left := -20000\r\n    for i := 0; i < len(s); i++ {\r\n        cc := s[i]\r\n\r\n        if cc == c {\r\n            left = i\r\n        }\r\n\r\n        result[i] = i - left\r\n    }\r\n\r\n    right := 20000\r\n    for i := len(s) - 1; i >= 0; i-- {\r\n        cc := s[i]\r\n\r\n        if cc == c {\r\n            right = i\r\n        }\r\n\r\n        result[i] = min(right - i, result[i])\r\n    }\r\n\r\n\r\n    return result\r\n}\r\n```\r\n\r\n时间复杂度 O(len(s))\r\n额外空间复杂度 O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917430600","body":"### 解法一：BF\r\n\r\nincrement 的时间复杂度 O(k)\r\n\r\n```rust\r\nstruct CustomStack {\r\n    elements: Vec<i32>,\r\n    maxSize: usize,\r\n}\r\n\r\nimpl CustomStack {\r\n    fn new(maxSize: i32) -> Self {\r\n        CustomStack{\r\n            elements: Vec::new(),\r\n            maxSize: maxSize as usize,\r\n        }\r\n    }\r\n    \r\n    fn push(&mut self, x: i32) {\r\n        if self.elements.len() < self.maxSize {\r\n            self.elements.push(x)\r\n        }\r\n    }\r\n    \r\n    fn pop(&mut self) -> i32 {\r\n        self.elements.pop().unwrap_or(-1)\r\n    }\r\n    \r\n    fn increment(&mut self, k: i32, val: i32) {\r\n        let k = std::cmp::min(k as usize, self.elements.len());\r\n        \r\n        for i in 0..k {\r\n            *(self.elements.get_mut(i).unwrap()) += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 解法二：前缀和思想\r\n\r\nincrement 的时间复杂度 O(1)\r\n\r\n```rust\r\nstruct CustomStack {\r\n    elements: Vec<i32>,\r\n    increments: Vec<i32>,\r\n    maxSize: usize,\r\n}\r\n\r\nimpl CustomStack {\r\n    fn new(maxSize: i32) -> Self {\r\n        CustomStack{\r\n            elements: Vec::new(),\r\n            increments: Vec::new(),\r\n            maxSize: maxSize as usize,\r\n        }\r\n    }\r\n    \r\n    fn push(&mut self, x: i32) {\r\n        if self.elements.len() < self.maxSize {\r\n            self.elements.push(x);\r\n            self.increments.push(0);\r\n        }\r\n    }\r\n    \r\n    fn pop(&mut self) -> i32 {\r\n        if let Some(inc) = self.increments.pop() {\r\n            if !self.increments.is_empty() {\r\n                *(self.increments.last_mut().unwrap()) += inc;\r\n            }\r\n\r\n            self.elements.pop().unwrap() + inc\r\n        } else {\r\n            -1\r\n        }\r\n    }\r\n    \r\n    fn increment(&mut self, k: i32, val: i32) {\r\n        if !self.increments.is_empty() {\r\n            let k = std::cmp::min(k as usize, self.increments.len());\r\n            self.increments[k - 1] += val;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917662104","body":"简单粗暴利用栈完成\r\n\r\n```rust\r\nimpl Solution {\r\n    pub fn decode_string(s: String) -> String {\r\n        let mut result = \"\".to_string();\r\n        let mut numbers: Vec<usize> = Vec::new();\r\n        let mut letters: Vec<String> = Vec::new();\r\n\r\n        let mut i = 0;\r\n        while i < s.len() {\r\n            let c = s.bytes().nth(i).unwrap() as char;\r\n\r\n            if c.is_ascii_alphabetic() {\r\n                let s = Solution::scan_letter(&s, &mut i);\r\n\r\n                if let Some(last) = letters.last_mut() {\r\n                    *last += &s;\r\n                } else {\r\n                    result += &s;\r\n                }\r\n                \r\n                continue;\r\n            }\r\n\r\n            if c.is_ascii_digit() {\r\n                let n = Solution::scan_number(&s, &mut i);\r\n                numbers.push(n);\r\n                continue;\r\n            }\r\n\r\n            if c == '[' {\r\n                letters.push(\"\".to_string());\r\n                i += 1;\r\n                continue;\r\n            }\r\n\r\n            if c == ']' {\r\n                let part = letters.pop().unwrap().repeat(numbers.pop().unwrap());\r\n\r\n                if let Some(last) = letters.last_mut() {\r\n                    *last += &part;\r\n                } else {\r\n                    result += &part;\r\n                }\r\n                \r\n                i += 1;\r\n                continue;\r\n            }\r\n\r\n            panic!(\"unknown char {}\", c);\r\n        }\r\n\r\n        result\r\n    }\r\n\r\n    fn scan_letter(s: &str, i: &mut usize) -> String {\r\n        let mut result = \"\".to_string();\r\n\r\n        while *i < s.len() {\r\n            let c = s.bytes().nth(*i).unwrap() as char;\r\n\r\n            if c.is_ascii_alphabetic() {\r\n                result.push(c);\r\n                *i += 1;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        result\r\n    }\r\n\r\n    fn scan_number(s: &str, i: &mut usize) -> usize {\r\n        let mut result = 0;\r\n\r\n        while *i < s.len() {\r\n            let c = s.bytes().nth(*i).unwrap() as char;\r\n\r\n            if let Some(n) = c.to_digit(10) {\r\n                result = 10 * result + (n as usize);\r\n                *i += 1;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        result\r\n    }\r\n}\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/11208082/132994383-2cd05f26-0253-4de8-999a-dbdf6cf5a588.png)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918685453","body":"```rust\r\nstruct MyQueue {\r\n    stack_for_push: Vec<i32>,\r\n    stack_for_pop: Vec<i32>,\r\n}\r\n\r\n\r\n/**\r\n * `&self` means the method takes an immutable reference.\r\n * If you need a mutable reference, change it to `&mut self` instead.\r\n */\r\nimpl MyQueue {\r\n\r\n    /** Initialize your data structure here. */\r\n    fn new() -> Self {\r\n        MyQueue {\r\n            stack_for_push: Vec::new(),\r\n            stack_for_pop: Vec::new(),\r\n        }\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    fn push(&mut self, x: i32) {\r\n        self.stack_for_push.push(x);\r\n    }\r\n\r\n    fn clean(&mut self) {\r\n        if self.stack_for_pop.is_empty() {\r\n            while let Some(x) = self.stack_for_push.pop() {\r\n                self.stack_for_pop.push(x);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    fn pop(&mut self) -> i32 {\r\n        self.clean();\r\n\r\n        self.stack_for_pop.pop().unwrap()    \r\n    }\r\n\r\n    \r\n    /** Get the front element. */\r\n    fn peek(&mut self) -> i32 {\r\n        self.clean();\r\n\r\n        self.stack_for_pop.last().unwrap().to_owned()\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    fn empty(&self) -> bool {\r\n        self.stack_for_push.is_empty() && self.stack_for_pop.is_empty()\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * let obj = MyQueue::new();\r\n * obj.push(x);\r\n * let ret_2: i32 = obj.pop();\r\n * let ret_3: i32 = obj.peek();\r\n * let ret_4: bool = obj.empty();\r\n */\r\n```\r\n\r\n时间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920143268","body":"```rust\r\nimpl Solution {\r\n    pub fn max_chunks_to_sorted(arr: Vec<i32>) -> i32 {\r\n        let mut stack: Vec<i32> = Vec::new();\r\n\r\n        for i in 0..arr.len() {\r\n            if matches!(stack.last(), Some(x) if *x > arr[i]) {\r\n                let current = stack.pop().unwrap();\r\n\r\n                while matches!(stack.last(), Some(x) if *x > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n\r\n                stack.push(current);\r\n            } else {\r\n                stack.push(arr[i]);\r\n            }\r\n        }\r\n\r\n        stack.len() as i32\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度 O(len(arr))\r\n空间复杂度 O(len(arr))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920964967","body":"```go\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    l := 0\r\n    var last *ListNode\r\n\r\n    node := head\r\n    for node != nil {\r\n        l++\r\n        last = node\r\n        node = node.Next\r\n    }\r\n\r\n    if l == 0 {\r\n        return head\r\n    }\r\n\r\n    k = k % l\r\n\r\n    if k == 0 {\r\n        return head\r\n    }\r\n    newHead := head\r\n    var newLast *ListNode\r\n    kk := l - k\r\n    for i := 0; i < kk; i++ {\r\n        newLast = newHead\r\n        newHead = newHead.Next\r\n    }\r\n\r\n    last.Next = head\r\n    newLast.Next = nil\r\n\r\n    return newHead\r\n}\r\n```\r\n\r\n时间复杂度 O(链表长度)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921818146","body":"```go\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    dummy := &ListNode{\r\n        Val: 0,\r\n        Next: head,\r\n    }\r\n\r\n    zero := dummy\r\n    for zero.Next != nil {\r\n        one := zero.Next\r\n        two := one.Next\r\n\r\n        if two == nil {\r\n            break\r\n        }\r\n\r\n        three := two.Next\r\n        two.Next = one\r\n        one.Next = three\r\n        zero.Next = two\r\n\r\n        zero = one\r\n    }\r\n\r\n    return dummy.Next\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922271329","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * type TreeNode struct {\r\n *     Val int\r\n *     Left *TreeNode\r\n *     Right *TreeNode\r\n * }\r\n */\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n    return do(head, nil)\r\n}\r\n\r\nfunc mid(left, right *ListNode) *ListNode {\r\n    slow, fast := left, left\r\n    for fast != right && fast.Next != right {\r\n        slow = slow.Next\r\n        fast = fast.Next.Next\r\n    }\r\n    return slow\r\n}\r\n\r\n// do for [left, right)\r\nfunc do(left, right *ListNode) *TreeNode {\r\n    if left == right {\r\n        return nil\r\n    }\r\n\r\n    x := mid(left, right)\r\n\r\n    root := &TreeNode{Val: x.Val}\r\n    root.Left = do(left, x)\r\n    root.Right = do(x.Next, right)\r\n\r\n    return root\r\n}\r\n```\r\n\r\n递归做法，时间和空间复杂度均为 O(nlogn) \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922424486","body":"```go\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n    lA := getLength(headA)\r\n    lB := getLength(headB)\r\n\r\n    if lA < lB {\r\n        headB = next(headB, lB-lA)\r\n    } else if lA > lB {\r\n        headA = next(headA, lA-lB)\r\n    }\r\n\r\n    for headA != headB {\r\n        headA = headA.Next\r\n        headB = headB.Next\r\n    }\r\n\r\n    return headA\r\n}\r\n\r\nfunc next(head *ListNode, c int) *ListNode {\r\n    for i := 0; i < c; i++ {\r\n        head = head.Next\r\n    }\r\n    return head\r\n}\r\n\r\nfunc getLength(head *ListNode) int {\r\n    l := 0\r\n\r\n    for head != nil {\r\n        head = head.Next\r\n        l += 1\r\n    }\r\n\r\n    return l\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilyzhaoyilu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916253690","body":"### 思路\r\n按照官方题解\r\n\r\n### CPP代码\r\n```Cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int n = num.size();\r\n        for(int i = n - 1; i >= 0; --i){\r\n            int curSum = num[i] + k % 10;\r\n            k /= 10;\r\n            if(curSum >= 10){\r\n                k++;\r\n                curSum -=10;\r\n            }\r\n            res.push_back(curSum);\r\n        }\r\n        while(k > 0){\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n + logk + resLength)，其中 n 为数组的长度；resLength是res这个vector的长度，来自于reverse的时间消耗\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917310692","body":"#### 思路 \r\nIterate twice: from the left and from the right. While interating, keep track of the distance between the current char to the target char. In the response vector, update the distance if the current distance is smaller. Simiar to Dijkstra.\r\n\r\n#### 代码 CPP\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        //明天就能和城仔打游戏了哦耶(＾－＾)V\r\n        //res has to have a placeholder to use index\r\n        vector<int> res(s.size(), s.size() + 1);\r\n        int targetDistance = s.size() + 1;\r\n        //iterate through the left side\r\n        for(int i = 0; i < s.size(); i++){\r\n            \r\n            if(s[i] == c){\r\n                targetDistance = 0;\r\n            }else{\r\n                targetDistance++;\r\n            }\r\n\r\n            if(res[i] > targetDistance){\r\n                res[i] = targetDistance;\r\n            }\r\n        }\r\n\r\n        targetDistance = s.size() + 1;\r\n\r\n        //iterate through the right side\r\n        for(int i = s.size() - 1; i >= 0; i--){\r\n            \r\n            if(s[i] == c){\r\n                targetDistance = 0;\r\n            }else{\r\n                targetDistance++;\r\n            }\r\n            if(res[i] > targetDistance){\r\n                res[i] = targetDistance;\r\n            }\r\n\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度：O(n) n is the length of s    \r\n空间复杂度：O(1) constants","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917549437","body":"今天是跟城仔和Fleta打游戏所以并不想好好写题的一天，啊打游戏真开心~\n官方题解\n```cpp\nclass CustomStack {\npublic:\n    vector<int> stack, add;\n    int top;\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n        add.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != stack.size() - 1){\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    int pop() {\n        if(top == -1){\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if(top != 0){\n            add[top - 1] += add[top];\n        }\n        add[top] = 0;\n        --top;\n        return ret;\n\n    }\n    \n    void increment(int k, int val) {\n        int lim = min(k - 1, top);\n        if(lim >= 0){\n            add[lim] += val;\n        }\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918327105","body":"自己没有写出来，搬运了官方的\n\n```cpp\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                stk.pop_back();\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                while (repTime--) t += o; \n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922418219","body":"传统思路，这期我的重点在锻炼写c++而不是思路上，所以就不写思路了(*^▽^*)\r\nApex的服务器啥时候能修好啊\r\n\r\n- [用类set](#思路-用set)\r\n- [双指针](#思路-双指针)\r\n\r\n### 思路 用类set\r\nset就是hashmap/哈希表的一种；\r\n此处的是没有顺序的。JS的一般默认是有序的：D\r\n#### 代码 CPP\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        unordered_set<ListNode *>visited;\r\n        ListNode *temp = headA;\r\n        while(temp != nullptr){\r\n            visited.insert(temp);\r\n            temp = temp->next;\r\n        }\r\n        temp = headB;\r\n        while(temp != nullptr){\r\n            if(visited.count(temp)){\r\n                return temp;\r\n            }\r\n            temp = temp->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度：O(n + m) n is the size of the list that starts with HeadA, m is ... headB  </br>\r\n空间复杂度：O(m)\r\n\r\n\r\n### 思路 双指针\r\n\r\n#### 代码 CPP\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(headA == nullptr || headB == nullptr){\r\n            return nullptr;\r\n        } \r\n        ListNode *pa = headA, *pb = headB;\r\n        while(pa != pb){\r\n            pa = pa == nullptr ? headB : pa->next;\r\n            pb = pb == nullptr ? headA : pb->next;\r\n        }\r\n        return pa;\r\n    }\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度：O(n + m)  </br>\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Dana-Dai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916255452","body":"## 思路\n直接对数组操作，但要注意进位，尤其是K > A的情况，要在数组开头插入以进位\n\n## 语言\ncpp\n\n## 代码\n···\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        //把K直接加到数组num上\n        int len = num.size() - 1;\n        while (k > 0) {\n            num[len] += k;\n            k = num[len] / 10;\n            num[len] %= 10;\n            len --;\n\n            if (len < 0 && k > 0) {\n                num.insert(num.begin(), 0);\n                len = 0;\n            }\n        }\n        return num;\n    }\n};\n```\n## 复杂度分析\n时间复杂度：$O（N）$即需要遍历一遍数组，故为N\n空间复杂度：$O（1）$不需要额外开辟空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917348700","body":"# 中心拓展法\n## 思路\n遍历字符串s，以字符串每个节点为中心，向两边遍历，更新距离\n## 代码\n~~~\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        //中心拓展法，以每个节点为中心，分别相前向后遍历\n        int len = s.length();\n        vector<int> answer(len);\n\n        for (int i = 0; i < len; i ++) {\n            if (s[i] == c) continue;\n            int l = i, r = i;\n            int dist = 0;\n\n            while (l >= 0 || r <= len - 1) {\n                if (s[l] == c) {\n                    dist = i - l;\n                    break;\n                }\n\n                if (s[r] == c) {\n                    dist = r - i;\n                    break;\n                }\n\n                if (l > 0) l --;\n                if (r < len - 1) r ++;\n            }\n            answer[i] = dist;\n        }\n\n        return answer;\n    }\n};\n~~~\n时间复杂度：O（N^2）遍历两遍数组\n\n# 左右搜索法\n## 思路\n从左到右更新一遍距离，遇到c即为0，从右向左更新一遍距离，遇到对每个节点的距离进行覆盖\n## 代码\n~~~\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> dist(len, len);\n        //从左向右遍历，遇到c即为0，不断更新距离\n        for (int i = 0; i < len; i ++) {\n            if (s[i] == c) dist[i] = 0;\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\n        }\n\n        //从右向左遍历，再次更新距离\n        for (int i = len - 1; i >= 0; i --) {\n            if (dist[i] == len || (i < len - 1 && dist[i + 1] + 1 < dist[i]))\n                dist[i] = dist[i + 1] + 1;\n        }\n\n        return dist;\n    }\n};\n~~~\n时间复杂度：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917439877","body":"## 思路\n用数组实现\n## 代码\n~~~\nclass CustomStack {\nprivate:\n    int ans[1000];\n    int size;\n    int top;\npublic:\n    CustomStack(int maxSize) {\n        size = maxSize;\n        top = 0;\n    }\n    \n    void push(int x) {\n        if (top < size) \n            ans[top ++] = x;\n    }\n    \n    int pop() {\n        if (top > 0) return ans[-- top];\n        else return -1;\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0, num = min(k, top); i < num; i ++)\n            ans[i] += val;\n    }\n};\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917764935","body":"~~~\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        stack<string> strs;\n        stack<int> nums;\n        int num = 0;\n        for (int i = 0; i < s.size(); i ++) {\n            if (s[i] >= '0' && s[i] <= '9')\n                num = s[i] - '0' + num * 10;\n            else if (s[i] == '[') {\n                nums.push(num);\n                num = 0;\n                strs.push(res);\n                res = \"\";\n            }\n            else if (s[i] >= 'a' && s[i] <= 'z') \n                res = res + s[i];\n            else {\n                int cur = nums.top();\n                nums.pop();\n                for (int i = 0; i < cur; i ++) \n                    strs.top() += res;\n                res = strs.top();\n                strs.pop();\n            }\n        }\n        return res;\n    }\n};\n~~~\n时间复杂度和空间复杂度均要遍历一遍s，即O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918723821","body":"~~~c++\nclass MyQueue {\npublic:\n    //构造两个栈\n    //一个入栈，一个出栈\n    stack<int> stIn;\n    stack<int> stOut;\n    /** Initialize your data structure here. */\n    MyQueue() {\n\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stIn.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        //只有当stOut为空的时候，才全部导入stIn内的数据\n        if (stOut.empty()) \n            while (!stIn.empty()) {\n                stOut.push(stIn.top());\n                stIn.pop();\n            }\n        int res = stOut.top();\n        stOut.pop();\n        return res;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        //返回队首元素\n        //直接调用类的pop函数\n        int res = this->pop();\n        stOut.push(res);\n        return res; \n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return stIn.empty() && stOut.empty();\n    }\n};\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919602192","body":"分块的标准是：一个单独元素就可以是一个块，而且块后面的所有元素都得不小于该块的最大值；\n考虑到用单调栈来维护块的最大值\n~~~c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> res;\n        res.push(arr[0]);\n        for (int i = 1; i < arr.size(); i ++) {\n            if (arr[i] < res.top()) {\n                int maxNum = res.top();\n                while (!res.empty() && res.top() > arr[i]) res.pop();\n                res.push(maxNum);\n            }\n            else\n                res.push(arr[i]);\n        }\n        return res.size();\n    }\n};\n~~~\n时间复杂度：O（n）\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920189566","body":"1. 闭合成环，该题最终结果无非就是遍历到一个结点，该结点的下一个结点为head，该结点的next指向NULL；\n2. 问题就转变为确定该结点位置，首先遍历一遍链表，确定结点数，右移k个值，即最终的结点位置就是节点数 - k - 1；\n3. 更新head和指向NULL的结点\n~~~C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        //base case\n        if (head == NULL) return NULL;\n\n        //若链表结点数为n，即无非就是取第n-k个结点\n        //将该结点的下一个结点变为head，该结点的next指向NULL；\n        int n = 1;\n        ListNode* cur = head;\n        while (cur->next) {\n            n ++;\n            cur = cur->next;\n        }\n\n        //闭合成环(要考虑到k > n的情况)\n        cur->next = head;\n        int num = n - (k % n) - 1;\n\n        cur = head;\n        while (num --) cur = cur->next;\n        ListNode* res = cur->next;\n        cur->next = NULL;\n        return res;\n    }\n};\n~~~\n时间复杂度：O（n）链表结点一共n个，最后位置在第i个，那么为O（n + i），即为O(n)\n空间复杂度：O（1） 原地操作","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921061634","body":"模拟交换过程\n~~~c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        //由于头节点也发生变化\n        //需要增设头节点\n        ListNode *dummyHead = new ListNode(0);\n        dummyHead->next = head;\n        ListNode* cur = dummyHead;\n\n        //开始模拟两两交换\n        //讨论特殊情况\n        while (cur->next && cur->next->next) {\n            ListNode *tmp1 = cur->next;\n            ListNode *tmp2 = cur->next->next->next;\n\n            cur->next = cur->next->next;\n            cur->next->next = tmp1;\n            cur->next->next->next = tmp2;\n\n            //更新下一个交换的起点\n            cur = cur->next->next;\n        }\n\n        return dummyHead->next;\n    }\n};\n~~~\n时间复杂度O（n），遍历一遍整个链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922162432","body":"将有序链表变成有序数组，每次取mid作为根节点\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    //将有序链表转成有序数组\n    TreeNode* sortedListToBST(ListNode* head) {\n        vector<int> res;\n        while (head) {\n            res.push_back(head->val);\n            head = head->next;\n        }\n        return dfs(res, 0, res.size() - 1);\n    }\n\n    TreeNode* dfs(vector<int>& res, int start, int end) {\n        if (start > end) return nullptr;\n        int mid = start + (end - start >> 1);\n        TreeNode* root = new TreeNode(res[mid]);\n\n        root->left = dfs(res, start, mid - 1);\n        root->right = dfs(res, mid + 1, end);\n        return root;\n    }\n};\n```\n时间复杂度：O（n），链表转换为数组需O（n）内完成，而后的dfs则是O（logn）\n空间复杂度：O（n），vector的加入","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922489400","body":"```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        //若有交点，那么两链表遍历完自己，再遍历另一个链表,两链表相遇的点就是起始交点,即走相同路径\n        ListNode* A = headA, * B = headB;\n        while (A != B) {\n            //若无交点(A : 4 1 8 4 5)  B(5 0 1 2 7 9)\n            //整个遍历完A和B，此时A走过的为(4 1 8 4 5 NULL 5 0 1 2 7 9) B走过的为(5 0 1 2 7 9 NULL 4 1 8 4 5)\n            //此时二者在NULL处相遇，即返回NULL，也就是无交点\n            A = A != NULL ? A->next : headB;\n            B = B != NULL ? B->next : headA;\n        }\n        return A;\n    }\n};\n```\n时间复杂度为O（N），遍历完链表A和B","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"last-Battle":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916257585","body":"## 思路\n\n## 关键点\n\n-  从个位开始往前面推算，每计算一位就放入vector结果中，并通过carry维护进位，最后再反转\n- 注意数组下标和k的位数要保证有效，防止越界\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int carry = 0, len = num.size() - 1;\n        int tmparr = 0, tmpk = 0, sum = 0;\n        int i = len;\n        while (i >= 0 || k != 0) {\n            tmparr = 0;\n            tmpk = 0;\n            if (k != 0) {\n                tmpk = k % 10;\n                k /= 10;\n            }\n            if (i >= 0) {\n                tmparr = num[i];\n                --i;\n            }\n\n            sum = tmparr + tmpk + carry;\n            carry = sum / 10;\n            res.emplace_back(sum % 10);    \n        }\n        \n        if (carry) {\n            res.emplace_back(carry);\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917416457","body":"## 思路\n\n## 关键点\n\n-  双指针，每个下标分别往前后两个方向遍历直到找到第一个期待的c为止，找不到就认为距离最大\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> res(s.length(), 0);\n        for (int i = 0; i < s.length(); ++i) {\n            int start = i - 1, end = i + 1;\n            int ts = INT_MAX, te = INT_MAX;\n            if (s[i] == c) {\n                res[i] = 0;\n            } else {\n                while (start >= 0 && s[start] != c) {\n                    --start;\n                }\n                ts = start < 0 ? ts : abs(i - start);\n\n                while (end < s.length() && s[end] != c) {\n                    ++end;\n                }\n                te = end >= s.length() ? te : abs(i - end);\n\n                res[i] = min(ts, te);\n            }\n        }\n\n        return res;\n    }\n};\n\n```\n\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917434217","body":"## 思路\n\n## 关键点\n\n-  使用一个辅助栈进行模拟操作\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        size = maxSize;\n    }\n    \n    void push(int x) {\n        if (realst.size() < size) {\n            realst.push(x);\n        }\n    }\n    \n    int pop() {\n        if (realst.empty()) {\n            return -1;\n        }\n\n        auto res = realst.top();\n        realst.pop();\n        return res;\n    }\n    \n    void increment(int k, int val) {\n        while (realst.size() > k) {\n            helperst.push(realst.top());\n            realst.pop();\n        }\n\n        while (!realst.empty()) {\n            helperst.push(realst.top() + val);\n            realst.pop();\n        }\n\n        while (!helperst.empty()) {\n            realst.push(helperst.top());\n            helperst.pop();\n        }\n    }\n\nprivate:\n    int size;\n    stack<int> realst;\n    stack<int> helperst;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n```\n\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918029083","body":"## 思路\n\n## 关键点\n\n-  维护2个栈，1个是数字栈记录重复次数，1个是字符串栈记录曾经维护好的字符串\n- 遇到\"[\"就入2个栈\n- 遇到\"]\"就结算\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res;\n        stack<int> stN;\n        stack<string> stS;\n        int num = 0;\n\n        for (auto& v : s) {\n            // 持续处理数字\n            if (isGigit(v)) {\n                num = num * 10 + (v - '0');\n            } \n            // 遇到 \"[\" 就把维护的数字和字符串各自入栈\n            else if (v == '[') {\n                cout << \"num: \" << num << endl;\n                stN.push(num);\n                num = 0;\n\n                stS.push(res);\n                res.clear();\n            } else if (v == ']') {\n                // 重复次数\n                int repeatTimes = stN.top();\n                stN.pop();\n\n                string tmp = stS.top();\n                stS.pop();\n                for (int i = 1; i <= repeatTimes; ++i) {\n                    tmp += res;\n                }\n                \n                res = tmp;\n            } \n            // 维护当前处理到的字符串\n            else {\n                res += v;\n            }\n        }\n\n        return res;\n    }\n\n    bool isGigit(const char& c) {\n        return c >= '0' && c <= '9';\n    }\n};\n\n```\n\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918355969","body":"## 思路\n\n## 关键点\n\n-  用2个栈去模拟\n- push就往realst里面搞\n- pop和peek就先看helperst，不为空就搞helperst，为空就把realst里面的元素都搞到helperst里面\n- empty同时判断realst和helperst是否都为空\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n    \n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        realst.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        int res;\n        if (helperst.empty()) {\n            while (!realst.empty()) {\n                helperst.push(realst.top());\n                realst.pop();\n            }\n        }\n        res = helperst.top();\n        helperst.pop();\n\n        return res;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if (helperst.empty()) {\n            while (!realst.empty()) {\n                helperst.push(realst.top());\n                realst.pop();\n            }\n        }\n\n        return helperst.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return realst.empty() && helperst.empty();\n    }\nprivate:\n    stack<int> realst;\n    stack<int> helperst;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n\n```\n\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920055794","body":"## 思路\n\n## 关键点\n\n-  这题没有思路，看了大半天的单调栈，自己尝试模仿着写的\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        if (arr.empty()) {\n            return 0;\n        }\n        \n        stack<int> monotonicStack;\n        \n        monotonicStack.push(arr[0]);\n        for (int i = 1; i < arr.size(); ++i) {\n            if (!monotonicStack.empty() && monotonicStack.top() > arr[i]) {\n                auto maxtop = monotonicStack.top();\n                monotonicStack.pop();\n                \n                while (!monotonicStack.empty() && monotonicStack.top() > arr[i]) {\n                    monotonicStack.pop();\n                }\n                \n                monotonicStack.push(maxtop);\n                \n            } else {\n                monotonicStack.push(arr[i]);\n            }\n        }\n        \n        return monotonicStack.size();\n    }\n};\n\n```\n\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920164914","body":"## 思路\n\n## 关键点\n\n- 先求出链表总长，防止k不合法导致越界，最终有效k为k % 链表长度 \n- 快慢指针，快指针先走k步，然后快慢指针同时往后移，最后更新一下各种指针的指向\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr) {\n            return head;\n        }\n\n        int len = 0;\n        auto tmp = head;\n        while (tmp != nullptr) {\n            tmp = tmp->next;\n            ++len;\n        }\n\n        k %= len;\n\n        auto slow = head, fast = head;\n        while (k--) {\n            fast = fast->next;\n        }\n        while (fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n\n        fast->next = head;\n        auto res = slow->next;\n        slow->next = nullptr;\n\n        return res;\n    }\n};\n\n```\n\n\n## 复杂度分析\n\n令 n 为链表长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921543120","body":"## 思路\r\n\r\n## 关键点\r\n- 画图、画图、画图！不画图真难想！\r\n\r\n```\r\n/*\r\nd -> 1 -> 2 -> 3 -> 4\r\n     n1   n2\r\n\r\nd    1 -> 2 -> 3 -> 4\r\n|    n1   n2\r\n|         ^\r\n|         | \r\n----------- \r\n\r\n\r\nd    1    2 -> 3 -> 4\r\n|    n1   n2   ^\r\n|    |    ^    |\r\n|    |    |    |\r\n-----|-----    |\r\n     |         |\r\n      ---------  \r\n\r\n\r\nd    1 <- 2 -> 3 -> 4\r\n|    n1   n2   ^\r\n|    |    ^    |\r\n|    |    |    |\r\n-----|-----    |\r\n     |         |\r\n      ---------        \r\n\r\n\r\nd -> 2 -> 1 -> 3 -> 4\r\n         cur   n1   n2\r\n\r\n*/         \r\n```\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n\r\n      \r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        \r\n        auto dummy = new ListNode(-1);\r\n        dummy->next = head;\r\n        auto cur = dummy;\r\n        \r\n        while (cur->next != nullptr && cur->next->next != nullptr) {\r\n            auto n1 = cur->next;\r\n            auto n2 = cur->next->next;\r\n            \r\n            cur->next = n2;\r\n            n1->next = n2->next;\r\n            n2->next = n1;\r\n            cur = n1;\r\n            \r\n        }\r\n        \r\n        return dummy->next;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n## 复杂度分析\r\n\r\n令 n 为链表长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922282541","body":"## 思路\n\n## 关键点\n\n-  分治，注意递归的base case，最开始没有写\n```C++\nif (head->next == nullptr) {\n    return new TreeNode(head->val);\n}\n```\n搞了好久……\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr) {\n            return nullptr;\n        }\n        \n        if (head->next == nullptr) {\n            return new TreeNode(head->val);\n        }\n        \n        auto res = getMid(head);\n        if (res.second == nullptr) {\n            return nullptr;\n        }\n        \n        auto cur = res.second;\n        auto nexthead = res.second->next;\n        res.first->next = nullptr;\n        \n        TreeNode* root = new TreeNode(cur->val);\n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(nexthead);\n        \n        return root;\n    }\n    \n    pair<ListNode*, ListNode*> getMid(ListNode* head) {\n        auto slow = head, fast = head;\n        auto prev = slow;\n        while (fast != nullptr && fast->next != nullptr) {\n            prev = slow;\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        return {prev, slow};\n    }\n};\n\n```\n\n\n## 复杂度分析\n\n令 n 为链表长度。\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922400437","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  长链表先往后走，直到和短链表长度一样为止，然后2个链表分别往后走\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (headA == nullptr || headB == nullptr) {\r\n            return nullptr;\r\n        }\r\n\r\n        auto lenA = getLen(headA);\r\n        auto lenB = getLen(headB);\r\n        auto diff = abs(lenA - lenB);\r\n\r\n        if (lenA > lenB) {\r\n            while (diff--) {\r\n                headA = headA->next;\r\n            }\r\n        } else {\r\n            while (diff--) {\r\n                headB = headB->next;\r\n            }\r\n        }\r\n\r\n        while (headA != nullptr && headB != nullptr) {\r\n            if (headA == headB) {\r\n                return headA;\r\n            }\r\n\r\n            headA = headA->next;\r\n            headB = headB->next;\r\n        }\r\n\r\n        return nullptr;\r\n    }\r\n\r\n    int getLen(ListNode* head) {\r\n        int res = 0;\r\n        while (head != nullptr) {\r\n            ++res;\r\n            head = head->next;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n## 复杂度分析\r\n\r\n令 n 为链表长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mm12344":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916262628","body":"## 思路\r\n简单数值解法\r\n## 代码\r\n\r\n```py3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        x = 0\r\n        ans=[]\r\n        if len(num)==1 and num[0]==0 and k==0: return[0]\r\n        for i in num:\r\n            x = x*10 + i\r\n        x = x + k\r\n        while x!=0:\r\n            ans.append(x%10)\r\n            x=x//10\r\n        return ans[::-1]\r\n```\r\n\r\n## 复杂度\r\n时间：O(2n)\r\n空间：O(ans)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917430027","body":"## 思路\r\n\r\n思路一 找到每一个c的位置，构成一个数组cIdx\r\n遍历字符串，每个下标i处在数组内容中找一个离i最近的数，并返回i-数的绝对值 min(abs(i*len(cidx)-cI’d))\r\n\r\n## 代码\r\n```py3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        cidx= [i for i in range(len(s)) if s[i]==c]\r\n        return [min(abs(i-j) for j in cidx) for i in range(len(s))]\r\n```\r\n## 复杂度\r\n时间：n*k, n为字符串s的长度，k为c在s中出现的次数\r\n空间：k","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661759","body":"## 代码\r\n```py3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.delta = []\r\n        self.len = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.maxSize:\r\n            self.stack.append(x)\r\n            self.delta.append(0)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.len:\r\n            return -1\r\n        self.len -= 1\r\n        a = self.stack.pop()\r\n        d = self.delta.pop()\r\n        if self.len:\r\n            self.delta[-1] += d\r\n        return a + d\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if not self.len:\r\n            return\r\n        if self.len < k:\r\n            self.delta[-1] += val\r\n        else:\r\n            self.delta[k - 1] += val\r\n```\r\n\r\n## 复杂度\r\n时间o1\r\n空间o(maxsize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918327805","body":"占坑，正在编写自己的思路及代码\r\n```py3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919288356","body":"## 思路\r\n参考题解\r\n\r\n## 代码\r\n```py3\r\n\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"I\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.help_stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack)\r\n\r\n```\r\n## 复杂度\r\n\r\nN为数组长度。\r\n\r\n时间复杂度：$O(1)\r\n空间复杂度：$O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920149076","body":"## 思路\r\n最简单的，利用计数唯一性和排序唯一性来分桶\r\n\r\n## 代码\r\n```py3\r\n\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        ans = 0\r\n\r\n        for a, b in zip(arr, sorted(arr)): #组合两个元素个数相同的数组，一一对应组成元组列表\r\n            count_a[a] += 1\r\n            count_b[b] += 1\r\n            if count_a == count_b: ans += 1\r\n\r\n        return ans\r\n\r\n```\r\n\r\n## 复杂度\r\n时间： o(n^2),两个数组间比较也是o(N)\r\n空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921029068","body":"## 代码\r\n```py3\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        # 双指针\r\n        if head:\r\n            p1 = head\r\n            p2 = head\r\n            count = 1\r\n            i = 0\r\n            while i < k:\r\n                if p2.next:\r\n                    count += 1\r\n                    p2 = p2.next\r\n                else:\r\n                    k = k % count\r\n                    i = -1\r\n                    p2 = head\r\n                i += 1\r\n\r\n            while p2.next:\r\n                p1 = p1.next\r\n                p2 = p2.next\r\n\r\n            if p1.next:\r\n                tmp = p1.next\r\n            else:\r\n                return head\r\n            p1.next = None\r\n            p2.next = head\r\n            return tmp\r\n```\r\n## 复杂度\r\n时间：O(N)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921908609","body":"## 代码\n```py3\nif not head or not head.next: return head\n    ans = ListNode()\n    ans.next = head.next\n    pre = ans\n    while head and head.next:\n        next = head.next\n        n_next = next.next\n\n        next.next = head\n        pre.next = next\n        head.next = n_next\n        # 更新指针\n        pre = head\n        head = n_next\n    return ans.next\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922329772","body":"# 代码\n\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzehan123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916267006","body":"\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> ans = new LinkedList<>();\n        int temp=0;\n        for (int i = num.length-1; i >=0 ; i--) {\n            temp = k%10;\n            k/=10;\n            if (temp+num[i]>=10){\n                k++;\n                ans.addFirst((temp+num[i])%10);\n            }else {\n                ans.addFirst(temp+num[i]);\n            }\n            if (i==0){\n                while (k>0){\n                    temp = k%10;\n                    k/=10;\n                    ans.addFirst(temp);\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(max(n,logk))$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917310599","body":"\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\npublic int[] shortestToChar(String s, char c) {\n        int l = Integer.MIN_VALUE + s.length() + 1;\n        int r = s.indexOf(c);\n        int[] res = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            if (i <=  r){\n                res[i] = Math.min(i - l, r - i);\n            }else {\n                l = r;\n                r = s.indexOf(c, l + 1) == -1 ? Integer.MAX_VALUE : s.indexOf(c, l + 1);\n                res[i] = Math.min(i - l, r - i);\n            }\n        }\n        return res;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917445738","body":"\n## 思路\n\n数组模拟\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass CustomStack {\n\n    int[] data;\n    int head;\n\n    public CustomStack(int maxSize) {\n\n        data = new int[maxSize];\n        head = -1;\n    }\n    \n    public void push(int x) {\n\n        if (head == data.length - 1)\n            return;\n            \n        data[++head] = x;\n    }\n    \n    public int pop() {\n\n        if (head == -1)\n            return -1;\n\n        return data[head--];\n    }\n    \n    public void increment(int k, int val) {\n\n        for (int i = 0; i < Math.min(k, head + 1); i++)\n            data[i] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917703878","body":"\n\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    int index = 0;\n    public String decodeString(String s) {\n        // write your code here\n        if (s.length() == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        int repeat = 0;\n\n        while (index < s.length()) {\n            char c = s.charAt(index);\n            if (c == '[') {\n                index++;\n                String sub = decodeString(s);\n                for (int i = 0; i < repeat; i++) {\n                    sb.append(sub);\n                }\n                repeat = 0;\n                index++;\n            } else if (c == ']') {\n                return sb.toString();\n            } else if (Character.isDigit(c)) {\n                repeat = repeat * 10 + c - '0';\n                index++;\n            } else {\n                sb.append(c);\n                index++;\n            }\n        }\n\n        return sb.toString();\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918694247","body":"\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass MyQueue {\n\n    //定义栈\n    private Stack<Integer> stackA;\n    private Stack<Integer> stackB;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stackA = new Stack<Integer>();\n        stackB = new Stack<Integer>();\n    }\n    \n    /** Push element x to the back of queue. */\n    //栈A入栈\n    public void push(int x) {\n        stackA.push(x);\n\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    //栈A出栈到栈B，栈B出栈\n    public int pop() {\n        if(stackB.isEmpty()) {\n            while(!stackA.isEmpty()){\n                stackB.push(stackA.pop());\n            }\n        }\n        return stackB.pop();\n    }\n    \n    //栈A出栈到栈B，栈B出栈\n    /** Get the front element. */\n    public int peek() {\n        if(stackB.isEmpty()) {\n            while(!stackA.isEmpty()){\n                stackB.push(stackA.pop());\n            }\n        }\n        return stackB.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    //栈A和栈B都为空\n    public boolean empty() {\n        if(stackA.isEmpty() && stackB.isEmpty()){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919596531","body":"\n## 题目地址(768. 最多能完成排序的块 II)\n\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n\n## 题目描述\n\n```\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\n\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n示例 1:\n\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n\n\n示例 2:\n\n输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n\n\n注意:\n\narr的长度在[1, 2000]之间。\narr[i]的大小在[0, 10**8]之间。\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        int[] forward = new int[n];\n        int[] backward = new int[n];\n\n        forward[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n            forward[i] = Math.max(forward[i-1], arr[i]);\n        }\n\n        backward[n - 1] = arr[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            backward[i] = Math.min(backward[i + 1], arr[i]);\n        }\n\n        int res = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (forward[i] <= backward[i + 1]) res++;\n        }\n\n        return res + 1;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920206404","body":"\n## 题目地址(61. Rotate List)\n\nhttps://leetcode-cn.com/problems/rotate-list/\n\n## 题目描述\n\n```\nGiven the head of a linked list, rotate the list to the right by k places.\n\n \n\nExample 1:\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n\n\nExample 2:\n\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n\n\n \n\nConstraints:\n\nThe number of nodes in the list is in the range [0, 500].\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head == null){\n            return null;\n        }\n        ListNode slow = head;\n        int count = 1;\n        while (slow.next != null){\n            count ++;\n            slow = slow.next;\n        }\n        // 尾结点\n        ListNode tail = slow;\n        k = k % count;\n        if(k == 0){\n            return head;\n        }\n        slow = head;\n        ListNode fast = head;\n        for(int i=0;i<k;i++){\n            fast = fast.next;\n        }\n        while (fast.next != null){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        ListNode newHead = slow.next;\n        tail.next = head;\n        slow.next = null;\n        return newHead;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921231637","body":"\n## 题目地址(24. 两两交换链表中的节点)\n\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n## 题目描述\n\n```\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n \n\n示例 1：\n\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n\n示例 2：\n\n输入：head = []\n输出：[]\n\n\n示例 3：\n\n输入：head = [1]\n输出：[1]\n\n\n \n\n提示：\n\n链表中节点的数目在范围 [0, 100] 内\n0 <= Node.val <= 100\n\n \n\n进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) \n    {\n        if(head==null||head.next==null)\n            return head;\n        ListNode myHead=new ListNode();\n        myHead.next=head;\n        ListNode p=myHead;\n        while(p!=null&&p.next!=null&&p.next.next!=null)\n        {\n            var x=p.next;\n            var y=p.next.next;\n            x.next=y.next;\n            y.next=x;\n            p.next=y;\n            p=x;\n        }\n        return myHead.next;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922031265","body":"\n## 题目地址(109. 有序链表转换二叉搜索树)\n\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\n\n## 题目描述\n\n```\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n示例:\n\n给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        else if(head.next == null) return new TreeNode(head.val);\n        ListNode pre = head;\n        ListNode p = pre.next;\n        ListNode q = p.next;\n        //找到链表的中点p\n        while(q!=null && q.next!=null){\n            pre = pre.next;\n            p = pre.next;\n            q = q.next.next;\n        }\n        //将中点左边的链表分开\n        pre.next = null;\n        TreeNode root = new TreeNode(p.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(p.next);\n        return root;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922361774","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n示例 2：\n\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n0 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]\n\n \n\n进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA;\n        ListNode pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n        // Note: In the case lists do not intersect, the pointers for A and B\n        // will still line up in the 2nd iteration, just that here won't be\n        // a common node down the list and both will reach their respective ends\n        // at the same time. So pA will be NULL in that case.\n}\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erik7777777":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916274001","body":"## 思路 \n从低位往高位顺着加\n### 代码 ： java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int cur = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry;\n            k = k > 0 ? k / 10 : 0;\n            i = i >= 0 ? i - 1 : -1;\n            carry = cur / 10;\n            cur = cur % 10;\n            res.add(cur);\n        }\n        if (carry == 1) res.add(carry);\n        Collections.reverse(res);\n        return res;\n    }\n```\n\n### 复杂度分析\n - 时间复杂度：O(n)，其中 n 为数组的长度\n - 空间复杂度：O(1)\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918519983","body":"### 思路\n2 stacks \n \n## 代码 \n```java\nclass MyQueue {\n    Deque<Integer> push;\n    Deque<Integer> pop;\n    int size;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        push = new ArrayDeque<>();\n        pop = new ArrayDeque<>();\n        size = 0;\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        push.push(x);\n        size++;\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        peek();\n        size--;\n        return pop.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (!pop.isEmpty()) {\n            return pop.peek();\n        }\n        while (!push.isEmpty()) pop.push(push.pop());\n        return pop.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return size == 0;\n    }\n}\n```\n\n### 复杂度\npush: O(1)\npeek: O(n)\npop: O(n)\nsize: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920980912","body":"### 思路\n将链表头尾相连 再从头开始找 第size（总长度） - k % size（旋转的node， 或者说去找将成为新root node的node）\n\n## 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return head;\n        ListNode tail = head;\n        int size = 1;\n        while (tail.next != null) {\n            tail = tail.next;\n            size++;\n        }\n        k = k % size;\n        if (k == 0) return head;\n        tail.next = head;\n        k = size - k;\n        while (k > 0) {\n            tail = tail.next;\n            k--;\n        }\n        ListNode newHead = tail.next;\n        tail.next = null;\n        return newHead;\n    }\n}\n```\n### 复杂度\ntime O(n)\nspace O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921452534","body":"### 思路\niterate or recursion， use dummy head and swap \n\n### 代码\n\n```java\npublic ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode dummy = new ListNode();\n        ListNode prev = dummy;\n        dummy.next = head;\n        while (head != null && head.next != null) {\n            ListNode next = head.next.next;\n            prev.next = head.next;\n            head.next.next = head;\n            head.next = null;\n            prev = head;\n            head = next;\n        }\n        return dummy.next;\n    }\n```\n\n### 复杂度\ntime O(n)   space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922016356","body":"### 思路\n Recursively find the mid point of the list, and break the list into two parts, use the smaller part as left node and the larger part as the right node according to the definition of the BST.\n\n### 代码\n\n```java\npublic TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n        ListNode prev = null;\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        prev.next = null;\n        ListNode right = slow.next;\n        TreeNode root = new TreeNode(slow.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(right);\n        return root;\n    }\n```\n\n### 复杂度\ntime : O(nlogn) n(elements in every layer) * logn(number of layers). \nspace : O(height of stack/tree) -> O(logn)\n\n### idea\nuse a list to store all the element in the linked list : cost O(n) time\nuse list.get(i) to retrieve the element in the middle of the list : cost O(1)\n\nin this way our time complexity will be around O(n) and space complexity will be around O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922405692","body":"### 思路\nstraightforward way is to use a set to record, when we find the first node we can't add to set, it is the start node of the intersection part\n\n### 代码\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        Set<ListNode> visited = new HashSet<>();\n        while (headA != null || headB != null) {\n            if (headA != null && !visited.add(headA)) return headA;\n            if (headB != null && !visited.add(headB)) return headB;\n            headA = headA == null ? headA : headA.next;\n            headB = headB == null ? headB : headB.next;\n        }\n        return null;\n    }\n```\n\n### 复杂度\ntime : O(m + n)  space : strictly the same as time O(m + n)   m, n are the length of two lists \n\n### idea \n#### we can do better, use math to deal with it. the difference of length of two list is the difference of the different part of lists\n#### denote the length into two parts \n#### different + same:\n#### a + c \n#### b + c\n#### when we know the value of  |a - b|, we can find the first node of the intersection part\n#### a + c + b = b + c + a","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yachtcoder":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916275711","body":"\n从低到高递归处理每一位以及前面的进位\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num = num[::-1]\n        k = [int(x) for x in str(k)][::-1]\n        ret = []\n        def add1(l1, l2, carry, idx):\n            nonlocal ret\n            if carry == 0 and idx >= len(l1) and idx >= len(l2): return\n            n1 = 0 if idx >= len(l1) else l1[idx]\n            n2 = 0 if idx >= len(l2) else l2[idx]\n            ret.append((n1+n2+carry) % 10)\n            carry = (n1+n2+carry)//10\n            add1(l1, l2, carry, idx+1)\n        add1(num, k, 0, 0)\n        return ret[::-1]\n```\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917022162","body":"两次遍历 左到右然后右到左\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        ans = [0]*len(s)\r\n        lastc = float('inf')\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                ans[i] = 0\r\n                lastc = i\r\n            else:\r\n                ans[i] = abs(lastc - i)\r\n        for i in range(len(s)-1, -1, -1):\r\n            ch = s[i]\r\n            if ch == c:\r\n                ans[i] = 0\r\n                lastc = i\r\n            else:\r\n                ans[i] = min(ans[i], abs(lastc - i))\r\n        return ans\r\n```\r\nTime: O(n)\r\nSpace: Constant with O(n) for answer","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917477476","body":"Use a deque to pop and append from the left side. And a helper stack to temporarily hold the *k* popped item.\nTime O(n) for inc, O(1) for push/pop\nSpace O(n)\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.stack = deque()\n        self.max = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        return self.stack.pop() if self.stack else -1\n\n    def increment(self, k: int, val: int) -> None:\n        helper = []\n        while k > 0 and self.stack:\n            helper.append(self.stack.popleft())\n            k -= 1\n        while helper:\n            self.stack.appendleft(helper.pop()+val)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917682104","body":"Use a stack to process every pair of brackets. \nTokenization is a bit hacky. Processing each char might be more concise.\nTime: O(n^2) because even though each char is processed once, manipulating the string is O(n) each time.\nSpace: O(n)\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        toks = []\n        s = list(s)\n        for i in range(1, len(s)):\n            prev = s[i-1]\n            if prev[-1].isalpha() != s[i][0].isalpha():\n                s[i]= \" \"+s[i]\n        s = ''.join(s).replace(\"[\", \" [ \").replace(\"]\", \" ] \")\n        for t in s.split():\n            if t == \"]\":\n                st = \"\"\n                n = 0\n                while stack:\n                    c = stack.pop()\n                    if c == \"[\": break\n                    st = c+st\n                n = int(stack.pop())\n                stack.append(st*n)\n            else:\n                stack.append(t)\n        return ''.join(stack)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918353922","body":"Use a helper stack and data stack. \r\nThe data stack handles push() in O(1).\r\nHelper stack handles pop() and peek() by holding data in a reverse order we push to the data stack.\r\nWe only load the helper stack when it is empty. \r\nTime: amortized O(1)\r\nSpace: O(n)\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.data = []\r\n        self.helper = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.data.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if len(self.helper) == 0:\r\n            self.d2h()\r\n        return self.helper.pop()\r\n\r\n    def d2h(self):\r\n        while self.data:\r\n            self.helper.append(self.data.pop())\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if len(self.helper) == 0:\r\n            self.d2h()\r\n        return self.helper[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.data) == 0 and len(self.helper) == 0\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919307710","body":"Top down DP: Recursion + Memo\r\nWe partition a list into left and right. A partition is valid if max(left) <= min(right).\r\nOnce we find a partition we recursively partition left and right and accumulate the number of partitions.\r\nWith memoization, at most we have n^2 partitions.\r\nTime: O(n^2)\r\nSpace: O(n^2)\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        @lru_cache(None)\r\n        def partition(i, j): \r\n            cnt = 1\r\n            for k in range(i+1, j):\r\n                left = arr[i:k]\r\n                right = arr[k:j]\r\n                if max(left) <= min(right):\r\n                    cnt = max(cnt, partition(i, k) + partition(k, j))\r\n                    break\r\n            return cnt        \r\n        return partition(0, len(arr))\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920333935","body":"Two pointers. \nSimilar to the 'find the kth node from backward problem'.\n\n1. find the length of the list N and mod k with it.\n2. faster pointer move k steps ahead then start moving the slow pointer.\n3. when the faster pointer reaches to the last node, the slow pointer will be pointing to the kth node from backward.\n4. break the list from slow.next and use slow.next as new head then join the old head.\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return None\n        p1, p2 = head, head\n        N = 0\n        while p2:\n            p2 = p2.next\n            N += 1\n\n        k %= N\n        if k == 0: return head\n\n        p2 = head\n        while k > 0:\n            p2 = p2.next\n            k -= 1\n        \n        while p2.next:\n            p2 = p2.next\n            p1 = p1.next\n        \n        newhead = p1.next\n        p1.next = None\n        p2.next = head\n        return newhead\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921041950","body":"Use a dummy header to help swapping, swap each pair then move the pointers until there's no more pair to swap.\r\nTime: O(n)\r\nSpace: O(1)\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head: return None\r\n        dh = ListNode(next=head)\r\n        p0 = dh\r\n        p1 = head\r\n        p2 = head.next\r\n        while p1 and p2:\r\n            tmp = p2.next\r\n            p0.next = p2\r\n            p2.next = p1\r\n            p1.next = tmp\r\n            p0 = p1\r\n            p1 = tmp\r\n            p2 = tmp.next if tmp else None\r\n        return dh.next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921923919","body":"1. Find the median node of the list with fast & slow pointers.\r\n2. Break the list into three parts: left, median, and right\r\n3. Use the median node as root, build two sub BST recursively on left and right.\r\n\r\nTime: O(n)\r\nSpace: O(n) due to the recursion stack\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def build(head):\r\n            if not head: return None\r\n            if not head.next: return TreeNode(val = head.val)\r\n            pre, fast, slow = head, head, head\r\n            while fast and fast.next:\r\n                fast = fast.next.next\r\n                pre = slow\r\n                slow = slow.next\r\n            median = slow\r\n            right = slow.next\r\n            pre.next = None\r\n            return TreeNode(val = median.val, left = build(head), right = build(right))\r\n        return build(head)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922339264","body":"Use a set to store the node id of one list then check the other list and return the first one in common.\r\nTime O(n+m)\r\nSpace O(n)\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        ids = set()\r\n        while headA:\r\n            ids.add(id(headA))\r\n            headA = headA.next\r\n        while headB:\r\n            if id(headB) in ids:\r\n                return headB\r\n            headB = headB.next\r\n        return None\r\n```\r\n\r\nO(1) space idea: \r\nIf two list intersects, they have a common suffix. \r\nAssume the longer list have a length of la, the shorter one with a length of lb, then by moving the longer list (la-lb) steps ahead then move the two together, two pointer will meet at the first common node.\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        la, lb = 0, 0\r\n        ha, hb = headA, headB\r\n        while headA:\r\n            la += 1\r\n            headA = headA.next\r\n        while headB:\r\n            lb += 1\r\n            headB = headB.next\r\n            \r\n        headA, headB = ha, hb            \r\n        if la > lb:\r\n            headA, headB = headB, headA\r\n        \r\n        k = abs(la-lb)\r\n        while k > 0:\r\n            headB = headB.next\r\n            k -= 1\r\n        while headA and headB:\r\n            if headA == headB:\r\n                return headA\r\n            headA = headA.next\r\n            headB = headB.next\r\n        return None\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922501628","body":"Fast and slow pointer, or the Hare and Tortoise algorithm. \n1. Fast pointer moves 2 steps a time, slow pointer 1 step a time.\n2. If the two meet then there's cycle. \n3. Once they meet, move the fast pointer back to the head, then move it 1 step a time. \n4. When the two meet again, they meet at the entry of the cycle.\nTime: O(n)\nSpace: O(1)\n```python\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow: break\n        if fast is None or fast.next is None: return None\n        fast = head\n        while slow != fast:\n            fast = fast.next\n            slow = slow.next\n        return slow\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chang-you":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916277083","body":"## 代码\r\nJava:\r\n\r\n```java\r\n// Space = O(n) / O(1) 数组/k长度\r\n// Time = O(Math.max(n, log(k)) / O(1): num或k长度中较大的\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //用LinkedList不断从头将位数和加入index 0\r\n        List<Integer> res = new LinkedList<>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            //从末尾往前扫，加和取余的值\r\n            res.add(0, (num[i] + k) % 10);\r\n            //更新k存进位carry\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        \r\n        // post-possing: 处理k位数大于num的情况剩下的部分\r\n        // Time = O(log(k))\r\n        while (k > 0) {\r\n            res.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n##  复杂度分析\r\nSpace = O(n) / O(1) ：数组/k长度\r\n\r\nTime = O(Math.max(n, log(k)) / O(1): num或k长度中较大的","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917052225","body":"## 思路\r\n\r\n我们要找到左右最短距离，所以从左右两边都要分别遍历一遍，比较更新取二者较小值。\r\n\r\n## 关键点 \r\npos初始值的initialize。  \r\n由于我们要取最小值，所以要取一个较大数的初始值，  \r\n因为`res[i] = i - pos`，所以pos如果initialize为Integer MIN_VALUE, i-Integer MIN_VALUE会越界。  \r\n如果取Integer MAX_VALUE，最小值始终会是这个。  \r\n所以我们取数组长度的最大值稍大的即可，即-s.length();\r\n\r\n## 代码\r\nJava\r\n```java\r\n// Time = O(n)\r\n// Space = O(n)\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int n = S.length();\r\n        int[] res = new int[n];\r\n        int pos = -n;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S.charAt(i) == C) {\r\n                pos = i;\r\n            }\r\n            res[i] = i - pos;\r\n        }\r\n\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) {\r\n                pos = i;\r\n            }\r\n            res[i] = Math.min(res[i], Math.abs(i - pos));\r\n        }\r\n\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n## 复杂度\r\nTime=O(n) 左右两个for loop \r\n\r\nSpace=O(n) 开辟String长度的数组。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917484844","body":"## 思路\n数组模拟栈 \n\n## Java代码\n\n```java\nclass CustomStack {\n    int max;\n    int[] increStack;\n    int idx;\n    \n    public CustomStack(int maxSize) {\n        increStack = new int[maxSize];\n        max = maxSize;\n        idx = 0;\n    }\n    \n    public void push(int x) {\n        if (idx == max) {\n            return;\n        } \n        increStack[idx++] = x;\n    }\n    \n    public int pop() {\n        if (idx == 0) {\n            return -1;\n        }\n        return increStack[--idx];\n    }\n    \n    public void increment(int k, int val) {\n        k = Math.min(k, idx);\n        for(int i = 0; i < k; i++) {\n            increStack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n## 复杂度\nSpace: O(n)   \nTime: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917712493","body":"## 思路\n递归模型\n每次递归遇到\"]“终止，ans记录返回的string, end 记录s的终止位置。\n\n## java code\n```java\nclass Solution {\n    public String decodeString(String s) {\n        char[] str = s.toCharArray();\n\t\treturn process(str, 0).ans;\n\t}\n\n\tpublic static class Info {\n\t\tpublic String ans;\n\t\tpublic int end;\n\n\t\tpublic Info(String a, int e) {\n\t\t\tans = a;\n\t\t\tend = e; // 哪个位置停\n\t\t}\n\t}\n\n\t// s[i....]  何时停？遇到   ']'  或者遇到 s的终止位置，停止\n\t// 返回Info (包含ans(返回的string) 和 end(算到了哪))\n\tpublic static Info process(char[] s, int i) {\n\t\tStringBuilder ans = new StringBuilder();\n\t\tint times = 0;\n\t\twhile (i < s.length && s[i] != ']') {\n\t\t\tif ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {\n\t\t\t\tans.append(s[i++]);\n\t\t\t} else if (s[i] >= '0' && s[i] <= '9') {\n                //遇到数字 更新times\n\t\t\t\ttimes = times * 10 + s[i++] - '0';\n\t\t\t} else { // str[index] = '['\n\t\t\t\tInfo next = process(s, i + 1);\n\t\t\t\tans.append(timesString(times, next.ans));\n\t\t\t\ttimes = 0;\n\t\t\t\ti = next.end + 1;\n\t\t\t}\n\t\t}\n\t\treturn new Info(ans.toString(), i);\n\t}\n\n\tpublic static String timesString(int times, String str) {\n\t\tStringBuilder ans = new StringBuilder();\n\t\tfor (int i = 0; i < times; i++) {\n\t\t\tans.append(str);\n\t\t}\n\t\treturn ans.toString();\n\t}\n}\n\n```\n\n## 复杂度\nTime = O(n)  \nSpace = O(n)  \nn为String长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918403687","body":"## 思路\n使用两个Stack:  \ns1:代表的是没进行处理的stack, aka queue的反方向. \ns2: 处理过的stack, 和queue方向一样. \n\n## Java代码\n```java\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n        \n    \n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (!stack2.isEmpty()) {\n            return stack2.pop();\n        } else {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n            return stack2.pop();\n        }\n            \n    }\n    \n    /** Get t he front element. */\n    public int peek() {\n        if (!stack2.isEmpty()) {\n            return stack2.peek();\n        } else {\n            while (!stack1.isEmpty()) {\n                stack2.push((stack1.pop()));\n            }\n            return stack2.peek();\n        }\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n## 复杂度\n\nTime: \npush: O(1) \npop:  O(1)\npeek: O(1) \nempty: O(1)\n\nSpace = O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919869546","body":"## 思路\n只要有序，我们就可以chunk单个数字。  \n否则如果某一段无序，我们必须chunk那一整段。  \n如果有序：从左往右从小到大，从右往左从大到小  \n假设有一个max[], 记录从左往右遍历过程中的最大值：  \n- 那么如果有序，max[]会递增（规律顺序和原数组一致）  \n- 反之，max[]中必有相等的值  \n\n从右往左遍历，原数组从右往左从大到小，  \n- 有序的部分满足：max[i-1]<=min，那么我们可以单独chunk单个数字->res++\n- 顺序颠倒的部分则不满足，我们要chunk一整段，直到遇到再次满足max[i-1]<=min前，res不更新, 但min持续更新。  \n\n## Java代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        if (arr.length < 2) return arr.length;\n        \n        int[] max = new int[arr.length];\n        max[0] = arr[0];\n        for (int i = 1; i < max.length; i++) {\n            max[i] = Math.max(arr[i], max[i - 1]);\n        }\n        \n        int res = 1;\n        int min = arr[arr.length - 1];\n        for (int i = arr.length - 1; i > 0; i--) {\n            min = Math.min(min, arr[i]);\n            if (max[i - 1] <= min) {\n                res++;\n            }\n        }\n        \n        return res;\n    }\n}\n```\n\n## 复杂度\nSpace = O(n) - 开辟arr大小数组  \nTime = O(n) - traverse two times from both ways.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920691162","body":"# 思路\nWe create a cycle at the appropriate spot in which we can break the list elsewhere to \"simulate\" a rotation of elements. We return the reformatted list's head.\n\n# Java Code\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n         if (head == null || head.next == null) return head;\n        ListNode index = head;\n        int len = 1;\n        while (index.next != null) {\n          index = index.next;\n          len++;\n        }\n        index.next = head;\n        for (int i = 1; i < len - k % len; i++) {\n          head = head.next;\n        }\n\n        ListNode res = head.next;\n        head.next = null;\n        return res;\n    }\n}\n```\n\n## Complexity\nTime = O(n) (Traverse the whole linked list). \nSpace = O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921551276","body":"## Plan\r\nmove the head of the list to the 2nd node in the list (This's what we're going to return). \r\nUse \"startOfNextSegment\" node to record second.next:\r\n- to keep track of the \"third\" node of current swap round.  \r\n- It's also the \"start\"of next round's swap: `first = startOfNextSegment`.   \r\nWhen `startOfNextSegment == null || startOfNextSegment`: swap stop,\r\n\r\n## Java Code\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n      return head;\r\n    }\r\n\r\n    ListNode first = head;\r\n    ListNode second = head.next;\r\n    ListNode startOfNextSegment = null;\r\n\r\n    // Move the head of the list to the 2nd node in the list\r\n    head = head.next;\r\n\r\n    while (true) {\r\n      startOfNextSegment = second.next;\r\n      second.next = first;\r\n\r\n      if (startOfNextSegment == null || startOfNextSegment.next == null) {\r\n        first.next = startOfNextSegment;\r\n        return head;\r\n      }\r\n\r\n      first.next = startOfNextSegment.next;\r\n\r\n      first = startOfNextSegment;\r\n      second = startOfNextSegment.next;\r\n    }    \r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime = O(1)\r\nSpace = O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922327857","body":"## Thinking\nUse Fast/Slow pointer to find the medium,  \n- the left subtrees of BST [root, medium]. \n- the right subtrees of BST: [medium.next, tail]. \n- Use helper function to build BST subtree recursively. \n\n## Java Code\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        return toBST(head, null);\n    }\n    \n    public TreeNode toBST(ListNode head, ListNode tail) {\n        if (head == tail) return null;\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = toBST(head, slow);\n        root.right = toBST(slow.next, tail);\n        return root;\n    }\n}\n```\n\n## Complexity \nTime = O(n)  : we need to visit every TreeNode\nSpace = O(n): the height of the tree/the heights of the call stacks of the recursive tree(can be skewed)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922407504","body":"## Thinking\n\nAdd pathA to the tail to PathB, and add PathB to the tail of path A.  \nif they have intersection, the condition `while(a != b)` will terminate, and the node that a is at is what we want to return.    \nElse a will just reach the end of the combined list, which is null, return a <-> return null.  \n\n## Java Code\n```java\n/**\n     *\n     A:          a1 → a2\n                         ↘\n                         c1 → c2 → c3\n                         ↗\n     B:     b1 → b2 → b3\n .\n     begin to intersect at node c1.\n\n     A : a1 → a2 -> c1 → c2 → c3 -> b1 → b2 → b3 -> *c1*→ c2 → c3\n     B : b1 → b2 → b3 -> c1 → c2 → c3 -> a1 → a2 -> *c1* → c2 → c3\n\n     time : O(m + n);\n     space : O(1);\n\n\n     */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        ListNode a = headA;\n        ListNode b = headB;\n        while (a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n\n```\n\n## Complexity:\nTime = O(m + n) : Traverse both linkedlist twice.   \nSpace= O(1) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mmboxmm":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916278377","body":"## 思路\nAddition from right to left\n\n## 代码\n\n```Kotlin\nfun addToArrayForm(num: IntArray, k: Int): List<Int> {\n  val res = mutableListOf<Int>()\n  var carry = 0\n  var index = num.size - 1\n  var tmp = k\n\n  while (index >= 0 || tmp > 0 || carry > 0) {\n    var sum = carry\n    if (index >= 0) sum += num[index--]\n    if (tmp > 0) sum += tmp % 10\n\n    res.add(sum % 10)\n\n    carry = sum / 10\n    tmp /= 10\n  }\n  return res.reversed()\n}\n```\n\n## 复杂度分析\n- Time：O(len(num))\n- Space：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917097521","body":"## 思路\nScan the string twice, from left and from right. Update the min.\n\n## 代码\n\n```Kotlin\nfun shortestToChar(s: String, c: Char): IntArray {\n  val res = IntArray(s.length) { s.length }\n  var last = -1\n  for ((index, ch) in s.withIndex()) {\n    if (ch == c) {\n      last = index\n      res[index] = 0\n    } else if (last != -1) {\n      res[index] = index - last\n    }\n  }\n\n  last = -1\n  for (index in res.size - 1 downTo 0) {\n    if (res[index] == 0) {\n      last = index\n    } else if (last != -1) {\n      res[index] = minOf(res[index], last - index)\n    }\n  }\n  return res\n}\n```\n\n## 复杂度\n- Time: O(n)\n- Space: O(1), no extra space.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917448490","body":"## 思路\nArrayList is always better than LinkedList\n\n## 代码\n\n```Kotlin\nclass CustomStack(private val maxSize: Int) {\n  private val list = mutableListOf<Int>()\n\n  fun push(x: Int) {\n    if (list.size < maxSize) list.add(x)\n  }\n\n  fun pop(): Int = list.removeLastOrNull() ?: -1\n\n  fun increment(k: Int, v: Int) = (0 until minOf(list.size, k)).forEach {\n    list[it] += v\n  }\n}\n```\n## 复杂度分析\n- push/pop: O(1)\n- inc: O(min(k, size))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917717449","body":"## 思路\n分为四种类型，数字，字符串，[ 和 ]。 前三种压栈，最后一个出栈。感觉很笨，需要学习一下！\n\n## 代码\n```Kotlin\nfun decodeString(s: String): String {\n  if (s.isBlank()) return s\n\n  val stack = ArrayDeque<String>()\n  var i = 0\n  while (i < s.length) {\n    if (s[i].isDigit()) {\n      val start = i\n      while (++i < s.length && s[i].isDigit()) {\n      }\n      stack.addLast(s.substring(start, i))\n    } else if (s[i].isLetter()) {\n      val start = i\n      while (++i < s.length && s[i].isLetter()) {\n      }\n      stack.addLast(s.substring(start, i))\n    } else if (s[i] == '[') {\n      stack.addLast(\"[\")\n      i++\n    } else {\n      val sb = StringBuilder()\n      while (stack.isNotEmpty() && stack.last() != \"[\") {\n        sb.insert(0, stack.removeLast())\n      }\n      stack.removeLast()\n      val freq = stack.removeLast().toInt()\n      stack.addLast(sb.repeat(freq))\n      i++\n    }\n  }\n  val res = StringBuilder()\n  while (stack.isNotEmpty()) {\n    res.insert(0, stack.removeLast())\n  }\n  return res.toString()\n}\n```\n\n## 复杂度分析\n- Time: O(len(s))\n- Space: O(len(s))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918461081","body":"## 思路\n一个负责入，一个负责出。双栈。\n\n## 代码\n\n```Kotlin\nclass MyQueue() {\n  /** Initialize your data structure here. */\n  private val inStack = ArrayDeque<Int>()\n  private val outStack = ArrayDeque<Int>()\n\n  /** Push element x to the back of queue. */\n  fun push(x: Int) = inStack.addLast(x)\n\n  /** Removes the element from in front of queue and returns that element. */\n  fun pop(): Int {\n    prep()\n    return outStack.removeLast()\n  }\n\n\n  /** Get the front element. */\n  fun peek(): Int {\n    prep()\n    return outStack.last()\n  }\n\n  private fun prep() {\n    if (outStack.isEmpty()) {\n      require(inStack.isNotEmpty())\n      while (inStack.isNotEmpty()) {\n        outStack.addLast(inStack.removeLast())\n      }\n    }\n  }\n\n  /** Returns whether the queue is empty. */\n  fun empty(): Boolean = inStack.isEmpty() && outStack.isEmpty()\n}\n```\n\n## 复杂度分析\n- Time: amortized O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919458617","body":"## 思路\n从左往右，依次遍历每个元素。每个元素\n\n- 新建一个block，如果之前的元素不大于该元素\n- 融入之前的block，即融合到之前的多个blocks，直到block最大值小于该元素\n\n## 代码\n```Kotlin\nfun maxChunksToSorted(arr: IntArray): Int {\n  val stack = ArrayDeque<Int>()\n  for (n in arr) {\n    val max = stack.lastOrNull() ?: n\n    if (n >= max) {\n      stack.addLast(n)\n    } else {\n      while (stack.isNotEmpty() && n < stack.last()) {\n        stack.removeLast()\n      }\n      stack.addLast(max)\n    }\n  }\n  return stack.size\n}\n```\n\n## 复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920258118","body":"## 思路\n先首尾相连，然后找准位置断开。\n\n## 代码\n\n### Kotlin\n```Kotlin\nfun rotateRight(head: ListNode?, k: Int): ListNode? {\n  if (head == null || k == 0) return head;\n\n  var num = 1\n  var node = head\n  while (node?.next != null) {\n    num++\n    node = node.next\n  }\n\n  node?.next = head\n  var offset = num - (k % num)\n  if (offset == 0) return head\n\n  node = head\n  while (--offset > 0) {\n    node = node?.next\n  }\n  val res = node?.next\n  node?.next = null\n  return res\n}\n```\n### Java\n```Java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k <= 0) return head;\n        \n        int total = 1;\n        ListNode cur = head;\n        while (cur != null && cur.next != null) {\n            total++;\n            cur = cur.next;\n        }\n        \n        cur.next = head;\n        \n        k = total - (k % total);\n        if (k == 0) return head;\n        while (--k > 0) {\n            head = head.next;\n        }\n        \n        ListNode res = head.next;\n        head.next = null;\n        return res;\n    }\n}\n```\n\n### 复杂度\nO(len(list))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921290399","body":"## 思路\n拆分，合并。史上最长代码，bug risk free.\n\n## 代码\n\n```Java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        ListNode l = new ListNode(), r = new ListNode();\n        ListNode left = l, right = r;\n    \n        while (head != null && head.next != null) {\n            left.next = head;\n            right.next = head.next;\n            \n            left = left.next;\n            right = right.next;\n            head = head.next.next;\n        }\n        if (head != null) {\n            left.next = head;\n            left = left.next;\n        }\n        \n        left.next = null;\n        right.next = null;\n        \n        left = l.next;\n        right = r.next;\n        \n        ListNode res = new ListNode();\n        head = res;\n        \n        while(left != null || right != null) {\n            if (right != null) {\n                head.next = right;\n                right = right.next;\n                head = head.next;\n            }\n            \n            if (left != null) {\n                head.next = left;\n                left = left.next;\n                head = head.next;\n            }\n        }\n        return res.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922103552","body":"今天不想写题解\n\n```Java\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n        \n        ListNode mid = findMid(head);\n        TreeNode res = new TreeNode(mid.val);\n        \n        res.left = sortedListToBST(head);\n        res.right = sortedListToBST(mid.next);\n        \n        return res;\n    }\n    \n    private ListNode findMid(ListNode head) {\n        ListNode slow = head, fast = head, prev = null;\n        \n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        prev.next = null;\n        return slow;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922336031","body":"简答的打个卡吧\r\n\r\n## 代码\r\n\r\n```Java\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) return null;\r\n        ListNode a = headA, b = headB;\r\n        while (a != b) {\r\n            a = a == null ? headB : a.next;\r\n            b = b == null ? headA : b.next;\r\n        }\r\n        return a;\r\n    }\r\n```\r\n## 复杂度分析\r\n\r\n- Time: O(len(A) + len(B) - len(common(A, B))\r\n- Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangwiitao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916281347","body":"#### JS\n\n```js\nvar addToArrayForm = function (num, k) {\n    const ret = [];\n    let i = num.length - 1, carry = 0;\n    while (i >= 0 || k != 0) {\n        let x = i >= 0 ? num[i] : 0;\n        let y = k !== 0 ? k % 10 : 0;\n\n        const sum = x + y + carry;\n\n        ret.push(sum % 10);\n        carry = Math.floor(sum / 10);\n\n        i--;\n        k = Math.floor(k / 10);\n    }\n    if (carry) {\n        ret.push(carry);\n    }\n    return ret.reverse();\n};\n```\n#### 复杂度分析\n- 时间复杂度：O（n），再具体不会了\n- 空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917418388","body":"#### 思路\n遍历每个字符，从两边扩散，计算最小的值\n\n#### 代码\n\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n    const newArr = Array(s.length).fill(0);\n\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) continue;\n        let l = i;\n        let r = i;\n        let distance = Infinity;\n        while (l >= 0) {\n            if (s[l] === c) {\n                distance = Math.min(distance, i - l);\n                break;\n            }\n            l--\n        }\n        while (r < s.length) {\n            if (s[r] === c) {\n                distance = Math.min(distance, r - i);\n                break;\n            }\n            r++;\n        }\n        newArr[i] = distance;\n    }\n    return newArr;\n};\n\n```\n\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917438071","body":"#### 思路\n用数组模拟\n#### 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    return this.stack.length > 0 ? this.stack.pop() : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    let length = Math.min(k, this.stack.length);\n    for (let i = 0; i < length; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n- 时间复杂度：O(1)push pop, O(n)inc\n- 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918323994","body":"#### 思路:\n开括号前面的为数字，闭括号前面的为字符，遇到开括号前面可能大于个位数，用10*拼接\n#### 代码\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n    let numStack = [];\n    let strStack = [];\n    let num = 0;\n    let result = \"\";\n    for (let char of s) {\n        if (!isNaN(char)) {\n            num = num * 10 + Number(char);\n        } else if (char === \"[\") {\n            numStack.push(num);\n            num = 0;\n            strStack.push(result);\n            result = \"\";\n        }else if(char ===\"]\"){\n            let repeatNum = numStack.pop();\n            result = strStack.pop() + result.repeat(repeatNum);\n        }else{\n            result += char;\n        }\n    }\n    return result;\n};\n```\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918446362","body":"#### 思路\n用俩个栈，从一个挪出来到另一个，在另一个出栈时，顺序就对了\n\n#### 代码\n```js\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function () {\n    this.inStack = [];\n    this.outStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.inStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    return this.inStack.length == 0 && this.outStack.length == 0\n};\nMyQueue.prototype.in2out = function () {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n}\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n- 时间复杂度：push,enpty,O(1),peek,pop,O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920117594","body":"#### 思路\n单调栈递增，如果后面的元素小于前面的元素，则压缩到前面比它大的元素中。\n#### 代码\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n    let stack = [];\n    for (let i = 0; i < arr.length; i++) {\n        let a = arr[i];\n        if (stack.length > 0 && stack[stack.length - 1] > a) {\n            let cur = stack[stack.length - 1];\n            while (stack.length > 0 && stack[stack.length - 1] > a) stack.pop();\n            stack.push(cur);\n        } else {\n            stack.push(a)\n        }\n    }\n    return stack.length;\n};\n```\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921023294","body":"#### 思路\n俩个指针，快的和慢的相差k，当快的走到最后，慢指针下一节点所在就是新的头结点，快指针指向之前头结点，慢指针节点指向空\n#### 代码\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n    if (head === null || k === 0) return head;\n    var tot = 0;\n    var tmp = head;\n    while (tmp !== null && ++tot > 0) tmp = tmp.next;\n    k %= tot;\n    if (k == 0) return head;\n\n\n    var slow = head, fast = head;\n    while (k-- > 0) fast = fast.next;\n    while (fast.next !== null) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n\n    var nHead = slow.next;\n    slow.next = null;\n\n    fast.next = head;\n    return nHead;\n\n};\n- 时间复杂度：O（N）\n- 空间复杂度：O（1）\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921879865","body":"#### 思路\n交换节点\n#### 代码\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    const dummyHead = new ListNode(0);\n    dummyHead.next = head;\n    let temp = dummyHead;\n    while (temp.next !== null && temp.next.next !== null) {\n        const node1 = temp.next;\n        const node2 = temp.next.next;\n        temp.next = node2;\n        node1.next = node2.next;\n        node2.next = node1;\n        temp = node1;\n    }\n    return dummyHead.next;\n};\n\n```\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922331330","body":"#### 代码\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\n\nconst sortedListToBST = (head) => {\n    if (head == null) return null;\n    let slow = head;\n    let fast = head;\n    let preSlow;\n\n    while (fast && fast.next) {\n        preSlow = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    const root = new TreeNode(slow.val);\n\n    if (preSlow != null) {\n        preSlow.next = null;\n        root.left = sortedListToBST(head);\n    }\n    root.right = sortedListToBST(slow.next);\n    return root;\n};\n\n```\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922494248","body":"```js\nvar getIntersectionNode = function(headA, headB) {\n      if (!headA || !headB) return null;\n\n    const hashmap = new Map();\n\n    let pA = headA;\n    while (pA) {\n        hashmap.set(pA, 1);\n        pA = pA.next;\n    }\n\n    let pB = headB;\n    while (pB) {\n        if (hashmap.has(pB)) return pB;\n        pB = pB.next;\n    }\n\n};\n```\n- 时间复杂度：O（m+n）\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916284826","body":"# LC989. Add to Array-Form of Integer\r\n## Main Idea\r\nFirst, it looks like we can convert the array `num` to integer and add it to `k`, but `num.length <= 1E+4` so this approach will cause integer overflow. So we will have to do the addition in array form.\r\n\r\nThen the idea is to simulate the entire process, add each digit of `num` and `k` with a `carry` bit. We will terminate the loop when we run out of digits for both `num` and `k` and `carry == 0`.\r\n\r\n## Code\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length, carry = 0, i = n - 1;\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        while (i >= 0 || k > 0 || carry > 0) {\r\n            int kDigit = k % 10;\r\n            k /= 10;\r\n            int sum = i >= 0 ? carry + kDigit + num[i] : carry + kDigit;\r\n            res.add(sum % 10);\r\n            carry = sum >= 10 ? 1 : 0;\r\n            --i;\r\n        }\r\n      \r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity Analysis\r\nTime: `O(max(N, log(K)))`\r\n* Given a number `K`, its length will be `log_{2}(K)`, the time complexity depends on the length of `N` and `K`, whichever is longer.\r\n* Notice we want to insert digits at the end of the array and then reverse it after we finish the addition. If we insert at the head of array, then it will take `O(n^2)` of time.\r\n\r\nSpace: `O(1)`, as we didn't use additional spaces except the return array.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917026412","body":"# LC821. Shortest Distance to a Character\n## Main Idea\n### One Scan with Two Pointers\nWe use `prev` array to record the previous appearance of `c` and `next` array to record the next for each character in the string. \n\nFor the first character, initialize its `prev[0]` to be infinity. Then for each character `s[i]`, if `s[i] == c`, then `prev[i] = 0`, else, `prev[i] = prev[i - 1] + 1`, notice if `prev[i - 1] == Integer.MAX_VALUE`, we don't need to add 1 so it won't cause integer overflow.\n\nSimilar logic for `next` array.\n\nThen for each character, `res[i] = min{prev[i], next[i]}`.\n\nAlso we can use two pointers to acheive our goal with one scan.\n\n## Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] next = new int[n], prev = new int[n], res = new int[n];\n        for (int i = 0; i < n; ++i) {\n            int j = n - 1 - i;\n            if (i == 0) {\n                prev[i] = s.charAt(i) == c ? 0 : Integer.MAX_VALUE;\n                next[j] = s.charAt(j) == c ? 0 : Integer.MAX_VALUE;\n            } else {\n                prev[i] = s.charAt(i) == c ? 0 : prev[i - 1] == Integer.MAX_VALUE ? prev[i - 1] : prev[i - 1] + 1;\n                next[j] = s.charAt(j) == c ? 0 : next[j + 1] == Integer.MAX_VALUE ? next[j + 1] : next[j + 1] + 1;\n\n                if (i >= j) {\n                    res[i] = Math.min(prev[i], next[i]);\n                    res[j] = Math.min(prev[j], next[j]);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n## Complexity Analysis\nTime: `O(n)`\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917430931","body":"# LC1381. Design a Stack With Increment Operation\r\n## Main Idea\r\nA stack can be implemented with an array, but usually we only have access to stack top due to encapsulation, while we can actually access/modify any elements in the array internally.\r\n\r\nWe can implement the stack API with `array`:\r\n* `push()`: append at the end of array (`O(1)`)\r\n* `pop()`: remove the end of array (`O(1)`)\r\n* `increment()`: use a for loop to increment `array[0:k]` (`O(k)`).\r\n\r\n### Optimization. Range Update with Difference Array && Lazy Evaluation\r\nNotice the time complexity of `increment()` is too high due to range update, and we can use a difference array to optimize it.\r\n\r\nAlso we don't really care about the values of elements until we `pop` them, so we can evaluate them when we pop them out of the stack.\r\n\r\n## Code\r\n```java\r\nclass CustomStack {\r\n    private List<Integer> array;\r\n    private List<Integer> diff;\r\n    private int cap;\r\n    private int size;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        array = new ArrayList<>();\r\n        diff = new ArrayList<>();\r\n        cap = maxSize;\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (size >= cap) {\r\n            return;\r\n        }\r\n        ++size;\r\n        array.add(x);\r\n        diff.add(0);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (size == 0) {\r\n            return -1;\r\n        }\r\n        int num = array.remove(size - 1);\r\n        int d = diff.remove(size - 1);\r\n        --size;\r\n        if (size > 0)\r\n            diff.set(size - 1, diff.get(size - 1) + d);\r\n        return num + d;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int idx = Math.min(k, size) - 1;\r\n        if (idx >= 0)\r\n            diff.set(idx, diff.get(idx) + val);\r\n    }\r\n}\r\n```\r\n## Complexity Analysis\r\nTime: `O(1)` for all operations\r\n\r\nSpace: `O(n)` as we used 2 arrays.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917696390","body":"# LC394. Decode String\r\n## Method 1. Recursion\r\n### Main Idea\r\nFirst, I think we can use recursion to handle nested cases like `3[a2[bc]]`, where we can decode `2[bc]` first, and we get `3[abcbc]`, which is the same problem with different size.\r\n\r\n**Algorithm**\r\n\r\nWe need a global variable `index` to indicate which index are we currently processing.\r\n* Base case: if there are no brackets, we just return the string itself.\r\n* When we see a digit, we convert it to number `cnt`, increment `index` to skip the `[`, and pass the string to recursive call.\r\n* When we see a `]`, we can return from this recursive call.\r\n\r\n### Code\r\n```java\r\nclass Solution {\r\n    private int index = 0;\r\n    public String decodeString(String s) {\r\n        StringBuilder sb = new StringBuilder();\r\n        int n = s.length();\r\n        while (index < n && s.charAt(index) != ']') {\r\n            char c = s.charAt(index);\r\n            if (Character.isDigit(c)) {\r\n                int cnt = 0;\r\n                while (Character.isDigit(s.charAt(index))) {\r\n                    cnt = cnt * 10 + s.charAt(index) - '0';\r\n                    ++index;\r\n                }\r\n                ++index;\r\n                String str = decodeString(s);\r\n                for (int i = 0; i < cnt; ++i) {\r\n                    sb.append(str);\r\n                }\r\n            } else {\r\n                sb.append(c);\r\n            }\r\n            ++index;\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n### Complexity Analysis\r\nTime: `O(S)`, where `S` is the length of the decoded string.\r\n\r\nSpace: `O(s)`, where `s` is the length of the input string, as the space complexity depends on the depth of recursive calls, and we can have at most `s` nested brackets.\r\n## Method 2. Stack\r\n### Main Idea\r\nWe can also use stack to solve problems of parentheses matching, in this problem, we will push everything to the stack until we see a `]`, then we pop things from the stack until we found its matching `[`. And we can decode the string, and push the decoded string back to the stack.\r\n### Code\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int n = s.length();\r\n        Deque<Character> stack = new ArrayDeque<>();\r\n        for (int i = 0; i < n; ++i) {\r\n            char c = s.charAt(i);\r\n            if (c != ']') {\r\n                stack.push(c);\r\n            } else {\r\n                List<Character> list = new ArrayList<>();\r\n                while (stack.peek() != '[') {\r\n                    list.add(stack.pop());\r\n                }\r\n                stack.pop();\r\n\r\n                int cnt = 0, base = 1;\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    int digit = stack.pop() - '0';\r\n                    cnt += (digit * base);\r\n                    base *= 10;\r\n                }\r\n\r\n                for (int l = 0; l < cnt; ++l) {\r\n                    for (int j = list.size() - 1; j >= 0; --j) {\r\n                        stack.push(list.get(j));\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        while (!stack.isEmpty()) {\r\n            sb.append(stack.pop());\r\n        }\r\n\r\n        sb.reverse();\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n### Complexity Analysis\r\nTime: `O(S)`, where `S` is the length of the decoded string.\r\n\r\nSpace: `O(S)`, since we use a stack to store all the characters.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918432299","body":"# LC232. Implement Queue using Stacks\r\n## Main Idea\r\nWe can use `stack1` as the input stack, and `stack2` as the output stack. \r\n\r\n* `push()`: Push to `stack1`, so this new element will be on the stack top of `stack1` (which is the end of our queue).\r\n* `pop()` and `peek()`: Since we use `stack2` as our output stack, when we call `pop()` or `peek()`:\r\n* If `stack2` is empty, we want to move all elements from `stack1` to `stack2`, and their order will be reversed, so the bottom of `stack1` will be the top of `stack2`, which is the head of our queue.\r\n* If not, then we have access to the top of `stack2` already.\r\n## Code\r\n```java\r\nclass MyQueue {\r\n    private Deque<Integer> stack1;\r\n    private Deque<Integer> stack2;\r\n    private int size;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack1 = new ArrayDeque<>();\r\n        stack2 = new ArrayDeque<>();\r\n        size = 0;\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stack1.push(x);\r\n        ++size;\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (empty()) return -1;\r\n        peek();\r\n        --size;\r\n        return stack2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (empty()) return -1;\r\n        if (stack2.isEmpty()) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.peek();\r\n    }\r\n    \r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return size == 0;\r\n    }\r\n}\r\n```\r\n## Complexity Analysis\r\nTime:\r\n* `push()`: `O(1)`\r\n* `pop()` and `peek()`: \r\n\t* The **worst case** of `pop()` and `peek()` will be `O(n)`, where we have to move all elements from `stack1` to `stack2`.\r\n\t* **Amortized Analysis**: Say we have `n` elements in `stack1`, and `0` elements in `stack2`, and we want to call `pop()` or `peek()` `n` times. The first call will take `n` operations to move all elements from `stack2` to `stack1`. But after the first call we will have at least `n - 1` elemetns in `stack2`, which makes the next `n - 1` calls  `O(1)`. So the amrotized time will be `O(n + 1 + 1 +...+1 / n) = O((2n-1)/n) = O(1)`.\r\n\r\nSpace: `O(1)`, the two stacks are given and we didn't use any extra spaces.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919290956","body":"# LC768. Max Chunks To Make Sorted II\n## Method 1. Brute Force: Sort and Compare\n### Main Idea\nFirst we copy the array and sort it, call it `sortArr`. If `arr[i:j]` can be a chunk, then `arr[i:j]` should contain the same elements as `sortArr[i:j]` (but different permutations). If 2 arrays **contain the same elements, their sum should equal each other.**\n\nSo we can use a variable `netSum` to record the net sum, each iteration, `netSum += (arr[i] - sortArr[i])`. If `netSum == 0` at index `i`, that means we can cut at index `i`.\n### Code\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length, cnt = 0;\n        int[] sortArr = Arrays.copyOf(arr, n);\n        Arrays.sort(sortArr);\n        int netSum = 0;\n        for (int i = 0; i < n; ++i) {\n            netSum += (arr[i] - sortArr[i]);\n            if (netSum == 0) ++cnt;\n        }\n        return cnt;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(nlogn)` for sorting the array.\n\nSpace: `O(n)` for creating the `sortArr`.\n## Method 2. Monotonous Stack\n### Main Idea\nFor chunks `[c1, c2, c3, ..., cn]`, we have to maintain the property: `max(ci) <= min(cj)` if `i < j`. So we can create a monotonously increasing stack `stack` to **keep track of the max value for each previous chunk**. \n\nIf `arr[i] >= stack.peek()`, we can greedily create a new chunk and `stack.push(arr[i])`. Else, we need to find the previous chunk with max value smaller or equal to `arr[i]`, say `ck`, and we need to merge all the chunks `[c_k+1, ... c_cur]` with `arr[i]`.\n\nTo merge chunks, we can just pop all the max values representing those chunks off the stack, and push back the max among them (in our case, it will be stack top cuz this stack is increasing) as the max of the new chunk. \n### Code\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = 0; i < n; ++i) {\n            if (stack.isEmpty() || stack.peek() <= arr[i]) {\n                stack.push(arr[i]);\n            } else {\n                int max = stack.peek();\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\n                    stack.pop();\n                }\n                stack.push(max);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)`\n\nSpace: `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920192456","body":"# LC61. Rotate List\r\n## Method. Traverse & Modify LinkedList\r\n### Main Idea\r\n1. Find the length of the linked list. If `length == 0`, return `head`.\r\n2. If `k >= n`, then we can do `k = k % n` which doesn't affect the final result but reduce the number of rotations.\r\n3. Use two pointers to traverse the linked list to find the last kth element and its previous node.\r\n4. Modify the linked list. The last kth element will be the new head, and its previous node's next will be `null`, and the last node will point the the original head.\r\n### Code\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        int n = getLength(head);\r\n        if (n == 0) return head;\r\n        k %= n;\r\n        \r\n        // Find the last kth element as new head\r\n        ListNode fast = head, slow = head;\r\n        for (int i = 0; i < k; ++i) {\r\n            fast = fast.next;\r\n        }\r\n        \r\n        while (fast.next != null) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        \r\n        fast.next = head;\r\n        ListNode newHead = slow.next;\r\n        slow.next = null;\r\n        return newHead;\r\n        \r\n    }\r\n    \r\n    private int getLength(ListNode head) {\r\n        int len = 0;\r\n        while (head != null) {\r\n            ++len;\r\n            head = head.next;\r\n        }\r\n        return len;\r\n    }\r\n}\r\n```\r\n### Complexity Analysis\r\nTime: `O(n)`\r\nSpace: `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921075226","body":"# LC24. Swap Nodes in Pairs\n## Method 1. Iteration\n### Main Idea\n1. Use a dummy head `dummy` to simplify the code, `dummy.next = head`.\n2. Use a node `prev` to store the last node in the list that has been processed, initialize it with `dummy`.\n3. Each iteration, get the next two nodes of `prev`, call them `cur` and `next`  (be careful about NPE), and exchange their positions if both of them are not `null`.\n4. `prev = cur`, contiue the next iteration.\n\n### Code \n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(), prev = dummy;\n        dummy.next = head;\n        while (prev != null) {\n            ListNode cur = null, next = null;\n            \n            cur = prev.next;\n            if (cur != null) {\n                next = cur.next;\n            }\n            \n            if (next != null) {\n                prev.next = next;\n                ListNode tmp = next.next;\n                next.next = cur;\n                cur.next = tmp;\n            }\n            prev = cur;\n        }\n        \n        return dummy.next;\n    }\n}\n```\n\n### Complexity Analysis\n* Time: `O(n)`\n* Space: `O(1)`\n\n## Method 2. Recursion\n### Main Idea\n1. If the current list has length smaller than 2, don't need to swap.\n2. Else, recursivly swap the list `head.next.next`, and the swap function should return the `next` node.\n3. Swap the current 2 nodes, `newHead = head.next`, `newHead.next = head` and `head.next = next`.\n\n### Code\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode next = swapPairs(head.next.next);\n        ListNode newHead = head.next;\n        newHead.next = head;\n        head.next = next;\n        return newHead;\n    }\n}\n```\n\n### Complexity Analysis\n* Time: `O(n)`\n* Space: `O(n)` for the recursive call.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921970910","body":"# LC109. Convert Sorted List to Binary Search Tree\n## Method 1. Divide and Conquer\n### Main Idea\nIf we pick a node as root of the tree, then we will need to determine the left and right subtrees with the list nodes on the left and right hand sides, which is the same problem but with a smaller size.\n\nAlso, we want the BST to be balanced, so when constructing the tree, we want to **choose the middle list node as the root**, so left and right will have same number of nodes, or one side will have an extra node.\n\n**Algorithm**\n1. Base case: If there is only one node left, return it as a new `TreeNode`.\n2. Get the middle node.\n3. Recusrivly call the function on the left and right lists and get the left and right subtree.\n\n### Code\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n        \n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        \n        ListNode prev = head;\n        while (prev.next != slow) {\n            prev = prev.next;\n        }\n        prev.next = null;\n        TreeNode left = sortedListToBST(head);\n        TreeNode right = sortedListToBST(slow.next);\n        TreeNode root = new TreeNode(slow.val);\n        root.left = left;\n        root.right = right;\n        return root;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(nlogn)`, divide and conquer.\n\nSpace: `O(height) = O(logn)`  for recursive calls.\n\n**Tradeoff**\n\nNotice we can **convert the linked list to an array list** so we have random access to the middle node, which makes the time compleixty `O(n)` since we no longer have to traverse the entire list each layer. But the space complexity will be `O(n)` to store the array.\n\n## Method 2. In-Order Traversal\n### Main Idea\nThe bottleneck of method 1 is that we have to either find the mid node each recursive call or convert the linked list to array list, which either costs time or space. But can we do better?\n\nFirst recall the fact that **a sorted list/array is the in-order traversal of a bst**. Which means we can traverse the list once, and build the tree, like how we did in-order traversal, the left subtree is traversed and built first, then we create the root node, finally the right subtree.\n\nWe can use a global variable `cur` to represent the current node we are processing. Since we are doing an in-order traversal, all the nodes will be created in order, e.g, **node `i` won't be created until all nodes `0:i-1` are cteated**.\n\n**Algorithm**\n1. Define `inOrder(int i, int j)` to be the problem of  the converting `list[i:j]` to BST.\n2. Base case: if `i > j`, return `null`.\n3. Calculate `mid = i + (j - i) / 2`, left subtree will be `inOrder(i, mid - 1)`, and then we create our root with the current node `cur`, then the next node to create will be `cur.next`, and we build the right sutree with `inOrder(mid + 1, j)`.\n\n### Code\n```java\nclass Solution {\n    private ListNode cur;\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        cur = head;\n        int n = getLength(head);\n        return inOrder(0, n - 1);\n    }\n\n    private TreeNode inOrder(int l, int r) {\n        if (l > r) return null;\n        int m = l + (r - l) / 2;\n        TreeNode left = inOrder(l, m - 1);\n        TreeNode root = new TreeNode(cur.val);\n        cur = cur.next;\n        TreeNode right = inOrder(m + 1, r);\n        root.left = left;\n        root.right = right;\n        return root;\n    }\n\n    private int getLength(ListNode head) {\n        int cnt = 0;\n        while (head != null) {\n            head = head.next;\n            ++cnt;\n        }\n        return cnt;\n    }\n}\n```\n### Complexity Analysis\nTime: `O(n)`\n\nSpace: `O(logn)` for recursive calls.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922349282","body":"# LC160. Intersection of Two Linked Lists\r\n## Method 1. Hash\r\n### Main Idea\r\nFirst traverse list A and use a hash set to record visited, then traverse B, the first node of visited node will be the intersection, if there's no such a node, that means no intersection.\r\n### Code\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        Set<ListNode> visited = new HashSet<>();\r\n        while (headA != null) {\r\n            visited.add(headA);\r\n            headA = headA.next;\r\n        }\r\n\r\n        while (headB != null) {\r\n            if (visited.contains(headB)) {\r\n                return headB;\r\n            }\r\n            headB = headB.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n### Complexity Analysis\r\nTime: `O(m + n)`\r\n\r\nSpace: `O(m)`\r\n\r\n## Method 2. Two Pointers\r\n### Main Idea\r\nFirst traverse both arrays to find their lengths, then use two pointers `pA` and `pB` to traverse both lists. Before we start tracersal, move the pointer of the longer list forward by `abs(lA-lB)`.\r\n### Code\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        int lenA = listLen(headA), lenB = listLen(headB), diff = Math.abs(lenA - lenB);\r\n        ListNode cur1 = lenA < lenB ? headB : headA;\r\n        ListNode cur2 = lenA < lenB ? headA : headB;\r\n        for (int i = 0; i < diff; ++i) {\r\n            cur1 = cur1.next;\r\n        }\r\n        while (cur1 != null && cur2 != null) {\r\n            if (cur1 == cur2) {\r\n                return cur1;\r\n            } else {\r\n                cur1 = cur1.next;\r\n                cur2 = cur2.next;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private int listLen(ListNode head) {\r\n        if (head == null) {\r\n            return 0;\r\n        }\r\n        return 1 + listLen(head.next);\r\n    }\r\n}\r\n```\r\n### Complexity Analysis\r\nTime: `O(m + n)`\r\n\r\nSpace: `O(1)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ai2095":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916293322","body":"## LC 989 Add to Array-Form of Integer\n\nhttps://leetcode.com/problems/add-to-array-form-of-integer/\n\n### Topics  \n\n- Array\n- Math\n\n### Similar Questions\n\nMedium\n- https://leetcode.com/problems/add-two-numbers/\n\nEasy\n- https://leetcode.com/problems/plus-one/\n- https://leetcode.com/problems/add-binary/\n- https://leetcode.com/problems/add-strings/\n\n\n### 思路 \nAdd the number K to the array from right to left.\n\n#### 代码 Python\n\n```Python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carrier = 0\n        num_len = len(num)\n        i = num_len -1\n        # Add all matching digit        \n        while i >= 0 and k > 0:\n            cur_k, k = k%10, k//10\n            t_carrier = (num[i] + cur_k + carrier) // 10\n            num[i] = (num[i] + cur_k + carrier) % 10\n            carrier = t_carrier\n            i -= 1\n        \n        # Check whether num or k is left\n        if i >= 0:\n            while i >= 0:\n                t_carrier = (num[i] + carrier) // 10\n                num[i] = (num[i] + carrier) % 10\n                carrier = t_carrier\n                if carrier == 0:\n                    break\n                i -= 1\n            \n        if k > 0:\n            while k > 0:\n                cur_k, k = k%10, k//10\n                t_carrier = (cur_k + carrier) // 10\n                num = [(cur_k + carrier) % 10] + num\n                carrier = t_carrier\n\n        # Deal with carrier\n        if carrier > 0:\n            return [carrier] + num\n        else:\n            return num\n            \n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(N) </br>\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917052674","body":"## LC 821 Shortest Distance to a Character\n\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\n\n### Topics  \n\n- Array\n- String\n\n### Similar Questions\nHard\n- https://leetcode.com/problems/shortest-common-supersequence/\n\nMedium\n- https://leetcode.com/problems/find-k-length-substrings-with-no-repeated-characters/\n- https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/\n\nEasy\n- \n\n\n### 思路 \n1. Find all c ocurrences and save them into one list.\n2. Update the corresponding position in res to 0\n3. Update other elements in the result list\n\n#### 代码 Python\n\n```Python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # Helper function to update other elements.\n        def update_res(index):\n            # Update the lower part\n            i = index\n            while i > 0 and res[i] + 1 < res[i-1]:\n                res[i-1] = res[i] + 1\n                i -= 1\n            j = index\n            while j < len(res) - 1 and res[j] + 1 < res[j+1]:\n                res[j+1] = res[j] + 1\n                j +=1\n                \n        res = [float(\"inf\")]*len(s)\n        # Find all c ocurrences and save them into one list.\n        # Update the corresponding position in res to 0\n        c_l = []\n        for i, e in enumerate(s):\n            if e == c:\n                c_l.append(i)\n                res[i] = 0\n        \n        # Update other elements in the result list\n        for idx in c_l:\n            update_res(idx)\n    \n        return res\n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(N) </br>\n空间复杂度：O(N) N is the # of occurrence of c in s.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917439651","body":"## LC1381. Design a Stack With Increment Operation\r\n\r\nhttps://leetcode.com/problems/design-a-stack-with-increment-operation/\r\n\r\n### Topics  \r\n\r\n- Stack\r\n\r\n### Similar Questions\r\nHard\r\n- https://leetcode.com/problems/distribute-repeating-integers/\r\n- https://leetcode.com/problems/closest-room/\r\n\r\nMedium\r\n- https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/\r\n\r\n\r\n\r\n### 思路 \r\nUse a list and check the size.\r\n\r\n#### 代码 Python\r\n\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        \r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        return self.stack.pop() if len(self.stack) > 0 else -1\r\n            \r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：push: O(1), pop: O(1), increment: O(k) </br>\r\n空间复杂度：O(N) \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917760614","body":"## LC394. Decode String\n\nhttps://leetcode.com/problems/decode-string/\n\n### Topics  \n\n- Stack\n- String\n\n### Similar Questions\nHard\n- https://leetcode.com/problems/number-of-atoms/\n- https://leetcode.com/problems/encode-string-with-shortest-length/\n\nMedium\n- https://leetcode.com/problems/brace-expansion/\n\nEasy\n- \n\n\n### 思路 \nScan s from left to right.\nWhen \"[\", Use stack to store processed string and num.\nWhen \"]\", pop processed string and num , and concatenate the new string.\n\n#### 代码 Python\n\n```Python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        num, string, stack = 0, \"\", []\n        for c in s:\n            if c.isdigit():\n                num = num*10 + int(c)\n            elif c == \"[\":\n                stack.append(string)\n                stack.append(num)\n                string = \"\"\n                num = 0\n            elif c.isalpha():\n                string += c\n            elif c == \"]\":\n                pre_num = stack.pop()\n                pre_string = stack.pop()\n                string = pre_string + pre_num * string\n        return string\n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(N) </br>\n空间复杂度：O(N) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918429729","body":"## LC232. Implement Queue using Stacks\n\nhttps://leetcode.com/problems/implement-queue-using-stacks/\n\n### Topics  \n\n- Stack\n- Queue\n\n### Similar Questions\n\nEasy\n- https://leetcode.com/problems/implement-stack-using-queues/\n\n\n### 思路 \nSeparate the input and output. Only move the elements from input to output when needed, so that the complexity can be amortized O(1).\n\n#### 代码 Python\n\n```Python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.output, self.input = [], []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.input.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        self.peek()\n        return self.output.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if len(self.output) == 0:\n            while len(self.input) > 0:\n                self.output.append(self.input.pop())\n        return self.output[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.output) == 0 and len(self.input) == 0\n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(1) </br>\n空间复杂度：O(1) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919406639","body":"## LC768. Max Chunks To Make Sorted II\n\nhttps://leetcode.com/problems/max-chunks-to-make-sorted-ii/\n\n### Topics  \n\n- Array\n\n### Similar Questions\n\nMedium\n- https://leetcode.com/problems/max-chunks-to-make-sorted/\n\n\n### 思路 \nUse two dict to save the count of elements of original list and the sorted list. If the two dict equals, one chunck can be added.\n\n#### 代码 Python\n\n```Python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # Use two dict to save the count of elements of original list and the sorted list.\n        # If the two dict equals, one chunck can be added.\n        res, s1, s2 = 0, collections.Counter(), collections.Counter()\n        for e1, e2 in zip(arr, sorted(arr)):\n            s1[e1] += 1\n            s2[e2] += 1\n            res += s1 == s2\n        return res\n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(n^2) </br>\n空间复杂度：O(n) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920200909","body":"## LC61. Rotate List\n\nhttps://leetcode.com/problems/rotate-list/\n\n### Topics  \n\n- Linked List\n\n### Similar Questions\n\nMedium\n- https://leetcode.com/problems/rotate-array/\n- https://leetcode.com/problems/split-linked-list-in-parts/\n\n\n### 思路 \n1. get the length of the linked list and calculate the actual steps to move.\n2. use two pointers to find the splitting point.\n3. reconnect the list.\n\n#### 代码 Python\n\n```Python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # border check      \n        if head == None:\n            return head\n        \n        # find the length of the linked list\n        t, length = head, 1\n        while t.next != None:\n            t = t.next\n            length += 1\n        \n        # get the actual rotate steps\n        k = k % length\n        \n        # find the kth node from tail\n        tail = head\n        for _ in range(k):\n            tail = tail.next\n       \n        prev = head\n        while tail.next != None:\n            prev = prev.next\n            tail = tail.next\n             \n        # link the list again\n        tail.next = head\n        head = prev.next\n        prev.next = None\n        \n        return head\n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(n) </br>\n空间复杂度：O(1) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921063707","body":"## LC24. Swap Nodes in Pairs\r\n\r\nhttps://leetcode.com/problems/swap-nodes-in-pairs/\r\n\r\n### Topics  \r\n\r\n- Linked List\r\n\r\n### Similar Questions\r\nHard\r\n- https://leetcode.com/problems/reverse-nodes-in-k-group/\r\n\r\nMedium\r\n- https://leetcode.com/problems/swapping-nodes-in-a-linked-list/\r\n\r\n\r\n### 思路 \r\n1. Add a dummy head\r\n2. Keep two pointers, one is prev that points to next batch of two notes.\r\n\r\n#### 代码 Python\r\n\r\n```Python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        # border check \r\n        if not head or head.next == None:\r\n            return head\r\n        \r\n        dummy = ListNode(next=head)\r\n        prev = dummy\r\n        while prev.next != None and prev.next.next != None:\r\n            cur = prev.next\r\n            tmp = cur.next.next\r\n            prev.next = cur.next\r\n            prev.next.next = cur\r\n            cur.next = tmp\r\n            prev = prev.next.next\r\n        \r\n        return dummy.next\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(n) </br>\r\n空间复杂度：O(1) \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921961973","body":"## LC109. Convert Sorted List to Binary Search Tree\n\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/\n\n### Topics  \n\n- Linked List\n- Array\n- BST\n\n### Similar Questions\n\nMedium\n- https://leetcode.com/problems/design-add-and-search-words-data-structure/\n- https://leetcode.com/problems/design-search-autocomplete-system/\n- https://leetcode.com/problems/replace-words/\n- https://leetcode.com/problems/implement-magic-dictionary/\n\n\n### 思路 \n   Convert the linked list to list. Use recursion to build the tree in preorder.\n\n\n#### 代码 Python\n\n```Python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        # Border check\n        if not head:\n            return None\n        if head and head.next == None:\n            return TreeNode(head.val)\n        \n        # convert Linkedlist to list\n        lst = []\n        cur = head\n        while cur:\n            lst.append(cur.val)\n            cur = cur.next\n        \n        # Recursion\n        def recur(node_list):\n            if len(node_list) == 0:\n                return\n            cur_node = TreeNode(val=node_list[len(node_list)//2])\n            left = recur(node_list[:len(node_list)//2])\n            if left:\n                cur_node.left = left\n            right = recur(node_list[len(node_list)//2 + 1:])\n            if right:\n                cur_node.right = right\n            \n            return cur_node\n        \n        return recur(lst)\n            \n```\n\n#### 复杂度分析\n\n时间复杂度：O(n) </br>\n空间复杂度：O(n) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922423430","body":"## LC160. Intersection of Two Linked Lists\n\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/submissions/\n\n### Topics  \n\n- Linked List\n\n\n### Similar Questions\n\nEasy\n- https://leetcode.com/problems/minimum-index-sum-of-two-lists/\n\n\n### 思路 \n   Two pointers.\n   Find the lengths of two linked list. Move the pointer to make sure both lists have the same amount of elements left.\n\n#### 代码 Python\n\n```Python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        def listLen(head):\n            dummy, length = head, 0\n            while dummy:\n                length += 1\n                dummy = dummy.next\n            return length\n       # Get the list length.\n        lenA, lenB = listLen(headA), listLen(headB)\n        # Move the fast pointer to the position so that left items in both lists are the same.\n        fastA, fastB = headA, headB\n        if lenA > lenB:\n            for _ in range(lenA - lenB):\n                fastA = fastA.next\n        elif lenA < lenB:\n            for _ in range(lenB - lenA):\n                fastB = fastB.next\n                \n        while fastA != fastB:\n            fastA, fastB = fastA.next, fastB.next\n        \n        return fastA\n            \n```\n\n#### 复杂度分析\n\n时间复杂度：O(N) </br>\n空间复杂度：O(1) \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanglr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916293869","body":"## 思路\r\n\r\n双指针 + 进位加法逻辑\r\n\r\n双指针, 让两个数的末位对齐, 两个指针 i, j均从各自字符串的末尾开始走。\r\n\r\n定义一个数组来存放结果, 一个int值carry来记录每位的进位值, 初始值设为0。\r\n算当前位置的数时, sum = a[i] + b[j] + carry, 每趟都要记得更新carry的值。\r\n\r\n循环结束时, 由于低位的数字字符先加到了结果字符串中, 最后还需要 reverse 一次, 让位置恢复正常。\r\n\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int k) {\r\n        if (k == 0) return A;\r\n        vector<int> res;\r\n        int n = A.size();\r\n        // 对位相加\r\n        int carry = 0;\r\n        int sum = 0;      \r\n        int i = n - 1; \r\n        while (k > 0 || i >= 0)\r\n        {\r\n            sum = carry + (k % 10);\r\n            if (i >= 0) // 保证访问A[i]前不越界\r\n                sum += A[i];\r\n\r\n            carry = (sum <= 9) ? 0 : 1;\r\n            res.push_back(sum % 10);            \r\n            k = k / 10;\r\n            \r\n            i--;\r\n        }\r\n        if (carry == 1) res.push_back(1);\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n\r\n代码已上传到: [leetcode-ac/91algo - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(max(n, k))，其中 n 为数组长度, k为数K的长度。\r\n- 空间复杂度：O(n), 主要是结果数组用的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917028429","body":"## 思路\r\n\r\n**题意**: 计算 `abs[i] = indexGap(i, 最近的字符c)`, 1 <= s.length <= 10^4\r\n输出 `abs[i]`的数组\r\n\r\n### 解法: 双指针 中心扩展\r\n\r\n使用一个结果数组 gaps[]\r\n\r\n将string s转为字符数组，然后从前往后遍历。\r\n循环变量记作i, 对于每一趟: \r\n如果当前字符就是要搜索的字符c, 距离记为 0，否则分别向左、向右找最近的字符c。\r\n向左找, 找到第一个字符c, 将指针i与之的index之差记作leftDistance。\r\n向右找, 找到第一个字符c, 将指针i与之的index之差记作rightDistance。\r\n取两者的较小值。\r\n\r\n依次填充 gaps[i] 的值即可。\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> gaps(s.size());\r\n        vector<char> chars(s.begin(), s.end());\r\n\r\n        for (int i = 0; i < chars.size(); i++)\r\n        {\r\n            // 如果当前字符就是要搜索的字符c, 距离为 0\r\n            if (chars[i] == c) gaps[i] = 0;\r\n            else /* 否则分别向左、向右找最近的字符c */\r\n            {\r\n                int leftDistance = INT_MAX, rightDistance = INT_MAX;\r\n                for (int left = i; left >= 0; left--)\r\n                {\r\n                    if (chars[left] == c) // 向左找, 找到第一个\r\n                    {\r\n                        leftDistance = i - left;\r\n                        break;\r\n                    }\r\n                }\r\n                for (int right = i; right < chars.size(); right++) // 向右找, 找到第一个\r\n                {\r\n                    if (chars[right] == c)\r\n                    {\r\n                        rightDistance = right - i;\r\n                        break;\r\n                    }\r\n                }\r\n                gaps[i] = min(leftDistance, rightDistance);\r\n            }\r\n        }\r\n\r\n        return gaps;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n代码已同步上传到: [leetcode-ac/91algo - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(n^2)，其中 n 为字符串长度。\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917431784","body":"## 思路\r\n根据题目标签，用栈试试\r\n\r\n### 用栈实现\r\n\r\n用数组模拟栈操作。\r\n对于increment操作，求和即可。\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int size;\r\n\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        size = 0;\r\n    }\r\n\r\n    void push(int x) {\r\n        if (size < stack.size())\r\n        {\r\n            stack[size] = x;\r\n            size++;            \r\n        }\r\n    }\r\n\r\n    int pop() {\r\n        int res = -1;\r\n        if (size > 0)\r\n        {\r\n            size--;\r\n            res = stack[size];\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < min(k, size); i++)\r\n            stack[i] += val;\r\n    }\r\n};\r\n```\r\n\r\n代码已上传到: [leetcode-ac/91algo - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo)\r\n\r\n## 复杂度分析\r\n\r\n- **时间复杂度**:  O(k)\r\n插入和弹出为O(1)，累加操作需要遍历 O(k)个元素。\r\n\r\n- **空间复杂度**\r\n需要额外 O(maxSize)的栈空间。\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917667105","body":"## 思路\r\n\r\n规律:\r\n对于每一个小段, 如果有n层配对的中括号, 那么它的格式是:\r\n`n[xxx]`\r\n\r\n如果出现次数是1, 那么它的格式是:\r\nxxx,\r\n1和`[]`直接不写, 和原串相同.\r\n\r\n如果存在多层中括号, 则需要使用**栈**或**递归**的方式解决。\r\n\r\n## 栈\r\n\r\n使用两个stack (后面直接将deque用作stack, 性能更好),\r\n一个stack存放重复出现的次数。\r\n另一个stack存储扫描到的字符串。\r\n将结果字符串记作resStr。\r\n\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        deque<int> numStack;\r\n        deque<string> strStack;\r\n        string resStr;\r\n\r\n        int n = s.size();\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            char ch = s[i];\r\n            if (isdigit(ch))\r\n            {\r\n                int digit = ch - '0';\r\n                while (i < n - 1 && isdigit(s[i + 1]))\r\n                {\r\n                    digit = digit * 10 + s[i + 1] - '0';\r\n                    i++;\r\n                }\r\n                numStack.push_front(digit);\r\n            }\r\n            else if (ch == '[')\r\n            {\r\n                strStack.push_front(resStr);\r\n                resStr.clear();\r\n            }\r\n            else if (ch == ']')\r\n            {\r\n                string tmp = strStack.front();\r\n                strStack.pop_front();\r\n                int repeatCount = numStack.front();\r\n                numStack.pop_front();\r\n                for (int j = 0; j < repeatCount; j++)\r\n                    tmp.append(resStr);\r\n\r\n                resStr = tmp;\r\n            }\r\n            else resStr.push_back(ch);  // 直接取出来放进结果字符串中\r\n        }\r\n        return resStr;\r\n    }\r\n};\r\n```\r\n\r\n\r\n代码已上传到: [leetcode-ac/91algo - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918342651","body":"## 思路\r\n\r\n### 使用两个栈\r\n\r\n使用两个栈s1, s2设计一个\"队列\", 就是要求弄出一个容器, 按照先进先出的要求工作, 且注意栈必须是从同一端插入和弹出。而\"队列\"是从一端插入、另一端弹出。\r\n\r\ns1用来做一开始的push, pop功能使用s2做反向：将s1中的数全扔到s2中，再从s2中取时顺序就是先进先出了。\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass MyQueue {\r\n    stack<int> s1, s2;\r\n    int front;\r\n    \r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {}\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        if(s1.empty())\r\n            front = x;\r\n        \r\n        s1.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if(s2.empty()){\r\n            while(!s1.empty()){     /* 把s1中的元素全部移到s2中 */\r\n                s2.push(s1.top());\r\n                s1.pop();\r\n            }\r\n        }\r\n        int res = s2.top();\r\n        s2.pop();\r\n\r\n        return res;\r\n    }\r\n\r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(!s2.empty())\r\n            return s2.top();\r\n        \r\n        return front;\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s1.empty() && s2.empty();\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n代码已上传到: [leetcode-ac/91algo daily - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo/daily)\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：\r\npush: O(1)\r\npop:  平均 O(1)\r\npeek: O(1)\r\nempty: O(1)\r\n\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919295677","body":"## 思路\r\n\r\n### 排序+求和\r\n\r\n对比未排序的原数组和从小到大排序后的数组。\r\n\r\n---\r\n\r\n该题页面下方有个提示:\r\n\r\n> Each k for which some permutation of arr[:k] is equal to sorted(arr)[:k] is where we should cut each chunk.\r\n\r\n大意是当arr的前k个元素从小到大排序的序列是arr的前k个元素的某一种排列时，我们就能够将其分隔成1个块了。\r\n\r\n---\r\n\r\n根据题目的提示可知：**当一个分块包含的不同数的个数与排序后对应的分块中不同的数刚好能对应上，那就可以切割成为单独的块了**。\r\n\r\n既然每个分块中数字是一样的，那它们的和也是一样的了，可以依次作为分块判断的依据。可以用一个从index=0开始的滑动窗口(滑动窗口对应的区间是[0, i])同时扫描原数组和排序数组，当窗口中数字的和相等时，就将数组进行分块，分块数量增加1。\r\n\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        vector<int> sortedArr(arr);\r\n        sort(sortedArr.begin(), sortedArr.end());\r\n\r\n        long arrSum = 0;\r\n        long sortedSum = 0;\r\n        int maxCount = 0;\r\n        int n = arr.size();        \r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            arrSum += arr[i];\r\n            sortedSum += sortedArr[i];\r\n            if (arrSum == sortedSum)   /* 当区间[0, i]中的数已经处于正确的区间上时, \r\n                                    该数字及其前面相邻的数组成的片段只要排序就满足要求了。\r\n                                    这个片段已处理完毕，可以为数量贡献1了。 */\r\n                maxCount++;\r\n        }\r\n        return maxCount;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n代码已上传到: [leetcode-ac/91algo daily - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo/daily)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(n log n), n为数组长度，数组排序的平均时间复杂度是 O(n log n)\r\n- 空间复杂度：O(n), n 为数组长度\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920166848","body":"## 思路\r\n\r\n### 取模 + 两次遍历\r\n\r\n**C++思考方式:**\r\n将head指针复制为tail (这里tail是当前结点cur, 每次移动一位, 当tail的next为 NULL时, tail成为尾结点)，先遍历一次算出长度len。\r\n\r\n由于k可能会超过链表长度len，于是需要用一个预处理小技巧 - k对len取模，shift = k % len。如果shift = 0, 不需要继续处理了。\r\n\r\n否则，将head指针复制为prev, 再while循环一次, 迭代次数为 len - shift。循环结束时, prev的next指针指向的位置就是所求链表的头结点。使用一个新的指针nextP占住prev的next指针指向的位置, 将head结点挂接到tail的next指针上，然后将prev的next置为NULL, 最后返回 nextP 指针。\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (head == NULL) return head;\r\n        int len = 1;\r\n        ListNode* tail = head;\r\n        \r\n        /* while循环一次，得到长度len。这里tail是当前结点cur, 当tail的next为 NULL时, tail成为尾结点 */\r\n        while (tail->next)\r\n        {\r\n            tail = tail->next;\r\n            ++len;\r\n        }\r\n        int shift = k % len;\r\n        if (shift == 0)\r\n            return head;        \r\n\r\n        ListNode* prev = head;\r\n        /* 再while循环一次, 迭代次数为 len - shift */\r\n        while (--len > shift)      // 处理len - shift个结点\r\n        {\r\n            prev = prev->next;\r\n        }\r\n\r\n        ListNode* nextP = prev->next;\r\n        tail->next = head;\r\n        prev->next = NULL;\r\n\r\n        return nextP;        \r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n代码已上传到: [leetcode-ac/91algo daily - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo/daily)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(n), 两次遍历链表, 一次长度为 n, 另一次为 n - k % n\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921047480","body":"## 思路\r\n\r\n貌似可以递归做, 也可以迭代做。\r\n\r\n草稿纸上画画图, 就清晰怎么做了。\r\n\r\n### 递归解法\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == NULL || head->next == NULL)\r\n            return head;\r\n\r\n        ListNode* newHead = head->next;\r\n        head->next = swapPairs(newHead->next);  // 后面的交给递归解决\r\n        newHead->next = head;\r\n        \r\n        return newHead;\r\n    }\r\n};\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：O(n), n 为链表长度。\r\n- 空间复杂度：O(n), n 为链表长度，额外空间是递归栈的空间。\r\n\r\n\r\n### 迭代解法\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n    {\r\n        if (head == NULL || head->next == NULL)\r\n            return head;\r\n\r\n        ListNode *fakeHead = new ListNode(-1);\r\n        fakeHead->next = head;\r\n        ListNode *cur = fakeHead;\r\n        while (cur->next != NULL && cur->next->next != NULL)\r\n        {\r\n            ListNode *swap1 = cur->next;      /* ①与②号结点交换 */\r\n            ListNode *swap2 = cur->next->next;\r\n            cur->next = swap2;\r\n            swap1->next = swap2->next;        /*交换后①号结点的next指针指向③号结点*/\r\n            swap2->next = swap1;\r\n            cur = swap1;\r\n        }\r\n        return fakeHead->next;\r\n    }\r\n};\r\n```\r\n\r\n#### 复杂度分析\r\n- 时间复杂度：O(n), n 为链表长度。\r\n- 空间复杂度：O(1)。\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921914288","body":"## 思路\r\n\r\n### 先遍历完链表, 再用dfs构建bst\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        vector<int> nums;\r\n        getNums(head, nums);\r\n        return dfs(nums, 0, nums.size() - 1);\r\n    }\r\n    void getNums(ListNode* head, vector<int>& nums)\r\n    {\r\n        while (head)\r\n        {\r\n            nums.push_back(head->val);\r\n            head = head->next;\r\n        }\r\n    }\r\n    TreeNode* dfs(vector<int>& nums, int start, int end)\r\n    {\r\n        if (start == end)\r\n        {\r\n            TreeNode* root = new TreeNode(nums[start]);\r\n            return root;\r\n        }\r\n        if (start < end)\r\n        {\r\n            int m = (end - start) / 2 + start;\r\n            auto leftChild =  dfs(nums, start, m - 1);\r\n            auto rightChild =  dfs(nums, m + 1, end);\r\n            TreeNode* root = new TreeNode(nums[m], leftChild, rightChild);\r\n            return root;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```\r\n\r\n\r\n代码已上传到: [leetcode-ac/91algo daily - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo/daily)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(n log n)\r\n- 空间复杂度：O(n), 用了个额外的数组存储链表结点的值\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922333627","body":"## 思路\r\n\r\nL1和L2的数据举例如下:\r\n\r\n\r\nL1: 1 -> 2 -> 3 -> 4 -> 5 ->6\r\nL2: 7 -> 4 -> 5 -> 6\r\n\r\n接下来，我们来分析这个链表问题，其实所有的链表问题都是玩指针。我们先来看看最容易想到的暴力法求解，然后对其进行改进。\r\n\r\n\r\n\r\n\r\n### 方法1: 暴力法\r\n\r\n用两个指针p1, p2，都从头开始走，按题意两指针肯定在某一位置相遇，该方法的时间复杂度为O(m*n)。\r\n\r\n\r\n![p1-双指针分别从头开始遍历](https://pic.leetcode-cn.com/1625892902-mnwPbA-image.png)\r\n\r\n\r\n\r\n那有没有更快的方法，找到这个点呢？\r\n\r\n\r\n\r\n\r\n假如**两个链表一样**长，那么两个指针同步向前走，第1次汇合时就找到了。\r\n\r\n\r\n![p2](https://pic.leetcode-cn.com/1625892928-TfnxGF-image.png)\r\n\r\n\r\n现在遇到的问题是，我们不知道这两个链表的长度，更一般的情形是两个长度不一样，长度差记为 gapLen。此时如果两个指针都从头同步走，必然会丢失一些点，且两指针很有可能无法相遇(错过汇合的那个节点)。那对此有什么办法呢？\r\n\r\n\r\n### 方法2: 让较长的链表先走 gapLen 步，接下来两个指针同步向前走\r\n\r\n分别遍历1次链表L1 和 L2, 得到长度len1和len2, 记作长度差gapLen = abs(len1 - len2)。\r\n\r\n假如我们让较长的链表先走 gapLen 步，接下来两个指针同步向前走，那么在第1次汇合时就能找到了。这就是目前最好的思路了，时间复杂度降为 O(m+n)。\r\n\r\n![p3](https://pic.leetcode-cn.com/1625892839-dpjTmX-image.png)\r\n\r\n\r\n## 代码(方法2)\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\r\n    {\r\n        if (headA == NULL || headB == NULL)\r\n            return NULL;\r\n        int len1 = getLen(headA);\r\n        int len2 = getLen(headB);\r\n\r\n        // 较长链表的head指针先移动 gapLen 个位置\r\n        int gap = abs(len1 - len2);\r\n        if (len1 >= len2)\r\n        {            \r\n            while (gap--)\r\n                headA = headA->next;\r\n        }\r\n        else\r\n        {\r\n            while (gap--)\r\n                headB = headB->next;\r\n        }\r\n        // 指针headA 和 headB同步向前移动，遇到相同则直接返回\r\n        while (headA != NULL) {\r\n            if (headA == headB) {\r\n                return headA;\r\n            }\r\n            headA = headA->next;\r\n            headB = headB->next;\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n    int getLen(ListNode *head)\r\n    {\r\n        int count = 0;\r\n        ListNode *p = head;\r\n        while (p != NULL)\r\n        {\r\n            count++;\r\n            p = p->next;\r\n        }\r\n        return count;\r\n    }    \r\n};\r\n```\r\n\r\n代码已上传到: [leetcode-ac/91algo daily - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo/daily)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(m+n)\r\n- 空间复杂度：O(1)\r\n\r\n**ps**: 之前用C# 写了一次这个题的题解, 发表在[力扣题解区](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tong-bu-shuang-zhi-zhen-fa-cban-qing-xi-j2hgz/) .","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922500004","body":"## 思路\r\n\r\n### 方法1: 使用 set\r\n\r\n使用set，判断重复出现。当出现环时, 会试图将一个已经插入到set中的node进行第二次插入，此时set会获得状态: 插入失败。\r\n故第一个重复插入(插入的状态为false)的结点就是入环的第一个结点。\r\n\r\n\r\n### 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        set<ListNode*> st;\r\n        ListNode* p = head;\r\n        ListNode* res = NULL;\r\n\r\n        while(p != NULL)\r\n        {\r\n            if(st.insert(p).second == false)  /* 向set中插入node失败，说明是第2次出现了，第1个出现第2次的 */\r\n            {\r\n                res = p;\r\n                return res;\r\n            }\r\n            p = p -> next;\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```\r\n\r\n\r\n代码已上传到: [leetcode-ac/91algo daily - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo/daily)\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n### 方法2: 快慢指针\r\n\r\n对链表先做一轮遍历, 这一轮中, 快指针每次走2步, 慢指针每次走1步, 如果快慢指针恰好指向了同一个结点就break掉。\r\n\r\n如果快慢指针还没相遇就把慢指针拉回链表开头的位置进行第2轮遍历, 这一轮中, 快指针每次走1步, 慢指针每次也走1步, 循环结束时，慢指针即为入环的第一个结点。\r\n\r\n### 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode* slow = head;\r\n        ListNode* fast = head;\r\n\r\n        while (fast != NULL && fast->next != NULL)\r\n        {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n            if (slow == fast)\r\n                break;\r\n        }\r\n        /* 处理上一轮遍历结束时的临界情况 */\r\n        if (fast == NULL || fast->next == NULL)\r\n            return NULL;\r\n        slow = head;\r\n        while (fast != slow)   /* 只要还没相遇就继续循环 */\r\n        {\r\n            slow = slow->next;\r\n            fast = fast->next;  /* 此轮循环每次只走一步 */\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZiyangZ":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916314383","body":"- Talk about how to make an easy problem complicated:\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int size = Math.max(num.length, String.valueOf(k).length());\n        int dif = size - num.length; \n        int[] ans = new int[size];\n        int carry = 0;\n        for (int i = ans.length - 1; i >= 0; i--) {\n            int n = (i - dif) < 0 ? 0:num[i - dif];\n            int m = k % 10;\n            k = k / 10;\n            ans[i] = (n + m + carry) % 10;\n            carry = (n + m + carry) / 10;\n        }\n        \n        List<Integer> list = new ArrayList<>();\n        if (carry == 1) list.add(1);\n        for (int i: ans) list.add(i);\n        \n        return list;\n    }\n}\n```\n\n- So turns out all we need to do is adding digits from the last position and reverse the list.\n- Time and space O(max(n, m)) where n is the length of num and m is the number of digits in k.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917038224","body":"- Time and space O(n).\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        List<Integer> index = new ArrayList<>();\n        index.add(Integer.MAX_VALUE);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) index.add(i);\n        }\n        index.add(Integer.MAX_VALUE);\n        \n        int[] ans = new int[s.length()];\n        int i = 1;\n        for (int j = 0; j < s.length(); j++) {\n            ans[j] = Math.min(Math.abs(j - index.get(i)), Math.abs(j - index.get(i - 1)));\n            if (j == index.get(i)) i++;\n        }\n        \n        return ans;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917714370","body":"- Time O(maxCount * n) where maxCount is the maximum value of integer in s and n is the length of s.\n- Space O(n).\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder ans = new StringBuilder();\n        int count = 0;\n        Stack<Integer> countStack = new Stack<>();\n        Stack<StringBuilder> stringStack = new Stack<>();\n        for (char c: s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                if (countStack.isEmpty()) ans.append(c);\n                else {\n                    stringStack.push(stringStack.pop().append(c));\n                }\n            }\n            if (Character.isDigit(c)) {\n                count = 10 * count + c - '0';\n            }\n            if (c == '[') {\n                countStack.push(count);\n                count = 0;\n                stringStack.push(new StringBuilder());\n            }\n            if (c == ']') {\n                int n = countStack.pop();\n                StringBuilder sb = stringStack.pop();\n                if (countStack.size() == 0) {\n                    for (int i = 0; i < n; i++) {\n                        ans.append(sb);\n                    }\n                } else {\n                    StringBuilder cur = stringStack.pop();\n                    for (int i = 0; i < n; i++) {\n                        cur.append(sb);\n                    }\n                    stringStack.push(cur);\n                }\n            }\n        }\n        return ans.toString();\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919631226","body":"- The brute force way is to compare the array with the sorted one. If a segment of elements is the same but in a different order, the number of chunks adds one. Originally I use two TreeMaps to compare the elements. This is not necessary. A HashMap will work. When comparing two HashMaps, the sequence of the keys and values does not matter.\r\n- The sorting takes O(nlogn). For the worst case (chunk == 1), comparing two HashMaps takes O(n) time so the total time is O(n^2). Space is O(n). Surprisingly this is not TLE on LC.\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] arr2 = arr.clone();\r\n        Arrays.sort(arr2);\r\n        Map<Integer, Integer> map1 = new HashMap<>();\r\n        Map<Integer, Integer> map2 = new HashMap<>();\r\n        \r\n        int ans = 0;\r\n        for (int i = 0; i < arr.length; i++) {\r\n            map1.put(arr[i], map1.getOrDefault(arr[i], 0) + 1);\r\n            map2.put(arr2[i], map2.getOrDefault(arr2[i], 0) + 1);\r\n            if (map1.equals(map2)) {\r\n                ans++;\r\n                map1.clear();\r\n                map2.clear();\r\n            }\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n- The optimal solution is using a monotonic stack. This is more like a greedy method because it's neither easy to prove nor easy to come up with during an interview. So just remember it.\r\n- Suppose we have multiple chunks in the array, each chunk has the largest value. All we need to do is find these largest values. These values mark the end of each chunk. We push the element to the stack if it is larger than the top value. As long as it is larger than the top value, it means we can start a new chunk. If it is smaller, we pop the top of the stack and save it somewhere. This top value represents the largest value in the current chunk and it will be pushed back later. Now we need to find the largest value in the previous chunk. That value should be smaller than the current number. We pop all the values that are larger than the current value because all these values become the middle part of the chunk. In the end, we return the size of the stack.\r\n- In the worst case each element is pushed in and popped out once. The time is O(n) and space is O(n).\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        for (int n: arr) {\r\n            if (stack.isEmpty() || stack.peek() <= n) {\r\n                stack.push(n);\r\n            } else {\r\n                int top = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > n) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(top);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922491752","body":"```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode curA = headA;\r\n        ListNode curB = headB;\r\n        while (curA != curB) {\r\n            if (curA.next == null && curB.next == null) return null;\r\n            curA = (curA.next == null)? headB:curA.next;\r\n            curB = (curB.next == null)? headA:curB.next;\r\n        }\r\n        return curA;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cicihou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916314749","body":"``` python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res = []\r\n        for i in num:\r\n            res.append(str(i))\r\n        res = str(int(''.join(res)) + k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n        \r\n```\r\n\r\n\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917058171","body":"``` python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        c_position = [i for i in range(len(s)) if s[i] == c]\n        return [min([abs(c-i) for c in c_position]) for i in range(len(s))]\n```\ntime: O(len(s) * len(c))\nspace: O(len(c))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917517660","body":"class CustomStack:\r\n\r\n    def __init__(self, maxSize):\r\n        self.n = maxSize\r\n        self.stack = []\r\n        self.inc = []\r\n\r\n    def push(self, x):\r\n        if len(self.inc) < self.n:\r\n            self.stack.append(x)\r\n            self.inc.append(0)\r\n\r\n    def pop(self):\r\n        if not self.inc: return -1\r\n        if len(self.inc) > 1:\r\n            self.inc[-2] += self.inc[-1]\r\n        return self.stack.pop() + self.inc.pop()\r\n\r\n    def increment(self, k, val):\r\n        if self.inc:\r\n            self.inc[min(k, len(self.inc)) - 1] += val\r\n        \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917673177","body":"``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ''' stack '''\r\n        stack = []\r\n        for i in s:\r\n            if i == ']':\r\n                volume = ''\r\n                tmp = ''\r\n                while stack[-1] != '[':\r\n                    val = stack.pop()\r\n                    tmp = val + tmp\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    a = stack.pop()\r\n                    volume = a + volume\r\n                stack.append(int(volume) * tmp)\r\n            else:\r\n                stack.append(i)\r\n        return ''.join(stack)\r\n```\r\n\r\n时间：最坏情况 O(n^2)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918459024","body":"class MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.item = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n\n        如果用栈的思想来做，栈在 push 不能保证先入先出的\n        每一次要用一个help_stack 实现栈的翻转\n        while self.stack:\n            self.help_stack.append(self.stack.pop())\n        self.help_stack.append(x)\n        while self.help_stack:\n            self.stack.append(self.help_stack.pop())\n        \"\"\"\n        self.item.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        return self.item.pop(0)\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.item[0]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.item) == 0\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919603344","body":"``` python\n'''\n题解：https://github.com/azl397985856/leetcode/blob/master/problems/768.max-chunks-to-make-sorted-ii.md\n\n方法一：计数分桶（参考 769）\n方法二：单调栈\n'''\n\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        '''\n        method 1 分桶计数\n\n        分桶计数核心：\n        如果两个数组的计数信息是一致的，那么两个数组排序后的结果也是一致的\n\n        因此我们用排序过的数组，跟原本的数组相比较，来判断是否可以分块\n        '''\n        res = 0\n        cache = {}\n        cache2 = {}\n        for i, j in zip(arr, sorted(arr)):\n            cache[i] = cache.get(i, 0) + 1\n            cache2[j] = cache2.get(j, 0) + 1\n            if cache == cache2:\n                res += 1\n        return res\n\n        '''\n        method 2 分桶计数 - 优化写法\n        代码：https://leetcode.com/problems/max-chunks-to-make-sorted-ii/discuss/113465/JavaPython-Easy-and-Straight-Froward\n        '''\n\n        res, s1, s2 = 0, 0, 0\n        for a, b in zip(arr, sorted(arr)):\n            s1 += a\n            s2 += b\n            res += s1 == s2\n        return res\n\n        '''\n        method 3\n        monostack\n        '''\n        # TODO\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920201646","body":"``` PYTHON\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0:\n            return head\n        length = 0\n\n        cur = head\n        while cur:\n            length += 1\n            cur = cur.next\n        if length in (0, 1):\n            return head\n        \n        fast = head\n        slow = head\n        \n        for _ in range(k % length):\n            fast = fast.next\n        \n        while fast.next and slow:\n            fast = fast.next\n            slow = slow.next\n        fast.next = head\n        cur = slow.next\n        slow.next = None\n        return cur","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921227125","body":"``` python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        cur = dummy = ListNode(0, head)\n        while cur.next and cur.next.next:\n            fir = cur.next\n            sec = cur.next.next\n            cur.next = sec\n            fir.next = sec.next\n            sec.next = fir\n            cur = fir\n        return dummy.next","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922016493","body":"``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return\n        if not head.next:\n            return TreeNode(head.val)\n        \n        fast = slow = head\n        pre = None\n        while fast and fast.next:\n            pre = slow\n            fast = fast.next.next\n            slow = slow.next\n        root = TreeNode(slow.val)\n        pre.next = None\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922408528","body":"``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return\n\n        dic = {}\n        while headA:\n            dic[headA] = None\n            headA = headA.next\n        while headB:\n            if headB in dic:\n                return headB\n            else:\n                headB = headB.next\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922500336","body":"``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        cur = head\n        cache = {}\n        while cur:\n            if cur not in cache:\n                cache[cur] = cur\n            else:\n                return cache[cur]\n            cur = cur.next\n        return None\n            ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shixinlovey1314":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916315048","body":"# ***Title:989. Add to Array-Form of Integer***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/add-to-array-form-of-integer/)\n\n## ***Solution***\n1. Revert the array, so that we only need to manipulate the end of the array.\n2. Extract the lowest digit of K and add into the array ascendingly. \n3. After each addition, if the item at the given index excceds 10, then only keep the lowest digit part and add 1 to the next item in the array (Watch out the array boundary and expand the array by 1 if needed..\n4. After processed K, check if there still exist delta > 0, if so keep on repeating the process similar to step 2 until delta equals 0.\n5. Revert the array back.\n\n## ***Code***\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int index = 0;\n        int delta = 0;\n        \n        std::reverse(num.begin(), num.end());\n        \n        while (k > 0) {\n            delta += k % 10 + num[index];\n            k /= 10;\n            \n            num[index++] = delta % 10;\n            delta /= 10;\n            \n            if (index == num.size() && (k > 0 || delta > 0))\n                num.push_back(0);\n        }\n        \n        while (delta > 0) {\n            delta += num[index];\n            num[index++] = delta % 10;\n            delta /= 10;\n            \n            if (index == num.size() && (delta > 0))\n                num.push_back(0);\n        }\n            \n        std::reverse(num.begin(), num.end());\n        \n        return num;\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(max(N, M)), N is the size of the array, while M is the size of the virtual array form of K, which is logarithm of base 10 -> log10(K).\n\n### ***Space Complexity and Explaination***\nO(1) since we reuse the input array and didn't need any extra space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917319452","body":"# ***Title: 821. Shortest Distance to a Character***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/shortest-distance-to-a-character/)\n\n## ***Solution***\nStore all the indices of c in an array called helper_array, then traverse the original array and compare the indices with helper_array, to update the distance.\nSince the indices in helper_array will be in assend order, we can use 2 pointers, one points to the orginal array (po) and the other points to the helper array(ph), keep on moving the po, but only moves the ph when po > helper_array[ph], and each time compare the po with ph -1 and ph and use the smaller value to update the output array.\n## ***Code***\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> helper_array;\n        vector<int> dis(s.length(), INT_MAX);\n        \n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] == c) {\n                helper_array.push_back(i); \n            }\n        }\n        \n        for (int i = 0, j = 0; i < s.length() && j < helper_array.size(); i++) {\n            if (i > helper_array[j] && j < helper_array.size() - 1) j++;\n            \n            if (i < helper_array[j]) {\n                // compare with j - 1.\n                dis[i] = j == 0? INT_MAX : i - helper_array[j - 1];\n                // compare with j.\n                dis[i] = min(dis[i], helper_array[j] - i);\n            } else if (i > helper_array[j]) {\n                // compare with j + 1\n                dis[i] = j == helper_array.size() - 1? INT_MAX : helper_array[j + 1] - i;\n                // compare with j\n                dis[i] = min(dis[i], i - helper_array[j]);\n            } else {\n                dis[i] = 0;\n            }\n            \n        }\n        \n        return dis;\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(n), we first iterated the orginal array to setup the helper_array which takes O(n) time.\nDuring comparasion, since we will visit each item in the original array for 1 once, and each vistit we would compare with most 2 items from helper_array, which take O(2n)\nTotal time complexity is O(n) + O(2n) = O(n)\n\n### ***Space Complexity and Explaination***\nO(n) for the helper_array, and in the worst case, the helper_array will have the same size as the original array.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917541883","body":"# ***Title:1381. Design a Stack With Increment Operation***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n## ***Solution***\nWe can use an array to implement the stack, use an index to track the top of the stack.\nArray supports random access, so it is very easy to do inc, and for push and pop, we just need to change the tracking index accordingly.\n## ***Code***\n```C++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        dataStore = vector<int> (maxSize);\n        topIndex = 0;\n        size = maxSize;\n    }\n    \n    void push(int x) {\n        if (topIndex == size)\n            return;\n        dataStore[topIndex++] = x;\n    }\n    \n    int pop() {\n        if (topIndex == 0)\n            return -1;\n        return dataStore[--topIndex];\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < k && i < topIndex; i++)\n            dataStore[i] += val;\n    }\n    \nprivate:\n    vector <int> dataStore;\n    int topIndex;\n    int size;\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nCustomStack(int maxSize) takes O(1), since we can allocate the array with 1 opereation.\nPush and pop both takes O(1), since we just need to manipulate the tracking index.\nInc takes O(k), which k is the number of items that we want to increment.\n\n### ***Space Complexity and Explaination***\nO(n), which n is the maxSize that passes in.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917815080","body":"# ***Title:394. Decode String***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/decode-string/)\n\n## ***Solution***\nNaturally, we can think of using stack to solve this problem, we start push to then stack when we see a digit and start pop the stack when we see the ']', untill we see the '\\['  at that point we save all the chars between '\\[' and ']' into a temp string, we then popup the digit from the stack and add them into the result.\nthe only issue is when the encoded string itself is enbeded with another encoded string.\nTo solve this, we can so a small modification to the stack, after we decode the string using the stack, we check if the stack is NULL,\n\n## ***Code***\n```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string result;\n        stack<char> encodingStack;\n        bool isPush = false;\n        \n        for (char c : s) {\n            if (isdigit(c) || (isPush && c != ']')) {\n                isPush = true;\n                encodingStack.push(c);\n            } else if (c == ']') {\n                isPush = false;\n                \n                string tmp;\n                while (!encodingStack.empty() && encodingStack.top() != '[') {\n                    tmp.push_back(encodingStack.top());\n                    encodingStack.pop();\n                }\n                // pop out '['\n                encodingStack.pop();\n                reverse(tmp.begin(), tmp.end());\n                \n                \n                string numStr;\n                \n                while (!encodingStack.empty() && isdigit(encodingStack.top())) {\n                    numStr.push_back(encodingStack.top());\n                    encodingStack.pop();\n                }\n                \n                reverse(numStr.begin(), numStr.end());             \n                \n                // pop out num\n                int num = stoi(numStr);\n                \n                string addition;\n                for (int i = 0; i < num; i++) {\n                    addition.append(tmp);\n                }\n                \n                if (encodingStack.empty())\n                    result.append(addition);\n                else {\n                    for (char ch : addition)\n                        encodingStack.push(ch);\n                    isPush = true;\n                }\n                \n            } else {\n                result.push_back(c);\n            }\n        }\n        \n        return result;\n    }\n};\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO((maxK to the power of countK)* n): countK is the maximum nested level and maxK is the maximum value of K.\n### ***Space Complexity and Explaination***\nO((maxK to the power of countK)* n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918435552","body":"# ***Title:232. Implement Queue using Stacks***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/implement-queue-using-stacks/)\n\n## ***Solution***\nWe use 1 stack for push(push_stack) and the other stack for pop(pop_stack).\nInitialy, we only push data to the stack, until there's an requst for peek or top.\nWhen peek or top, if pop_stack is not empty, pop the item from the pop_stack, otherwise, pop all the items from the push_stack and push them into the pop_stack.\n\n## ***Code***\n```C++\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        push_stack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        int val =  peek();\n        pop_stack.pop();\n        \n        return val;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if (!pop_stack.empty())\n            return pop_stack.top();\n        \n        while(!push_stack.empty()) {\n            pop_stack.push(push_stack.top());\n            push_stack.pop();\n        }\n        \n        return pop_stack.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return push_stack.empty() && pop_stack.empty();\n    }\n    \nprivate:\n    stack<int> push_stack;\n    stack<int> pop_stack;\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\n    Push: O(1)\n    Pop: O(n) for worst case,  Amortized O(1)\n    Peek: O(n) for worst case, Amortized O(1)\n    empty: O(1)\n### ***Space Complexity and Explaination***\n    O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919381587","body":"# ***Title:768. Max Chunks To Make Sorted II***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/max-chunks-to-make-sorted-ii/)\n\n## ***Solution***\nWe can utilize the fact that we need to compare with the sorted version of the original array.\nGiven a partition of the orignal array, it can be the same as the sorted array only if it contains all the items that suppse to be in the sorted portion.\nFor example:\nOrignal array [2, 1, 3, 4, 4] sorted array [1, 2, 3, 4, 4]\nthe following slice won't work\n[2|1|3|4|4] because when we compare to the sorted array, at index 0, original array will be value 2, while in the soreted array, index 0 will be 1.\n[2,1|3|4|4] will work, because [2, 1] can be soreted to be [1, 2].\n\nWhat's more, to determine whehter a portion can be formed to be the sorted portion, we only need to make sure they have exactly the same numbers.\n\nAlgo:\n1. Get the sorted version of the original array - sortedArray\n2. Compare the original array with the sorted array, while using a slide window [start, end]\n3. increase end until the numbers in [start, end] fron the orginial array are exactlay the same as the portion in the sorted array.\n4. Add the count and set start = end + 1\n\nOne techic for the sliding window comparison: we just need to use one map.\nWhen we encounter a num x from original array, we increaset the count of xin the map.\nWhen we encounter a num y from the sorted array, we decrease the count of y in the map.\nif x or y becomes 0, we remove it from the map.\n\nSo the two porttions are identical when the map is empty.\n\n## ***Code***\n```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int count = 0;\n        vector<int> sorted(arr);\n        unordered_map<int, int> checker;\n        \n        // Get the sorted version\n        std::sort(arr.begin(), arr.end());\n        \n        for (int index = 0; index < arr.size(); index++) {            \n            if ((++checker[sorted[index]]) == 0) {\n                checker.erase(sorted[index]);\n            }\n            \n            if ((--checker[arr[index]]) == 0) {\n                checker.erase(arr[index]);\n            }\n            \n            if (checker.empty()) {\n                count++;\n            }\n        }\n        \n        \n        return count;\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nWe need O(nlogn) to get the sorted array. \nOnce we got the sorted array, we just need to compare the two arrays, which takes O(n)\nSo the total time complexity is O(nlogn) + O(n) = O(nlogn)\n### ***Space Complexity and Explaination***\nWe need O(n) to store the sorted array, we also need worst O(n) for the map that will be used to compare the two portions.\nSo the total space complexity is O(n) + O(n) = O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920520988","body":"# ***Title:61. Rotate List***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/rotate-list/)\n\n## ***Solution***\n1. Itereate through the list,  count the number of nodes in the list and store the last node.\n2. calculate the offset for the breaking point.\n3. Jump to the pre node of breaking point, prenode->next = null,  link the last node with the previous head.\n4. return the breaking point which is the new node.\n\n## ***Code***\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) { \n        if (!head)\n            return head;\n        \n        ListNode* node = head;\n        ListNode* last = NULL;\n        int count = 0;\n        \n        while (node) {\n            last = node;\n            node = node->next;\n            count++;\n        }\n        \n        if (k >= count) {\n            k %= count;\n        }\n        \n        if (!k)\n            return head;\n        \n        count -= k;\n        \n        node = head;\n        ListNode* pre = NULL;\n        while (count--) {\n            pre = node;\n            node = node->next;\n        }\n        \n        if (pre && last) {\n            pre->next = NULL;\n            last->next = head;\n        }\n        \n        return node;\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(n)\n### ***Space Complexity and Explaination***\nO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921107642","body":"# ***Title:24. Swap Nodes in Pairs***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/swap-nodes-in-pairs/)\n\n## ***Solution***\nTo swap two adjacent nodes, we need to know the preNode which might be tricy, so we can introce a dummy head.\nThen swao the nodes as we visiting the list.\n\n## ***Code***\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        \n        ListNode* pre = dummy;\n        \n        while(pre && pre->next && pre->next->next) {\n            ListNode* p1 = pre->next;\n            ListNode* p2 = p1->next;\n            \n            p1->next = p2->next;\n            p2->next = p1;\n            pre->next = p2;\n            \n            pre = p1;\n        }\n        \n        return dummy->next;\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(n)\n### ***Space Complexity and Explaination***\nO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922165033","body":"# ***Title:109. Convert Sorted List to Binary Search Tree***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n## ***Solution***\nTo make the tree a weighted binary tree, each time we need to make the middle point as the root node.\nSo the problem is to find the middle point of the list, then recursively build its left subtree and right subtree.\n\n## ***Code***\n```C++\nclass Solution {\npublic:\n    TreeNode* constructTree(ListNode* start,  ListNode* end) {  \n        if (!start || !end)\n            return NULL;\n        \n        TreeNode *node = new TreeNode();\n        ListNode *pre = start, *slow = start, *fast = start;\n        \n        while (fast && fast != end) {\n            pre = slow;\n            slow = slow->next;\n            fast = fast->next;\n            if (fast && fast != end)\n                fast = fast->next;\n        }\n        \n        node->val = slow->val;\n        node->left = pre == slow? NULL:constructTree(start, pre);\n        node->right = slow == fast? NULL:constructTree(slow->next, end);  \n        \n        return node;\n    }\n    \n    TreeNode* sortedListToBST(ListNode* head) {\n        ListNode* tail = head;\n        while(tail && tail->next)\n            tail = tail->next;\n        return constructTree(head, tail);\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(nlogn)\n### ***Space Complexity and Explaination***\nO(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922411942","body":"# ***Title:160. Intersection of Two Linked Lists***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/intersection-of-two-linked-lists/)\n\n## ***Solution***\nIf list A and list B have intersection, they would have the same tail node (And a subset list of common nodes).\nWhen list A and list B has different length, we just need to fastwind the 'longger' list till their remain length are the same,\nthen we can compare each node on the two lists to find the intersection node.\n\nAlgo:\n1. Go through list A, get lengthA and tailA.\n2. Go through list B, get lengthB and tailB.\n3. if tailA != tailB, return NULL.\n4. compare lenghtA and lengthB, find the longger list.\n5. fastwind the logger list till the two lists have same remain length\n6. Traverse two lists and find the intercestion node.\n\n## ***Code***\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (!headA || !headB)\n            return NULL;\n        \n        int lenA = 1;\n        int lenB = 1;\n        ListNode* nodeA = headA;\n        ListNode* nodeB = headB;\n        \n        while (nodeA && nodeA->next) {\n            lenA++;\n            nodeA = nodeA->next;\n        }\n        \n        while (nodeB && nodeB->next) {\n            lenB++;\n            nodeB = nodeB->next;\n        }\n        \n        if (nodeA != nodeB)\n            return NULL;\n        \n        ListNode* longList = NULL;\n        ListNode* shortList = NULL;\n        \n        if (lenA > lenB) {\n            longList = headA;\n            shortList = headB;\n        } else {\n            longList = headB;\n            shortList = headA;\n        }\n        \n        int delta = abs(lenA - lenB);\n        \n        while (delta--) {\n            longList = longList->next;\n        }\n        \n        while (longList && shortList) {\n            if (longList == shortList)\n                break;\n            longList = longList->next;\n            shortList = shortList->next;\n        }\n        \n        return longList;\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(M+N)\n### ***Space Complexity and Explaination***\nO(1)\n\n## ***Better Solution***\nThe previouse solution has O(M+N) time complexity and O(1) space complexity, but the code is quite long and error prone.\nWe could use an even simpler approach.\n\nLet's say the length of the common list is lenC.\nThe length of the exclusive partion of the listA is lenA\nThe length of the exclusive partion of the listB is lenB.\n\nWe know that lenA + lenC + lenB = lenB + lenC + lenA\n\nSo we can simplify the solution:\npA point to the head of list A\npB point to the head of list B.\nif pA reach the end of list A, point pA to list B.\nif pB reach the end of list B, point pB to list A.\nwhen pA == pB, we have found the intersection.\n\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* pA = headA;\n        ListNode* pB = headB;\n        \n        while (pA != pB) {\n            pA = pA? pA->next : headB;\n            pB = pB? pB->next : headA;\n        }\n        \n        return pA;\n    }\n};\n```\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(M+N)\n### ***Space Complexity and Explaination***\nO(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916317988","body":"## 思路\r\n### 模版\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n### 代码\r\n- 语言： Python3\r\n\r\n```python\r\nfrom collections import deque\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) -1\r\n        res = []\r\n        carry = 0\r\n\r\n        while i >=0 or k != 0:\r\n            if i >= 0:\r\n                curr_num = num[i]\r\n            else:\r\n                curr_num = 0\r\n            if k != 0:\r\n                curr_k = k % 10 \r\n            else:\r\n                curr_k = 0\r\n\r\n            total = curr_num + curr_k + carry\r\n            curr_total = total % 10\r\n            carry = total // 10\r\n            res.append(curr_total)\r\n            i -= 1\r\n            k = k // 10\r\n\r\n        if carry != 0:\r\n            res.append(carry)\r\n\r\n        return res[::-1]\r\n```\r\n\r\n### 复杂度：\r\n- 时间复杂度：$O(n)$ 遍历\r\n- 空间复杂度：$O(n)$ 新创立了一个ans list","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917211204","body":"## 思路和复杂度\n- 暴力：遍历两遍，先遍历一遍记录下target的index -> index_list，再遍历第二遍得到最小值\n- 可以优化的地方：遍历第二遍: \n1. 可以遍历index_list记录最小值 O(n^2); \n2. 可以用一个指针标记最近的target O(N)\n\n## Python3\n```Python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # 两遍遍历\n        index_list = []\n        ans = []\n        min_distance = len(s)\n        for index, char in enumerate(s):\n            if char == c:\n                index_list.append(index)\n\n        for index, char in enumerate(s):\n            for i in range(0, len(index_list)):\n                distance = abs(index-index_list[i])\n                min_distance = min(distance, min_distance)\n                if i == len(index_list) -1:\n                    ans.append(min_distance)\n                    min_distance = len(s)\n\n        return ans\n```\n\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917475437","body":"## 思路\n栈: append(), pop()来实现\n\n## Python3 \n```Python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack == []:\n            return -1\n        else:\n            num = self.stack.pop()\n            return num\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len (self.stack))):\n                self.stack[i] += val\n```\n\n## 复杂度\n时间：\n- push, pop: O(1)\n- increment: O(k)\n\n空间：O(n) \n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917728082","body":"## 思路\n要点：有点类似于左括号、右括号用stack来解决的题目\n- stack = [(str, num)]  用一个string参数来记录目前的string, 用num记录目前的number, 遇到“[”时入栈，遇到“]”出栈\n- 直接用str = top[0] + str[1] * str来输出更新的string\n- 如果是多位数，则num需要考虑进位\n\n## Python3\n```Python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = [] # stack = [(str, num)] 遇到“[”时入栈，遇到“]”出栈\n        str = \"\"\n        num = 0\n\n        for char in s:\n            if char.isdigit():\n                num = num * 10 + int(char) #如果是多位数，要考虑进位*10\n            elif char == '[':\n                stack.append((str, num))\n                str = \"\"\n                num = 0\n            elif char == ']':\n                top = stack.pop()\n                str = top[0] + str*top[1]\n            else:\n                str += char\n        \n        return str\n```\n\n## 复杂度：\ntime O(n), space O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918612804","body":"## 思路\n用两个list, append(), pop() 实现队列: [12345] -> [54321]\n- 一个stack用来接收元素，一个stack用来pop元素\n- 什么时候pop stack1的元素？**当stack2为空的时候将stack1中的元素pop出来，pop全部元素直到stack1为空** \n\n## Python3\n```Python\nclass MyQueue:\n    # 一个stack用来接收元素，一个stack用来pop元素\n    # 需要等到self.stack2为空的时候再将stack1的元素弹出\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.stack2 == []:\n            while self.stack1 != []:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        if self.stack2 == []:\n            while self.stack1 != []:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        if self.stack1 == [] and self.stack2 == []:\n            return True\n        else:\n            return False\n```\n\n## 复杂度：\ntime: pop()，peak() -> O(n), 其他为O(1)\nspace: O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919561067","body":"## 思路\n**单调栈**\n- 维护一个stack，单调递减，如果后面的数字比栈顶(max)小，则说明需要合并块\n- 把栈顶记录下来(这是一个单独的块), 然后逐个比较，如果current_num < stack[i], 则需要把stack中的数字pop()出来 -> 相当于合并不同的块\n- 最后再将栈顶（块的代表）append进stack中\n- 如果后面的数字比栈顶大，则不需要合并，直接append进stack中\n\n## Python\n```Python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]:\n                top = stack.pop()\n                while stack and num < stack[-1]:\n                    stack.pop()\n                stack.append(top)\n            else:\n                stack.append(num)\n        return len(stack)\n```\n\n## 复杂度\ntime: O(n)\nspace: O(n) create a stack\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920569117","body":"## 思路\n难点主要是Node的断开，连接：\n- 应该是断开倒数第K个节点： 倒数第K个节点.next = None\n- 将末尾节点连接到第一个: 末尾节点.next = head\n\n## Python3\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        #就是把原来的链表尾部连上头，然后找倒数第k个点作为新的表头\n        if not head:\n            return \n        p = head\n        i = 1 #记录链表长度\n        while p.next:\n            p = p.next\n            i += 1\n        k = k % i #当k超过了；链表节点个数的时候就想当于循环了一次\n        p.next = head\n        for _ in range(i - k): #找到断开的点\n            p = p.next\n        res = p.next #新的起点\n        p.next = None #断开\n        return res\n```\n\n## 复杂度：\ntime: O(n)\nspace: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921462031","body":"## 思路：\n画图: \n- 前：prev -> A -> B -> nextB\n- 后：prev -> B -> A -> nextB\n\n## Python3\n```Python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # 需要比较head, head.next，考虑特殊情况\n        if not head or not head.next:\n            return head\n\n        dummy = ListNode()\n        dummy.next = head.next\n        prev = dummy\n        A = head\n\n        while A and A.next:\n            B = A.next\n            nextB = B.next\n\n            prev.next = B\n            B.next = A\n            A.next = nextB\n\n            prev = A\n            A = nextB\n\n        return dummy.next\n```\n\n## 复杂度\n- time: O(n)\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922172808","body":"## 思路\n- 有序排列：想到中序遍历 -> 双指针找到root\n- 递归部分想的还不是特别清楚\n\n## Python3\n```Python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922414919","body":"## 思路\n- 双指针。链表必做题。\n- A = A.next if A else headB 这里是if A还是A.next需要注意一下\n\n## Python3 \n```Python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        A = headA\n        B = headB\n        \n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n\n        return A\n```\n\n## 复杂度\n- time: O(n1+n2)\n- space: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luojiamun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916322388","body":"### 思路\n\nDeque, Array遍历；\n\n注意题目要求，1 <= A.length <= 10000，所以直接做加法是不可能的。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int pos = 0;\n        int carry = 0;\n        Deque<Integer> res = new LinkedList<>();\n        while(pos < num.length || k >= Math.pow(10, pos) || carry > 0){\n            int fromNum = pos < num.length?num[num.length - 1 - pos]:0;\n            int fromK = (k / (int)Math.pow(10, pos)) % 10;\n            int sum = fromNum + fromK + carry;\n            res.addFirst(sum % 10);\n            carry = sum > 9?1:0;\n            pos++;\n        }\n                \n        return new ArrayList<>(res);\n    }\n}\n```\n\n### 复杂度\n\nO(MAX(num.length, Integer.valueOf(k).toString.length()))\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917160920","body":"### 思路\r\nArray遍历\r\n\r\n两次遍历\r\n- 第一次从左到右，遇到c，将其右边的依次从1-m编号；直到遇到下一个c，重复编号过程。（第一个c左边为未编号状态）\r\n- 第二次从右到左，遇到c，将其左边当前编号与预计编号比较并取min；第二次编号并会将第一个c左边的编号完成。\r\n\r\nStack\r\n将s遍历一次\r\n- 如果当前为c，\r\n    - pop站内元素，并依次按距离递增编号；直到栈空或栈顶为c；当前位置编号0；将当前位置压入栈\r\n- 如果当前不为c\r\n    - 如果栈顶为c，那么当前位置编号1\r\n    - 否则当前位置编号为前一个位置编号+1；\r\n    - 将当前位置index 压入栈；\r\n\r\n\r\n### 代码\r\n```java\r\n//array遍历\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int pre = Integer.MIN_VALUE / 2;\r\n        int[] res = new int[s.length()];\r\n        for(int i = 0;i < s.length();i++){\r\n            if(s.charAt(i) == c) pre = i;\r\n            res[i] = i - pre;\r\n        }\r\n        \r\n        pre = Integer.MAX_VALUE;\r\n        for(int i = s.length() - 1;i >= 0;i--){\r\n            if(s.charAt(i) == c) pre = i;\r\n            res[i] = Math.min(res[i], pre - i);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n\r\n//stack\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        int[] res = new int[s.length()];\r\n        stack.add(0);\r\n        for(int i = 0;i < s.length();i++){\r\n            if(s.charAt(i) == c){\r\n                int pos = 0;\r\n                while(!stack.isEmpty() && s.charAt(stack.peek()) != c){\r\n                    int cur = stack.pop();\r\n                    \r\n                    res[cur] = res[cur] == 0?++pos:Math.min(++pos, res[cur]);\r\n                }\r\n                res[i] = 0;\r\n                stack.add(i);\r\n            } else {\r\n                if(!stack.isEmpty() && s.charAt(stack.peek()) == c){\r\n                    res[i] = 1;\r\n                } else if(i > 0 && res[i-1] != 0) {\r\n                    res[i] = res[i-1] + 1;\r\n                }\r\n                stack.add(i);\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\nArray遍历\r\nO(s.length());\r\nO(1)\r\n\r\nStack\r\nO(s.length())\r\nO(N),维护一个栈。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917448932","body":"### 思路\r\n\r\n用array模拟stack的操作。比较特别的是increment这个方法，将栈底的k个元素递增val。\r\n\r\n基本的push和pop的操作通过记录index来实现就好。increment这个方法则可以通过`两种`方式.\r\n\r\n- 不使用额外空间的基础上，用loop update栈底部的k个值；\r\n- 使用额外的array，存储increment value，然后pop时与原始值求和；\r\n- 在递增array中，变量以\"内卷\"的方式存储，即只更新第k个值，共所有的前k个值更新所用。这样操作的目的是为了避免循环赋值；\r\n\r\n\r\n### 代码\r\n```java\r\n//loop for increment\r\nclass CustomStack {\r\n    int[] store;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.store = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < store.length - 1){\r\n            store[++top] = x;    \r\n        }\r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(top >= 0){\r\n            return store[top--];\r\n        } else {\r\n            return -1;\r\n        }\r\n        \r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(top == -1) return;\r\n        int count = k;\r\n        int cur = 0;\r\n        while(count > 0 && cur <= top){\r\n            store[cur] += val;\r\n            count--;\r\n            cur++;\r\n        }\r\n    }\r\n}\r\n\r\n//array for increment\r\nclass CustomStack {\r\n    int[] store;\r\n    int[] incre;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.store = new int[maxSize];\r\n        this.incre = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < store.length - 1){\r\n            store[++top] = x;    \r\n        }\r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(top < 0) return -1;\r\n        int sum = store[top] + incre[top];\r\n        if(top == 0) {\r\n            incre[top] = 0;\r\n            top--;\r\n            return sum;\r\n        }\r\n        incre[top - 1] += incre[top];\r\n        incre[top] = 0;\r\n        top--;\r\n        return sum;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(top == -1) return;\r\n        if(k > top + 1) k = top + 1;\r\n        incre[k - 1] += val;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\nloop for increment\r\npop, push复杂度O(1), increment复杂度O(K);\r\nO(1)，不包括用于模拟的array；\r\n\r\narray for increment\r\npop, push, increment都是O(1)；\r\n在原本模拟stack的array基础上，额外付出O(N)提供存储incre的array。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917688530","body":"### 思路\r\n\r\nstack, string\r\n\r\n这题的主要考点\r\n\r\n- 利用栈，在遇到右括号`]`时pop进行运算，运算完成后push回到stack；\r\n    - 这个技巧可以说用的蛮多，类似的技巧在1381也用到过；\r\n    - `字符` * `数字` = `新字符`；这里字符和数字可以分别存在两个栈，也可以存在一个栈，判断条件不同；\r\n\r\n需要注意的地方\r\n\r\n- 因为用的是栈，所以每次pop之后，得到的String顺序是反的，数字也是反的，得reverse；\r\n- 注意每次数字部分都需要reverse再做repeat操作；但字符只需要最后对res做reverse操作，如果在循环体就对字符做reverse，比较容易混淆；\r\n- String操作，要避免`str = str + \"abc\"`或`str = \"abc\" + str`这类操作，因为它们是O(N)的；虽然每次操作的N不是很大，但最坏的情况可以和s.length()一样，最终导致O(N^2);\r\n- 用StringBuilder.append来做，是O(1)的。而且可以很方便的使用reverse()方法。\r\n\r\n\r\n\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<String> stack = new Stack<>();\r\n        \r\n        for(int i = 0;i < s.length();i++){\r\n            if(s.charAt(i) == ']'){\r\n                //get chars inside []\r\n                StringBuilder s_sb = new StringBuilder();\r\n                while(!stack.isEmpty() && !stack.peek().equals(\"[\")){\r\n                    s_sb.append(stack.pop());\r\n                }\r\n                stack.pop();//for '['\r\n                \r\n                //get numeric multiplier\r\n                StringBuilder n_sb = new StringBuilder();\r\n                while(!stack.isEmpty() && stack.peek().charAt(0) <= '9' && stack.peek().charAt(0) >= '0'){\r\n                    n_sb.append(stack.pop());\r\n                }\r\n                \r\n                stack.add(s_sb.toString().repeat(Integer.valueOf(n_sb.reverse().toString())));\r\n            } else {\r\n                stack.add(String.valueOf(s.charAt(i)));\r\n            }\r\n        }\r\n        \r\n        StringBuilder resb = new StringBuilder();\r\n        while(!stack.isEmpty()){\r\n            resb.append(stack.pop());\r\n        }\r\n        return resb.reverse().toString();\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\nO(N)，循环体会从头到尾遍历s.length();\r\nO(N)，要维护一个栈；\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918385223","body":"### 思路\n\n借助两个栈，一个input-stack用于接收push，一个output-stack用于pop；\n- 所有的push都进入input；\n- 所有的pop都出自output；\n- 如果output空了，就从input提取；\n\n\n### 代码\n```java\n/*\n1. init two stacks: input and output\n2. when push, push to the input\n3. when pop, pop from output, if output is empty, pop from input to output, then pop from output\n*/\n\nclass MyQueue {\n    Stack<Integer> in;\n    Stack<Integer> out;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        this.in = new Stack<>();\n        this.out = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        in.add(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(!out.isEmpty()){\n            return out.pop();\n        } else if(!in.isEmpty()){\n            while(!in.isEmpty()){\n                out.add(in.pop());\n            }\n            return out.pop();\n        } else {\n            return Integer.MIN_VALUE;\n        }\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(!out.isEmpty()){\n            return out.peek();\n        } else if(!in.isEmpty()){\n            while(!in.isEmpty()){\n                out.add(in.pop());\n            }\n            return out.peek();\n        } else {\n            return Integer.MIN_VALUE;\n        }\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n```\n\n### 复杂度\n\npush: O(1);\npop/peek: 如果output-stack站内有元素，O(1)，如果没有，O(M)，M是当前input站内的元素数量；\nisEmpty: O(1)\n\nspace: O(N),需要维护两个栈，如果这两个栈算是计划内，那就为O(1)，即除栈外只需常数空间。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919458484","body":"### 思路\n\n借助一个排好序的sorted，和原本的arr做比较。\n\n如果当前index之前的元素形成的集合是相同的，那么就可以算作一个partition。\n\n相同在这里的定义是差的和为0。\n\n之所以可以借用sum=0这个，是因为比较的对象是sorted，而不是如下这种反例。\n\narr1: [1,6,6,4,8]\nsorted: [1,4,6,6,8]\n反例：[1,4,8,6,6]\n\n\n\n### 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] sorted = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(sorted);\n        int sum = 0;\n        int ans = 0;\n        for(int i = 0;i < sorted.length;i++){\n            sum += arr[i] - sorted[i];\n            if(sum == 0) ans++;\n        }\n        return ans;\n    }\n}\n```\n\n### 复杂度\n\npush: O(nlogn);复杂度的主要来源是排序；\nspace: O(N),需要维护一个额外的sorted array；\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920264023","body":"### 思路\n\n- 拿到题目的思路\n\n1. 遍历一次找到链表长度，记住old_tail；\n2. 遍历第二次停在length-k，此处为new_tail，next为新的head\n3. 把new_tail指向null，old_tail指向head，返回new_head;\n\n注意影响bug free的因素：\n边界问题。k可长可短，如果为0怎么办；如果超过length怎么办，如果超过length但是回头了(%length == 0)怎么办?\n1. 如果k=0，可以提前return；\n2. 如果`k % length = 0`,这个`一定要return`,否则会有错误答案。\n\n`AC`\n\n### 代码\n```java\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null || k == 0) return head;\n        int length = 0;\n        ListNode cur = head;\n        while(cur.next != null){\n            cur = cur.next;\n            length++;\n        }\n        length++;\n        ListNode old_tail = cur;\n        \n        if(k % length == 0) return head;\n        \n        cur = head;\n        int count = length - k % length;\n        \n        while(--count > 0){\n            cur = cur.next;\n        }\n        \n        ListNode new_head = cur.next;\n        cur.next = null;\n        old_tail.next = head;\n        \n        return new_head;\n    }\n}\n```\n\n### 复杂度\n\ntime: O(N)\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921077053","body":"### 思路\n\n- 拿到题目的思路\n\n1. 每两个node为一个pair进行交换；\n2. 交换完成后，next到下一对pair；\n\nbug free需要注意的地方：\n\n1. 交换完成后，和这一对pair的pre的关系要接上；\n2. 可以用dummy做pre，返回dummy.next很方便；\n\n`AC`\n\n### 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        ListNode left = head;\n        ListNode right = head.next;\n        \n        \n        while(left != null && right != null){\n            left.next = right.next;\n            right.next = left;\n            pre.next = right;\n            pre = left;\n            left = left.next;\n            if(left != null){\n                right = left.next;\n            }    \n        }\n        return dummy.next;\n    }\n}\n```\n\n### 复杂度\n\ntime: O(N)\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921998203","body":"### 思路\r\n\r\n- 拿到题的直觉解法\r\n\r\n链表的中点是树的root，左半是左子树的全部节点，右半是右子树的全部节点；\r\n\r\n链表的中点可以通过快慢指针找到；\r\n\r\n可以用递归(pre-order dfs)来生成树，递归的结构\r\n- params: head of listnode\r\n- return：root of tree\r\n- 递归终止条件：head of listnode is null\r\n\r\n注意：影响bug free的问题\r\n- 注意左子树。使用了dummy后，设置leftHead的时候要使用dummy.next而不是直接使用head，因为要考虑到当前head只有一个node，它的左右分枝因此都为null，如果直接使用head，会导致多出来了分枝。dummy.next可以很`智能`的规避这个问题。\r\n- 可以用dummy做pre，返回dummy.next很方便；\r\n\r\n`AC`\r\n\r\n- 官网有意思的解法\r\n\r\nBST的in-order顺序和linkedlist顺序是一致的，既然如此，我们就可以匹配这两者。但题目是生成树，因此在没有树的时候，我们如何来in-order dfs？\r\n这个解法巧妙的模拟了in-order，即便没有树，也可以dfs，只要保持相对同步就行。使用的工具是左右子树在linkedlist的index。\r\n\r\n`AC`\r\n\r\n### 代码\r\n```java\r\n//pre-order dfs recursion\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null){\r\n            return null;\r\n        }\r\n        if(head.next == null){\r\n            TreeNode root = new TreeNode(head.val);\r\n            return root;\r\n        }\r\n        \r\n        return helper(head);\r\n        \r\n    }\r\n    \r\n    public TreeNode helper(ListNode head){\r\n        if(head == null) return null;\r\n        //find mid node in the listnodes\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        \r\n        ListNode fast = dummy;\r\n        ListNode slow = dummy;\r\n        while(fast.next != null && fast.next.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        //slow.next is root, then slow should point to null\r\n        ListNode rootNode = slow.next;\r\n        TreeNode root = new TreeNode(rootNode.val);\r\n        slow.next = null;\r\n        ListNode leftHead = dummy.next;\r\n        ListNode rightHead = rootNode.next;\r\n        root.left = helper(leftHead);\r\n        root.right = helper(rightHead);\r\n        \r\n        return root;\r\n    }\r\n}\r\n\r\n//边模拟in-order, 边生成\r\nclass Solution {\r\n    ListNode head;\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        if(head.next == null) {\r\n            TreeNode root = new TreeNode(head.val);\r\n            return root;\r\n        }\r\n        \r\n        this.head = head;\r\n        int length = 0;\r\n        ListNode cur = head;\r\n        while(cur != null){\r\n            length++;\r\n            cur = cur.next;\r\n        }\r\n        \r\n        return inorder(0, length);\r\n    }\r\n    \r\n    public TreeNode inorder(int left, int right){\r\n        if(left > right || head == null) return null;\r\n        int mid = left + (right - left) / 2;\r\n        TreeNode l = inorder(left, mid - 1);\r\n        \r\n        TreeNode root = new TreeNode(head.val);\r\n        head = head.next;\r\n        \r\n        root.left = l;\r\n        root.right = inorder(mid + 1, right);\r\n        \r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n`pre-order dfs`\r\ntime: O(NlogN), 递归的部分会有logN次，每次会有快慢指针N/2次，因此总量N * longN\r\nspace: O(logN),主要是递归用来存储栈的占用。\r\n\r\n`simulate in-order`\r\ntime: O(N)，递归的复杂度只有logN，但我们要通过一次遍历链表查询长度，因此复杂度最高为N\r\nspace: O(logN)，主要是递归存储栈的占用。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922352422","body":"### 思路\r\n\r\n- 拿到题的直觉解法\r\n\r\n两个LinkedList如果长度一样，那么直接遍历就好；\r\n\r\n两个LinkedList如果长度不同，则先算长短，然后长的先走length的差，就可以齐头并进当作相同长度的case处理；\r\n\r\n`AC`\r\n\r\n- 稍微优化\r\n\r\n两个LinkedList不用分别求长度，要知道的只是`长度差`.\r\n更进一步，连`长度差`都不需要知道，只需要长的先走diff那几步，所以可以稍微优化一下这部分。复杂度没变。\r\n\r\n`AC`\r\n\r\n### 代码\r\n```java\r\n\r\n//遍历两次求长度\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        int lengthA = 0;\r\n        ListNode curA = headA;\r\n        while(curA != null){\r\n            curA = curA.next;\r\n            lengthA++;\r\n        }\r\n        int lengthB = 0;\r\n        ListNode curB = headB;\r\n        while(curB != null){\r\n            curB = curB.next;\r\n            lengthB++;\r\n        }\r\n        \r\n        ListNode headLong = lengthA >= lengthB?headA: headB;\r\n        ListNode headShort = lengthA >= lengthB?headB: headA;\r\n        int diff = Math.abs(lengthA - lengthB);\r\n        \r\n        while(diff > 0){\r\n            headLong = headLong.next;\r\n            diff--;\r\n        }\r\n        \r\n        while(headLong != headShort){\r\n            headLong = headLong.next;\r\n            headShort = headShort.next;\r\n        }\r\n        \r\n        return headLong;\r\n    }\r\n}\r\n\r\n//遍历一次\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode curA = headA;\r\n        ListNode curB = headB;\r\n        \r\n        while(curA != null && curB != null){\r\n            curA = curA.next;\r\n            curB = curB.next;\r\n        }\r\n        \r\n        ListNode shortee = curA == null?headA: headB;\r\n        ListNode longee = curA == null?headB: headA;\r\n        ListNode running = curA == null?curB: curA;\r\n        \r\n        int diff = 0;\r\n        while(running != null){\r\n            running = running.next;\r\n            longee = longee.next;\r\n        }\r\n        while(shortee != null && longee != null && shortee != longee){\r\n            shortee = shortee.next;\r\n            longee = longee.next;\r\n        }\r\n        return shortee;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂\r\n\r\n两个解法复杂度一样，但是第二个方法因为少遍历了一些所以稍微优化点；\r\ntime: O(N)\r\nspace: O(1)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yiwchen":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916330275","body":"思路：\nadd with carry\n\nPython:\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        n = len(num)\n        while(n > 0 or k > 0):\n            if n > 0:\n                k += num[n - 1]\n            k, r = divmod(k, 10)\n            res.append(r)\n            n -= 1\n        return res[::-1]\n```\nC++:\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        int sum;\n        for (int i = n - 1; i >=0; --i){\n            \n            /*Calculation of current digit*/\n            \n            sum = num[i] + k % 10;\n            k /= 10;\n            \n            /*Add the carry to k if there is any*/\n            \n            if (sum >= 10){\n                k++;\n                sum -= 10;\n            }\n            \n            /*Append the sum to the end*/\n            \n            res.push_back(sum);\n        }\n        \n        /* Append the rest of k to the end if k is bigger than n*/\n        \n        for (k = k; k > 0; k/= 10){\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n复杂度分析:\n\n时间复杂度：O(len(A) + len(str(k)) + len(res)) = O(max(len(A), len(str(k))))\n空间复杂度：O(1)\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918538698","body":"思路：\r\n双栈\r\n\r\nC++\r\n```\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack;\r\n    stack<int> outStack;\r\n    \r\n    void inToout(){\r\n        while (!inStack.empty()){\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n    \r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if (outStack.empty()){\r\n            inToout();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            inToout();\r\n        }\r\n        return outStack.top();\r\n    }\r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n\r\nComplexity:\r\nTC: pop: O(1) push O(1), peek O(n)\r\nSC: O(n) from the stack size\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920114449","body":"思路：\r\n贪心（？）直接对比排序后数组\r\nPython:\r\n```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        dic = {}\r\n        for i, val in enumerate(sorted(arr)):\r\n            dic[val] = dic.get(val, []) + [i]\r\n        res = 0\r\n        right = 0\r\n        for i, val in enumerate(arr):\r\n            right = max(right, dic[val].pop(0))\r\n            if i == right:\r\n                res += 1\r\n        return res\r\n```\r\nC++:\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& A) {\r\n        vector<int> sortedA(A);\r\n        sort(sortedA.begin(), sortedA.end());\r\n\r\n        long s1 = 0;\r\n        long s2 = 0;\r\n        int res = 0;\r\n        int n = A.size();        \r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            s1 += A[i];\r\n            s2 += sortedA[i];\r\n            if (s1 == s2)\r\n                res++;\r\n        /*        s1 -= s1;\r\n                s2 -= s2;\r\n        */\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\nComplexity:\r\nTC: O(n log n) from sorting\r\nSC: O(n) for the extra array","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922009948","body":"思路：\n暴力做……\n```\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        l = 0 \n        cur = head\n        while cur:\n            cur = cur.next\n            l += 1\n            \n        def toTree(left, right):\n            nonlocal head\n\n            if left > right: \n                return None\n            \n            mid = (left+ right) // 2\n            \n            left = toTree(left, mid - 1)\n            \n            t = TreeNode(head.val)\n            \n            head = head.next\n            right = toTree(mid + 1, right)\n            \n            t.left = left\n            \n            t.right = right\n            \n            return t\n        \n        tree = toTree(0, l - 1)\n        return tree\n```\n\nTC:\nO(N) 要找一次长度\n\nSC:\nO(Log(N)) 主要是call stack","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qixuan-code":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916334960","body":"[LC 989. Add to Array-Form of Integer](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n**思路**\n- 把num list转化成数字\n- 数字和k相加\n- 相加的和转化成list\n\n**python代码**\n```class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        true_number = 0\n        result = []\n        if k == 0 and len(num) == 1:\n            return num\n        for i in range(n):\n            true_number = true_number + num[i]*10**(n-i-1)\n\n        add_up = true_number + k\n        while add_up:\n            result.append(add_up%10)\n            add_up = add_up//10\n\n        return result[::-1]\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917085339","body":"[821. Shortest Distance to a Character](https://leetcode.com/problems/shortest-distance-to-a-character/)\n\n**comment**\nRuntime: 146 ms beat 5%\n\n**python代码**\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        temp = []\n        res = []\n        for i in range(len(s)):\n            if s[i] == c:\n                temp.append(i)\n        \n        for j in range(len(s)):\n            a = [abs(x-j) for x in temp]\n            res.append(min(a))\n            \n        return res\n```\n**复杂度分析**\n- 时间复杂度：O(N^2+N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917650395","body":"[LC 1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n\n\n**python代码**\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = maxSize\n        self.stk = []\n        self.current_position = 0\n\n    def push(self, x: int) -> None:\n        if self.current_position < self.size:\n            self.stk.append(x)\n            self.current_position +=1\n\n    def pop(self) -> int:\n        if self.current_position == 0:\n            return -1\n        self.current_position -=1\n        return self.stk.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,self.current_position)):\n            self.stk[i] += val\n```\n\n**复杂度分析**\n- 时间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917830671","body":"[LC 394. Decode String](https://leetcode.com/problems/decode-string/)\n\n没有思路，把答案默写了一遍\n\n**python代码**\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = [] \n        for i in s:\n            if i == ']':\n                strs = ''\n                repeat_number = ''\n                while stack and stack[-1] !='[':\n                    strs = stack.pop()+strs\n                stack.pop() #pop out'[]'\n        \n                while stack and stack[-1].isdigit():\n                    repeat_number = repeat_number + stack.pop()\n                    \n                stack.append(int(repeat_number)*strs)\n            \n            else:\n                stack.append(i)\n        return \"\".join(stack)\n        \n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918762503","body":"[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)\n\n**Ideas**\n- this problem asks to implement queue(FIFO) by two stacks. I use one stack for enqueue function and the other for dequeue.\n\n**comment**\nRuntime: Runtime: 38 ms, faster than 18.90% \n\n**python代码**\n```\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.enqueue_stack = []\n        self.dequeue_stack = []\n        \n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.enqueue_stack.append(x)\n            \n  \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.dequeue_stack == []:\n            \n            while self.enqueue_stack:\n                self.dequeue_stack.append(self.enqueue_stack.pop())\n            \n        return self.dequeue_stack.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.dequeue_stack == []:\n            return self.enqueue_stack[0]\n        else:\n            return self.dequeue_stack[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return self.enqueue_stack == [] and self.dequeue_stack == []\n        \n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)]\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919541681","body":"[LC 768. Max Chunks To Make Sorted II](https://leetcode.com/problems/max-chunks-to-make-sorted-ii/)\n\n**Ideas**\n- Monotonic Stack\n- key point:\n   max[chunk[i-1]] <= min[chunk[i]] < max[chunk[i] <= min[chunk[i+1]]\n**comment**\nRuntime: 69 ms, faster than 84.22%\n\n**python code**\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for a in arr:\n            if stack and stack[-1]>a:\n                store = stack[-1]\n                while stack and stack[-1]>a:\n                    stack.pop()\n                stack.append(store)\n            else:\n                stack.append(a)\n                \n        return len(stack)\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920540639","body":"[LC 61. Rotate List](https://leetcode.com/problems/rotate-list/)\n\n**Ideas**\n- Slow fast pointer \n- k means that the gap between slow pointer and fast pointer\n\n**comment**\nRuntime: Runtime: 66 ms, faster than 6.74%\n\n**python代码**\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k ==0 or not head or not head.next:\n            return head\n        #calculate the length of the linked list\n        cur = head\n        length = 1\n        \n        while cur.next != None:\n            cur = cur.next\n            length += 1\n            \n        k = k%length\n        \n        fast = head\n        slow = head\n        for i in range(k):\n            fast = fast.next\n        while fast.next != None:\n            fast = fast.next\n            slow = slow.next\n        \n        \n        fast.next = head\n        head = slow.next\n        slow.next = None\n        \n        return head\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922489154","body":"[LC 989. intersection of two linked lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)\n\n\n\n\n**python代码**\n```\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        len1, len2 = 0, 0\n        moveA, moveB = headA, headB\n        while moveA:\n            len1 += 1\n            moveA = moveA.next\n        while moveB:\n            len2 += 1\n            moveB = moveB.next\n        if len1 < len2:\n            for _ in range(len2 - len1):\n                headB = headB.next\n        else:\n            for _ in range(len1 - len2):\n                headA = headA.next\n        while headA and headB and headA != headB:\n            headA = headA.next\n            headB = headB.next\n        return headA\n\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JiangyanLiNEU":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916335257","body":"### Two ideas hit me when I saw this problem.\n* convert array num to integer --> add k to the integer --> convert new integer to array --> return this array\n* Use k as carry on number, and keep adding it to the elements in num until k is 0. Note that, we might  need to insert elements into num array.\n\n### Here is my implement:\n* #### Convert idea ( Runtime = O( len(num) ), Space = O( len(num) ) )\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        # convert array num into string version\n        num_string = ''\n        for n in num:\n            num_string += str(n)\n\n        # add num and k, and convert it to string version\n        num_add_k_string = str(int(num_string) + k)\n\n        # convert result into array of int version\n        toReturn = [ int(i) for i in num_add_k_string ]\n        return toReturn\n```\n\n* #### carry k idea ( Runtime = O( len(num) ), Space = O(1) )\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        # add k into the last digit of num, and check if there should be a carryOn number\n        num[-1] += k\n        if num[-1] < 10:\n            return num\n        # if no carryOn number, then just return num, otherwise, we keep adding carry on into previous digit and update carryOn\n        carryOn = num[-1]//10\n        num[-1] = num[-1]%10\n        index = -2\n        while carryOn != 0:\n            # when there are enough digits for us to add\n            if index >= -len(num):\n                num[index] += carryOn\n            # we need to insert new digit at the beginning of the array\n            else:\n                num.insert(0, carryOn)\n            carryOn = num[index] // 10\n            num[index] %= 10\n            index -= 1\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917119307","body":"#### Two ideas\n##### Straightforward way (Runtime = O(n), Space = O(n))\n* I get all the index of letter c in s\n* CASE1,  any letter before the first c letter, the distance will be (c_index - letter_index) \n* CASE2, any letter in between two c letters, we need to find the middle point. The distance will be (letter_index-c_index) and then after middle point, it will be (c_index-letter_index) \n* CASE3, any letter after the last c letter, the distance will be (letter_index - last_c_index)\n\n##### forward and backward update (Runtime = O(n), Space = O(n))\n* Iterate from left to right, the distance is always the distance to the right nearest letter c\n* Iterate from right to left, update the distance to be the minimum distance of current one and distance to the left nearest letter c\n\n#### Implement straightforward idea\n``` python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        # get all the location of letter c\n        c_location = [i for i in range(len(s)) if s[i]==c\n        result = []\n        #case 1\n        for i in range(c_location[0]+1):\n            result.append(c_location[0]-i)\n        #case 2\n        while len(c_location) >= 2:\n            popStart = c_location.pop(0)\n            endAt = c_location[0]\n            index = popStart + 1\n            while index <= (endAt+popStart)//2:\n                result.append(index-popStart)\n                index += 1\n            while index <= endAt:\n                result.append(endAt-index)\n                index+=1 \n        #case 3\n        for i in range(c_location[0]+1,len(s)):\n            result.append(i-c_location[0])\n        return result\n```\n\n#### Implement smarter idea\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        result = [float('inf') for i in s]\n        last_c = -float('inf')\n        for i in range(len(s)):\n            if s[i] == c:\n                last_c = i\n                result[i] = i-last_c\n            else:\n                result[i] = i-last_c\n        last_c = float('inf')\n        for i in range(len(s)-1, -1,-1):\n            if s[i] == c:\n                last_c = i\n            result[i] = min(result[i], last_c - i)\n        return result \n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917453838","body":"#### follow the instructions and it is easy to implement\n```python\nclass CustomStack(object):\n    def __init__(self, maxSize):\n        self.stack = []\n        self.limit = maxSize\n        self.length = 0\n\n    def push(self, x):\n        if self.length < self.limit:\n            self.stack.append(x)\n            self.length += 1\n\n    def pop(self):\n        if self.length == 0:\n            return -1\n        else:\n            num = self.stack.pop()\n            self.length -= 1\n            return num\n\n    def increment(self, k, val):\n        for i in range(min(k,self.length)):\n            self.stack[i] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917685897","body":"#### Idea\nI use stack to solve this problem. The main idea is:\n* an array called left to store all the elements we saw//processed\n* when we see a number element, we check if this digit belong to a greater number (for examplt, if we got '0' and the last element in left is '3', so obviously, we make it to '30'), if so, we add this one to the previous on in left array, otherwise we append this number into left array\n* when we see [ elements, we record its index in an array called firstpart.\n* when we see ] elements, we need to find its match [ part in firstpart array. then we know, the number is right before the [ elements and the segments needed to be repeated is after [ elements. Then we process this segment and append it to the left array. In the meantime, we need to update the index, so we can keep track of the location of [.\n\n####Implement ( Runtime=O(n), space=(n))\n```python\nclass Solution(object):\n    def decodeString(self, s):\n        def process(time, array):\n            seg = ''.join(array)\n            return seg*time\n    \n        result = ''\n        \n        firstpart = []\n        left = []\n        index = -1\n        while s:\n            cur = s[0]\n            s = s[1:]\n            \n            if left and left[-1].isnumeric() and cur.isnumeric():\n                left[-1] += cur\n            else:\n                left.append(cur)\n                index += 1\n                if cur == '[':\n                    firstpart.append(index)\n                elif cur == ']':\n                    match = firstpart.pop()\n                    time = int(left[match-1])\n                    seg = left[match+1:index]\n                    index = match-2+1\n                    left = left[:match-1]\n                    left.append(process(time, seg))\n        return ''.join(left)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918422454","body":"#### Two Ideas\n##### Two stacks\n* Use two stacks\n* stack1 stores elements, stack2 is only used when someone call pop and peek.\n* pop all elements in stack1 and append them into stack2\n* after find the right elements, do the same thing from stack2 to stack1\n##### One stack, one index indicating the location of the first element in the stack\n* index is always the location of the first elements in the stack\n* every time we pop, we increase index by 1.\n\n#### Implement\n* 2 stacks (Runtime = O(n) Space = O(n) )\n```python\nclass MyQueue(object):\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n    def push(self, x):\n        self.stack1.append(x)\n    def helper(self, array1, array2):\n        while array1:\n            array2.append(array1.pop())\n        return \n    def pop(self):\n        self.helper(self.stack1, self.stack2)\n        target = self.stack2.pop()\n        self.helper(self.stack2, self.stack1)\n        return target\n    def peek(self):\n        self.helper(self.stack1, self.stack2)\n        target = self.stack2[-1]\n        self.helper(self.stack2, self.stack1)\n        return target\n    def empty(self):\n        return len(self.stack1) == 0\n```\n* Index and stack ( Runtime = O(1) Space = O(n) )\n``` python \nclass MyQueue(object):\n    def __init__(self):\n        self.stack1 = []\n        self.index = 0\n    def push(self, x):\n        self.stack1.append(x)\n    def pop(self):\n        target = self.stack1[self.index]\n        self.index += 1\n        return target\n    def peek(self):\n        return self.stack1[self.index]\n    def empty(self):\n        return self.index > len(self.stack1)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919479695","body":"#### Idea\nuse an array called segments to store the interval segments. Everytime new interval overlap with the previous one, we merge two intervals, otherwise, we append new interval. The result is the length of the segments.\n#### Implement ( Runtime = O(n^2), Space = O(n) )\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \n        segments = []\n\n        def merge():\n            if len(segments) <= 1:\n                return \n            else:\n                if (segments[-1][0]>=segments[-2][1]):\n                    return\n                else:\n                    a = segments.pop()\n                    b = segments.pop()\n                    segments.append([min(a[0],b[0]),max(a[1],b[1])])\n                    merge()\n        \n        for num in arr:\n            segments.append([num,num])\n            merge()\n        return len(segments)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920187238","body":"#### Idea\nNode1 -> Node2 -> Node 3 -> Node 4 -> Node 5  k=2\n head                      prePointer     pointer       tail\nwhat I do is rebuilding the connection: prePointer.next = None; tail.next = head; return pointer\n#### Implement (Runtime = O(n), Space = O(1) )\n```python\nclass Solution(object):\n    def rotateRight(self, head, k):\n        # edge case\n        if head == None:\n            return head\n\n        # get the length of the list\n        length = 1\n        cur = head\n        while cur.next:\n            length += 1\n            cur = cur.next\n        \n        k = k%length\n\n        # edge cases\n        if k == 0:\n            return head\n        if head.next == None:\n            return head\n        \n        # get the prePointer, pointer, tail\n        prePointer = head\n        rest = length-1\n        while rest > k:\n            prePointer = prePointer.next\n            rest -= 1\n        pointer = cur.next\n        prePointer.next = None\n        tail = pointer\n        while tail.next:\n            tail = tail.next\n\n        # rebuild the link\n        tail.next = head\n        return pointer\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921137556","body":"#### Idea\n* Break the linked list down into segments which only contains 2 nodes or 1 node in each segments. We store those segments in an array. \n* for each item in segments, we swap it if there are 2 nodes, otherwise, we don't do anything\n* Build connect between each segments. ele1.tail -> ele2.head\n#### Implement ( Runtime = O(n)  Space=O(n) )\n```python\nclass Solution(object):\n    def swapPairs(self, head):\n        segments = []\n        cur = head\n       # edge cases\n        if cur==None or cur.next == None:\n            return head\n        # break the linked list down into segments\n        while cur:\n           # stop condition for while loop\n            if cur.next == None or cur.next.next == None:\n                segments.append(cur)\n                break\n            else:\n                nextOne = cur.next.next\n                cur.next.next = None\n                segments.append(cur)\n                cur = nextOne\n       # swap the nodes for each segment\n        for i in range(len(segments)):\n            node = segments[i]\n            if node.next == None:\n                break\n            left = node\n            right = left.next\n            right.next, left.next = left, None\n            segments[i] = right\n        # Rebuild the connect between segments\n        head = segments[0]\n        tail = head.next\n        for seg in segments[1:]:\n            tail.next = seg\n            if seg.next == None:\n                return head\n            tail = seg.next\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921931361","body":"#### Idea\nUse **divide and conquer** to build tree:\n* find the middle node in the linked list\n* break the connection from the previous node and next node, so here we got three linked list\n * 10 --> -3 --> 0 --> 5 --> 9\n *             br   br\n* the first and third segments do the same thing repeadly until no node left, tree node is the middle node\n\n#### Implement ( Runtime = O( n ), Space=( n ) )\n```python\nclass Solution(object):\n    def sortedListToBST(self, head):\n        # Edge cases to stop recursion\n        if not head:\n            return None\n        if not head.next:\n            # print('get node, ', pointer.val)\n            return TreeNode(head.val)\n        # Find the length of this linkedlist\n        length = 0\n        cur = head\n        while cur:\n            length += 1\n            cur = cur.next\n        # Break it into three segments: \n        middle = length//2\n        dummy = ListNode(0,head)\n        pre = dummy\n        pointer = pre.next\n        while middle>0:\n            pre = pointer\n            pointer = pointer.next\n            middle -= 1\n        # Break the connection\n        pre.next = None\n        right = pointer.next\n        pointer.next = None\n        left = dummy.next\n        # Do recursion\n        return TreeNode(pointer.val, self.sortedListToBST(left), self.sortedListToBST(right))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922344192","body":"#### Idea\n* get the length of A and B \n* Because the second half is the same, so we move the longer list's pointer forward until their lengths are the same\n* Update two pointers until they are the same, return the node. Return None if we check all the node and didn't get same address.\n#### Implement (Runtime = O(len(A)+len(B)), Space = O(1) )\n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        lengthA = 0\n        lengthB = 0\n        # Get the length of A and B\n        cur = headA\n        while cur:\n            lengthA += 1\n            cur = cur.next\n        cur = headB\n        while cur:\n            lengthB += 1\n            cur = cur.next\n        # Now we know longer list and short list\n        minn, maxx = min(lengthA, lengthB), max(lengthA, lengthB)\n        if lengthA > lengthB:\n            longer = headA\n            short = headB\n        else:\n            longer = headB\n            short = headA\n        # forward the pointer of longer list, so they have the same length\n        for i in range(maxx-minn):\n            longer = longer.next\n        # check each node, return it if the address is the same\n        for i in range(minn):\n            if longer == short:\n                return longer\n            else:\n                longer = longer.next\n                short = short.next\n        # Return null if not intersection\n        return None\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZT4188":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916338863","body":"思路：\n历遍数组\n\nPython:\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        K = list(map(int,str(K)))\n        \n        res = []\n        i,j = len(A)-1,len(K)-1\n        carry = 0\n\n        while i >= 0 and j >= 0:\n            res.append(A[i] + K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n            j -= 1\n        while i >= 0:\n            res.append(A[i] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n        while j >= 0:\n            res.append(K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            j -= 1\n\n        if carry:\n            res.append(1)\n\n        return res[::-1]\n\n时间复杂度：O(N+max(0,K−N) \n空间复杂度：O(1)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917407266","body":"class Solution(object):\n    def shortestToChar(self, S, C):\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(S):\n            if x == C: prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in xrange(len(S) - 1, -1, -1):\n            if S[i] == C: prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Jackielj":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916352332","body":"### LC 989. Add to Array-Form of Integer\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        int i = num.length - 1;\n        int carry = 0;\n        while (i >= 0 || k > 0 || carry > 0) {\n            int fromNum = i >= 0 ? num[i] : 0;\n            int fromK = k % 10;\n            int val = fromNum + fromK + carry;\n            list.add(0, val % 10);\n            carry = val > 9 ? 1 : 0;\n            k = k / 10;\n            i--;\n        }\n        return list;\n    }\n}\n\n```\n### 时空复杂度：\n时间：O(Math.max(len(num), len(k.toString()))\n\n空间：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918873723","body":"# 232 implement queue using stack\n\n## use two stack to realize the queue, push every element to stack1, any api call for peek or pop, if the current stack2 is empty, transfer every element from stack1 to stack2\nfor empty just check whether the current stack1 is stack2 is both empty;\n\n```java\nclass MyQueue {\n    Deque<Integer> stack1;\n    Deque<Integer> stack2;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack1 = new ArrayDeque<>();\n        stack2 = new ArrayDeque<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        stack1.offerFirst(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (stack2.isEmpty()) {\n            transfer();\n        }\n        return stack2.pollFirst();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (stack2.isEmpty()) {\n            transfer();\n        }\n        return stack2.peekFirst();\n        \n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n    public void transfer() {\n        while (!stack1.isEmpty()) {\n            stack2.offerFirst(stack1.pollFirst());\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919448124","body":"# 768. max chunks to make sorted II\n## 分析\n单调递增栈， 每一个元素代表当前block的最大的值， 如果当前scan的value比栈顶元素大，代表可以被分块， 但是遇到比前一个block， 或者所有之前block里最大的元素小的value， 我们就需要把他们融合成一个block，eg： 2 3 4 1， 在遇到1之前， 栈里会存3个元素，也就是， 2 3 4 可以被分成3 个block， 但是遇到1的时候， 我们分别弹栈4 ， 3， 2 栈空了， 再把最近的block的最大值4放进去， 融合成了一个栈。最终栈的大小就是block的个数\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        if (arr == null || arr.length == 0) return 0;\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = 0; i < arr.length; i++) {\n            if (!stack.isEmpty() && arr[i] < stack.peekFirst()) {\n                int large = stack.pollFirst();\n                while (!stack.isEmpty() && arr[i] < stack.peekFirst()) {\n                    stack.pollFirst();\n                }\n                stack.offerFirst(large);\n            } else {\n                stack.offerFirst(arr[i]);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n## 时空复杂度\n时间：O(n), size of the input array;\n\n空间：O(n) worst case: size of the input array of ascending order;","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Daniel-Zheng":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916354433","body":"### 思路\r\n从末位开始，向vector里添加各对应位置数字与进位之和。如原数组里各位置已加完，则需处理K中剩余数字与进位之和。\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int carry = 0;\r\n        vector<int> res;\r\n        for (int i = num.size() - 1; i >= 0; i--) {\r\n            res.push_back((carry + num[i] + k % 10) % 10);\r\n            carry = (carry + num[i] + k % 10) / 10;\r\n            k /= 10;\r\n        }\r\n        carry = carry + k;\r\n        while (carry) {\r\n            res.push_back(carry % 10);\r\n            carry /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N + logN + Max(0, K - N)^2)，N为数组A的长度，K为K的长度。 \r\n- 空间复杂度：O(Max(1, K - N))，N为数组A的长度，K为K的长度。 ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917313085","body":"### 思路\n找到C的左边界和右边界，计算边界内的字符到每个边界的值。\n\n### 代码(C++)\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> res;\n        int n = s.size() - 1;\n        int left = s[0] == c ? 0 : n;\n        int right = s.find(c, 1);\n        \n        for (int i = 0; i <= n; i++) {\n            res.push_back(min(abs(i - left), abs(i - right)));\n            if (i == right) {\n                left = right;\n                right = s.find(c, right + 1);\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(N)，N为S的长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917560532","body":"### 思路\n用Vector来模拟Stack\n\n### 代码(C++)\n```C++\nclass CustomStack {\npublic:\n    vector<int> res;\n    int count = 0;\n    int size;\n    \n    CustomStack(int maxSize) {\n        res.resize(maxSize);\n        size = maxSize;\n    }\n    \n    void push(int x) {\n        if (count == size) return;\n        res[count++] = x;\n    }\n    \n    int pop() {\n        if (count == 0) return -1;\n        return res[--count];\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < min(count, k); i++) res[i] += val;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(min(K, Count))\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917872604","body":"### 思路\n模拟Stack\n\n### 代码(C++)\n```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == ']') {\n                string str = \"\";\n                string cnt = \"\";\n                while (res.back() != '[') {\n                    str = res.back() + str;\n                    res.pop_back();\n                }\n                res.pop_back();\n                while (!res.empty() && isdigit(res.back())) {\n                    cnt = res.back() + cnt;\n                    res.pop_back();\n                }\n                int a = stoi(cnt);\n                while (a > 0) {\n                    res.append(str);\n                    a--;\n                }\n            } else {\n                res.push_back(s[i]);\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918656931","body":"### 思路\n使用两个Stack，一个Push，另一个Pop。\n\n### 代码(C++)\n```C++\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n        \n    }\n    stack<int> res;\n    stack<int> help;\n    /** Push element x to the back of queue. */\n    void push(int x) {\n        while (!help.empty()) {\n            res.push(help.top());\n            help.pop();\n        }\n        res.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        while (!res.empty()) {\n            help.push(res.top());\n            res.pop();\n        }\n        int ans = help.top();\n        help.pop();\n        return ans;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        while (!res.empty()) {\n            help.push(res.top());\n            res.pop();\n        }\n        int ans = help.top();\n        return ans;\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return res.empty() && help.empty();\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919693852","body":"### 思路\n单调栈。\n\n### 代码(C++)\n```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> res;\n        for (int i = 0; i < arr.size(); i++) {\n            if (!res.empty() && arr[i] < res.top()) {\n                int curMax = res.top();\n                while (!res.empty() && arr[i] < res.top()) res.pop();\n                res.push(curMax);\n            } else {\n                res.push(arr[i]);\n            }\n        }\n        return res.size();\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920538297","body":"### 思路\n快慢指针。\n\n### 代码(C++)\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr\n            || head->next == nullptr\n            || k == 0)\n            return head;\n\n        int len = 1;\n        ListNode* cur = head;\n        while (cur->next != nullptr) {\n            cur = cur->next;\n            len++;\n        }\n\n        k %= len;\n\n        ListNode* fast = head;\n        ListNode* slow = head;\n\n        while (fast->next != nullptr) {\n            if (k-- <= 0) {\n                slow = slow->next;\n            }\n            fast = fast->next;\n        }\n\n        fast->next = head;\n        ListNode* new_head = slow->next;\n        slow->next = nullptr;\n        return new_head;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921525944","body":"### 思路\n构造DummyHead指向Head。\n\n### 代码(C++)\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummyHead = new ListNode(0, head);\n        ListNode* temp = dummyHead;\n        while (temp->next != nullptr && temp->next->next != nullptr) {\n            ListNode* node1 = temp->next;\n            ListNode* node2 = temp->next->next;\n            temp->next = node2;\n            node1->next = node2->next;\n            node2->next = node1;\n            temp = node1;\n        }\n        return dummyHead->next;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922210873","body":"### 思路\n中序遍历。\n\n### 代码(C++)\n```C++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        vector<int> nodes;\n        while (head != nullptr) {\n            nodes.push_back(head->val);\n            head = head->next;\n        }\n        return sortedListToBST(nodes, 0, nodes.size());\n    }\n    TreeNode* sortedListToBST(vector<int>& nodes, int start, int end) {\n        if (start >= end) return nullptr;\n\n        int mid = (end - start) / 2 + start;\n        TreeNode* root = new TreeNode(nodes[mid]);\n        root->left = sortedListToBST(nodes, start, mid);\n        root->right = sortedListToBST(nodes, mid + 1, end);\n        return root;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922414145","body":"### 思路1\n遍历两个单链表，可以用hashset存储headA，再判断headB中是否有交点。\n\n### 代码(C++)\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set<ListNode*> visited;\n        ListNode* temp = headA;\n        while (temp != nullptr) {\n            visited.insert(temp);\n            temp = temp->next;\n        }\n        temp = headB;\n        while (temp != nullptr) {\n            if (visited.count(temp)) return temp;\n            temp = temp->next;\n        }\n        return nullptr;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(M + N)，M为headA长度，N为headB长度。\n- 空间复杂度：O(M)\n\n### 思路2\n双指针，同时遍历headA + headB，headB + headA，如有交点一定会有相等的节点。\n\n### 代码(C++)\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* A = headA;\n        ListNode* B = headB;\n        while (A != B) {\n            A = A != nullptr ? A->next : headB;\n            B = B != nullptr ? B->next : headA;\n        }\n        return A;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(M + N)，M为headA长度，N为headB长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916360004","body":"# 思路\r\n从后往前加，直到没有为止\r\n\r\n# 代码(Python3)\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        add1 = 0\r\n        add2 = 0\r\n        stop1Flag = False\r\n        stop2Flag = False\r\n        \r\n        resultStack = []\r\n        \r\n        k_int = list(map(int,str(k)))\r\n        \r\n        index = -1\r\n        while(True):\r\n            try:\r\n                add1 = num[index]                \r\n            except:\r\n                stop1Flag = True\r\n                add1 = 0\r\n                \r\n            try:\r\n                add2 = k_int[index]\r\n            except:\r\n                stop2Flag = True\r\n                add2 = 0\r\n            \r\n            index -= 1\r\n            \r\n            if(stop1Flag and stop2Flag):\r\n                if carry != 0:\r\n                    resultStack.append(carry)\r\n                break\r\n            else:\r\n                resultStack.append((add1 + add2 + carry)%10)\r\n                carry = (add1 + add2 + carry)//10\r\n        return (list(resultStack[::-1])\r\n```\r\n# 复杂度分析\r\n时间复杂度：O(N + Max(0, K - N)^2)，N为数组A的长度，K为K的长度。\r\n空间复杂度：O(Max(1, K + N))，N为数组A的长度，K为K的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917127990","body":"# 思路\n计算出c的所有位置，让s中的每个字符的位置相减，去最小值\n\n# 代码\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        index = 0\n        locations = []\n        for idx, letter in enumerate(s):\n            if letter == c:\n                locations.append(idx)\n                \n        indexes = range(len(s))\n        difference = [ abs(x - locations[0]) for x in indexes]\n        \n        for i in range(1,len(locations)):\n            difference = [ min(difference[x] , abs(x - locations[i])) for x in indexes]\n            \n        return difference\n```\n\n# 复杂度\nTime: O(n*k)\nSpace: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917466321","body":"# 思路\nstack内容用array来存储\n\n# 代码\n```python3\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.currentStack = []\n\n    def push(self, x: int) -> None:\n        if(len(self.currentStack) < self.maxSize):\n            self.currentStack.append(x)\n\n    def pop(self) -> int:\n        if(len(self.currentStack) > 0):\n            return self.currentStack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k , len(self.currentStack))):\n            self.currentStack[i] += val   \n```\n\n# 复杂度\n## 时间复杂度\npush : O(1)\n\npop :   O(1)\n\nincrement : min(O(K), O(N));\n## 空间复杂度\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917820784","body":"# 思路\n遇到[就把前面的字符串和数字压入stack,存储当前[]内的字符，直到遇见]，则弹出stack，把重复次数的当前字符增加在前字符后面\n\n# 代码\n```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:        \n        k_number = 0        \n        resultString = \"\"        \n        decoded_string = []        \n        for char in s:\n            if char.isnumeric():\n                k_number = 10 * k_number + int(char)\n            elif char == \"[\":\n                decoded_string.append(resultString)\n                decoded_string.append(k_number)\n                k_number = 0\n                resultString = \"\"\n            elif char == \"]\":\n                current_k = decoded_string.pop() \n                currentString = decoded_string.pop()\n                resultString = currentString + current_k * resultString\n                \n            else:\n                resultString += char\n        return resultString\n```\n\n# 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918456016","body":"# 思路\n两个stack，一个用于主要数据存储，另外一个用于pop的时候临时存储\n\n# 代码\n```python3\nclass MyQueue:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        while(self.stack1 != []):\n            self.stack2.append(self.stack1.pop())\n        returnValue = self.stack2.pop()\n        while(self.stack2 != []):\n            self.stack1.append(self.stack2.pop())\n        return returnValue \n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        while(self.stack1 != []):\n            self.stack2.append(self.stack1.pop())\n        returnValue = self.stack2.pop()\n        self.stack1.append(returnValue)\n        while(self.stack2 != []):\n            self.stack1.append(self.stack2.pop())\n        return returnValue\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return True if self.stack1 == [] else False\n```\n# 复杂度\n时间复杂度: O(N)\n\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919485248","body":"# 思路\n遍历arr，若元素大于等于stack顶数，直接push。若小于，则pop出前面所有大于当前数，并压入最大值。返回stack的长度。\n\n# 代码\n```python3\nclass Solution:\n    def maxChunksToSorted(self, arr) -> int:\n        tempStack = []\n        for currentNumber in arr:\n            if tempStack == []:\n                tempStack.append(currentNumber)\n            else:\n                tempStackTail = tempStack[-1]\n                if currentNumber >= tempStackTail:\n                    tempStack.append(currentNumber)\n                else:\n                    while tempStack and tempStack[-1] > currentNumber:\n                        tempStack.pop()\n                    tempStack.append(tempStackTail)\n        return len(tempStack)\n```\n\n# 复杂度\n时间复杂度： O(n)\n空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920199619","body":"# 思路\n1. 计算长度。 确定边界条件，包括linked list 长度为0，返回None。或者模为0，返回head。\n2. 找到新的起止点\n3. 设定各个点的next\n\n# 代码\n```python3\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:        \n        length = 0\n        current = head\n        while(current != None):\n            length += 1\n            current = current.next\n            \n        if length == 0:\n            return None            \n        if k % length == 0:\n            return head\n        \n        needStep = length - k % length - 1   \n       \n        current = head\n        for _ in range(needStep):\n            current = current.next\n        \n        newTail = current\n        current = current.next\n        newHead = current\n        while(current.next != None):\n            current = current.next\n            \n        newTail.next = None\n        current.next = head\n        \n        return newHead\n```\n# 复杂度\n时间复杂度 ：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921210618","body":"# 思路\nA-B-C-D\n\n变为\n\nA-B-D\n\nC-D\n\n变为\n\nA-B-D\n\nC-B\n\n变为\n\nA-C-B-D\n\n# 代码\n```python3\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0)\n        dummy.next = head\n        cur = dummy\n        while cur.next != None and cur.next.next != None: \n            tmp = cur.next\n            tmp1 = cur.next.next.next\n            \n            cur.next = cur.next.next\n            cur.next.next = tmp\n            cur.next.next.next = tmp1\n            \n            cur = cur.next.next\n        return dummy.next\n```\n# 复杂度\n时间复杂度 ：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922178479","body":"# 思路\n由于是对称的，所有使用递归。头部为None，这返回None。头部无下一个，则返回当前节点。然后有2倍速的fast寻找middle节点。然后断开成两边继续\n\n# 代码\n```python3\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        \n        pre, slow, fast = None, head, head\n        \n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        if pre:\n            pre.next = None\n            \n        node = TreeNode(slow.val)\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n# 复杂度\n时间复杂度 ：O(nlogn)\n\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922343087","body":"# 思路\n先遍历两个linked list，算出长度。然后长度长的先走长度差点部分，然后一直向前走，直到相遇。\n\n# 代码\n```python3\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        lenA = 0\n        curA = headA\n        while(curA != None):\n            curA = curA.next\n            lenA += 1\n            \n        lenB = 0\n        curB = headB\n        while(curB != None):\n            curB = curB.next\n            lenB += 1            \n        \n        curA = headA\n        curB = headB\n        \n        if(lenA < lenB):\n            lenA, lenB = lenB, lenA\n            curA, curB = curB, curA\n            \n        for _ in range(lenA - lenB):\n            curA = curA.next\n        \n        while(curA != None):\n            if curA ==  curB:\n                return curA\n            else:\n                curA = curA.next\n                curB = curB.next\n        \n        return None\n```\n# 复杂度\n时间复杂度 ：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922503345","body":"# 思路\nfast 以两倍速slow遍历，直到fast==slow.然后fast和head同时前进，直到相等\n\n# 代码\n```python3\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = head\n        fast = head\n        \n        while fast != None and fast.next != None:\n            slow = slow.next\n            fast = fast.next.next\n            \n            if slow == fast:\n                while head != slow:\n                    head = head.next\n                    slow = slow.next\n                return head\n        return None\n```\n# 复杂度\n时间复杂度 ：O(n)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RonghuanYou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916378066","body":"按照加法的运算顺序从后往前遍历，r是余数，也就是做完加法后的当前位的值\nk是除去最后一位的值\n结束循环，如果k>0，就要一直处理最后的carry，就是k%10放入output array\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sumArr = []\n        for i in range(len(num) - 1, -1, -1):\n            r = (num[i] + k) % 10\n            k = (num[i] + k) // 10\n            sumArr.append(r)\n            \n        while k > 0:\n            sumArr.append(k % 10)\n            k = k // 10\n        return sumArr[::-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917355278","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        shortest_dis_arr = [len(s)] * len(s)\n        for i in range(len(s)):\n            if s[i] == c:\n                shortest_dis_arr[i] = 0\n        \n        for i in range(1, len(s)):\n            shortest_dis_arr[i] = min(shortest_dis_arr[i], shortest_dis_arr[i-1]+1)\n       \n        for i in range(len(s) - 2, -1, -1):\n            shortest_dis_arr[i] = min(shortest_dis_arr[i], shortest_dis_arr[i+1]+1)\n\n        return shortest_dis_arr\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917448503","body":"```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        return self.stack.pop() if len(self.stack) > 0 else -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range (min(k, len(self.stack))):\n            self.stack[i] += val\n        \n\n# time complexity: \n# push(), pop(): O(1), increment(): O(min(k, n))\n# space complexity: O(N) N is max size\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917877224","body":"思路:\n用两个stack，一个记录出现的数字，一个记录字符串。\n当遇到[的时候，就存储数字和字符串。\n当遇到]的时候，就出栈，实现从内到外的这个打印效果。\n其他时候就Concatenate char。\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        numS, chaS = [], []\n        num, output = 0, \"\"\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '[':\n                numS.append(num)\n                chaS.append(output)\n                num, output = 0, \"\"\n            elif c == ']':\n                output = chaS.pop() + output * numS.pop()\n            else:\n                output += c\n        return output\n```\ntime complexity: O(N)\nspace complexity: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918859155","body":"```python3\r\n\r\nclass MyQueue:\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.s1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        self._move_s1_to_s2()\r\n        return self.s2.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        self._move_s1_to_s2()\r\n        return self.s2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.s2) + len(self.s1) == 0\r\n\r\n    def _move_s1_to_s2(self):\r\n        # move item from s1 to s2(empty check to make sure s2 stack is done with pop())\r\n        if len(self.s2) == 0:\r\n            while len(self.s1) > 0:\r\n                self.s2.append(self.s1.pop())\r\n\r\n```\r\ntime complexity: O(N)\r\nspace complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919753083","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        ans, sum1, sum2 = 0, 0, 0\n        sorted_arr = sorted(arr)\n        \n        for i, x in enumerate(arr):\n            sum1 += x\n            sum2 += sorted_arr[i]\n            if sum1 == sum2:\n                ans += 1\n                sum1, sum2 = 0, 0\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920632736","body":"```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or head is None or head.next is None:\n            return head\n        \n        cnt = 0\n        runner = head\n        \n        while runner:\n            cnt += 1\n            runner = runner.next\n        \n        k %= cnt\n        if k == 0:\n            return head\n        \n        slow = fast = head\n    \n        while k > 0:\n            k -= 1\n            fast = fast.next\n        \n        while fast.next:\n            slow, fast = slow.next, fast.next\n            \n        start = slow.next\n        slow.next = None\n        fast.next = head\n        return start\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921530046","body":"```python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        head = dummy\n\n        while head.next and head.next.next:\n            n1 = head.next\n            n2 = head.next.next\n\n            n1.next = n2.next\n            n2.next = n1\n            \n            head.next = n2\n            head = n1\n\n        return dummy.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922244705","body":"```python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        nums = []\n        while head:\n            nums.append(head.val)\n            head = head.next\n        return self.helper(nums, 0, len(nums) - 1)\n    \n    \n    def helper(self, nums, start, end):\n        if start > end: return None\n        \n        mid = (start + end) // 2\n        return TreeNode(nums[mid],  self.helper(nums, start, mid - 1), self.helper(nums, mid + 1, end))\n        \n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922426907","body":"```python3 \nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        runner1, runner2 = headA, headB\n        while runner1 != runner2:\n            runner1 = headB if runner1 is None else runner1.next\n            runner2 = headA if runner2 is None else runner2.next\n        return runner1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pophy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916379125","body":"## Java代码\r\n\r\n```java\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Stack<Integer> stack = new Stack<>();\r\n        int borrow = 0;\r\n        int i = num.length - 1;\r\n\r\n        while (k != 0 || i >= 0 || borrow != 0) {\r\n            int currentNumber;\r\n           if (i >= 0 && k != 0) {\r\n                currentNumber = num[i] + k % 10;\r\n           } else if (i >=0) {\r\n               currentNumber = num[i];\r\n           } else {\r\n               currentNumber = k % 10;\r\n           }\r\n            stack.add((currentNumber + borrow) % 10);\r\n            borrow = (currentNumber + borrow) / 10;\r\n            k = k / 10;\r\n            i--;\r\n        }\r\n\r\n        while (!stack.isEmpty()) {\r\n            res.add(stack.pop());\r\n        }\r\n        return res;\r\n    } \r\n```\r\n\r\n## 时间复杂度\r\n\r\nO(n)\r\n\r\n## 空间复杂度\r\n\r\nO(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917164588","body":"### 思路\r\n\r\n- 暴力解\r\n  - 从前遍历字符串中每一个char 到 target的距离， O(N^2)\r\n- 优化解\r\n  - 首先遍历字符串 找到target在字符串中的位置 并记录在index queue中\r\n  - 设置两个指针 pre = MIN_VALUE 和 next = queue.peek()， 分别代表target在字符串中出现的前一个和后一个位置\r\n  - 再次遍历字符串 当前距离 = Math.min(i-pre,  next -i)\r\n  - 果current Index == queue.peek(), pre = currentIndex, queue.poll()\r\n\r\n### Java Code\r\n\r\n```java\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        Queue<Integer> indexQueue = new LinkedList();\r\n        for (int i=0; i<s.toCharArray().length;i++) {\r\n            if (s.charAt(i) == c) {\r\n                indexQueue.add(i);\r\n            }\r\n        }\r\n        int pre = -1;\r\n        for (int i=0; i<s.toCharArray().length;i++) {\r\n            int next = indexQueue.peek();\r\n            res[i] = pre < 0 ? Math.abs(next-i) : Math.min(Math.abs(i-pre),Math.abs(next-i));\r\n            if (i == indexQueue.peek() && indexQueue.size() > 1) {\r\n                pre = indexQueue.peek();\r\n                indexQueue.poll();\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n### 时间 & 空间 复杂度\r\n\r\n- O(n)\r\n- O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917469345","body":"## 思路\n\n**核心： lazy evaluation**\n\n- 直到pop的时候 才处理增量问题\n\n- 利用额外的list来记录所有的增量\n- pop的时候 查询该位置的增量数据 + 原始数据\n\n## Java Code\n\n```java\nclass CustomStack {\n\n    int MAX_SIZE;\n    Stack<Integer> stack;\n    int[] increment;\n\n    public CustomStack(int maxSize) {\n        MAX_SIZE = maxSize;\n        //default to 0\n        increment = new int[2000];\n        stack = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (stack.size() >= MAX_SIZE) {\n            return;\n        }\n        stack.push(x);\n    }\n\n    public int pop() {\n        if (stack.isEmpty()) {\n            return -1;\n        }\n        int incrementValue = increment[stack.size() - 1];\n        //reset increment\n        increment[stack.size() - 1] = 0;\n        return stack.pop() + incrementValue;\n    }\n\n    public void increment(int k, int val) {\n        int incrementSize = Math.min(k,stack.size());\n        for (int i = 0; i < incrementSize; i++) {\n            increment[i] = increment[i] + val;\n        }\n    }\n}\n\n\n```\n\n## 时间复杂度\n\n### push/pop\n\n- O(1)\n\n### increment\n\n- O(k)\n\n### 空间复杂度\n\n- O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917705204","body":"## 思路\n\n- 利用两个stack，stringStack / counterStack\n- 遍历表达式 当前字符记为c， index i\n  - 如果 c 是数字\n    - c 的下一位也是数字， 则一直向后拓展到 j, subString(i,j)转为数字 压入counterStack\n  - 如果c == '[' 表示 subString开始，向stringStack中压入空串 “”\n  - 如果是c == ']' 表示sub string结束\n    - counterStack弹出counter数值\n    - stringStack弹出当前substring\n    - 循环counter次substring, 压回stringStack\n  - 非[ / ] 表示当前字符为substing中的一个 stringStack .push(stringStack.pop() + c)\n- 最后stringStack中的string就是答案\n\n## Java code\n\n```java\n    public String decodeString(String s) {\n        Stack<String> stringStack = new Stack();\n        Stack<Integer> counterStack = new Stack();\n        stringStack.push(\"\");\n        //starting index\n        int i = 0;\n        while (i < s.length()) {\n            Character c = s.charAt(i);\n            //match number\n            if (c >= '0' && c <= '9') {\n                int j = i + 1;\n                while (s.charAt(j) >= '0' && s.charAt(j) <= '9') {\n                    j++;\n                }\n                counterStack.push(Integer.parseInt(s.substring(i, j)));\n                i = j;\n            } else {\n                //match string\n                if (c == '[') {\n                    stringStack.push(\"\");\n                } else if (c == ']') {\n                    int counter = counterStack.pop();\n                    StringBuilder sb = new StringBuilder();\n                    String subString = stringStack.pop();\n                    for (int k = 0; k < counter; k++) {\n                        sb.append(subString);\n                    }\n                    stringStack.push(stringStack.pop() + sb);\n                } else {\n                    stringStack.push(stringStack.pop() + c);\n                }\n                i++;\n            }\n        }\n        return stringStack.pop();\n    }\n```\n\n## 时间复杂度 & 空间复杂度\n\n- 时间\n  - O(n)\n- 空间\n  - O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918478258","body":"## 思路\r\n\r\n- 队列FIFO 栈FILO 所以考虑用2个栈 2次进出操作模拟队列\r\n- 分为压入栈和弹出栈 inStack outStack\r\n  - push操作时 元素进inStack\r\n  - pop时 如果outStack为空 就弹出全部inStack元素到outStack 然后pop\r\n    - 不为空就直接pop\r\n\r\n## Java Code\r\n\r\n```java\r\nclass MyQueue {\r\n\r\n    Deque<Integer> inStack = new LinkedList();\r\n    Deque<Integer> outStack = new LinkedList();\r\n    \r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (empty()) {\r\n            return -1;\r\n        } \r\n        if (outStack.isEmpty()) {\r\n            dump();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (empty()) {\r\n            return -1;\r\n        } \r\n        if (outStack.isEmpty()) {\r\n            dump();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n    \r\n    private void dump() {\r\n\t\twhile (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n```\r\n\r\n## 时间 & 空间\r\n\r\n- 时间\r\n  - push/pop O(1)\r\n- 空间\r\n  - o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919387939","body":"## 解法1\r\n\r\n### 思路\r\n\r\n- 自然思维 \r\n  - 原数组A[ ]排序后为数组B[]\r\n    - 如果A[i~j]的元素和排序后数组B[i~j]有相同元素，则i~j为合法分割\r\n  - 遍历数组A 和 数组 B， 如果找到相同元素集合 计数++\r\n\r\n### Java Code\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int res = 0;\r\n        int[] original = Arrays.copyOf(arr,arr.length);\r\n        Arrays.sort(arr);\r\n        List<Integer> listOriginal = new ArrayList<>();\r\n        List<Integer> listSorted = new ArrayList<>();\r\n        for (int i = 0; i < arr.length; i++) {\r\n            listSorted.add(arr[i]);\r\n            listOriginal.add(original[i]);\r\n            if (haveSameElement(listOriginal,listSorted)) {\r\n                res++;\r\n                listOriginal.clear();\r\n                listSorted.clear();\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    private boolean haveSameElement(List<Integer> l1, List<Integer> l2) {\r\n        Collections.sort(l1);\r\n        Collections.sort(l2);\r\n        return l1.equals(l2);\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 时间&空间\r\n\r\n- 时间\r\n  - 遍历元素n * 比较两个list需要排序 n*log(n) = O(n^2 *log(n))\r\n- 空间\r\n  - O(n)\r\n\r\n## 解法2\r\n\r\n### 思路\r\n\r\n- 对于分割完毕的块[C1,C2...Cn] 则有\r\n  - 如果i < j, C[i].max <= C[j].min\r\n- 利用单调递增栈 stack 用来储存可以分割的每个区域的最大值\r\n  - 如果看到新值 arr[i] 比 stack 中的值小， 则表示以前的分割有误，\r\n    - 记录当前stack.peek() = max 表示当前块最大值\r\n    - 循环弹出stack的值\r\n    - stack.push(max) 表示合并块后的最大值\r\n- 最后stack中有多少个最大值 就是有多少个合法分割的块\r\n\r\n### Java Code\r\n\r\n```java\r\n    public int maxChunksToSorted2(int[] arr) {\r\n        Deque<Integer> stack = new LinkedList();\r\n        for (int i=0; i<arr.length; i++) {\r\n            if (stack.isEmpty() || stack.peek() <= arr[i]) {\r\n                stack.push(arr[i]);\r\n            } else {\r\n                //merge chunks, max will be the max nunber in new merged chunk\r\n                int max = stack.peek();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(max);\r\n            }\r\n        }\r\n        return stack.size();\r\n\r\n    }\r\n```\r\n\r\n### 时间&空间\r\n\r\n- 时间 O(n)\r\n- 空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920336224","body":"# Rotate List\r\n\r\n## 解法1 - 额外空间\r\n\r\n### 思路\r\n\r\n- 先找出链表长度N  K%N 得到实际需要操作的长度\r\n  - 例如 链表长度 3 k=10, 10 % 3 = 1 即移动1个位置\r\n- 把node依次放入queue\r\n  - 从队列头去除node放回队列 循环n - (k % n)次\r\n- 重新组成链表 并返回头\r\n\r\n### Java Code\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        Queue<ListNode> queue = new LinkedList();\r\n        int length = 0;\r\n        ListNode current = head;\r\n        while (current != null) {\r\n            queue.add(current);\r\n            current = current.next;\r\n            length++;\r\n        }\r\n        int moveSteps = length - k % length;\r\n        for (int i=0; i<moveSteps; i++) {\r\n            queue.add(queue.poll());\r\n        }\r\n\r\n        ListNode newHead = queue.poll();\r\n        ListNode pre = newHead;\r\n        while (!queue.isEmpty()) {\r\n            current = queue.poll();\r\n            pre.next = current;\r\n            pre = current;\r\n        }\r\n        pre.next = null;\r\n        return newHead;\r\n    }\r\n}\r\n```\r\n\r\n### 时间&空间\r\n\r\n- 时间 O(n)\r\n- 空间 O(n)\r\n\r\n\r\n\r\n## 解法2 - 额外空间 O(1)\r\n\r\n### 思路\r\n\r\n- 需要找出head, tail, newHead,newTail\r\n  - 用快慢指针找出 newTail\r\n  - newTail.next = newHead\r\n  - tail.next = head\r\n  - newTail.next = null\r\n  - 最后返回newHead\r\n\r\n### Java code\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        if (head.next == null) {\r\n            return head;\r\n        }\r\n        //get length of list\r\n        int length = 0;\r\n        ListNode current = head;\r\n        while (current != null) {\r\n            current = current.next;\r\n            length++;\r\n        }\r\n        k = k % length;\r\n\r\n        if (k == 0) {\r\n            return head;\r\n        }\r\n        \r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        //fast move ksteps, then slow move\r\n        for (int i=0; i<k; i++) {\r\n            fast = fast.next;\r\n        }\r\n        while (fast.next != null) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        ListNode newTail = slow;\r\n        ListNode tail = fast;\r\n        ListNode newHead = newTail.next;\r\n        newTail.next = null;\r\n        tail.next = head;\r\n\r\n        return newHead;\r\n}\r\n```\r\n\r\n### 时间&空间\r\n\r\n- 时间 O(n)\r\n- 空间 O(1)\r\n\r\n```Java\r\n\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921142937","body":"## 思路\n\n- 两两交换 是k个一组反转的特殊情况 即k=2\n- 使用stack来进行反转 把node放入stack，当stack.size() == k时 弹出并重新连成链表\n- 注意防止环出现 所以放入stack时 每一个node.next = null\n\n## Java code\n\n```java\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        return swapKPairs(head,2);\n    }\n\n    public ListNode swapKPairs(ListNode head, int k) {\n        ListNode newHead = null;\n        ListNode preNode = null;\n        Deque<ListNode> stack = new LinkedList<>();\n        while (head != null) {\n            while (head != null && stack.size() != k) {\n                ListNode next = head.next;\n                head.next = null;\n                stack.push(head);\n                head = next;\n            }\n            \n            while (!stack.isEmpty()) {\n                if (newHead == null) {\n                    newHead = stack.peek();\n                }\n                if (preNode == null) {\n                    preNode = stack.pop();\n                } else {\n                    ListNode node = stack.pop();\n                    preNode.next = node;\n                    preNode = node;\n                }\n            }\n        }\n        return newHead;\n    }\n```\n\n## 时间&空间\n\n- 时间 o(n)\n- 空间 o(k) k = 2","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922048922","body":"### 思路\n\n- 利用快慢指针 找到链表 Mid - 1的位置\n- mid-1的下一个 就是二叉树的头\n- 断开mid -1和mid的连接 \n- 递归分别生成left 和 right\n  - 左边的头是head 右边的头是mid + 1\n  - 递归退出条件是 head == null 或者head.next == null\n\n### Java Code\n\n```java\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n\n        ListNode preMid = findMid(head);\n        TreeNode root = new TreeNode(preMid.next.val);\n        ListNode nextMid = preMid.next.next;\n        preMid.next = null;\n        TreeNode left = sortedListToBST(head);\n        TreeNode right = sortedListToBST(nextMid);\n        root.left = left;\n        root.right = right;\n        return root;\n    }\n\n\n    private ListNode findMid(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        if (fast != null && fast.next != null) {\n            fast = fast.next.next;\n        }\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n```\n\n### 时间&空间\n\n- 时间 O(n*log(n))  \n- 空间 O(1) 不考虑递归栈系统内存","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922342528","body":"## Intersection of Two Linked Lists\n\n### 思路\n\n- 首先判断两个链表是否相交， 如果两个表的最后一个Node不一样 则不相交\n- 在判断是否相交的同时 得到两个链表的长度 l1 和 l2\n  - k = abs(l1-l2)\n- 长度较长的链表先走k步 然后两个链表一起走 相同的Node就是相交的点\n\nJava Code\n\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode curA = headA;\n        int lengthA = 0, lengthB = 0;\n        while (curA.next != null) {\n            curA = curA.next;\n            lengthA++;\n        }\n        ListNode curB = headB;\n        while (curB.next != null) {\n            curB = curB.next;\n            lengthB++;\n        }\n        if (curA != curB) {\n            return null;\n        }\n        curA = headA;\n        curB = headB;\n        int k = Math.abs(lengthA - lengthB);\n        if (lengthA > lengthB) {\n            for (int i = 0; i < k; i++) {\n                curA = curA.next;\n            }\n        } else {\n            for (int i = 0; i < k; i++) {\n                curB = curB.next;\n            }\n        }\n        while (curA != null && curB != null) {\n            if (curA == curB) {\n                return curA;\n            }\n            curA = curA.next;\n            curB = curB.next;\n        }\n        return null;\n    }\n```\n\n### 时间 & 空间\n\n- 时间 O(n)\n- 空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922503305","body":"### 思路\n\n- 快慢指针 fast slow 判断是否有环\n  - 当 fast == slow时\n    - fast重新指向head 同时fast = fast.next slow = slow.next\n    - 当fast == slow时 返回fast\n  - 如果找不到fast == slow 则没有环\n\nJava Code\n```java\npublic ListNode detectCycle(ListNode head) {\n    if (head == null || head.next == null || head.next.next == null) {\n        return null;\n    }\n    ListNode fast = head.next.next;\n    ListNode slow = head.next;\n    while (fast != null && fast.next != null) {\n        if (fast == slow) {\n            fast = head;\n            break;\n        }\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    while (fast != null && slow != null) {\n        if (fast == slow) {\n            return fast;\n        }\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return null;\n}\n```\n\n### 时间 & 空间\n\n- 时间 O(n) \n- 空间 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ninghuang456":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916390741","body":"JAVA code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int carry = 0;\r\n        int index = A.length - 1;\r\n        while(K > 0 || index >= 0){\r\n            int curK = K % 10;\r\n            int curA = index >= 0 ? A[index]: 0;\r\n            int curDigitSum = curK + curA + carry;\r\n            int toBeAdded = curDigitSum % 10;\r\n            carry = curDigitSum / 10;\r\n            index --;\r\n            K /= 10;\r\n            res.addFirst(toBeAdded);\r\n        }\r\n        if(carry != 0){\r\n            res.addFirst(1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\nTime: O(n);\r\nSpace: O(n);\r\n\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919451441","body":"> @ninghuangaa\n> ```java\r\n>  public static int maxChunksToSorted(int[] arr) {\r\n>             int n = arr.length, res = 0;\r\n>             int[] sortArr = Arrays.copyOf(arr, n);\r\n>             Arrays.sort(sortArr);\r\n>             int netSum = 0;\r\n>             for (int i = 0; i < n; ++i) {\r\n>                 netSum += (arr[i] - sortArr[i]);\r\n>                 if (netSum == 0)\r\n>                     res++;\r\n>             }\r\n>             return res;\r\n>         }\r\n> ```\r\n> Time (N* LogN)\r\n> Space O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916408530","body":"Python 3 code:\r\n     \r\n    class Solution:\r\n         def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n              if num[0] == 0 and k == 0:\r\n                 return [0]\r\n              inputnum = 0\r\n              for number in num:\r\n                   inputnum = inputnum * 10 + number\r\n              summ = inputnum + k \r\n              res = []\r\n              while summ > 0:\r\n                      digit = summ % 10\r\n                      res.append(digit)\r\n                      summ = summ // 10\r\n              return res[::-1]\r\n\r\nTime Complexity: O(n) because we run through the given array one time\r\nSpace Complexit: O(n) because we created a new array res to record the sum","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917213167","body":"two pointers: for each character in the string we initialize two points L and R before and after the current character. Then we decrease the left pointer and increase the right pointer until the target character is found on the left side and right side of the current character. Then we record the minimum of the two distances. \r\nPython 3 code: \r\n\r\n    class Solution:\r\n         def shortestToChar(self, s: str, c: str) -> List[int]:\r\n               ans = []\r\n               for i in range(len(s)):\r\n                    left_val = len(s)\r\n                    right_val = len(s)\r\n                    if s[i] == c:\r\n                       ans.append(0)\r\n                       continue\r\n                    l , r = i - 1, i + 1\r\n                    while r <= len(s)-1:\r\n                             if s[r] == c:\r\n                                right_val = r - i\r\n                                break\r\n                             else:\r\n                                   r += 1\r\n                    while l >= 0:\r\n                             if s[l] == c:\r\n                               left_val = i - l\r\n                               break\r\n                             else:\r\n                                   l -= 1\r\n                   ans.append(min(left_val, right_val))\r\n               return ans\r\nTime complexity O(n^2) we scan through the string twice.\r\nSpace Complexity O(n) we record the distances in an list 'ans'","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917477332","body":"Python 3 code:\r\n            \r\n    class CustomStack:\r\n    \r\n            def __init__(self, maxSize: int):\r\n                  self.stack = [-10]* maxSize\r\n                  self.cur_pt = -1\r\n            def push(self, x: int) -> None:\r\n                  if self.stack[-1] == -10:\r\n                     self.stack[self.cur_pt + 1] = x\r\n                     self.cur_pt += 1\r\n            def pop(self) -> int:\r\n                  if self.cur_pt != -1:\r\n                     pop_val = self.stack[self.cur_pt]\r\n                     self.stack[self.cur_pt] = -10\r\n                     self.cur_pt -= 1\r\n                     return pop_val\r\n                  else:\r\n                      return -1\r\n\r\n            def increment(self, k: int, val: int) -> None:\r\n                  cur_size = min(self.cur_pt + 1, k)\r\n                  for i in range(cur_size):\r\n                       self.stack[i] += val\r\n\r\n\r\nTime Complexity: pop, push: O(1) \r\n                             increment: O(n) in worst case\r\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917820830","body":"Python 3 code:\r\n\r\n      class Solution:\r\n           def decodeString(self, s: str) -> str:\r\n                  stack = []\r\n                  for char in s:\r\n                       if char != ']':\r\n                           stack.append(char)\r\n                        else:\r\n                             cur_str = ''\r\n                             itr_iter = ''\r\n                             while stack and stack[-1] != '[':\r\n                                   cur_str = stack.pop() + cur_str\r\n                                    stack.pop()\r\n                              while stack and stack[-1].isdigit():\r\n                                   str_iter = stack.pop() + str_iter\r\n                                   int_iter = int(str_iter)\r\n                               stack.append(cur_str * int_iter)\r\n                  return ''.join(stack)\r\nTime complexity: O(N) N = length of decoded string\r\nSpace Complexity: O(N)\r\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918529567","body":"Python 3 code:\n\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.size1 = 0\n        self.stack2 = []\n        self.size2 = 0\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n        \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        pop_val = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return pop_val\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        peek_val = self.stack2[-1]\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return peek_val\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if not self.stack1:\n            return True\n        else:\n            return False\nTime complexity: pop: O(1) push O(1), peek O(n) \nSpace complexity: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920490219","body":"思路：先遍历链表得到表的长度length， 标记链表尾为tail， 记录k mod length 为 true_k，从表首前进length - true_k - 1 次 得到新链表的尾new_tail, 记录new_tail的下一个元素为new_head, \r\n连接旧表尾和旧表首， 更新new_tail的next为None， 返回 new_head\r\n\r\nPython 3 code :\r\n\r\n    class Solution:\r\n      def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n         if head == None or head.next == None:\r\n            return head\r\n         length = 1\r\n         pt = head\r\n         while pt.next != None:\r\n            pt = pt.next\r\n            length += 1\r\n        old_tail = pt\r\n        true_k = k % lenth\r\n        if true_k == 0: return head\r\n        num_to_move = length - true_k\r\n        cur = head\r\n        while num_to_move - 1:\r\n            cur = cur.next\r\n            num_to_move -= 1\r\n        new_tail = cur\r\n        new_head = cur.next\r\n        old_tail.next = head\r\n        new_tail.next = None\r\n        return new_head\r\n\r\nTime Complexity: O(n) as we scan through the linked list to get length.\r\nSpace Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921268965","body":"思路：\n先交换前两个节点，然后用迭代。\nPython 3 code:\n'''\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        if head == None or head.next == None:\n            return head\n        new_head  = head.next \n        head_of_next_pair = new_head.next\n        new_head.next = head\n        head.next = self.swapPairs(head_of_next_pair)\n        return new_head\n\n\nTime Complexity : O(n)\nSpace Complexity: O(n)  迭代使用了栈 ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922133173","body":"取链表中点为root node，左半作为左子树，右半作为右子树，然后递归\r\nPython 3 code:\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head: return None\r\n        if not head.next: return TreeNode(head.val)\r\n        curr = head\r\n        length = 1\r\n        while curr.next:\r\n            curr = curr.next\r\n            length += 1\r\n        mid = (length - 1) // 2\r\n        pt = head\r\n        while mid - 1 > 0:\r\n            pt = pt.next\r\n            mid -= 1\r\n        root_prev = pt\r\n        root = pt.next\r\n        root_after = root.next\r\n        root_prev.next = None\r\n        root_node = TreeNode(root.val)\r\n        root_node.left = self.sortedListToBST(head)\r\n        root_node.right = self.sortedListToBST(root_after)\r\n        return root_node\r\n```\r\nTime Complexity:  O(nlog(n)) : n + n/2 + n/4 + .....\r\nSpace Complexity: O(log(n)): because we are truncating n by half everytime we use recursion. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922377786","body":"思路：使用两个指针放在headA和headB， 当指针是链表尾部的时候重置指针到另一链表的头部，两个指针相遇的点即是交点\nPython 3 Code:\n\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a \n```\n\nTime Complexity: O(N + M) in the worst case where there is not intersection, we need to traverse the two linked lists.\nSpace Complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qyw-wqy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916408891","body":"## 代码\nJava:\n```\n public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int i = num.length-1;\n        int carry = k;\n        while (i >= 0 || carry > 0) {\n            int n = i >= 0 ? num[i--] : 0;\n            carry += n;\n            list.add(carry % 10);\n            carry /= 10;\n        }\n        \n        Collections.reverse(list);\n        return list;\n    }\n```\nTime：O(n)     \nSpace：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917565819","body":"## 代码\r\n\r\n用一个数组来记录累计累加的值\r\n```\r\nclass CustomStack {\r\n    int[] inc;\r\n    Deque<Integer> stack;\r\n    int maxSize;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        this.inc = new int[maxSize];\r\n        this.stack = new ArrayDeque<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (stack.size() == maxSize) return;\r\n        stack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (stack.isEmpty()) return -1;\r\n        int index = stack.size() - 1;\r\n        if (index > 0) inc[index - 1] += inc[index];\r\n        int val = stack.pop() + inc[index];\r\n        inc[index] = 0;\r\n        return val;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int index = Math.min(k - 1, stack.size() - 1);\r\n        if (index < 0) return;\r\n        inc[index] += val;\r\n    }\r\n}\r\n```\r\n复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917738072","body":"## 代码\nJava:\n```\nclass Solution {\n    int i = 0;\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        while (i < s.length()) {\n            if (Character.isDigit(s.charAt(i))) {\n                int num = 0;\n                while (i < s.length() && Character.isDigit(s.charAt(i))) {\n                    num = num * 10 + s.charAt(i++) - '0';\n                }\n                i++; //skip '['\n                String next = decodeString(s);\n                while (num-- > 0) sb.append(next);\n            } else if (s.charAt(i) == ']') {\n                i++; // skip '['\n                return sb.toString();\n            } else {\n                sb.append(s.charAt(i++));\n            }\n        }\n        \n        return sb.toString();\n    }\n}\n```\nComplexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918859966","body":"```\nclass MyQueue {\n    Stack<Integer> first;\n    Stack<Integer> second;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        this.first = new Stack<>();\n        this.second = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        second.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (first.isEmpty()) swap();\n        return first.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (first.isEmpty()) swap();\n        return first.peek();\n    }\n    \n    private void swap() {\n        while (!second.isEmpty()) {\n            first.push(second.pop());\n        }\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return first.isEmpty() && second.isEmpty();\n    }\n}\n```\ntime complexity: O(1)\nspace complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919672426","body":"```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] sorted = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(sorted);\n        int count = 0;\n        for (int i = 0, sum = 0; i < arr.length; i++) {\n            sum += arr[i] - sorted[i];\n            if (sum == 0) count++;\n        }\n        return count;\n    }\n}\n```\nTime: O(nlogn)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920614513","body":"```\npublic ListNode rotateRight(ListNode head, int k) {\n        int len = 0;\n        ListNode pre = null;\n        ListNode node = head;\n        while (node != null) {\n            pre = node;\n            node = node.next;\n            len++;\n        }\n        if (len == 0) return null;\n        pre.next = head;\n        k  %= len;\n        len -= k;\n        node = head;\n        while (len-- > 0) {\n            pre = node;\n            node = node.next;\n        }\n        pre.next = null;\n        return node;\n    }\n```\nTime: O(n)\nSpace: O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922396016","body":"```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n        \n        while (a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        \n        return a;\n    }\n}\n```\nTime: O(n)\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skinnyh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916409263","body":"# Solution1\n\nUse while loop to add K to num digit by digit. Maintain the carry and end the loop when carry is 0 and all digits from K has been added. Note that inserting to the list head is not efficient.\n\n# Code\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry, idx = 0, len(num) - 1\n        while k > 0 or carry > 0:\n            digit = k % 10\n            k = k // 10\n            if idx < 0:\n                num.insert(0, 0)\n                i = 0\n            else:\n                i = idx\n            tmp = num[i] + digit + carry\n            num[i] = tmp % 10\n            carry = tmp // 10\n            idx -= 1\n        return num\n```\n\nTime complexity: O(N + max(0, K - N)^2), K is length of k and N is length of num\n\nSpace complexity: O(max(1, K - N))\n\n# Solution2\n\nCreate another result array and always append the digit sum to the result end to avoid insert to head. Reverse the result list before return. The while loop end condition will also need to check if it has traversed all the num list.\n\n# Code\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry, idx = 0, len(num) - 1\n        res = []\n        while idx >= 0 or k > 0 or carry > 0:\n            digit = k % 10\n            k = k // 10\n            n = num[idx] if idx >= 0 else 0\n            res.append((n + digit + carry) % 10)\n            carry = (n + digit + carry) // 10\n            idx -= 1\n        return reversed(res)\n```\n\nTime complexity: O(N)\n\nSpace complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917162074","body":"# Note\n\nRecord the occurrence of char c in a list c_idx. Then use two pointers i and p to iterate S and c_idx. For each i, compare the distance with p and p+1 until find the closest p.\n\nThe space complexity can be improved. Instead of saving the c positions, we can scan the S twice from **left to right and from right to left**. So that each char will be able to compare to the closest C on its left and right.\n\n# Solution1\n\n```python\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res, c_idx = [], []\n        for i, ch in enumerate(s):\n            if ch == c:\n                c_idx.append(i)\n        p = 0\n        for i in range(len(s)):\n            while (p < len(c_idx) - 1 and abs(c_idx[p + 1] - i) < abs(c_idx[p] - i)):\n                p += 1\n            res.append(abs(c_idx[p] - i))\n        return res\n```\n\nTime complexity: O(2N + K) where N is the length of s and K is occurrence count of c.\n\nSpace complexity: O(K) to save the char occurrence positions.\n\n# Solution2\n\n```python\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n, c_idx = len(s), float('-inf')\n        res = [n] * n\n        for i in range(n):\n            if s[i] == c: c_idx = i\n            res[i] = min(res[i], abs(i - c_idx))\n        for i in range(n)[::-1]:\n            if s[i] == c: c_idx = i\n            res[i] = min(res[i], abs(i - c_idx))\n        return res\n```\n\nTime complexity: O(2N) where N = len(s)\n\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662219","body":"# Note\n\n- Naive method to implement inc() by adding val to first k elements will take O(k) time.\n- Since we only get number from stack with the pop() method, we can use lazy increment idea. Let inc[i] means for all elements stack[0] ~ stack[i], we should plus inc[i] when popped from the stack. After we pop a number from stack,  inc[i-1]+=inc[i]. Thus inc() becomes O(1)\n\n# Solution\n\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.list = []\n        # inc[i] means for all elements stack[0] ~ stack[i],\n        # we should plus inc[i] when popped from the stack.\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.max_size:\n            self.list.append(x)\n            self.inc.append(0)\n        \n    def pop(self) -> int:\n        if not self.list:\n            return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        return self.list.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, len(self.inc)) - 1] += val\n```\n\nTime complexity: O(1)\n\nSpace complexity: O(N) N is the max_size","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918688319","body":"# Note\n\n- Use input stack and output stack. Push new numbers to the input stack. When doing pop, if output stack is empty, move all the numbers from input stack to the output stack so the order is reversed.\n\n# Solution\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.in_stack = []\n        self.out_stack = []\n        \n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.in_stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.out_stack:\n            self.peek()\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n        return self.out_stack[-1]\n    \n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.in_stack) + len(self.out_stack) == 0\n```\n\nTime complexity: O(1) amortized. Every number only gets among the two stacks once.\n\nSpace complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919523494","body":"# Note\n\nUse monotonic stack. For every number in array, pop out all the previous numbers greater than current. Specially, we record the largest number pop from the stack so that the final numbers in the stack means the the largest value in each chunk. And the stack length is the result.\n\n# Solution\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for n in arr:\n            largest = n\n            while stack and stack[-1] > n:\n                largest = max(largest, stack.pop())\n            stack.append(largest)\n        return len(stack)\n```\n\nTime complexity: O(N) Each elements at most gets push and pop once.\n\nSpace complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920313312","body":"# Note\n\nK can be larger than length so we need to know length and use k = k % len to find effective rotations. Then we can find the K+1 node from the tail, which is the (len - k) node from the head. This node will be the new tail, and node.next will be the new head. \n\n# Solution\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return head\n        tail = head\n        l = 1\n        while tail.next:\n            tail = tail.next\n            l += 1\n        k = k % l\n        if k == 0: return head\n        # Get the k+1 node from the tail\n        p = head\n        for _ in range(l - k - 1):\n            p = p.next\n        # p will be the new tail and p.next is the new head\n        tail.next = head\n        head = p.next\n        p.next = None\n        return head\n```\n\nTime complexity: O(N)\n\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921216559","body":"# Note\n\n- Use a dummy node to avoid edge cases.\n- Iterate the list and swap a pair at each move. For each pair, `nextFirst = second.next, prev.next = second, second.next = first and first.next = nextFirst, prev = first`\n\n# Solution\n\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        dummy.next = head\n        prev = dummy\n        while head and head.next:\n            nextNode = head.next.next\n            prev.next = head.next\n            head.next.next = head\n            head.next = nextNode\n            prev = head\n            head = nextNode\n        return dummy.next\n```\n\nTime complexity: O(N)\n\nSpace complexity: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922371066","body":"# Note\n\n- Use two pointers moving from the heads of two list. Quit iteration when the two pointers meet. When each pointer reaches to at the end, move it to the other head so it solves the problem of length difference.\n- When two lists have the same length, two pointers will reach the end the same time on the first iteration if no intersect and we can end there when both pointers are None.\n\n# Solution\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return None\n        pa, pb = headA, headB\n        while (pa != pb):\n            pa = pa.next if pa else headB\n            pb = pb.next if pb else headA\n        return pa\n```\n\nTime complexity: O(m+n)\n\nSpace complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leo173701":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916409706","body":"很笨的办法， 请忽略  \n时间复杂度 o(n),\n空间复杂度o(n)\n\n  `def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        n = len(num)\n        temp = 0\n        for i in range(n):\n            temp +=num[i]* (10**(n-1-i))     \n        b = temp + k\n        res = []\n        while b>9:\n            d = b%10\n            b = b//10\n            res.append(d)\n        res.append(b)\n        res.reverse()        \n        return res`\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917050689","body":"思路：维护一个滑动窗口[left, right]，不断调整窗口的位置\r\n          left=right\r\n          right = new location\r\n\r\n1. 第一遍遍历, 统计所在的位置temp\r\n2. 如果temp只有一个元素， 那就直接再遍历一次，直接返回结果res\r\n3. 如果temp 有2个及其以上元素，那就用滑动窗口\r\n时间复杂度： O(n)\r\n空间复杂度： O(n)\r\n\r\n`    Python3 :\r\ndef shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        temp = []\r\n        for i in range(len(s)):\r\n            if c==s[i]:\r\n                 temp.append(i)\r\n        res = [-1 for _ in range(len(s))]\r\n        # print(temp)\r\n        if len(temp)==1:\r\n            res = [abs(i-temp[0]) for i in range(len(s))]\r\n            return res\r\n        left = temp[0]\r\n        right = temp[1]\r\n        j=1\r\n        for i in range(len(s)):\r\n            if i<=temp[0]:\r\n                res[i] = temp[0]-i\r\n                continue\r\n            elif i>=temp[-1]:\r\n                res[i]=i-temp[-1]\r\n            elif i==left:\r\n                    res[i]=0\r\n            elif i==right:\r\n                res[i]=0\r\n                if j<(len(temp)-1):\r\n                    left = right\r\n                    j+=1\r\n                    right = temp[j]\r\n                    # print(\"now it's time to shift window, new left=\",left,\" right=\",right)\r\n            else:\r\n                res[i] = min(abs(i-left), abs(right-i))\r\n                # print(\"i is inside the window\")\r\n                # print(\"     i = \",i,\",res[i]=\",res[i])\r\n                # print(\"          left = \",left)\r\n                # print(\"          right = \",right)\r\n        return res`","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918285011","body":"思路：遇到字符匹配的事情，第一反应就是 用栈 来处理了。本题的关键在于“[”  “]”, 这俩是判断入栈  还是 出栈 的关键。\n时间复杂度: O(n)\n空间复杂度：O(n) (其实用不到这么多空间，O(n) 算是最差的情况了）\n\n    def decodeString(self, s: str) -> str:\n\n        bracket_stack = []\n        digit_stack = []\n        res = ''\n        n = ''\n        for e in s:\n            \n            if e.isdigit():\n                n+=e\n            elif e == '[':\n                bracket_stack.append(res)\n                digit_stack.append(n)\n                n = ''\n                res = ''\n            elif e == ']':\n                \n                res = (bracket_stack.pop() + res*int(digit_stack.pop()))\n            else:\n                res += e\n        return res","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919525563","body":"时间复杂度 O(n), 空间复杂度O(n)\n\npublic int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        int[] maxOfLeft = new int[n];\n        int[] minOfRight = new int[n];\n\n        maxOfLeft[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n            maxOfLeft[i] = Math.max(maxOfLeft[i-1], arr[i]);\n        }\n\n        minOfRight[n - 1] = arr[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]);\n        }\n\n        int res = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (maxOfLeft[i] <= minOfRight[i + 1]) res++;\n        }\n\n        return res + 1;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920316844","body":"思路要点：\n1. 先遍历一遍求出总的长度n，  并且记录尾节点\n2. k = k%n, 也就是跑了很多圈以后的位置\n3. 快慢指针，先让fastpointer 跑K步， 再和slotpointer 一起开始跑， 这样就得到倒数第K个节点所在的位置。\n\n\n‘def rotateRight(self, head, k):\n\n\n    if not head:\n        return None\n    \n    if head.next == None:\n        return head\n        \n    pointer = head\n    length = 1\n    \n    while pointer.next:\n        pointer = pointer.next\n        length += 1\n    \n    rotateTimes = k%length\n    \n    if k == 0 or rotateTimes == 0:\n        return head\n    \n    fastPointer = head\n    slowPointer = head\n    \n    for a in range (rotateTimes):\n        fastPointer = fastPointer.next\n    \n    \n    while fastPointer.next:\n        slowPointer = slowPointer.next\n        fastPointer = fastPointer.next\n    \n    temp = slowPointer.next\n    \n    slowPointer.next = None\n    fastPointer.next = head\n    head = temp\n    \n    return head’","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922353060","body":"要点：双指针，  链表的拼接\n思路： 可以这么理解，a，b两个链表，变更为 a+b 和 b+a，长度就相等了，然后等步遍历判断是否相等就行了\n时间复杂度: O(m+n)\n空间复杂度: O(1)\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA==null || headB==null){return null;}\n        ListNode pa = headA;\n        ListNode pb = headB;\n        while(pa!=pb){\n            pa= pa==null? headB:pa.next;\n            pb= pb==null? headA:pb.next;\n        }\n        return pa;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kidexp":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916420802","body":"## Thinking\nassume  num length is n, k has m digits\n\nTake [1,2,3]+999 as an example\n\nFirst convert [1,2,3] into 123 which takes O(m)\n\nThen add 123 with 999 = 1122, which takes O(1)\n\nFinally convert 1122 to [1,1,2,2] which is O(max(m,n)+1)  = O(max(m,n)\n\n\n## Code\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        m = 0\n        for digit in num:\n            m = m * 10 + digit\n        sum_ = m + k\n        result = []\n        while sum_:\n            result.append(sum_ % 10)\n            sum_ //= 10\n        return result[::-1] if result else [0]\n\n```\n\n## Complexity\nTime: O(n)+O(1)+O(max(m,n) = O(m+n)\n\nSpace Complexity: O(max(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917107545","body":"## Thoughts\nassume s length is n\n\ntake S = \"loveleetcode\", C = 'e' as an example\n\nfirst we compute the position of C in S, we can get T  [3,5,6,11], O(n), if S only contains chars of C then T will have same length as S.\n\nthen we can use one pointer (c_index) to indicate which position of C in S we are referring to \nwe iterate through S with index i, each time we will only compare at the position of current char in S with two positions in T, (c_index, and c_index+1), and chose the minimal difference \nWhenever s[I] is equal to next position in T, we will update c_index\n\nthe whole two pointers approach takes at most 2n which is O(n)\n\n## code \n```python\nfrom typing import List\n\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        positions = [i for i in range(len(s)) if s[i] == c]\n        c_index = 0\n        results = []\n        for i in range(len(s)):\n            if c_index < len(positions) - 1 and i == positions[c_index + 1]:\n                c_index += 1\n            if c_index == len(positions) - 1:\n                results.append(abs(i - positions[c_index]))\n            else:\n                results.append(\n                    min(abs(i - positions[c_index]), abs(positions[c_index + 1] - i))\n                )\n        return results\n\n```\n\n## Complexity\nTime complexity: O(n) \n\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917433569","body":"## thoughts\r\na straight forward solution is to have a stack, then push and pop is just reusing stack push and pop, which is O(1)\r\n\r\n when increment, we can do the increment  whenever we call increment and starts from the k, which makes increment O(k)\r\n\r\nA better solution is that  we can reuse lazy execution since increment is only done for the bottom k elements and there is no random delete/inserts, we can keep an inc array, whenever there is an increment operation, we just update inc[k] with val added to it. For push, we can append 0 to inc to make inc same size as stack, for pop, we need update pop last element of inc and add it to the new last element.\r\n\r\nFor the lazy execution solution, all operation will be O(1)\r\n\r\n```python\r\nclass CustomStack:\r\n    \"\"\"\r\n    O(k) increment\r\n    \"\"\"\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.max_size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val\r\n\r\n\r\nclass CustomStack:\r\n    \"\"\"\r\n    O(1) increment\r\n    \"\"\"\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.max_size = maxSize\r\n        self.inc = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n            self.inc.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            if len(self.stack) > 1:\r\n                self.inc[-2] += self.inc[-1]\r\n            return self.stack.pop() + self.inc.pop()\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.stack:\r\n            self.inc[min(k, len(self.stack)) - 1] += val\r\n```\r\n\r\n## Complexity:\r\n* time complexity: push/pop/increment O(1)\r\n* space complexity: O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917732631","body":"## thoughts\nvery typical stack problem,  we can iterate through the string, \n1. each time we face a digit, we keep adding the digit to the stack \n2. each time we face other char  that ']' we just append to stack \n3. each time we face ']' pop until ''[ to get string, then get num and multiple num with string and append to stack\nfinally we will have join all strings in stack and return it \n\n## code\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        \"\"\"\n        simplified version\n        \"\"\"\n        stack = []\n        i = 0\n        for i in range(len(s)):\n            if s[i].isdigit():\n                if stack and type(stack[-1]) is int:\n                    stack[-1] = stack[-1] * 10 + int(s[i])\n                else:\n                    stack.append(int(s[i]))\n            elif s[i] == \"]\":\n                temp_str = \"\"\n                while stack and stack[-1] != \"[\":\n                    temp_str = stack.pop() + temp_str\n                if stack and stack[-1] == \"[\":\n                    stack.pop()\n                if stack and type(stack[-1]) is int:\n                    repeat_num = stack.pop()\n                    stack.append(temp_str * repeat_num)\n            else:\n                stack.append(s[i])\n        return \"\".join(stack)\n\n```\n## complexity\ntime complexity : O(n)\nspace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918675084","body":"## thoughts\nuse two stacks, one is used to push, one for pop\n\nwhenever we do pop or peek, we will check the 2nd stack is empty or not, if empty, we will push all the first stack's content into it\n\nwhen check empty we will check both stack are empty \n## code\n```python\nclass MyQueue:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []\n        self.queue = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.queue:\n            while self.stack:\n                self.queue.append(self.stack.pop())\n        return self.queue.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if not self.queue:\n            while self.stack:\n                self.queue.append(self.stack.pop())\n        return self.queue[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.queue) == 0 and len(self.stack) == 0\n```\n## complexity \nall operation takes O(1) amortized \n\nspace complexity O(n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919632868","body":"## thoughts\n这个题目相当于把原来的数组分成几个块，相邻的两个块，左边的块的最大值小于右边块的最小值，可以用一个非递减的栈\n\n遍历数组，如果栈不为空，且栈顶元素（即栈里的最大值）比当前大，那么这就意味着这个数应该是和当前栈顶是一个块，那么我们把当前栈顶pop出来，然后把栈中比他大的数都pop出来，因为他们属于一个块, \n\n如果栈为空或者栈里面元素不比当前大 那就可以加入\n\n最后栈里面的元素就是每个block的最大值，所以这也意味着栈的长度就是block的数量\n##code\n```python\nfrom typing import List\n\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        \"\"\"\n        monotonous non-decreasing stack\n        \"\"\"\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]:\n                max_value = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(max_value)\n            else:\n                stack.append(num)\n        return len(stack)\n```\n## complexity\ntime complexity O(n)\n\nSpace Complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920456453","body":"## thoughts\n先求长度 n 和尾巴\n\n然后k mod 长度\n\n然后找到 新的head 分割 重新连接\n\n## code\n```python\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head or not head.next:\n            return head\n\n        # get list length\n        list_length = 0\n        cur = head\n        tail = None\n        while cur:\n            list_length += 1\n            cur = cur.next\n            if cur:\n                tail = cur\n\n        # handle k = 0 case\n        k = k % list_length\n        if k == 0:\n            return head\n\n        count = 0\n        cur = head\n        while count < list_length - k - 1:\n            count += 1\n            cur = cur.next\n        new_head = cur.next\n        cur.next = None\n        tail.next = head\n        return new_head\n```\n\n## complexity\ntime complexity O(n)\nspace complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921411925","body":"## thoughts\n遍历linkedlist，记住下下个node swap 自己和next，\n 和之前的相连，然后向下下个node转\n\n##code\n```python\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head == None or head.next == None:\n            return head\n\n        new_head = ListNode(0)\n        new_head.next = head\n\n        prev = new_head\n        current_node = prev.next\n        while current_node != None:\n            next_node = current_node.next\n            if next_node != None:\n                temp = next_node.next\n                next_node.next = current_node\n                prev.next = next_node\n                prev = current_node\n                current_node.next = temp\n                current_node = temp\n            else:\n                break\n\n        return new_head.next\n\n```\n\n## complexity\ntime complexity O(n)\nspace complexity O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922132180","body":"## thoughts \n每次找中点，左边作为左子树，右边是右子树，递归\n\n##code\n```\ndef find_mid_of_linked_list(head):\n    if not head or not head.next:\n        return head\n    dummy_head = ListNode(0, head)\n    slow = fast = dummy_head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    mid = slow.next\n    slow.next = None\n    return mid\n\n\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        mid = find_mid_of_linked_list(head)\n        if mid:\n            root = TreeNode(mid.val)\n            if head != mid:\n                root.left = self.sortedListToBST(head)\n            if mid.next:\n                root.right = self.sortedListToBST(mid.next)\n            return root\n        else:\n            return None\n```\n\n#complexity\ntime complexity O(nlgn)\n\nspace complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922380204","body":"## thoughts\nl两个指针，跑到a的尽头走b，走到b的尽头走a，走完a和b之后一定会会在节点相遇，如果第二遍走到尽头不相遇就是没有交点\n\n## code\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        l1, l2 = headA, headB\n        finish = False\n        while l1 != l2:\n            if l1.next is None and l2.next is None:\n                if finish:\n                    return None\n            if l1.next is None:\n                l1 = headB\n                finish = True\n            else:\n                l1 = l1.next\n            if l2.next is None:\n                l2 = headA\n            else:\n                l2 = l2.next\n        return l1\n\n```\n\n## complexity\ntime complexity O(m+n)\nspace complexity O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falconruo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916424749","body":"**思路:**\r\n1. 数组num的第1个元素num[0]表示整数的最高位数字, 第n个元素num[n - 1]代表整数的个位数字\r\n2. 新的整数的每一位数字由三个部分决定：num[i], 整数k的当前位(k % 10), 进位(carry)->sum = val + k % 10 + carry\r\n\r\n**复杂度分析:**\r\n- 时间复杂度: O(max(N, lgk))，N为数组num的长度, k为给定整数k\r\n- 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size() - 1;\r\n        vector<int> res;\r\n        int carry = 0, val = 0, sum = 0;\r\n        while (n >= 0 || k != 0) {\r\n            val = (n >= 0) ? num[n] : 0;\r\n            sum = val + k % 10 + carry;\r\n            res.push_back(sum % 10);\r\n            carry = sum / 10;\r\n            k /= 10;\r\n            n--;\r\n        }\r\n\r\n        if (carry)\r\n            res.push_back(carry);\r\n        \r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917118118","body":"**思路:**\r\n\r\n。从左到右依次遍历字符串S，比较每个字符与字符C的最短距离并存放到返回数组res中\r\n。从右到左依次遍历字符串S，比较每个字符与字符C的最短距离并与之前存放在数组res中的距离取小值\r\n\r\n**复杂度分析:**\r\n\r\n时间复杂度: O(n), n为字符串s的长度\r\n空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n\r\n```C++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n, n - 1);\r\n\r\n        int idx = n - 1;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (s[i] == c)\r\n                idx = i;\r\n            res[i] = min(res[i], abs(idx - i));\r\n        }\r\n\r\n        idx = 0;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            if (s[i] == c)\r\n                idx = i;\r\n            res[i] = min(res[i], abs(idx - i));\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917452191","body":"**思路:**\r\n1. 使用一个数组vector来模拟栈, 使用一个变量size表示栈的容量maxSize\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(k), k为给定长度, 其中push/pop: O(1)\r\n2. 空间复杂度: O(n), n为maxSize\r\n\r\n**代码(C++):**\r\n```C++\r\n语言： cpp\r\n\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        size = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (st.size() >= size) return;\r\n        st.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (st.size() == 0) return -1;\r\n        int val = st.back();\r\n        st.pop_back();\r\n        return (val);\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int idx = (k <= st.size()) ? k : st.size();\r\n\r\n        for (int i = 0; i < idx; ++i)\r\n            st[i] += val;\r\n    }\r\nprivate:\r\n    int size;\r\n    vector<int> st;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917712710","body":"**思路:**\r\n1. 使用辅助栈存放：\r\n- repeat次数\r\n- 临时子串\r\n- 子串\"[\"\r\n2. 遇到']', 连续出栈直至栈顶元素为\"[\", 将所有的字符串拼接在一起，存放在一个字符串tmp\r\n3. 将栈顶元素\"[\"出栈\r\n4. 继续取栈顶元素，此字符串为repeat次数k，将字符串tmp重复k次，存入新的子串ns并入栈\r\n5. 循环完毕依次将栈st的子串取出，按照顺序插入返回字符串res\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(m), m为给定字符串s长度\r\n2. 空间复杂度: O(n), n为decoded string长度\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res = \"\";\r\n        stack<string> st;\r\n        int n = s.length();\r\n\r\n        for (int i = 0; i < n; ++i) {\r\n            string tmp = \"\";\r\n            if (isalpha(s[i])) {\r\n                while (isalpha(s[i])) {\r\n                    tmp += s[i];\r\n                    ++i;\r\n                }\r\n                --i;\r\n                st.push(tmp);\r\n            } else if (isdigit(s[i])) {\r\n                while (isdigit(s[i])) {\r\n                    tmp += s[i];\r\n                    ++i;\r\n                }\r\n                --i;\r\n                st.push(tmp);\r\n            } else if (s[i] == '[') {\r\n                tmp += s[i];\r\n                st.push(tmp);\r\n            } else if (s[i] == ']') {\r\n                while (st.top() != \"[\") { // add other alpha string into new\r\n                    tmp.insert(0, st.top());\r\n                    st.pop();\r\n                }\r\n                st.pop(); // \"[\"\r\n\r\n                int k = stoi(st.top()); // k\r\n                st.pop();\r\n\r\n                string ns = \"\";\r\n                while (k--) // expand substring tmp by k times\r\n                    ns += tmp;\r\n                st.push(ns);\r\n            }\r\n        }\r\n\r\n        while (!st.empty()) {\r\n            res.insert(0, st.top());\r\n            st.pop();\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918445433","body":"**思路:**\r\n\r\n使用两个栈stack<int> s1, s2用于push, pop/peek\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(1)， 平均时间\r\n2. 空间复杂度: O(n), n为队列长度\r\n\r\n**代码(C++):**\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        while (!s2.empty()) {\r\n            s1.push(s2.top());\r\n            s2.pop();\r\n        }\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        while (!s1.empty()) {\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n        int val = s2.top();\r\n        s2.pop();\r\n        return val;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        while (!s1.empty()) {\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n        return s2.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s1.empty() && s2.empty();\r\n    }\r\nprivate:\r\n    stack<int> s1, s2;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919383249","body":"**思路:**\r\n\r\n方法一、\r\n滑动窗口法\r\n1. 使用一个辅助数组sorted，将数组arr排序后的放入数组sorted\r\n2. 对于一个有效的分块(chunk)，里面的数字之和是相等的，只是数字的顺序不同\r\n3. 使用滑动窗口同时从左向右扫描原数组arr和排序数组sorted,每次当两个窗口里的数字之和相等时，找到一个有效的块(chunk)\r\n\r\n方法二、\r\n利用单调队列(monotonic queue/stack)或单调栈来存放每个有效分块(Chunk)的最大值，遍历整个数组arr，比较当前数组元素与栈里元素的大小\r\n\r\n**复杂度分析:**\r\n方法一、\r\n1. 时间复杂度: O(nlogn), n为给定数组的元素个数\r\n2. 空间复杂度: O(n), n为给定数组的元素个数(辅助数组的长度)\r\n\r\n方法二、\r\n1. 时间复杂度: O(n), n为给定数组的元素个数\r\n2. 空间复杂度: O(n), n为给定数组的元素个数\r\n\r\n**代码(C++):**\r\n```C++\r\n\r\n方法一、\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        vector<int> sorted = arr;\r\n\r\n        sort(sorted.begin(), sorted.end()); // O(nlogn)\r\n\r\n        int chunks = 0;\r\n\r\n        long sum = 0, sorted_sum = 0;\r\n        for (int i = 0; i < arr.size(); ++i) { // O(n)\r\n            sum += arr[i];\r\n            sorted_sum += sorted[i];\r\n\r\n            if (sum == sorted_sum)\r\n                chunks++;\r\n        }\r\n\r\n        return chunks;\r\n    }\r\n};\r\n\r\n方法二、 使用辅助栈(数组)\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> s;\r\n\r\n        for (int i = 0;i < arr.size();i++) {\r\n            if (s.empty() || s.top() <= arr[i])\r\n                s.push(arr[i]);\r\n            else {\r\n                int max_val = s.top();\r\n\r\n                while (!s.empty() && s.top() > arr[i])\r\n                    s.pop();\r\n                s.push(max_val);\r\n            }\r\n        }\r\n\r\n        return s.size();\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920331566","body":"**思路:**\r\n\r\n将list向右旋转k步即为将list的头（head)向右移动 n - k步, 也就是新的头结点是第n - k个结点\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(n), n为给定链表长度\r\n2. 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n\r\n        if (!head || !head->next) return head;\r\n        int n = 1;\r\n\r\n        ListNode* p = head;\r\n        // get the length of list\r\n        while (p->next) {\r\n            p = p->next;\r\n            ++n;\r\n        }\r\n        // connect to a cycled list\r\n        p->next = head;\r\n\r\n        int left = n - k % n;\r\n\r\n        while (left--)\r\n            p = p->next;\r\n\r\n        head = p->next;\r\n        // break the cycle\r\n        p->next = nullptr;\r\n        \r\n        return head;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921125033","body":"**思路:**\r\n方法一、加入一个dummy节点，dummy->next指向head，遍历链表 (head && head->next):\r\n- 前置指针prev->next指向当前节点的后续节点（cur->next）\r\n- 当前指针curr->next指向当前节点的后续节点的next (curr->next->next)\r\n- 当前节点的后续节点的next(prev->next->next)指向当前节点curr\r\n- 向前移动前置指针prev和当前指针curr\r\n\r\n方法二、递归法\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(n), n为给定链表长度\r\n2. 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (!head || !head->next) return head;\r\n        \r\n        ListNode* dummy = new ListNode(-1);\r\n        dummy->next = head;\r\n        \r\n        ListNode *prev = dummy, *cur = head;\r\n        \r\n        while (cur && cur->next) {\r\n            prev->next = cur->next;\r\n            cur->next = cur->next->next;\r\n            prev->next->next = cur;\r\n\r\n            prev = cur;\r\n            cur = cur->next;\r\n        }\r\n        return dummy->next;\r\n    }\r\n};\r\n\r\n递归法\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (!head || !head->next) return head;\r\n\r\n        ListNode* p = head->next;\r\n        head->next = swapPairs(p->next);\r\n        p->next = head;\r\n        return p;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922020055","body":"**思路:**\r\n方法一、递归\r\n因为是升序递增的linked list, 使用快慢指针的方法每次取中间结点创建树的root结点,利用递归思路再分别处理左右子树(head -> slow, slow->next -> tail)\r\n\r\n方法二、模拟中序遍历\r\n1. 先遍历链表一遍计算出总的结点数len, 用两个指针l = 0, r = len\r\n2. 递归：\r\n\t- 每次取中间结点作为root = l + (r - l)/2\r\n\t- 先处理左子树(左半部分链表)\r\n\t- 生成根结点(head->val)\r\n\t- 移动head一步\r\n\t- 再处理右子树\r\n\r\n**复杂度分析:**\r\n方法一、\r\n1. 时间复杂度: O(nlogn), n为给定链表长度， 递归的部分会有logN次，每次会有快慢指针N/2次，因此总量N * longN\r\n2. 空间复杂度: O(logn), 递归栈，主要是递归用来存储栈的占用\r\n\r\n方法二、\r\n1. 时间复杂度: O(n), n为给定链表长度， 递归的复杂度只有logN，但我们要通过一次遍历链表查询长度，因此复杂度最高为N\r\n2. 空间复杂度: O(logn), 递归栈， 主要是递归用来存储栈的占用\r\n\r\n**代码(C++):**\r\n```C++\r\n方法一、递归\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\n方法一\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if (!head) return nullptr;\r\n        if (!head->next) {\r\n            TreeNode* node = new TreeNode(head->val);\r\n            return node;\r\n        }\r\n\r\n        ListNode* prev = nullptr;\r\n        ListNode* fast = head;\r\n        ListNode* slow = head;\r\n\r\n        // find the mid node of linked list\r\n        while (fast && fast->next) {\r\n            prev = slow;\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n\r\n        // break the linked list\r\n        prev->next = nullptr;\r\n\r\n        TreeNode* root = new TreeNode(slow->val);\r\n        root->left = sortedListToBST(head);\r\n        root->right = sortedListToBST(slow->next);\r\n\r\n        return root;\r\n    }\r\n};\r\n\r\n方法二、\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* head;\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if (!head) return nullptr;\r\n        if (!head->next) {\r\n            TreeNode* node = new TreeNode(head->val);\r\n            return node;\r\n        }\r\n\r\n        cur = head;\r\n        int len = 0;\r\n        while (cur) {\r\n            ++len;\r\n            cur = cur->next;\r\n        }\r\n\r\n        cur = head;\r\n        return buildTree(0, len);\r\n    }\r\nprivate:\r\n    ListNode* cur;\r\n\r\n    TreeNode* buildTree(int l, int r) {\r\n        if (l > r || !cur) return nullptr;\r\n        \r\n        int m = l + (r - l)/2;\r\n        TreeNode* lf = buildTree(l, m - 1);\r\n\r\n        TreeNode* root = new TreeNode(cur->val);\r\n        cur = cur->next;\r\n        root->left = lf;\r\n        root->right = buildTree(m + 1, r);\r\n        \r\n        return root;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922359431","body":"**思路:**\r\n比较两个链表是否有交叉结点，定义两个指针p, q分别指向headA, headB\r\n1. 首先计算每个链表的结点个数，存入变量lenA, lenB，如果任意一个链表为空则无交叉，返回nullptr\r\n2. 令p指向结点数多的链表, q指向结点数少的链表, 令两个链表的长度差为diff\r\n    - 首先移动长的链表直至diff为0\r\n    - 同时移动两个链表，并判断结点是否相等，相等则说明是交叉结点并返回当前结点，不等则继续指向下一个结点，直至表尾\r\n3. 如果没有交叉(intersection)返回nullptr\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(n + m), n, m为给定链表A和B长度\r\n2. 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode *pA = headA, *pB = headB;\r\n        while(pA != pB){\r\n            pA = pA ? pA->next : headB;\r\n            pB = pB ? pB->next : headA;\r\n        }\r\n        return pA;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922527345","body":"**思路:**\r\n利用两个指针slow、fast，快(fast)指针走两步，慢(slow)指针走一步。\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(n), n为结点数\r\n2. 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        if (!head || !head->next) return nullptr;\r\n\r\n        ListNode *fast = head, *slow = head;\r\n\r\n        while (fast && fast->next) {\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n\r\n            if (fast == slow)\r\n                break;\r\n        }\r\n\r\n        if (!fast || !fast->next) return nullptr;\r\n\r\n        fast = head;\r\n\r\n        while (fast != slow) {\r\n            fast = fast->next;\r\n            slow = slow->next;\r\n        }\r\n        return fast;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"florenzliu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916425383","body":"**Explanation**\r\n\r\n- Convert k to its array-form. \r\n- Add the array-forms of num and k by digit from the end to the beginning and save it in the result array. \r\n- Reverse the array-form of the result. \r\n\r\nUse the quotient and remainder divided by 10: set the current position as the remainder and update the quotient for the next position.\r\n\r\n**Python**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        newK = []\r\n        for i in str(k):\r\n            newK.append(int(i))\r\n        \r\n        result = []\r\n        i, j = len(num)-1, len(newK)-1\r\n        quotient, remainder = 0, 0\r\n        while i >= 0 or j >= 0:\r\n            currI = num[i] if i >= 0 else 0\r\n            currJ = newK[j] if j >= 0 else 0\r\n            curr = currI + currJ + quotient\r\n            result.append(curr % 10)\r\n            quotient = curr // 10\r\n            i -= 1\r\n            j -= 1\r\n            \r\n        if quotient != 0:\r\n            result.append(quotient)\r\n        return result[::-1]\r\n```\r\n\r\n**Complexity**\r\n\r\n- Time Complexity: ```O(max(N, logk))``` where N is the length of the ```num``` array.\r\n- Space Complexity: ```O(max(N, logk))``` \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917364782","body":"**Explanation**\n- Traverse from left. Find the shortest distance to a character from the left.\n- Traverse from right. Find the shortest distance to a character from the right.\n- Take the minimum of the two values to create the final answer \n\n**Python**\n\n```python\nclass Solution:\n    def shortestToChar(self, S: str, C: str) -> List[int]:\n        result = [math.inf for _ in range(len(S))]\n        \n        # traverse from left\n        curr = -math.inf\n        for i in range(len(S)):\n            if S[i] == C:\n                curr = i\n            result[i] = i - curr\n            \n        # traverse from right\n        curr = math.inf\n        for i in range(len(S)-1, -1, -1):\n            if S[i] == C:\n                curr = i\n            result[i] = min(curr-i, result[i])\n            \n        return result\n```\n\n**Complexity**\n\n- Time Complexity: ```O(N)``` where ```N``` is the length of the string ```S```.\n- Space Complexity: ```O(N)``` \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917552803","body":"**Explanation**\n- Use a list as a stack. Use count to keep a record of the number of elements in the stack. Use maxSize to remember max size.\n- ```push```: if stack has not reached maxSize, add the element to the end of the stack and update the count by +1.\n- ```pop```: if stack is not empty, pop the last element of the stack and update the count by -1. Otherwise, return -1\n- ```increment```: add ```val``` to the first k elements or the whole stack (if count < k)\n\n**Python**\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.count = 0\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if self.count < self.maxSize:\n            self.stack.append(x)\n            self.count += 1\n\n    def pop(self) -> int:\n        if self.count > 0:\n            self.count -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.count)):\n            self.stack[i] = self.stack[i] + val\n            \n        return result\n```\n\n**Complexity**\n\n- Time Complexity: ```O(1)``` for push and pop operations;  ```O(min(k, count))``` for increment operations where ```count``` is the length of the stack.\n- Space Complexity: ```O(1)``` \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917858833","body":"**Explanation**\n- Use a stack to keep track of the traversed string in the square bracket and its repeated times.\n- When encountering ']', pop the elements from the stack to compose the current traversed string in the current square bracket, and continue to pop in order to find its repeated times. Compose the current string and add it back to the stack.\n- Join all the strings in the stack to return the final decoded string\n\n**Python**\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for ch in s:\n            if ch == \"]\":\n                curr = \"\"\n                while stack[-1] != \"[\":\n                    curr = stack.pop() + curr\n                stack.pop()\n                num = \"\"\n                while stack and stack[-1].isdigit():\n                    num = stack.pop() + num\n                currStr = curr * int(num)\n                stack.append(currStr)\n            else:\n                stack.append(ch)    \n        return \"\".join(stack)\n```\n\n**Complexity**\n\n- Time Complexity: ```O(N)``` \n- Space Complexity: ```O(N)``` \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918652442","body":"**Explanation**\r\n- Use stack 1 to keep the newly added element (push)\r\n- Use stack 2 to store the current elements of stack 1 in the reverse order, i.e., the sequence of queue elements (pop)\r\n- The last element in the stack 1 will be the last element in the queue.\r\n- The last element in the stack 2 will be the first element in the queue. \r\n\r\n**Python**\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.st1 = [] # keep the newly added element on top of stack 1\r\n        self.st2 = []        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.st1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.st2:\r\n            while self.st1:\r\n                self.st2.append(self.st1.pop())\r\n        return self.st2.pop()\r\n  \r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"        \r\n        if self.st2:\r\n            return self.st2[-1]\r\n        return self.st1[0]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.st1 and not self.st2\r\n```\r\n\r\n**Complexity**\r\n|                  | push | pop | peek | empty |\r\n|----------------- | ----| ---- | -----| ----- |\r\n| Time Complexity | O(1) | amortized O(1), worst-case O(n) | O(1) | O(1) |\r\n| Space Complexity | O(n) | O(1) | O(1) | O(1) |","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919643750","body":"**Explanation**\n- Use a monotonically increasing stack to save the largest value in each partitioned chunk.\n- When encountering a smaller element, pop out the elements in the stack until the last one is smaller than the current element. Otherwise, add it to the stack.\n- Return the length of the stack as the final answer.\n\n**Python**\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:        \n        stack = []\n        for i in range(len(arr)):\n            if stack and stack[-1] > arr[i]:\n                curr = stack[-1]\n                while stack and stack[-1] > arr[i]:\n                    stack.pop()\n                stack.append(curr)\n            else:\n                stack.append(arr[i])\n                \n        return len(stack)\n```\n\n**Complexity**\n\n- Time Complexity: ```O(N)``` \n- Space Complexity: ```O(N)``` \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920341426","body":"**Explanation**\n- Base case is when the linked list has no node or 1 node.\n- Traverse the linked list and get its length ```l``` and its last element ```oldTail```.\n- The newTail is the ```(l - k % l - 1)th``` node.\n- The newHead is the ```(l - k % l)th``` node.\n- Break the link between newTail and newHead and link the oldTail to head to get the new linked list. \n\n**Python**\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:        \n        # base case\n        if not head or not head.next:\n            return head\n        \n        oldTail = head\n        l = 1\n        while oldTail.next:\n            oldTail = oldTail.next\n            l += 1\n        oldTail.next = head\n        \n        # new tail: l - k % l - 1\n        # new head: l - k % l         \n        newTail = head\n        for i in range(l - k % l - 1):\n            newTail = newTail.next\n        \n        newHead = newTail.next\n        newTail.next = None\n        \n        return newHead\n```\n\n**Complexity**\n\n- Time Complexity: ```O(N)``` \n- Space Complexity: ```O(1)``` \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921512760","body":"**Explanation**\n- Break the linked list into pairs by jumping in steps of two.\n- Swap the nodes by implementing ```prev``` and ```curr``` nodes: \n  - prev.next = curr.next\n  - curr.next = curr.next.next\n  - finally, prev.next.next = curr\n- Update the ```prev``` and ```curr``` nodes to the next node pair\n\n**Python**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        sentinel = ListNode()\n        sentinel.next = head\n        \n        prev = sentinel\n        curr = head\n        while curr and curr.next:\n            # swap the next 2 nodes\n            prev.next = curr.next\n            curr.next = curr.next.next\n            prev.next.next = curr\n            # update prev and curr nodes\n            prev = curr\n            curr = curr.next\n        \n        return sentinel.next\n```\n\n**Complexity**\n\n- Time Complexity: ```O(N)``` where ```N``` is the size of the linked list\n- Space Complexity: ```O(1)``` \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922187678","body":"**Explanation**\n- Iterate over the linked list to find its length\n- Simulate the inorder traversal by using the mid point, i.e. (start + end) / 2.\n- Recurse on the left half, process the current head value, progress the head node to the next node, and then recurse on the right half.\n\n**Python**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        # inorder simulation\n        # find size\n        size = 0\n        curr = head\n        while curr:\n            size += 1\n            curr = curr.next\n            \n        def helper(start, end):   \n            nonlocal head\n            if start > end:\n                return None\n            mid = (start + end) // 2\n            left = helper(start, mid-1)\n            \n            node = TreeNode(head.val)\n            node.left = left\n            \n            head = head.next\n            \n            right = helper(mid+1, end)\n            node.right = right\n            \n            return node\n        \n        return helper(0, size-1)\n```\n\n**Complexity**\n\n- Time Complexity: ```O(N)``` where ```N``` is the size of the linked list\n- Space Complexity: ```O(logN)``` since the height of the height-balanced BST is bounded by logN\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922419664","body":"**Explanation**\n- While list A and list B could be of different lengths, the shared \"tail\" following the intersection has to be the same length\n- Use two pointers to step through the two lists together\n  - one is starting at the shorter list and then continue with the longer list\n  - one is starting at the longer list and then continue with the shorter list\n- The intersection node is where the two pointers point to the same value at the first time.\n\n**Python**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        pointerA, pointerB = headA, headB\n        \n        while pointerA != pointerB:\n            \n            pointerA = pointerA.next if pointerA else headB\n            pointerB = pointerB.next if pointerB else headA\n            \n        return pointerA\n```\n\n**Complexity**\n\n- Time Complexity: ```O(M + N)``` where ```M``` is the size of the linked list A and ```N``` is the size of the linked list B\n- Space Complexity: ```O(1)``` ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916426832","body":"## Ripple Adder\r\nSimilar to the implementation of ripple adder, The adder will add numbers at the same position, output the sum of the current position, and pass the carry to the next bit.\r\n \r\n## Python\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], k: int) -> List[int]:\r\n        curSum = 0\r\n        carry = 0\r\n\r\n        # This can be achieved through continuing division, but I am lazy\r\n        if not A:\r\n            return [int(i) for i in str(k)]\r\n        elif not k:\r\n            return A\r\n\r\n        K = [int(i) for i in str(k)]\r\n        LA = len(A)-1\r\n        LK = len(K)-1\r\n\r\n        if LA <= LK:\r\n            target = K\r\n            idx = LK\r\n        else:\r\n            target = A\r\n            idx = LA\r\n        while LA >= 0 and LK >= 0:\r\n            curSum = A[LA] + K[LK] + carry\r\n            if curSum < 10:\r\n                target[idx] = curSum\r\n                carry = 0\r\n            else:\r\n                carry = curSum //10\r\n                target[idx] = curSum % 10\r\n            LA-=1\r\n            LK-=1\r\n            idx-=1\r\n        if LK != LA:\r\n            while idx >=0:\r\n                curSum = target[idx] + carry\r\n                if curSum < 10:\r\n                    target[idx] = curSum\r\n                    carry = 0\r\n                else:\r\n                    carry = curSum // 10\r\n                    target[idx] = curSum%10\r\n                idx-=1\r\n        if carry > 0:\r\n            target[0:0] = [carry]\r\n        return target\r\n```\r\n\r\nTime Complexity: O(max(K,A))\r\nSpace Complexity: O(max(K,A))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917027536","body":"## Thought\r\nTraverse the array twice, one time we traverse from left to right, the second time we traverse from the back. In the first iteration, we record a temporary variable for the index where `s[i] == c`, then we can know all the distance of a character with a `c` character behind it.  Then in the opposite direction, we determine if a `c`  on the left side or on the right side is the closest for it.\r\n\r\n## python\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        N = len(s)\r\n        ans = [100000] * N\r\n        closeLoc = -100000\r\n        for i in range(N):\r\n            if s[i] == c:\r\n                closeLoc = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(i-closeLoc, ans[i])\r\n        \r\n        closeLoc = 100000\r\n        for i in range(N-1, -1, -1):\r\n            if s[i] == c:\r\n                closeLoc = i\r\n            else:\r\n                ans[i] = min(closeLoc-i, ans[i])\r\n        \r\n        return and\r\n```\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917451093","body":"## Thought\r\n模拟题\r\n## Python\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.size = 0\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size:\r\n            self.size -=1\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n    def increment(self, k: int, val: int) -> None:\r\n        k = min(k,self.size)\r\n        for i in range(k):\r\n            self.stack[i] += val\r\n```\r\n\r\nTime Complexity: push, pop: O(1) increment: O(min(k,size))\r\nSpace Complexity: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917777695","body":"## Thought\r\n这道题因为有“[”“]”, 所以我第一时间想到的是用stack（LIFO）。 我们能遍历整个字符串来看如何处理每个字符\r\n1. 如果当前字符为任意数字，我们便能添加当前数字进入一个叫`count `的字符串内\r\n2. 如果当前字符为任意字母，我们便能添加当前字母进入以及个叫`ans`的字符串内\r\n3. 如果当前字符为\"[\"，我们便需要把当前`count`和`ans`入栈，这里入栈是因为`ans`代表了当前'['外层我们想要的字符串，count则表示`[`内层需要重复的次数。入栈后当前`ans`和`count`清空\r\n4. 如果当前字符为\"]\", 我们则出栈得到\"[\" 之前的原ans+重复次数，让`ans`更新为原ans+重复次数*`ans`\r\n\r\n##Python\r\n```Python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        ans = \"\"\r\n        count = \"\"\r\n\r\n        for char in s:\r\n            if \"0\" <= char <= \"9\":\r\n                count += char\r\n            elif \"a\" <= char <= \"z\":\r\n                ans += char\r\n            elif char == \"]\":\r\n                pair = stack.pop()\r\n                ans = pair[1]+ int(pair[0])*ans\r\n                #count = \"\"\r\n            elif char == \"[\":\r\n                stack.append((count, ans))\r\n                count = \"\"\r\n                ans = \"\"\r\n        return ans\r\n``` \r\nTime Complexity: O(n) 遍历整个字符串\r\nSpace complexity: O(n) 最多有可能创建一个 n 长度的stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918734174","body":"## Thought\r\n使用两个栈，一个用于记录所有的入栈，一个记录所有的出栈，这样就能达到amortized O(1) 时间\r\n\r\n```Python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack.pop()\r\n        else:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n            if self.outStack:\r\n                return self.outStack.pop()\r\n            else:\r\n                return -1\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack[-1]\r\n        else:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n            if self.outStack:\r\n                return self.outStack[-1]\r\n            else:\r\n                return -1\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.inStack and not self.outStack\r\n``` \r\n时间：push，empty O(1), pop, peek amortized O(1)\r\n空间： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919679571","body":"今天有点忙，明天补上细节\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        i = 0\r\n        stack = []\r\n        while i < len(arr):\r\n            # arr[i] has no impact on the block\r\n            if (not stack) or (arr[i] >= stack[-1]):\r\n                stack.append(arr[i])\r\n            # arr[i] has impact\r\n            elif stack and arr[i] < stack[-1]:\r\n                head = stack.pop()\r\n                # determine where does this arr[i] will impact\r\n                # this will ends when arr[i] >= stack[-1]: which means no further impact\r\n                while stack and arr[i] < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            i += 1\r\n\r\n        return len(stack)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920274865","body":"## Thought\r\n这道题很直观，先算出总长度count，再使用快慢指针找到倒数的第k%count的数字，本质上rotate就是让这个数字变成head并链接上之前的list。有一些edge case 需要考虑\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        # rotating by k means to take the kth (reversed) element and links its to the beginnng\r\n        count = 0\r\n        cur = head\r\n        while cur:\r\n            cur = cur.next\r\n            count+=1\r\n\r\n        if count:\r\n            k = k%count\r\n\r\n        if k == 0 or not head:\r\n            return head\r\n\r\n        fast = slow = head\r\n        prev = None\r\n        while k > 1:\r\n            fast = fast.next\r\n            k-=1\r\n        \r\n        while fast and fast.next and slow and slow.next:\r\n            fast = fast.next\r\n            prev = slow\r\n            slow = slow.next\r\n        \r\n        if prev:\r\n            prev.next = None\r\n        fast.next = head\r\n        return slow\r\n\r\n```\r\n\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921223724","body":"## Thought\r\n这道题很直观，只需要每次考虑当前正在交换的pair就行。会有特例，当前pair 右node为空。\r\n\r\n## Python\r\n```python\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n        \r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        l = head\r\n        prev = dummy = ListNode()\r\n        if head and head.next:\r\n            r = head.next\r\n        else:\r\n            return head\r\n        \r\n        rr = r.next\r\n\r\n        while l and r:\r\n            r.next = l\r\n            l.next = rr\r\n            prev.next = r\r\n\r\n            prev = l\r\n            l = rr\r\n            if l and l.next:\r\n                r = l.next\r\n                rr = r.next\r\n            else:\r\n                r = None\r\n        return dummy.next\r\n```\r\n\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922183640","body":"先打卡，白天补上细节\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:        \r\n        if not head:\r\n            return None\r\n        fast = slow = head\r\n        preSlow = None\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            preSlow = slow\r\n            slow = slow.next\r\n\r\n        root = TreeNode(slow.val)\r\n        if preSlow:\r\n            preSlow.next = None\r\n            root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922408305","body":"\r\n只说为什么 `while a != b` 因为遍历到最后 一定会是`None == None` 情况\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a = headA\r\n        b = headB\r\n        while a != b:\r\n            if a:\r\n                a = a.next\r\n            else:\r\n                a = headB\r\n            if b:\r\n                b = b.next\r\n            else:\r\n                b = headA\r\n        # if not a or not b:\r\n        #     return None\r\n        return a\r\n```\r\nTime: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZhuMengCheng":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916429301","body":"思路:\r\n从末尾相加后截取末尾存储进位,, 测试用例: [2,1,5]  806  \r\n 比如806和5相加等于811 ,保存末尾1,\r\n继续相加为81+1=82. 保存2 类推,\r\n 8会和下一个2相加为10,  \r\n整个数组的值变成[10,2,1] 截取10的情况,可能计算次数超过数组长度.需要添加额外条件判断计算次数\r\n`/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let res = []\r\n    // k>0 如果遇到合为10需要多一次计算 ,查询条件不能限制为只有num数组的长度\r\n    for(let i = num.length-1 ;i>=0 || k > 0;--i){\r\n        // 大于0的位数直接相加后取余数进位\r\n        if(i >= 0){\r\n            k += num[i]\r\n        }\r\n        res.push(k % 10)\r\n        // 计算是否有等于10 或者大于0的情况,在执行下次进位\r\n        k  =   (k - k  % 10) / 10\r\n    }\r\n    return res.reverse()\r\n}`\r\n\r\n时间复杂度：O(max(n,log k))\r\n空间复杂度:  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917405227","body":"思路: \n首先第一次循环找到所有目标元素的下标,第二次循环从头再次循环找到所有非目标元素和目标元素的下标差值.取绝对值并循环.因为索引数组indexList的值一直在增加.找到索引大于非目标元素下标的差值.循环IndexList并计算出最小值.\n```javascript\nvar shortestToChar = function(str, target) {\n    const indexList = []\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] == target) {\n            indexList.push(i)\n        }\n    }\n    const result = Array.from(str.length).fill('-1')\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] == target) {\n            result.push(0)\n            continue;\n        }\n        for (let k = 0; k < indexList.length; k++) {\n            const targetIndex = Math.abs(indexList[k] - i);\n            if (targetIndex >= result[i]) break;\n            result[i] = targetIndex;\n        }\n    }\n    return result\n};\n```\n时间复杂度:O(str*Target)\n空间复杂度:O(Target)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917795142","body":"# 思路两个栈存储倍数和需要翻倍的字符.判断[]位置翻倍存储当前字符..翻倍所有字符后拼接返回完整字符\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n    let num = 0;\n    let numStock = []\n    let resultStock = []\n    let result = ''\n    for (let str in s) {\n        if (!isNaN(s[str])) {\n            num = num * 10 + Number(s[str])\n        } else if (s[str] == '[') {\n            resultStock.push(result);\n            result = '';\n            numStock.push(num)\n            num = 0;\n        } else if (s[str] == ']') {\n            let copyNum = numStock.pop();\n            result = resultStock.pop() + result.repeat(copyNum);\n        } else {\n            result += s[str]\n        }\n    }\n    return result\n};\nconsole.log(decodeString('3[a]2[bc]'))\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918886975","body":"```javascript\r\n// 双栈 初始化获取到数组\r\nvar MyQueue = function () {\r\n    this.inStack = [];\r\n    this.outStack = [];\r\n};\r\n// 添加元素\r\nMyQueue.prototype.push = function (x) {\r\n    this.inStack.push(x)\r\n};\r\n// 移除数组最后一个元素并取值\r\nMyQueue.prototype.pop = function () {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack.pop();\r\n};\r\n// 返回队列开头元素  数组从后往前算\r\nMyQueue.prototype.peek = function () {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack[this.outStack.length - 1];\r\n}\r\n// 判断数组长度\r\nMyQueue.prototype.empty = function () {\r\n    return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\nMyQueue.prototype.in2out = function () {\r\n    while (this.inStack.length) {\r\n        this.outStack.push(this.inStack.pop());\r\n    }\r\n}\r\n```\r\n时间复杂度: O(1)\r\n空间复杂度: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920628112","body":"```javascript\r\nvar rotateRight = function (head, k) {\r\n    // 如果是空的,返回本身\r\n    if (!head) {\r\n        return head\r\n    }\r\n    let n = 1;\r\n    let cur = head;\r\n    // 计算链表长度\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        n++;\r\n    }\r\n    // 超过链表长度会重复操作  计算一次移动的最短距离\r\n    let add = n - k % n;\r\n    // 把链表看成一个环\r\n    if (add === n) {\r\n        return head;\r\n    }\r\n    cur.next = head;\r\n    // 开始替换\r\n    while (add) {\r\n        cur = cur.next;\r\n        add--;\r\n    }\r\n    const ret = cur.next;\r\n    cur.next = null;\r\n    // 返回替换的位置后的值\r\n    return ret;\r\n};\r\n```\r\n// 时间复杂度:O(N)\r\n// 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921700788","body":"两两替换前后\n```javascript\nvar swapPairs = function (head) {\n    if (head === null || head.next === null) {\n        return head;\n    }\n    // 当前的链表下一个,替换成上一个.\n    const newHead = head.next;\n    // 递归替换 每两个一组替换\n    head.next = swapPairs(newHead.next);\n    newHead.next = head;\n    return newHead;\n};\n```\n时间复杂度:O(N)\n空间复杂度:O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lllouiselao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916434574","body":"[989. Add to Array-Form of Integer](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n#### 想法：最brutal way： traverse list->str->int->list \n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        str_turple = ''\n        for i in num:\n            str_turple += str(i)\n\n        str_int = int(str_turple) + k\n        int_str = str(str_int)\n\n        output = []\n        for n in int_str:\n            output.append(int(n))\n        return output\n```\n#### complexcity O(n^2) ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917574208","body":"[1381. Design a Stack With Increment Operation](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n#### 想法：设计一个栈 用list的方式来实现 \r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack_len = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.stack_len < self.maxSize:\r\n            self.stack.append(x)\r\n            self.stack_len +=1\r\n\r\n    def pop(self) -> int:\r\n        if self.stack_len == 0:\r\n            return -1\r\n        else:\r\n            self.stack_len -= 1\r\n            item = self.stack[self.stack_len]\r\n            del self.stack[self.stack_len]\r\n            return item\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(self.stack_len):\r\n            if i < k:\r\n                self.stack[i] = self.stack[i] + val\r\n            else:\r\n                return\r\n```\r\n\r\n#### complexcity pop:O(1) Push:O(1) increment:O(min(k, stack_len))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918319030","body":"* DAY4\n[394. Decode String](https://leetcode-cn.com/problems/decode-string/)\n#### thoughts: think about -> [20. Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses/) but didn't know how to touch on this, still didn't familiar with how stack work\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        num_stack = []  \n        num_val = 0\n        result = \"\"  \n        for ele in s:\n            if ele.isdigit():\n                num_val = num_val * 10 + int(ele)\n            elif ele == \"[\":\n                num_stack.append([result, num_val])\n                result, num_val = \"\", 0\n            elif ele == \"]\":\n                top = num_stack.pop()\n                result = top[0] + result * top[1]\n            else:\n                result += ele\n        return result\n```\n#### Complexcity O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922460695","body":"```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        p1 = headA\r\n        p2 = headB\r\n        while p1 != p2:\r\n            if p1 == None:\r\n                p1 = headB\r\n            else:\r\n                p1 = p1.next\r\n            if p2 == None:\r\n                p2 = headA\r\n            else:\r\n                p2 = p2.next\r\n        return p1\r\n```\r\nComplexity: O(m)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen445":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916452724","body":"### 思路: \n\nFirst, we should convert k to list and iterate from back of the list. If the sum of two digits at the same position plus carry is greater than 10, then we set the carry to 1. The modulo of the sum is the result at that position. \n\n### 代码：\n```\n  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        k=[int(x) for x in str(k)]\n        i=len(num)-1\n        j=len(k)-1\n        carry=0\n        result=deque([])\n        while i>=0 or j>=0:\n            a=num[i] if i >=0 else 0 \n            b=k[j] if j>=0 else 0\n            s=a+b+carry\n            carry=s//10\n            result.appendleft(s%10)\n            i-=1\n            j-=1\n        if carry != 0:\n            result.appendleft(carry)\n        return result\n```\n**复杂度分析**\n\nTime Complexity: O(n) n is the largest length of two numbers\n\nSpace Complexity: O(n) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917311617","body":"### 思路\r\nBefore the loop we need two variables prev(keep track the most recent index of c ) and j (everything before j in s has been calculated). We iterate from 0 to the end, if we found current index is c, we keep calculating min distance until j reach current index. We also update the prev.  \r\n\r\n### 代码\r\n```\r\ndef shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result=[-1]*len(s)\r\n        j=0\r\n        prev=None\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                while j<=i:\r\n                    if prev is not None:\r\n                        min_dis = abs(prev-j)\r\n                    else:\r\n                        min_dis = float('inf')\r\n                    min_dis=min(abs(j-i),min_dis)\r\n                    result[j]=min_dis\r\n                    j+=1\r\n                prev=i\r\n        while j < len(s):\r\n            result[j]=abs(prev-j)\r\n            j+=1\r\n        return result \r\n```\r\n### 复杂度\r\nTime: O(n) n is the length of s\r\nSpace: O(1) \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917546048","body":"### 思路\nusing array to implement stack\n\n### 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack=[]\n        self.size_limit=maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.size_limit:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        return -1\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n ```    \n***复杂度***\n\nT: O(1)\n\nS: O(n) n is the length of stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917820792","body":"### 思路\r\n\r\nusing stack to keep track result, iterate each element into stack, if you see \"]\", start to pop until you see the \"[\".\r\n### 代码\r\n``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[]\r\n        for e in s:\r\n            if e==\"]\":\r\n                temp=[]\r\n                while stack[-1] != \"[\":\r\n                    temp.append(stack.pop())\r\n                stack.pop()\r\n                count=0\r\n                order=1\r\n                while stack and stack[-1].isnumeric():\r\n                    count+=int(stack.pop())*order\r\n                    order*=10\r\n                for i in range (count):\r\n                    stack.extend(temp[::-1])\r\n            else:\r\n                stack.append(e)\r\n        return \"\".join(stack)\r\n            \r\n```\r\n\r\n### 复杂度\r\nT: O(n)\r\nS: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918776856","body":"### 思路\r\nWe used two stacks. Stack1 is used for store elements that has been pushed and stack 2 stored elements in queue order. \r\n### 代码\r\n``` python3\r\nclass MyQueue:\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1=[]\r\n        self.stack2=[]\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack1.append(x)\r\n      \r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n       \r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.stack2:\r\n            return self.stack2[-1]\r\n        else:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.stack1 and not self.stack2\r\n```\r\n### 复杂度分析\r\nT: push->O(1), pop->O(n),peek->O(n), empty->O(1)\r\nS: O(n) n is the number of elements in the queue \r\n       ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919776849","body":"### 思路\r\nWe used hash_map to keep track the value we needed for a chunk. Stack is the value that we haven't been add it hashmap.\r\n### 代码\r\n\r\n``` python3\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        result=0\r\n        stack=arr.copy()\r\n        stack.sort()\r\n        stack=stack[::-1]\r\n        values_need=dict()\r\n        for num in arr:     \r\n            if not stack or num < stack[-1]:\r\n                values_need[num]-=1\r\n                if values_need[num]==0:\r\n                    del values_need[num]\r\n                if len(values_need)==0:\r\n                    result+=1\r\n            elif num> stack[-1]:\r\n                while num > stack[-1]:\r\n                    top=stack.pop()\r\n                    if top not in values_need:\r\n                        values_need[top]=1\r\n                    else:\r\n                        values_need[top]+=1\r\n                stack.pop()\r\n            else:\r\n                if not values_need:\r\n                    result+=1 \r\n                stack.pop()\r\n        return result\r\n```\r\n### 复杂度\r\nT: O(nlogn) sorting the arr takes nlogn\r\n\r\nS: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920593805","body":"### 思路\n1. Connect the tail to the head and count number of nodes\n2. Calculate the new tail position n-k%n-1, new head is the next element of new tail \n3. Disconnect new head and new tail, and return new tail\n\n### 代码\n``` python\n def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return None\n        count=0\n        current=head\n        while current:\n            tail=current\n            count+=1\n            current=current.next\n        tail.next=head\n        new_tail=count-k%count-1\n        current=head \n        for i in range(new_tail):\n            current=current.next\n        new_head=current.next\n        current.next=None\n        return new_head\n        \n ```\n### 复杂度\nTime: O(n) n is the number of node\n\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921577850","body":"### 思路\n\niterative version: We initialize the two pointers to first two nodes.  We process the first two nodes, and we move to the two pointers to next two nodes until we hit the last node or None.\n\nrecursion version: The base case is we have a single node or node is None, we just return it. Otherwise, we swap the pointer for the first two nodes, and we recursively call the function with the third node being the head. \n### 代码\n\nRecursion:\n```python3\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or head.next is None:\n            return head\n        current=head.next\n        head.next=self.swapPairs(current.next)\n        current.next=head\n        return current\n```\n\nIterative:\n```python3\n class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or head.next is None:\n            return head\n        new_head=head.next\n        prev=ListNode(0)\n        while head and head.next:\n            current=head.next\n            head.next=current.next\n            current.next=head\n            prev.next=current\n            head=head.next\n            prev=current.next\n        return new_head\n```\n\n### 复杂度\n\niterative:\nTime: O(n)\nSpace: O(1)\n\nrecursion:\nTime:O(n)\nSpace:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922123784","body":"### 思路\nsolution1: We convert linked list to an array, and find the middle node as the root. We can recursively calling itself to build BST.\n\nsolution2: We can use two pointers to find the middle node as the root. We recursively process left subtree and right subtree.\n\n### 代码\n\nsolution 1:\n``` python3\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        result=[]\n        while head:\n            result.append(head.val)\n            head=head.next\n        return self.binary_search_tree(result,0,len(result)-1)\n    def binary_search_tree(self,arr,start,end):\n        if start > end:\n            return None\n        middle=start+(end-start)//2\n        root=TreeNode(arr[middle])\n        root.left=self.binary_search_tree(arr,start,middle-1)\n        root.right=self.binary_search_tree(arr,middle+1,end)\n        return root\n```\nsolution2:\n``` python3\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        dummy=ListNode(0)\n        dummy.next=head\n        slow, fast = dummy,head\n        while fast and fast.next:\n            slow=slow.next\n            fast=fast.next.next\n        root=TreeNode(slow.next.val)\n        root.right=self.sortedListToBST(slow.next.next)\n        slow.next=None\n        root.left =self.sortedListToBST(head)\n        return root\n```\n### 复杂度\nSolution 1:\n* Time: O(n) n is the number of nodes\n* Space: O(n) \n\nSolution 2:\n* Time: O(nlogN) \n* Space: O(logN)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922420781","body":"### 思路\nSolution 1: Iterate from linked lists A and add the nodes to the set. Then, we iterate from linked list B, if the node is already in the set then the node is the intersection.\n\nSolution 2: We have two pointers, one starts at LinkedList A and the other one starts from LInkedList B. In each iteration we advance pointer A and pointer B. Whenever one of them reaches the end, the pointer starts from other linked list head. Iteration ends when two pointers are equal.\n\n### 代码\nSolution 1\n```python3\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        visited=set()\n        while headA:\n            visited.add(headA)\n            headA=headA.next\n        while headB:\n            if headB in visited:\n                return headB\n            headB=headB.next\n        return None\n```\nSolution 2\n```python3\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a=headA\n        b=headB\n        while a!=b:\n            a=headB if a is None else a.next\n            b=headA if b is None else b.next\n        return a\n```\n### 复杂度\n#### Solution 1\n* Time: O(n) n is the number of nodes\n* Space: O(n) n is the number of nodes for LinkedList A\n\n#### Solution 2\n* Time: O(n) n is the number of nodes\n* Space:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JachinM":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916481597","body":"## Java\n#### 解题思路\n+ 整型数组开始与k相应的位上的数字相加（从个位开始，整型数组的个位是num[num.length-1]），并将每位上相加的结果添加到一个整型的Array数组中。\n+ 这里需要注意如果相对应位置上的数相加大于10时，我们应该有进位操作，即 让k+1，number-10（ps：这里的number代表整型数组与k的相应位置上的数相加后得到的结果）\n+ 最后如果k>0,这说明最高位上有进位，最后得到的数组少最高位，我们应该再把k的每个位置的数取出来加入到数组中。\n+ 由于低数位先加入我们最终得到的Array数组中，所以我们需要翻转一下得到的数组，在java中可以调用Collections.reverse()函数来实现。\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        List<Integer> resultList = new ArrayList<>();\n        int sum =0;\n        for(int i=len-1;i>=0;i--){\n            sum = num[i]+k%10;\n            k=k/10;\n            if(sum>=10){\n                k++;\n                sum-=10;\n            }\n            resultList.add(sum);\n        }\n        while(k>0){\n            resultList.add(k%10);\n            k=k/10;\n        }\n        Collections.reverse(resultList);\n        return resultList;\n    }\n}\n```\n#### 时间复杂度\nO(n)\n#### 空间复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917427381","body":"## Java\n#### 解题思路\n先把目标字符c的位置存储起来，然后遍历目标字符串的每个字符，计算每个字符与数组里存储的目标字符串的索引值的差值选出最小的存储到结果数组中。\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        char[] ch = s.toCharArray();\n        List<Integer> index = new ArrayList<>();\n        for(int i=0;i<s.length();i++){\n            if(ch[i]==c){\n                index.add(i);\n            }\n        }\n        for(int i=0;i<s.length();i++){\n            int min=abs(i,index.get(0));\n            for(int j=1;j<index.size();j++){\n                int temp = abs(i,index.get(j));\n                \n                if(min>temp){\n                    min=temp;\n                }\n            }\n            result[i]=min;\n        }\n        return result;\n    }\n    public int abs(int a,int b){\n        int result = a-b;\n        return (result<0)?-result:result;\n    }\n}\n```\n\n#### 时间复杂度\nO(n<sup>2</sup>)\n#### 空间复杂度\nO(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922282026","body":"### 思路\n设当前链表的左端点为left，右端点right, left 包含在链表中而right 不包含在链表中。我们希望快速地找出链表的中位数节点mid.初始时，快指针 fast 和慢指针 slow 均指向链表的左端点 left。将快指针fast 向右移动两次的同时，将慢指针slow 向右移动一次，直到快指针到达边界。此时，慢指针对应的元素就是中位数。\n在找出了中位数节点之后，我们将其作为当前根节点的元素，并递归地构造其左侧部分的链表对应的左子树，以及右侧部分的链表对应的右子树。\n### Java代码\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n\n### 复杂度分析\n时间复杂度\nO(nlogn)\n\n空间复杂度\nO(logn)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyalei1026":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916481742","body":"### 思路\r\n convert a list of integers into a number\r\n update this number by adding k \r\n convert back the result into a list of integers\r\n### 代码\r\n```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_str = \"\"\r\n        for n in num:\r\n            num_str += str(n)\r\n        output = []\r\n        for n in str(int(num_str) + k):\r\n            output.append(int(n))\r\n        return output\r\n```\r\n**复杂度分析**\r\nTime Complexity：O(n)\r\nSpace Complexity：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917863211","body":"补卡\r\n# 思路\r\nalways find the closest target character\r\n# 代码\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n         index = []\r\n                for i in range(len(s)):\r\n                    if s[i] == c:\r\n                        index.append(i)\r\n                output = []\r\n                j = 0\r\n                i = 0\r\n                while i < len(s):\r\n                    if (j+1 < len(index)):\r\n                        if abs(i - index[j]) >= abs(i - index[j + 1]):\r\n                            j += 1\r\n                    output.append(abs(i-index[j]))\r\n                    i += 1\r\n                return output\r\n```\r\n# 复杂度\r\nTime complexity: O(n)\r\nSpace complexity: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917690368","body":"# 思路\r\n用list实现\r\n# 代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0:\r\n            return -1\r\n        pop = self.stack[-1]\r\n        del self.stack[-1]\r\n        return pop\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack) <= k:\r\n            for i in range(len(self.stack)):\r\n                self.stack[i] += val\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i] += val\r\n```\r\n# 复杂度\r\nTime complexity: pop and push O(1)\r\n                            increment O(n)\r\nSpace complexity: O(n) ?\r\n\r\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918672379","body":"# Main idea:\r\n\r\n- Two stack. One is for input, the other one is for output.\r\n- When push, add element to input stack. \r\n- When pop, transfer all elements in input stack to helper from top. And return the top element in helper which is bottom element in input stack\r\n- when peek, use the same strategy mention above.\r\n# Code\r\n ```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.helper = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if len(self.stack) == 0:\r\n            return \r\n        while self.stack:\r\n            self.helper.append(self.stack.pop())\r\n        temp = self.helper.pop()\r\n        while self.helper:\r\n            self.stack.append(self.helper.pop())\r\n        return temp\r\n        \r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if len(self.stack) == 0:\r\n            return \r\n        while len(self.stack) > 1:\r\n            self.helper.append(self.stack.pop())\r\n        temp = self.stack.pop()\r\n        self.helper.append(temp)\r\n        while self.helper:\r\n            self.stack.append(self.helper.pop())\r\n        return temp\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n ```\r\n# Complexity\r\nTime complexity: O(n)\r\nSpace complexity: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920567015","body":"# Main idea\r\ntraverse linkedlist, find the tail of linkedlist and link the tail with head\r\nfind remainder of k, in case round up situation, k % len(linkedlist)\r\nbreak the link at count - k % count\r\ncurrent node is head node now, directly return current\r\n# Code\r\n```\r\nclass Solution:\r\n        \r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:   \r\n        current = head\r\n        tail = None\r\n        count = 0\r\n        while current:\r\n            if not current.next:\r\n                tail = current\r\n            current = current.next\r\n            count += 1\r\n            \r\n    \r\n        if count == 0 or k % count == 0:\r\n            return head\r\n        \r\n        tail.next = head\r\n        \r\n        current = head\r\n        previous = None\r\n        i = 0\r\n        while i < (count - k % count):\r\n            previous = current\r\n            current = current.next\r\n            i += 1\r\n        previous.next = None\r\n        return current\r\n```\r\n# Complexity\r\nTime complexity: O(N)\r\nSpace Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921376490","body":"# Main idea\r\nUse a dummy node and iterate the linkedlist.\r\n# Code\r\n```\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        dummy = ListNode(-1)\r\n        pre = dummy\r\n        first = head\r\n        second = head.next\r\n        while first and second:\r\n            temp = second.next\r\n            pre.next = second\r\n            second.next = first\r\n            first.next = temp\r\n            pre = first\r\n            first = first.next\r\n            second = temp.next if temp else None\r\n        return dummy.next\r\n```\r\n# Complexity\r\nTime complexity: O(n)\r\nSpace complexity:O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangzz2015":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916499894","body":"\n\n\n## 思路\n- 把K按照位转换成vector。则求解方法和求解两个vector 数相加相同，从后往前遍历。注意carry。时间复杂度 k的位数N，A的位数位M, O(N) + O(max(N,M)) 空间复杂度为 O(N + max(N,M)) \n\n\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        \n        vector<int> veck;  \n        while(k)\n        {\n            veck.push_back(k%10);\n            k =k /10; \n        }\n        bool next = false; \n        int left =num.size()-1; \n        int right =0; \n        vector<int> ret; \n        while(left>=0 && right < veck.size())\n        {\n            int sum = num[left] + veck[right] + (next? 1:0);\n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            left--; \n            right++; \n        }\n        while(left>=0)\n        {\n            int sum = num[left] + (next? 1:0); \n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            left--;                 \n        }\n        while(right < veck.size())\n        {\n            int sum = veck[right] + (next? 1 : 0);\n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            right++;             \n        }\n        if(next)\n            ret.push_back(1);\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917122923","body":"## 思路\n- 最短距离，使用BFS。第一次遍历找到所有c的字符，放入queue。并设置初始化距离0。下面通过BFS遍历，一层一层设置其他字符的距离。复杂度O(N) + O(N)。空间复杂度O(N)。需要使用队列记录节点。\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        \n        //  method 1 use queue and bft. \n        queue<int> que; \n        vector<int> ret(s.size(), INT_MAX); \n        for(int i=0; i<s.size(); i++)\n        {\n            if(s[i]==c)\n            {\n                ret[i]=0; \n                que.push(i);\n            }\n        }\n        while(que.size())\n        {\n            int topVal = que.front();\n            que.pop();\n            for(int i=-1; i<=1; i=i+2)\n            {\n                int newIndex = topVal +i; \n                if(newIndex<0 || newIndex>=s.size()) // skip; \n                    continue;                \n                if(ret[topVal]+1 < ret[newIndex])\n                {\n                    que.push(newIndex);\n                    ret[newIndex]=ret[topVal]+1;\n                }\n            }\n        }        \n        return ret; \n        \n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917453403","body":"## 思路\n- 关键如何 inc 增加val。另外使用一个栈sum来存储increment val。当出栈时候，把sum加上，并传给下一个top。另外使用vector 来模拟栈。时间复杂度为O(1)，空间复杂度为O(N)。\nC++ Code:\n\n```c++\n\nclass CustomStack {\npublic:\n    vector<int> stack;\n    vector<int> sum; \n    int imaxSize=0; \n    CustomStack(int maxSize) {\n        stack.reserve(maxSize);\n        imaxSize = maxSize;\n        sum.reserve(maxSize);\n    }\n    \n    void push(int x) {\n        if(stack.size()<imaxSize)\n        {\n            stack.push_back(x);\n            sum.push_back(0);\n        }\n    }\n    \n    int pop() {\n        if(stack.size())\n        {\n            int val = stack.back(); \n            int inc = sum.back(); \n            stack.pop_back();\n            sum.pop_back(); \n            if(sum.size())\n            {\n                sum[sum.size()-1] += inc;\n            }\n            return val + inc; \n                \n        }\n        else\n            return -1; \n        \n        \n    }\n    \n    void increment(int k, int val) {\n        int index = min(k,int(sum.size()))-1; \n        \n        if(index>=0)\n          sum[index] +=val; \n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917690879","body":"## 思路\n- 括号匹配问题，使用递归或者栈的办法，和处理计算器的括号处理类似，使用递归办法，递归需要输入，start的位置，对应[后面的位置，输出需要两个内容，1个对应[]内的字符串，另外也需要传出，当前结束的位置，所以采用引用办法返回start，递归完成，后面继续处理下一个。碰到[ 进入递归，碰到 ]返回string，另外要注意num 清零。\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        \n        int start =0; \n        return helper(s, start); \n    }\n    \n    \n    string helper(string& s, int& start)\n    {\n        int num =0; \n        string ret;\n        for(; start < s.size(); start++)\n        {\n            if(s[start]-'0'>=0 && s[start]-'0'<=9) // is digital\n            {\n                num = num*10 + (s[start] - '0' );\n            }\n            else if(s[start]=='[')\n            {\n                start++;  \n                string oneWord = helper(s, start);\n                for(int i=0; i< num; i++)\n                {\n                    ret +=oneWord; \n                }\n                num =0;                 \n            }\n            else if(s[start] == ']')\n            {\n                return ret;\n            }\n            else // charater. \n            {\n                ret.push_back(s[start]); \n            }\n            \n        }  \n        return ret;\n        \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918445096","body":"## 关键点\n-  队列先进先出，栈后进先出。利用两个栈进行reverse操作。例如[ 1 2 3 4 5] 出栈的顺序为5 4 3 2 1。队列的顺序为1 2 3 4 5。如果使用两个栈，把第一个栈的出栈再放入另外一个栈[5 4 3 2 1]。在出栈的顺序则为1 2 3 4 5 和队列顺序相同。具体实现，所有的入栈放入栈1。不要马上把栈1的内容出栈放入栈2。出栈操作栈2。只有当栈2的内容为空时，才把栈1内容移动到栈2。平均的时间复杂度为O(2)。所有的元素入栈两次，出栈两次，先入栈1，再出栈1，再入栈2，再出栈2。空间复杂度为O(2N)。需要两个栈维护栈内元素。\n\nC++ Code:\n\n```c++\n\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    vector<int> stack1;\n    vector<int> stack2; \n    MyQueue() {\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        \n        stack1.push_back(x); \n        \n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        transferStack1ToStack2();\n        int topVal = stack2.back();\n        stack2.pop_back();\n        return topVal;                                \n    }\n    \n    /** Get the front element. */\n    int peek() {\n        transferStack1ToStack2(); \n        return stack2.back();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        \n        return stack1.size()==0 && stack2.size()==0; \n        \n    }\nprivate:\n    void transferStack1ToStack2()\n    {\n        if(stack2.size()==0)\n        {\n            while(stack1.size())\n            {\n                int topVal = stack1.back(); \n                stack2.push_back(topVal);\n                stack1.pop_back();\n            }            \n        }        \n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919520445","body":"## 思路\r\n-方法1，采用排序 [0 1 3 4 2] 进行排序后[0 1 2 3 4] 对应的index 为[ 0 1 4 2 3 ]  能发现如果最大的index 和  对应顺序的index相同，则为一个chunk。如果排序后的index和原始的index相同，则表面自己所在的位置就是对应排序的位置，则一定可以单独成为一个chunk。如果不相同，则对应最大的位置一定需要在一个chunk。时间复杂度O(n + nlogn + n) 空间复杂度 O(2n ) 需要记录数值大小以及对应的index\r\n-方法2，维护一个单调递增栈的办法，[0 1 3 4 2] 则 [ 0 1 3 4] 当2来后，要注意先记住最大4。pop 出3 4 ，再把最大4放入形成[ 0 1 4] 该单调栈记录为每个chunk 里面最大数。并维持递增栈。最后返回栈的大小，就是chunk的大小。时间复杂度O(n) 空间复杂度 O(n) \r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++  方法1 \r\n\r\nstruct comp\r\n{\r\n    bool operator()(vector<int>& node1, vector<int>& node2)\r\n    {\r\n        if(node1[0] == node2[0])  return node1[1]<node2[1];\r\n        \r\n        return node1[0] < node2[0]; \r\n    }\r\n};\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n \r\n        vector<vector<int>> record(arr.size(), vector<int>(2));\r\n        for(int i=0; i< arr.size(); i++)\r\n        {\r\n            record[i][0] = arr[i];\r\n            record[i][1] = i; \r\n        }\r\n        sort(record.begin(), record.end(), comp()); \r\n        int count =0; \r\n        int imax =-1; \r\n        for(int i=0; i< record.size(); i++)\r\n        {\r\n\r\n            imax =  max(imax, record[i][1]); \r\n            if(imax == i )\r\n                count++; \r\n        }\r\n        \r\n        return count; \r\n    }\r\n};\r\n\r\n```\r\n```c++  方法2 \r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n \r\n////////// monic stack. decrease. \r\n        vector<int> stack; \r\n        for(int i=0;i < arr.size(); i++)            \r\n        {\r\n            if((stack.size() && stack.back()<=arr[i])  || stack.size()==0)\r\n            {\r\n              stack.push_back(arr[i]);\r\n            }\r\n            else\r\n            {\r\n                int largestNum = stack.back();\r\n                while(stack.size() && stack.back()>arr[i])\r\n                {\r\n                    stack.pop_back();\r\n                }\r\n                stack.push_back(largestNum);\r\n            }        \r\n        }\r\n        return stack.size();\r\n    }\r\n    \r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920581076","body":"## 思路\r\n- 边界情况，ListNode为空或者只有1个元素是直接返回，当k=0时，也可直接返回。\r\n-核心逻辑，找到ListNode的size N，并找到tail节点，tail节点和head节点连起来。k有可能大于N。k = k%N。移动k次，找到新的List的tail。断开tail，tail->next 为新的head 节点。复杂度为O(N)，空间复杂度为O(1)\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(head == NULL || head->next==NULL || k==0)\r\n            return head; \r\n            \r\n        int totalSize =1; \r\n        ListNode* tail = head;\r\n        while(tail->next)\r\n        {\r\n            totalSize++; \r\n            tail = tail->next; \r\n        }\r\n\r\n        \r\n        k = k%totalSize;\r\n        if(k==0)\r\n            return head; \r\n        ListNode* newTail = head; \r\n        for(int i=0; i< totalSize -k-1; i++)\r\n        {\r\n            newTail = newTail->next; \r\n        }\r\n        ListNode* newHead = newTail->next; \r\n        newTail->next = NULL; \r\n        \r\n        tail->next = head;  \r\n        return newHead; \r\n        \r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921093811","body":"## 思路\n- 例子[ 1 2 3 4 ]   按照要求得到 [2 1 4 3] 每次交换涉及到3个节点， prev->current ->next->next_next...   变换后变成prev ->next -> current->next_next 。完成一次后，更新新的prev 和current。进入下一次交换 \n-另外由于头节点发生变化，利用虚拟头指针，时间复杂度为O(N) 空间复杂为O(1) \n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        \n        ListNode tmpNode; \n        tmpNode.next = head; \n        ListNode* prevNode = &tmpNode; \n        ListNode* currentNode = NULL;\n        ListNode* nextNode = NULL;\n        while(head && head->next)\n        {\n            //  it has three node. \n            //   prevNode   currentNode nextNode; \n            //  orig   prevNode->next = currentNode   currenNode->next = nextNode   nextNode->nextNode will be next current. \n            //  new    prevNode->next =  nextNode   nextNode->next=currentNode   currentNode->next =   next prev node. \n            currentNode= head; \n            nextNode = head->next; \n            \n            // swap. It is better to get next from back. \n            currentNode->next = nextNode->next;            \n            nextNode->next = currentNode; \n            prevNode->next = nextNode; \n            \n            \n            prevNode = currentNode;                         \n            head = currentNode->next; \n        }\n        \n        return tmpNode.next; \n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922177971","body":"## 思路\r\n- 方法1. 把list转换为vector。采用前序遍历，每次找到中点，作为root节点，前半部分为left。后半部分为right。时间负责度为O(2N)，空间复杂度为O(N) + O(logN)\r\n- 方法2. 通过快慢指针找到中间节点，和方法1类似。唯一要注意找到leaf节点，直接返回。另外需要把中间的前一个节点砍断，时间复杂度为O(NlogN)，因为需要遍历list找到中点，空间复杂度为栈的高度O(logN)\r\n- 方法3. 先编译list找到size，然后采用中序遍历办法，中序遍历就是list的顺序。时间复杂度为O(2N)。空间复杂度为O(logN)\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++ 方法1\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        \r\n        if(head == NULL)\r\n            return NULL; \r\n        vector<int> value; \r\n        while(head)\r\n        {\r\n            value.push_back(head->val);\r\n            head = head->next; \r\n        }\r\n        \r\n        return helper(value, 0, value.size()-1); \r\n        \r\n    }\r\n    \r\n    TreeNode* helper(vector<int>& vec, int start, int end)\r\n    {\r\n        if(start>end)\r\n            return NULL;\r\n        int middle = start + (end-start)/2; \r\n        TreeNode* current = new TreeNode(vec[middle]); \r\n        \r\n        current->left = helper(vec, start, middle-1); \r\n        current->right = helper(vec, middle+1, end); \r\n        return current; \r\n            \r\n    }\r\n};\r\n\r\n```  方法2\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        \r\n        if(head == NULL)\r\n            return NULL; \r\n        \r\n        \r\n        return helper(head); \r\n    }\r\n    //  [head, end)\r\n    TreeNode* helper(ListNode* head)\r\n    {\r\n        if(head == NULL)\r\n            return NULL; \r\n        \r\n        ListNode* middle = middleNode(head);\r\n        //cout<< \"middle:\" <<middle->val <<\"\\n\";\r\n        \r\n        TreeNode* current = new TreeNode(middle->val);\r\n        if(head == middle)\r\n            return current;         \r\n        \r\n        current->left = helper(head);\r\n        current->right = helper(middle->next); \r\n\r\n        return current; \r\n        \r\n    }\r\n    \r\n    ListNode* middleNode(ListNode* head)\r\n    {\r\n        if(head==NULL|| head->next==NULL )\r\n            return head; \r\n        //  1 2 3 4  --- > return 2 \r\n        //  1 2 3 4 5 ----> return 3; \r\n        ListNode* fast = head;\r\n        ListNode* slow = head; \r\n        ListNode* prev = head; \r\n        while(fast!=NULL && fast->next!=NULL)\r\n        {\r\n            fast = fast->next->next; \r\n            prev = slow; \r\n            slow = slow->next; \r\n        }\r\n        // cut left and right; \r\n        if(prev!=NULL)\r\n            prev->next = NULL; \r\n        return slow; \r\n            \r\n    }\r\n};\r\n\r\n```  \r\n```  方法3\r\nclass Solution {\r\npublic:\r\n    ListNode* currentList; \r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        \r\n        if(head == NULL)\r\n            return NULL;\r\n        int size=0; \r\n        currentList = head;         \r\n        while(head)\r\n        {\r\n            size++; \r\n            head = head->next; \r\n        }\r\n\r\n        return helper( 0, size-1);\r\n    }\r\n    \r\n    TreeNode* helper(int start, int end)\r\n    {\r\n        if(start>end)\r\n            return NULL; \r\n        \r\n        int middle = start + (end - start)/2; \r\n        TreeNode* leftNode = helper(start, middle-1); \r\n        \r\n //       cout << \"current:\" << currentList->val<<\"\\n\"; \r\n        TreeNode* current = new TreeNode(currentList->val);\r\n        currentList = currentList->next; \r\n        TreeNode* rightNode = helper(middle+1, end); \r\n        \r\n        current->left = leftNode; \r\n        current->right = rightNode;\r\n        \r\n        return current; \r\n    }\r\n\r\n};\r\n```  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922348679","body":"## 思路\r\n- 方法1，采用hash set，记录访问的NodeList。检查是否有重复，采用方法，两个List同步访问，并检查，最差情况复杂度为O(n+m)，空间复杂度为O(n+m)\r\n- 方法2，采用双指针办法，逻辑为ListA走到尾，切换到ListB，ListB走到尾，切换到ListA。最后相同的点就为交叉点。有两种情况，一种是有交叉，一种没有交叉，如果没有交叉，则两个指针都访问了ListA的node和ListB的node，最后相同点为NULL指针，当有交叉点，假设A  --->   l  +m   ，  B --->  n +m ，后半部分m 为交叉后相同点，则两个指针每个指针都遍历了 l + n + m，最后第一次相同的点，就为第一个交叉点。时间复杂度，最差情况为O(n+m)，如果是最后一点交叉，空间复杂度为O(1)\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++ 方法1 \r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        \r\n     unordered_set<ListNode*> recordNode; \r\n     while(headA &&headB)\r\n     {\r\n         if(recordNode.find(headA)!=recordNode.end())\r\n             return headA;\r\n         else\r\n             recordNode.insert(headA);\r\n         if(recordNode.find(headB)!=recordNode.end())\r\n             return headB;\r\n         else\r\n             recordNode.insert(headB);\r\n         headA = headA->next;\r\n         headB = headB->next; \r\n     }\r\n    if(headA)\r\n    {\r\n        while(headA)\r\n        {\r\n           if(recordNode.find(headA)!=recordNode.end())\r\n             return headA;\r\n         else\r\n             recordNode.insert(headA);  \r\n         headA = headA->next;            \r\n        }\r\n    }\r\n    if(headB)\r\n    {\r\n        while(headB)\r\n        {\r\n         if(recordNode.find(headB)!=recordNode.end())\r\n             return headB;\r\n         else\r\n             recordNode.insert(headB);   \r\n         headB = headB->next; \r\n        }\r\n    }\r\n        return NULL;\r\n        \r\n    }\r\n};\r\n\r\n```\r\n```c++ 方法2\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        \r\n        // basic rule.  move a move b.  If a == NULL, then move to b head. \r\n        // if b == NULL, then move to a head. \r\n        //  same node will be intersection point. \r\n        ListNode* nodeA = headA; \r\n        ListNode* nodeB= headB; \r\n        while(nodeA != nodeB )\r\n        {\r\n            if(nodeA == NULL )\r\n            {\r\n                nodeA = headB;\r\n            }\r\n            else\r\n                nodeA = nodeA->next; \r\n            \r\n            if(nodeB == NULL)\r\n            {\r\n                nodeB = headA;\r\n            }\r\n            else\r\n                nodeB = nodeB->next; \r\n        }\r\n        \r\n        return nodeA; \r\n        \r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922512991","body":"## 思路\n- 方法1 使用快慢指针先找到intersec点，如果有intersec点，则表明有环，如果没有则没环，注意要先移动再判断，避免初始设置相同，返回错误。找到intersec点，再移动fast或者slow到head，使用相同速度，则相同点为intersec的第一个点。仔细推导如下。如果有环  环之前的大小为l  环的大小为 m     首先计算第一次快慢指针的相遇点  (l + x)*2 = l + m +x  可知道l  = m-x 。如果slow指针回到原点，快指针再走 m - x  慢指针走 l 下，正好达到环的第一个点。时间复杂度为O(N)，空间复杂度为O(1)\n- 方法2，可使用hash set，记录走得节点，如果碰到第一个重复点，则是环的第一个点。时间复杂度为O(N)，空间复杂度为O(N)\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++  方法1 \nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        \n        ListNode* fast = getInterSect(head);\n        if(fast==NULL)\n            return NULL;\n        \n        ListNode* slow = head; \n        while(slow!=fast)\n        {\n            slow = slow->next; \n            fast = fast->next; \n        }\n        return slow;\n        \n    }\n    \n  ListNode* getInterSect(ListNode* head)\n  {\n        ListNode* fast = head; \n        ListNode* slow = head;\n        while(fast && fast->next)\n        {\n            fast = fast->next->next; \n            slow = slow->next; \n            if(fast == slow)\n                return fast; \n        }\n        \n        return NULL; \n  }\n};\n\n```\n```c++  方法2 \nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        \n        if(head == NULL)\n            return NULL; \n        unordered_set<ListNode*> recordNode; \n        \n        while(head)\n        {\n            if(recordNode.find(head)!=recordNode.end())\n                return head; \n            \n            recordNode.insert(head);\n            head = head->next;\n        }\n        \n        return NULL; \n            \n            \n    }\n        \n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongxw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916507442","body":"### 思路\r\n\r\nwhile num[i]存在 或者 k不为0:\r\n    当前位sum = 进位 + nums[i](如果存在) + k mod 10 (如果k不为0)；\r\n    倒序遍历num，同时k = k /10;\r\n    进位 carry = sum / 10;\r\n    当前位 digit = sum mod 10;\r\n    输出数组记录digit;\r\n如果最后一位有进位，添加到输出数组中;\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    i = num.length - 1;\r\n    carry = 0;\r\n    ans = [];\r\n    while(i >= 0 || k != 0) {\r\n      sum = carry;\r\n      if (i >= 0) {\r\n        sum += num[i];\r\n        i--;\r\n      }\r\n      if (k != 0) {\r\n        sum += k % 10;\r\n        k = Math.floor(k / 10);\r\n      }\r\n\r\n      carry = Math.floor(sum / 10);\r\n      ans.unshift(sum % 10);\r\n    }\r\n\r\n    if (carry > 0) {\r\n      ans.unshift(carry);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。 k <= 10^4 不计\r\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917253566","body":"### 思路\r\n正序遍历，计算每个位置到左侧指定字符的最短距离；\r\n倒序遍历，计算每个位置到右侧指定字符的最短距离；\r\n取最小值。\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  let ans = new Array(s.length);\r\n  let count = s.length;\r\n  for (let i=0; i<s.length; i++) {\r\n    count = s[i] === c ? 0 : count + 1;\r\n    ans[i] = count;\r\n  }\r\n\r\n  count = s.length;\r\n  for (let i=s.length-1; i>=0; i--) {\r\n    count = s[i] === c ? 0 : count + 1;\r\n    ans[i] = Math.min(ans[i], count);\r\n  }\r\n\r\n  return ans;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(s.length)\r\n- 空间复杂度：O(s.length)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917494101","body":"## 思路\r\n用数组记录增量值，数组大小是maxSize\r\n出栈时，需要把栈顶元素加上应的增量值返回。\r\n同时要维护增量值数组：把栈顶对应的增量值加到栈顶的下一个元素上，并把对应的栈顶位置清空。\r\n\r\n## 代码\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n  this.increments = new Array(maxSize).fill(0);\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length < this.maxSize) {\r\n    this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  let size = this.stack.length;\r\n  if (size === 0) {\r\n    return -1;\r\n  } else {\r\n    let val = this.increments[size - 1];\r\n    this.increments[size - 1] = 0;\r\n    if (size - 2 >= 0) {\r\n      this.increments[size - 2] += val;\r\n    }\r\n\r\n    return this.stack.pop() + val;\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let size = Math.min(this.stack.length, k);\r\n  this.increments[size - 1] += val;\r\n};\r\n```\r\n\r\n*TC: O(1)*\r\n*SC: O(maxSize)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917756044","body":"## 思路\r\n类似括号匹配，遍历字符串，\r\n如果是数字，就计算当前数字；\r\n如果是字符，入栈；\r\n如果是左括号，先把当前计算好的数字入栈，再把左括号入栈；\r\n如果是右括号，先把栈顶字符串依次出栈并拼接起来，直到碰到左括号。左括号出栈后，栈顶是重复次数，根据次数展开当前字符串后入栈。\r\n遍历结束后把栈内所有已解码完成的字符串拼接起来。\r\n\r\n## 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  let stack = [];\r\n\r\n  let num = 0;\r\n  for (let i=0; i<s.length; i++) {\r\n    if (s[i] >= '0' && s[i] <= '9') {\r\n      num = num * 10 + (s[i] - '0');\r\n    } else if (s[i] === '[') {\r\n      stack.push(num);\r\n      num = 0;\r\n      stack.push(s[i]);\r\n    } else if (s[i] === ']') {\r\n      let str = '';\r\n      while (stack[stack.length - 1] !== '[') {\r\n        str = stack.pop() + str;\r\n      }\r\n      stack.pop(); // '['\r\n\r\n      let temp = '';\r\n      let repeat = stack.pop();\r\n      while (repeat > 0) {\r\n        temp += str;\r\n        repeat--;\r\n      }\r\n      stack.push(temp);\r\n    } else {\r\n      // chars\r\n      stack.push(s[i]);\r\n    }\r\n  }\r\n\r\n  let ans = '';\r\n  while (stack.length !== 0) {\r\n    ans = stack.pop() + ans;\r\n  }\r\n\r\n  return ans;\r\n};\r\n```\r\n\r\n*TC: O(ans.length)*\r\n*SC: O(ans.length)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918662417","body":"### 思路\r\n两个栈分别负责入列和出列；\r\n入列时直接把元素压进入列栈；\r\n出列时先检查出列的栈是否为空，如果不空就直接取栈顶元素；如果空就把入列栈的所有元素转移到出列栈；\r\npeek()同理；\r\n判空的时候要判断两个栈是否同时为空。\r\n\r\n### 代码\r\n```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.inStack = [];\r\n    this.outStack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.inStack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  if (this.empty()) {\r\n    return -1;\r\n  }\r\n\r\n  if (this.outStack.length === 0) {\r\n    this.peek();\r\n  }\r\n  return this.outStack.pop(); \r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if (this.empty()) {\r\n      return -1;\r\n    }\r\n\r\n    if (this.outStack.length === 0) {\r\n      while(this.inStack.length !== 0) {\r\n        this.outStack.push(this.inStack.pop());\r\n      }\r\n    }\r\n\r\n    return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.inStack.length === 0 && this.outStack.length === 0;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： push O(1), pop / peek 最坏情况O(n), empty O(1)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919593955","body":"### 思路\r\n关键点在于分块的判断标准： 对于任意位置i，可以分块的标准是[i+1...n]的最小值，不能超过[0...i]的最大值。否则排序的时候，[i+1...n]中的某个值必须换到[0....i]，这样就不能在位置i分块了。\r\n所以可以有两种做法，一种是先从左到右计算[0...i]的最大值，再从右到左计算[i+1...n]的最小值，再对比两个数组统计答案。\r\n或者直接用单调栈。\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  let monoStack = [];\r\n  for (let num of arr) {\r\n    if (monoStack.length > 0 && num < monoStack[monoStack.length - 1]) {\r\n      let top = monoStack[monoStack.length - 1];\r\n      while (monoStack.length > 0 && num < monoStack[monoStack.length - 1]) {\r\n        monoStack.pop();\r\n      }\r\n      monoStack.push(top);\r\n    } else {\r\n      monoStack.push(num);\r\n    }\r\n  }\r\n\r\n  return monoStack.length;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920488376","body":"### 思路\r\n先计算链表长度，根据长度把k取余\r\n观察题目发现新的头节点是原链表的倒数第k个节点\r\n双指针方法求倒数第k+1个节点，同时可以得到尾节点。\r\n最后修改相关节点next指针，返回结果。\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n  if (head === null || head.next === null) {\r\n    return head;\r\n  }\r\n\r\n  let len = 0;\r\n  let node = head;\r\n  while (node !== null) {\r\n    len++;\r\n    node = node.next;\r\n  }\r\n\r\n  k = k % len;\r\n  if (k === 0) {\r\n    return head;\r\n  }\r\n\r\n  let first = head;\r\n  let second = head;\r\n  while (first.next !== null) {\r\n    first = first.next;\r\n\r\n    if (k > 0) {\r\n      k--;\r\n    } else {\r\n      second = second.next;\r\n    }\r\n  }\r\n\r\n  let newHead = second.next;\r\n  second.next = null;\r\n  first.next = head;\r\n\r\n  return newHead;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921359569","body":"### 思路\r\n三个指针分别指向相邻的两个节点和这两个节点前面的那个节点，根据题意遍历链表并调整三个节点的next指针\r\n用一个假的链表头简化逻辑\r\n### 代码\r\n```js\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n  if (head === null || head.next === null) {\r\n    return head;\r\n  }\r\n\r\n  let dummy = new ListNode(0, head);\r\n\r\n  let pre = dummy;\r\n  let fast = head.next;\r\n  let slow = head;\r\n  while (fast !== null) {\r\n    const next = fast.next;\r\n\r\n    fast.next = slow;\r\n    slow.next = next;\r\n    pre.next = fast;\r\n\r\n    if (next === null) {\r\n      break;\r\n    }\r\n    \r\n    pre = slow;\r\n    slow = next;\r\n    fast = next.next;\r\n  }\r\n\r\n  return dummy.next;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922147083","body":"### 思路\r\n快慢指针找链表最中间的节点做为树根。然后对左半链表和右半链表进行递归，生成左右子树。\r\n### 代码\r\n```js\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n  return recurBuild(head, null);\r\n};\r\n\r\nfunction recurBuild(start, end) {\r\n  if (start === end) {\r\n    return null;\r\n  }\r\n  if (start.next === end) {\r\n    return new TreeNode(start.val);\r\n  }\r\n\r\n  let fast = start;\r\n  let slow = start;\r\n  while (fast != end && fast.next !== end) {\r\n    slow = slow.next;\r\n    fast = fast.next.next;\r\n  }\r\n\r\n  node = new TreeNode(slow.val, recurBuild(start, slow), recurBuild(slow.next, end));\r\n  return node;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： O(logn) 二分递归\r\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922382332","body":"## 思路\r\n遍历链表A，节点存到集合里。\r\n遍历链表B，如果某个节点在集合里，就返回。\r\n## 代码\r\n```js\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n  let setA = new Set();\r\n  let p = headA;\r\n  while (p !== null) {\r\n    setA.add(p);\r\n    p = p.next;\r\n  }\r\n\r\n  p = headB;\r\n  while (p !== null) {\r\n    if (setA.has(p)) {\r\n      return p;\r\n    }\r\n    p = p.next;\r\n  }\r\n\r\n  return null;\r\n  // return trick(headA, headB);\r\n};\r\n```\r\n\r\n*TC: O(len(headA) + len(headB))*\r\n*SC: O(len(headA))*","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okbug":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916511474","body":"JS 占坑\r\n其实可以用力扣第二题（两数之和） 类似的解法\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    for (let i = num.length - 1; i >= 0 || k > 0; i--) {\r\n\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n\r\n        res.push(k % 10); // 当时个位上的数\r\n        k = (k - k % 10) / 10;\r\n    }\r\n\r\n    return res.reverse();\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917402316","body":"```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, INT_MAX);\n        for (int i = 0, j = -1; i < n; i++) {\n            if (s[i] == c) j = i;\n            if (j != -1) res[i] = i - j;\n        }\n        for (int i = n - 1, j = -1; i >= 0; i--) {\n            if (s[i] == c) j = i;\n            if (j != -1) res[i] = min(res[i], j - i);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917627382","body":"```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\n\r\n/**\r\n * @return {number}\r\n */\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\n\r\nclass CustomStack extends Array {\r\n    constructor(maxSize) {\r\n        super();\r\n        this.max = maxSize || 0;\r\n        this.q = [];\r\n    }\r\n\r\n    push(x) {\r\n        let len = this.q.length;\r\n        if (len >= this.max) return;\r\n        this.q.push(x)\r\n    }\r\n\r\n    pop() {\r\n        if (this.q.length > 0) return this.q.pop();\r\n        return -1;\r\n    }\r\n\r\n    increment(k, val) {\r\n        let len = Math.min(k, this.q.length);\r\n        for (let i = 0; i < len; i++) {\r\n            this.q[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n利用数组的push和pop方法直接实现","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918283270","body":"# 代码\nCPP\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res;\n        for (int i = 0; i < s.size();) {\n            if (!isdigit(s[i])) res += s[i ++ ];\n            else {\n                int j = i;\n                while (isdigit(s[j])) j++ ;\n                int t = atoi(s.substr(i, j - i).c_str());\n                int k = j + 1, sum = 0;\n                while (sum >= 0) {\n                    if (s[k] == '[') sum ++ ;\n                    if (s[k] == ']') sum -- ;\n                    k ++ ;\n                }\n                string str = decodeString(s.substr(j + 1, k - j - 2));\n                while (t--) res += str;\n                i = k;\n            }\n        }\n\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918665539","body":"# 思路\n一个类继承于Array\n可以原生实现push方法，只需要重写pop为shift即可，并且添加peek和empty方法\n\n# 代码\n\n```js\nclass MyQueue extends Array {\n    constructor() {\n        super();\n    }\n\n    pop() {\n        return this.shift();\n    }\n\n    peek() {\n        return this[0];\n    }\n\n    empty() {\n        return this.length === 0\n    };\n}\n```\n\n\n这是基于数组的shift方法实现的","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919995492","body":"# 代码\n\nJavaScript\n\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    let s = [...arr].sort((a, b) => a - b);\n\n    let count = 0, sum1 = 0, sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += s[i];\n        \n        if (sum1 === sum2) count++;\n    }\n\n    return count;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920516940","body":"# 思路\n解法1，转数组，然后通过unshift和pop()获取旋转后的数组，然后再将其转为链表\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head) return null;\n    let arr = [];\n    let p = head;\n    while (p) {\n        arr.push(p.val);\n        p = p.next;\n    }\n\n    k = k % arr.length;\n    while (k --) {\n        arr.unshift(arr.pop());\n    }\n\n    let dummy = new ListNode(-1);\n    let cur = dummy;\n    for (let i = 0; i < arr.length; i++) {\n        cur = cur.next = new ListNode(arr[i]);\n    }\n\n    return dummy.next;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921367283","body":"# 代码\n\nC++\n\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummy = new ListNode(-1);\n        dummy->next = head;\n        auto p = dummy;\n\n        while (p->next && p->next->next) { // 要保证是偶数位的链表个数\n            auto p1 = p->next, p2 = p1->next;\n            p->next = p2; // 让第二个变到前面去\n            p1->next = p2->next; // 第一个指向第二个的后一个\n            p2->next = p1; // 第二个的后面变成第一个，那么 现在就是 \n            // p -> p2 -> p1 -> (原来的p2->next)\n            p = p1;\n        }\n\n        return dummy->next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922325629","body":"# 思路\n递归\n\n# 代码\nJS\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if (!head) return null;\n    let n = 0;\n    for (let p = head; p; p = p.next) n ++;\n    if (n === 1) return new TreeNode(head.val);\n    let cur = head;\n    for (let i = 0; i < (n >> 1) - 1; i++) cur = cur.next;\n    let root = new TreeNode(cur.next.val);\n    root.right = sortedListToBST(cur.next.next);\n    cur.next = null;\n    root.left = sortedListToBST(head);\n\n    return root;\n};\n```\n\n\nC++\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (!head) return nullptr;\n        int n = 0;\n        for (auto p = head; p; p = p->next) n ++;\n        if (n == 1) return new TreeNode(head->val);\n        auto cur = head;\n        for (int i = 0; i < n / 2 - 1; i++) cur = cur->next;\n        auto root = new TreeNode(cur->next->val);\n        root->right = sortedListToBST(cur->next->next);\n        cur->next = nullptr;\n        root->left = sortedListToBST(head);\n\n        return root;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922405199","body":"# 代码\n\nC++\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* p1 = headA;\n        ListNode* p2 = headB;\n        while (p1 != p2) {\n            p1 = p1 ? p1->next : headB;\n            p2 = p2 ? p2->next : headA;\n        }\n\n        return p1;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan0327":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916531466","body":"思路：\n1.数组从个位开始[即从后往前计数]，用一个sum保存位和[加数+被加数+低位进位],一个pre保存进位\n重新设置一个输出数组out。\n2.数组从后往前遍历，每位与k%10相加、与低位进位相加，获得sum 。 sum%10加入数组，sum/10为进\n位值，运算完记得把k/10.\n3.若数组跑完k还有值或进位有值，则再跑一遍循环处理完剩余的数据\n4.最后对整个数组首尾交换即可\n代码：\n```Go\nfunc largestRectangleArea(heights []int) int {\n    stack := []int{}\n    N := len(heights)\n    st, result := make([]int,N+2), 0\n    for i:=0; i< N+2;i++{\n        if i == 0 || i == N+1{\n            st[i] = 0\n        }else{\n            st[i] = heights[i-1]\n        }\n    }\n    for i:=0; i < N+2;i++{\n        for len(stack) > 0 &&st[i] < st[stack[len(stack)-1]]{\n            mid := stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            w := i - stack[len(stack)-1] - 1\n            h := st[mid]\n            result = max(result, w*h)\n        }\n            stack = append(stack, i)\n    }\n    return result\n}\n\nfunc max(x, y int) int{\n    if x > y{\n        return x\n    }else{\n        return y\n    }\n}\n```\n时间复杂度：O(n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917318416","body":"首先生成一个N长度的数组output，并且对每个值赋值len（s）【N为字符串s的长度】,然后从数组前后分别遍历一次。\r\n从前往后时，先判断字符是否等于目标字符，若相等则数组output置0.对于不相等的字符再次判断，若字符串位于首位，则置为len（s）。接下来，每位的取值为该数组左边一位的取值加1:output[i] = output[i-1] + 1\r\n从后往前时，从倒数第二位开始判断。当该值大于等于len（s）说明该数的左边没有特定字符 或 此时的取值大于 该值右边一位的数值+1【取左右目标字符的距离最小值】，则取 该值右边一位的数值+1\r\n\r\n关键边界条件两个：\r\n1.从左往右遍历的0位，他的取值没有上一位进行参考\r\n2.有右往左的遍历n-1位，他的取值没有下一位进行参考\r\n\r\n```Go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    output := make([]int,len(s), len(s))\r\n    for i:=0; i< len(s); i++{\r\n        if(s[i] == c) {\r\n            output[i] = 0\r\n        }else{\r\n            if i==0 {\r\n                output[i] = len(s)\r\n            }else{\r\n               output[i] = output[i-1] + 1\r\n            }\r\n        }\r\n    }\r\n\r\n    for i:=len(s)-2;i >= 0;i--{\r\n        if (output[i] >= len(s) || output[i] > output[i+1] + 1){\r\n            output[i] = output[i+1] + 1\r\n        }\r\n    }\r\n    return output\r\n}\r\n```\r\n复杂度分析\r\n时间复杂度O（n）\r\n空间复杂度O（n）\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917514422","body":"type CustomStack struct {\n    stack []int\n    max int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{make([]int, 0), maxSize}\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if len(this.stack) < this.max{\n        this.stack = append(this.stack, x)\n    }\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if len(this.stack) == 0 {\n        return -1\n    }\n    out := this.stack[len(this.stack)-1]\n    this.stack = this.stack[:len(this.stack)-1]\n    return out\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    if k > len(this.stack){\n        k = len(this.stack)\n    }\n    for i:=0; i < k; i++{\n        this.stack[i] += val\n    }\n}\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918095523","body":"思路：\r\n用两个堆栈，当遇到数字，数字*10累加。遇到'['，将数字压入数字栈，字符串压入字符串栈。遇到']'将重复次数提出来，将]前的字符串重复拼接，除此之外就是继续拼接现有字符串。\r\n\r\n关键：strings.Repeat 调用\r\n从string 获取字符串 ， string(s[i]) 特别是string 获取单个字符，就string(s[i])\r\n若有数字就 strconv.Atoi\r\n\r\n代码：\r\n```Go\r\nfunc decodeString(s string) string {\r\n    stack1 := []int{}\r\n    stack2 := []string{}\r\n    byte := \"\"\r\n    count := 0\r\n    for i:=0; i < len(s); i++{\r\n        if s[i] >= '0' && s[i] <= '9'{\r\n            n, _ := strconv.Atoi(string(s[i]))\r\n            count = count *10 + n\r\n        }else if s[i] == '['{\r\n            stack1 = append(stack1, count)\r\n            count = 0\r\n            stack2 = append(stack2, byte)\r\n            byte = \"\"\r\n        }else if s[i] == ']'{\r\n            num := stack1[len(stack1)-1]\r\n            stack1 = stack1[:len(stack1)-1]\r\n            out := stack2[len(stack2)-1]\r\n            stack2 = stack2[:len(stack2)-1]\r\n            byte = string(out) + strings.Repeat(byte, num) \r\n        }else{\r\n            byte += string(s[i])\r\n        }\r\n    }\r\n    return byte\r\n}\r\n```\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918700645","body":"思路\r\n使用两个栈，一个作为输入栈，一个作为输出栈。 输入栈用来存输入【先进后出】， 但是当调用Pop、peek的时候，先判断输出栈是否有元素，没有元素则把输入栈的元素按先入后出的顺序压入输出栈 。 两次先入后出 = 先入先出 = 队列\r\n\r\n代码\r\n实现语言: Go\r\n```Go\r\ntype MyQueue struct {\r\n    stackin []int\r\n    stackout []int\r\n}\r\n\r\n\r\n/** Initialize your data structure here. */\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{make([]int,0), make([]int,0)}\r\n}\r\n\r\n\r\n/** Push element x to the back of queue. */\r\nfunc (this *MyQueue) Push(x int)  {\r\n    this.stackin = append(this.stackin, x)\r\n}\r\n\r\nfunc (this *MyQueue) in2out (){\r\n    for len(this.stackin) > 0 {\r\n        this.stackout = append(this.stackout, this.stackin[len(this.stackin)-1])\r\n        this.stackin = this.stackin[:len(this.stackin)-1]\r\n        }\r\n}\r\n\r\n/** Removes the element from in front of queue and returns that element. */\r\nfunc (this *MyQueue) Pop() int {\r\n    if len(this.stackout) == 0{\r\n        this.in2out()\r\n    }\r\n        out := this.stackout[len(this.stackout)-1]\r\n        this.stackout = this.stackout[:len(this.stackout)-1]\r\n        return out\r\n}\r\n\r\n\r\n/** Get the front element. */\r\nfunc (this *MyQueue) Peek() int {\r\n    if len(this.stackout) == 0{\r\n        this.in2out()\r\n    }\r\n    return this.stackout[len(this.stackout)-1]\r\n}\r\n\r\n\r\n/** Returns whether the queue is empty. */\r\nfunc (this *MyQueue) Empty() bool {\r\n    return len(this.stackout) == 0&& len(this.stackin) == 0\r\n}\r\n\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * obj := Constructor();\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * param_3 := obj.Peek();\r\n * param_4 := obj.Empty();\r\n */\r\n```\r\n\r\n复杂度分析\r\n时间复杂度：\r\npush: O(1)\r\npop: 平均 O(1)\r\npeek: O(1)\r\nempty: O(1)\r\n\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919628471","body":"思路：最近练了单调栈，但是一时间想不起来。然后又是看答案的一天，核心的话通过判断栈的数量来判断可以分成几块。\r\n若栈为空或遇到比栈顶大的数，存入栈。\r\n若遇到比栈小的，重新判断，先把栈顶拿出来作为临时变量\r\n反复比较栈顶的值是否小于遍历的值，若小于，则出栈。\r\n最后输出栈的长度，关键是判断。\r\n```Go\r\nfunc maxChunksToSorted(arr []int) int {\r\n    stack := []int{}\r\n    count := 1\r\n    for _,x := range arr{\r\n        for len(stack) > 0&& x >= stack[len(stack)-1]{\r\n            stack = stack[:len(stack)-1]\r\n            if len(stack) == 0{\r\n                count++\r\n            }\r\n        }\r\n        stack = append(stack, x)\r\n    }\r\n    return count\r\n}\r\n\r\n```\r\n时空复杂度\r\n时间复杂度：O(N)\r\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920502426","body":"思路：\r\n1.自己有思路，但是没写出来，然后对了答案。\r\n于是：\r\n【记得考虑边界条件，如k=0, 链表为空，链表为1】\r\n首先遍历链表获得链长n，关键是n初始值为1 且判断链表下一位不为空 即 pre.Next != nil\r\n然后首尾相接组成环\r\n倒数M位 = 整数N位 - k%N = add【步数】\r\n然后再for add > 0 判断，获得倒数第一位置。然后输出为pre.Next ，再把pre.Next = nil 打断即可\r\n```Go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    if k == 0 || head == nil || head.Next == nil {\r\n        return head\r\n    }\r\n    pre := head\r\n    n := 1\r\n    for pre.Next != nil{\r\n        pre = pre.Next\r\n        n++\r\n    }\r\n    add := n - k%n\r\n    if add == n{\r\n        return head\r\n    }\r\n    pre.Next = head\r\n    for add > 0{\r\n        pre = pre.Next\r\n        add--\r\n    }\r\n    next := pre.Next\r\n    pre.Next = nil\r\n    return next\r\n}\r\n```\r\n补充一种快慢指针做法\r\n```Go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    if k == 0 || head == nil || head.Next == nil {\r\n        return head\r\n    }\r\n    num := 1\r\n    cur := head\r\n    for cur.Next != nil{\r\n        cur = cur.Next\r\n        num++\r\n    }\r\n\r\n    slow, fast := head, head\r\n    k %= num\r\n    for k > 0{\r\n        fast = fast.Next\r\n        k--\r\n    }\r\n    for fast.Next != nil{\r\n        slow = slow.Next\r\n        fast = fast.Next\r\n    }\r\n    fast.Next = head\r\n    out := slow.Next\r\n    slow.Next = nil\r\n    return out\r\n}\r\n```\r\n— 时间复杂度：O(n)\r\n\r\n— 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921372728","body":"思路：\r\n根据题目做的思路就可以了，用西法的穿针引线。\r\n\r\n```Go\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    if head == nil || head.Next == nil{\r\n        return head\r\n    }\r\n    dummy := &ListNode{Next: head}\r\n    cur := dummy\r\n    for cur.Next != nil && cur.Next.Next != nil{\r\n        Node1 := cur.Next\r\n        Node2 := cur.Next.Next\r\n        cur.Next = Node2\r\n        Node1.Next = Node2.Next\r\n        Node2.Next = Node1\r\n        cur = Node1\r\n    }\r\n    return dummy.Next\r\n}\r\n```\r\n时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。\r\n\r\n空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922173696","body":"法一：\r\n用数组把值存进来，然后遍历+ 二分查找 递归实现\r\n```Go\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n    arr := []int{}\r\n    for head != nil{\r\n        arr =append(arr, head.Val)\r\n        head = head.Next\r\n    }\r\n    return buildBST(arr, 0 , len(arr)-1)\r\n}\r\n\r\nfunc buildBST(arr []int, left ,right int) *TreeNode{\r\n    if left > right{\r\n        return nil\r\n    }\r\n    mid := (left + right) >>1\r\n    root := &TreeNode{Val:arr[mid]}\r\n    root.Left = buildBST(arr,left, mid-1)\r\n    root.Right = buildBST(arr, mid+1, right)\r\n    return root\r\n}\r\n````\r\n时间复杂度：O(n)，用 O(1) 时间找到数组中间元素，总体复杂度相当于只遍历了一遍数组。\r\n空间复杂度：O(n)。\r\n\r\n\r\n法2：用双指针遍历找中点链表，然后递归中点链表，用一个preSlow记录前一段链表，先拆即Next=nil再排序\r\n```Go\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n    if head == nil{\r\n        return nil\r\n    }\r\n    slow, fast := head, head\r\n    var preSlow *ListNode = nil\r\n    for fast!= nil && fast.Next != nil{\r\n        preSlow = slow\r\n        slow = slow.Next\r\n        fast = fast.Next.Next\r\n    }\r\n    root := &TreeNode{Val: slow.Val}\r\n    if preSlow != nil{\r\n        preSlow.Next = nil\r\n        root.Left = sortedListToBST(head)\r\n    }\r\n    root.Right = sortedListToBST(slow.Next)\r\n    return root\r\n}\r\n```\r\n时间复杂度：O(nlogn)O(nlogn)。一共 logn 层递归，每次找中点 O(n/2)，即 O(n)（我这么解释好像不是很对）。可以参考这个解释：每次递归花 O(n) 时间找到中点，有 T(n) = O(n) + 2T(n/2), 根据主定理推导出 O(nlogn)。主定理（master theorem）见下图：\r\n空间复杂度：O(logn)。\r\n递归栈的调用深度。\r\n\r\n\r\n法三：手动生成排序二叉搜索树，一个指针用来遍历链表，林外一个进行二分查找判断。\r\n用buildBST进行递归，采取分而治之。采取先生成左子树，再生成根节点，然后生成后子树，中间逐渐推进h\r\n```Go\r\nvar h *ListNode\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n    if head == nil{\r\n        return nil\r\n    }\r\n    num := 0\r\n    h = head\r\n    for head != nil{\r\n        num++\r\n        head = head.Next\r\n    }\r\n    return buildBST(0, num-1)\r\n}\r\n\r\nfunc buildBST(start, end int) *TreeNode{\r\n    if start > end{\r\n        return nil\r\n    }\r\n    mid := (start + end) >> 1\r\n    left := buildBST(start, mid-1)\r\n    root := &TreeNode{Val:h.Val}\r\n    h = h.Next\r\n    root.Left =left\r\n    root.Right = buildBST(mid+1, end)\r\n    return root\r\n}\r\n```\r\n时间复杂度：O(n)。\r\n空间复杂度：O(logn)。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922395746","body":"思路：\r\n自己写了一个方法，首先遍历两个链表的长度。通过判断最后一个节点是否为同一个节点来判断两个链表是否相交。\r\n但是这里没必要，因为要找第一个相交节点。 于是取差值，让长链表先走差值。 然后两个链表同时走，关键是判断当前链表是否为nil，否则同时向后移。若遍历完差值没发现相交点，则两个链表不相交\r\n\r\n```Go\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n    if headA == nil || headB == nil{\r\n        return nil\r\n    }\r\n    num1 := count(headA)\r\n    num2 := count(headB)\r\n    gab := abs(num1 - num2)\r\n       if num1 > num2{\r\n           for gab >0{\r\n               headA = headA.Next\r\n               gab--\r\n           }\r\n       }else{\r\n           for gab > 0{\r\n               headB = headB.Next\r\n               gab--\r\n           }  \r\n       }\r\n   \r\n   for headA != nil {\r\n       if headA == headB{\r\n           return headA\r\n       }\r\n       headA = headA.Next\r\n       headB = headB.Next\r\n   }\r\n   return nil\r\n}\r\n\r\nfunc count (head *ListNode) int{\r\n    sum := 0\r\n    p := head\r\n    for p != nil{\r\n        p = p.Next\r\n        sum++\r\n    }\r\n    return sum\r\n}\r\n\r\nfunc abs(x int) int{\r\n    if x < 0 {\r\n        return -x\r\n    }else{\r\n        return x\r\n    }\r\n}\r\n```\r\n时间复杂度：O(n+m)\r\n空间复杂度：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916534184","body":"### 解题思路\n因为数组num的长度太大，会越界，所以每一数位单独运算。把k先用字符串方法转换为各个数位的数组。用`carry`记录进位，每一个对应数位进行加法运算，结果存到链表头部。注意循环结束后再查看一下最终进位`carry`是否为0，不为0的话存到链表中。\n\n### 代码（java）\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        String str = String.valueOf(k); // Convert k to string, can also use Integer.toString(k)\n        String[] elements = str.split(\"\"); // Get individual digits as String format\n        int klen = elements.length;\n\n        int carry = 0;\n        LinkedList<Integer> result = new LinkedList<>();\n        int nlen = num.length;\n        int length = nlen > klen ? nlen : klen;\n\n        for (int i = 0; i < length; i++) {\n            int knum = i < klen ? Integer.parseInt(elements[klen - 1 - i]) : 0;\n            int cur = nlen - 1 - i;\n            int n = i < nlen ? num[cur] : 0;\n            result.addFirst((n + knum + carry) % 10);\n            carry = (n + knum + carry) / 10;\n        }\n\n        if (carry != 0) result.addFirst(carry);       \n        return result;\n    }\n}\n```\n\n**复杂度分析**\n\n令n为nums数组长度，字符串数组的长度为logk\n- 时间复杂度：O(max(n, logk)), 两个数组长度的最大值（最终循环次数）\n- 空间复杂度：O(n), 创建链表储存结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917266221","body":"### 解题思路\n遍历两次字符串：第一次正向遍历，计算每个字符和前面出现的特殊字符的最近距离；第二次反向遍历，计算每个字符和后面出现的特殊字符的最近距离。两次遍历过程中，把最短距离写入整数数组中。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int length = s.length();\n        int[] res = new int[length]; // create int array with size of the length of string\n        Arrays.fill(res, length); // initialize the array and fill with the length of string (the distance between two characters is always smaller than the length of string)\n\n        int idx = 0;\n        // traverse the array, and update the distance\n        for (int i = s.indexOf(c); i < length; i++) {\n            if (s.charAt(i) == c) idx = i;\n            if (Math.abs(idx - i) < res[i]) res[i] = Math.abs(idx - i);\n        }\n        // traverse the array in reverse order, and update the distance\n        for (int j = s.lastIndexOf(c); j >= 0; j--) {\n            if (s.charAt(j) == c) idx = j;\n            if (Math.abs(idx - j) < res[j]) res[j] = Math.abs(idx - j);\n        }\n\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n令n为字符串长度\n- 时间复杂度：O(n)，循环运行次数\n- 空间复杂度：O(n)，建立了整数数组储存结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917435398","body":"### 解题思路\n用数组来实现栈，再设置两个变量`maxSize`和`currentSize`分别记录数组最大长度和当前长度，用来快速判断栈是否已满，并且快速查找栈顶元素。\n\n### 代码\n\n```java\nclass CustomStack {\n\n    private int[] stack;\n    private int maxSize;\n    private int currentSize = 0;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (currentSize < maxSize) {\n            stack[currentSize] = x;\n            currentSize++; // remember to update currentSize\n        }\n    }\n    \n    public int pop() {\n        if (currentSize == 0) return -1;\n        currentSize--; // remember to update currentSize\n        return stack[currentSize];\n    }\n    \n    public void increment(int k, int val) {\n        int n = k < currentSize ? k : currentSize;\n        for (int i = 0; i < n; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n**复杂度分析**\n- 时间复杂度：push和pop操作O(1)，increment操作O(k)\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917677317","body":"### 解题思路\n用栈来解决。重复的部分满足格式`k[encoded_string]`，先将除`]`外的字符入栈，遇到`]`说明重复的部分出现，先出栈字母，再出栈`[`，最后出栈数字。根据数字将重复部分重新入栈。最后出栈所有字符获得字符串即为结果。\n\n### 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        for (char c: s.toCharArray()) {\n            if (c != ']') {\n                stack.push(c); // push characters into stack if it is not ']'\n            }\n            else {\n                StringBuilder sb = new StringBuilder();\n\t\t// get the repeated characters\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n\n                String sub = sb.toString();\n\t\t// pop '[' from stack\n                stack.pop();\n\n                sb = new StringBuilder();\n\t\t// get the repeated times\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n\n                int count = Integer.parseInt(sb.toString());\n\t\t// push the repeated characters back into stack\n                while (count > 0) {\n                    for (char element: sub.toCharArray()) {\n                        stack.push(element);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while (!stack.isEmpty()) {\n            res.insert(0, stack.pop());\n        }\n\n        return res.toString();\n    }\n}\n```\n\n**复杂度分析**\n\n令字符串长度为n\n- 时间复杂度：O(n)，需要遍历字符串\n- 空间复杂度：O(n)，创建栈储存字符","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918658348","body":"### 解题思路\n创建两个栈`in`和`out`分别储存入列元素和出列元素，`in`栈元素出栈然后入栈得到`out`栈，顺序相反，可以实现FIFO。当有元素入列时，push进`in`栈。当有元素出列时，先看`out`栈是否非空，如果为空将`in`栈中元素导入到`out`栈中，然后出列。\n\n### 代码\n\n```java\nclass MyQueue {\n\n    Stack<Integer> in;\n    Stack<Integer> out;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        in.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (out.isEmpty()) {\n            while(!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n        return out.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (out.isEmpty()) {\n            while(!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n**复杂度分析**\n- 时间复杂度：push和empty为O(1)，pop和peek平均O(1)，最坏O(n)\n- 空间复杂度：O(n)，使用了两个栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919684871","body":"### 解题思路\n使用单调栈。令`currentMax`为对应排序块中最大元素，我们在栈中只存`currentMax`，则所存的`currentMax`单调递增。如果新元素小于前面块的`currentMax`，新元素需要和前面的块合并，我们需要更新栈中保留的`currentMax`。最后返回栈的长度即为最多块数。\n\n### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new LinkedList<>();\n        for (int i = 0; i < arr.length; i++) {\n            if (!stack.isEmpty() && stack.peek() > arr[i]){\n                int currentMax = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\n                        stack.pop();\n                }\n                stack.push(currentMax);\n            }\n            else {\n                stack.push(arr[i]);\n            }    \n        }\n        return stack.size();\n    }\n}\n```\n\n**复杂度分析**\n\n令n为数组长度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920637936","body":"### 解题思路\n先将链表链接成环，之后再找到旋转之后的head，在head的前一个node和head之间断开\n\n### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        ListNode current = head;\n        ListNode previous = head;\n\n        if (head == null) return head;\n\n        int length = 1;\n\n        // find current tail and connect it to head\n        while (current.next != null) {\n            current = current.next;\n            length++;\n        }\n        current.next = head;\n\n        current = head;\n        // find the new head\n        for (int i = 0; i < length - k % length; i++) {\n            previous = current;\n            current = current.next;\n        }\n        // set the previous node as tail\n        previous.next = null;\n        return current;\n    }\n}\n```\n\n**复杂度分析**\n\n令n为链表长度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921355383","body":"### 解题思路\n用迭代方法，用`node1`和`node2`记录两个相邻的需要交换的nodes，同时记录`node1`之前node和`node2`之后node，按照交换后的正确顺序连接起来这4个nodes即可。注意最后要检查null pointer。\n还可以用递归方法。\n\n### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode node1 = head;\n        ListNode node2 = head.next;\n        ListNode pre = null;\n        head = node2;\n\n        while (node1 != null && node2 != null) {\n            ListNode temp = node2.next;\n            node2.next = node1;\n            node1.next = temp;\n            if (pre != null) pre.next = node2;\n            pre = node1;\n            if (temp == null) break;\n            else {\n                node1 = temp;\n                node2 = temp.next;\n            }\n        }\n        return head;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922144971","body":"### 解题思路\n递归，每次找到链表中点，建立`TreeNode`，中点左右分割得两个链表，然后继续找中点，建立`TreeNode`，分割链表。。。找中点最初想法是遍历链表求长度，然后算出中点位置，继续遍历找到中点，结果超时。后改为快慢指针找中点，只需要一次遍历。\n\n### 代码\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n\n        ListNode root;\n        ListNode left = head;\n        ListNode pre = null;\n        ListNode right = null;\n\n        ListNode fast = head;\n        ListNode slow = head;\n\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            pre = slow;\n            slow = slow.next;\n        }\n        root = slow;\n        right = root != null ? root.next : null;\n        pre.next = null;\n\n        return new TreeNode(root.val, sortedListToBST(left), sortedListToBST(right));\n    }\n}\n```\n\n**复杂度分析**\n\n令链表长度为N\n- 时间复杂度：O(NlogN)，运用递归，递归树深度为logN，每层操作数为N\n- 空间复杂度：O(logN)，递归树深度为logN，每个递归函数空间复杂度为O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922366819","body":"### 解题思路\n方法参考链表讲义\n\n方法1：双指针，最开始分别指向`headA`和`headB`，当指针走到终点的时候，更新指针指向另外链表的head。当两个指针指向的节点相同时，即找到交叉节点。此时指针走过了两个链表不相同的部分各一次，并且走过了一次两个链表相同部分，走的距离相等。\n\n方法2：哈希表，先遍历链表A，将节点存到哈希表中，再遍历链表B，找到第一个哈希表中出现的节点即为交叉节点。\n\n### 代码\n\n方法1：\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while (a != b) {\n            a = a != null ? a.next : null;\n            b = b != null ? b.next : null;\n            if (a == null && b == null) return null;\n            if (a == null) a = headB;\n            if (b == null) b = headA;\n        }\n         return a;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(1)\n\n\n方法2：\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> nodes = new HashSet<>();\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while (a != null) {\n            nodes.add(a);\n            a = a.next;\n        }\n\n        while (b != null) {\n            if (nodes.contains(b)) return b;\n            b = b.next;\n        }\n        return null;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(m)，建立了哈希表储存A中所有节点\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922517473","body":"### 解题思路\n参考链表讲义。\n\n方法一：快慢指针。`fast`每次前进两格，`slow`每次前进一格。如果无环则`fast`率先到达尾部null。如果有环，则在相遇时重置`fast`为`head`，每次前进一格，再次相遇节点即为开始入环的第一个节点。\n\n方法二：哈希表。用哈希表储存访问过的节点，遍历链表如果节点不在哈希表中则加入哈希表。第一个出现在哈希表的重复节点即为开始入环的第一个节点。如果遍历结束没有出现重复节点，则无环。\n\n### 代码\n\n方法一：\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode fast = head;\n        ListNode slow = head;\n\n        do {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == null || fast.next == null) return null;\n        } while (fast != slow);\n\n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }       \n        return fast;\n    }\n}\n```\n**复杂度分析**\n\n令n为链表长度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n方法二：\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        Set<ListNode> visited = new HashSet<>();\n        ListNode current = head;\n\n        while (current != null) {\n            if (visited.contains(current)) return current;\n            visited.add(current);\n            current = current.next;\n        }\n        return null;        \n    }\n}\n```\n**复杂度分析**\n\n令n为链表长度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZJP1483469269":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916534668","body":"#### 思路\n对数组与k进行按位加 保留进位位，并与下一位的k和数组相加 最后判断k是否加完，若没有则直接加进队列\n#### 代码\n    class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        int c=0;\n        int a=0;\n        LinkedList<Integer> ans = new LinkedList<>();\n        for(int i=len-1;i>=0;i--){\n            a = (num[i] + k%10 + c )%10;\n            c = (num[i] + k%10 + c)/10;\n            k = k/10;\n            ans.addFirst(a);\n        }\n        if(c!=0){\n            k=k+c;\n        }\n        if(k!=0){\n            while(k!=0){\n                ans.addFirst(k%10);\n                k/=10; \n            }\n        }\n        return ans;\n    }\n}; \n\n####复杂度分析\n时间复杂度：O(n) n为数组长度\n空间复杂度：O(n) n为数组长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917319847","body":"#### 思路\n对字符串从左到右遍历一次，对于c字符右侧的非c字符，在对应的数组中加1，然后对字符串从右到左遍历一次，对于c字符左侧的非c字符，在对应的数组中减1并与第一次遍历得到的数据进行比较取较小值填入数组。\n\n#### 代码\n    class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int p =s.indexOf(c),q=s.lastIndexOf(c);\n        for(int i=p;i<len-1;i++){\n            res[i+1]=res[i]+1;\n            if(s.charAt(i+1)==c)\n                res[i+1]=0;\n        }\n        for(int i=q;i>0;i--){\n           \n            if(res[i-1]!=0)\n                res[i-1]=res[i]+1<res[i-1] ? res[i]+1 : res[i-1];\n            else\n                res[i-1]=res[i]+1;   \n            if(s.charAt(i-1)==c){\n                res[i-1]=0;\n            } \n\n        }\n        return res;\n    }\n    }   \n#### 复杂度分析\n时间复杂度：O(N）\n空间复杂度：O(N)N为字符串长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917534456","body":"#### 思路\n采用数组实现栈的操作，top一直指向栈顶，若栈为空top=-1\n#### 代码\n    class CustomStack {\n    int[] stack;\n    int top=-1;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top<stack.length-1){\n            stack[++top]=x;\n        }\n    }\n    \n    public int pop() {\n        if(top>=0){\n            return stack[top--];\n        }\n        else return -1;\n    }\n    \n    public void increment(int k, int val) {\n        if(top<k){\n            for(int i=0;i<=top;i++){\n                stack[i]+=val;\n            }\n        }\n        else{\n            for(int i=0;i<k;i++){\n                stack[i]+=val;\n            }\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n#### 复杂度分析\n入栈：时间复杂度O(1)\n出栈：时间复杂度O(1)\nincrement：时间复杂度O(min(k,stack.length))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917980911","body":"#### 思路\n使用栈对括号进行匹配，每次将字符串与数字入栈，遇到】进行一次出栈，并对字符串进行运算。\n#### 代码\n    class Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n\n\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n#### 复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918986868","body":"#### 思路\n使用两个栈，入队时将栈2的值压入栈1中，然后将入队值压入栈2，再将栈1值压回栈2；\n出队时从栈2pop\n队首元素即为栈2栈顶元素\n队是否为空与栈2是否为空等价\n#### 代码\n    class MyQueue {\n\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        froma2b(stack2,stack1);\n        stack2.push(x);\n        froma2b(stack1,stack2);\n\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        return stack2.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        return stack2.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack2.empty();\n    }\n\n    public void froma2b(Stack a,Stack b){\n        while(!a.empty()){\n            b.push(a.pop());\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n#### 复杂度分析\n入队：时间复杂度：O（2N）\n           空间复杂度：O（N）\n出队：时间复杂度：O（1）\n           空间复杂度：O（1）\n队首：时间复杂度：O（1）\n           空间复杂度：O（1）\n是否为空：时间复杂度：O（1）\n                  空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919953789","body":"#### 思路\n找出尽可能长的子数组 使得子数组的第一位大于最后一位，将这个子数组看作一个块\n#### 代码\n    class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for (int num : arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                int cur = stack.removeLast();\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}\n#### 复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920677979","body":"#### 思路\n使用双指针，第一个指针先走k%n步，n为链表长度，然后第二个指针与第一个指针一起走，直到第一个指针指向链表结尾，这样得到第二个指针就指向倒数第k个node\n#### 代码\n    class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        ListNode p=head,q=head,n=head;\n        int i=0,j=0;\n        if(head==null||k==0)\n            return head;\n        while(n.next!=null){\n            n=n.next;\n            j++;\n        }\n\n        while(p.next!=null){\n            if(i<k%(j+1)){\n                p = p.next;\n            }else{\n                p=p.next;\n                q=q.next;\n            }\n            i++;\n        }\n        p.next=head;\n        head = q.next;\n        q.next=null;\n        return head;\n        }\n    }\n#### 复杂度分析\n时间复杂度：O（n）\n空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921519401","body":"#### 思路\n使用三个指针记录节点，一个记录前一组数据的第一个位置，一个记录交换的那组数据的第一个位置，另一个记录交换的那种数据的第二个位置\n#### 代码\n    class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head==null) return head;\n        if(head.next==null) return head;\n        ListNode l=head,h=head.next,n=null;\n        head = h;\n        while(l.next!=null){\n            \n            if(h.next==null)\n            {\n                l.next=h.next;\n                h.next = l;\n                if(n==null){\n                    n = l;\n                }else{\n                    n.next = h;\n                }\n            }\n            else if(h.next.next==null)\n            {\n                l.next=h.next;\n                h.next = l;\n                if(n==null){\n                    n = l;\n                }else{\n                    n.next = h;\n                }\n                l=l.next;\n            }\n            else{\n                if(n==null){\n                    n = l;\n                }\n                n.next = h;\n                n = l;\n                l.next = h.next;    \n                h.next =l;\n                l = l.next;\n                h = l.next;\n            }\n\n        }\n        return head;\n\n    }\n    }\n#### 复杂度分析\n时间复杂度：O（n)\n空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922164762","body":"#### 思路\n使用快慢指针找到链表中心，并加入树顶，将链表分成两个链表，重复前面过程\n#### 代码\n    class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head==null) return null;\n        if(head.next==null) return new TreeNode(head.val);\n        ListNode l=head,h=head,pre =null;\n        while(h.next!=null){\n           h = h.next.next!=null?h.next.next:h.next;\n           pre = l;\n           l=l.next;\n        }\n        TreeNode root=new TreeNode(l.val);\n        pre.next=null;\n        ListNode rhead = l.next;\n\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(rhead);\n        return root;\n    }\n    }\n#### 复杂的分析\n时间复杂度：O（Nlog2N）\n空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922480124","body":"#### 思路\n先用四个指针寻找两个链表共同长度的串，然后用滑窗确定相同的串\n#### 代码\n    public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1=headA,p2=headA,q1=headB,q2=headB;\n        while(q2.next!=null&&p2.next!=null){\n            q2 = q2.next;\n            p2 = p2.next;\n        }\n        while(q2.next!=null){\n            q1=q1.next;\n            q2=q2.next;\n        }\n        while(p2.next!=null){\n            p1=p1.next;\n            p2=p2.next;\n        }\n        if(q2.val!=p2.val) return null;\n        q2=q1;\n        p2=p1;\n        while(q2.next!=null||p2.next!=null){\n            if(p1!=q1){\n                p1=p2.next;\n                q1=q2.next;\n                p2=p2.next;\n                q2=q2.next;\n            }else{\n                p2=p2.next;\n                q2=q2.next;\n            }\n        }\n        return p1;\n\n    }\n    }\n#### 复杂度分析\n时间复杂度：O（n）\n空间复杂度：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mozro0327":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916536901","body":"## 思路\r\n\r\n+ 当前位 = 数字A + 数字B + 进位\r\n+ 利用 k 作为进位和数字B的和\r\n\r\n## 代码\r\n\r\n~~~ cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> result;\r\n        int size = num.size(), sum = 0;\r\n        for (int i = size - 1; i >= 0 || k > 0; i--, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            result.push_back(k % 10);\r\n        }\r\n        reverse(result.begin(), result.end());\r\n        return result;\r\n    }\r\n};\r\n\r\n~~~\r\n\r\n## 复杂度分析\r\n\r\n+ 空间复杂度 `O(n)`\r\n+ 时间复杂度`O(max(n, logk))`\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917361461","body":"## 思路\r\n\r\n+ 由于 c 在 s 中出现的位置不会改变，可以将 c 的位置存储起来\r\n+ 挨个遍历 s 中的字符，寻找出最近的 c，并将其写入结果 vector 中\r\n\r\n## 代码\r\n\r\n~~~ cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int size = s.size();\r\n        vector<int> result(size, size);\r\n        vector<int> indexs;\r\n        for (int i = 0; i < size; i++) {\r\n            if (s[i] == c) {\r\n            indexs.push_back(i);\r\n            }\r\n        }\r\n        for (int i = 0; i < size; i++) {\r\n            if (s[i] == c) {\r\n            result[i] = 0;\r\n            continue;\r\n            }\r\n            for (int j = 0; j < indexs.size(); j++) {\r\n            int dist = abs(i - indexs[j]);\r\n            if (dist > result[i]) {\r\n                break;\r\n            }\r\n            result[i] = dist;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};\r\n~~~\r\n\r\n## 时空复杂度\r\n\r\n+ 时间复杂度：`O(n * indexs.size())`\r\n+ 空间复杂度：`O(indexs.size())`\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917627610","body":"## 思路\r\n\r\n+ 利用 `vector` 实现一个栈\r\n+ 用模拟法实现增量操作\r\n\r\n## 代码\r\n\r\n~~~ cpp\r\nclass CustomStack {\r\npublic:\r\n    vector<int>nums;\r\n    int top;\r\n\r\n    CustomStack(int maxSize) {\r\n        nums.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top != nums.size() - 1) {\r\n            top++;\r\n            nums[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        int tmp = nums[top];\r\n        top--;\r\n        return tmp;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim = min(k, top + 1);\r\n        for (int i = 0; i < lim; ++i) {\r\n            nums[i] += val;\r\n        }\r\n    }\r\n};\r\n~~~\r\n\r\n## 复杂度分析\r\n\r\n+ 时间复杂度\r\n  1. `O(1)`\r\n  2. `O(1)`\r\n  3. `O(n)`\r\n+ 空间复杂度\r\n  + `O(n)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916539064","body":"## 989. Add to Array-Form of Integer\n\nThe **array-form** of an integer `num` is an array representing its digits in left to right order.\n\n- For example, for `num = 1321`, the array form is `[1,3,2,1]`.\n\nGiven `num`, the **array-form** of an integer, and an integer `k`, return *the **array-form** of the integer* `num + k`.\n\n**Example 1:**\n\n```\nInput: num = [1,2,0,0], k = 34\nOutput: [1,2,3,4]\nExplanation: 1200 + 34 = 1234\n```\n\n## Note\n\n1. O(n), O(n), `n is max(n.length,k.digitsNum)`\n   1. **From right to left**, pick the digits from the num array and k to construct the result array; Reverse the result array when returning.\n   2. CurrentValue is comprised of value from num, k and carry;Keep running the loop **as long as there is a value in num, k or carry**;\n2. Problems:\n   1. The num array could be too big to perform normal addition which leads to a totally wrong answer. \n   2. The summation of num array could be less than k which means that we may run out of the num array first.\n   3. Never forget carry.\n   4. The division in JS won’t give you an Int, please use `Math.floor()`.\n\n```js\nvar addToArrayForm = function(num, k) {\n    let res=[];\n    let carry=0;\n    let rightIndex=num.length-1;\n    \n    while(rightIndex>=0 || k>0 || carry>0){\n        let currentSum=rightIndex>=0?num[rightIndex]+carry+ k%10:carry+ k%10;\n        k=Math.floor(k/10);\n        carry=Math.floor(currentSum/10)\n        res.push(currentSum%10);\n        rightIndex--;\n    }\n  \n    return res.reverse();\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917348991","body":"## 821. Shortest Distance to a Character\n\nGiven a string `s` and a character `c` that occurs in `s`, return *an array of integers* `answer` *where* `answer.length == s.length` *and* `answer[i]` *is the **distance**from index* `i` *to the **closest** occurrence of character* `c` *in* `s`.\n\nThe **distance** between two indices `i` and `j` is `abs(i - j)`, where `abs` is the absolute value function.\n\n**Example 2:**\n\n```\nInput: s = \"aaab\", c = \"b\"\nOutput: [3,2,1,0]\n```\n\n## Note\n\n1. O(n*m), O(m+n), n is the length of the string, m is the occurrence of c. \n   1. Iterate the string s to get all the indices of c\n   2. Iterate the string s again to fill the result array by comparing current index with all the indices in Step 1 to get a minimal.\n\n```js\nvar shortestToChar = function(s, c) {\n    let indicesOfC=[];\n    let res=[];\n    \n    for(let i=0;i<s.length;i++){\n        if(s[i]===c) indicesOfC.push(i);\n    }\n    \n    for(let j=0;j<s.length;j++){\n        let currDistance=s.length;\n        for(let k of indicesOfC){\n            currDistance=Math.min(currDistance,Math.abs(j-k));\n        }\n        res.push(currDistance);\n    }\n    \n    return res;\n};\n```\n\n2. O(n), O(n), n is the length of the string.\n   1. Use a prev index to remember to previous occurring index of c.\n   2. Add the distance of prev and to res array.\n   3. Loop the string reversely, change the res array if there is a minimal.\n\n```js\nvar shortestToChar = function(s, c) {\n    let res=[];\n    let prev=Infinity;\n    \n    for(let i=0;i<s.length;i++){\n        if(s[i]===c) prev=i;\n        res[i]=Math.abs(prev-i);\n    }\n    \n    prev=Infinity;\n    for(let j=s.length-1;j>=0;j--){\n        if(s[j]===c) prev=j;\n        res[j]=Math.min(res[j],Math.abs(prev-j));\n    }\n    \n    return res;\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917495154","body":"## 1381. Design a Stack With Increment Operation\n\nDesign a stack which supports the following operations.\n\nImplement the `CustomStack` class:\n\n- `CustomStack(int maxSize)` Initializes the object with `maxSize` which is the maximum number of elements in the stack or do nothing if the stack reached the `maxSize`.\n- `void push(int x)` Adds `x` to the top of the stack if the stack hasn't reached the `maxSize`.\n- `int pop()` Pops and returns the top of stack or **-1** if the stack is empty.\n- `void inc(int k, int val)` Increments the bottom `k` elements of the stack by `val`. If there are less than `k` elements in the stack, just increment all the elements in the stack.\n\n## Note\n\n1. Push O(1), Pop O(1), Increment O(n), n is min(this.size,k);\n2. Space Complexity: O(n)\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize=maxSize;\n    this.size=0;\n    this.stack=[];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.size!==this.maxSize){\n        this.stack.push(x);\n        this.size++;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.size===0) return -1;\n    this.size--;\n    return this.stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=Math.min(k-1,this.size-1);i>=0;i--){\n        this.stack[i]+=val;\n    }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918335481","body":"## 394. Decode String\n\nGiven an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there won't be input like `3a` or `2[4]`.\n\n \n\n**Example 1:**\n\n```\nInput: s = \"3[a]2[bc]\"\nOutput: \"aaabcbc\"\n```\n\n## Note\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack=[];\n    for(let char of s){\n        if(char===']'){\n            let repeatCount='';\n            let repeatStr='';\n            let curr=stack.pop();\n            while(curr!=='['){\n                repeatStr=curr+repeatStr;\n                curr=stack.pop()\n            }\n            curr=stack.pop();\n            while(!isNaN(curr)){\n                repeatCount=curr+repeatCount;\n                curr=stack.pop() \n            }\n            stack.push(curr);\n            stack.push(repeatStr.repeat(repeatCount));\n        }else{\n            stack.push(char);\n        }\n    }\n    \n    return stack.join('');\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919276821","body":"## 232.Implement Queue using Stacks\n\nImplement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).\n\nImplement the `MyQueue` class:\n\n- `void push(int x)` Pushes element x to the back of the queue.\n- `int pop()` Removes the element from the front of the queue and returns it.\n- `int peek()` Returns the element at the front of the queue.\n- `boolean empty()` Returns `true` if the queue is empty, `false` otherwise.\n\n**Notes:**\n\n- You must use **only** standard operations of a stack, which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.\n- Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\n\n \n\n**Example 1:**\n\n```\nInput\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 1, 1, false]\n\nExplanation\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n```\n\n## Note\n\n1. Two stacks,\n   1. Push O(1): Stack1 is used to store elements when push. \n   2. Pop O(n): When pop is called, check whether Stack 2 is empty. If so, iterate all the elements in Stack 1 and push them into Stack2. Return the pop of Stack 2.\n   3. Peek O(n)\n   4. isEmpty O(1);\n2. Problems:\n   1. `if(stack)` is not working, but `if(stack.length>0)` works.\n\n```js\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.stack1=[];\n    this.stack2=[];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.stack2.length>0) return this.stack2.pop();\n    while(this.stack1.length>0){\n        this.stack2.push(this.stack1.pop());\n    }\n    if(this.stack2.length>0) return this.stack2.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.stack2.length>0) return this.stack2[this.stack2.length-1];\n    while(this.stack1.length>0){\n        this.stack2.push(this.stack1.pop());\n    }\n    if(this.stack2.length>0) return this.stack2[this.stack2.length-1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return (this.stack1.length===0 && this.stack2.length===0)\n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920612725","body":"## 61. Rotate List\n\nGiven the `head` of a linked list, rotate the list to the right by `k` places.\n\n \n\n**Example 1:**\n\n![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)\n\n```\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n```\n\n## Note\n\n1. O(n), O(1)\n   1. Get the length of LinkedList\n   2. Decrease K by module operation `k=k%count`\n   3. How to get Kth node from the bottom of the linkedList\n      1. Set two pointers, fast and slow\n      2. fast moves first while decreasing k\n      3. When `k<=0` , slow begins to move\n      4. Until fast reaches the last node\n2. Problem;\n   1. Decrease k by module or you could not pass the tests with big k value\n   2. Use fast and slow pointer to determine the final position which should be moved.\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if(!head || !head.next) return head;\n    let dummy=new ListNode(0);\n    dummy.next=head;\n    let countNode=head;\n    \n    let count=0;\n    while(countNode){\n        count++;\n        countNode=countNode.next;\n    }\n    \n    k=k%count;\n    \n    let slow=head;\n    let fast=head;\n    \n    while(fast.next){\n        if(k<=0) slow=slow.next;\n        k--;\n        fast=fast.next;\n    }\n    \n    fast.next=dummy.next;\n    dummy.next=slow.next;\n    slow.next=null;\n    \n    return dummy.next;\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"NorthSeacoder":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916540032","body":"```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n    const res = [];\n    let carry = 0;\n    num.reverse();\n    const strK = String(k).split('').reverse().join('');\n    const maxLen = Math.max(num.length, strK.length)\n    for (let index = 0; index < maxLen; index++) {\n        let value = Number(strK[index] ? strK[index] : 0) + (num[index] ? num[index] : 0) + carry;\n        if (value >= 10) {\n            value %= 10;\n            carry = 1\n        } else {\n            carry = 0\n\n        }\n        res.push(value);\n    }\n    if (carry) res.push(carry)\n    return res.reverse()\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917312078","body":"```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    const res = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        const dis = getDis(i, s, c);\r\n        res.push(dis)\r\n    }\r\n    return res\r\n};\r\nconst getDis = (i, s, c) => {\r\n    let l = i, r = i, dis = Infinity;\r\n    if (s[i] === c) return 0;\r\n    while (l >= 0) {\r\n        if (s[l] === c) {\r\n            dis = Math.min(dis, i - l);\r\n            break;\r\n        }\r\n        l--;\r\n    }\r\n    while (r < s.length) {\r\n        if (s[r] === c) {\r\n            dis = Math.min(dis, r - i);\r\n            break;\r\n        }\r\n        r++;\r\n    }\r\n    return dis\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917640513","body":"```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.list = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.list.length < this.maxSize) {\n        this.list.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    const item = this.list.pop()\n    return item ?? -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    for (let i = 0; i < k && i < this.list.length; i++) {\n        this.list[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918213664","body":"```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n    const stack = [];\n    for (let char of s) {\n        if (char === ']') {\n            let repeatRes = '', repeats = '';\n            let str = stack.pop();\n            while (str !== '[') {\n                repeatRes = str + repeatRes;\n                str = stack.pop()\n            }\n            let num = stack.pop()\n            while (!isNaN(num)) {\n                repeats = num + repeats;\n                num = stack.pop()\n            }\n            stack.push(num);//多弹出的字符串\n            repeatRes = repeatRes.repeat(parseInt(repeats));\n            stack.push(repeatRes)\n\n        } else {\n            stack.push(char)\n        }\n    }\n    return stack.join('')\n\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919228958","body":"```javascript\n\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function () {\n    this.stack = [];\n    this._stack = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.stack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    let cur = null;\n    while (cur = this.stack.pop()) {\n        this._stack.push(cur)\n    }\n    const res = this._stack.pop();\n    while (cur = this._stack.pop()) {\n        this.stack.push(cur)\n    }\n    return res\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    return this.stack[0]\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    return this.stack.length === 0\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920067441","body":"```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n    let stack = [];\n\n    for (let i = 0; i < arr.length; i++) {\n        if (stack.length === 0 || stack[stack.length - 1] <= arr[i]) {\n            stack.push(arr[i])//单调递增栈,栈中的每个值就是一个分块中的极大值\n        } else {//当前值小于栈顶元素即tem<arr[i]\n            //临时保存单调栈中最大值(当前值可以加入栈顶元素所代表的块)\n            let tem = stack.pop();\n            //一个元素代表一个块,当前值此时压入最大值所在的块中,该块的区间为[当前值,最大值]\n            //剩下单调栈中不应该存在大于当前值的元素\n            //因此剩余单调栈中大于当前值的元素意味着可以压入新块中\n            while (stack[stack.length - 1] > arr[i]) {\n                stack.pop()\n            }\n            stack.push(tem)\n        }\n    }\n    return stack.length\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920895447","body":"```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n    if (!head || !head.next) return head\n    let num = 2;\n    while (k > 0) {\n        let cur = head;\n        while (cur.next.next) {\n            cur = cur.next;\n            num++\n        }\n        if (k > num) k = k % num;\n        if (k > 0) {\n            let tail = cur.next;\n            cur.next = null;\n            tail.next = head;\n            head = tail\n            k--;\n        }\n\n    }\n    return head\n};\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921780012","body":"```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n    if (!head || !head.next) return head;\n    let res = head.next;\n    let pre = new ListNode(0, head);\n    let cur = head;\n    while (cur && cur.next) {\n        let next = cur.next;\n        let nextnext = next.next;\n        cur.next = nextnext;\n        next.next = cur;\n        pre.next = next;\n        \n        pre = cur;\n        cur = cur.next;\n    };\n    return res\n};\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922466105","body":"```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n    let pointA = headA, pointB = headB;\n    while (pointA !== pointB) {\n        pointA = pointA ? pointA.next : headB;\n        pointB = pointB ? pointB.next : headA;\n    }\n    return pointA\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurallalala":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916541347","body":"### 代码\n```\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        num_k = []\n        while k > 0:\n            num_k.insert(0, k%10)\n            k = k // 10\n        l, lk = len(num), len(num_k)\n        if l < lk:\n            num, num_k = num_k, num\n            l, lk = lk, l\n        carry = 0\n        for i in range(max(l, lk)):\n            s = carry\n            l_idx, lk_idx = l-i-1, lk-i-1\n            s += num[l_idx]\n            if lk_idx >= 0:\n                s += num_k[lk_idx]\n            if s >= 10:\n                carry = s // 10\n                s = s % 10\n            else:\n                carry = 0\n            num[l_idx] = s\n        if carry > 0:\n            num.insert(0, carry)\n        return num\n```\n### 复杂度分析\n* 时间复杂度O(N)\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917327549","body":"### 代码\n```\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0]*n\n        carry = -1\n        for i in range(n):\n            if s[i] == c:\n                carry = i\n                res[i] = i\n            else:\n                res[i] = carry\n        carry = -1\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                carry = i\n                res[i] = 0\n            else:\n                if res[i] == -1 and carry != -1:\n                    res[i] = abs(carry-i)\n                elif res[i] != -1 and carry == -1:\n                    res[i] = abs(res[i]-i)\n                else:\n                    res[i] = min(abs(res[i]-i), abs(carry-i))\n        return res\n                   \n```\n### 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917537886","body":"### 代码\n```\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.list = []\n        self.maxSize = maxSize\n        self.size = 0\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if self.size+1 <= self.maxSize:\n            self.list.append(x)\n            self.size += 1\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.size > 0:\n            res = self.list[-1]\n            self.list.pop()\n            self.size -= 1\n            return res\n        else:\n            return -1\n        \n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        tmp = []\n        while self.list:\n            tmp.append(self.list[-1])\n            self.list.pop()\n        for i in range(k):\n            if not tmp:\n                break\n            self.list.append(tmp[-1] + val)\n            tmp.pop()\n        while tmp:\n            self.list.append(tmp[-1])\n            tmp.pop()\n```\n### 复杂度分析\n* 时间复杂度\npush O(1)\npop O(1)\nincr O(n)\n* 空间复杂度\npush O(1)\npop O(1)\nincr O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917724388","body":"### 代码\n```\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for c in s:\n            if c != \"]\":\n                stack.append(c)\n            else:\n                last = stack[-1]\n                cut = \"\"\n                while last != \"[\":\n                    stack.pop()\n                    cut = last + cut\n                    last = stack[-1]\n                stack.pop()\n                last = stack[-1]\n                digits = \"\"\n                while last.isdigit():\n                    stack.pop()\n                    digits = last + digits\n                    if not stack:\n                        break\n                    last = stack[-1]\n                stack.append(int(digits)*cut)\n        return ''.join(stack)\n```\n### 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918748501","body":"### 代码\n```\nclass MyQueue(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1[-1])\n                self.stack1.pop()\n        res = self.stack2[-1]\n        self.stack2.pop()\n        return res\n\n    def peek(self):\n        \"\"\"\n        Get the front element.\n        :rtype: int\n        \"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1[-1])\n                self.stack1.pop()\n        res = self.stack2[-1]\n        return res\n\n    def empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        return not self.stack1 and not self.stack2\n```\n### 复杂度分析\n* 时间复杂度：O(N)\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919654062","body":"### 代码\r\n```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        arr_sorted = sorted(arr)\r\n        ct = 0\r\n        s, s_sorted = 0, 0\r\n        for i in range(len(arr)):\r\n            s += arr[i]\r\n            s_sorted += arr_sorted[i]\r\n            if s == s_sorted:\r\n                ct += 1\r\n                s, s_sorted = 0, 0\r\n        return ct\r\n```\r\n### 复杂度\r\n* 时间复杂度 O(nlogn)\r\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920537881","body":"### 代码\n```\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or k==0:\n            return head\n        n = 1\n        p = head\n        while p.next:\n            p = p.next\n            n += 1\n        last = p\n        k = k % n\n        if k==0:\n            return head\n        p = head\n        for i in range(n-k-1):\n            p = p.next\n        first = p.next\n        p.next = None\n        last.next = head\n        return first\n```\n### 复杂度\n* 时间复杂度：O(N)\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921423177","body":"### 代码\n```\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        pre, nxt = None, None\n        first, second = head, head.next\n        origin_head = second\n        while second:\n            nxt = second.next\n            first.next = nxt\n            if pre:\n                pre.next = second\n            second.next = first\n            pre = first\n            first = nxt\n            if first:\n                second = first.next\n            else:\n                break\n        return origin_head\n```\n### 复杂度\n* 时间复杂度：O(N)\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922184165","body":"### 代码\n```\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n        nums = []\n        p = head\n        while p:\n            nums.append(p)\n            p = p.next\n        return self.buildTree(nums)\n    \n    def buildTree(self, nums):\n        if not nums:\n            return None\n        mid = len(nums) // 2\n        root = TreeNode(nums[mid].val)\n        root.left = self.buildTree(nums[:mid])\n        root.right = self.buildTree(nums[mid+1:])\n        return root\n```\n### 复杂度\n* 时间复杂度 O(N)\n* 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922415809","body":"### 代码\n```\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        a_len, b_len = 0, 0\n        pa, pb = headA, headB\n        while pa:\n            pa = pa.next\n            a_len += 1\n        while pb:\n            pb = pb.next\n            b_len += 1\n        pmax = headB if b_len > a_len else headA\n        pmin = headB if b_len <= a_len else headA\n        diff = abs(a_len-b_len)\n        while diff > 0:\n            pmax = pmax.next\n            diff -= 1\n        while pmin:\n            if pmin == pmax:\n                return pmin\n            else:\n                pmin = pmin.next\n                pmax = pmax.next\n        return None\n```\n### 复杂度\n* 时间复杂度：O(N)\n* 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingliufilms":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916548236","body":"##  当前的问题：\r\n\r\n### 题目 run 的时候被 accept 了，但是 submit 的时候说是答案是错的。新手不知道该怎么改进。先把卡打了再说。如果有大佬看到，可以指点迷津吗？谢谢。我会继续改进。\r\n\r\n##  思路: \r\n\r\n- 先把当前 array 中转 string 再转回 integer, numInt；\r\n- 把 numInt 和 k 加起来成和, sum；\r\n- 利用 sum 除以 10 的余数来加入到新 array 的尾部\r\n\r\n## 代码 Javascript \r\n\r\n```\r\nconst addToArrayForm = function(num, k) {\r\n    const numInt = parseInt(num.join(''));\r\n    let sum = numInt + k;\r\n    const resultArray = [];\r\n    while (sum >= 0) {\r\n           let el = sum % 10 ;\r\n           sum = Math.floor(sum / 10);\r\n           resultArray.splice(0, 0, el);\r\n           }\r\n    return resultArray;\r\n```\r\n\r\n##  复杂度分析\r\n\r\n时间与空间均为 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917193739","body":"# link: \r\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\r\n\r\n# 知识弱点：\r\n\r\n- nested for loops (eg. i & j): how it works is that 到 i 某一个 index, 遍历一遍 j 的所有 indices,然后再移到 i 的下一个 index\r\n\r\n## （抄）思路 （没有自己做出来，看的别人的答案）:\r\n\r\n- 先把 c 找出来，把 c 的 indices 存入数组；\r\n- 遍历整个数组，每一个 index 与 c 对应的 index 求绝对值到差， 来找到每一个 index 与最近一个 c 的 距离；\r\n- 把这些距离存入新的空数组\r\n\r\n## 代码 Javascript\r\n\r\n```javascript\r\nconst shortestToChar = function (s, c) {\r\n  const indices = [];\r\n  const distances = [];\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      indices.push(i);\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    let min = Number.MAX_SAFE_INTEGER;\r\n    for (let j = 0; j < indices.length; j++) {\r\n      let distance = Math.abs(indices[j] - i);\r\n      if (distance < min) {\r\n        min = distance;\r\n      }\r\n    }\r\n    distances.push(min);\r\n  }\r\n\r\n  return distances;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间 O(n2)\r\n\r\n空间 不会算\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917518259","body":"# link:\r\n\r\nhttps://leetcode.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 思路:\r\n\r\n- 创建一个 obj, key 为 array（stack) 值为空， key 为 maxSize 值为 argument maxSize\r\n- push: 如果已是 maxSize，直接 return; 不然到话，push x;\r\n- pop: 如果 stack 为空，直接 return; 否则，pop 的 top 的值\r\n- increment: 取 stack 的长度与 k 的最小值， 遍历这个最小值长度的bottom stack, increment val\r\n\r\n## 代码 Javascript\r\n\r\n```javascript\r\nconst CustomStack = function (maxSize) {\r\n  this.arr = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.arr.length === this.maxSize) return;\r\n  this.arr.push(x);\r\n};\r\n\r\nCustomStack.prototype.pop = function () {\r\n  if (this.arr.length === 0) return -1;\r\n  return this.arr.pop();\r\n};\r\n\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < Math.min(this.arr.length, k); i++) {\r\n    this.arr[i] += val;\r\n  }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间 o(n)\r\n空间 o(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918273643","body":"# link:\r\n\r\nhttps://leetcode.com/problems/decode-string/\r\n\r\n## 代码 Javascript\r\n\r\n```javascript\r\nconst decodeString = function (str) {\r\n  let stack = [];\r\n  let currStr = \"\";\r\n  let currNum = 0;\r\n\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (str[i] === \"[\") {\r\n      stack.push(currStr);\r\n      stack.push(currNum);\r\n      currStr = \"\";\r\n      currNum = 0;\r\n    } else if (str[i] === \"]\") {\r\n      let prevNum = stack.pop();\r\n      let prevStr = stack.pop();\r\n      currStr = prevStr + currStr.repeat(prevNum);\r\n    } else if (str[i] >= \"0\" && str[i] <= \"9\") {\r\n      currNum = currNum * 10 + Number(str[i]);\r\n    } else {\r\n      currStr += str[i];\r\n    }\r\n  }\r\n  return currStr;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间 O(N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918701188","body":"# link:\r\n\r\nhttps://leetcode.com/problems/implement-queue-using-stacks/\r\n\r\n## 代码 Javascript\r\n\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nconst MyQueue = function () {\r\n  this.front = [];\r\n  this.back = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue.\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n  this.back.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n  if (!this.front.length) {\r\n    while (this.back.length) {\r\n      this.front.push(this.back.pop());\r\n    }\r\n  }\r\n  return this.front.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n  if (!this.front.length) {\r\n    while (this.back.length) {\r\n      this.front.push(this.back.pop());\r\n    }\r\n  }\r\n  return this.front[this.front.length - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n  return !this.front.length && !this.back.length;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间 o(1)\r\n空间 o(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919623423","body":"## link:\r\n\r\nhttps://leetcode.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n## 目前的问题：\r\n\r\n可能是因为要 sort array, 现在运行挺慢的。Runtime: 127 ms, faster than 12.50% of JavaScript online submissions for Max Chunks To Make Sorted II.\r\n\r\n## 思路:\r\n\r\n- 举例来说，如果 array【2，1，5】要 target 【1，2，5】，可以看 subarray 的和\r\n- 【2】的和 不等与【1】的和，但是【2，1】的和等于【1，2】的和；【2，1，5】的和也等于【1，2，5】的和---这样就割出了两个 chunks\r\n- 所以，如果能找出所有 length 相同的 argument array 和 sorted array 的 subarray 的 每一次和的重叠，就找出了 max chunks\r\n\r\n## 代码 Javascript\r\n\r\n```javascript\r\nconst maxChunksToSorted = function (arr) {\r\n  // [...arr] does not mutate the array\r\n  const sortedArr = [...arr].sort((a, b) => a - b);\r\n  let sum1 = 0;\r\n  let sum2 = 0;\r\n  let count = 0;\r\n  for (let i = 0; i < arr.length; i++) {\r\n    sum1 += arr[i];\r\n    sum2 += sortedArr[i];\r\n    if (sum1 == sum2) {\r\n      count += 1;\r\n    }\r\n  }\r\n  return count;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间 O(n)\r\n空间 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920273035","body":"## link:\r\n\r\nhttps://leetcode.com/problems/rotate-list/\r\n\r\n## 代码 Javascript\r\n\r\n```javascript\r\nconst rotateRight = function (head, k) {\r\n  //find the length\r\n  let length = 1;\r\n  let pt = head;\r\n  while (pt && pt.next) {\r\n    length++;\r\n    pt = pt.next;\r\n  }\r\n\r\n  //we're using modulo for the edge case of if the length is smaller than k\r\n  k = k % length;\r\n\r\n  //edge case -> if k is 0, we don't need a rotation\r\n  if (k === 0) {\r\n    return head;\r\n  }\r\n\r\n  //find the new tail\r\n  let newTail = head;\r\n  let spaces = length - k;\r\n  while (spaces > 1) {\r\n    spaces--;\r\n    newTail = newTail.next;\r\n  }\r\n\r\n  //save the new head and reset appropriately\r\n  let newHead = newTail.next;\r\n  newTail.next = null;\r\n  pt.next = head;\r\n  return newHead;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间 O(n)\r\n空间 O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921219461","body":"## link:\r\n\r\nhttps://leetcode.com/problems/swap-nodes-in-pairs/\r\n\r\n## 思路:\r\n\r\n- 还没有看懂这个 recursion 是怎么来的\r\n\r\n## 代码 Javascript\r\n\r\n```javascript\r\nconst swapPairs = function (head) {\r\n  if (!head || !head.next) return head;\r\n  const v1 = head,\r\n    v2 = head.next,\r\n    v3 = v2.next;\r\n  v2.next = v1;\r\n  v1.next = swapPairs(v3);\r\n  return v2;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间 O(n)\r\n空间 O(n)?\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922104186","body":"## link:\r\n\r\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n## 代码 Javascript\r\n\r\n```javascript\r\nconst sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  const sorted = [];\r\n  let cur = head;\r\n\r\n  while (cur) {\r\n    sorted.push(cur.val);\r\n    cur = cur.next;\r\n  }\r\n\r\n  const generate = (l, r) => {\r\n    if (l > r) return null;\r\n    const mid = Math.floor((r + l) / 2);\r\n    let val = sorted[mid];\r\n    const node = new TreeNode(val);\r\n    node.left = generate(l, mid - 1);\r\n    node.right = generate(mid + 1, r);\r\n    return node;\r\n  };\r\n\r\n  return generate(0, sorted.length - 1);\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间 O(n)\r\n空间 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922401506","body":"## link:\r\n\r\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/\r\n\r\n## 思路:\r\n\r\n- 把没有 intersect 的 listA 的节数带入 x, 没有 intersect 的 listB 的节数带入 y, intersect 的部分叫 z。如果要从 listA, listB 的头部同速前进，如果它们的长度不同， 不会同时走完。这是我们可以 listA, listB 转到各自没有 intersect 的部分，继续走，直到走到 null\r\n- x+z+y = y+z+x\r\n\r\n## 代码 Javascript\r\n\r\n```javascript\r\nconst getIntersectionNode = function(headA, headB) {\r\n    if (!headA || !headB) return null;\r\n    var curA = headA;\r\n    var curB = headB;\r\n    while (curA != curB) {\r\n        curA = curA == null ? headB : curA.next;\r\n        curB = curB == null ? headA : curB.next;\r\n    }\r\n    return curA;\r\n  };\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间 O(m+n)\r\n空间 O(m+n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jin03041209":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916558714","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> list = new LinkedList<>();\n        int i = num.length-1;\n        while(i>=0||k>0){\n            if(i>=0){\n                k +=num[i];\n            }\n            list.addFirst(k%10);\n            k /= 10;\n            i--;\n        }\n        return list;\n    }\n}\n复杂度分析：\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"agentzzz":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916559464","body":"两个思路：\n\n1.将数组元素转化为数字，然后数字相加，返回数组【但是，数字表示范围容易超限】\n\n2.按位相加\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        long long n = 0;\n        for (int i = 0; i < num.size(); ++i)\n        {\n            n = n * 10 + num[i];\n        }\n        n += k;\n        vector<int>res;\n        if(n==0) return {0};\n        while (n != 0)\n        {\n            res.push_back(n % 10);\n            n /= 10;\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n\n超出数字表示范围\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        \n        int i = num.size()-1;\n        vector<int>res;\n        while(i>=0)\n        {\n            int temp = num[i] + k;\n            res.push_back(temp%10);\n            k = temp/10;\n            i--;\n        }\n        while(k>0) {\n\t\t\tres.push_back(k%10);\n\t\t\tk/=10;\n\t\t}\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n\n时间复杂度O（N）\n\n空间复杂度O（N）\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917382729","body":"```C++\nclass Solution {\npublic:\n\tvector<int> shortestToChar(string s, char c) {\n\t\tvector<int> res;\n        res.resize(s.size());\n\t\tint temp = INT_MIN / 2;\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (s[i] == c) temp = i;\n\t\t\tres[i] = i - temp;\n\t\t}\n\t\ttemp = INT_MAX / 2;\n\t\tfor (int i = s.size() - 1; i >= 0; i--) {\n\t\t\tif (s[i] == c) temp = i;\n\t\t\tres[i] = min(temp - i, res[i]);\n\t\t}\n\t\treturn res;\n\n\t}\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917543601","body":"用数组实现增量栈\r\n\r\n```C++\r\nclass CustomStack {\r\npublic:\r\n    vector<int>mem;\r\n    int _size;\r\n    \r\n    CustomStack(int maxSize) {\r\n        this->_size = maxSize;\r\n    }\r\n\r\n    void push(int x) {\r\n        if (mem.size() < _size) mem.push_back(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (mem.empty()) return -1;\r\n        else {           \r\n            int ret = mem.back();\r\n            mem.pop_back();\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    void increment(int k, int val) {\r\n        if (k > mem.size()) {\r\n            for (int i = 0; i < mem.size(); i++) {\r\n                mem[i] += val;\r\n            }\r\n        }\r\n        else {\r\n            for (int i = 0; i < k; i++) {\r\n                mem[i] += val;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918212278","body":"# 思路\n辅助栈\n```C++\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int multi = 0;\n        stack<int>stk_multi;\n        stack<string>stk_res;\n        string res = \"\";\n        for(int i =0;i<s.size();i++)\n        {\n            if(s[i]=='[')\n            {\n                stk_multi.push(multi);\n                stk_res.push(res);\n                multi = 0;\n                res = \"\";\n            }\n            else if(s[i]==']')\n            {\n                string temp = \"\";\n                int curmulti = stk_multi.top();\n                stk_multi.pop();\n                for(int i = 0;i<curmulti;i++)\n                {\n                    temp+=res;\n                }\n                res = stk_res.top()+temp;\n                stk_res.pop();\n            }\n            else if(isdigit(s[i])) multi = multi*10 + s[i]-'0';\n            else res+=s[i];\n        }\n        return res;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918731465","body":"```C++\r\n\r\nclass MyQueue {\r\nprivate:\r\n    stack<int>stk1;\r\n    stack<int>stk2;\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        stk1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if(stk2.empty())\r\n        {\r\n            while(!stk1.empty()){\r\n                auto temp = stk1.top();\r\n                stk1.pop();\r\n                stk2.push(temp);\r\n            }\r\n            \r\n        }\r\n        auto num = stk2.top();\r\n        stk2.pop();\r\n        return num;\r\n        \r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(stk2.empty())\r\n        {\r\n            while(!stk1.empty()){\r\n                auto temp = stk1.top();\r\n                stk1.pop();\r\n                stk2.push(temp);\r\n                \r\n            }\r\n        }\r\n        return stk2.top();\r\n\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        if(stk1.empty() && stk2.empty())\r\n            return true;\r\n        return false;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919781517","body":"```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        vector<int>temp(arr);\r\n        sort(temp.begin(), temp.end());\r\n        int flag = 0;\r\n        int res = 0;\r\n        map<int, int>mp;\r\n        for (int i = 0; i < arr.size(); i++) {\r\n            mp[arr[i]]++;\r\n            if (mp[arr[i]]==1) flag++;\r\n            if (mp[arr[i]] == 0) flag--;\r\n            mp[temp[i]]--;\r\n            if (mp[temp[i]] == -1) flag++;\r\n            if (mp[temp[i]] == 0) flag--;\r\n\r\n            if (flag == 0) res++;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916559576","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n## S1: 逐位相加\r\n\r\n将数字逐位相加，从低位到高位。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> ans;\r\n        int i = num.size() - 1;\r\n        int carry = 0;\r\n        while (i >= 0 || k > 0 || carry > 0) {\r\n            int a = i >= 0 ? num[i--] : 0;\r\n            int b = k > 0 ? k % 10 : 0;\r\n            k /= 10;\r\n            int sum = a + b + carry;\r\n            ans.push_back(sum % 10);\r\n            carry = sum / 10;\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(max(N,logk))$，N 是 num 的长度，logk 是 k 的位数。进行逐位相加以及最后 reverse 数组的时间分别都是 $O(max(N,logk))$。\r\n- ***Space:** $O(1)$，*除返回值外，使用的是常数空间。\r\n\r\n## S2: 相加\r\n\r\n将 k 从低位到高位直接加到数组的每一位。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> ans;\r\n        int i = num.size() - 1;\r\n        while (i >= 0 || k > 0) {\r\n            k += i >= 0 ? num[i--] : 0;\r\n            ans.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(max(N,logk))$\r\n- ***Space:** $O(1)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917374959","body":"# 821.字符的最短距离\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n- [821.字符的最短距离](#821字符的最短距离)\n  - [题目描述](#题目描述)\n  - [解法 1：中心扩展法](#解法-1中心扩展法)\n    - [思路](#思路)\n    - [复杂度分析](#复杂度分析)\n    - [代码 (JS/C++)](#代码-jsc)\n  - [解法 2：空间换时间](#解法-2空间换时间)\n    - [思路](#思路-1)\n    - [复杂度分析](#复杂度分析-1)\n    - [代码 (JS/C++)](#代码-jsc-1)\n  - [解法 3：贪心](#解法-3贪心)\n    - [思路](#思路-2)\n    - [复杂度分析](#复杂度分析-2)\n    - [代码 (JS/C++/Python)](#代码-jscpython)\n  - [解法 4：窗口](#解法-4窗口)\n    - [思路](#思路-3)\n    - [复杂度分析](#复杂度分析-3)\n    - [代码 (JS/C++/Python)](#代码-jscpython-1)\n\n## 题目描述\n\n```\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\n\n示例 1:\n\n输入: S = \"loveleetcode\", C = 'e'\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\n说明:\n\n字符串 S 的长度范围为 [1, 10000]。\nC 是一个单字符，且保证是字符串 S 里的字符。\nS 和 C 中的所有字母均为小写字母。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n```\n\n## 解法 1：中心扩展法\n\n### 思路\n\n这是最符合直觉的思路，对每个字符分别进行如下处理：\n\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 `C`。\n- 只在一个方向找到的话，直接计算字符距离。\n- 两个方向都找到的话，取两个距离的最小值。\n\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_0.png)\n\n### 复杂度分析\n\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$。\n\n### 代码 (JS/C++)\n\nJavaScript Code\n\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  // 结果数组 res\n  var res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    // 如果当前是目标字符，就什么都不用做\n    if (S[i] === C) continue;\n\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n\nC++ Code\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        vector<int> res(S.length());\n\n        for (int i = 0; i < S.length(); i++) {\n            if (S[i] == C) continue;\n\n            int left = i;\n            int right = i;\n            int dist = 0;\n\n            while (left >= 0 || right <= S.length() - 1) {\n                if (S[left] == C) {\n                    dist = i - left;\n                    break;\n                }\n                if (S[right] == C) {\n                    dist = right - i;\n                    break;\n                }\n\n                if (left > 0) left--;\n                if (right < S.length() - 1) right++;\n            }\n\n            res[i] = dist;\n        }\n\n        return res;\n    }\n};\n```\n\n## 解法 2：空间换时间\n\n### 思路\n\n空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。\n\n因为目标字符 `C` 在 `S` 中的位置是不变的，所以我们可以提前将 `C` 的所有下标记录在一个数组 `cIndices` 中。\n\n然后遍历字符串 `S` 中的每个字符，到 `cIndices` 中找到距离当前位置最近的下标，计算距离。\n\n### 复杂度分析\n\n- 时间复杂度：$O(N*K)$，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，$K <= N$。\n- 空间复杂度：$O(K)$，K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间。\n\n### 代码 (JS/C++)\n\nJavaScript Code\n\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  // 记录 C 字符在 S 字符串中出现的所有下标\n  var cIndices = [];\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) cIndices.push(i);\n  }\n\n  // 结果数组 res\n  var res = Array(S.length).fill(Infinity);\n\n  for (let i = 0; i < S.length; i++) {\n    // 目标字符，距离是 0\n    if (S[i] === C) {\n      res[i] = 0;\n      continue;\n    }\n\n    // 非目标字符，到下标数组中找最近的下标\n    for (const cIndex of cIndices) {\n      const dist = Math.abs(cIndex - i);\n\n      // 小小剪枝一下\n      // 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除\n      if (dist >= res[i]) break;\n\n      res[i] = dist;\n    }\n  }\n  return res;\n};\n```\n\nC++ Code\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n        vector<int> c_indices;\n        // Initialize a vector of size n with default value n.\n        vector<int> res(n, n);\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) c_indices.push_back(i);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) {\n                res[i] = 0;\n                continue;\n            }\n\n            for (int j = 0; j < c_indices.size(); j++) {\n                int dist = abs(c_indices[j] - i);\n                if (dist > res[i]) break;\n                res[i] = dist;\n            }\n        }\n\n        return res;\n    }\n};\n```\n\n## 解法 3：贪心\n\n### 思路\n\n其实对于每个字符来说，它只关心离它最近的那个 `C` 字符，其他的它都不管。所以这里还可以用贪心的思路：\n\n1. 先 `从左往右` 遍历字符串 `S`，用一个数组 left 记录每个字符 `左侧` 出现的最后一个 `C` 字符的下标；\n2. 再 `从右往左` 遍历字符串 `S`，用一个数组 right 记录每个字符 `右侧` 出现的最后一个 `C` 字符的下标；\n3. 然后同时遍历这两个数组，计算距离最小值。\n\n**优化 1**\n\n再多想一步，其实第二个数组并不需要。因为对于左右两侧的 `C` 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：\n\n1. 字符左侧没有出现过 `C` 字符\n2. `i - left` > `right - i` (i 为当前字符下标，left 为字符左侧最近的 `C` 下标，right 为字符右侧最近的 `C` 下标)\n\n如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。\n\n**优化 2**\n\n如果我们是直接记录 `C` 与当前字符的距离，而不是记录 `C` 的下标，还可以省掉最后一次遍历计算距离的过程。\n\n### 复杂度分析\n\n- 时间复杂度：$O(N)$，N 是 S 的长度。\n- 空间复杂度：$O(1)$。\n\n### 代码 (JS/C++/Python)\n\nJavaScript Code\n\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length);\n\n  // 第一次遍历：从左往右\n  // 找到出现在左侧的 C 字符的最后下标\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) res[i] = i;\n    // 如果左侧没有出现 C 字符的话，用 Infinity 进行标记\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\n  }\n\n  // 第二次遍历：从右往左\n  // 找出现在右侧的 C 字符的最后下标\n  // 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]\n  for (let i = S.length - 1; i >= 0; i--) {\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\n  }\n\n  // 计算距离\n  for (let i = 0; i < res.length; i++) {\n    res[i] = Math.abs(res[i] - i);\n  }\n  return res;\n};\n```\n\n**直接计算距离：**\n\nJavaScript Code\n\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) res[i] = 0;\n    // 记录距离：res[i - 1] + 1\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\n  }\n\n  for (let i = S.length - 1; i >= 0; i--) {\n    // 更新距离：res[i + 1] + 1\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\n  }\n\n  return res;\n};\n```\n\nC++ Code\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n        vector<int> dist(n, n);\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) dist[i] = 0;\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (dist[i] == n\n                || (i < n - 1 && dist[i + 1] + 1 < dist[i]))\n                    dist[i] = dist[i + 1] + 1;\n        }\n\n        return dist;\n    }\n};\n```\n\nPython Code\n\n```py\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res\n```\n\n## 解法 4：窗口\n\n### 思路\n\n把 `C` 看成分界线，将 `S` 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\n\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_1.png)\n\n### 复杂度分析\n\n- 时间复杂度：$O(N)$，N 是 S 的长度。\n- 空间复杂度：$O(1)$。\n\n### 代码 (JS/C++/Python)\n\nJavaScript Code\n\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\n  let l = S[0] === C ? 0 : Infinity,\n    // 窗口右边界\n    r = S.indexOf(C, 1);\n\n  const res = Array(S.length);\n\n  for (let i = 0; i < S.length; i++) {\n    // 计算字符到当前窗口左右边界的最小距离\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n\n    // 遍历完了当前窗口的字符后，将整个窗口右移\n    if (i === r) {\n      l = r;\n      r = S.indexOf(C, l + 1);\n    }\n  }\n\n  return res;\n};\n```\n\nC++ Code\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n\n        int l = S[0] == C ? 0 : n;\n        int r = S.find(C, 1);\n\n        vector<int> dist(n);\n\n        for (int i = 0; i < n; i++) {\n            dist[i] = min(abs(i - l), abs(r - i));\n            if (i == r) {\n                l = r;\n                r = S.find(C, r + 1);\n            }\n        }\n\n        return dist;\n    }\n};\n```\n\nPython Code\n\n```py\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 for _ in range(n)]\n\n        l = 0 if s[0] == c else n\n        r = s.find(c, 1)\n\n        for i in range(n):\n            res[i] = min(abs(i - l), abs(r - i))\n            if i == r:\n                l = r\n                r = s.find(c, l + 1)\n        return res\n```\n\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917538656","body":"# 1381.设计一个支持增量操作的栈\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n- [1381.设计一个支持增量操作的栈](#1381dot设计一个支持增量操作的栈)\n  - [题目描述](#题目描述)\n  - [方法 1: 用数组或链表模拟栈](#方法-1-用数组或链表模拟栈)\n    - [数组](#数组)\n    - [复杂度分析](#复杂度分析)\n    - [链表](#链表)\n    - [复杂度分析](#复杂度分析-1)\n    - [代码](#代码)\n  - [方法 2: 空间换时间](#方法-2-空间换时间)\n    - [图解](#图解)\n    - [复杂度分析](#复杂度分析-2)\n    - [代码](#代码-1)\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/design-a-stack-with-increment-operation\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n```\n\n## 方法 1: 用数组或链表模拟栈\n\n### 数组\n\n使用数组来模拟栈，可以实现时间复杂度 $O(1)$ 的 `push` 和 `pop`，和 $O(k)$ 的 `inc`，剩下的就跟着题目描述来实现就好了。\n\n-   当栈元素个数等于 `maxSize` 时不允许继续入栈；\n-   当栈为空时，出栈操作返回 -1；\n-   增量操作时，当栈元素多于 `k` 个，将栈底的 k 个元素都加 `val`，栈元素少于 `k` 个时将所有元素都加上 `val`。\n\n### 复杂度分析\n\n-   时间复杂度：`push` 和 `pop` 是 $O(1)$，`inc` 是 $O(k)$。\n-   空间复杂度：$O(maxSize)$。\n\n### 链表\n\n也可以使用链表来模拟栈，入栈出栈都只操作 `head`，也能实现时间复杂度 $O(1)$ 的 `push` 和 `pop` 操作，但 `inc` 操作的话，由于找到从链表尾端开始的第 `k` 个元素 (可以用双指针来找) 的时间复杂度是 $O(n)$，然后将链表尾端的 `k` 个元素进行增量操作的时间复杂度是 $O(k)$，所以增量操作总的时间复杂度是 $O(n+k)$。\n\n### 复杂度分析\n\n-   时间复杂度：`push` 和 `pop` 是 $O(1)$，`inc` 是 $O(n+k)$。\n-   空间复杂度：$O(maxSize)$。\n\n### 代码\n\nJavaScript Code\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.list = [];\n    this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.list.length < this.maxSize) {\n        this.list.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    const item = this.list.pop();\n    return item === void 0 ? -1 : item;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    for (let i = 0; i < k && i < this.list.length; i++) {\n        this.list[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\nPython Code\n\n```py\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.list = []\n        self.maxSize = maxSize\n\n    def size(self):\n        return len(self.list)\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if self.size() < self.maxSize:\n            self.list.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return -1 if self.size() == 0 else self.list.pop()\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        size = k if k < self.size() else self.size()\n        for i in range(0, size):\n            self.list[i] += val\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 方法 2: 空间换时间\n\n其实我们只在出栈时才关心元素的值，所以在增量操作的时候，可以不用去更新栈内的元素，而是用一个 hashMap 来记录第几个元素需要增加多少。出栈时，检查当前元素的下标是否在 hashMap 中有记录，有的话就加上增量再出栈。这样我们就得到了时间复杂度 $O(1)$ 的增量操作，不过代价就是额外的 $O(N)$ 空间。\n\n### 图解\n\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/custom_stack.png)\n\n### 复杂度分析\n\n-   时间复杂度：`push`, `pop` 和 `inc` 都是 $O(1)$。\n-   空间复杂度：$O(maxSize)$，模拟栈的数组和哈希表的空间都是 $O(maxSize)$\n\n### 代码\n\nJavaScript Code\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.list = [];\n    this.maxSize = maxSize;\n    this.hashMap = {};\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nCustomStack.prototype._setInc = function (key, value) {\n    if (!(key in this.hashMap)) {\n        this.hashMap[key] = 0;\n    }\n    this.hashMap[key] += value;\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nCustomStack.prototype._getInc = function (key) {\n    return this.hashMap[key] || 0;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype._size = function () {\n    return this.list.length;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this._size() < this.maxSize) {\n        this.list.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    const top = this._size() - 1;\n    const inc = this._getInc(top);\n\n    let item = this.list.pop();\n    if (item === void 0) {\n        return -1;\n    }\n\n    item += inc;\n    const newTop = top - 1;\n    this._setInc(newTop, inc);\n    this.hashMap[top] = 0;\n    return item;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    const size = this._size();\n    k = k < size ? k - 1 : size - 1;\n    this._setInc(k, val);\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918019808","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/decode-string/)\n\n## S1: 递归\n\n![https://camo.githubusercontent.com/cfacf3e8bb0851bd0b122e218ad63e5ab2abf6d23d439dadf638ecb72298de74/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f6465636f64655f737472696e675f747265652e706e67](https://camo.githubusercontent.com/cfacf3e8bb0851bd0b122e218ad63e5ab2abf6d23d439dadf638ecb72298de74/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f6465636f64655f737472696e675f747265652e706e67)\n\n`n[string]` 表示解析 `[]` 模板里面的内容，然后重复 `n` 次，即得到 `n` 个 `string` 拼接起来的字符串。\n\n根据题意，`[]` 里面还可以再嵌套 `[]` ，例如 `n[m[string]]`。这种情况下，我们得先解析最内层的模板，重复 `m` 次，然后将 `m * string` 的结果作为外层模板的解析内容，再重复 `n` 次。\n\n如果嵌套的层数更多，我们也是得先找到最内层的 `[]`，就像洋葱一样，一层层剥开，然后再从内到外一层层解析和拼接。这种层层嵌套的描述很容易就让人想到了递归。\n\n按照常规，写递归时不要过多考虑前后的递归函数，想好当前递归函数需要处理些什么就好了。\n\n- 在每个递归函数里我们处理一段没有嵌套模版的字符串。\n- 遇到英文字母时，进行简单的拼接。\n- 遇到数字时，累加数字。\n- 遇到 `[` 时，说明接下来是一个嵌套模版，开始递归处理。递归处理嵌套模版结束后，我们回到了当前层级，需要的信息有两个，一个是嵌套模版的解码字符串，另一个是嵌套模版的结束坐标。嵌套模版的解码字符串重复 n 次后加到当前层级的解码字符串中，接着从嵌套模版的结束坐标开始继续处理当前层级的字符串。\n- 遇到 `]` 时，说明处理当前层级模版的递归可以结束了，返回上一种情况需要的信息，解码字符串以及模版结束的坐标。\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        return decodeString(s, 0).first;\n    }\n\n    pair<string, int> decodeString(string s, int cur) {\n        int k = 0;\n        string decoded;\n        while (cur < s.size()) {\n            // 收集数字\n            if (isdigit(s[cur])) {\n                k = k * 10 + s[cur] - '0';\n                cur++;\n            }\n            // 收集字母\n            else if (isalpha(s[cur])) {\n                decoded.push_back(s[cur]);\n                cur++;\n            }\n            // 开始解析下一层嵌套\n            else if (s[cur] == '[') {\n                pair<string, int> res = decodeString(s, cur + 1);\n                // 解析完嵌套模式后\n                while (k-- > 0) {\n                    decoded.append(res.first);\n                }\n                k = 0;\n                cur = res.second;\n            }\n            // 结束当前递归\n            else if (s[cur] == ']') {\n                return {decoded, cur + 1};\n            }\n        }\n        return {decoded, -1};\n    }\n};\n```\n\n```jsx\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s, cur = 0) {\n    let k = 0;\n    let decoded = '';\n    while (cur < s.length) {\n        if (s[cur] === '[') {\n            const [str, pos] = decodeString(s, cur + 1);\n            decoded += str.repeat(k);\n            k = 0;\n            cur = pos;\n        } else if (s[cur] === ']') {\n            return [decoded, cur + 1];\n        } else if (/[0-9]/.test(s[cur])) {\n            k = k * 10 + parseInt(s[cur++]);\n        } else {\n            decoded += s[cur++];\n        }\n    }\n    return decoded;\n};\n```\n\n- ****Time:**** $O(N)$，N 是解码后字符串的长度。\n- ***Space:** $O(N)$*\n\n## S2: 循环+栈\n\n可以用递归解决的问题，也可以用循环来解决。\n\n这里我用了正则 `/[a-zA-Z]+|[0-9]+|\\[|\\]/` 和 `exec()` 方法来遍历字符串并把它们拆分成 `token`，比如，`lz3[ab2[c]]` 会被拆分成 `lz`, `3`, `[`, `ab`, `2`, `[`, `c`, `]`, `]`。\n\n1. 遇到字母块 (`lz`)、数字时，入栈；\n2. 遇到 `[` 时，入栈，用来标识当前进入一个模板解析了；\n3. 遇到 `]` 时，说明当前模板遍历完了，我们可以开始解析了。\n    1. 开始出栈，把出栈的字母块都拼接起来。\n    2. 等出栈到 `[` 时，说明当前模板解析完成了。\n    3. 继续出栈一个元素，这个元素就是当前模板要重复的次数。\n    4. 把 `字母块 * 次数` 重新入栈，这是因为模板是可嵌套的，当前模板外面可能还有一层模板，所以我们要把当前层级的解析结果重新入栈，接着解析外层的模板。\n\n![https://camo.githubusercontent.com/cf2e9f7f12b4e571df77f88ec55ce574760d221c5b4551e0a179d361aad35f98/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f6465636f64655f737472696e675f737461636b2e706e67](https://camo.githubusercontent.com/cf2e9f7f12b4e571df77f88ec55ce574760d221c5b4551e0a179d361aad35f98/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f6465636f64655f737472696e675f737461636b2e706e67)\n\n```jsx\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n    const reg = /[a-zA-Z]+|[0-9]+|\\[|\\]/g;\n    const stack = [];\n    const peek = () => stack[stack.length - 1]; // p.s. 不正经栈\n\n    while (reg.lastIndex < s.length) {\n        let token = reg.exec(s)[0];\n        if (token !== ']') {\n            // 数字，字母，左括号通通入栈\n            stack.push(token);\n        } else {\n            // 遇到右括号就开始出栈\n            let str = '';\n            // [] 中间的就是要重复的模式，把它们全部出栈，拼接起来\n            while (peek() !== '[') {\n                str = stack.pop() + str;\n            }\n            // 丢掉左括号\n            stack.pop();\n            // 左括号前面的一定是模式重复的次数\n            const num = +stack.pop();\n            // 把复制操作后的字符串放回栈中，作为外层 [] 模式的一部分\n            stack.push(str.repeat(num));\n        }\n    }\n    return stack.join('');\n};\n```\n\n- ****Time:**** $O(N)$，N 是解码后字符串的长度。\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918795736","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n## S1: 优化模拟\n\n维护两个栈，一个用来写 (push)，一个用来读 (pop)。\n\n往写栈中 push，从读栈中 pop。当读栈为空时，将写栈中的数据全部倒入读栈中。\n\n```cpp\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        write_stack_.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if (read_stack_.empty()) pour_();\n        int value = read_stack_.top();\n        read_stack_.pop();\n        return value;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if (read_stack_.empty()) pour_();\n        return read_stack_.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return read_stack_.empty() && write_stack_.empty();\n    }\nprivate:\n    stack<int> write_stack_;\n    stack<int> read_stack_;\n\n    void pour_() {\n        while (!write_stack_.empty()) {\n            read_stack_.push(write_stack_.top());\n            write_stack_.pop();\n        }\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n- ****Time:**** `push` 是 $O(1)$，`pop` 均摊下来也是 $O(1)$，连续 N 次的 push 才会碰到一次 $O(N)$ 的 pop。\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919966965","body":"# 768. 最多能完成排序的块 II\n\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n\n- [768. 最多能完成排序的块 II](#768-最多能完成排序的块-ii)\n  - [题目描述](#题目描述)\n  - [方法 1: 滑动窗口](#方法-1-滑动窗口)\n    - [思路](#思路)\n    - [复杂度分析](#复杂度分析)\n    - [代码 (JS/C++)](#代码-jsc)\n  - [方法 2: 单调栈](#方法-2-单调栈)\n    - [思路](#思路-1)\n    - [图解](#图解)\n    - [复杂度分析](#复杂度分析-1)\n    - [代码(JS/C++)](#代码jsc)\n\n## 题目描述\n\n```\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\n\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n示例 1:\n\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\n示例 2:\n\n输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\n注意:\n\narr的长度在[1, 2000]之间。\narr[i]的大小在[0, 10**8]之间。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n```\n\n## 方法 1: 滑动窗口\n\n### 思路\n\n题目有一个提示：\n\n```\nEach k for which some permutation of arr[:k] is equal to sorted(arr)[:k] is where we should cut each chunk.\n```\n\n也就是原数组进行分块后，每一个分块和排序后的数组中对应的分块数字是一样的，只是排序不同。\n\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/06.max-chunks-to-make-sorted-ii-00.png)\n\n既然每个分块中数字是一样的，那它们的和也是一样的了。我们可以用一个滑动窗口同时扫描原数组和排序数组，当窗口中数字的和一样时，就将数组进行分块，就像上图中的色块一样。\n\n### 复杂度分析\n\n- 时间复杂度：$O(NlogN)$，N 为数组长度，数组排序时间认为是 $NlogN$，滑动窗口遍历数组时间为 $N$。\n- 空间复杂度：$O(N)$，N 为数组长度。\n\n### 代码 (JS/C++)\n\nJavaScript Code\n\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n  const sorted = [...arr];\n  sorted.sort((a, b) => a - b);\n\n  let count = 0,\n    sum1 = 0,\n    sum2 = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    sum1 += arr[i];\n    sum2 += sorted[i];\n\n    if (sum1 === sum2) {\n      count++;\n      sum1 = sum2 = 0; // 这行不要也可以啦\n    }\n  }\n\n  return count;\n};\n```\n\nC++ Code\n\n```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> sorted = arr;\n        sort(sorted.begin(), sorted.end());\n\n        long int arrSum = 0;\n        long int sortedSum = 0;\n        int chunkCount = 0;\n\n        for (int i = 0; i < n; i++) {\n            arrSum += arr[i];\n            sortedSum += sorted[i];\n            if (arrSum == sortedSum) chunkCount++;\n        }\n\n        return chunkCount;\n    }\n};\n```\n\n## 方法 2: 单调栈\n\n### 思路\n\n根据题意，将原数组进行分块后，对各分块分别进行排序后的结果等于原数组排序后的结果。\n\n可以得到的一个结论是，每个分块中的数字相对于前一个分块都是递增的(因为有重复数字，所以也可能是相同)，下一个分块中的所有数字都会大于等于上一个分块中的所有数字。\n\n- 因为题目要求能分的最多的块数，所以我们在分块的时候要尽量把块分小，这样就能分得比较多。\n\n- 在遍历数组的过程中，如果一个数字比之前所有分块的最大值都要大，我们就把它作为一个新的分块。\n\n- 如果数字小于之前某些分块的最大值，那这些分块都要被合成一个分块(保持栈的单调递增)。\n\n### 图解\n\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/06.max-chunks-to-make-sorted-ii-01.png)\n\n再看一个例子：\n\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/06.max-chunks-to-make-sorted-ii-02.png)\n\n### 复杂度分析\n\n- 时间复杂度：$O(N)$，N 为数组长度。\n- 空间复杂度：$O(N)$，N 为数组长度，单调栈消耗的空间。\n\n### 代码(JS/C++)\n\nJavaScript Code\n\n```js\nclass Stack {\n  constructor() {\n    this.list = [];\n  }\n  push(val) {\n    this.list.push(val);\n  }\n  pop() {\n    return this.list.pop();\n  }\n  empty() {\n    return this.list.length === 0;\n  }\n  peek() {\n    return this.list[this.list.length - 1];\n  }\n  size() {\n    return this.list.length;\n  }\n}\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n  const stack = new Stack();\n\n  for (let i = 0; i < arr.length; i++) {\n    if (stack.empty() || stack.peek() <= arr[i]) {\n      stack.push(arr[i]);\n    } else {\n      const temp = stack.pop();\n\n      while (stack.peek() > arr[i]) {\n        stack.pop();\n      }\n\n      stack.push(temp);\n    }\n  }\n  return stack.size();\n};\n```\n\nC++ Code\n\n```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> blocks;\n\n        for (int i = 0; i < arr.size(); i++) {\n            if (blocks.empty() || blocks.top() <= arr[i]) {\n                // a new chunk\n                blocks.push(arr[i]);\n            }\n            else {\n                int topNum = blocks.top();\n                blocks.pop();\n\n                // combine chunks\n                while (!blocks.empty() && blocks.top() > arr[i]) {\n                    blocks.pop();\n                }\n                blocks.push(topNum);\n            }\n        }\n\n        return blocks.size();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920571149","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/rotate-list/)\n\n## S1: 直觉思路\n\n直观的思路就是将末尾的 k 个节点移到头部。\n\n- 第一步是找到倒数第 k - 1 个节点，不会的可以先看 [剑指 Offer 22. 链表中倒数第k个节点](https://www.notion.so/Offer-22-k-5a01ded84e1a4135b4c6ebc48cca01e1)\n- 接下来就是简单的链表指针操作罢了，将 `[0, k-1]` 和 `[k, n-1]` 这两段链表换个位置。\n- 由于 k 可能会大于链表长度，所以我们最好先计算出链表长度再取模。\n- 既然已经知道了链表长度，第一步也可以不使用双指针来找倒数 k -1 个节点了。\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr || head->next == nullptr || k == 0) return head;\n\n        int n = 0;\n        ListNode* p = head;\n        ListNode* oldTail;\n        // 先计算出链表的长度，顺便记录下链表原尾部\n        while (p != nullptr) {\n            if (p->next == nullptr) oldTail = p;\n            p = p->next;\n            n++;\n        }\n        if (k % n == 0) return head;\n        // 找倒数第 k-1 个节点\n        k = n - k % n - 1;\n        p = head;\n        // 找到分割点，p 是新尾部，p->next 是新头部\n        while (k-- > 0) {\n            p = p->next;\n        }\n        if (p->next == nullptr) return head;\n        // 穿针引线将两段链表换个位置\n        ListNode* newTail = p;\n        ListNode* newHead = p->next;\n        newTail->next = nullptr;\n        oldTail->next = head;\n        return newHead;\n    }\n};\n```\n\n- ****Time:**** $O(N)$\n- ***Space:** $O(1)$*\n\n## S2: 闭环\n\n将链表首尾相连，从原尾部开始走 n-k 步，断开。相比第一种解法，少了操作链表指针的繁琐操作。\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr || head->next == nullptr || k == 0) return head;\n\n        int n = 1;\n        ListNode* p = head;\n        while (p->next != nullptr) {\n            p = p->next;\n            n++;\n        }\n        // 首尾相连\n        p->next = head;\n        k = n - k % n;\n        // 走 n-k 步，断开\n        while (k-- > 0) {\n            p = p->next;\n        }\n        ListNode* newHead = p->next;\n        p->next = nullptr;\n        return newHead;\n    }\n};\n```\n\n```jsx\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n    if (!head || k === 0) return head;\n\n    let cur = head,\n        len = 1;\n    while (cur.next) {\n        cur = cur.next;\n        len++;\n    }\n    cur.next = head;\n\n    cur = head;\n    let n = len - (k % len) - 1;\n    while (n > 0) {\n        cur = cur.next;\n        n--;\n    }\n    const newHead = cur.next;\n    cur.next = null;\n    return newHead;\n};\n```\n\n- ****Time:**** $O(N)$\n- ***Space:** $O(1)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921666087","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n## S1: 迭代\n\n简单的链表指针操作题，注意穿针引线的时候别打结了。\n\n- 注意指针改变的顺序，不然可能会丢失节点，不熟悉可以画图，或者先用变量把指针存起来，写得啰嗦点。\n- 可以加一个 dummy 节点在 head 前，简化操作，免去对头部节点的额外操作，是链表题目的常用技巧。\n\n![https://camo.githubusercontent.com/b66080a8fd804e7ed7002a1ff561cd6042c5e5885ea17e0346ec559f9e747a3d/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f30372e737761702d6e6f6465732d696e2d70616972732d30322e706e67](https://camo.githubusercontent.com/b66080a8fd804e7ed7002a1ff561cd6042c5e5885ea17e0346ec559f9e747a3d/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f30372e737761702d6e6f6465732d696e2d70616972732d30322e706e67)\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // 使用一个 dummy 节点来简化操作\n        // 不用额外处理头部节点，把头部节点也当成链表中间的一个节点处理即可\n        ListNode* dummy = new ListNode(0, head);\n        ListNode* prev = dummy;\n        ListNode* cur = head;\n\n        // 存在一对节点的时候才进行两两交换\n        while (cur != nullptr && cur->next != nullptr) {\n            ListNode* first = cur;\n            ListNode* second = cur->next;\n            first->next = second->next;\n            second->next = first;\n\n            prev->next = second;\n            prev = first;\n            cur = first->next;\n        }\n        return dummy->next;\n    }\n};\n```\n\n```jsx\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  const dummy = new ListNode(null, head);\n  let prev = dummy;\n  let cur = prev.next;\n\n  while (cur && cur.next) {\n    // 按照上图，指针更换顺序是这样子的\n    // prev.next = cur.next\n    // cur.next = prev.next.next\n    // prev.next.next = cur\n\n    // 也可以先用一个指针把下一个节点存起来\n    const next = cur.next;\n    cur.next = next.next;\n    next.next = cur;\n    prev.next = next;\n\n    prev = cur;\n    cur = cur.next;\n  }\n  return dummy.next;\n};\n```\n\n- ****Time:**** $O(N)$，N 是链表的长度。\n- ***Space:** $O(1)$*\n\n## S2: 递归\n\n用递归来解决这个问题时，我们只需要考虑这几个问题：\n\n**小问题**\n\n当前递归函数需要解决什么问题？将前后的情况都当作黑匣子，我们只需要关注当前的递归函数即可，答案显然是将两个节点进行交换\n\n![https://camo.githubusercontent.com/d3a748ec184d989953abca98977a1b4eae07f3e250b40ab0714e9b259f77da9f/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f30372e737761702d6e6f6465732d696e2d70616972732d30302e706e67](https://camo.githubusercontent.com/d3a748ec184d989953abca98977a1b4eae07f3e250b40ab0714e9b259f77da9f/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f30372e737761702d6e6f6465732d696e2d70616972732d30302e706e67)\n\n**小问题之间的关系**\n\n我们将链表进行两两分组，在每个递归函数中只处理一组节点，那么各个递归函数之间的关系是什么？答案也是显而易见的，需要将各组节点重新连接。再具体点就是，下一层递归函数需要返回什么数据给当前函数，而当前递归函数需要什么数据给上一层递归函数，这两个其实是一个问题。就这道问题而已，需要返回的是交换后的第一个节点。\n\n![https://camo.githubusercontent.com/1bfc5fa8f248c28b9f725b706fdcaf557ab1082328d27c8924d11ab02dc8b45b/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f30372e737761702d6e6f6465732d696e2d70616972732d30312e706e67](https://camo.githubusercontent.com/1bfc5fa8f248c28b9f725b706fdcaf557ab1082328d27c8924d11ab02dc8b45b/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f30372e737761702d6e6f6465732d696e2d70616972732d30312e706e67)\n\n**递归出口**\n\n- 最后一个节点或者空节点\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // 递归出口\n        if (head == nullptr || head->next == nullptr) return head;\n        ListNode* first = head;\n        ListNode* second = head->next;\n\n        // 下一层递归函数会返回下一组交换后的第一个节点\n        ListNode* reversed = swapPairs(second->next);\n\n        // 当前递归函数需要处理的\n        first->next = reversed;\n        second->next = first;\n        // 返回交换后的第一个节点\n        return second;\n    }\n};\n```\n\n```jsx\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  // 递归出口\n  if (!head || !head.next) return head;\n\n  // 先保存下一个节点，避免丢失\n  const next = head.next;\n\n  // 下一个递归会返回互换后的第一个节点\n  // head 是当前组互换后的第二个节点，head.next 指向下一组就好\n  head.next = swapPairs(next.next);\n\n  // 将当前组的两个节点互换\n  next.next = head;\n\n  // 返回互换后的第一个节点\n  return next;\n};\n```\n\n- ****Time:**** $O(N)$，N 是链表的长度。\n- ***Space:** $O(N)$*，递归栈的深度就是链表的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922227582","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n## S1: 递归+分治\n\n前置知识：\n\n- 二叉搜索树的中序遍历刚好是一个有序序列\n- 寻找链表中点\n- 分治构建二叉树\n\n具体实现：\n\n1. 构建二叉树要从 root 开始，而二叉搜索树和有序链表的联系就是，二叉搜索树的 root 刚好是有序链表的中点。\n2. 将有序链表从中点一分为二，再回到第一步。\n3. \n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        return sortedListToBST(head, nullptr);\n    }\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail) {\n        if (head == tail) return nullptr;\n\n        ListNode* mid = findMidNode(head, tail);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = sortedListToBST(head, mid);\n        root->right = sortedListToBST(mid->next, tail);\n        return root;\n    }\n    ListNode* findMidNode(ListNode* head, ListNode* tail) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != tail && fast->next != tail) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n};\n```\n\n```jsx\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function (head, tail = null) {\n  if (!head || head === tail) return null;\n\n  let slow = head,\n    fast = head;\n  while (fast !== tail && fast.next !== tail) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n\n  const root = new TreeNode(slow.val);\n  root.left = sortedListToBST(head, slow);\n  root.right = sortedListToBST(slow.next, tail);\n  return root;\n};\n```\n\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n        if not head: return None\n        prev, slow, fast = None, head, head\n\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        root = TreeNode(slow.val)\n        if slow == fast: return root\n\n        if prev: prev.next = None\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n```\n\n- ****Time:**** $O(NlogN)$，N 是链表长度。递推关系式参照 [主定律](https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86)。以下是个人胡乱分析，寻找链表中间节点的总时间是 $N+N/2+N/4+...+1=\\frac{(N+1)*logN}{2}=NlogN + N$。\n- ***Space:** $O(logN)$*，递归栈的深度，因为采用了二分的方式来构建树，递归栈的深度最大就是 $log(N)$。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922396610","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n## S1: 暴力法\n\n对链表 A 的每个节点，都去链表 B 中遍历一遍找看看有没有相同的节点。\n\n```jsx\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n    if (!headA || !headB) return null;\n\n    let pA = headA;\n    while (pA) {\n        let pB = headB;\n\n        while (pB) {\n            if (pA === pB) return pA;\n            pB = pB.next;\n        }\n\n        pA = pA.next;\n    }\n};\n```\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (headA == NULL || headB == NULL) return NULL;\n\n        ListNode *pA = headA;\n\n        while (pA != NULL) {\n            ListNode *pB = headB;\n            while (pB != NULL) {\n                if (pA == pB) {\n                    return pA;\n                }\n                pB = pB->next;\n            }\n            pA = pA->next;\n        }\n        return NULL;\n    }\n};\n```\n\n- ****Time:**** $O(m*n)$，m 和 n 分别是两个链表的长度。\n- ***Space:** $O(1)$*\n\n## S2: 哈希表\n\n- 先遍历遍历链表 A，将所有节点都存在一个哈希表中\n- 再遍历链表 B，找到在哈希表中出现过的节点即为两个链表的交点。\n\n```jsx\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n    if (!headA || !headB) return null;\n\n    const hashmap = new Map();\n\n    let pA = headA;\n    while (pA) {\n        hashmap.set(pA, 1);\n        pA = pA.next;\n    }\n\n    let pB = headB;\n    while (pB) {\n        if (hashmap.has(pB)) return pB;\n        pB = pB.next;\n    }\n};\n```\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set<ListNode*> visited;\n        ListNode* p = headA;\n        while (p != NULL) {\n            visited.insert(p);\n            p = p->next;\n        }\n        p = headB;\n        while (p != NULL) {\n            if (visited.find(p) != visited.end()) return *visited.find(p);\n            p = p->next;\n        }\n        return NULL;\n    }\n};\n```\n\n- ****Time:**** $O(m+n)$，m 和 n 分别是两个链表的长度。\n- ***Space:** $O(m)$*\n\n## S3: 双指针\n\n![https://camo.githubusercontent.com/c1fabf4badffd96c0857bdc66bf8ccdf9214991b45c0e1b08c54feda9d91a77e/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f696e74657273656374696f6e5f6f665f6c696e6b65645f6c697374732e706e67](https://camo.githubusercontent.com/c1fabf4badffd96c0857bdc66bf8ccdf9214991b45c0e1b08c54feda9d91a77e/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f696e74657273656374696f6e5f6f665f6c696e6b65645f6c697374732e706e67)\n\n**如果两个链表有交点的话：**\n\n![https://camo.githubusercontent.com/3580f2f8d58e14290c175c9a117219b37d85e71c1d2b058a65b9982b10555f40/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f696e74657273656374696f6e5f6f665f6c696e6b65645f6c697374735f312e706e67](https://camo.githubusercontent.com/3580f2f8d58e14290c175c9a117219b37d85e71c1d2b058a65b9982b10555f40/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f696e74657273656374696f6e5f6f665f6c696e6b65645f6c697374735f312e706e67)\n\n**如果链表没有交点的话：**\n\n1. 两个链表长度一样时，第一次遍历结束后 pA 和 pB 都是 null，结束遍历。\n2. 两个链表长度不一样时，两次遍历结束后 pA 和 pB 都是 null，结束遍历。\n\n```jsx\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n    if (!headA || !headB) return null;\n\n    let pA = headA,\n        pB = headB;\n    while (pA !== pB) {\n        pA = pA === null ? headB : pA.next;\n        pB = pB === null ? headA : pB.next;\n    }\n    return pA;\n};\n```\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (headA == NULL || headB == NULL) return NULL;\n        ListNode *pA = headA, *pB = headB;\n        while (pA != pB) {\n            pA = pA == NULL ? headB : pA->next;\n            pB = pB == NULL ? headA : pB->next;\n        }\n        return pA;\n    }\n};\n```\n\n- ****Time:**** $O(m+n)$，m 和 n 分别是两个链表的长度。\n- ***Space:** $O(1)$*","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingyingchu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916561783","body":"```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]: \r\n        # if k is 0, do an early return\r\n        if k == 0:\r\n            return num\r\n        # convert the array into an integer\r\n        temp = 0\r\n        for i in range(len(num)):\r\n            temp = temp * 10 + num[i]\r\n        # get the updated integer\r\n        temp = temp + k\r\n        # convert it back to an array by appending digits of the integer backwards to the result array\r\n        result = []\r\n        while temp > 0:\r\n            result.append(temp%10)\r\n            temp = temp // 10\r\n        return result[::-1]\r\n\r\n\r\ntime: O(n) - n is the length of num\r\nspace: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917503437","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [0] * len(s)\r\n        indices = []\r\n\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                indices.append(i)\r\n\r\n        for j in range(len(result)):\r\n            if s[j] != c:\r\n                shortest = float('inf')\r\n                for indice in indices:\r\n                    shortest = min(abs(indice - j), shortest)\r\n                result[j] = shortest\r\n        return result\r\n\r\n# time: O(m * n) - m is the length of s and n is the length of indices\r\n# space: O(n)\r\n        ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917512096","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.s = []\r\n        self.size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.s) < self.size:\r\n            self.s.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.s) == 0:\r\n            return -1\r\n        else:\r\n            return self.s.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(k):\r\n            if i < len(self.s):\r\n                self.s[i] += val\r\n\r\nTime: O(1) for push and pop, O(min(k, s)) where s is the size of the stack\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918278952","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n\r\n        for i in range(len(s)):\r\n            if s[i] == \"]\":\r\n                letters = ''\r\n                count = ''\r\n                while stack and stack[-1] != \"[\":\r\n                    letters = stack.pop() + letters\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    count = stack.pop() + count\r\n                stack.append(int(count) * letters)\r\n            \r\n            else:\r\n                stack.append(s[i])\r\n\r\n        return ''.join(stack)\r\n\r\nTime and Space: O(n) where n is the length of s","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918746484","body":"```\r\nclass MyQueue:\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.s1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if len(self.s2) == 0:\r\n            while len(self.s1) != 0:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if len(self.s2) == 0:\r\n            while len(self.s1) != 0:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.s1) == 0 and len(self.s2) == 0\r\n\r\nTime: O(1)\r\nSpace: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921294412","body":"```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        dummy = ListNode(-1)\r\n        dummy.next = head\r\n        prev = dummy\r\n        cur = head\r\n\r\n        while cur and cur.next:\r\n            new = cur.next.next\r\n            prev.next = cur.next\r\n            cur.next.next = cur\r\n            cur.next = new\r\n            \r\n            prev = cur\r\n            cur = new\r\n\r\n        return dummy.next\r\n\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922403560","body":"```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:    \r\n        cur1 = headA\r\n        cur2 = headB\r\n\r\n        while cur1 != cur2:\r\n            cur1 = cur1.next if cur1 else headB\r\n            cur2 = cur2.next if cur2 else headA\r\n        return cur1\r\n\r\nTime: O(a+b) where a is length of list A and b is length of list B\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922501206","body":"```\r\nPlan:\r\n1) User the two pointer technique, slow/fast pointers\r\n2) P1 starts from head and p2 starts from where slow and fast meet\r\n3) move both p1 and p2 at the same speed, and p1 and p2 meet at the entrance of the cycle\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return None\r\n\r\n        slow = fast = head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            \r\n            if slow == fast:\r\n                p1 = head\r\n                p2 = fast\r\n\r\n                while p1 != p2:\r\n                    p1 = p1.next\r\n                    p2 = p2.next\r\n                return p1\r\n        return None\r\n\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SunStrongChina":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916563357","body":"> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> ```\r\n\r\n### 官方求解方法\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        result1=[]\r\n        for i in range(len(num)-1,-1,-1):\r\n            r1=num[i]+k%10\r\n\r\n            remain1=k//10+r1//10\r\n            if r1>=10:\r\n                r1=r1%10\r\n            result1.insert(0,r1)\r\n            k=remain1\r\n        if k>0:\r\n            while k:\r\n                result1.insert(0,k%10)\r\n                k=(k-k%10)//10\r\n        return result1\r\n```\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)\r\n### 字符串求解\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        str1=''\r\n        for num1 in num:\r\n            str1+=str(num1)\r\n        result1=int(str1)+k\r\n        return [int(s1) for s1 in str(result1)]\r\n```\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917370321","body":"> # 821. 字符的最短距离\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历(正向遍历和反向遍历)\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n> \r\n> 示例 1:\r\n> \r\n> 输入: S = \"loveleetcode\", C = 'e'\r\n> 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n> 说明:\r\n> \r\n> - 字符串 S 的长度范围为 [1, 10000]。\r\n> - C 是一个单字符，且保证是字符串 S 里的字符。\r\n> - S 和 C 中的所有字母均为小写字母。\r\n> ```\r\n解法一：字符串中每一个字符，都从左右两边找，哪个先找到目标字符，就返回距离\r\n\r\npython\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        #字符搜索法\r\n        def searchTargetStr(s,i,c):\r\n            if s[i]==c:#是的话直接返回\r\n                return 0\r\n            if i>0:#定义左右搜索起始边界\r\n                left=i-1\r\n            else:\r\n                left=i\r\n            if i<len(s)-1:\r\n                right=i+1\r\n            else:\r\n                right=len(s)-1\r\n            while left>=0 or right<=len(s)-1:#同时从左和从右开始搜索，那一个先到，哪一个就是最短距离，直接返回即可\r\n                if left>=0:\r\n                    if s[left]==c:\r\n                        return i-left\r\n                    else:\r\n                        left-=1\r\n                if right<=len(s)-1:\r\n                    if s[right]==c:\r\n                        return right-i\r\n                    else:\r\n\r\n                        right+=1\r\n        results=[]\r\n        for i in range(len(s)):#搜索每一个字符\r\n            dis=searchTargetStr(s,i,c)\r\n            results.append(dis)\r\n        return results\r\n```\r\n时间复杂度：O(nlog(n))\r\n空间复杂度：O(n)\r\n\r\n\r\n解法二：\r\n先记录目标字符的位置，然后对于每一字符，寻找离它最近的目标字符，计算其距离\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        dict1=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                dict1.append(i)\r\n        #\r\n        \r\n        results=[]\r\n        for i in range(len(s)):\r\n            res=len(s)*2+1\r\n            for v1 in dict1:\r\n                if abs(i-v1)<abs(i-res):\r\n                    res=v1\r\n            results.append(abs(res-i))\r\n        return results\r\n```\r\n时间复杂度：O(n*n)\r\n空间复杂度：O(n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917537083","body":"> # 1381. 设计一个支持增量操作的栈\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n> \r\n> ## 前置知识\r\n> * 栈\r\n> * 前缀和\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 请你设计一个支持下述操作的栈。\r\n> \r\n> 实现自定义栈类 CustomStack ：\r\n> \r\n> CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\n> void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\n> int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\n> void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n> \r\n> \r\n> 示例：\r\n> \r\n> 输入：\r\n> [\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n> [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n> 输出：\r\n> [null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n> 解释：\r\n> CustomStack customStack = new CustomStack(3); // 栈是空的 []\r\n> customStack.push(1); // 栈变为 [1]\r\n> customStack.push(2); // 栈变为 [1, 2]\r\n> customStack.pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\n> customStack.push(2); // 栈变为 [1, 2]\r\n> customStack.push(3); // 栈变为 [1, 2, 3]\r\n> customStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\n> customStack.increment(5, 100); // 栈变为 [101, 102, 103]\r\n> customStack.increment(2, 100); // 栈变为 [201, 202, 103]\r\n> customStack.pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\n> customStack.pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\n> customStack.pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []\r\n> customStack.pop(); // 返回 -1 --> 栈为空，返回 -1\r\n> \r\n> \r\n> 提示：\r\n> \r\n> 1 <= maxSize <= 1000\r\n> 1 <= x <= 1000\r\n> 1 <= k <= 1000\r\n> 0 <= val <= 100\r\n> 每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n> ```\r\n#用一个数组记录栈操作的对应所加值\r\n每当需要弹出的时候，再加上那个需要加的值即可，然后同时更新下一个位置的附加值\r\n\r\n\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.add=[]\r\n        self.maxSize=maxSize\r\n        self.values=[]\r\n        self.count=0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.count<self.maxSize:\r\n            self.count+=1\r\n            self.values.append(x)\r\n            self.add.append(0)\r\n        \r\n\r\n\r\n    def pop(self) -> int:\r\n        #栈弹出操作\r\n        if self.count<=0:\r\n            return -1\r\n        \r\n        topAdd=self.add.pop()\r\n        self.count-=1\r\n        if self.count>=1 and topAdd!=0:\r\n            self.add[-1]+=topAdd\r\n\r\n        return self.values.pop()+topAdd\r\n        \r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        minValue=k\r\n        if self.count>0:\r\n            if minValue>=self.count:\r\n                self.add[self.count-1]+=val\r\n            else:\r\n                self.add[minValue-1]+=val\r\n```\r\n   \r\n时间复杂度：O(1)，所有操作均为0(1)\r\n空间复杂度：O(n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917762117","body":"> # 394. 字符串解码\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/decode-string/\r\n> \r\n> ## 前置知识\r\n> * 栈\r\n> * 括号匹配\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个经过编码的字符串，返回它解码后的字符串。\r\n> \r\n> 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n> \r\n> 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n> \r\n> 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：s = \"3[a]2[bc]\"\r\n> 输出：\"aaabcbc\"\r\n> 示例 2：\r\n> \r\n> 输入：s = \"3[a2[c]]\"\r\n> 输出：\"accaccacc\"\r\n> 示例 3：\r\n> \r\n> 输入：s = \"2[abc]3[cd]ef\"\r\n> 输出：\"abcabccdcdcdef\"\r\n> 示例 4：\r\n> \r\n> 输入：s = \"abc3[cd]xyz\"\r\n> 输出：\"abccdcdcdxyz\"\r\n> ```\r\n解题思路：\r\n碰到']'就开始退栈，知道退栈字符为'['为止\r\n然后开始数字退栈，直到下一个数字不再是字符为止，最后提取该段解析结果，进栈\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        l=0\r\n        str_array=[]\r\n        while l<len(s):\r\n            str_array.append(s[l])\r\n\r\n            if s[l]==']':\r\n                str1=''\r\n                s2=str_array.pop()\r\n                while s2!='[':\r\n                    s2=str_array.pop()\r\n                    if s2!='[':\r\n                        str1=s2+str1\r\n                        \r\n                numStr=''\r\n                while len(str_array)>=1 and str_array[-1] in '01213456789':\r\n                    numStr=str_array.pop()+numStr\r\n                str_array.append(str1*int(numStr))\r\n            l+=1\r\n        return ''.join(str_array)\r\n                \r\n```\r\n时间复杂度：O(N)\r\n空间复杂度: O(N)            \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918730006","body":"> # 232. 用栈实现队列\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n> \r\n> ## 前置知识\r\n> * 栈\r\n> * 队列\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 使用栈实现队列的下列操作：\r\n> \r\n> push(x) -- 将一个元素放入队列的尾部。\r\n> pop() -- 从队列首部移除元素。\r\n> peek() -- 返回队列首部的元素。\r\n> empty() -- 返回队列是否为空。\r\n> 示例:\r\n> \r\n> MyQueue queue = new MyQueue();\r\n> \r\n> queue.push(1);\r\n> queue.push(2);\r\n> queue.peek(); // 返回 1\r\n> queue.pop(); // 返回 1\r\n> queue.empty(); // 返回 false\r\n> 说明:\r\n> \r\n> 你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n> 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n> 假设所有操作都是有效的、 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\r\n> ```\r\n\r\n\r\n\r\n> # 232. 用栈实现队列\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n> \r\n> ## 前置知识\r\n> * 栈\r\n> * 队列\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 使用栈实现队列的下列操作：\r\n> \r\n> push(x) -- 将一个元素放入队列的尾部。\r\n> pop() -- 从队列首部移除元素。\r\n> peek() -- 返回队列首部的元素。\r\n> empty() -- 返回队列是否为空。\r\n> 示例:\r\n> \r\n> MyQueue queue = new MyQueue();\r\n> \r\n> queue.push(1);\r\n> queue.push(2);\r\n> queue.peek(); // 返回 1\r\n> queue.pop(); // 返回 1\r\n> queue.empty(); // 返回 false\r\n> 说明:\r\n> \r\n> 你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n> 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n> 假设所有操作都是有效的、 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\r\n> ```\r\n\r\n#思路\r\n用一个栈来接收输入，一个栈负责输出，每次需要弹出或者返回顶部值时，使用输出栈进行弹出操作\r\n#python\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack=[]\r\n        self.outStack=[]\r\n        \r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n       \r\n    def in2out(self):\r\n        while self.inStack:\r\n            self.outStack.append(self.inStack.pop())\r\n  \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.outStack:#outStack如果是空的话，就将元素全部转移过去\r\n            self.in2out()\r\n\r\n        return self.outStack.pop()\r\n        \r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.outStack:\r\n            self.in2out()\r\n        return self.outStack[-1]\r\n\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if not self.inStack and not self.outStack:\r\n            return True\r\n        else:\r\n            return False\r\n```\r\n        \r\n#时间复杂度：O(1)，各种入队出队操作\r\n#空间复杂度：O(n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920145466","body":"> # 768. 最多能完成排序的块 II\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n> \r\n> ## 前置知识\r\n> * 栈\r\n> * 单调栈\r\n> * 队列\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\r\n> \r\n> arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n> \r\n> 我们最多能将数组分成多少块？\r\n> \r\n> 示例 1:\r\n> \r\n> 输入: arr = [5,4,3,2,1]\r\n> 输出: 1\r\n> 解释:\r\n> 将数组分成2块或者更多块，都无法得到所需的结果。\r\n> 例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\r\n> 示例 2:\r\n> \r\n> 输入: arr = [2,1,3,4,4]\r\n> 输出: 4\r\n> 解释:\r\n> 我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\r\n> 然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\r\n> 注意:\r\n> \r\n> arr的长度在[1, 2000]之间。\r\n> arr[i]的大小在[0, 10**8]之间。\r\n> ```\r\n#单调栈解法，用一个单调栈，如果当前栈为空或者栈尾部元素小于等于即将入栈元素，则直接入栈，否则就先弹出当前栈最大元素，然后如果栈中元素大于即将入栈元素则一一退栈，最后再讲最大值入栈，这个最大值代表着前面必须是一段。因此最终单调栈有几个元素就有最多几块。\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack=[]\r\n        for num in arr:\r\n            if not stack or stack[-1]<=num:\r\n                stack.append(num)\r\n            else:\r\n                max_value=stack.pop()\r\n                while  stack and stack[-1]>num:\r\n                    stack.pop()\r\n                stack.append(max_value)\r\n        return len(stack)\r\n\r\n```\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920989455","body":"> # 61. 旋转链表\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/rotate-list/\r\n> \r\n> ## 前置知识\r\n> * 求单链表的倒数第 N 个节点\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。\r\n> \r\n> 示例 1:\r\n> \r\n> 输入: 1->2->3->4->5->NULL, k = 2\r\n> 输出: 4->5->1->2->3->NULL\r\n> 解释:\r\n> 向右旋转 1 步: 5->1->2->3->4->NULL\r\n> 向右旋转 2 步: 4->5->1->2->3->NULL\r\n> 示例 2:\r\n> \r\n> 输入: 0->1->2->NULL, k = 4\r\n> 输出: 2->0->1->NULL\r\n> 解释:\r\n> 向右旋转 1 步: 2->0->1->NULL\r\n> 向右旋转 2 步: 1->2->0->NULL\r\n> 向右旋转 3 步: 0->1->2->NULL\r\n> 向右旋转 4 步: 2->0->1->NULL\r\n> ```\r\n双指针解法，慢指针比快指针慢k步，然后快指针到达末尾时，正好慢指针所在位置为倒数第k个节点，将慢指针指向None，快指针指向开头就行了\r\n\r\npython\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        count=0\r\n        now=head\r\n        while now:\r\n            now=now.next\r\n            count+=1\r\n        print(count)\r\n        k=k%count\r\n        fast=slow=head\r\n        i=0\r\n        while fast and fast.next:\r\n            if i>=k:\r\n                slow=slow.next#找到了第k个\r\n            fast=fast.next\r\n            i+=1\r\n        head2=slow.next#一种特殊情况是，到达末尾了，第k个节点已经指向None，所以直接返回head就行\r\n        if head2:\r\n            slow.next=None\r\n            fast.next=head\r\n            return head2\r\n        else:\r\n            return head\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921643238","body":"> # 24. 两两交换链表中的节点\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n> \r\n> ## 前置知识\r\n> * 链表的基本知识\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n> \r\n> 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> ```\r\n> \r\n> ![image](https://camo.githubusercontent.com/37e86afda9f65871e855a3affee582b2c887ab3087927b4dc92801bc6d4ad26f/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31302f30332f737761705f6578312e6a7067)\r\n> \r\n> ```\r\n> 输入：head = [1,2,3,4]\r\n> 输出：[2,1,4,3]\r\n> 示例 2：\r\n> \r\n> 输入：head = []\r\n> 输出：[]\r\n> 示例 3：\r\n> \r\n> 输入：head = [1]\r\n> 输出：[1]\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 链表中节点的数目在范围 [0, 100] 内\r\n> 0 <= Node.val <= 100\r\n> ```\r\n### 思路\r\n创建一个空节点，让这个空节点指向链表，然后设置链表的前驱节点prev为空节点，那么每次只需要反转prev.next以及prev.next.next, 直到链表中prev.next 后者prev.next.next为空为止，最后返回空节点.next就行了\r\n### python\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        node1=ListNode(-1)\r\n        node1.next=head\r\n        node2=node1\r\n        prev=node1\r\n        tmp=node1\r\n        #链表题的诀窍就是存前驱动和后驱节点\r\n        while prev.next and prev.next.next:\r\n            node3=prev.next\r\n            node4=prev.next.next\r\n            \r\n\r\n            prev.next=node4\r\n            tmp=node4.next\r\n            node4.next=node3\r\n            node3.next=tmp\r\n            prev=node3\r\n        \r\n        return node1.next\r\n\r\n```\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922329648","body":"> # 109. 有序链表转换二叉搜索树\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\r\n> \r\n> ## 前置知识\r\n> * 递归\r\n> * 二叉搜索树的任意一个节点，当前节点的值必然大于所有左子树节点的值。同理,当前节点的值必然小于所有右子树节点的值\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\r\n> \r\n> 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\r\n> \r\n> 示例:\r\n> \r\n> 给定的有序链表： [-10, -3, 0, 5, 9],\r\n> \r\n> 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\r\n> \r\n>     0\r\n>    / \\\r\n>  -3   9\r\n>  /   /\r\n> -10  5\r\n> ```\r\n参考官方题解\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return head\r\n        pre=None\r\n        slow=fast=head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n\r\n```\r\n\r\n时间复杂度：O(NlogN)\r\n空间复杂度：O(N)\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922494392","body":"> # 160. 相交链表\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n> \r\n> ## 前置知识\r\n> * 链表\r\n> * 双指针\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 编写一个程序，找到两个单链表相交的起始节点。\r\n> ```\r\n#解法一\r\n\r\n\r\n> # 160. 相交链表\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n> \r\n> ## 前置知识\r\n> * 链表\r\n> * 双指针\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 编写一个程序，找到两个单链表相交的起始节点。\r\n> ```\r\n#第一种解法：hash方法\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        dict1=set()\r\n        while headA:\r\n            dict1.add(headA)\r\n            headA=headA.next\r\n        while headB:\r\n            if headB in dict1:\r\n                return headB\r\n            headB=headB.next\r\n        return None\r\n\r\n\r\n```\r\n时间复杂度：O(M+N)\r\n空间复杂度：O(M)后者O(N)\r\n\r\n\r\n#第二种解法\r\n可以理解为，让他们走同样路程的路，速度一样，在一条路上总会相遇\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a=headA\r\n        b=headB\r\n        while headB or  headA:\r\n            if headA==headB:\r\n                return headA\r\n            headA=headA.next\r\n            headB=headB.next\r\n            if headA==None and headB==None:\r\n                break\r\n            #一个到头了\r\n            if not headA:\r\n                headA=b\r\n                \r\n            if not headB:\r\n                headB=a   \r\n        return None\r\n\r\n```\r\n\r\n时间复杂度：O(M)+O(N)\r\n空间复杂度：O(1)\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuyangqiQAQ":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916566326","body":"### 一位一位相加即可\n````java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int x = 0;\n        LinkedList<Integer> list = new LinkedList<>();\n        for (int i = 0; i < num.length; i++) {\n            int num1 = num[num.length - i - 1];\n            int num2 = k % 10;\n            k /= 10;\n            int sum = num1 + num2 + x;\n            if(sum >= 10) {\n                sum = sum - 10;\n                x = 1;\n            }else {\n                x = 0;\n            }\n            list.addFirst(sum);\n        }\n        while (k > 0 || x == 1) {\n            int num1 = k % 10 + x;\n            k /= 10;\n            if(num1 >= 10) {\n                num1 -= 10;\n                x = 1;\n            }else {\n                x = 0;\n            }\n            list.addFirst(num1);\n        }\n\n        return list;\n    }\n}\n````\n### 复杂度分析\n时间复杂度: O(max(n, logk))\n空间复杂度: O(max(n, logk)) 存储需要返回的结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917345699","body":"### 开始没理解思路只能暴力破解\n````java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] nums = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            int left = i;\n            int right = i;\n            while (left >= 0 || right <s.length()) {\n                if(left >= 0) {\n                    if(s.charAt(left) == c) {\n                        nums[i] = Math.abs(i - left);\n                        break;\n                    }\n                    left--;\n                }\n                if(right < s.length()) {\n                    if(s.charAt(right) == c) {\n                        nums[i] = Math.abs(i - right);\n                        break;\n                    }\n                    right++;\n                }\n            }\n        }\n        return nums;\n    }\n}\n````\n\n### 两次for循环\n````java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] nums = new int[s.length()];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == c) pre = i;\n            nums[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if(s.charAt(i) == c) pre = i;\n            nums[i] = Math.min(nums[i], pre - i);\n        }\n        return nums;\n    }\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917613990","body":"````java\nclass CustomStack {\n\n    int[] nums;\n\n    int first = 0;\n\n    int count = 0;\n\n    public CustomStack(int maxSize) {\n        nums = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(count == nums.length) {\n            return;\n        }\n        if(first == nums.length - 1) {\n            first = 0;\n        }else {\n            first++;\n        }\n        nums[first] = x;\n        count++;\n    }\n    \n    public int pop() {\n        if(count == 0) {\n            return -1;\n        }\n        int res = nums[first];\n        if(first == 0) {\n            first = nums.length - 1;\n        }else {\n            first--;\n        }\n        count--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        if(count == 0) {\n            return;\n        }\n        if(k > nums.length) {\n            k = nums.length;\n        }\n        int index = first;\n        //找到栈底指针\n        for (int i = 0; i < count - 1; i++) {\n            if(index == 0) {\n                index = nums.length - 1;\n            }else {\n                index--;\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            nums[index] += val;\n            if(index == nums.length - 1) {\n                index = 0;\n            }else {\n                index++;\n            }\n        }\n    }\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917766185","body":"````java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder strBud = new StringBuilder();\n        Stack<Character> stack = new Stack<>();\n        for (int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == ']') {\n                StringBuilder str = new StringBuilder();\n                while (true) {\n                    char c = stack.pop();\n                    if(c == '[') break;\n                    else str.append(c);\n                }\n                int k = 0;\n                //计算k\n                int a = 1;\n                while (!stack.isEmpty() && stack.peek() >= '0' && stack.peek() <= '9') {\n                    k += a * (stack.pop() - '0');\n                    a *= 10;\n                }\n                String s1 = str.toString();\n                for (int j = 0; j < k; j++) {\n                    for (int l = s1.length() - 1; l >= 0; l--) {\n                        stack.push(s1.charAt(l));\n                    }\n                }\n            }else {\n                stack.push(s.charAt(i));\n            }\n        }\n        while (!stack.isEmpty()) {\n            strBud.append(stack.pop());\n        }\n        return strBud.reverse().toString();\n    }\n}\n````\n### 时间复杂度:O(n) n为字符串长度，因为拼接时时间复杂度会变成O(k * n)。但总的复杂度o(n)\n### 空间复杂度:O(n) n为字符串长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918704600","body":"### 一个用于存储。一个用于取。\n````java\nclass MyQueue {\n\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(this.empty()) {\n            return -1;\n        }\n        if(stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        if(this.empty()) {\n            return -1;\n        }\n        if(stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.empty();\n    }\n}\n````\n时间复杂度: 存:O(1).取:O(1)，最坏时间复杂度:O(n)\n空间复杂度: 存O(n)，取空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919625186","body":"````java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        for (int num : arr) {\r\n            if(!stack.isEmpty()){\r\n                int top = stack.peek();\r\n                if(num > top) {\r\n                    stack.push(num);\r\n                }else {\r\n                    //出栈\r\n                    while (!stack.isEmpty() && stack.peek() > num) stack.pop();\r\n                    stack.push(top);\r\n                }\r\n            }else {\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n````\r\n### 时空复杂度\r\n 时间复杂度：O(N)\r\n 空间复杂度:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920508704","body":"\n### 思路都在注释了\n````java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(k == 0 || head == null) return head;\n        //获取链表长度\n        int length = 0;\n        for (ListNode current = head; current != null; current = current.next)\n            length++;\n        //用长度对k求余数获取从某个节点开始旋转\n        int index = length - k % length;\n        ListNode current = head;\n        for (int i = 0; i < index - 1; i++) {\n            current = current.next;\n        }\n        if(current.next == null) return head;\n        ListNode tempHead = current.next;\n        current.next = null;\n        ListNode node = tempHead;\n        for(; node.next != null; node = node.next);\n        node.next = head;\n        return tempHead;\n    }\n}\n````\n### 复杂度分析\n时间复杂度: 总时间复杂度为O(2*n)。所以时间复杂度为O(n) n为链表长度\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921378189","body":"### 关于任意节点交换的链表只需要在它前面创建一个节点pre一切都简单多了。如果单单只换值更简单。本题要求要换节点故在head前创建一个节点。直接返回pre.next即可。\n````java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode current = head;\n        ListNode pre = new ListNode(0, head);\n        ListNode res = pre;\n        ListNode next = head == null ? null: current.next;\n        while (next != null) {\n            pre.next = next;\n            current.next = next.next;\n            next.next = current;\n            pre = current;\n            current = current.next;\n            next = current == null ? null : current.next;\n        }\n        return res.next;\n    }\n}\n````\n###时空分析:\n时间复杂度: O(N) 链表长度\n空间复杂度: O(1) 只需要创建一个节点即可。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922162114","body":"### 最简单的方法就是将链表转成list只需要遍历一遍即可\n````java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        List<Integer> list = new ArrayList<>();\n        for(ListNode node = head; node != null; node = node.next) {\n            list.add(node.val);\n        }\n        return buildTree(list, 0, list.size() - 1);\n    }\n    public TreeNode buildTree(List<Integer> list, int left, int right) {\n        if(left <= right) {\n            int mid = left + (right - left) / 2;\n            TreeNode node = new TreeNode(list.get(mid));\n            node.left = buildTree(list, left, mid - 1);\n            node.right = buildTree(list, mid + 1, right);\n            return node;\n        }\n        return null;\n    }\n}\n````\n###  复杂度分析:\n时间复杂度:O(n）\n空间复杂度:O(N)\n\n### 将他变成list无非是为了更方便的找中间点，如果不想开销额外的空间我们可以通过快慢指针每次都找出链表中间点也可以做到。\n````java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n    public TreeNode buildTree(ListNode head, ListNode endNode) {\n        if(head != endNode) {\n            ListNode midNode = getMidNode(head, endNode);\n            TreeNode treeNode = new TreeNode(midNode.val);\n            treeNode.left = buildTree(head, midNode);\n            treeNode.right = buildTree(midNode.next, endNode);\n            return treeNode;\n        }\n        return null;\n    }\n    //寻找中间节点\n    public ListNode getMidNode(ListNode head, ListNode endNode) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != endNode && fast.next != endNode) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n````\n###  复杂度分析:\n时间复杂度:O(n）\n空间复杂度:O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"newbeenoob":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916566437","body":"## 思路\r\n\r\n---\r\n\r\n从数组末尾（个位）开始，逐位相加，并计算进位，因为是从低位开始计算，每次结果都要添加到结果数组的头部\r\n\r\n## 代码：JavaScript\r\n\r\n---\r\n\r\n```JavaScript\r\nvar addToArrayForm = function(num, k) {\r\n    const ans = [];\r\n    let carry = 0;\r\n    let cur;\r\n    let Addres;\r\n    let item;\r\n    let pos = num.length - 1;\r\n    do {\r\n        cur = k % 10;\r\n        k = ~~(k / 10); // ~~ 用于下取整\r\n        item = num[pos] ?? 0;\r\n        Addres = (cur + carry + item) % 10;\r\n        carry = ~~((cur + carry + item) / 10);\r\n        ans.unshift(Addres);\r\n        --pos;\r\n    } while( (k || carry) || pos >= 0)\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n---\r\n\r\n- 时间复杂度： `O(n + logk)`  n 为输入数组长度，k为非负整数大小\r\n\r\n- 额外空间复杂度： `O(1)`  \r\n\r\n## 标签\r\n\r\n---\r\n\r\n`数组` , `模拟`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917321008","body":"## 思路\n\n---\n\n好多大佬都已经写出最优解了，这里想探究其他的 （更麻烦的😂做法) ，套的通用的BFS模板..\n\n## 代码：JavaScript\n\n---\n\n```JavaScript\nvar shortestToChar = function(s, target) {\n    \n    // BFS 模板\n    const dist = new Array(s.length).fill(Infinity);\n    const q = [];\n\n    for(let i = 0 ; i < s.length ; ++i) {\n        if (s[i] === target) {\n            dist[i] = 0;\n            q.push(i);\n        }\n    }\n\n    while(q.length){\n        const sz = q.length;\n        for(let _ = 0 ; _ < sz ; ++_) {\n            const head = q.shift();\n            if (dist[head] !== target) {\n                if (head + 1 < dist.length && dist[head + 1] > dist[head] + 1) {\n                    dist[head + 1] = dist[head] + 1;\n                    q.push(head + 1);\n                }\n                if (head - 1 >= 0 && dist[head - 1] > dist[head] + 1) {\n                     dist[head - 1] = dist[head] + 1\n                     q.push(head - 1)\n                }\n            }; \n        }\n    }\n\n    return dist;\n};\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度： `O(n^2)` \n\n- 额外空间复杂度： `O(n)`  开了一个队列\n\n## 标签\n\n---\n\n`字符串` , `广度优先遍历`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917601494","body":"## 思路1 - 直观思维，数组模拟栈，直接遍历加入增量\n\n```JavaScript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.topPointer = -1;\n    this.stack = new Array(maxSize).fill(0);\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.topPointer === this.maxSize - 1) return;\n    this.topPointer++;\n    this.stack[this.topPointer] = x;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.topPointer === -1) return -1;\n    const ret = this.stack[this.topPointer];\n    this.topPointer--;\n    return ret;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const len = this.getSize();\n\n    for(let i = 0 ; i < len && i < k ; ++i ) {\n        this.stack[i] += val;\n    }\n};\n\nCustomStack.prototype.getSize = function() {\n    return this.topPointer + 1;\n}\n```\n\n\n\n\n\n## 思路2 - 惰性计算增量\n\n```JavaScript\n// 这个思路的核心在于惰性计算增量，也就是等弹出的时候才会计算增量\n// 维护一个增量表，记录栈中对应元素应有的增量\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.topPointer = -1;\n    this.stack = new Array(maxSize).fill(0);\n    this.incTable = new Array(maxSize).fill(0);\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.topPointer === this.maxSize - 1) return;\n    this.topPointer++;\n    this.stack[this.topPointer] = x;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.topPointer === -1) return -1;\n    const inc = this.incTable[this.topPointer];\n    if(this.topPointer > 0 && inc > 0) this.incTable[this.topPointer - 1] += inc;\n\n    const ret = this.stack[this.topPointer] + inc;\n    this.incTable[this.topPointer] = 0; // 弹出的元素需要消除对应位置的增量\n    this.topPointer--;\n    return ret;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const curSize = this.getSize();\n    curSize > k ? this.incTable[k-1] += val : this.incTable[curSize - 1] += val;\n};\n\nCustomStack.prototype.getSize = function() {\n    return this.topPointer + 1;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917984606","body":"## 思路\n\n---\n\n设置两个辅助栈，一个用于存储数字，一个用于存储`encoded_string`  （这个栈内最后的内容就是结果）\n遇到数字时候，要记得处理连续的数字位，`n = n * 10 + cur`  最后再压入数字栈\n遇到非数字时，分情况讨论：\n\n  1. 遇到 右方括号，代表括号闭合，不断弹出栈直到遇到最近的左方括号，在这个过程当中弹出的栈就是要重复k次的`encoded string` ， 从数字栈中弹出一个元素 , `repeat` 计算后再放回 `encoded_string`栈内\n\n  2. 其余情况一股脑入栈即可\n\n## 代码：Javascript\n\n---\n\n```JavaScript\nvar decodeString = function(s) {\n    let ans = \"\";\n\n    let data = [];\n    let count = [];\n    s = s.split('');\n    for(let i = 0 ; i < s.length ; ++i){\n        if(isNaN(+s[i])){\n            if(s[i] === ']'){\n                let temp = '';\n                while(data[data.length - 1] !== '[') {\n                    temp += data.pop();\n                }\n                data.pop();\n                let times = count.pop();\n                data.push(temp.repeat(times));\n            }else{\n                data.push(s[i]);\n            }\n\n\n        }else if(!isNaN(+s[i])){\n            let num = 0;\n\n            while(!isNaN(+s[i])) {\n                num = +s[i] + num * 10;\n                ++i;\n            }\n            \n            count.push(num);\n            --i;\n        }\n    }\n\n    return data.reduce((acc , cur) => {\n        return acc + cur.split('').reverse().join('')\n    } , '')\n};\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度： `O(n)`  n 为输入字符串长度\n\n- 额外空间复杂度： `O(max(k)*max(len(s)))`  max(k)代表最大的整数大小（重复次数），max(len(s)) 代表最长的encoded_string\n\n## 标签\n\n---\n\n`字符串` , `栈`","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920008709","body":"## 思路\n\n---\n\n这道题不太理解，也是研究了大佬的题解才思考出来的，这里题目要求我们给输入数组分块，使得每一块经过排序之后，拼接完毕之后得到的数组与升序排序之后的数组一致（块间顺序不能变），并且求最多的分块数（有点贪心的意思），这道题既然是放在单调栈标签里面的，那就先尝试用单调栈解决\n\n这里维护一个单调递增的栈，栈中元素的含义是（每个分块当中的最大值），挨个把数组内元素送入单调栈，压入的时候定义以下规则：\n\n  1. 如果栈中为空 或者 即将入栈的元素大于等于栈顶元素，代表这里我们可以划分出一个新块来，新块的最大值就是入栈元素，这里直接压栈就好\n\n  2. 否则，代表这个元素要并入之前划分好的某一个或者多个块内，只要栈顶元素是大于当前元素的，就以此弹栈，直到找到了这个元素在有序数组当中应在的位置，（这里我自我感觉有点像插入排序）可以开始合并分块了，下面的操作比较关键：**始终记住栈中存着的元素是某个分块的最大值**，那么当前元素其实并不配被压入栈，所以要记录一下之前第一个弹出的栈顶元素，它是未来合并块之后新块的最大值，在依次弹栈之后还需要把它再压回去，以维护这里单调栈的定义。\n\n## 代码：JavaScript\n\n---\n\n```JavaScript\nvar maxChunksToSorted = function(arr) {\n    // 单调栈\n    const increasingStack = [];\n\n    for(let num of arr){\n        if (!increasingStack.length || increasingStack[increasingStack.length - 1] <= num) {\n            increasingStack.push(num);\n            continue;\n        }\n        const maxVal = increasingStack.pop()\n\n        while(increasingStack[increasingStack.length - 1] > num) increasingStack.pop();\n\n        increasingStack.push(maxVal)\n    }\n\n    return increasingStack.length;\n};\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度： `O(n)`  n 为输入数组长度\n\n- 额外空间复杂度： `O(n)`  即单调栈消耗的最大空间（极端情况下输入数组完全升序有序，最多可分n个块，栈容量 === 数组长度）\n\n## 标签\n\n---\n\n`数组` , `排序` , `单调栈`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920775761","body":"## 思路\n\n---\n\n遇到这种循环移位的问题，首先要对 旋转长度 k 取模，`k mod len` 得出有效的旋转长度，其中`len`为链表的总长，设置快慢指针，快指针先出发到达链表的第k位，慢指针再后出发，直到快指针走到最尽头，此时需要记录快指针和慢指针的位置，快指针所在的位置就是旧链表的尾巴，慢指针所在的位置就是新链表的头，其前一项就是新链表的尾，重新拼接之后，便得到了旋转后的链表。\n\n以下情况需要特判一下：空表，单节点的表，`k mod len` 为 0 的情况，直接返回 head 即可。\n\n## 代码：JavaScript\n\n```JavaScript\nvar rotateRight = function(head, k) {\n    \n    if(!head || !head.next || !k) return head;\n\n    let p = head;\n    let len = 0;\n    while(p){\n        p = p.next;\n        ++len;\n    }\n\n    k %= len;\n\n    if(!k) return head;\n\n    p = head;\n    for(let _ = 0 ; _ < k ; ++_ ){\n        p = p.next;\n    }\n    let newHead = head;\n    let newTail;\n    let oldTail;\n    while(p){\n        if(p && !p.next) {\n            oldTail = p;\n            newTail = newHead;\n        }\n        p = p.next;\n        newHead = newHead.next;\n    }\n    newTail.next = null;\n    oldTail.next = head;\n    return newHead;\n};\n```\n\n---\n\n## 复杂度分析\n\n---\n\n- 时间复杂度： `O(n)` \n\n- 额外空间复杂度： `O(1)`  原地操作指针\n\n## 标签\n\n---\n\n`链表` , `快慢指针`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921517512","body":"## 思路\n\n---\n\n为了方便操作，增加一个虚拟头节点（`dummy`），维护四个指针，分别指向前一项，待交换节点1，待交换节点2，下一项，每次两两交换，注意一些边界情况的判断：空链表，单节点链表，奇数个元素的链表）每次交换后需要更新四个指针的指向。\n\n## 代码：JavaScript\n\n```JavaScript\nvar swapPairs = function(head) {\n    let dummy = new ListNode(-1);\n\n    dummy.next = head;\n\n    if(!dummy.next || !dummy.next.next) return head;\n\n    let pre = dummy , p1 = head , p2 , next;\n\n    while(p1){\n        p2 = p1.next;\n        if(!p2) break; // 奇数个元素时 剩下落单的节点，无需交换\n        next = p2.next;\n        p1.next = next;\n        pre.next = p2;\n        p2.next = p1;\n\n        // update\n        pre = p1;\n        p1 = next;\n    }\n\n    return dummy.next;\n};\n```\n\n---\n\n## 复杂度分析\n\n---\n\n- 时间复杂度： `O(n)` \n\n- 额外空间复杂度： `O(1)`  原地操作指针\n\n## 标签\n\n---\n\n`链表` ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922241558","body":"## 思路\n\n---\n\n这道题类似于有序数组转二叉搜索树，每次折半，将左半边和右半边分别作为左子树和右子树，不断递归，直到所有节点都已经用完，与数组不同的是其取中间节点的方式不能直接下标索引访问，而是需要通过快慢指针找到中间节点，并且不仅需要记录中间节点，还需要记录中间节点的前驱，以便于将链表切割。\n\n## 代码：JavaScript\n\n```JavaScript\nvar sortedListToBST = function(head) {\n\n    const findMid = (head) => {\n        let dummy = new ListNode(-1);\n        dummy.next = head;\n\n        let slow = dummy , fast = dummy;\n        let pre = null; // slow 的前驱\n        let count = 0;\n        while(fast && fast.next) {\n            if(count) pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n            ++count;\n        }\n\n        return {pre , slow};\n    }\n    \n    // 分别对于空链表和独头链表特判\n    if (!head) return null; \n\n    else if (!head.next) return new TreeNode(head.val);\n\n    const {pre , slow} = findMid(head);\n    let leftHead = head , rightHead = slow.next;\n    if (!pre) leftHead = null; // pre不存在代表左子树为空\n    if (pre) pre.next = null; // pre存在则从pre这一位置断开原链表 完成拆分\n\n    slow.next = null;\n    const node = new TreeNode(slow.val);\n    node.left = sortedListToBST(leftHead);\n    node.right = sortedListToBST(rightHead);\n    \n    return node;\n\n};\n```\n\n---\n\n## 复杂度分析\n\n---\n\n- 时间复杂度： `O(nlogn)` 递归深度为log2n，也就是递归log2n次，每次查找中间节点的操作都是 `o(n)` 的时间复杂度，所以总共为 nlogn\n\n- 额外空间复杂度： `O(logn)`  其空间为递归栈的深度，每次都折半，栈深度为log2n\n\n## 标签\n\n---\n\n`链表` , `快慢指针` ，`递归`\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922402184","body":"## 思路\n\n---\n\n相向运动相遇问题 先计算长度，得出长短链表的差值`diff`，让长链表先走`diff`个距离，然后让长短链表以同速向前走，直到两指针相撞（有交点）或者两指针都走到了末尾（`==null`）代表没有交点\n\n## 代码：JavaScript\n\n```JavaScript\nvar getIntersectionNode = function(headA, headB) {\n    \n    if (!headA || !headB) return null;\n\n    let p1 = headA , p2 = headB;\n    \n    // 先计算长度\n    let len1 = 0 , len2 = 0;\n    while(p1) {\n        p1 = p1.next;\n        len1++;\n    }\n\n    while(p2) {\n        p2 = p2.next;\n        len2++;\n    }\n    let fast , slow;\n    let diff = Math.abs(len1 - len2);\n    if (len1 > len2) {\n        fast = headA; slow = headB;\n    } else {\n        fast = headB; slow = headA;\n    }\n\n    while(diff){\n        --diff;\n        fast = fast.next;\n    }\n\n    while(fast && slow && fast !== slow) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n\n    return slow;\n};\n```\n\n---\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：`o(n)`  一趟计算长度，一趟双指针走一趟\n\n- 额外空间复杂度： `o(1)`\n\n## 标签\n\n---\n\n`链表` , `双指针` ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samaritan1998":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916568209","body":"### 思路：\n\n和链表相加一样，while后面的条件是 || 然后循环里面再去判断\n\n### 代码：\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n=len(num)\n        i=n-1\n        res=[]\n        carry=0\n        while i>=0 or k!=0  or carry:\n            temp=0\n            if(i>=0):\n                temp+=num[i]\n                i-=1\n            if(k!=0):\n                temp+=k%10\n                k//=10\n                \n            res.append((temp+carry)%10)\n            carry=(temp+carry)//10\n        return res[::-1]\n```\n\n### 时间复杂度\n\nO(max（n，log(k)）) n为数组长度\n\n拓展一下链表加法\n\n```python\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        p=ListNode(0)\n        head=p\n        carry=0\n        while (l1 or l2 or carry):\n            if l1:\n                carry+=l1.val\n                l1=l1.next\n            if l2:\n                carry+=l2.val\n                l2=l2.next\n            p.next=ListNode(carry%10)\n            p=p.next\n            carry=carry//10\n        return head.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917634691","body":"```\nclass Solution(object):\n    def shortestToChar(self, S, C):\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(S):\n            if x == C: prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in xrange(len(S) - 1, -1, -1):\n            if S[i] == C: prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917634523","body":"``` python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ginnydyy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916568816","body":"## Problem\nhttps://leetcode.com/problems/add-to-array-form-of-integer/\n\n## Notes\n- Cannot solve the problem by converting `num` to int then do the addition and convert it back to int array. Because `1 <= num.length <= 104` and Integer.MAX_VALUE is smaller than that, the conversion or addition will cause overflow.\n- When doing addition, need to consider when the sum is larger than `9`, need to do the `k++` and `sum -= 10` to carry `1`, after `k /= 10`.\n- The length of `num` may be shorter than the length of `k`, the first loop condition should use the length of `num`. Use the second loop to convert the remain of `k`.\n- The length of `num` may be longer than the length of `k`, since `k%10` and `k/10` will be always 0 after `k` becomes 0, so it's ok to use the length of `num` in the first loop.\n- The original length of ArrayList is `10`, and the solution can always add the new digit at index 0 of the List, perhaps using LinkedList as the returned List would have better performance.\n\n## Solution\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new LinkedList<>();\n        for(int i = num.length - 1; i >= 0; i--){\n            int sum = num[i] + k%10;\n             k /= 10;\n            if(sum > 9){\n                k++;\n                sum -= 10;\n            }\n            result.add(0, sum);\n        }\n        while(k > 0){\n            result.add(0, k%10);\n            k /= 10;\n        }\n        return result;\n    }\n}\n```\n\n## Complexity\n- Time: The solution processes each element of `num` and each digit of `k`. So it's O(max(n, `the number of digits of k`)). And the `the number of digits of k` is `logk` (https://brilliant.org/wiki/finding-digits-of-a-number/). So it's O(max(n, logk)) (n is the length of `num`).\n- Space: Except the returned List, the extra space used is O(1).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334085","body":"## Problem\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\n\n## Notes\n- Scan the input array from left to right, set the distance between each element and the previous seen char `c` to the result array (`pos - i`).\n- Start from index `0`, the initial value of `pos` (the index of the last seen char `c`) is `-n` (`n` is the lenght of input array), so the distance of the elements scanned before the first seen char `c` would be an int greater than `n`. Thus, when scanning from right to left, the new distance would be shorter than it and be adopted.\n- Scan the input array from right to left, the new distance between each element and the previous seen char `c` (`i - pos`) is compared to the current distance, update it with the shorter one.\n- Start from index `pos - 1`, because the distance of the elements on the right side of `pos` won't be updated.\n\n## Solution\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int pos = -n;\n        int[] result = new int[n];\n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) == c){\n                pos = i;\n            }\n            result[i] = i - pos;\n        }\n        for(int i = pos - 1; i >= 0; i--){\n            if(s.charAt(i) == c){\n                pos = i;\n            }\n            result[i] = Math.min(result[i], pos - i);\n        }\n        \n        return result;\n    }\n}\n```\n\n## Complexity\n- Time: Scan twice. O(n).\n- Space: The returned array. O(n).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917549800","body":"## Problem\nhttps://leetcode.com/problems/design-a-stack-with-increment-operation/\n\n## Notes\n- Design a stack backed by an array.\n- Initialize the array using the `maxSize` (constructor parameter). Use the `size` to record the actual number of elements in the stack.\n- `push`/`pop` elements to/from the end of the array (the right side).\n\n## Solution\n```java\nclass CustomStack {\n    private int[] array;\n    private int size = 0;\n\n    public CustomStack(int maxSize) {\n        array = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(size < array.length){\n            array[size] = x;\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if(size == 0){\n            return -1;\n        }\n        int result = array[size - 1];\n        size--;\n        return result;\n    }\n    \n    public void increment(int k, int val) {\n        if(size == 0){\n            return;\n        }\n        int count = Math.min(k, size);\n        for(int i = 0; i < count; i++){\n            array[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n## Complexity\n- Time: push: O(1); pop: O(1); increment: O(min(k, n)) (n is the number of elements in the stack).\n- Space: O(maxSize) for the backed array. O(1) for extra space.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917979362","body":"## Problem\nhttps://leetcode.com/problems/decode-string/\n\n## Notes\n- Scan the characters of the input String while pushing them into a stack.\n- `]` is the key point, when seeing it, start popping characters from the stack.\n  - Keep popping characters (they are all letters) until seeing the `[`.\n  - Use a `LinkedList` to store the letters being popped, always add the letter to the index 0 (head) of the list.\n  - Pop the `[` and dump it.\n  - Keep popping characters (they are all digits) until the next one is not a digit.\n  - Use base (1, 10, 100...) to process the digits into `k`\n  - Push the list of characters to stack `k` times\n- After scanning the input String, popping all the characters to a StringBuilder, reverse it and return it as a String. \n\n## Solution\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        \n        for(int i = 0; i < s.length(); i++){\n            char curr = s.charAt(i);\n            \n            // start to process the encoded string from stack\n            if(curr == ']'){\n                List<Character> list = new LinkedList<>();\n                while(!stack.isEmpty() && stack.peek() != '['){\n                    list.add(0, stack.pop());\n                }\n                \n                // pop the '[' from stack and dump it\n                stack.pop();\n                \n                // process the digits from stack\n                int base = 1;\n                int k = 0;\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    k += Character.getNumericValue(stack.pop()) * base;\n                    base *= 10;\n                }\n                \n                // decode the string by generating the sub string k times and push to stack\n                while(k > 0){\n                    for(char c : list){\n                        stack.push(c);\n                    }\n                    k--;\n                }\n            }else{\n               stack.push(curr); \n            }\n            \n        }\n        \n        StringBuilder result = new StringBuilder();\n        while(!stack.isEmpty()){\n            result.append(stack.pop());\n        }\n        \n        return result.reverse().toString();\n    }\n}\n```\n\n## Complexity\n- Time: O(n) (n is the length of the decoded string).\n- Space: O(n) (n is the length of the decoded string). The max size of the Stack, LinkedList and StringBuilder is n.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918883986","body":"## Problem\r\nhttps://leetcode.com/problems/implement-queue-using-stacks/\r\n\r\n## Notes\r\n- Push to the inStack. Maintain an int `front` to record the bottom item of the inStack. When inStack is empty, update `front` as the current item being pushed.\r\n- Pop from the outStack. Only if the outStack is empty, then fill it from inStack before pop operation.\r\n- When outStack is not empty, then peek from outStack, otherwise return `front` directly.\r\n\r\n## Solution\r\n```java\r\nclass MyQueue {\r\n    \r\n    Stack<Integer> inStack = new Stack<>();\r\n    Stack<Integer> outStack = new Stack<>();\r\n    int front = 0;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        // only if inStack is empty, then update front\r\n        if(inStack.empty()){\r\n            front = x;\r\n        }\r\n        inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        // only if outStack is empty then fill it\r\n        if(outStack.isEmpty()){\r\n            while(!inStack.isEmpty()){\r\n                outStack.push(inStack.pop());\r\n            }\r\n        }\r\n\r\n        return outStack.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(!outStack.isEmpty()){\r\n            return outStack.peek();\r\n        }\r\n        // only if outStack is empty, then return front\r\n        return front;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return (inStack.isEmpty() && outStack.isEmpty());\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n## Complexity\r\n- Time: \r\n  - push: O(1); \r\n  - pop: amortized O(1), worst O(n); \r\n  - peek: O(1).\r\n- Space: O(n) (n is the number of items in the stack).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919778806","body":"## Problem\nhttps://leetcode.com/problems/max-chunks-to-make-sorted-ii/\n\n## Notes\n- Scan the input array.\n  - When the current number is greater than or equal to the previous number, it means they can be splitted to different trunks.\n  - When the current number is smaller than the previous number, it means they have to be grouped to a trunk.\n    - Also need to consider all the previous numbers, if the current number is smaller than them, they have to be grouped to a trunk, until the first left most number which is greater than or equal to the current number.   \n- Use monotonic stack to store the numbers in the ascending order, each number represents a split of a trunk.\n  - When the current number is greater than or equal to the previous number, push it to the stack.\n  - When the current number is smaller than the previous number, pop out the last number from stack. And pop out all the numbers that are greater than the current one. Then push back the last number to the stack.\n  - So one smaller number on the right side triggers the merging. The last number of the stack (the max number) merges all the numbers that are smaller than the current number, including the one on its right side.\n  - When the scan of input array finishes, the size of the stack represents the largest number of trunks.\n\n ## Solution\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        // a stack with element in ascending order, each element represents a split of trunk\n        Stack<Integer> stack = new Stack<>();\n        // initialize with the first number of input array\n        stack.push(arr[0]);\n        \n        for(int i = 1; i < arr.length; i++){\n            int number = arr[i];\n            if(number < stack.peek()){ // current < max, need to merge\n                // record the max\n                int max = stack.pop();\n                \n                // merge all the previous number that are greater than the current\n                // they need to be grouped in a trunk with the max\n                while(!stack.isEmpty() && number < stack.peek()){\n                    stack.pop();\n                }\n                \n                // push back the max (as a split of trunk)\n                stack.push(max);\n            }else{\n                stack.push(number);\n            }\n        }\n        \n        return stack.size();\n    }\n}\n```\n\n## Complexity\n- Time: Scanning the input array costs O(n). Operations on the stack cost O(n). So total is O(n) (n is the size of the input array).\n- Space: O(n) for the stack.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920585796","body":"## Problem\nhttps://leetcode.com/problems/rotate-list/\n\n## Notes\n- Scan the list to count the size of the list.\n- Calculate the actual `k` using `k % size`, because `k` might be greater than the size of the list.\n  - If the actual `k` is 0, no need to rotate, return `head`.   \n- Find the kth node from the end of the list using two pointers.\n  - Right pointer move kth steps, then left pointer starts to move together with right point, until right pointer reaches the end node.\n  - When the pointers stop, the left.next points to the kth node, rotate it as the new head, and return it.\n\n## Solution\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || k == 0){\n            return head;\n        }\n        \n        // scan the list to count the size of input list\n        int size = 1;\n        ListNode node = head;\n        while(node.next != null){\n            node = node.next;\n            size++;\n        }\n        \n        // calculate the actual count of k\n        // if it equals 0, means no need to rotate\n        int count = k % size;\n        if(count == 0){\n            return head;\n        }\n        \n        // use two pointers to locate the kth node from the end of the list\n        // right pointer moves k steps, then left and right pointers move together\n        // until right pointer reaches the end of the list\n        // then left.next is the kth node from the end of the list\n        ListNode left = head;\n        ListNode right = head;\n        while(right.next != null){\n            right = right.next;\n            if(count > 0){\n                count--;\n            }else{\n                left = left.next;\n            }\n        }\n        \n        // rotate the left.next as the new head\n        ListNode result = left.next;\n        right.next = head;\n        left.next = null;\n        \n        return result;\n    }\n}\n```\n\n## Complexity\n- Time: Scan once for counting the size of the list. Scan again for finding the kth node from the end. So total is O(n) (n is the size of the list).\n- Space: O(1). No extra space used.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921329392","body":"## Problem\nhttps://leetcode.com/problems/swap-nodes-in-pairs/\n\n## Notes\n- Can use iteration or recursion to solve this problem\n- Iteration\n  - Use 4 pointers to deal with one swap, i.e. to swap A and B:\n  - preA->A->B->nextB => preA->B->A->nextB\n  - Use a virtual node as preA when A is the input head\n  - Record B as the final result before the first swap\n- Recursion\n  - Take swapping two nodes as one recursion, i.e. to swap A and B:\n    - swap A and B\n    - next recursion is to deal with B.next\n    - point A.next to the next recursion returned node\n    - return B\n\n## Solution\n- Iteration\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // iteration\n        if(head == null || head.next == null){\n            return head;\n        }\n        \n        // preA->A->B->nextB  =>  preA->B->A->nextB\n        ListNode preA = new ListNode();\n        preA.next = head;\n        ListNode A = head;\n        ListNode B, nextB;\n        \n        ListNode result = head.next;\n        \n        while(A != null && A.next != null){\n            // update nodes\n            B = A.next;\n            nextB = B.next;\n            \n            // swap A and B\n            A.next = nextB;\n            B.next = A;\n            preA.next = B;\n            \n            // update nodes\n            preA = A;\n            A = nextB;\n        }\n        \n        return result;\n    }\n}\n```\n\n- Recursion\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // recursion\n        return helper(head);\n    }\n    \n    // take node.next as the returned result\n    // swap node and node.next\n    // point node.next to the next recursion returned result\n    // return result\n    private ListNode helper(ListNode node){\n        if(node == null || node.next == null){\n            return node;\n        }\n        \n        ListNode result = node.next;\n        node.next = helper(result.next);\n        result.next = node;\n        \n        return result;\n    }\n}\n```\n\n## Complexity\n- Time: O(n) to scan the list once.\n- Space: O(1) no extra space except the stacks for recursion.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922209822","body":"## Problem\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/\n\n## Notes\n- Can solve this problem using recursion or converting to ArrayList then recursion.\n  - Recursion\n    - Given the (start, end) range of the input list (end is the size of the list, not the last node of the list).\n    - Find the mid point of the list (use fast and slow pointers).\n    - Create a TreeNode using the mid point value, make it as the root of the BST.\n    - Recursively call the helper method with the range (start, mid), and make the return TreeNode as the left subtree root.\n    - Recursively call the helper method with the range (mid + 1, end), and make the return TreeNode as the left subtree root.\n    - The exit of the recursion is when start == end, return null.\n  - Converting to ArrayList and Recursion\n    - Convert the input list into ArrayList.\n    - Given the (start, end) range of the ArrayList (end is the size of the list, not the last index of the list).\n    - Create a TreeNode using the mid point value (mid = start + (end - start)/2), make it as the root of the BST.\n    - Recursively call the helper method with the range (start, mid), and make the return TreeNode as the left subtree root.\n    - Recursively call the helper method with the range (mid + 1, end), and make the return TreeNode as the left subtree root.\n    - The exit of the recursion is when start == end, return null.\n\n## Solution\n- Recursion\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        // recursion\n        if(head == null){\n            return null;\n        }\n                \n        return helper(head, null); // the right boundary is null initially, not the last node of the list\n    }\n    \n    private TreeNode helper(ListNode head, ListNode tail){\n        if(head == tail){\n            return null;\n        }\n        \n        // find the middle point of the list\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        \n        // slow is at the middle point, split left and right, and proceed with recursion\n        TreeNode result = new TreeNode(slow.val);\n        result.left = helper(head, slow);\n        result.right = helper(slow.next, tail); // the right boundary is tail, not fast.\n        \n        return result;\n    }\n}\n```\n\n- Converting to ArrayList and Recursion\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        // convert list to Arraylist and recursion\n        if(head == null){\n            return null;\n        }\n        \n        List<Integer> arrayList = convertToArrayList(head);\n        \n        return helper(arrayList, 0 , arrayList.size()); // the right boundary is arrayList.size() initially, not arrayList.size() - 1\n    }\n    \n    private TreeNode helper(List<Integer> arrayList, int start, int end){\n        if(start == end){\n            return null;\n        }        \n        int mid = start + (end - start)/2;\n        TreeNode result = new TreeNode(arrayList.get(mid));\n        result.left = helper(arrayList, start, mid);\n        result.right = helper(arrayList, mid + 1, end);\n        return result;\n    }\n    \n    private List<Integer> convertToArrayList(ListNode head){\n        List<Integer> arrayList = new ArrayList<>();\n        while(head != null){\n            arrayList.add(head.val);\n            head = head.next;\n        }\n        return arrayList;\n    }\n}\n```\n\n## Complexity\n- Recursion\n  - Time: O(n) to find the mid points for each recursion (n/2 for left, n/2 for right). There are logn recursion calls. Total O(nlogn) (n is the size of the input list).\n  - Space: O(1) for each recursion, there are logn recursion calls. Total O(logn).\n- Conversion and Recursion\n  - Time: O(n) to convert the list to ArrayList. O(1) to get the mid point value of the ArrayList as the subtree root. There are n nodes. So O(n).\n  - Space: O(n) for the extra ArrayList.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922355621","body":"## Problem\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/\n\n## Notes\n- Can solve this problem by using set or two pointers\n  - Use set\n    - Scan one list and record the nodes in a set\n    - Scan the other list and compare the nodes to the set\n  - Use two pointers\n    - Two p1, p2 traverse two lists respectively\n    - When p1 reaches the end of listA, point to the head of listB, and continue\n    - When p2 reaches the end of listB, point to the head of listA, and continue\n    - When p1 == p2, stop the traversal, and return p1 as the result\n    - When there is an intersection, p1 != null\n      - listA is A+C; listB is B+C (start of C is the intersection)\n      - p1 goes through A+C+B+C\n      - p2 goes through B+C+A+C\n      - p1 p2 stop at the second time they reach the start of C \n    - When there is no intersection, p1 == null (at this point, p1 and p2 stop at the end of both lists)\n      - listA is A+C; listB is B+D (there is no intersection)\n      - p1 goes through A+C+B+D\n      - p2 goes through B+D+A+C\n      - p1 reaches the end of D while p2 reaches the end of C, they both are null at this point, p1 == p2, so the traversal stops\n\n## Solution\n- Use set\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // scan one list and record nodes in a set\n        // scan the other list and compare to the set\n        Set<ListNode> set = new HashSet<>();\n        while(headA != null){\n            set.add(headA);\n            headA = headA.next;\n        }\n        while(headB != null){\n            if(set.contains(headB)){\n                return headB;\n            }\n            headB = headB.next;\n        }\n        \n        return null;\n    }\n}\n```\n\n- Use two pointers\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // two pointers to traverse two list\n        // when p1 reaches the end of listA, point to head of listB\n        // when p2 reachese the end of listB, point to head of listA\n        // the traversal stops when p1 == p2, p1 is the result\n        // when there is an intersection, p1 != null\n        // when there is no intersection, p1 == null (p1 p2 stop at the end of both lists)\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1 != p2){\n            p1 = p1 == null? headB: p1.next;\n            p2 = p2 == null? headA: p2.next;\n        }\n        return p1;\n    }\n}\n```\n\n## Complexity\n- Use set\n  - Time: O(m + n) (m is the size of listA, n is the size of listB).\n  - Space: O(m) to store the nodes of listA.\n- Use two pointers\n  - Time: O(m + n).\n  - Space: O(1).","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GemZq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916569778","body":"### 代码\n```python \nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        A_list = [str(i) for i in num ]\n        A_number = int(''.join(A_list))\n        result_number = A_number + k\n        result = [int(i) for i in str(result_number)]\n        return result\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlemoon-zh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916571164","body":"## day 1\n\n简单粗暴的解法：\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = 0\n        for number in num:\n            n = n * 10 + number\n        return [int(ch) for ch in str(k + n)]\n```\n复杂度：`O(n)`\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428451","body":"## day 2\n\n两次扫的做法，每次维护一个last表示最近一次看见的目标字符位置，时间复杂度为`O(n)`：\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [float('inf')] * len(s)\n        last = None\n        \n        for i in range(len(s)):\n            if s[i] == c:\n                last = i\n                res[i] = 0\n            \n            elif last != None:\n                res[i] = abs(last-i)\n        \n        last = None\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                last = i\n            elif last != None:\n                res[i] = min(res[i], abs(last-i))\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917700878","body":"## day3\n\n由于题目中说了incr操作比较多，push和pop操作比较少；因而应该尽量让incr操作简单，其余操作复杂一些也没关系；\n\n我的策略是，使用一个inc的map来记录每次的对前k个元素的更改，在每次pop的时候遍历这些增加值，得到真正的返回值；此外在pop时，有时会需要更新inc的map，因为比如本来是对前5个元素增加1，在pop完了之后，就只剩4个元素了，这就要修改inc的map。\n\n代码如下：\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.max = maxSize\n        self.stack = []\n        self.inc = collections.Counter()\n\n    def push(self, x: int) -> None:\n        if self.max == len(self.stack):\n            return\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        \n        pos = len(self.stack)\n        res = self.stack.pop(-1)\n        \n        for k, v in list(self.inc.items()):\n            if pos <= k:\n                res += v\n            \n            if k == pos:\n                self.inc[k] = 0\n                if (k-1) > 0:\n                    self.inc[k-1] += v\n                \n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        k = min(k, len(self.stack))\n        self.inc[k] += val\n        \n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917702341","body":"## day 4\n\n[Leetcode 394 Decode String](https://leetcode.com/problems/decode-string/)\n\n这题还是有些难度的，用到了stack，其实也是一种递归的思维，因为递归就是栈。然后再根据题目要求，写出满足的逻辑即可。\n\n由于题目说明了，所有的格式都是规范的，不会出现`3a`这种情况，所以我们只要按照规则做就行了。\n\n- 遇到数字时，将其压入数字栈中；\n- 遇到`[`和其他字母时，压入符号栈中；\n- 遇到`]`时，表示我们可以进行一个字符串拼接了；\n    - 拼接的字符串来自符号栈中，不断出栈，直到遇到第一个`[`，表示当前的字符串完毕；\n    - 接着从数字栈中弹出一个元素，表示将刚才的字符串重复若干遍；\n    - 再将重复过的字符串压入符号栈中，继续上述过程；\n\n最后符号栈中的各个字符串都是并列的关系，比如`4[a]3[cd]`，最终的结果是 `['aaaa', 'cdcdcd']`，使用join函数将它们拼接到一起就可以了。\n\n代码如下：\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        i = 0\n        num = []\n        ch = []\n\n        while i < len(s):\n            if s[i].isdigit():\n                n = 0\n                while s[i].isdigit():\n                    n = n * 10 + int(s[i])\n                    i += 1\n                num.append(n)\n            elif s[i] == ']':\n                ss = []\n                while ch[-1] != '[':\n                    ss.insert(0, ch.pop(-1))\n                ch.pop(-1)\n                ch.append(''.join(ss) * num.pop(-1))\n                i += 1\n            else:\n                ch.append(s[i])\n                i += 1\n                \n        # print(ch)\n        return ''.join(ch)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918586109","body":"## day 5\n\n[232 Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)\n\nStack is FILO and queue is FIFO. In order to implement FIFO using FILO, we need two stacks. \n\nWhen we add a new element, we push it into stack1. When we retrieve the element, it's at the bottom of stack1. Then we pop all the elements from stack1 to stack2, then the desired element is on the top of stack2.\n\nNext time we want to push an element, just push it to stack 1. If we want to retrieve an elements, it has two cases, 1 if stack2 is not empty, pop from it, 2 if stack 2 is empty, we pop all the elements from stack1 to stack2, then we pop from stack2.\n\n```java\nclass MyQueue {\n    LinkedList<Integer> s1;\n    LinkedList<Integer> s2;\n    \n    public MyQueue() {\n        s1 = new LinkedList<>();\n        s2 = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty())\n                s2.push(s1.pop());\n        }\n        \n        return s2.pop();\n    }\n    \n    public int peek() {\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty())\n                s2.push(s1.pop());\n        }\n        \n        return s2.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return s1.isEmpty() && s2.isEmpty();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919516314","body":"## day 6\n\n这题简单的地方在于，元素不重复，并且在`[0, n)`的范围内，最开始想到的是先创建一个拷贝，然后进行排序，然后同时扫描两个数组，如果发现元素刚好重合，就算一个划分；\n\n后来发现，可以不用排序，在`i`位置时，如果之前遇到的所有元素都小于`i`，表示可以形成一个划分，代码中的`rightMost`表示到目前位置遇到的最大元素；\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int rightMost = 0;\n        int res = 0;\n        \n        for(int i = 0; i < arr.length; i++) {\n            rightMost = Math.max(rightMost, arr[i]);\n            if (rightMost <= i) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n时间复杂度：`O(n)`\n空间复杂度：`O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920469992","body":"## day 7\n\n[61 Rotate List](https://leetcode.com/problems/rotate-list/)\n\n思路并不难，改变指向时需要多多注意，以及小心边界情况。\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null)\n            return head;\n        int n = 0;\n        ListNode cur = head;\n        // O(n)\n        ListNode last = null;\n        while (cur != null) {\n            n++;\n            if (cur.next == null)\n                last = cur;\n            cur = cur.next;\n        }\n        \n        k = k % n;\n        if (k == 0)\n            return head;\n        k = n - k;\n        cur = head;\n        while (--k > 0) {\n            cur = cur.next;\n        }\n        \n        ListNode ans = cur.next;\n        cur.next = null;\n        last.next = head;\n        \n        return ans;\n            \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921307723","body":"## day 8\n\n递归方法，两两改变指针指向；\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n        ListNode a = head, b = head.next;\n        ListNode t = b.next;\n        b.next = a;\n        a.next = swapPairs(t);\n        return b;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922171240","body":"## day 9\n\n[109 Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n找到链表中间，递归建树。\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null)\n            return null;\n        if (head.next == null)        \n            return new TreeNode(head.val);\n        \n        ListNode slow = head, fast = head;\n        ListNode pre = null;\n        \n        while (fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        pre.next = null;\n        TreeNode root = new TreeNode(slow.val);\n        \n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922368487","body":"## day 10\n\n[160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)\n\n简单的思路是用Set；\n\n`O(1)` space的思路是，先找两个链表的长度差`diff`，然后让长的那个先走`diff`步，接着两个同时走，如果途中有相等，说明遇到重合节点；\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA, b = headB;\n        \n        while (a != null && b != null) {\n            a = a.next;\n            b = b.next;\n        }\n        \n        int diff = 0;\n        \n        if (b != null) {\n            a = b;\n            ListNode t = headA;\n            headA = headB;\n            headB = t;\n        }\n        \n        while (a != null) {\n            a = a.next;\n            diff++;\n        }\n\n        a = headA;\n        b = headB;\n        \n        while (diff-- > 0) {\n            a = a.next;\n        }\n        while (a != null && b != null) {\n            if (a == b)\n                return a;\n            a = a.next;\n            b = b.next;\n        }\n        \n        return null;       \n    }\n}\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xbhog":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916571254","body":"# 989.数组形式的整数加法\n\n## 思路：\n\n首先的思路是：\n\n1. 遍历数组整合成整数\n2. 与k值相加\n\n刚开始前三个测试样例平安无事，从测4后开始疯狂溢出。\n\n把int 改成Long，短暂解决，测96后，又开始了一轮溢出.....\n\n解决方式：\n\n数组的最后一位与k的最后一位相加，注意进位量。\n\n思考缺点：\n\n1. 对数据不敏感\n2. 思考不完整\n3. 读题不明确就上手做\n\n## 代码段：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for(int i = n-1; i >= 0; i--){\n            //数组最后一个与k的最后一位相加\n            int sum = num[i]+k%10;\n            k /= 10;\n            if(sum >= 10){\n                sum -=10;\n                //进位设置\n                k++;\n            }\n            res.add(sum);\n        }\n        //防止k的位数大于num\n        for(;k >0; k/=10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n## 复杂度分析：\n\n无嵌套,除返回值以外，操作空间为O(1)\n\n- 时间复杂度 O(N)\n- 空间复杂度 O(1)\n\n如果解释有所错误，欢迎朋友指正，感谢！\n\n## ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917322785","body":"# 821. 字符的最短距离\n\n## 思路：\n\n两层循环，i,j表示两个指针，设置一个临时变量，在遍历数组时，找到i-j的最小值更新。\n\n## 代码段：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        List<Integer> list = new ArrayList<>();\n        char[] ch = s.toCharArray();\n        int n = ch.length;\n    \n        for(int i = 0; i < n; i++){\n            int t = Integer.MAX_VALUE;\n            if(ch[i] == c){\n                list.add(0);\n                continue;\n            }\n            for(int j = 0; j < n; j++){\n                if(ch[j] == c){\n                    int temp = Math.abs(i-j);\n                    if(temp < t) t = temp;;\n                }\n            }\n            list.add(t);\n        }\n        int[] res = new int[list.size()];\n        int cnt = 0;\n        for(int i : list){\n            res[cnt++] = i;\n        }\n        return res;\n    }\n}\n```\n\n## 复杂度分析：\n\n时间复杂度：O(n^2)\n\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917535093","body":"# [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n## 思路：\n\n开始使用的Deque来实现，后来发现在increment函数中实现有些麻烦。\n\n又转成数组实现：\n\n**简单的使用模板**\n\n```\n// tt表示栈顶\nint stk[N], tt = 0;\n\n// 向栈顶插入一个数\nstk[ ++ tt] = x;\n\n// 从栈顶弹出一个数\ntt -- ;\n\n// 栈顶的值\nstk[tt];\n\n// 判断栈是否为空\nif (tt > 0)\n{\n\n}\n```\n\n## Java代码段：\n\n```java\nclass CustomStack {\n    static int[] stk;\n    static int tt;\n    public CustomStack(int maxSize) {\n        tt = -1;\n        stk = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(tt < stk.length-1){\n            stk[++tt] = x;\n        }\n    }\n    \n    public int pop() {\n        if(tt == -1) return -1;\n        tt--;\n        return stk[tt+1];\n    }\n    \n    public void increment(int k, int val) {\n        if(stk.length < k){\n            for(int i = 0; i < stk.length; i++){\n                stk[i] += val;\n            }\n        }else{\n            for(int i = 0; i < k; i++){\n                stk[i] += val;\n            }\n        }\n        \n    }\n}\n```\n\n## 复杂度分析：\n\n时间复杂度：push、pop 为O(1),inc为O(N);\n\n空间复杂度：O(maxSize);","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918758167","body":"# 用栈实现队列\n\n\n\n## 实现思路：\n\n使用两个栈，一个输入栈，一个输出栈；\n\npush的时候保存到输入栈中。\n\npop和peek的时候在输出栈为空的情况下，将所有的输入栈中的数据存到输出栈中\n\nempty需要输出栈与输入栈都为空，才成立。\n\n## Java代码段：\n\n```java\nclass MyQueue {\n    static Stack<Integer> stkin;  //输入栈\n    static Stack<Integer> stkout; //输出栈\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stkin = new Stack<>();\n        stkout = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        //push的时候保存到输入栈中\n        stkin.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        // 当输出栈为空时\n        if(stkout.empty()){\n            //将所有的输入栈中的数据存到输出栈中\n            while(!stkin.empty()) stkout.push(stkin.pop());\n        }\n        // 通过输出栈进行输出\n        return stkout.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(stkout.empty()){\n            while(!stkin.empty()) stkout.push(stkin.pop());\n        }\n        return stkout.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        // 如果输出栈与输入栈都为空\n        // 当 stkin 栈为空时，说明没有元素可以倒腾到 stkout 栈了\n        // 并且 stkout 栈也为空时，说明没有以前从 stkin 中倒腾到的元素了 \n        return stkin.empty() && stkout.empty();\n    }\n}\n```\n\n## 复杂度分析：\n\npush:\n\n- 时间复杂度：O(1)\n\n- 空间复杂度：O(N)\n\npeek与pop:\n\n- 时间复杂度：O(N)\n\n- 空间复杂度：O(N)\n\nempty:\n\n- 时间复杂度：O(1)\n\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919637031","body":"# 768.最多能完成排序的块\n\n## 思路：\n\n按题解思路整理：\n\n- 性质1：后一个分块的所有值都比前一个分块的最大值大或者相等，所以当遇到数字比前面的数值都大的话，就是一个新的分块\n\n- 性质2：当数字比分块的最大值小的话，那么表示同属一个块，合并当前数字为一个块并且保证栈单调递增\n\n## Java代码段:\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stk = new LinkedList<>();\n        for(int num : arr){\n            if(!stk.isEmpty() && num < stk.peek()){\n                int head = stk.pop();\n                while(!stk.isEmpty() && num < stk.peek()) stk.pop();\n                stk.push(head);\n            }else{\n                stk.push(num);\n            }\n        }\n        return stk.size();\n    }\n}\n```\n\n## 复杂度分析：\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920542214","body":"# 61、旋转链表\n\n## 思路：\n\n- 方法一：可以采用闭合为环，在找到对应位置节点，截取就行。\n- 方法二：找到 头 尾  中(k)，进行拼接\n\n## Java代码段：\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        if(k == 0) return head;\n        //获取链表长度\n        ListNode cur = head;\n        int len = 0;\n        //找长度\n        while(cur != null){\n            cur = cur.next;\n            len++;\n        }\n        k=Math.abs(len-k);\n        ListNode p = head;\n        //找截断点  len-k-1精髓\n        for(int i = 0; i < len-k-1; i++){\n            p = p.next;\n        }\n        ListNode temp = head;\n        //找尾节点\n        while(temp.next != null) temp = temp.next;\n\n        //拼接\n        temp.next = head;\n        head = p.next;\n        p.next = null;\n        return head;\n        \n    }\n}\n```\n\n## 时间复杂度：\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921464703","body":"# 24.两两交换链表中的节点\n\n## 思路：\n\n![image-20210917124543083](https://gitee.com/xbhog/BlogImg/raw/master/null/change1.png)\n\n## Java代码段：\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n\n        ListNode dum = new ListNode(0);\n        dum.next = head;\n        ListNode temp = dum;\n        while(temp.next != null && temp.next.next != null){\n            //声明两个指针start,end\n            ListNode start = temp.next;\n            ListNode end = temp.next.next;\n            temp.next = end;\n            start.next = end.next;\n            end.next = start;\n            //移动指针\n            temp = start;\n        }\n        return dum.next;\n    }\n}\n```\n\n## 复杂度分析：\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922238051","body":"# [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n## 解题思路：\n\n1. 转为数组，构建avl\n2. 采用快慢指针找中心点，构建avl\n\n## Java代码段：\n\n### 解法一：（题解）\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return build(head,null);\n\n    }\n    //构建二叉平衡树，节点左边为左树，右节点为右树\n    public static TreeNode build(ListNode l ,ListNode r){\n        if(l == r) return null;\n        ListNode mid = getMidNumber(l,r);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = build(l,mid);\n        root.right = build(mid.next,r);\n        return root;\n    }\n    //使用快慢指针找出链表的中心节点\n    public static ListNode getMidNumber(ListNode left,ListNode right){\n        ListNode fast = left;\n        ListNode slow = left;\n        while(fast != right && fast.next != right){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```\n\n### 转为数组解法(二)：\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        ListNode cur = head;\n        List<Integer> list = new ArrayList<>();\n        while(cur != null){\n            list.add(cur.val);\n            cur = cur.next;\n        }\n        int cnt = 0;\n        int[] temp =new int[list.size()];\n        for(int i : list){\n            System.out.println(i);\n            temp[cnt++] = i;\n        }\n        return dfs(temp,0,list.size()-1);\n\n    }\n    public static TreeNode dfs(int[] temp,int left,int right){\n        if(left > right) return null;\n        int mid = left+right >>1;\n        TreeNode root = new TreeNode(temp[mid]);\n        root.left = dfs(temp,left,mid-1);\n        root.right = dfs(temp,mid+1,right);\n        return root;\n    }\n}\n```\n\n## 复杂度分析：\n\n解法一：\n\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922401964","body":"# [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n## 解题思路：\n\n采用set来实现，先遍历一遍A,在遍历B，如果遍历B时，节点存在 则返回；该解法为简单题；\n\n## Java代码段：\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> set = new HashSet<>();\n        while(headA != null){\n            set.add(headA);\n            headA = headA.next;\n        } \n        ListNode cur = headB;\n        while(cur != null){\n            if(set.contains(cur)){\n                return cur;\n            }\n            cur = cur.next;\n        } \n        return null;\n    }\n}\n```\n\n## 复杂度分析：\n\n**其中 m 和 n 是分别是链表 headA 和 headB 的长度**\n\n时间复杂度：O(m+n) 都要遍历A和B\n\n空间复杂度：o(m)  要保存A中的节点信息","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"st2yang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916573727","body":"## 思路\r\n- k 添加到末尾\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        res = []\r\n\r\n        i = n - 1\r\n        while i >= 0 or k > 0:\r\n            if i >= 0:\r\n                k += num[i]\r\n            res.append(k % 10)\r\n            i -= 1\r\n            k //= 10\r\n        \r\n        return res[::-1]\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917053954","body":"## 思路\r\n- 数组正反向遍历\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        res = [inf] * n\r\n\r\n        l = -inf\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                l = i\r\n            res[i] = i - l\r\n        \r\n        r = inf\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                r = i\r\n            res[i] = min(r - i, res[i])\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917544977","body":"## 思路\r\n- 数组\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.data = []\r\n        self.cnt = 0\r\n        self.max_size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.max_size:\r\n            self.data.append(x)\r\n            self.cnt += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt > 0:\r\n            self.cnt -= 1\r\n            return self.data.pop()\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(k, self.cnt)):\r\n            self.data[i] += val\r\n```\r\n\r\n## 复杂度\r\n- 时间: push O(1), pop O(1), increment O(k)\r\n- 空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917807393","body":"## 思路\r\n- stack\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n\r\n        for c in s:\r\n            if c == ']':\r\n                stri = \"\"\r\n                cnt = \"\"\r\n                while stack and stack[-1] != '[':\r\n                    stri = stack.pop() + stri\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    cnt = stack.pop() + cnt\r\n                stack.append(stri * int(cnt))\r\n            else:\r\n                stack.append(c)\r\n\r\n        return \"\".join(stack)\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918606764","body":"## 思路\r\n- 两个stack\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        self.peek()\r\n        \r\n        return self.pop_stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop())\r\n        \r\n        return self.pop_stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.push_stack) == 0 and len(self.pop_stack) == 0\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(1)\r\n- 空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920149323","body":"## 思路\r\n- 单调栈\r\n\r\n## 代码\r\n- python\r\n```python\r\n# 维护一个递增栈，其中元素是每个块的最大值\r\n# 遇到新元素时，保证栈中没有比它大的\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n\r\n        for a in arr:\r\n            if stack and stack[-1] > a:\r\n                top = stack[-1]\r\n                while stack and stack[-1] > a:\r\n                    stack.pop()\r\n                stack.append(top)\r\n            else:\r\n                stack.append(a)\r\n        \r\n        return len(stack)\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920202587","body":"## 思路\r\n- 快慢指针找倒数第k个节点\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        \r\n        i = 0\r\n        count = 1\r\n        fast = slow = head\r\n        while i < k:\r\n            if fast.next:\r\n                fast = fast.next\r\n                count += 1\r\n            else:\r\n                fast = head\r\n                k = k % count\r\n                i = -1\r\n            i += 1\r\n                \r\n        while fast.next:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        \r\n        if slow.next:\r\n            new_head = slow.next\r\n            slow.next = None\r\n            fast.next = head\r\n            head = new_head\r\n        \r\n        return head\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921418876","body":"## 思路\r\n- 链表\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy = prev = ListNode()\r\n        prev.next = head\r\n        \r\n        while prev.next and prev.next.next:\r\n            a = prev.next\r\n            b = prev.next.next\r\n            a.next = b.next\r\n            b.next = a\r\n            prev.next = b\r\n            prev = a\r\n        \r\n        return dummy.next\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922172108","body":"## 思路\r\n- 链表\r\n- 分治\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return head\r\n        \r\n        # find the middle list node\r\n        pre, slow, fast = None, head, head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        \r\n        # break the link\r\n        if pre:\r\n            pre.next = None\r\n        \r\n        # only one node\r\n        node = TreeNode(val=slow.val)\r\n        if slow == fast:\r\n            return node\r\n        \r\n        # recursion\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(nlogn)\r\n- 空间: O(logn), 递归栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922383740","body":"## 思路\r\n- 双指针\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        pA = headA\r\n        pB = headB\r\n\r\n        while pA != pB:\r\n            if not pA:\r\n                pA = headB\r\n            else:\r\n                pA = pA.next\r\n            if not pB:\r\n                pB = headA\r\n            else:\r\n                pB = pB.next\r\n        \r\n        return pA\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(m + n)\r\n- 空间: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiezhengyun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916575375","body":"# 思路\n- 把k转数组，变成两个数组相加\n- 生成res数组。长度要比num 和 kArr 最大长度 + 1\n- 个位数相加，添加到res 数组\n- 判断进位carry，返回结果\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  var l1 = num.length - 1;\n  var kArr = String(k).split('');\n  var l2 = kArr.length - 1;\n  var resLen = (l1 > l2 ? l1 : l2) + 1;\n  var res = new Array(resLen + 1).fill(0);\n  var carry = 0;\n\n  while (l1 > -1 || l2 > -1) {\n    var val1 = l1 > -1 ? num[l1] : 0;\n    var val2 = l2 > -1 ? kArr[l2] : 0;\n\n    var sum = val1 + Number(val2) + carry;\n    var carry = Math.floor(sum / 10);\n    res[resLen] = Math.floor(sum % 10);\n\n    resLen--;\n    if (l1 > -1) l1--;\n    if (l2 > -1) l2--;\n  }\n\n  if (carry) {\n    res[resLen] = carry;\n  } else {\n    res.shift();\n  }\n  return res;\n};\n```\n# 复杂度分析\nN是数组nums的长度，K是数字k的长度\n- 时间复杂度  O(max(N,K) + shift) shift 是数组删除第一个元素\n- 空间复杂度 O(max(N,K)+1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917373358","body":"# 821. 字符的最短距离\n\n# 思路\n- 计算字符串 s 中每个字符 向左 或 向右 距离 c 的距离;\n- 通过两次便利分别找出 向左，向右的距离，取最小值\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n  var res = new Array(s.length - 1);\n  //prev 上一个 c 出现的位置\n  // i 元素 向左查找， prev初始设为 -10001，因为s.length 最大值为 10000(因为第一个元素如果不是c，那第一个元素距离左边的c距离是无的，用一个极大值来表示)\n  // 此时res 存 向左查找遇到 c 的距离\n  var prev = -10001;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) prev = i;\n    res[i] = i - prev;\n  }\n  // 接着 算出 数组每一位 向右，遇到c 的距离\n  // prev = 10001\n  // 此时 res[i]，取向左和向右的最小值\n  prev = 10001;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) prev = i;\n    res[i] = Math.min(res[i], prev - i);\n  }\n  return res;\n};\n```\n\n# 复杂度\n- 时间复杂度 O(N) ,遍历2次数组\n- 空间复杂度，除返回的数组外，O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917541225","body":"```js\nclass CustomStack {\n  constructor(maxSize) {\n    this.maxSize = maxSize;\n    this.arr = [];\n  }\n\n  push(x) {\n    if (this.arr.length >= this.maxSize) return;\n    this.arr.push(x);\n  }\n\n  pop() {\n    if (this.arr.length > 0) {\n      return this.arr.pop();\n    }\n    return -1;\n  }\n\n  increment(k, val) {\n    var min = Math.min(k, this.arr.length);\n    for (var i = 0; i < min; i++) {\n      this.arr[i] = this.arr[i] + val;\n    }\n  }\n}\n```\n## 复杂度\n- 时间复杂度: increment  O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918132736","body":"# 栈\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  var strStack = []\n  var numStack = []\n  var num = ''\n  var res = ''\n  for(let c of s){\n    if (!isNaN(c)) { //是数字\n      num += c\n      //1位数以上的数字，不能立即入栈\n    } else if (c === '[') { //[ 字符串入栈 , 数字也入栈\n      strStack.push(res)\n      res = ''\n      numStack.push(num)\n      num = ''\n    } else if (c === ']') { // 双出栈\n      var times = numStack.pop()\n      var str = strStack.pop()\n      res = str + res.repeat(times)\n    } else {\n      res += c\n    }\n  }\n  return res\n};\n```\n## 复杂度\nN是字符串s解码后新字符串的长度，S是字符串s的长度\n- 时间复杂度 O(N)\n- 空间复杂度O(S)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918714896","body":"# 思路\n- 队列是先进先出，栈是后进先出，所以得有2个栈来实现队列\n- 一个输入栈，一个输出栈。\n- pop 和 peek 操作的时候，得把输入栈的元素全部移入输出栈，然后从输出栈输出（保证输出栈的栈顶是最后进的元素）\n\n```js\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function () {\n  this.stackIn = []\n  this.stackOut = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.stackIn.push(x)\n};\n\nMyQueue.prototype.setStackOut = function(){\n  if (this.stackOut.length === 0) {\n    while (this.stackIn.length) {\n      var item = this.stackIn.pop()\n      this.stackOut.push(item)\n    }\n  }\n}\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  this.setStackOut()\n  return this.stackOut.pop()\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  this.setStackOut()\n  var item = this.stackOut.pop()\n  this.stackOut.push(item)\n  return item\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return this.stackOut.length === 0 && this.stackIn.length === 0\n};\n\n```\n## 复杂度分析\n### push\n- 时间复杂度 O(1)\n- 空间复杂度 O(n)\n### pop\n- 时间 最坏情况下 O(n)\n- 空间 O(1)\n### peek\n- 时间 最坏情况下 O(n)\n- 空间 O(1)\n### empty \n- 时间 O(1)\n- 空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919622060","body":"# 768. 最多能完成排序的块 II\n## 思路\n抄的小漾的滑动窗口\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n  var sorted = [...arr]\n  sorted.sort((a, b) => a - b)\n\n  var count = 0,\n    sum1 = 0,\n    sum2 = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum1 += arr[i]\n    sum2 += sorted[i]\n    if (sum1 === sum2) count++\n  }\n  return count\n};\n```\n## 复杂度\nN为数组长度\n- 时间复杂度 排序O(NlogN) 循环O(n)，所以是O(NlogN)\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920578721","body":"# 思路 \n因为k可能比链表的长度大，先结成环形链表，再确认走的步数\n- k < len 走 len-k\n- k >= len 走  len - k%len 取余，计算实际的k，避免多走无效的（这里k === len 可以直接返回head）  \n\n其实这两一样\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head || !head.next || !k) return head\n\n  var cur = head\n  var len = 1\n  while (head.next) {\n    len++\n    head = head.next\n  }\n  head.next = cur\n\n  var move = len - k % len;\n\n  while (move) {\n    head = head.next\n    move--\n  }\n\n  var h = head.next\n  head.next = null\n  return h\n};\n```\n## 复杂度\nN是链表的长度\n- 时间复杂度 O(N)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921423338","body":"# 24. 两两交换链表中的节点\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n![](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n\n- 题目很好理解，交换节点\n- 用一个虚拟头\n- 一定要画图来操作链表  \n\n![](https://raw.githubusercontent.com/xiezhengyun/learnWeb/master/Images/%E7%AE%97%E6%B3%95/%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A82%E4%B8%AA%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0.png)  \n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  var dh = new ListNode(-1);\n  dh.next = head;\n  var cur = dh;\n  while (cur.next && cur.next.next) {\n    var next2 = cur.next.next.next;\n    var next = cur.next;\n\n    cur.next = cur.next.next;\n    cur.next.next = next;\n    cur.next.next.next = next2;\n\n    cur = cur.next.next;\n  }\n  return dh.next;\n};\n```\n## 复杂度\nN链表的长度\n-  时间复杂度 O(N)\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922156089","body":"# 思路\n- 一看题解才知道，快慢指针找链表中点，我是直接转数组了...   \n- 找中点，递归生成树\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function (head) {\n  if (!head) return null\n  var arr = []\n  while (head) {\n    arr.push(head.val)\n    head = head.next\n  }\n  \n  var buildTree = function (arr, l, r) {\n    if (l > r) return null\n    var mid = Math.ceil((l + r) / 2)\n    var root = new TreeNode(arr[mid])\n\n    root.left = buildTree(arr, l, mid - 1)\n    root.right = buildTree(arr, mid + 1, r)\n\n    return root\n  }\n  return buildTree(arr, 0, arr.length - 1)\n};\n```\n# 复杂度\nN是链表长度\n- 时间复杂度 O(NlogN) \n- 空间复杂度 O(NlogN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922397553","body":"# 思路\n这题我做过\n- 循环两个链表，一个完了接着另一个，这样，两个指针就是走了相同的路，他们会同时到达相交节点，或者同时等于null\n```js\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n  var p1 = headA,p2 = headB;\n  while(p1 !== p2){\n    p1 = p1 ? p1.next: headB\n    p2 = p2 ? p2.next: headA\n  }\n  return p1 \n};\n```\n## 复杂度\nM，N为2个链表的长度\n- Time：O(M+N)\n- Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916575768","body":"### 思路\n列表转成数值，加上k，然后倒着一位一位加到列表，然后反转列表\n### 代码（Python3）\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        inta = 0\n        for i in A:\n            inta = inta*10 + i\n        inta = inta+K\n        res = []\n        while inta!=0:\n            res.append(inta%10)\n            inta//=10\n        if not res:\n            res.append(0)\n        return res[::-1]\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917412218","body":"### 思路\r\n先把所有目标字符位置标记，然后再走一遍，取近的距离\r\n### 代码（Python3）\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                l.append(i)\r\n        k = 0\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=len(l)-1 and abs(i-l[k])>abs(i-l[k+1]):\r\n                k += 1\r\n            res.append(abs(i-l[k]))\r\n        return res\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917649977","body":"### 思路\r\n保存数据的同时保存增量，可以利用空间换时间，缩小时间复杂度\r\n### 代码（Python3）\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append([x,0])\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            x,val = self.stack.pop()\r\n            if self.stack:\r\n                self.stack[-1][1]+=val\r\n            return x+val\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if not self.stack:\r\n            return\r\n        if len(self.stack)<=k:\r\n            self.stack[-1][1]+=val\r\n        else:\r\n            self.stack[k-1][1]+=val\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917748878","body":"### 思路\r\n用栈存储\r\n倒序遍历字符串，遇到数值的下一个字符，处理字符串。\r\n### 代码（Python3）\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[]\r\n        flag = False\r\n        for c in s[::-1]+\"/\":\r\n            \r\n            if c.isdigit():\r\n                flag = True\r\n            if flag and not c.isdigit():    \r\n                flag = False            \r\n                temp = []\r\n                while True:\r\n                    t = stack.pop()\r\n                    if t!=\"]\":\r\n                        temp.append(t)\r\n                    else:\r\n                        break\r\n                temp = \"\".join(temp).split(\"[\")\r\n                stack.append(int(temp[0])*temp[1])\r\n            stack.append(c)\r\n        stack.pop()\r\n        return \"\".join(stack[::-1])\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918696022","body":"### 思路\r\n两个栈，一个入栈，一个出栈。\r\n如果入队列，就加入到入栈中。\r\n如果出队列，出栈中有数据就直接出，没有的话，把入栈中的数据全部倒到出栈中，再从出栈中出。\r\n### 代码（Python3）\r\n```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.outstack) + len(self.instack)==0\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(1)    虽然有时候需要倒栈，但是平摊复杂度为O1\r\n- 空间复杂度：O(n)    两个栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919658713","body":"### 思路\r\n单调栈\r\n### 代码（Python3）\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []        \r\n        for i in arr:\r\n            big = stack[-1] if stack else 0\r\n            if i<big:\r\n                while stack and i<stack[-1]:\r\n                    stack.pop()\r\n                stack.append(big)\r\n            else:\r\n                stack.append(i)\r\n        return len(stack)\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920472481","body":"### 思路\r\n模拟\r\n### 代码（Python3）\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        length = 0\r\n        virtualhead = ListNode(-1,head)\r\n        cur = virtualhead\r\n        while cur.next:\r\n            length+=1\r\n            cur = cur.next\r\n        cur.next = head\r\n        k = k%length\r\n        cur = head\r\n        for i in range(length-k-1):\r\n            cur = cur.next\r\n        virtualhead.next=cur.next\r\n        cur.next=None\r\n        return virtualhead.next\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921588936","body":"### 思路\r\n模拟\r\n### 代码（Python3）\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        virtualhead = ListNode(-1,head)\r\n        prepre = virtualhead\r\n        pre = head\r\n        cur = head.next\r\n        while pre and cur:\r\n            pre.next = cur.next  # 将前面节点的next设置为当前节点的下一个节点\r\n            cur.next = pre  # 当前节点的next设置为前一个节点\r\n            prepre.next = cur  # 前前节点的next设置为当前节点\r\n            prepre = pre  # prepre向后移动2个单位\r\n            pre = pre.next  # pre向后移动一个单位\r\n            if pre:  # 如果后面有节点，就把cur也向后移动\r\n                cur = pre.next\r\n        return virtualhead.next\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922244937","body":"### 思路\r\n中序遍历构造二叉树\r\n### 代码（Python3）\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        # 求出长度\r\n        l = 0\r\n        cur = head\r\n        while cur:\r\n            l+=1\r\n            cur=cur.next\r\n        # 中序遍历递归构建二叉树\r\n        def dfs(left,right):\r\n            if left>right:\r\n                return None\r\n            mid = (left+right)//2  # 求出中间值\r\n            temp = dfs(left,mid-1)  # 递归构建左子树\r\n            nonlocal head\r\n            root  = TreeNode(head.val)  # 构建根节点\r\n            root.left = temp  # 把左子树连上\r\n            head = head.next  # 链表指针后移\r\n            root.right = dfs(mid+1,right)  # 构建并连上右子树\r\n            return root\r\n        \r\n        return dfs(0,l-1)\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922405632","body":"### 思路\r\na+b与b+a长度相同\r\n### 代码（Python3）\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        \r\n        t1=headA\r\n        t2=headB\r\n        while t1 != t2:\r\n            t1=t1.next if t1 else headB\r\n            t2=t2.next if t2 else headA\r\n        return t1\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Toms-BigData":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916577408","body":"# 思路\n将数组中的数字转化为字符拼接成字符串，将字符串转化为int类型与K相加后再次转化为字符串，通过list()和map()函数将字符串拆分成int数组\n# 代码：Python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_str = \"\".join('%s' %id for id in num)\n        num_data = str(int(num_str) + k)\n        return list(map(int,num_data))\n# 时间复杂度\n时间复杂度为O(n)\n空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917330247","body":"# 821. 字符的最短距离\n## 思路：\n建立一个长度等同于s的值全为float('inf')的数组，一个记录上次出现c位置的变量，循环遍历s。\n当第一次出现c时，将所有字符到该字符的距离存入数组。\n当s中再次出现c时，比较从上一个c出现后，后一位的距离到该位置的距离哪个近（因为在上一个位置出现c之前的字符的距离一定小于后面出现c的距离）更新数组\n## Python3代码：\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        distance_list = [float('inf') for _ in range(len(s))]\n        last_char_position = -1\n        for i in range(len(s)):\n            if s[i] == c:\n                for j in range(last_char_position+1,len(distance_list)):\n                    distance_list[j] = abs(j-i) if abs(j-i) < distance_list[j] else distance_list[j]\n        return distance_list\n## 复杂度分析\n时间复杂度：O(N^2)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917758164","body":"# 1381. 设计一个支持增量操作的栈\n## 思路\n数组模拟入栈出栈，做增量时先判断长度再确定遍历次数\n## Python3代码\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = [0 for _ in range(maxSize)]\n        self.stack_point = -1\n\n\n    def push(self, x: int) -> None:\n        if self.stack_point < self.maxSize-1:\n            self.stack_point += 1\n            self.stack[self.stack_point] = x\n\n    def pop(self) -> int:\n        if self.stack_point == -1:\n            return -1\n        else:\n            data = self.stack[self.stack_point]\n            self.stack_point -= 1\n            return data\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.stack_point+1 <= k:\n            for i in range(self.stack_point+1):\n                self.stack[i] += val\n        else:\n            for i in range(k):\n                self.stack[i] += val\n## 时间复杂度\n时间复杂度:constructor、push、pop的复杂度为O(1), increment的复杂度为k, k是该方法参数k的长度\n空间复杂度:O(n) n,为maxSize","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918190736","body":"# 394. 字符串解码\r\n## 思路：\r\n定义两个栈char_list,numList.\r\nchar_list用来存放最后要输出的字符串的数组\r\nnum_list用来存放每个s中的数字在char_list中的位置\r\n遍历s\r\n遇到小写字母直接存入\r\n遇到数字时继续读取字符查看数字有几位，拼接成1个数字比如[\"1\",\"0\",\"0\"]转化为“100”存入char_list中，将该位置的值存入num_list中\r\n遇到'['不做处理\r\n遇到']'取出num_list中的栈顶元素（上一个数字的位置）,将当前位置的数字取出转化为int(),取出那个位置后的所有char_list中的字符，相乘后存入char_list中\r\n最后以字符串形式输出数组中的所有元素\r\n\r\n## python3代码\r\n\r\n\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        '字符串列表'\r\n        char_list = [0 for _ in range(10000)]\r\n        char_flag = -1\r\n        num_list = [0 for _ in range(len(s))]\r\n        num_flag = -1\r\n        i = 0\r\n        while i < len(s):\r\n            if 'a' <= s[i] <= 'z':\r\n                char_flag += 1\r\n                char_list[char_flag] = s[i]\r\n            elif '0' <= s[i] <= '9':\r\n                num_length = 1\r\n                while '0' <= s[i + 1] <= '9':\r\n                    num_length += 1\r\n                    i += 1\r\n                head = i - num_length + 1\r\n                tail = i + 1\r\n                a = s[head:tail]\r\n                num_char = ''.join(a)\r\n                char_flag += 1\r\n                char_list[char_flag] = num_char\r\n                num_flag += 1\r\n                num_list[num_flag] = char_flag\r\n            elif ']' == s[i]:\r\n                # 取出字符串要乘的倍数\r\n                mutiple_num = int(char_list[num_list[num_flag]])\r\n                # 取出被乘的字符串\r\n                head = num_list[num_flag] + 1\r\n                tail = char_flag + 1\r\n                str = \"\".join(char_list[head:tail])\r\n                # 乘好后的字符串\r\n                mutiple_str = mutiple_num * str\r\n                # 将指针倒退回上一个数字位置\r\n                char_flag = num_list[num_flag] - 1\r\n                for data in mutiple_str:\r\n                    char_flag += 1\r\n                    char_list[char_flag] = data\r\n                num_flag -= 1\r\n            i += 1\r\n        final_str = \"\".join(char_list[0:char_flag + 1])\r\n        return final_str\r\n```\r\n\r\n\r\n## 时间复杂度和空间复杂度\r\n时间: O(n^2)\r\n空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918754710","body":"# 232. 用栈实现队列\n## 思路：\n用两个栈实现，起一个栈视为队列尾，第二个栈视为队列头\n新数据进入直接放置在队列尾栈中\n当执行pop 或peek时，先判断队列头栈中是否有数据，没有则将队列尾栈中的元素依次pop出来append到队列头栈中后，执行pop。有数据则直接执行pop\n当双栈都为空empyt为True\n## Python3代码：\n\"\"\"\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.empty() == False:\n            if len(self.stack2) == 0:\n                while len(self.stack1) > 0:\n                    self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n        else:\n            return -1\n\n\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.empty() == False:\n            if len(self.stack2) == 0:\n                while len(self.stack1) > 0:\n                    self.stack2.append(self.stack1.pop())\n            return self.stack2[-1]\n        else:\n            return -1\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if len(self.stack1) == 0 and len(self.stack2) == 0:\n            return True\n        else:\n            return False\n\"\"\"\n## 复杂度\n时间复杂度：除了倒栈操作其他均为O(1)\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921793640","body":"# 24. 两两交换链表中的节点\n## 思路\n建立一个头指针存储整个链表，两两一组进行置换\n## Python3代码\n```\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head is None:\n            return head\n        i = 0\n        # 定义一个头结点\n        flag_point = ListNode(0,head)\n        # 第一次交换涉及到头结点所以单独操作\n        if head.next != None:\n            first_point = head\n            second_point = head.next\n            first_point.next = second_point.next\n            second_point.next = first_point\n            flag_point.next = second_point\n        # 第二次以后操作相同\n        while head.next != None and head.next.next != None:\n            first_point = head.next\n            second_point = head.next.next\n            first_point.next = second_point.next\n            second_point.next = first_point\n            head.next = second_point\n            head = head.next.next\n        return flag_point.next\n```\n## 复杂度分析\n时间:O(n) n为链表长度\n空间:O(1)只增加了一个头结点\n## 做题心得\n最开始做的时候没有想到加头结点，用head直接操作发现赋值时产生循环解决不掉,错误代码如下所示：\n```\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head is None:\n            return head\n        i = 1\n        # 记录当前指针所在节点\n        flag_point = head\n        while flag_point.next != None:\n            i += 1\n            if i%2 == 0:\n                first_point = flag_point\n                second_point = flag_point.next\n                first_point.next = second_point.next\n                second_point.next = first_point\n                flag_point = second_point\n            flag_point = flag_point.next\n        return head\n```\n引以为戒","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922318108","body":"# 109. 有序链表转换二叉搜索树\n## 思路\n投机取巧法：今天实在没时间了，先把108做了就用了108的做法，将链表转化为数组（讲道理空间换时间也没毛病嘛，况且只需要执行一次遍历就可以得到整个数组，不亏好吧）\n然后就是2分查找加递归。\n## Python3代码\n```\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\n        if len(nums) == 1:\n            return TreeNode(val=nums[0])\n        data_num = int((len(nums) - 1) / 2)\n        data_node = TreeNode(val=nums[data_num])\n        left_list = nums[0:data_num]\n        if len(left_list) != 0:\n            data_node.left = self.sortedArrayToBST(left_list)\n        right_list = nums[data_num + 1:len(nums)]\n        if len(right_list) != 0:\n            data_node.right = self.sortedArrayToBST(right_list)\n        return data_node\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if head == None:\n            return None\n        if head.next == None:\n            return TreeNode(head.val)\n        a = []\n        a.append(head.val)\n        while head.next != None:\n            head = head.next\n            a.append(head.val)\n        return self.sortedArrayToBST(a)\n```\n## 复杂度\n时间:O(n)取决于列表长度\n空间:O(n)取决于列表长度\n## 待更新\n等我想想链表有什么好方法之后再改这个代码，更新放在这里","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ymkymk":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916579966","body":"# **思路**\n\n从低位开始相加，大于10就进位\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n    public List<Integer> addToArrayForm(int[] num, int k){\n        List<Integer> res = new ArrayList<Integer>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10){\n                //进一位\n                k++;\n                //减去10才是需要的数\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n\n        /**\n         * 如果k位数比数组多\n         */\n        for(; k > 0; k /= 10){\n            res.add(k % 10);\n        }\n\n        //链表反转\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(max(n, logk))，如果n>k，那么复杂度就是O(n)，如果k比n大，那么复杂度就是O(logk)\n\n空间复杂度：O(1)，每次使用的空间都为常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917333047","body":"# **思路**\n\n左右开弓，计算数组左右两边哪个值小就取哪个，先从左边开始计算得到一个数组，然后再从右边遍历，取最小值\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n    public int[] shortestToChar(String s, char c){\n        int len = s.length();\n        int[] ans = new int[len];\n        //因为s.length <= 10 *10 *10 *10\n        int prev = - 10 *10 *10 *10;\n\n        for (int i = 0; i < len; ++i) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            ans[i] = i - prev;\n        }\n\n        prev = 10 *10 *10 *10;\n        for (int i = len-1; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(n)，需要左右遍历，一共两次\n\n空间复杂度：O(n)，new了一个ans数组出来，这个数据占用的大小为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917534771","body":"# **思路**\n\nincrement并不直接将val加到栈中，而是先记录k和val，等到pop时再加入\n\n# **代码**\n\n``\n\n```\npublic class CustomStack {\n\n\n    private int size;\n    private int[] increment;\n    private int[] stack;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        increment = new int[maxSize+1];\n        size = 0;\n    }\n\n    public void push(int x) {\n       if (size == stack.length){\n           return;\n       }\n\n       stack[size++] = x;\n    }\n\n    public int pop() {\n        if (size == 0) {\n            return -1;\n        }\n\n        int ret = stack[size - 1];\n        if (increment[size] != 0){\n            ret += increment[size];\n            increment[size - 1] += increment[size];\n            increment[size] = 0;\n        }\n        size--;\n        return ret;\n    }\n\n    public void increment(int k, int val) {\n        increment[Math.min(k, size)] += val;\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(1)\n空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918139870","body":"# **思路**\n\n两个列表，一个记录数字（即倍数），一个记录字母\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n        public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) {\n                    tmp.append(res);\n                }\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') {\n                //如果是数字\n                multi = multi * 10 + Integer.parseInt(c + \"\");\n            }\n            else {\n                //如果是字母\n                res.append(c);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(N)，一次遍历 s；\n空间复杂度：O(N)，辅助栈在极端情况下需要线性空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919177241","body":"# **思路**\n\npush正常push，出栈的时候才处理\n\n# **代码**\n\n``\n\n```\nclass MyQueue {\n\n    private Stack stack = new Stack();\n    /** Initialize your data structure here. */\n    public MyQueue() {\n\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        stack.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (stack.isEmpty()){\n            return -1;\n        }\n\n        int removeElement = (int) stack.remove(0);\n        return removeElement;\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        return (int) stack.elementAt(0);\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack.isEmpty();\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(1)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920018498","body":"# **思路**\n\n首先还是要找到从左边开始最小的块。\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n     public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        int nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i];\n            int y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) {\n                nonzero--;\n            }\n            if (count.get(x) == 1) {\n                nonzero++;\n            }\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) {\n                nonzero++;\n            }\n            if (count.get(y) == 0) {\n                nonzero--;\n            }\n\n            if (nonzero == 0) {\n                ans++;\n            }\n        }\n\n        return ans;\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度: O(NlogN)，其中N为arr的长度。\n空间复杂度: O(N)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920894977","body":"# **思路**\n\n形成闭合圆环，指针走动\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n    public ListNode rotateRight(ListNode head, int k) {\n\n        if (head == null || head.next == null || k == 0){\n            return head;\n        }\n\n        int len = 1;\n        ListNode root = head;\n        //遍历求出listNode大小\n        while (root.next!= null){\n            root = root.next;\n            len++;\n        }\n\n        int remainder = k%len;\n        if (remainder == 0){\n            return head;\n        }\n\n        //尾节点的下一个节点是头节点，弄成闭合圆环\n        root.next = head;\n        while (remainder++ < len){\n            root = root.next;\n        }\n\n        ListNode ret = root.next;\n        root.next = null;\n        return ret;\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(n)， 最多遍历两次\n\n空间复杂度：O(1)，每次使用的空间都为常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921747515","body":"# **思路**\n\n创建一个虚拟节点，下一个节点指向头节点，然后两两替换\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n   public ListNode swapPairs(ListNode root){\n        if (root == null || root.next == null){\n            return root;\n        }\n\n        ListNode vitualNode = new ListNode(0);\n        vitualNode.next = root;\n        ListNode tmpNode = vitualNode;\n        while (tmpNode.next != null && tmpNode.next.next != null){\n            ListNode node1 = tmpNode.next;\n            ListNode node2 = tmpNode.next.next;\n            tmpNode.next = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n            tmpNode = node1;\n        }\n        return vitualNode.next;\n    }\n\n\n      class ListNode {\n      int val;\n      ListNode next;\n      ListNode() {}\n      ListNode(int val) { this.val = val; }\n      ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n  }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(n)，替换节点指向\n\n空间复杂度：O(1)，每次使用的空间都为常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922332108","body":"# **思路**\n\n分治 + 中序遍历优化(参考官方解题思路)\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n         ListNode globalHead;\n\n    public TreeNode sortedListToBST(ListNode head) {\n        globalHead = head;\n        int length = getLength(head);\n        return buildTree(0, length - 1);\n    }\n\n    public int getLength(ListNode head) {\n        int ret = 0;\n        while (head != null) {\n            ++ret;\n            head = head.next;\n        }\n        return ret;\n    }\n\n    public TreeNode buildTree(int left, int right) {\n        if (left > right) {\n            return null;\n        }\n        int mid = (left + right + 1) / 2;\n        TreeNode root = new TreeNode();\n        root.left = buildTree(left, mid - 1);\n        root.val = globalHead.val;\n        globalHead = globalHead.next;\n        root.right = buildTree(mid + 1, right);\n        return root;\n    }\n\n    class ListNode {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) { this.val = val; }\n        ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n    }\n\n    class TreeNode {\n      int val;\n      TreeNode left;\n      TreeNode right;\n      TreeNode() {}\n      TreeNode(int val) { this.val = val; }\n      TreeNode(int val, TreeNode left, TreeNode right) {\n          this.val = val;\n          this.left = left;\n          this.right = right;\n      }\n   }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(n)，其中 n 是链表的长度。\n\n空间复杂度：O(logn)，这里只计算除了返回答案之外的空间。平衡二叉树的高度为 O(logn)，即为递归过程中栈的最大深度，也就是需要的空间。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HackBL":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916580190","body":"```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        while (k > 0) {\r\n            list.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        return list;\r\n    }\r\n}\r\n```\r\n* 时间复杂度: O(Max(n, k))\r\n* 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917156860","body":"* 正反向遍历\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int k = -s.length();\r\n        \r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) \r\n                k = i;\r\n            \r\n            res[i] = i - k;\r\n        }\r\n        \r\n        for (int i = k; i >= 0; i--) {\r\n            if (s.charAt(i) == c)\r\n                k = i;\r\n            res[i] = Math.min(res[i], k-i);\r\n        }\r\n        \r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n* Time: O(n)\r\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917481827","body":"* LinkedList构建Stack\r\n```\r\nclass CustomStack {\r\n    Node head;\r\n    int maxSize;\r\n    int size;\r\n    int[] inc;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        this.head = null;\r\n        this.maxSize = maxSize;\r\n        this.size = 0;\r\n        this.inc = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (size < maxSize) {\r\n            Node node = new Node(x);\r\n            node.next = head;\r\n            head = node;\r\n            size++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (size == 0) return -1;\r\n        int cur = head.val;\r\n        head = head.next;\r\n        int i = --size;\r\n        \r\n        if (i >= 1)\r\n            inc[i-1] += inc[i];\r\n        \r\n        \r\n        cur += inc[i];\r\n        inc[i] = 0;\r\n        \r\n        return cur;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int i = Math.min(size, k) - 1;\r\n        if (i < 0) return;\r\n        inc[i] += val;\r\n    }\r\n    \r\n    class Node{\r\n        Node next;\r\n        int val;\r\n        \r\n        public Node(int val) {\r\n            this.val = val;\r\n        }\r\n    }\r\n}\r\n```\r\n* Time: O(1) for all operations\r\n* Space O(n)\r\n* 空间换时间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917699649","body":"* Stack判断括号\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Deque<StringBuilder> strStack = new LinkedList<>();\r\n        Deque<Integer> intStack = new LinkedList<>();\r\n        StringBuilder sb = new StringBuilder();\r\n        int k = 0;\r\n        \r\n        for (char c: s.toCharArray()) {\r\n            if (Character.isDigit(c)) {\r\n                k = k * 10 + (c - '0');\r\n            } else if (c == '[') {\r\n                strStack.push(sb);\r\n                intStack.push(k);\r\n                \r\n                sb = new StringBuilder();\r\n                k = 0;\r\n            } else if (c == ']') {\r\n                StringBuilder tmp = sb;\r\n                sb = strStack.pop();\r\n                \r\n                for (int i = intStack.pop(); i > 0; i--)\r\n                    sb.append(tmp);\r\n            } else {\r\n                sb.append(c);\r\n            }\r\n        }\r\n        \r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n* Time: O(maxK*n) such as k[string]\r\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918813852","body":"* 2 Stack实现Queue\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> in = new Stack();\r\n    Stack<Integer> out = new Stack();\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (out.isEmpty()) {\r\n            if (in.isEmpty()) return -1;\r\n            \r\n            while (!in.isEmpty())\r\n                out.push(in.pop());\r\n            \r\n        }\r\n        return out.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (out.isEmpty()) {\r\n            if (in.isEmpty()) return -1;\r\n            \r\n            while (!in.isEmpty())\r\n                out.push(in.pop());\r\n            \r\n        }\r\n        return out.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return in.isEmpty() && out.isEmpty();\r\n    }\r\n}\r\n```\r\n* 时间: push O(1), peek O(n), pop O(n), empty O(1)\r\n* 空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920106980","body":"* 如果前面的元素<=后面的元素，chunck += 1\r\n* 维持当前最大的元素，一直与后面的一个做比较，如果 <= 后面的元素，chunck+=1\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int n = arr.length;\r\n        int res = 0;\r\n        int max = arr[0];\r\n        int[] min = new int[n];\r\n        \r\n        min[n-1] = arr[n-1];\r\n        for (int i = n-2; i >= 0; i--)\r\n            min[i] = Math.min(arr[i], min[i+1]);\r\n        \r\n        \r\n        for (int i = 0; i < n-1; i++) {\r\n            if (i > 0)\r\n                max = Math.max(arr[i], max);\r\n            \r\n            if (max <= min[i+1])\r\n                res++;\r\n        }\r\n        \r\n        return res + 1;\r\n    }\r\n}\r\n```\r\n* Time: O(n)\r\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920573274","body":"* two pointers \r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return null;\r\n        ListNode dummy = new ListNode();\r\n        dummy.next = head;\r\n        ListNode p1 = dummy, p2 = dummy;\r\n        int n = 0;\r\n        \r\n        while (p1.next != null) {\r\n            p1 = p1.next;\r\n            n++;\r\n        }\r\n        \r\n        for (int i = 0; i < n - k % n; i++)\r\n            p2 = p2.next;\r\n        \r\n        p1.next = dummy.next;\r\n        dummy.next = p2.next;\r\n        p2.next = null;\r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\n* Time: O(n)\r\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921317073","body":"* Iterative\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummy = new ListNode();\r\n        dummy.next = head;\r\n        ListNode prev = dummy;\r\n        \r\n        while (head != null && head.next != null) {\r\n            ListNode then = head.next;\r\n            head.next = then.next;\r\n            then.next = head;\r\n            prev.next = then;\r\n            prev = head;\r\n            head = head.next;\r\n        }\r\n        \r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\n* Time: O(n)\r\n* Space: O(1)\r\n\r\n* Recursive:\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) return head;\r\n        \r\n        ListNode then = head.next;\r\n        ListNode nextNode = then.next;\r\n        \r\n        then.next = head;\r\n        head.next = swapPairs(nextNode);\r\n\r\n        return then;\r\n    }\r\n}\r\n```\r\n* Time: O(n)\r\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922176562","body":"* Recursive, DFS to construct height balanced BST by LinkedList\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return sortedListToBST(head, null);\r\n    }\r\n    \r\n    public TreeNode sortedListToBST(ListNode head, ListNode tail) {\r\n        if (head == tail) return null;\r\n        ListNode fast = head, slow = head;\r\n        \r\n        while (fast != tail && fast.next != tail) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        \r\n        TreeNode node = new TreeNode(slow.val);\r\n        node.left = sortedListToBST(head, slow);\r\n        node.right = sortedListToBST(slow.next, tail);\r\n        \r\n        return node;\r\n    }\r\n}\r\n```\r\n* Time: O(nlogn)\r\n* Space: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922424207","body":"```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode n1 = headA, n2 = headB;\r\n        \r\n        while (n1 != null || n2 != null) {\r\n            if (n1 == null) n1 = headB;\r\n            if (n2 == null) n2 = headA;\r\n            if (n1 == n2) return n1;\r\n            \r\n            n1 = n1.next;\r\n            n2 = n2.next;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n}\r\n```\r\n* 时间复杂度: O(n)\r\n* 空间: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"TimmmYang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916580399","body":"## 思路\n从低到高逐位相加。如果k的位数比X多，就继续执行一遍。可以把两个循环合并，给结果单开一个list逆序返回。\n## 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            summ = num[i] + k % 10 + carry\n            k //= 10\n            carry = 0\n            if summ >= 10:\n                carry = 1\n                summ -= 10\n            num[i] = summ\n        if carry == 1 and k == 0:\n            num.insert(0, 1)\n            return num\n        while k != 0:\n            summ = k % 10 + carry\n            k //= 10\n            carry = 0\n            if summ >= 10:\n                carry = 1\n                summ -= 10\n            num.insert(0, summ)\n        if carry == 1:\n            num.insert(0, 1)\n        return num\n```\n## 复杂度\n时间：O(max(n, log(k)))，n为num长度\n\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351996","body":"# 方法一\r\n## 思路\r\n第一反应的做法，两次遍历，使用额外列表存含有c的index。这样出现了循环嵌套，虽然可以通过但是不够优秀\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        record = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                record.append(i)\r\n        for i in range(len(s)):\r\n            d = len(s)\r\n            for idx in record:\r\n                d = min(abs(i - idx), d)\r\n            res.append(d)\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n时间：O(N^2)\r\n空间：O(N)\r\nN为s长度\r\n\r\n# 方法二\r\n## 思路\r\n使用正反两次遍历，每次存该位置元素离最左（右）边目标的距离，两者取最小值即为答案。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        idx = float('-inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i\r\n            res.append(i - idx)\r\n        idx = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            res[i] = (min(res[i], idx - i))\r\n        return res\r\n```\r\n### 复杂度\r\n时间：O(N)\r\n空间：O(N)\r\nN为s长度\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917593338","body":"## 思路\r\n普通的直接数组increment方法时间复杂度为O(min(k,len(stack))，不够优秀。使用空间换时间，增加一个add列表存增量，pop的时候加上增量即可。\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) - 1 != self.top:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        res = self.stack[self.top] + self.add[self.top]\r\n        if self.top != 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return res\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k - 1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n## 复杂度\r\n时间: 全部为O(1)\r\n空间: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917788183","body":"## 思路\r\n结果需要从括号内向外逐层解开，使用栈可以达到我们的目标。最后在栈内的字符串都是解好的字符串，连起来返回即可。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                mul = ''\r\n                tmp = ''\r\n                while stack and stack[-1] != '[':\r\n                    tmp = stack.pop() + tmp. # 在前面pop后面就不用翻转了\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    mul = stack.pop() + mul\r\n                tmp = tmp * int(mul)\r\n                stack.append(tmp)\r\n            else:\r\n                stack.append(c)\r\n        return ''.join(stack)\r\n```\r\n\r\n## 复杂度\r\n时间：O(N)，N为s长度\r\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919028425","body":"## 思路\r\n两个栈来完成队列。stack1用来入队列，stack2用来出队列。\r\n\r\n## 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1, self.stack2 = [], []\r\n        \r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.stack2:\r\n            return self.stack2[-1]\r\n        else:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2[-1]            \r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if not self.stack1 and not self.stack2:\r\n            return True\r\n        else:\r\n            return False\r\n```\r\n## 复杂度\r\n时间：O(1) 每个操作均摊时间复杂度\r\n空间：O(N) N为入队列元素数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919703312","body":"## 思路\r\n单调栈。本质是遍历数组，找到数组从头到当前位置的最大值小于数组当前位置到最后的最小值的地点，这里就可以是切分的点。使用单调栈从后往前依次存入最小值，再从头遍历比较即可。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack_min = []\r\n        minimum = float('inf')\r\n        maximum = float('-inf')\r\n        res = 0\r\n        for i in range(len(arr) - 1, -1, -1):\r\n            minimum = min(minimum, arr[i])\r\n            stack_min.append(minimum)\r\n        for i in range(len(arr)):\r\n            if maximum <= stack_min[-1]:\r\n                res += 1\r\n            maximum = max(maximum, arr[i])\r\n            stack_min.pop()\r\n        return res\r\n```\r\n## 复杂度\r\n时间：O(N) N为数组长度\r\n空间：O(N) 单调栈所占空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920623163","body":"## 思路\r\n把链表变成环，往回找k%s个节点即可，s为链表长度。其实也不用非要成环，无非是找到倒数第k%s个节点，然后断开+连接到初始头节点即可。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or k == 0 or head.next is None:\r\n            return head\r\n        p = head\r\n        s = 1\r\n        while p.next is not None:\r\n            p = p.next\r\n            s += 1\r\n        p.next = head\r\n        mod = s - k % s\r\n        if mod == 0: return head\r\n        while mod > 0:\r\n            p = p.next\r\n            mod -= 1\r\n        res = p.next\r\n        p.next = None\r\n        return res\r\n```\r\n## 复杂度\r\n时间：O(N) N为链表长度\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921418721","body":"## 思路\r\n迭代法，遍历一遍链表，注意下循环的条件。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        dummy = ListNode()\r\n        dummy.next = head\r\n        pre, cur, nxt = dummy, head, head.next\r\n        tmp = head\r\n        while tmp and nxt:  \r\n            tmp = nxt.next\r\n            nxt.next = cur\r\n            cur.next = tmp\r\n            pre.next = nxt\r\n            if tmp:\r\n                pre, cur, nxt = cur, tmp, tmp.next        \r\n        return dummy.next\r\n```\r\n\r\n## 复杂度\r\n时间：O(N) N为链表长度\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922166569","body":"## 思路\r\nDFS，每棵子树的根结点是输入的左右两边的中点。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        vals = []\r\n        while head:\r\n            vals.append(head.val)\r\n            head = head.next\r\n        def constructBST(left, right):\r\n            if left > right:\r\n                return\r\n            mid = (left + right) // 2\r\n            node = TreeNode(vals[mid])\r\n            node.left = constructBST(left, mid-1)\r\n            node.right = constructBST(mid+1, right)\r\n            return node\r\n        return constructBST(0, len(vals)-1)\r\n```\r\n## 复杂度\r\n时间：O(N) N是链表长度。\r\n空间：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922407256","body":"## 思路\r\n双指针，链表A或B同时开始遍历，遍历到最后一个节点后分别指向对方的头节点进行第二次遍历，这样如果相交就会在相交节点两指针相遇，返回即可；不相交就会第二次触底，这时返回即可。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        p1, p2 = headA, headB\r\n        flag1 = flag2 = 0\r\n        while p1 != p2:\r\n            p1 = p1.next\r\n            p2 = p2.next\r\n            if p1 == None:\r\n                p1 = headB\r\n                flag1 += 1\r\n            if p2 == None:\r\n                p2 = headA\r\n                flag2 += 1\r\n            if flag1 >= 2 or flag2 >= 2:\r\n                return None\r\n        return p1\r\n```\r\n## 复杂度\r\n时间：O(n) n为两链表长度之和\r\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AnhTom2000":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916581198","body":"## 思路\r\n遍历数组并且拆分k进行诸位相加，过程中注意如果两者的和超过了个位数，需要累计进位。\r\n## Java\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        int i = num.length - 1;\r\n        while( i >= 0 || k > 0){\r\n          if( i >= 0){\r\n          int sum = num[i] + k % 10;\r\n          k/=10;\r\n          if(sum >=10){\r\n            k++;\r\n            sum-=10;\r\n          }\r\n          list.addFirst(sum);\r\n          i--; \r\n        }else {\r\n          list.addFirst(k%10);\r\n          k/=10;\r\n        }\r\n      }\r\n        return list;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度：`O(n+logk)`,n为数组长度\r\n空间复杂度：`O(max(n,k))`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917326031","body":"## 思路\n\n- 正向遍历一遍，每次遇到目标字符就标记，然后计算非目标字符的距离\n\n- 反向遍历一遍，同上述做法，计算与正向遍历结果最小值更新数组\n\n## 代码\n\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n      int len = s.length();\n      int res[] = new int[len];\n      int now = Integer.MAX_VALUE;\n      for(int i = 0; i < len; i++){\n        char target = s.charAt(i);\n        if(target == c) now = i;\n        res[i] = Math.abs( i - now);\n      }\n\n      int lNow = Integer.MAX_VALUE;\n      for(int j = len - 1; j >=0;j--){\n        char target = s.charAt(j);\n        if(target == c) lNow = j;\n        res[j] = Math.min(res[j],Math.abs(lNow - j));\n      }\n      return res;\n    }\n}\n```\n\n## 复杂度分析\n\n时间复杂度 : `O(n)`,n为字符串长度\n\n空间复杂度 : `O(n)`\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917544924","body":"## 思路\n\n使用数组模拟栈，用一个变量 size来记录当前栈顶的位置。\n\n- 对于 push 操作，首先判断当前元素的个数是否达到上限，如果没有达到，就把 size 后移一个位置并添加一个元素。\n\n- 对于 pop 操作，首先判断当前栈是否为空，非空返回栈顶元素并将 size 前移一位，否则返回 −1。\n\n- 对于 inc 操作，直接对栈底的最多 k 个元素加上 val。\n\n## 代码\n\n```Java\nclass CustomStack {\n   private int stack[];\n   private int maxSize;\n   private int size;\n    public CustomStack(int maxSize) {\n      this.maxSize = maxSize;\n      this.size = -1;\n      this.stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n      if(isFull()) return; \n      this.stack[++this.size] = x;\n    }\n    \n    public int pop() {\n      if(isEmpty()) return -1;\n      int res = this.stack[this.size];\n      this.size--;\n      return res;\n    }\n    \n    public void increment(int k, int val) {\n       for(int i = 0;i <=this.size && i < k;i++){\n         this.stack[i]+=val;\n       }\n    }\n\n    private boolean isFull(){\n      return this.size == this.maxSize-1;\n    }\n\n    private boolean isEmpty(){\n      return this.size == -1;\n    }\n}\n```\n\n## 复杂度分析\n\n时间复杂度 : `O(n)`,栈大小，push操作和poo操作的复杂度为`O(1)`\n\n空间复杂度 : `O(maxSize)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918006506","body":"## 思路\n\n使用两个辅助栈。\n\n一个存储数字，一个存储遇到`\"[\"`的瞬时结果（这个栈中的所有瞬时结果合起来就是最最终的结果）。\n\n如果遇到数字，需要处理多位数字的情况，使用`mutil`变量将他们连接起来，并在遇到`\"[\"`时压入存储数字的栈。\n\n非数字情况，有三种情况：\n\n- 遇到`\"[\"`，我们需要将连接的数字以及连接的瞬时字符串压入栈中\n\n- 遇到`\"]\"`，括号闭合，我们需要将数字栈顶元素弹出，循环添加括号中出现的字符，并且最后连同存储瞬时结果栈的栈顶元素添加进结果字符串中。\n\n- 其余的字符串直接添加进`res`中就可以了\n\n## 代码：Java\n\n```Java\nclass Solution { \n    public String decodeString(String s) {\n        Stack<Integer> s1  = new Stack<>();\n        Stack<String> s2 = new Stack<>();\n        StringBuilder res = new StringBuilder();\n        int mutil = 0;\n        for(char c: s.toCharArray()){\n          if(c == '['){\n            s1.push(mutil);\n            s2.push(res.toString());\n            res = new StringBuilder();\n            mutil = 0;\n          }else if(c == ']'){\n            int nums = s1.pop();\n            StringBuilder temp = new StringBuilder();\n            for(int i = 0; i < nums;i++){\n              temp.append(res);\n            }\n            res  = new StringBuilder(s2.pop() + temp);\n          }else if(Character.isDigit(c)){\n            mutil = mutil * 10 + (c - '0');\n          }else res.append(c);\n        }\n        return res.toString();\n    }\n}\n```\n\n## 复杂度分析\n\n时间复杂度：`O(n)`,n代表字符串长度\n\n空间复杂度：`O(n)`,栈空间最大存储的是字符串的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918815377","body":"## 思路\n\n使用两个辅助栈，一个作为输入栈，一个作为输出栈\n\n因为队列`FIFO`的特性，正好和栈`LIFO`反过来\n\n我们在存入数据的时候，用输入栈临时存储数据，如果输出栈为空，依次将输入栈中的数据弹出，添加到输出栈中，这样在输入栈底中的元素就变成了输出栈顶的元素，实现队列`FIFO`的特性。\n\n## 代码 : Java\n\n```Java\nclass MyQueue {\n\n  Stack<Integer> s1 ;\n\n  Stack<Integer> s2 ;\n\n  public MyQueue() {\n   this.s1 = new Stack<>();\n   this.s2 = new Stack<>();\n  }\n\n  public void push(int x) {\n   this.s1.push(x);\n  }\n\n  public int pop() {\n\n   if(this.s2.isEmpty()){\n   inOut();\n  }\n   return this.s2.pop();\n  }\n\n  public int peek() {\n   if(this.s2.isEmpty()){\n   inOut();\n  }\n   return this.s2.peek();\n  }\n\n  public boolean empty() {\n  return this.s1.isEmpty() && this.s2.isEmpty();\n  }\n\n  public void inOut(){\n  while(!this.s1.isEmpty()){\n  this.s2.push(this.s1.pop()); \n  }\n }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920081894","body":"## 思路\n\n今天刚学的一种算法结构，看了一些大佬的题解以及一些解析单调栈的文章才勉强能将题目做出来，就简单写一下我理解的思路\n\n单调栈在某一个元素插入过程中，为保持自身的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。\n\n遍历数组，判断是否满足入栈出栈的条件。\n\n- 入栈条件：如果当前栈为空或当前数值大于栈顶元素，则更新栈中最大值\n\n- 出栈条件：如果当前数值小于栈顶元素，则循环弹出栈顶，直至当前元素小于或等于栈顶元素，然后将一开始弹出的栈顶元素入栈，作为单调栈的最大值。\n\n## 代码：Java\n\n```Java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for(int i = 0; i < arr.length;i++){\n          if(stack.isEmpty() || stack.peek() <= arr[i]) stack.push(arr[i]);\n          else {\n            int pop = stack.pop();\n            while(!stack.isEmpty() && stack.peek() > arr[i]) stack.pop();\n            stack.push(pop);\n          }\n        }\n        return stack.size();\n    }\n}\n```\n\n## 复杂度分析\n\n时间复杂度 ：`O(n)`\n\n空间复杂度 ：`O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920780982","body":"## 思路\n\n我们首先计算出链表的长度 nn，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n - 1) - (k \\bmod n)(n−1)−(kmodn) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。\n\n## 代码\n\n```Java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n      if(k == 0 || head == null || head.next == null) return head;\n      ListNode temp = head;\n      int index = 1;\n      while(temp.next != null){\n        index++;\n        temp = temp.next;\n      }\n      int add = index - k % index;\n      temp.next = head;\n      while(add-- >0){\n          temp = temp.next;\n      }\n      ListNode res = temp.next;\n      temp.next = null;\n      return res;\n    }\n}\n```\n\n## 复杂度分析\n\n时间复杂度 ： `O(n)`\n\n空间复杂度 ： `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921542087","body":"## 思路\n\n 迭代法：设置两个指针，每次移动的步伐都为2，每次移动后将两指针的next域进行交换\n\n## 代码 : Java\n\n```Java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n       if(head == null || head.next == null) return head;\n      \n       ListNode dummy = new ListNode(-1);\n       dummy.next = head;\n       ListNode temp = dummy;\n       while(temp.next != null && temp.next.next != null){\n          ListNode slow = temp.next;\n          ListNode fast = temp.next.next;\n          temp.next = fast;\n          slow.next = fast.next;\n          fast.next = slow;\n          temp = slow;\n       }\n       return dummy.next;\n    }\n}\n```\n\n## 复杂度分析\n\n时间复杂度  :  `O(n)`\n\n空间复杂度 ：`O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922278937","body":"## 思路\n\n分治法，有点类似于折半查找的思路，每次先用快慢指针找到链表的中点，这个中点作为子树的根节点，然后通过中点继续划分左右链表。\n\n## 代码： Java\n\n```Java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n       if(head == null) return null;\n       if(head.next == null) return new TreeNode(head.val);\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode split = null;\n       while( fast != null && fast.next != null){\n         fast = fast.next.next;\n         split = slow;\n         slow = slow.next;\n       }\n       TreeNode root = new TreeNode(slow.val);\n       ListNode rhead = slow.next;\n       split.next = null;\n\n       root.left = sortedListToBST(head);\n       root.right = sortedListToBST(rhead);\n       return root;\n    }\n}\n```\n\n## 复杂度分析\n\n时间复杂度：`O(nlogn)`\n\n空间复杂度：`O(logn)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922402325","body":"## 思路\n\n先算出链表A与链表B的`length`，然后算出两者之间的差值`diffrence`，让两者中最长的的链表先走`diffrence`步，再让较短的链表与长链表一起遍历，如果两个链表结点相同则说明两个链表相交了。\n\n## 代码：Java\n\n```Java\npublic class Solution {\n    public int getLen(ListNode head){\n      ListNode  temp = head;\n      int index = 0;\n      while(temp != null){\n        index++;\n        temp = temp.next;\n      }\n      return index;\n    }\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n       int a = getLen(headA);\n       int b = getLen(headB);\n       int difference = Math.abs(a - b);\n       ListNode ta = headA;\n       ListNode tb = headB;\n\n       if(b > a){\n         for(int i = 0; i < difference ;i ++){\n           tb = tb.next;\n         }\n         while(tb != null){\n           if(tb == ta) return tb;\n           tb = tb.next;\n           ta = ta.next;\n         }\n       }else {\n         for(int i = 0; i < difference ;i++){\n           ta = ta.next;\n         }\n         while(ta != null){\n           if(ta == tb) return ta;\n           ta = ta.next;\n           tb = tb.next;\n         }\n       }\n\n       return null;\n    }\n}\n```\n## 复杂度分析\n\n时间复杂度：`O(n)`\n\n空间复杂度：`O(1)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"15691894985":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916582098","body":"day  01  989　　数组形式的整数加法\r\n\r\n- 思路：\r\n  1. 遍历数组，取出合成整数\r\n  2. 合成整数与Ｋ求和\r\n  3. 把求和后的整数再反向分解为数组\r\n\r\n- 代码段：\r\n```python\r\n  def add_to_array(arrya,k):\r\n       n = len(arrya)\r\n       x=0\r\n       y =[]\r\n      for i in range(n):\r\n          x = x+ arrya[i] * 10**(n-i-1)\r\n       x = x +k\r\n       if len(x)>n:\r\n          for i in range(len(x)):\r\n              y.append( x//(10**(len(x)-i-1)))\r\n              x = x -y[i]*(10**(len(x)-i-1))\r\n       else:\r\n          for i in range(n):\r\n              y.append( x//(10**(n-i-1)))\r\n              x = x -y[i]*(10**(n-i-1))\r\n      return y\r\n  \r\n\r\n\r\n- 复杂度分析\r\n  1. 时间复杂度 O(N)\r\n  2. 空间复杂度O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917327328","body":"思路：\n\n1.先遍历记录字符c出现的位置。\n\n2.遍历字符S，找到目标字符最近的解\n```python\n    def  distance_character(self,S:str,C:str)->list[int]:\n        x =[]\n        SY = S\n        res = [1000000 for i in range (len(S))]\n        while S.rfind(C)!=-1:\n            x.append(S.rfind(C))\n            S = S[:x[-1]]\n        # 目标字符\n        x.reverse()\n        for i in range(len(SY)):\n            if SY[i]==C:\n                res[i]= 0\n        # 非目标字符，找最近\n            for index in x:\n                dist = abs(index-i)\n                if dist>res[i]: #因为计算了与第一个字符的距离后，只要后面一个比之前的距离大那么后面的都会大\n                    break\n                res[i] = dist\n        return dist\n\n\n\n复杂度分析\n\n- 时间复杂度分析 O（n*k）n是字符串长度，k是字符C出现在字符串内的次数\n- 空间复杂度O（k） k是字符C出现在字符串内的次数\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917541695","body":"思路一：用一个数组去操作increment。push和pop判断边界 记录一个当前栈长\n```python\n    class CustomStack:   #根据题目描述解法\n        def __init__(self, maxSize):\n            self.n = maxSize\n            self.stack = [] #其中元素\n            self.inc = 0 #当前长度\n        def push(self,x):#入栈操作\n            if self.inc<self.n:\n                self.stack.append(x)\n                self.inc += 1\n        def pop(self):\n            if self.inc==0:return -1\n            self.inc -= 1\n            return self.stack.pop()\n        def increment(self,k,val):\n            for i in range(0, min(k,len(self.inc))):\n                self.stack[i] += val\n\n复杂度分析：\n\n时间复杂度：push和pop都为O(1)  increment 为O(min(k,inc))\n\n空间复杂度：返回值O(1)\n\n方法二：前缀和解法\n- 思路，空间换时间，单独将Increment操作结合到pop里\n- incremnet信息，优化记录当前栈长度inc，同时pop减小increment数组的开销\n    class CustomStack:   #前缀合解法\n        def __init__(self, maxSize):\n            self.n = maxSize\n            self.stack = [] #其中元素\n            self.inc = 0 #当前长度\n            self.incrementals = []\n        def push(self, x):  # 入栈操作\n            if self.inc< self.n:\n                self.stack.append(x)\n                self.incrementals.append(0)\n                self.inc += 1\n        def pop(self):\n            if self.inc == 0: return -1\n            self.inc -= 1\n            if self.inc >=1:\n                self.incrementals[self.inc-2] += self.incrementals[self.inc-1]\n            ans = self.stack.pop() + self.incrementals.pop()\n            self.incrementals[self.inc-1] = 0\n            self.inc -= 1\n            return ans\n    \n        def increment(self, k, val):\n            if self.inc:\n                self.incrementals[min(self.inc,k)-1] += val\n\n复杂度分析:\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(inc)      维护一个大小inc的数组  inc < maxSize\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917803468","body":"9.13  day3   394.字符串解码\n\n思路：\n\n-  解码的过程是以找到成对的括弧，重复中间的字符。括弧可用先进后出特性的栈表示\n\n- 遍历S中的字符，如果不是']'重复压栈操作，如果是']'时，说明括弧匹配时候，只要栈最后一位不为'['时，继续取出刚入栈的，作为重复字符串，并执行出栈。在判断栈中倒末是否为数字，是数字则进行数字与重复字符的运算，并添加到栈中。\n```python\n    def decode_string(s):\n        stack = []\n        for c in s :\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1]!='[':   #括弧匹配时候把重复的字符取出来\n                    repeatStr = stack.pop()+ repeatStr #取出来的字符就出栈\n                stack.pop()  #把'['也出栈\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop()+repeatCount   #判断是否数值时候把数字取出来，数字出栈\n                stack.append(int(repeatCount) *repeatStr)  #按数字重复字符，并加到append\n            else:\n                stack.append(c)  #没有遇到]前持续压栈\n        return \"\".join(stack)   #把stack重新拼接\n\n复杂度分析：\n\n- 时间复杂度：O(N) 一个遍历操作，字符串的长度\n- 空间复杂度：O(N)  记录解码后的字符串所需要的空间\n\n \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919082715","body":" 9.14 day4  232. 用栈实现队列\n\n- 思路：\n  由于栈是先进后出，队列是先进先出，因此用两个栈，一个出的同时进入另一个栈实现反转\n\n- 代码：\n```python\n      class MyQueue:\n      \n          def __init__(self):\n              self.stack1,self.stack2 = [],[] \n      \n          def push(self, x: int) -> None:\n      \n              self.stack1.append(x)\n      \n          def pop(self) -> int:\n              if self.stack2:\n                  return self.stack2.pop()\n              else:\n                  while self.stack1:\n                      self.stack2.append(self.stack1.pop())#把栈1的数出栈，然后保存到栈2\n                  return self.stack2.pop()\n      \n          def peek(self) -> int:\n         #获得最前面的元素值\n              if self.stack2:\n                  return self.stack2[-1]\n              else:\n                  while self.stack1:\n                      self.stack2.append(self.stack1.pop())  # 把栈1的数出栈，然后保存到栈2\n                  return self.stack2[-1]\n      \n          def empty(self) -> bool:\n              if not self.stack2 and not self.stack1:\n                  return True\n              else:\n                  return False\n  \n\n- 时间复杂度分析：\n  时间复杂度：push O(1) pop 是  O(N) 反转一次  peek O(N) 反转一次  empty是O(1) \n  空间复杂度：O(N)是另一个栈的空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919987152","body":"9.15 day 5  768. 最多能完成排序的块 II\n\n- 思路：\n  找到分块的边界，就是当前数组和排序后的数组，窗口滑动内的元素求和应该相等，块是内部排序，相等的点就可以分块。相比于题解中用collections.defaultdict(int) 判断计数信息是否一致。用collections.defaultdict(int)来记录diff，求和更为简单。\n- 代码：\n```python\n      def  maxChunksToSorted(arr):\n          #滑动窗口思想\n          sored = sorted(arr, reverse=False)\n          count = 0\n          sum1 = 0\n          sum2 = 0\n          for i in range(len(arr)):\n              sum1 += arr[i]\n              sum2 += sored[i]\n              if sum1 == sum2:\n                  count += 1\n          return count\n***\n  时间复杂度：arr.length()为N 时间复杂度是O(N) ，因此为O(N)\n  空间复杂度：两个sum   因此为O(N)\n  执行用时：40ms\n***\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920888093","body":"day6  61. 旋转链表\n\n思路：\n\n- 找到链表中倒数k和k+1个节点，用快慢指针，快指针比慢指针先走K步。\n- 将倒数K+1节点的next指向null\n- 将尾部节点Next指向head\n- 返回倒数第K个节点    右移动k位 即向右移动K%len\n```python\n      class Solution:\n          def  rotateRight(head,k):\n          #     找到倒数第k个节点,和k+1个节点\n          #        先建立链表\n              if head:\n                  p1 = head\n                  p2 = head\n                  count = 1\n                  i = 0\n                  while i <k:\n                      if p2.next:\n                          count += 1\n                          p2 = p2.next\n                      else:\n                          k = k % count\n                          i =-1\n                          p2 = head \n                      i +=1   #快指针 先走K步，直接到尾部指向head\n                  while  p2.next:\n                      p1 = p1.next #慢指针的next 指向none\n                      p2 = p2.next\n                  if p1.next: \n                      tmp = p1.next\n                  else:\n                      return head\n                  p1.next = None #k+1的节点\n                  p2.next = head #当前尾部节点指向head\n                  return tmp #如果是尾部节点则指向头节点\n  复杂度分析：\n  - 时间复杂度，O(N) 最坏情况下遍历两次\n  - 空间复杂度，O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921440707","body":"day 7   24. 两两交换链表中的节点\n\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n思路：\n\n  1.链表节点的指针，两两交换。定义两个节点的前节点和第二个节点的后续节点，然后逆转。同时改变指针位置。进行下一次交换\n\n  2.判断边界条件，为空表和只有一个节点的时候\n```python\n    class Solution:\n        def swapPairs(self, head: ListNode) -> ListNode:\n             if not head or not head.next:#为空表 或者只有一个节点\n                return head\n             ans = ListNode()  # A = new 链表新节点\n             ans.next = head.next# A.next =B\n             pre = ans  # A节点\n            # 第一个节点 = head\n             while (head and head.next): #第一个节点不为空且其next不为空\n                next = head.next# B = A.next\n                n_next = next.next# Bnext= B.next\n                # 对链表进行逆转\n                next.next = head  # B.next = A\n                pre.next = next # A.next  = B\n                head.next = n_next# A.next = Bnext\n    \n                # 修改指针位置，进行下一轮逆转\n                pre = head# 前置指针 = 第一个节点 pre -> B-> A-> nextB 指向A\n                head = n_next # 第一个节点 = 后指针\n             return ans.next\n\n复杂度：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922228113","body":"方法一：快慢指针\n\n思路：\n\n- 获取链表中点，以中点为根节点，构造左树，造右树\n- 获取链表中点：快指针进两步，慢指针进一步 因此快指针到达尾部时候，慢指针就在中间\n- 考虑特殊情况，空链表和链表中只有一个节点的情况\n```python\n       def sortedListToBST(self,head:ListNode)->TreeNode:\n            #双指针\n            if not head or not head.next:#为空表 或者只有一个节点\n                return head\n            pre =None #中间节点\n            p1,p2 = head,head\n            while p2 and p2.next:\n                pre = p1\n                p1 = p1.next #慢指针进一步 因此快指针到达尾部时候，慢指针就在中间\n                p2 = p2.next.next #快指针进两步\n            #建立并断开前后连续连接点\n            if pre:\n                pre.next = None\n            root = TreeNode(p1.val)\n            # 递归建立左右子树\n            root.left = self.sortedListToBST(head)\n            root.right = self.sortedListToBST(p1.next)\n            print(root)\n            return root\n\n复杂度分析：\n\n- 时间复杂度：由于主定理 T(N)=O(N)+2T(N/2),可推导出来O（nlogn）\n- 空间复杂度为：O(logn)递归的调用深度\n\n方法二：中序遍历优化\n\n思路：\n\n- 不用急着找出链表的中位数节点，而是使用一个占位节点，等到中序遍历到该节点时，再填充它的值。\n- 求出链表的节点总个数，每次二分求出中位数编号\n- 构建左子树，然后用 h.val 创建节点 再构建根节点，构建右子树\n     def sortedListToBST(self,head:ListNode)->TreeNode:\n         def getLength(head:ListNode)->int:\n             ret = 0\n             while head:\n                 ret +=1\n                 head = head.next\n             return ret\n         def buildTree(left:int,right:int)->TreeNode:\n             # 进行中序遍历，中间节点为mid=(left+right+1)/2\n             if left > right:\n                 return None #递归出口\n             mid = (left +right +1)//2\n             root = TreeNode()\n             root.left = buildTree(left,mid-1)\n             nonlocal head\n             root.val = head.val\n             head = head.next\n             root.right = buildTree(mid+1,right)\n             return root\n         length = getLength(head)\n         return buildTree(0,length-1)\n\n复杂度分析：\n\n- 时间复杂度:找中位数时间变短 O(N) 递推式为 T(n) = 2  T(n/2) + O(1)，根据主定理，T(n) = O(n)T(n)=O(n)。\n- 空间复杂度:O(logn)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922476249","body":"方法一：哈希表\n\n- 首先遍历headA ，headA的节点加到哈希表进行储存\n- 其次用headB遍历的时候，看是否headB的节点在HeadA中，在的话就找到，不在就返回空\n```python\n      class Solution:\n          def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n          if (headA == None or headB == None):\n             return None\n          s =set()\n          while headA:\n              s.add(headA)\n              headA = headA.next\n          while headB:\n              if headB in s:\n                  return headB\n              headB = headB.next\n          return None\n      \n  复杂度分析：\n  - 时间复杂度：O(N) \n  - 空间复杂度：O(N) 开辟了一个哈希表\n  \n\n方法一：双指针\n\n思路：\n\n- 两指针以相同的速度从头节点移动\n- 当A到达尾节点时候，把headA重新定位到B的头节点\n- 当B到达尾节点时候，把headB重新定位到A的头节点\n- A、B指针相遇时，相遇节点为两链表的起始节点 因为两个指针访问都经过A+B+C\n\n    class Solution:\n        def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n    #     双指针\n        a,b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n\n复杂度分析:\n\n- 时间复杂度：需要遍历的长度为A+B+C 所以为O(N)\n- 空间复杂度：返回一个值O(1)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MonkofEast":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916582275","body":"# Algo\n1. Loop the array in a reversing way.\n   1. **Add current int directly to the current loc**\n   2. **Cal quo and res. Save quo as new int to next iter; save res as current item**\n   > (Optional) Leave the loop if no int should be added\n2. Attach the rest of quo in front of the array\n   >**DO remember to split out the quo since quo might not be single-digit**\n\n# Code\n```py\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # there is a same question for linked list\n        \n        # xrange(start, stop[not included], step) is not a list but a generator\n        for i in range(len(num) - 1, -1, -1):\n            # if reach the highest digit, if still have k, save and add\n            # else, just keep adding\n            num[i] += k\n            # carry along\n            k, num[i] = divmod(num[i], 10)\n            # no carry, leave\n            if not k: break\n        \n        # use map to broadcast for corners like \"[0], 100\"\n        # map(func, iterable), return an iterator\n        if k: num = list(map(int, str(k))) + num\n        return num\n```\n\n# Comp\n> T: O(N)\n> \n>S: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917096987","body":"# 821. Shortest Distance to a Character\n> [Click Me](https://leetcode.com/problems/shortest-distance-to-a-character/)\n## Algo\n0. Greedy\n1. Loop from lft, find the dis to cloest 'c' on the lft\n   > **Should init a float('-inf') for first non 'c's**\n2. Loop from lft, fint the dis to cloest 'c' on the rgt\n   > **Should init a float('-inf') for first non 'c's**\n4. Save the min() from 1 & 2\n   >Can be integrated into stp-2\n\n## Code\n```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # greedy\n        # init a res list \n        res = []\n        \n        # save previous loc of 'c', use '-inf' for the first non 'c's\n        prev = float('-inf') # S: O(1)\n        \n        # start from left, cal the distance of cloest 'c' on the left, record\n        for i in range(len(s)):\n            if s[i] == c:\n                prev = i\n                res.append(0)\n                continue\n            res.append(i - prev)\n            \n        # reset prev for the first non 'c's\n        prev = float('inf')\n        \n        # start from right, cal the distanc of cloest 'c' on the right, record\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                prev = i\n                continue\n            res[i] = min(res[i], prev - i)\n        return res\n```\n\n## Comp\n### T: O(N)\n### S: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917505444","body":"# 1381. Design a Stack With Increment Operation\n> [Click Me](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n## Algo\n1. Use an extra increment list. inc[i] means stack[0]~stack[i] should be incremented by inc[i]\n2. When popping, use the suminc[top] and stack[top]\n    1. Passing accumulationg when poping\n4. for func increment(), just mani self.inc\n\n## Code\n```py\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        # space for time\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.inc) < self.maxSize:            \n            self.stack.append(x)\n            # each item in inc represents the increment of stack[0] ~ stack[1]\n            # thus, the number of non-zero items == number of calling increment() before any pop\n            # [0, 0, 0, 3, 0, 0, 1, 3, 2]\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        # empty stack\n        if not self.stack: return -1\n        # accumulate the increments if there are previous increment\n        if len(self.inc) > 1: self.inc[-2] += self.inc[-1]\n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        # adjust self.inc[] to indicate increment\n        if self.inc: self.inc[min(k, len(self.inc)) - 1] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## Comp\n### T: O(1) for push/pop/inc\n### S: O(N) stack + inc","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917697358","body":"# 394. Decode String\n> [Click Me](https://leetcode.com/problems/decode-string/)\n## Algo\n1. Consider innermost decoding, stack is good\n2. new a stack for final output\n3. new a list for temp saving decode\n4. travel through the original str\n    1. if not ']', continue\n    2. if ']', stop, decode\n\n## Code\n```py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        # the key here is to consider cases like jksd19[dsl]fion3[acc2[d]]\n        # this nested pattern should be decode from innermost str\n        # so stack is good for this task\n        # KEY!!!: ']' on the top of stack is the starting point to decode\n        \n        stack = []\n        decodeList = []\n        \n        # travel the ori str\n        for i in range(len(s)):\n            # if not , travel\n            if s[i] != ']':\n                stack.append(s[i])\n            # if ']', stop, start decoding\n            else:\n                while stack[-1] != '[': decodeList.insert(0, stack.pop())\n                stack.pop() # delete '['\n                # find the multi times\n                times, multi = 0, 1\n                while stack and stack[-1].isnumeric():\n                    times += multi*int(stack.pop())\n                    multi *= 10\n                stack = stack + decodeList*times\n                decodeList.clear()\n        \n        # (str).join(list): return a str\n        return \"\".join(stack)\n```\n\n## Comp\n### T: O(N)\n### S: O(max(decoded-list))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918489981","body":"# 232. Implement Queue using Stacks\n> [Click Me](https://leetcode.com/problems/implement-queue-using-stacks/)\n## Algo\n1. KEY: 1 stack in + 1 stack out = 1 queue\n2. I choose push to be O(n), other O(1)\n\n## Code\n```py\nclass MyQueue:\n    # if want to use deque\n    # from collections import deque\n    \n    # but here I just use list\n    \"\"\"\n     LC is not smart enough to check operation used.....\n     So self limit that stacks can only use pop()\n    \"\"\"\n    # 2 stacks for mutually containing\n    # stack 1 receive push(), stack take pop()\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1, self.stack2 = [], []\n        \n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        # I push everything to stack 2 back, stack 1 holds nothing\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        # then append at tail\n        self.stack1.append(x)\n        # then push everything back to stack 2\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        # harder push() makes pop() easier\n        return self.stack2.pop()\n        \n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        # in fact a pointer will do, whatever\n        return self.stack2[-1]\n        \n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not self.stack2\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n## Comp\n### T: O(N) for push(), O(1) for others\n### S: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920119995","body":"# 768. Max Chunks To Make Sorted II\n> [Click Me](https://leetcode.com/problems/max-chunks-to-make-sorted-ii/)\n## Algo\n1. same counting info => same sorting info\n2. loop the arr, if decrese, merge to the biggest till now\n3. at the end, every item in monoStack should be a block\n4. use a incresing monoStack to comform with sorting\n5. stay with the current block high!\n\n\n## Code\n```py\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # use monotone stack\n        \"\"\"\n        KEY1: same counting info => same sorting info\n        KEY2: loop the arr, if decrese, merge to the biggest till now\n        KEY3: at the end, every item in monoStack should be a block\n        KEY4: use a incresing monoStack to comform with sorting\n        KEY5: stay with the current block high!\n        \"\"\"\n        # monoStack[-1] should be the highest in a block\n        monoStack = []        \n        \n        for a in arr:            \n            # check if this item can be merged\n            if monoStack and monoStack[-1] > a:\n                block_high = monoStack[-1]\n                while monoStack and monoStack[-1] > a: monoStack.pop()\n                monoStack.append(block_high)\n            else:\n                monoStack.append(a)\n        \n        return len(monoStack)\n```\n\n## Comp\n### T: O(N)\n### S: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920508750","body":"# 61. Rotate List\n> [Click Me](https://leetcode.com/problems/rotate-list/)\n## Algo\n1. get the nodes -k and -k-1: by quick/slow pointer\n2. set node_(-k-1).next to none\n3. combine tail.next and head\n4. return node -k\n\n## Code\n```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        # corner cases\n        if not head or not head.next: return head\n        \n        # save a len for super big k\n        list_len = 0\n        count = 0\n        \n        # slow/quick\n        quick, slow = head, head        \n        while count < k:\n            # k can be more than len(linkedlist)\n            if not quick.next:\n                list_len += 1\n                k = k % list_len\n                quick = head\n                count = 0\n                continue\n            quick = quick.next\n            list_len += 1\n            count += 1\n        while quick.next:\n            slow = slow.next\n            quick = quick.next\n            \n        # check if it's a full circle\n        if not slow.next: return head\n        \n        # now slow is the last node\n        new_head = slow.next\n        slow.next = None\n        quick.next = head\n        return new_head    \n```\n\n## Comp\n### T: O(N)\n### S: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921410120","body":"# 24. Swap Nodes in Pairs\n> [Click Me](https://leetcode.com/problems/swap-nodes-in-pairs/)\n## Algo\n1. should care 4 nodes: A.prev, A, B, B.next\n2. should have a sentinel\n\n## Code\n```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # should care 4 nodes: A.prev, A, B, B.next\n        # should have a sentinel\n        \n        # corner cases\n        if not head or not head.next: return head\n        \n        # prefix the first swap influence to res\n        res = ListNode(0, head.next)        \n        sentinel = ListNode(0, head)\n        \n        # iter\n        while sentinel.next and sentinel.next.next:\n            # set A, B, B.next\n            A = sentinel.next\n            B = sentinel.next.next\n            B_next = B.next\n            # A point B.next, B == A.next\n            A.next = B_next\n            # B point A\n            B.next = A\n            # A.prev point B\n            sentinel.next = B\n            # update sentinel\n            sentinel = A\n        \n        # return\n        return res.next\n```\n\n## Comp\n### T: O(N)\n### S: O(1)\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922325942","body":"# 109. Convert Sorted List to Binary Search Tree\n> [Click Me](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)\n## Algo\n1. find the mid point\n2. DO REMEMBER to cut the link before mid point for futher left leaves\n3. Save the val to a TreeNode\n4. DO REMEMBER to strike if there is only one LL node remains\n5. recur to get left & right of mid point\n6. DO REMEMBER to return !!!!!!!!!!!!!!\n\n## Code\n```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        \n        # corner cases\n        if not head: return head # O(1)\n        \n        # slow/quick pointer to find mid point\n        cut_here, slow, quick = None, head, head # O(1)\n        while quick and quick.next: # O(N) = O(n/2) + O(n/2) + n/2\n            cut_here = slow # 1\n            slow = slow.next # 1 -> n/2\n            quick = quick.next.next # 1 -> n/2\n        \n        # set root (bigger than left, smaller than right)\n        root = TreeNode(slow.val) # O(1)\n        \n        # strike if only one Node remains\n        if slow == quick: return root # O(1)\n        \n        # cut the link to get left tree\n        if cut_here: cut_here.next = None # O(1)\n            \n        # here, we got O(N) for time\n        \n        # set leaf\n        root.left = self.sortedListToBST(head) # O(n/2): almost n/2\n        root.right = self.sortedListToBST(slow.next) # O(n/2): almost n/2\n        \n        # for T: O(X), push to k, sum, times ops, log\n        \n        return root\n```\n\n## Comp\n### T: O(NlogN) = O(N) * O(logN)\n### S: O(logN) = O(1) * O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922484171","body":"# 160. Intersection of Two Linked Lists\r\n> [Click Me](https://leetcode.com/problems/intersection-of-two-linked-lists/submissions/)\r\n## Algo\r\n1. Double pointer\r\n2. **CAVEAT: \"a.next\" for judgement will lead to inf loop**\r\n\r\n## Code\r\n```py\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA            \r\n        return a\r\n```\r\n\r\n## Comp\r\n### T: O(N)\r\n### S: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916583583","body":"## 思路\n\n通过算盘模拟大数加法\n\n```js\n/**\n * @param {number[]} A\n * @param {number} K\n * @return {number[]}\n */\nvar addToArrayForm = function (A, K) {\n  // K 也转换为数组\n  K = K.toString().split('').map(v => +v)\n\n  // 保证A的长度 > K的长度\n  if (A.length < K.length) {\n    [A, K] = [K, A]\n  }\n\n  A.reverse()\n  K.reverse()\n\n\n  let carry = 0\n  for (let i = 0; i < A.length; i++) {\n    // A 长度大于 K, K[i] 可能越界\n    let b = K[i] === undefined ? 0 : K[i]\n    let curSum = A[i] + b + carry\n    A[i] = curSum % 10\n    carry = Math.floor(curSum / 10)\n  }\n\n  // 处理最后的进位\n  if (carry) {\n    A.push(carry)\n  }\n\n  return A.reverse()\n};\n```\n\n+ 时间复杂度: $O(max(n, m)), n 为数组A的长度, m 为数字K转字符后的长度\n+ 空间复杂度: $O(m)$, m 为数字K转字符后的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xj-yan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916584126","body":"# 思路\n从右向左遍历数组，并依次取k的最低位进行相加，如果结果大于10，则需要进位。\n\n# Java\n\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        boolean isCarried = false;\n        List<Integer> list = new ArrayList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0 || isCarried){\n            if (i >= 0 && k == 0 && !isCarried){\n                list.add(num[i]);\n                i--;\n                continue;\n            }\n            int val = (i >= 0 ? num[i--] : 0) + k % 10 + (isCarried ? 1 : 0);\n            if (val >= 10) {\n                val %= 10;\n                isCarried = true;\n            }else isCarried = false;\n            list.add(val);\n            k /= 10;\n            \n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n\n```\n\n# 复杂度分析\n\n时间复杂度：O(max(n, log k)),  n为数组长度\n空间复杂的：O(1) 如果不考虑输出结果占用的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917425010","body":"# IDEA (JAVA)\r\n\r\n1. 初始化输出数组里的所有元素为10001（根据题目给出的constraints）\r\n2. 如果该index对应的string里的character为c，则把输出数组里的该index对应的数值设为Integer.MAX_VALUE.\r\n3.  设置一个Integer变量prev, 初始值设为null，第一遍从左往右扫数组，如果prev不为null，且该index不为Integer.MAX_VALUE, 则更新输出数组的值为Math.abs(prev - index)， 如果该index为Integer.MAX_VALUE, 则更新prev的数值为当前index。\r\n4. 重新把prev设为null，再第二遍从右往左扫，如果prev不为null，且该index不为Integer.MAX_VALUE, 且Math.abs(prev - index)小于当前index的数值，则更新输出数组的值为Math.abs(prev - index)，如果该index为Integer.MAX_VALUE, 则更新prev的数值为当前index，且该index对应的元素值设为0。\r\n```java\r\n    class Solution {\r\n        public int[] shortestToChar(String s, char c) {\r\n            int[] result = new int[s.length()];\r\n            \r\n            Arrays.fill(result, 10001);\r\n            for (int i = 0; i < result.length; i++){\r\n                if (s.charAt(i) == c) result[i] = Integer.MAX_VALUE;\r\n            }\r\n            \r\n            Integer prev = null;\r\n            for (int i = 0; i < result.length; i++){\r\n                if (prev != null && result[i] != Integer.MAX_VALUE){\r\n                    result[i] = Math.abs(prev - i);\r\n                }else if (result[i] == Integer.MAX_VALUE) prev = i;\r\n            }\r\n            \r\n            prev = null;\r\n            for (int i = result.length - 1; i >= 0; i--){\r\n                if (prev != null && result[i] != Integer.MAX_VALUE){\r\n                    result[i] = Math.min(result[i], Math.abs(prev - i));\r\n                }else if (result[i] == Integer.MAX_VALUE){\r\n                    prev = i;\r\n                    result[i] = 0;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n```\r\n\r\n# 复杂度分析\r\nTime Complexity: O(n)\r\nSpace Complexity: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917659369","body":"  Using the array to implement the stack with increment operation.\n\n```java\nclass CustomStack {\n\n    private int[] array;\n    private int index, capacity;\n    \n    public CustomStack(int maxSize) {\n        array = new int[maxSize];\n        index = -1;\n        capacity = maxSize;\n    }\n    \n    public void push(int x) {\n        if (index == capacity - 1) return;\n        array[++index] = x;\n    }\n    \n    public int pop() {\n        if (index == -1) return -1;\n        return array[index--];\n    }\n    \n    public void increment(int k, int val) {\n        k = Math.min(k - 1, index);\n        for (int i = 0; i <= k; i++){\n            array[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\nTime Complexity: push - O(1), pop - O(1), increment - O(k)\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917778658","body":"# Code\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stack = new Stack<>();\n        Stack<Integer> numStack = new Stack<>();\n        \n        StringBuilder res = new StringBuilder();\n        int num = 0;\n        for (int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (Character.isDigit(c)){\n                num = num * 10 + c - '0';\n            }else if (c == '['){\n                numStack.push(num);\n                num = 0;\n                stack.push(res.toString());\n                res = new StringBuilder();\n            }else if(c == ']'){\n                StringBuilder tmp = new StringBuilder(stack.pop());\n                int rep = numStack.pop();\n                for (int k = 0; k < rep; k++){\n                    tmp.append(res);\n                }\n                res = tmp;\n            }else {\n                res.append(c);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n\nTime Complexity: O(n)\nSpace Complexity: O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918706304","body":"# IDEA (JAVA)\r\n\r\nUsing two stacks to monitor the queue, one is for output result and the other is to insert the pushed value.\r\n\r\n\r\n\r\n```java\r\nclass MyQueue {\r\n    private Stack<Integer> input, output;\r\n    \r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        input = new Stack<>();\r\n        output = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        input.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        peek();\r\n        return output.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (output.isEmpty()){\r\n            while (!input.isEmpty()){\r\n                output.push(input.pop());\r\n            }\r\n        }\r\n        return output.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return input.isEmpty() && output.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\nTime Complexity: push - O(n), pop/ peek - Amortized O(1)\r\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920137524","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        if (arr.length == 1) return 1;\r\n        Stack<Integer> stack = new Stack<>();\r\n        for (int i = 0; i < arr.length; i++){\r\n            // 如果arr[i]比栈顶小，说明arr[i]一定要和前面的元素融合，融合到没有栈元素比arr[i]大为止\r\n            if (!stack.isEmpty() && stack.peek() > arr[i]){\r\n                int max = stack.peek(); // 当前栈顶一定是前面所有块的最大值\r\n                while (!stack.isEmpty() && arr[i] < stack.peek()){\r\n                    stack.pop();\r\n                }\r\n                // 把原栈顶放回去\r\n                stack.push(max);\r\n            } else stack.push(arr[i]);\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920165005","body":"1. Calculate the length of the Linked List.\n2. Use two pointers to find out the node where should do the rotation.\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) return head;\n        int len = getLen(head);\n        k = k % len;\n        if (k == 0) return head;\n        ListNode dummy = new ListNode(0, head), slow = dummy, fast = dummy;\n        while (k > 0){\n            fast = fast.next;\n            k--;\n        }\n        while (fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        ListNode nextPart = slow.next;\n        slow.next = null;\n        fast.next = dummy.next;\n        dummy.next = nextPart;\n        return dummy.next;\n    }\n    \n    private int getLen(ListNode head){\n        ListNode curt = head;\n        int len = 0;\n        \n        while (curt != null){\n            len++;\n            curt = curt.next;\n        }\n        return len;\n    }\n}\n```\nTime Complexity: O(n)\nSpace Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921383436","body":"Generalized method to swap k nodes in pairs\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        ListNode dummy = new ListNode(0, head), pointer = dummy;\n        \n        while (pointer != null){\n            ListNode node = pointer;\n            for (int i = 0; i < 2 && node != null; i++){\n                node = node.next;\n            }\n            if (node == null) break;\n            ListNode prev = null, curt = pointer.next, next = null;\n            for (int i = 0; i < 2; i++){\n                next = curt.next;\n                curt.next = prev;\n                prev = curt;\n                curt = next;\n            }\n            \n            ListNode tail = pointer.next;\n            tail.next = curt;\n            pointer.next = prev;\n            pointer = tail;\n        }\n        \n        return dummy.next;\n    }\n}\n```\n\nTime Complexity: O(n), Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922031126","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) return null;\r\n        List<Integer> list = convertNodeToList(head);\r\n        return buildBST(list, 0, list.size() - 1);\r\n    }\r\n    \r\n    private List<Integer> convertNodeToList(ListNode head){\r\n        ListNode curt = head;\r\n        List<Integer> list = new ArrayList<>();\r\n        while (curt != null){\r\n            list.add(curt.val);\r\n            curt = curt.next;\r\n        }\r\n        return list;\r\n    }\r\n    \r\n    private TreeNode buildBST(List<Integer> list, int left, int right){\r\n        if (left > right) return null;\r\n        if (left == right) return new TreeNode(list.get(left));\r\n        \r\n        int mid = (right - left) / 2 + left;\r\n        TreeNode root = new TreeNode(list.get(mid));\r\n        root.left = buildBST(list, left, mid - 1);\r\n        root.right = buildBST(list, mid + 1, right);\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\nTime Complexity: O(n) Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922368949","body":"```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode curtA = headA, curtB = headB;\r\n        while (curtA != curtB){\r\n            curtA = curtA == null ? headB : curtA.next;\r\n            curtB = curtB == null ? headA : curtB.next;\r\n        }\r\n        return curtA;\r\n    }\r\n}\r\n```\r\n\r\nTime Complexity: O(n), Space Complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ychen8777":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916584445","body":"### 思路\n一开始看到 1 <= num.length <= 10^4 ，理解成 num 所代表的数最大为 10^4，就用了把 num 转成整数，加上 k, 再转回 arrayform 的方法，结果 num 很长的test case应该是出现overflow了\n而实际上 k 才是最大值比较小的参数，于是，从个位开始一位一位加，形成 arraylist，再反转\n\n### Java\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        \n        List<Integer> arrayForm = new ArrayList<>();\n        \n        int p = num.length - 1;\n        while (p >= 0 || k > 0) {\n            if (p >= 0) {\n                k += num[p];\n            }\n            \n            arrayForm.add(k % 10);\n            k = k / 10;\n            p--;\n        }\n        \n        Collections.reverse(arrayForm);\n        return arrayForm;\n   }\n}\n```\n### 复杂度\ntime: O(max(num的长度，k的位数))\nspace: O(max(num的长度，k的位数))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917329843","body":"### 思路\n由左向右遍历，记录 c 在 S[i] 左边时的最小距离 \\\n由右向左遍历，记录 S[i] 与 C 的最小距离 (C可能在左，也可能在右）\n\n###代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] result = new int[n];\n        int prev = Integer.MIN_VALUE / 2;\n        \n        // calculate distance from left\n        for (int i = 0; i < n; i ++) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            result[i] = i - prev;\n        }\n        \n        // calculate min distance\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = n - 1; i >= 0; i --) {\n            if (s.charAt(i) == c){\n                prev = i;\n            }\n            result[i] = Math.min(result[i], prev - i);\n        }\n        \n        return result;\n    }\n}\n```\n###复杂度\n时间、空间: O(S.length())","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917515934","body":"### 思路\n用 int[] 模拟stack \\\npush 时要检查有没有剩余空间 \\\npop 时要检查stack是否为空 \\\nincrement 时要注意 k 和 现有数量\n\n### 代码\n```java\nclass CustomStack {\n    private int[] stack;\n    private int top;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.top = -1;\n        \n    }\n    \n    public void push(int x) {\n        if (top < stack.length - 1 ) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top >= 0) {\n            int result = stack[top];\n            top--;\n            return result;\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top+1);\n        for (int i = 0; i < limit; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n### 复杂度\n时间: push, pop O(1), increment O(k) \\\n空间: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918307224","body":"### 思路\n没注意到第2个 testcase 有嵌套，只考虑了没有嵌套的情况  \\\n用 res, curString, curMultiplier 分别记录遍历到 s[i] 时的 最后结果，当前substring，以及当前substring需要重复的次数 \\\n逢 '[' 记录multiplier \\\n逢 ']' 将 curString 乘以倍数后append到 res，重置  curString, curMultiplier \\\n\n### 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        \n        if (\"\".equals(s)) {\n            return \"\";\n        }\n        \n        StringBuilder res = new StringBuilder(\"\");\n        StringBuilder curString = new StringBuilder(\"\");\n        StringBuilder curMultiplier = new StringBuilder(\"0\");\n        boolean isNumber = true;\n        int multiplier = 0;\n        \n        for (int i = 0; i < s.length(); i++) {\n            \n            char curChar = s.charAt(i);\n            //System.out.println(\"isNumber: \" + isNumber);\n            \n            \n            if (curChar == '[') {\n                multiplier = Integer.parseInt(curMultiplier.toString());\n                // curMultiplier = new StringBuilder(\"0\");\n                //System.out.println(\"multiplier: \" + curMultiplier + \", \" + multiplier);\n                isNumber = false;\n                continue;\n            }\n            \n            if (curChar == ']') {\n                res.append(multiplyString(multiplier, curString.toString()));\n                isNumber = true;\n                //System.out.println(\"curString: \" + curString.toString());\n                curMultiplier = new StringBuilder(\"0\");\n                curString = new StringBuilder(\"\");\n                continue;\n            }\n            \n            if (isNumber) {\n                curMultiplier.append(curChar);\n                //System.out.println(\"multiplier in isNumber: \" + curMultiplier);\n                continue;\n            } else {\n                curString.append(curChar);\n                continue;\n            }                   \n        }\n        \n        return res.toString();\n        \n        \n    }\n    \n    private String multiplyString(int num, String s) {\n        StringBuilder res = new StringBuilder(\"\");\n        \n        for (int i = 1; i <= num; i++) {\n            res.append(s);\n        }\n        \n        return res.toString();\n    }\n}\n```\n\n### 复杂度\n时间: O(n) \\\n空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919187559","body":"### 思路\n双栈 \\\n两次 LIFO 操作模拟出 FIFO\n\n### 代码\n```java\nclass MyQueue {\n    \n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n    private int front;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        this.stack1 = new Stack<>();\n        this.stack2 = new Stack<>();\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        if (stack1.isEmpty()) {\n            front = x;\n        }\n        \n        // move items from stack1 to stack2\n        while(!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        \n        // add x to stack2\n        stack2.push(x);\n        \n        // move items back to stack1\n        while(!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        \n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        \n        int res = stack1.pop();\n        \n        if (!stack1.isEmpty()) {\n            this.front = stack1.peek();\n        }\n        \n        return res;\n        \n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        return this.front;\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n\n### 复杂度\n时间: O(1), except for push, O(n) \\\n空间: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920536216","body":"### 思路\n无脑右移k次 -> Time Limit Exceeded \\\n优化： k % l == 0, 链表不变； 只需右移 k % l 次\n\n### 代码\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        \n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        \n        // get the length of list\n        int l = 1;\n        ListNode curNode = head;\n        while (curNode.next != null) {\n            l++;\n            curNode = curNode.next;\n        }\n        \n        if (k % l == 0) {\n            return head;\n        }\n        \n        k = k % l;\n        \n        ListNode res = head;\n        for (int i = 1; i <= k; i++) {\n            res = rotateOnce(res);\n        }\n        \n        return res;\n        \n    }\n    \n    \n    private ListNode rotateOnce(ListNode head) {\n        \n        ListNode dummyHead = new ListNode(0, head);\n        ListNode curNode = head;\n        \n        while(curNode.next.next != null) {\n            curNode = curNode.next;\n        }\n        \n        /*\n        \n        dummy -> head -> head.next -> head.next.next -> null\n        \n        */\n        \n        curNode.next.next = head;\n        dummyHead.next = curNode.next;\n        curNode.next = null;        \n        \n        return dummyHead.next;\n    }\n    \n}\n```\n\n### 复杂度\n时间: O(n) \\\n空间: O(1) ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922175459","body":"### 思路\n想到了找到中点，然后左右递归 \\\n没想到 快慢指针\n### 代码\n```java\n\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n    \n    private TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        \n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        \n        return root;\n    }\n    \n    \n    private ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        \n        return slow;\n    }   \n    \n}\n```\n### 复杂度\n时间：O(nlogn) \\\n空间：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922402548","body":"### 思路\n分别遍历两个链表获取长度，移动标记在长链表的指针，使其到长链表末尾的长度和短链表整体长度一致，两个指针分别遍历两个链表，两个指针指向的ListNode相同时，return 该ListNode\n\n### 代码\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        \n        int lengthA = getLength(headA);\n        int lengthB = getLength(headB);\n        \n        ListNode curA = headA;\n        ListNode curB = headB;\n        \n        while (lengthA > lengthB && curA != null) {\n            lengthA--;\n            curA = curA.next;\n        }\n        \n        while (lengthB > lengthA && curB != null) {\n            lengthB--;\n            curB = curB.next;\n        }\n        \n        while(curA != null && curB != null) {\n            if (curA == curB) {\n                return curA;\n            }\n            curA = curA.next;\n            curB = curB.next;\n        }\n        \n        return null;\n        \n    }\n    \n    public int getLength(ListNode head) {\n        if (head == null) {\n            return 0;\n        }\n        \n        int length = 1;\n        ListNode cur = head;\n        \n        while(cur.next != null) {\n            length++;\n            cur = cur.next;\n        }\n        \n        return length;\n            \n    }\n    \n}\n```\n### 复杂度\n时间: O(m+n) \\\n空间: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"L-SUI":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916585903","body":"思路：字符串相加，大位数相加，从后往前算\r\njs\r\n\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917881881","body":"/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let stack = []; // 保存需要 repeat 的字符串\r\n    let times = ''; // 乘以的倍数\r\n\r\n    for (let i = 0, len = s.length; i < len; i++) {\r\n        let item = s[i];\r\n\r\n        if (/[0-9]/.test(item)) {\r\n            if (i === 0 || /[0-9]/.test(s[i - 1])) {\r\n                times += item;\r\n            } else {\r\n                times = item\r\n            }\r\n        } else if (item === '[') {\r\n            times && stack.push(Number(times));\r\n            times = '';\r\n        } else if (item === ']') {\r\n            var curr = stack.pop();\r\n            var temp = '';\r\n            while (typeof curr !== 'number') {\r\n                temp = curr + temp;\r\n                curr = stack.pop();\r\n            }\r\n            temp = temp.repeat(curr);\r\n            stack.push(temp);\r\n        } else {\r\n            stack.push(item);\r\n        }\r\n    }\r\n    return stack.join('');\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918837496","body":"var MyQueue = function() {\r\n    this.inStack = [];\r\n    this.outStack = [];\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n    return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\nMyQueue.prototype.in2out = function() {\r\n    while (this.inStack.length) {\r\n        this.outStack.push(this.inStack.pop());\r\n    }\r\n}\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920715670","body":"var rotateRight = function(head, k) {\r\n    if (k === 0 || !head || !head.next) {\r\n        return head;\r\n    }\r\n    let n = 1;\r\n    let cur = head;\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        n++;\r\n    }\r\n\r\n    let add = n - k % n;\r\n    if (add === n) {\r\n        return head;\r\n    }\r\n\r\n    cur.next = head;\r\n    while (add) {\r\n        cur = cur.next;\r\n        add--;\r\n    }\r\n\r\n    const ret = cur.next;\r\n    cur.next = null;\r\n    return ret;\r\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922236314","body":"const sortedListToBST = (head) => {\r\n  if (head == null) return null;\r\n  let len = 0;\r\n  let h = head;  // h初始指向头结点\r\n  while (head) { // 计算链表节点个数\r\n    len++;\r\n    head = head.next;\r\n  }\r\n\r\n  const buildBST = (start, end) => {\r\n    if (start > end) return null;     // 递归出口，返回null节点\r\n    const mid = (start + end) >>> 1;  // 求mid，只是为了分治，不是用它断开链表\r\n    const left = buildBST(start, mid - 1); // 先递归构建左子树\r\n\r\n    const root = new TreeNode(h.val);      // 根据 h.val 构建节点\r\n    h = h.next;          // h指针步进              \r\n    root.left = left;    // root接上构建好的左子树        \r\n\r\n    root.right = buildBST(mid + 1, end); // 构建当前root的右子树，接上\r\n    return root;\r\n  };\r\n\r\n  return buildBST(0, len - 1);\r\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922490244","body":"var detectCycle = function(head) {\r\n    if (head === null) {\r\n        return null;\r\n    }\r\n    let slow = head, fast = head;\r\n    while (fast !== null) {\r\n        slow = slow.next;\r\n        if (fast.next !== null) {\r\n            fast = fast.next.next;\r\n        } else {\r\n            return null;\r\n        }\r\n        if (fast === slow) {\r\n            let ptr = head;\r\n            while (ptr !== slow) {\r\n                ptr = ptr.next;\r\n                slow = slow.next;\r\n            }\r\n            return ptr;\r\n        }\r\n    }\r\n    return null;\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilixikun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916586596","body":"## 思路如下\n数组从末尾、数字从个位开始依次累加、最好记得要注意头是否是 1\n## 代码如下\n```js\n  let len = num.length,\n    add = 0,\n    res = [];\n  while (len >= 0 || k > 0) {\n    const num1 = k % 10 || 0;\n    const num2 = num.length ? num.pop() : 0;\n    let sum = num1 + num2 + add;\n    if (sum > 9) {\n      sum %= 10;\n      add = 1;\n    } else add = 0;\n    res.unshift(sum);\n    len--;\n    k = parseInt(k / 10);\n  }\n  if (add) res.unshift(add);\n  return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917550590","body":"## 从左到右、再从右到左扫描、然后更新 index 的位置\n```js\n const maxLen = s.length;\n  const dist = new Array(s.length).fill(maxLen);\n\n  let index = null;\n  for (let i = 0; i < maxLen; i++) {\n    // 顺序扫一遍，计算出 `C` 右侧的字符 `S[i]` 距离 R\n    minDistance(i);\n  }\n\n  index = null;\n  for (let j = maxLen - 1; j >= 0; j--) {\n    // 逆序扫一遍，计算出 `C` 左侧的字符 `S[i]` 距离 L\n    minDistance(j);\n  }\n  \n  function minDistance(i) {\n    if (s[i] === c) {\n      index = i;\n    }\n\n    dist[i] = Math.min(\n      dist[i],\n      // 没有找到 C 之前，都用一个大数补位\n      index === null ? maxLen : Math.abs(i - index)\n    );\n  }\n\n  return dist;\n```\n\n## 复杂度\n- 空间复杂度：O（n）\n- 时间复杂度：O（n）","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917565276","body":"## 用JS数组来实现自定义栈类\n\n```js\nvar CustomStack = function(maxSize) {\n    this.size = 0;\n    this.list = [];\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.size<this.maxSize){\n        this.list.push(x)\n        this.size++\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.size==0) return -1\n    const num = this.list.pop();\n    this.size--\n    return num\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=0;i<k&&i<this.size;i++){\n        this.list[i]+=val\n    }\n};\n\n```\n## 复杂度\n- 时间复杂度： push、pop、increment 都是 O（1）\n- 空间复杂度：开辟了数组、O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917963774","body":"## 思路\n使用双栈来解决、一个用来储存复制多少次、一个用来储存当前需要复制的 字符串\n\n## 代码\n```js\n    const numStack =[];\n    const strStack =[];\n    let resStr = \"\",num=\"\"\n    for(let str of s){\n        if(!isNaN(str))num+=str。//处理 100a 这种情况\n        // 这个地方是关键、先➕入需要复制的字符串\n        else if(str===\"[\"){\n            strStack.push(resStr)\n            numStack.push(num)\n            resStr=''\n            num=\"\"\n        }\n        else if(str===\"]\"){\n            resStr=strStack.pop()+resStr.repeat(numStack.pop())\n        }else resStr+=str\n    }\n    return resStr\n```\n## 复杂度\n- 空间复杂度：O（n）\n- 时间复杂度：O（n）？","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918737680","body":"## 思路\r\n用一个栈来回倒折数据就行了\r\n## 代码\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack1=[];\r\n    this.stack2=[]\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n   while(this.stack1.length){\r\n       this.stack2.push(this.stack1.pop())\r\n   }\r\n   const res = this.stack2.pop();\r\n   while(this.stack2.length){\r\n       this.stack1.push(this.stack2.pop())\r\n   }\r\n   return res\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack1[0]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.stack1.length\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920636604","body":"# 思路\r\n- 首先计算链表长度、对k进行取余、避免不必要的多次计算。\r\n- 形成环、然后迭代 len - k -1。注意为什么要多 -1、因此我们需要记住前面的部分、然后再断开\r\n- 断开环、返回旋转后的\r\n# 代码\r\n```js\r\n  if (!head) return\r\n  let count = 1, prev = head\r\n  while (prev.next) {\r\n    count++\r\n    prev = prev.next\r\n  }\r\n  // 取余\r\n  k = k % count;\r\n  // 尾部接到头部\r\n  prev.next=head\r\n  let current = head\r\n  while (count-k-1) {\r\n    current=current.next\r\n    count--\r\n  }\r\n  let head2 = current.next;\r\n  current.next=null\r\n  return head2\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921416461","body":"## 思路\n定义虚拟节点、然后 两两节点分别交换\n## 代码\n```js\nvar swapPairs = function (head) {\n  const newHeader = new ListNode(null, head);\n  let cur = newHeader;\n  while (cur.next && cur.next.next) {\n    const one = cur.next;\n    const two = cur.next.next;\n    cur.next = two;\n    one.next = two.next;\n    two.next = one;\n    cur = one;\n  }\n  return newHeader.next;\n};\n```\n## 复杂度\n- 时间复杂度：O（n）\n- 空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922169399","body":"## 思路\n看到这题首先想法就是递归、遇到树类型递归解决起来是最简单也是最好理解的，但是运行过程不怎么好理解。\n题目要求升序排序的单链表构造成高度平衡的二叉搜索树。二叉搜索树的特点是左边比右边小。\n因此我们会想到二分、从中间切开、左边就是左子树、右边同理、然后依次递归执行。那么问题来了、链表我们不能只能拿到中间 mid、节点。但是我们可以使用 快慢指针来拿到 中间节点。\n需要注意的是，在拿到中间节点的时候我们也要保留前一个节点，再断开，那么就下一次递归时候用来当 \"left\"、而右节点就是 慢指针的下一个节点\n## 代码\n```js\nfunction sortedListToBST(head) {\n  function bfs(head) {\n    if (head == null) return null\n    if (head.next == null) return new TreeNode(head.val)\n    let fast = head;\n    let slow = head;\n    let prev = null; // 记录 mid 前面的一个\n    while (fast && fast.next) {\n      prev = slow\n      fast = fast.next.next\n      slow = slow.next\n    }\n    // 断开\n    prev.next = null\n    const node = new TreeNode(slow.val)\n    node.left = bfs(head)\n    node.right = bfs(slow.next)\n    return node\n  }\n  return bfs(head)\n}\n```\n##复杂度\n- 空间复杂度：O（h）\n- 时间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922398258","body":"# 思路\r\n- 方法一：用Hash表做标记、这里不多说\r\n- 方法二：双指针、两个链表首尾连着、如果有相交一定会相遇\r\n# 代码\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let p1 = headA,p2 = headB\r\n    while(p1!=p2){\r\n        p1=p1?p1.next:headB\r\n        p2=p2?p2.next:headA\r\n    }\r\n    return p1\r\n};\r\n``\r\n# 复杂度\r\n- 时间复杂度：O（m+n）\r\n- 空间复杂福：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Zhang6260":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916586641","body":"## JAVA版本\n\n## 思路：\n\n从数组的最后一位，当然数组的数+进位数，余数就是当前该位置的数，除以10的商便是进位数。（最后遍历完数组还有判断，进位数是否为0的情况，例如为:arr【9,9,9,9】，K为1的情况）\n\n## 代码\n\n> ```\n>    public static int[]fun(int[]arr,int K){\n>    LinkedList<Integer> list=new LinkedList<>();\n>     for(int i=arr.length-1;i>=0;i--){\n>         int temp=arr[i]+K;\n>         if(temp>=10){\n>\n>             list.add(0,temp%10);\n>             K=temp/10;\n>         }else {\n>             list.add(0,temp);\n>             K=0;\n>         }\n>     }\n>     while (K>0){\n>         list.add(K%10);\n>         K=K/10;\n>     }\n>     int[]res=new int[list.size()];\n>     for(int i=0;i<list.size();i++){\n>         res[i]=list.get(i);\n>     }\n>\n>     return  res;\n> }\n> ```\n\n__时间复杂度__：O(N)\n\n__空间复杂度__：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917323419","body":"## JAVA版本\n\n## 思路：\n\n分二次遍历数组，从头到的方式进行遍历，找距离每个位置上到该位置最近的左边C的的距离并记录到数组，同理从右到左的方式，找距离每个位置最右边的距离并记录到数组，最后再进行一次遍历，取每次取左右遍历的最小值。\n\n> ```\n> package Ti_911;\n>\n> public class ti_911_2 {\n>     public static void main(String[] args) {\n>         String S=\"loveleetcode\";\n>         char c='e';\n>         int []arr_a=new int[S.length()];\n>         int []arr_b=new int[S.length()];\n>         int count=0;\n>         int isfage=1;\n>         for(int i=0;i<arr_a.length;i++){\n>             if(isfage==1&&S.charAt(i)!=c){\n>                 arr_a[i]=Integer.MAX_VALUE;\n>             }else if(S.charAt(i)==c){\n>                 isfage=0;\n>                 arr_a[i]=0;\n>                 count=0;\n>             }else {\n>                 count++;\n>                 arr_a[i]=count;\n>             }\n>         }\n>         isfage=1;\n>         for(int i=arr_a.length-1;i>=0;i--){\n>             if(isfage==1&&S.charAt(i)!=c){\n>                 arr_b[i]=Integer.MAX_VALUE;\n>             }else if(S.charAt(i)==c){\n>                 isfage=0;\n>                 arr_b[i]=0;\n>                 count=0;\n>             }else {\n>                 count++;\n>                 arr_b[i]=count;\n>             }\n>         }\n>         int []res=new int[S.length()];\n>         for(int i=0;i<arr_a.length;i++){\n>             res[i]=Math.min(arr_a[i],arr_b[i]);\n>             System.out.print(res[i]+\" \");\n>         }\n>     }\n> }\n>\n> ```\n\n__时间复杂度__：O(N)\n\n__空间复杂度__：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917579134","body":"## JAVA版本\n\n## 思路：\n\n用一个数组+一个指针来完成。数组进行实际的存储，入栈则存入数据，并把指针+1，出栈就反之。注意：入栈的时候，需要对是否达到最大存储进行判断，出栈需要对栈是否为空进行判断。\n\n> ```\n> class CustomStack {\n>     int arr[];//用来实际进行存储\n>     int Max_length;  //最大的长度\n>     int index; //当前的位置\n>     public CustomStack(int maxSize) {\n>         arr=new int[maxSize];\n>         Max_length=maxSize;\n>         index=0;\n>     }\n>     public void push(int x) {\n>         if(index<Max_length){\n>             arr[index++]=x;\n>         }\n>     }\n>     public int pop() {\n>         if(index>0){\n>              index=index-1;\n>             return arr[index];\n>         }\n>         return -1;\n>     }\n>     public void increment(int k, int val) {\n>         for(int i=0;i<k;i++){\n>             if(i<index){\n>                 arr[i]+=val;\n>             }\n>         }\n>     }\n> }\n>\n> ```\n\n__时间复杂度__：O(1)\n\n__空间复杂度__：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918169222","body":"## JAVA版本\n\n## 思路：\n\n定义一栈来存储计算，当前字符不为 ‘】‘就直接存入到栈中，当前的字符为’]‘的时候，则就是要出栈的时候，直到栈顶为’[’，然后将‘[’出栈，再判断栈顶是否为数字（注意存在的数字可能是二位数一样），再通过所得的字符转，算出字符串并进行入栈，再取下一位字符进行判断，重复以上的操作。\n\n> ```\n> class Solution {\n>     public String decodeString(String s) {\n>         int n=s.length();\n>         int i=0;\n>         Stack<String> stack=new Stack<String>();\n>         while(i<n){\n>             char temp=s.charAt(i);\n>             if(temp!=']'){\n>                 stack.push(temp+\"\");\n>             }else{\n>                 String temp_string = \"\";\n>                 String temp_string2= \"\";\n>                 int  count=0;\n>                 while(fun(stack.peek())){    //取到栈顶为【为止\n>                     temp_string=stack.pop()+temp_string;\n>                 }\n>                 stack.pop();//[出栈\n>                 double  num=0.0;\n>                 while(!stack.isEmpty()){   //继续从栈中取 直到栈顶不为数字为止\n>                     if(Character.isDigit(stack.peek().charAt(0))){\n>                         count=Integer.parseInt(stack.peek())*(int)Math.pow(10.0,num)+count;\n>                         num++;\n>                     }else{\n>                         break;\n>                     }\n>                     stack.pop();\n>                 }\n>                 while (count>0){\n>                     temp_string2 += temp_string;\n>                     count--;\n>                 }\n>                 stack.push(temp_string2);\n>             }\n>             i++;\n>         }\n>         String res=\"\";\n>         while (!stack.isEmpty()){\n>            res=stack.pop()+res;\n>         }\n>         return res;\n>     }\n>     public  boolean fun(String s){\n>             if(s.length()>1)return true;\n>             if(s.equals(\"[\"))return false;\n>\n>             return true;\n>         }\n> }\n> ```\n\n__时间复杂度__：（有点分析不来。。。）\n\n__空间复杂度__：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919197287","body":"思路\n使用二个栈来完成的。\n\n代码：\nclass MyQueue {\n\n    /** Initialize your data structure here. */\n    Stack<Integer> stack_num;\n    Stack<Integer> stack_num2;\n    public MyQueue() {\n        stack_num=new Stack<Integer>();\n        stack_num2=new Stack<Integer>();\n\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        stack_num.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        int temp=-1;\n        if(stack_num2.isEmpty()){\n            while(!stack_num.isEmpty()){\n                stack_num2.push(stack_num.pop());\n            }\n            temp=stack_num2.pop();\n\n        }else{\n            temp=stack_num2.pop();\n        }\n        return temp;\n    }\n    /** Get the front element. */\n    public int peek() {\n        int temp=-1;\n        if(stack_num2.isEmpty()){\n            while(!stack_num.isEmpty()){\n                stack_num2.push(stack_num.pop());\n            }\n             temp=stack_num2.peek();\n        }else{\n            temp=stack_num2.peek();\n        }\n        return temp;\n    }\n  \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        boolean falge=false;\n        if(stack_num.isEmpty()&&stack_num2.isEmpty())\n        {\n            falge=true;\n        }\n        return falge;\n    }\n}\n时间复杂度: O(1)\n空间复杂度：O(n)\n(今天有点赶，就这样吧，明天调一下格式)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919840146","body":"## JAVA版本\n\n## 思路：\n\n先将原来的数组进行排序，然后再与之前的数字进行比较，数字的位置没有发现改变，则说明可以对当前位置进行分块，（对数字进行排序偷了个懒，直接调用了APi）\n\n> ```\n> class Solution {\n>     public int maxChunksToSorted(int[] arr) {\n>         int []sord=arr.clone();\n>         Arrays.sort(sord);\n>         int sum_a=0;\n>         int sum_b=0;\n>         int sum=0;\n>         for(int i=0;i<arr.length;i++){\n>             sum_a+=arr[i];\n>             sum_b+=sord[i];\n>             if(sum_a==sum_b){\n>                 sum+=1;\n>             }\n>         }\n>         return sum;\n>     }\n> }\n> ```\n\n__时间复杂度__：O(Nlogn)\n\n__空间复杂度__：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920558415","body":"## JAVA版本\n\n## 思路：\n\n使用快慢指针，快指针先移动k，然后快、慢指针再一起移动，直到快指针指导末尾，然后此时慢指针右边的处理到左边去。\n\n> ```\n> class Solution {\n>     public ListNode rotateRight(ListNode head, int k) {\n>         if(head == null || head.next == null) return head;\n>         int count = 0;\n>         ListNode now = head;\n>         while(now != null){\n>         now = now.next;\n>         count++;\n>         }\n>         k = k % count;\n>         ListNode slow = head, fast = head;\n>         while(fast.next != null){\n>             if(k-- <= 0){\n>                 slow = slow.next;\n>             }\n>             fast = fast.next;\n>         }\n>         fast.next = head;\n>         ListNode res = slow.next;\n>         slow.next = null;\n>         return res;\n>     }\n> }\n> ```\n\n__时间复杂度__：O(N)\n\n__空间复杂度__：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921902602","body":"JAVA版本\n\n思路：临时保存好当前节点、下一个节点和下一个节点的下一个节点，再进行“穿针引线”即可。\n\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n\n        ListNode res=new ListNode(-1);\n        res.next=head;\n        if(res.next==null||res.next.next==null)return res.next;\n        //确保有两个的交换结点\n        ListNode cur=res;\n        while(cur.next!=null&&cur.next.next!=null){\n            ListNode end=cur.next.next.next;\n            ListNode first=cur.next;\n            ListNode scengd=cur.next.next;\n            cur.next=scengd;\n            scengd.next=first;\n            first.next=end;\n            cur=first;\n        }\n        return res.next;\n    }\n}\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922306702","body":"JAVA版本\n思路：使用递归的思想。\n\n\n>class Solution {\n>\n>  public TreeNode sortedListToBST(ListNode head) {\n>\n>​    if(head==null)return null;\n>\n>​    return fun(head,null);\n>\n>  }\n>\n>  private TreeNode fun(ListNode node,ListNode tail){\n>\n>​    if(node==tail)return null;\n>\n>​    ListNode first=node,slow=node;\n>\n>​    while(first!=tail&&first.next!=tail){\n>\n>​      first=first.next.next;\n>\n>​      slow=slow.next;\n>\n>​    }\n>\n>​    TreeNode root =new TreeNode(slow.val);\n>\n>​    root.left=fun(node,slow);\n>\n>​    root.right=fun(slow.next,tail);\n>\n>​    return root;\n>\n>  }\n>\n>}\n\n### 时间复杂度：O(nlogn) \n\n### 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922429304","body":"## JAVA版本\n\n## 思路：\n\n方法一：使用额外的空间(Hash)来存储其中的一个链表，然后再遍历另一个遍历。\n\n方法二：使用双指针，原理：A和B链表如果相较于c(A在c点前后的长度为a,b.B在c点前后的长度为c，b),那么\n\n​\t\ta+b+c=c+b+a;就是二个指针再遍历完本链表后，再重新指向另一个链表。\n\n> ```java\n> public class Solution {\n>     public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n>         ListNode a=headA,b=headB;\n>         while(a!=b){\n>             if(a==null)a=headB;\n>             else a=a.next;\n>             if(b==null)b=headA;\n>             else b=b.next;\n>         }\n>         return a;\n>     }\n> }\n> ```\n\n__时间复杂度__：O(N)\n\n__空间复杂度__：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JK1452470209":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916587656","body":"**思路**\r\n从个位往后相加(处理进位情况)并存进list中，最后将list反转\r\n**Java**\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ret = new ArrayList<Integer>();\r\n        for (int i = num.length - 1; i >= 0; i--){\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10){\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            ret.add(sum);\r\n        }\r\n        //k>num.length情况\r\n        for (;k > 0;k /= 10){\r\n            ret.add(k % 10);\r\n        }\r\n        Collections.reverse(ret);\r\n        return ret;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度 :O(max(num.length,k))\r\n\r\n- 空间复杂度 :O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917357526","body":"思路\r\n\r\n常规思路将字符串转为char数组然后对其遍历，遇到指定字符则填充0，没有遇到则开启双指针对其扫描\r\n\r\n代码\r\n\r\n    class Solution {\r\n        public int[] shortestToChar(String s, char c) {\r\n            char[] chars = s.toCharArray();\r\n            int[] ints = new int[s.length()];\r\n            for (int i = 0; i < chars.length; i++) {\r\n                int index1 = 0,index2 = 0;\r\n                boolean flag1 = false,flag2 = false;\r\n                if (chars[i] == c){\r\n                    ints[i] = 0;\r\n                }else {\r\n                    //往前找\r\n                    for (int j = i - 1; j >= 0; j--) {\r\n                        index1++;\r\n                        if (chars[j] == c){\r\n                            flag1 = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    //往后找\r\n                    for (int j = i + 1; j < chars.length; j++) {\r\n                        index2++;\r\n                        if (chars[j] == c){\r\n                            flag2 = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (flag1 && flag2){\r\n                        ints[i] = Math.min(index1,index2);\r\n                        continue;\r\n                    }\r\n                    if (flag1){\r\n                        ints[i] = index1;\r\n                    }\r\n                    if (flag2){\r\n                        ints[i] = index2;\r\n                    }\r\n                }\r\n            }\r\n            return ints;\r\n        }\r\n    }\r\n\r\n复杂度\r\n\r\n时间复杂度：O(N) 对数组扫描俩遍\r\n\r\n空间复杂度：O(N) 使用俩个数组\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917545006","body":"思路\r\n\r\n要满足inc方法的需求，需要借助数组这种有下标的进行操作，进而可以想到用数组实现简易版栈的功能\r\n\r\n代码\r\n\r\n    class CustomStack {\r\n    \r\n        private int[] arr;\r\n        private int index;\r\n        public CustomStack(int maxSize) {\r\n            this.arr = new int[maxSize];\r\n        }\r\n    \r\n        public void push(int x) {\r\n            if (this.arr.length > index){\r\n                arr[index++] = x;\r\n            }\r\n        }\r\n    \r\n        public int pop() {\r\n            if (index != 0){\r\n                return arr[--index];\r\n            }else {\r\n                return -1;\r\n            }\r\n        }\r\n    \r\n        public void increment(int k, int val) {\r\n            if (index >= k){\r\n                for (int i = 0; i < k; i++) {\r\n                    arr[i] = arr[i] + val;\r\n                }\r\n            }else {\r\n                for (int i = 0; i < arr.length; i++) {\r\n                    arr[i] = arr[i] + val;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n复杂度\r\n\r\n时间复杂度：inc方法为O(k） 其他为O(1)\r\n\r\n空间复杂度：O(maxSize)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917811022","body":"**思路**\n\n使用字符栈与数字栈，遇到 **[** 就进栈 遇到 **]** 就出栈，出栈时将字符栈，数字栈同时出栈并运算。还需要考虑数字的进位问题 ret变量缓存着从栈底弹出字符串总和，并且有将字符串压入栈底的作用\n\n**代码**\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stacks = new Stack<>();\n        Stack<Integer> nums = new Stack<>();\n        String ret = \"\";\n        int num = 0;\n        for (char c : s.toCharArray()){\n            if ('0' <= c && c <= '9'){\n                num=num*10+c-'0';\n            }else if('a' <= c && c <= 'z'){\n                ret += c;\n            }else if (c == '['){\n                stacks.push(ret);\n                nums.push(num);\n                ret = \"\";\n                num = 0;\n            }else {\n                Integer cur = nums.pop();\n                String stackTemp = stacks.pop();\n                for (int i = 0; i < cur; i++) {\n                    stackTemp += ret;\n                }\n                ret = stackTemp;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918765346","body":"**思路**\n\n将数据装进栈里，需要pop操作时，才将数据放进另一个栈里，实现反转。注意点：不能每次pop 或者其他操作时就将栈数据放进另一个栈中。还要判断一下第二个栈是否为空，不然会出现顺序错误。\n\n**代码**\n\n```java\nclass MyQueue {\n\n    private Stack<Integer> stack1;\n\n    private Stack<Integer> stack2;\n\n    private Integer index;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack1 = new Stack();\n        stack2 = new Stack();\n        index = 0;\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        stack1.push(x);\n        index++;\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        swap();\n        Integer data = stack2.pop();\n        return data;\n\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        swap();\n        return stack2.peek() != 0 ? stack2.peek() : 0;\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        swap();\n        return stack2.empty();\n    }\n\n    private void swap(){\n        if (stack2.empty()) {\n            while (index != 0) {\n                stack2.push(stack1.pop());\n                index--;\n            }\n        }\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度：O(N）\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919666113","body":"**思路**\n\n第一道困难题，想不出思路，看了题解才知道。其方法在于排序后，对数的计数时 计数不相等就是不能分块的，计数相等则可以分块。\n\n**代码**\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] sorted_arr = arr.clone();\n        Arrays.sort(sorted_arr);\n        int count = 0,num1 = 0,num2 = 0;\n        for (int i = 0; i < arr.length; i++) {\n            num1 += arr[i];\n            num2 += sorted_arr[i];\n            if (num1 == num2){\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度：O(N^2) 排序加循环\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920545811","body":"**思路**\n\n用快慢指针找出分界点k的位置，把k的next指向null，将链表断开。将尾结点的next指向head 然后返回k+1节点的位置，链表走到k.next就停下来了\n\n**代码**\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        ListNode tempNode = head;\n        ListNode fast = head,slow = head;\n        int index = 1;\n        while (tempNode.next != null){\n            index++;\n            tempNode = tempNode.next;\n        }\n        //取模\n        int count = (k >= index) ? (k % index) : k;\n        for (int i = 0; i < count; i++) {\n            fast = fast.next;\n        }\n        //快慢指针\n        while (fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        fast.next = head;\n        tempNode = slow.next;\n        slow.next = null;\n\n        return tempNode;\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922171332","body":"**思路**\n\n昨晚数组的题目的转换之后，做链表的思路变得比较清晰。在使用快慢指针寻找中点时需要在细节上需要有些调整。\n\n**代码**\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null){\n            return null;\n        }\n        return dfs(head, null);\n    }\n    private TreeNode dfs(ListNode head,ListNode tail){\n        if (head == tail){\n            return null;\n        }\n        ListNode fast = head,slow = head;\n        while (fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = dfs(head,slow);\n        root.right = dfs(slow.next,tail);\n        return root;\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度：O(nlogn)\n\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922423146","body":"思路\r\n\r\n今天是中秋假期第一天，草率的刷完题目，看到俩个链表求焦点 第一反应就是用map去校验。啪啪一顿操作 空间复杂度略高。空间复杂度要到O(1)应该需要俩个指针操作。\r\n\r\n代码\r\n\r\n    public class Solution {\r\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n            if (headA == null || headB == null){\r\n                return null;\r\n            }\r\n            HashMap map = new HashMap<>();\r\n            while (headA != null){\r\n                map.put(headA,null);\r\n                headA = headA.next;\r\n            }\r\n            while (headB != null){\r\n                if (map.containsKey(headB)){\r\n                    return headB;\r\n                }\r\n                headB = headB.next;\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n\r\n复杂度\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"peteruixi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916589529","body":"### 思路\n\n先算出总和 再转换成列表\n\n### 代码\n\n```python\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = 0\n        for i in num:\n            temp = temp*10+i\n        temp += k\n        res = []\n        for i in str(temp):\n            res.append(int(i))\n        return res\n```\n\n### 复杂度\n\n- 时间复杂度: O(2N)\n- 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917324737","body":"### 思路\n\n前后扫描各一次, 找出最小的差距\n\n### 代码\n\n```python\ndef shortestToChar(self, s: str, c: str) -> List[int]:\n        N = len(s)\n        res = [0 for _ in range (N)]\n        index = float('-inf')\n        for i in range(N):\n            if s[i] ==c:\n                index = i\n            res[i] = abs(index-i)\n        for i in range(N-1,-1,-1):\n            if s[i] ==c:\n                index = i\n            res[i] = min(res[i],abs(index-i))\n        return res\n```\n\n### 复杂度分析\n\n- 时间复杂度: $O(2N)$\n- 空间复杂度: $O(N)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917637136","body":"### 思路\n\n利用self.size记录最大限制, append的时候检查条件\n\nincrement利用while loop\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = maxSize\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.size:\n            self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if len(self.stack):\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        i = 0\n        while i < k and i<len(self.stack):\n            self.stack[i]+=val\n            i+=1\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度: \n  - `add` , `pop`: O(1)\n  - `increment`: O(K)\n- 空间复杂度: \n  - O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918076360","body":"### 思路\n\n类似题目\n\n439. Ternary Expression Parser\n\n从后往前遍历获取最完整的substring\n\n- 判断是不是字符\n  - 是: 进栈\n  - 不是: (等于是数字), 先获取数字, 然后找出由`[]`包裹的substring, 然后进栈\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        i = len(s)-1\n        while i>=0:\n            # If value is not a digit, append all the character\n            if not s[i].isdigit():\n                stack.append(s[i])\n                i-=1\n            else:\n                # If value is a digit, get the value\n                num=''\n                while i>=0 and s[i].isdigit():\n                    num=s[i]+num\n                    i-=1\n                # Find the substring, by popping all bracket characters\n                sub=''\n                while stack[-1]!=']':\n                    tmp=stack.pop()\n                    if tmp!='[':\n                        sub+=tmp\n                stack.pop()\n                sub=int(num)*sub # Perfrom recurring substring\n                stack.append(sub) \n        stack.reverse()\n        return ''.join(stack)\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(stack depth)\n- 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918743680","body":"### 思路\n\n双栈, 一个栈负责`push` 一个栈负责`pop`. 当peek的时候, stack2 = stack1[::-1] + stack2, 需要pop的值为stack2末尾\n\n### 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = [] \n        self.stack2 = []\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n        print(self.stack1)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.peek():\n            return self.stack2.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if len(self.stack1):\n            print(self.stack1[::-1])\n            self.stack2 = self.stack1[::-1]+(self.stack2)\n            self.stack1 = []\n        \n        return self.stack2[-1] if self.stack2 else None\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not self.stack1 and not self.stack2\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### 复杂度分析\n\n- 时间复杂度 O(1)\n- 空间复杂度 O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919779169","body":"### 思路\n\n引用思路: \n\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i in arr:\n            print(stack)\n            if stack and stack[-1] > i:\n                head = stack.pop()\n                while stack and stack[-1]>i: stack.pop()\n                stack.append(head)\n            else:\n                stack.append(i)\n        return len(stack)\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920769884","body":"### 思路\n\n1. 找出链表总长度\n2. 长度%k算出需要旋转几位\n3. 找到位置实现旋转\n\n### 代码\n\n```\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return\n        temp = head\n        l = 1\n        while temp.next: \n            temp= temp.next\n            l+=1\n        k = k%l\n        temp.next = head\n        for _ in range(l-k):\n            temp=temp.next\n        res= temp.next\n        temp.next= None \n        return res\n```\n\n### 复杂度分析\n\n- 时间复杂度:(2N)\n- 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921752634","body":"### 思路\n\n因为要记录单数位链接跟前者的关系 所以操作点在那之前. 建立`dummy`节点, 从`dummy`节点开始遍历+操作\n\n### 代码\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:return head\n        sentinel = ListNode(0)\n        sentinel.next = head\n        temp = sentinel\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp=node1\n        return sentinel.next\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user1689":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590008","body":"## 思路\n模拟竖式加法\n\n## python3\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        # 将k转化成数组\n        num2 = []\n        strK = str(k)\n        for element in strK:\n            num2.append(element)\n        \n        # 直接相加 \n        res = []\n        addCarry = 0\n        i, j = len(num) - 1, len(num2) - 1\n        while i >= 0 and j >= 0:\n            sum_ = num[i] + int(num2[j]) + addCarry\n            digit = sum_ % 10\n            addCarry = sum_ // 10\n            res.append(digit)\n            i -= 1\n            j -= 1\n\n        # 如果多出digit另外处理\n        while i >= 0:\n            sum_ = num[i] + addCarry\n            digit = sum_ % 10\n            addCarry = sum_ // 10\n            res.append(digit)\n            i -= 1\n        \n        # 如果多出digit另外处理\n        while j >= 0:\n            sum_ = int(num2[j]) + addCarry\n            digit = sum_ % 10\n            addCarry = sum_ // 10\n            res.append(digit)\n            j -= 1\n\n        # 如果有进位 则加1\n        if addCarry:\n            res.append(1)\n        \n        # 因为append的原因，最后得反转\n        return res[::-1]\n\n        # print(res)\n```\n## 复杂度分析\n* time max(n, logk) n为数组长度\n* space n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917317466","body":"## 思路\n最小数组\n\n## python3\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # 思路一 最小数组\n        # 因为最近的c无非在字母的左边或者右边\n        # 两次遍历 \n        # 第一次从左往右维护prev为c的idx然后求出每个坐标到此prev的距离\n        # 第二此从右往左维护prev 与第一次的值作对比 将较小的存入\n\n        ans = []\n        # 若它左边没有c字母，则idx减去-inf等于inf，配对后面取min\n        prev = float('-inf')\n        # 从前往后 看每个单词与它左边离它最近的c的距离是多少\n        for idx, char in enumerate(s):\n            if char == c:\n                prev = idx\n            ans.append(idx - prev)\n        \n        prev = float('inf')\n        # 从后往前 看每个单词与它右边离它最近的c的距离是多少\n        for idx in range(len(s) - 1,  -1, -1):\n            if s[idx] == c:\n                prev = idx\n            ans[idx] = min(ans[idx], prev - idx)\n        return ans\n```\n## 复杂度分析\n* time n n为s长度\n* space n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917536367","body":"## 题目\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n## 思路\n* 思路一brute force\n* 思路二前缀和优化\n\n## python\n```python\n# 思路一\nclass CustomStack:\n    # time n\n    # space n\n    def __init__(self, maxSize: int):\n        self.stack = list()\n        self.maxSize = maxSize\n        self.size = 0\n\n    def push(self, x: int) -> None:\n        if self.size == self.maxSize:\n            return\n        else:\n            self.size += 1\n            self.stack.append(x)\n            \n    def pop(self) -> int:\n        if self.size > 0:\n            self.size -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if self.size <= k:\n            for i in range(0, self.size):\n                self.stack[i] += val\n        else:\n            for i in range(0, k):\n                self.stack[i] += val\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n\n# 思路二\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = list()\n        self.maxSize = maxSize\n        self.size = 0\n        self.increments = list()\n\n    def push(self, x: int) -> None:\n        if self.size == self.maxSize:\n            return\n        else:\n            self.size += 1\n            self.stack.append(x)\n            # 加0备用\n            self.increments.append(0)\n            \n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        self.size -= 1\n        # 由于先减size 所以当长度为2时 判断却size为1，但此时还是需要进行转移的\n        # 所以选择使用>=1\n        if self.size >= 1:\n            self.increments[-2] += self.increments[-1]\n        return self.stack.pop() + self.increments.pop()\n        \n    def increment(self, k: int, val: int) -> None:\n        # 如果存在 \n        if self.increments:\n            # 底层k个元素增1即为 index为 0 到 (k -1)的元素\n            # 为了符合题意(k - 1)与size取小\n            # += 是为了当多次调用increment时 值不会被覆盖\n            self.increments[min(k - 1, self.size - 1)] += val\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 复杂度分析\n* time 1\n* space n\n\n## 相关题目","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917887398","body":"## 题目\nhttps://leetcode-cn.com/problems/decode-string/\n\n## 思路\n模拟\n\n## python3\n```python\n# 写法一\nclass Solution:\n    def decodeString(self, s: str) -> str:\n\n        # time s + |s|\n        # space n\n        # 单栈模拟\n        stack = []\n \n        for char in s:\n            if char != ']':\n                stack.append(char)\n            else:\n                \n                # 取出字符\n                alpha = list()\n                while stack and stack[-1].isalpha():\n                    alpha.append(stack.pop())\n                # 数组 -> string\n                tmp = \"\"\n                for i in range(len(alpha) - 1, -1, -1):\n                    tmp += str(alpha[i])\n                alpha = tmp\n                \n                # case:\n                # s = \"3[ab]2[bc]\"\n                # stack = ['3','[','a','b']\n                # alpha = ['b','a']\n                # tmp = \"ab\"\n                \n                # 取出[\n                if stack and stack[-1] == '[':\n                    stack.pop()\n\n                # 取出倍数\n                multiple = list()\n                while stack and stack[-1].isdigit():\n                    multiple.append(stack.pop())\n                # 数组 -> string -> int\n                tmp = \"\"\n                for i in range(len(multiple) - 1, -1, -1):\n                    tmp += str(multiple[i])\n                multiple = int(tmp)\n                    \n                # 放回 倍数个字符\n                while multiple > 0:\n                    stack.append(alpha)\n                    multiple -= 1\n\n        res = \"\"\n        for i in range(0, len(stack)):\n            res += stack[i]\n        return res\n\n# 写法二\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        multi = 0\n\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                multi, res = 0, \"\"\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c) \n            else:\n                res += c\n        \n        return res\n```\n\n## 时间复杂度\n* time s + |s|\n* space n\n\n## 相关题目\n1.待补充","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918728402","body":"## 题目\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n## 思路\n双栈 只有在stack2为空时才往里append\n\n## python\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        # 当stack2不为空时不加stack2\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n        \n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.stack2:\n            return self.stack2[-1]\n        else:\n            return self.stack1[0]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.stack1) == 0 and len(self.stack2) == 0\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n## 时间复杂度\n* time 1\n* space n\n\n## 相关题目\n1. 225. Implement Stack using Queues","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919661075","body":"## 题目\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/submissions/\n\n## 思路\n* 计数\n* 计数优化\n* 单调栈\n\n## python3\n```python3\n# 思路一\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n\n        # time n**2 \n        # space n\n        # 思路二\n        # 哈希表\n        # 计数\n        # 这两个数组排序后的结果以及计数信息是一致的\n\n        c1 = defaultdict(int)\n        c2 = defaultdict(int)\n        ans = 0\n        for a, b in zip(arr, sorted(arr)):\n            c1[a] += 1\n            c2[b] += 1\n            if c1 == c2: ans += 1\n        return ans\n        \n# 思路二\n# 优化复杂度\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n\n        # time nlogn \n        # space n\n        # 思路二\n        # 哈希表\n        # 计数\n        # 这两个数组排序后的结果以及计数信息是一致的\n        # 优化空间复杂度和时间复杂度\n        # 用变量 nonzero 来计数目前差值不等于 0 的字符的个数\n\n        c = defaultdict(int)\n        ans = 0\n        nonzero = 0\n        for a, b in zip(arr, sorted(arr)):\n            c[a] += 1\n            if c[a] == 1: nonzero += 1\n            if c[a] == 0: nonzero -= 1\n            \n            c[b] -= 1\n            if c[b] == -1: nonzero += 1\n            if c[b] == 0: nonzero -= 1\n            \n            if nonzero == 0: ans += 1\n        return ans\n        \n# 思路三\n# 单调栈\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n\n        # time n\n        # space n\n        # 思路一\n        # 单调递增栈\n        # 假设head为每个块中最大元素 \n        # 我们在在栈中只存head\n        # 需要注意的是如果新元素小于前面几个head那么都需要一起融合了\n\n        stack = []\n        for num in arr:\n            # 当num < stack[-1] 说明需要融合\n            if stack and stack[-1] > num:\n                # 融合之前 先存下 head\n                head = stack.pop()\n                # 此步骤看是否需要融合前面其他的head\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(head)\n            else:\n                # num > stack[-1]时直接加入作为新head, 不需要融合\n                stack.append(num)\n        return len(stack)\n```\n\n## 复杂度分析\n* time n\n* space n\n\n## 相关题目\n1. https://leetcode-cn.com/problems/max-chunks-to-make-sorted/\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920544039","body":"## 题目\nhttps://leetcode-cn.com/problems/rotate-list/\n\n## 思路\n双指针\n\n## python3\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        # time n\n        # space 1\n        # 双指针\n        if not head or not head.next: return head\n        \n        # 计算长度\n        length = 0\n        cur = head\n        while cur:\n            length += 1\n            cur = cur.next\n        \n        # 对长度取模\n        # 如果取余为0，则表示旋转后和原本相同，则不旋转直接返回\n        k %= length\n        if k == 0: return head\n\n        dummy = ListNode(None, head)\n        slow, fast = dummy, dummy\n        while k > 0:\n            fast = fast.next\n            k -= 1\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next\n        \n        newHead = slow.next\n        slow.next = None\n        fast.next = dummy.next\n        \n        return newHead\n```\n## 复杂度分析\n* time n\n* space 1\n\n## 相关题目\n1. https://leetcode-cn.com/problems/rotate-array/\n2. https://leetcode-cn.com/problems/split-linked-list-in-parts/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921405742","body":"## 题目\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n## 思路\n模拟穿针引线\n\n## python\n```python3\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\n#写法一 递归\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # time n\n        # space 1\n        # 穿针引线 \n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n\n#写法二 迭代\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # time n\n        # space 1\n        # 穿针引线\n        dummy = ListNode(0, head)\n        cur = dummy\n\n        if not head: return \n\n        while cur.next and cur.next.next:\n            node1 = cur.next\n            node2 = cur.next.next\n\n            cur.next = node2\n            node1.next = node2.next\n            node2.next = node1\n\n            cur = cur.next.next\n        \n        return dummy.next\n\n```\n\n## 复杂度分析\n* time n n为链表长度\n* space 1\n\n## 相关题目\n1. https://leetcode-cn.com/problems/reverse-nodes-in-k-group/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922161016","body":"## 题目\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\n\n## 思路\n双指针\n\n## python\n```python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        # time nlogn 每次找中点为n 递归次数logn\n        # space logn 即树的高度\n        # 思路一\n        # 双指针\n        \n        # base\n        if not head:\n            return None\n        elif not head.next:\n            return TreeNode(head.val)\n        \n        # 找到中点\n        pre = None\n        slow, fast = head, head\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 建立并断开前后连接点\n        root = TreeNode(slow.val)\n        pre.next = None\n        \n        # 递归建立左右子树\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n\n```\n\n## 复杂度分析\n* time nlogn 每次找中点为n 递归次数logn\n* space logn\n\n## 相关题目\n1. https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922480291","body":"# 题目\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n# 思路\n\n# python\n```python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        curA, curB = headA, headB\n        while curA != curB:\n            if curA:\n                curA = curA.next\n            else:\n                curA = headB\n            if curB:\n                curB = curB.next\n            else:\n                curB = headA\n        return curA\n```\n\n# 时间复杂度\n* time n\n* space 1\n\n# 相关题目\n1. https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xieyj17":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590188","body":"# 1. 模拟加法逻辑\r\n\r\n把 `num` 和 `k` 都转换成array， 然后逆序从最后一位开始相加，如果大于10 就向下一位进1\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # res stores the final solution\r\n        res = []\r\n        # reverse order of num\r\n        num = num[::-1]\r\n        # convert k to an arry and reverse the order\r\n        sk = [int(i) for i in str(k)]\r\n        sk = sk[::-1]\r\n\t\t# padding 0s to the shorter array\r\n        if len(num) >= len(sk):\r\n            sk = sk + [0]*(len(num) - len(sk))\r\n        else:\r\n            num = num + [0]*(len(sk) - len(num))\r\n\t\t# t stores the result of floor division \r\n        t = 0\r\n     \r\n        for i in range(len(num)):\r\n            n = num[i]\r\n            k = sk[i]\r\n            # add residual to the final solution\r\n            res = res + [(n+k+t) % 10]\r\n            t = (n+k+t) // 10\r\n            \r\n        # if the last addition results a modulo > 0, add to the end of res\r\n        if t > 0:\r\n            res = res + [1]\r\n        return res[::-1]\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度： O(n)\r\n\r\n# 2. Why bother ¯\\\\_(ツ)_/¯\r\n\r\n使用python 内置函数，把 `num` 转换成 int\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sn = [str(i) for i in num]\r\n        sn = int(''.join(sn))\r\n        res = str(sn+k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917260187","body":"Step 1. 找到s 中所有c 在的位置\n\nStep 2. 如果两个c 中间的间隔为d 并且 d % 2 == 0， 那个它们离最近的c 的距离就是1,2,...,d//2, d//2, ..., 2, 1,如果d 是奇数那么距离就是 1,2,...,d//2, d//2+1,  d//2,  ..., 2, 1\n\nStep 3. 两端分别处理一下\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        def gen_interval(k):\n            if k%2 != 0:\n                l = k//2 + 1\n                return [i for i in range(1, l)] + [i for i in range(l, 0, -1)]\n            else:\n                l = k//2\n                return [i for i in range(1, l+1)] + [i for i in range(l, 0, -1)]\n\n        locs = []\n        for i in range(len(s)):\n            if s[i] == c:\n                locs.append(i)\n        if len(locs) == 0:\n            res = [i for i in range(locs[0],-1,-1)] + [i for i in range(len(s)-1-locs[0])]\n        else:\n            diffs = [locs[i+1] - locs[i] - 1 for i in range(len(locs)-1)]\n            res = [i for i in range(locs[0],0,-1)]\n            for d in diffs:\n                res += ([0] + gen_interval(d))\n            res += [i for i in range(len(s)-locs[-1])]\n        return res\n```\n\nTime: O(n)\n\nSpace: O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917482375","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.list = []\n        self.maxSize = maxSize\n        \n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.maxSize:\n            self.list = [x] + self.list       \n        \n\n    def pop(self) -> int:\n        if self.list:\n            r = self.list[0]\n            self.list = self.list[1:]\n            return r\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.list) <= k:\n            self.list = [i + val for i in self.list]\n        else:\n            for i in range(k):\n                self.list[-1-i] = self.list[-1-i] + val\n            \n```\n\n按照要求用最基本的方式实现，nothing fancy\n\n\n\nTime: O(1) for push and pop, O(k) for increment\n\nSpace: N/A","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917683180","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        curr_num = 0\n        curr_string = ''\n        for c in s:\n            if c == '[':\n                stack.append(curr_string)\n                stack.append(curr_num)\n                curr_string = ''\n                curr_num = 0\n            elif c == ']':\n                num = stack.pop()\n                prev_string = stack.pop()\n                curr_string = prev_string + num*curr_string\n            elif c.isdigit():\n                curr_num = curr_num*10 + int(c)\n            else:\n                curr_string += c\n        return curr_string\n```\n\n看了半天还是不会做，然后看了leetcode 的答案模仿着写了一遍，大概有点懂了\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918723591","body":"```python\nfrom collections import deque\n\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.queue = deque()\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.queue.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        return self.queue.popleft()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.queue[0]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.queue) == 0\n\n```\n\n使用`deque` 因此所有操作都是O(1)\n\n\n\nSpace: O(n)\n\nTime: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919658920","body":"### 1.首先是按照leetcode 上的提示用暴力解法\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        sorted_arr = sorted(arr)\n        i = 0\n        count = 0\n        for k in range(len(arr)):\n            if sorted(arr[i:k]) == sorted_arr[i:k]:\n                count += 1\n                i = k\n        return count\n```\n\nspace：O(n) 需要新建一个sorted array\n\ntime：O(n^2*log(n)) 需要sort array n 次，每次O(nlogn)\n\n\n\n### 2. 参考了leetcode 上面的答案自己模仿写了一个\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        n = len(arr)\n        i = 0\n        stack = []\n        biggest = arr[0]\n        while i < n:\n            biggest = max([biggest, arr[i]])\n            while stack and stack[-1] > arr[i]:\n                stack.pop()\n\n            stack.append(biggest)\n\n            i+=1\n        return len(stack)\n```\n\n大概的思路是用`stack` 来储存每个sub array 的最大值\n\nspace：O(n)\n\ntime：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920513202","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if (not head) or (not head.next):\n            return head\n        if k == 0:\n            return head\n        n = 0\n        q = ListNode(0)\n        q.next = head\n        while head:\n            n += 1\n            head = head.next\n        head = q.next\n        r = k % n\n        if r == 0:\n            return q.next\n        i=1\n        while i < n-r:\n            head = head.next\n            i+=1\n        p1 = ListNode(0)\n        p1.next = head.next\n        head.next = None\n        k = p1.next\n        while k.next:\n            k = k.next\n        k.next = q.next\n        return p1.next\n```\n\n思路：首先历遍一次linked list 获得长度n，然后历遍第二次找到倒数第 k%n 项， 将其设为linked list 的开头，第 k%n-1 项设为结尾即可\n\n\n\nTime: O(n)\n\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921409790","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if (not head) or (not head.next):\n            return head\n        p1 = head\n        p2 = head.next\n        p1.next = self.swapPairs(p2.next)\n        p2.next = p1\n        return p2\n\n```\n\n \n\n思考了半天没有想法，参考了答案之后发现recursion 可以很容易解决\n\nSpace 和Time complexity 比较难分析","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922163843","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        val = []\n        while head:\n            val.append(head.val)\n            head = head.next\n\n        def to_BST(l, r):\n            if l > r:\n                return None\n            elif l == r:\n                return TreeNode(val[l])\n            else:\n                mid = (l+r) // 2\n                node = TreeNode(val[mid])\n                node.left = to_BST(l, mid-1)\n                node.right = to_BST(mid+1, r)\n                return node\n        \n        return to_BST(0, len(val)-1)\n```\n\n第一次接触binary tree， 看了答案才会做的\n\nTime O(N)\n\nSpace O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922408703","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p1 = headA\n        p2 = headB\n        while p1 != p2:\n            if p1 is None:\n                p1 = headB\n            else:\n                p1 = p1.next\n            if p2 is None:\n                p2 = headA\n            else:\n                p2 = p2.next\n        return p1 \n```\n\n之前碰到过一次的题目，历遍两次找到相交的点\n\nTime O(n)\n\nSpace O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922509912","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        p1 = head\n        p2 = head\n        while p1 is not None and p1.next is not None:\n            p1 = p1.next.next\n            p2 = p2.next\n            \n            if p1 == p2:\n                while True:\n                    if p2 == head:\n                        return head\n                    else:\n                        head = head.next\n                        p2 = p2.next               \n                \n        return \n```\n\n\n\nSpace O(1)\n\nTime O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shamworld":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590720","body":"# 思路\n从末尾遍历num，取出值和k%10的余相加，然后把k除以10取余，这个时候就判断a的值是不是大于等于10，如果是，就处理a的值和k++，把处理的a放入数组，这里要判断k的边界，如果num循环完了，k还有值，那么就处理k，在加入数组中，最后把数组反转\n```js\nvar addToArrayForm = function (num, k) {\n    let m, res = [];\n    for (let i = num.length - 1; i >= 0; i--) {\n        m = num[i] + k % 10;//取末尾和k除以10的余相加\n        k = Math.floor(k / 10);\n        if (m >= 10) {\n            k++;//相加最大也是19 所以k+1就行\n            m = m - 10;//拿到当前位的值\n        }\n        res.push(m);\n    }\n    //k的长度大于num的长度的情况\n    while (k != 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    return res.reverse();\n};\n```\n# 复杂度分析\n- 时间复杂度:O(max(num.length,k))\n- 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917321998","body":"## 思路\r\n先找到c所在的位置的所有下标，然后遍历判断\r\n## 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let arr = [];\r\n    let result = [];\r\n    for(let i = 0;i < s.length; i++){  \r\n        if(s[i]===c){\r\n            arr.push(i)\r\n        }\r\n    }\r\n    for(let i = 0;i < s.length; i++){\r\n        if(s[i]===c){\r\n            result[i] = 0;\r\n            continue\r\n        }\r\n        \r\n        for(let index of arr){\r\n            let res = Math.abs(index-i);\r\n            console.log(result)\r\n            if(res>=result[i]) break;\r\n            result[i] = res;\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n## 复杂度分析\r\n- 时间复杂度:O(n^2)\r\n- 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917606373","body":"## 思路\n用一个数组维护栈，通过pop()和push()来操作\n## 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stackList = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stackList.length>=this.maxSize) return null;\n    this.stackList.push(x); \n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    \n    if(this.stackList.length==0) return -1;\n    return this.stackList.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(k<this.stackList.length){\n        for(let i = 0; i < k; i++){\n            this.stackList[i] += val\n        }\n    }else{\n        for(let i = 0; i < this.stackList.length; i++){\n            this.stackList[i] += val\n        }\n    }\n};\n\n```\n## 复杂度分析\n- 时间复杂度:pop,push为O(1)，increment为O(k)\n- 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917780048","body":"## 思路\n通过两个数组维护数字栈和字符串栈\n## 代码\n```js\nvar decodeString = function (s) {\n    let numList = [];//存放数字\n    let numStr = '';//存放数字长度\n    let stackList = [];//存放字符串\n    let str = '';//存放括号里面的字符串\n    let result = '';//返回值\n    for (let i = 0; i < s.length; i++) {\n        const n = s.charAt(i);\n        if (n >= 0 && n <= 9) {\n            numStr += n;\n        } else if (n === '[') {//这时说明前面数字，字符串已经匹配完了\n            numList.push(numStr);\n            stackList.push(str);\n            numStr = '';\n            str = '';\n        } else if (n === ']') {\n            const num = numList.pop();\n            let t = '';\n            for (let j = 0; j < num; j++) {\n                t += str;\n            }\n            //已经计算了一个闭环，就要判断stackList中还存不存在字符串，存在就加，例如：3[a2[c]]=>3[acc]\n            let temp = stackList.length > 0 ? stackList.pop() : '';\n            str = temp + t;\n            //如果当前数字数组中没有数据了，那就说明当前位置已经没有可以重复的字符串了，直接加入到返回值里面\n            if (numList.length === 0) {\n                result += str;\n                str = '';\n            }\n        } else {\n            //如果当前数字数组中没有数据了，那就说明当前位置已经没有可以重复的字符串了，直接加入到返回值里面\n            if (numList.length === 0) {\n                result += n;\n            } else {\n                str += n;\n            }\n        }\n    }\n\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918728382","body":"## 思路\n用两个数组维护，队列先进先出，栈先进后出\n## 代码\n```js\nvar MyQueue = function() {\n    this.stackInList = [];\n    this.stackOutList = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stackInList.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(!this.stackOutList.length){\n        while(this.stackInList.length){\n            this.stackOutList.push(this.stackInList.pop());\n        }\n    }\n    return this.stackOutList.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.stackOutList.length){\n        while(this.stackInList.length){\n            this.stackOutList.push(this.stackInList.pop());\n        }\n    }\n    if(!this.stackOutList.length) return null;\n    return this.stackOutList[this.stackOutList.length-1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stackOutList.length && !this.stackInList.length\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919657913","body":"## 思路\r\n滑动窗口\r\n## 代码\r\n```js\r\nvar maxChunksToSorted = function(arr) {\r\n    let sortArr = [...arr];\r\n    sortArr.sort((a,b)=>a-b);\r\n    let count = 0,num1 = 0,num2 = 0;\r\n    for(let i = 0; i < arr.length; i++){\r\n        num1 += arr[i];\r\n        num2 += sortArr[i];\r\n        if(num1==num2){\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n};\r\n```\r\n## 复杂度分析\r\n- 时间复杂度:O(NlogN)\r\n- 空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920614436","body":"## 思路\n先求出链表长度，用k去对链表长度取模看需要移动多少位，然后遍历\n## 代码\n```js\nvar rotateRight = function(head, k) {\n    if(!head) return head;\n    let preNode = head;\n    let len = 1;\n    while(preNode.next!=null){\n        len++;\n        preNode = preNode.next;\n    }\n    preNode.next = head;\n    let curNode = head;\n     k = k % len;\n    for(let i = 0; i < len - k - 1; i++){\n        curNode = curNode.next;\n    }\n    let head2 = curNode.next;\n    curNode.next = null;\n    return head2\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921398093","body":"## 思路\n调换next和next.next的位置 \n## 代码\n```js\nvar swapPairs = function(head) {\n    if(!head||!head.next){\n        return head;\n    }\n    let node = new ListNode(0);\n    node.next = head;\n    let temp = node;\n    while(temp.next!==null&&temp.next.next!==null){\n        let tempNode1 = temp.next;\n        let tempNode2 = temp.next.next;\n        temp.next = tempNode2;\n        tempNode1.next = tempNode2.next;\n        tempNode2.next = tempNode1;\n        temp = tempNode1;\n    }\n\n    return node.next;\n\n};\n```\n## 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922166588","body":"## 思路\n通过快慢指针找出中间值，然后构造左树和又树\n## 代码\n```js\nvar sortedListToBST = function(head) {\n    if(!head) return null;\n    function deep(left,right){\n        if(left==right)return null;\n        let fast = left,slow = left;\n        while(fast!=right&&fast.next!=right){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        let root = new TreeNode(slow.val);\n        root.left = deep(left,slow);\n        root.right = deep(slow.next,right);\n\n        return root;\n    }\n    return deep(head,null);\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922465312","body":"## 思路\n双指针，A遍历完还没找到就把A接到B的头部，同理B也是一样\n## 代理\n```js\nvar getIntersectionNode = function(headA, headB) {\n    if(!headA||!headB) return null;\n    let nodeA = headA,nodeB = headB;\n    while(nodeA!=nodeB){\n        nodeA = nodeA === null ? headB : nodeA.next;\n        nodeB = nodeB === null ? headA : nodeB.next;\n    }\n    return nodeA;\n};\n``\n`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"learning-go123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590825","body":"## 思路\n在原有num上操作数据，进位在num前面插入数据\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc addToArrayForm(num []int, k int) []int {\n    for i:=len(num)-1;i>=0;i--{\n        val := num[i] + k %10\n        k /= 10\n\n        num[i] = val % 10\n        if val > 9 {\n            if i - 1 >= 0 {\n                num[i-1] += 1\n            } else {\n                num =  append([]int{1}, num...)\n                i++\n            }\n        } \n    }\n\n    for k !=0 {\n        num =  append([]int{k%10}, num...)\n        k /= 10\n    }\n\n    return num\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917315087","body":"\n## 思路\n找到c数据，在回溯找到前面并修改比当前数据大的值双100%\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc shortestToChar(s string, c byte) []int {\n\tres := make([]int, len(s))\n\tres[0] = 10000\n\tfor i, value := range s {\n\t\tif i != 0 {\n\t\t\tres[i] = res[i-1]+1\n\t\t}\n\t\tif byte(value) == c {\n\t\t\tres[i] = 0\n\t\t\tfor j:= i-1;j>=0;j-- {\n\t\t\t\tif res[j] < i - j {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tres[j] = i - j\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917568773","body":"## 思路\n初始化一个maxsize大小的数组，一个pos定位当前使用的位置\n对pos操作，实现快速访问\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\ntype CustomStack struct {\n\tmaxSize int\n\tpos int\n\ts []int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{\n\t\tmaxSize: maxSize,\n\t\tpos:  -1,\n\t\ts : make([]int, maxSize),\n\t}\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n\tif this.pos+1 >= this.maxSize {\n\t\treturn\n\t}\n\tthis.pos++\n\tthis.s[this.pos] = x\n}\n\n\nfunc (this *CustomStack) Pop() int {\n\tif this.pos >= 0 {\n\t\tval := this.s[this.pos]\n\t\tthis.pos--\n\t\treturn val\n\t}\n\treturn -1\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n\tif this.pos <= -1 {\n\t\treturn\n\t}\n\tfor i:=0;i<this.maxSize;i++ {\n\t\tif i>=k {\n\t\t\tbreak\n\t\t}\n\t\tthis.s[i]+=val\n\t}\n}\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917859099","body":"## 思路\n默认写入栈，从内部往外面解开<br>\n1.遇到 ] 就回去先把所有字母弹出并且反转<br>\n2.在弹出数字。 根据数字复制字母在回写入栈，重复以上两步\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc decodeString(s string) string {\n\tvar stack []byte\n\tfor i := 0; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif c == 93 {\n\t\t\tvar d []byte\n\t\t\tfor stack[len(stack)-1] != 91 {\n\t\t\t\tsize := len(stack) - 1\n\t\t\t\td = append(d, stack[size])\n\t\t\t\tstack = stack[:size]\n\t\t\t}\n\t\t\td = reverse(d)\n\n\t\t\t// 剔除[\n\t\t\tstack = stack[:len(stack)-1]\n\t\t\tdigit := 1\n\t\t\tnum := 0\n\t\t\tfor len(stack) != 0 && stack[len(stack)-1] <= 57 {\n\t\t\t\tsize := len(stack) - 1\n\t\t\t\tnum += int(stack[size]-48) * digit\n\t\t\t\tdigit *= 10\n\t\t\t\tstack = stack[:size]\n\t\t\t}\n\n\t\t\tfor j := 1; j <= num; j++ {\n\t\t\t\tstack = append(stack, d...)\n\t\t\t}\n\t\t} else {\n\t\t\tstack = append(stack, c)\n\t\t}\n\n\t}\n\n\treturn string(stack)\n}\n\nfunc reverse(s []byte) []byte {\n\tn := len(s)\n\tfor i := 0; i < n/2; i++ {\n\t\ts[i], s[n-i-1] = s[n-i-1], s[i]\n\t}\n\treturn s\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918772700","body":"## 思路\n**重点：就是在什么时机把s1导入到s2**\n\n1 push默认写入s1栈\n\n2 每次pop或者pek的时候s2栈为空的情况把s1的数据pop到s2， s2的数据就倒过来了\n\n3 在pop s2 就变成先进先出了\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\ntype Stack []int\nfunc (s *Stack) Push(x int) {*s = append(*s, x)}\nfunc (s *Stack) Pop() (x int) {\n\tns := *s\n\tl := len(ns)\n\tx = ns[l-1]\n\t*s = ns[:l-1]\n\treturn\n}\nfunc (s Stack) Peek() (x int) {return s[len(s)-1]}\nfunc (s Stack) isEmpty() bool {return len(s) == 0}\n\ntype MyQueue struct {\n\ts1 Stack\n\ts2 Stack\n}\n\n/** Initialize your data structure here. */\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\ts1: make(Stack, 0),\n\t\ts2: make(Stack, 0),\n\t}\n}\n\n/** Push element x to the back of queue. */\nfunc (this *MyQueue) Push(x int) {\n\tthis.s1.Push(x)\n}\n\n/** Removes the element from in front of queue and returns that element. */\nfunc (this *MyQueue) Pop() int {\n\tthis.Peek()\n\treturn this.s2.Pop()\n}\n\n/** Get the front element. */\nfunc (this *MyQueue) Peek() int {\n\tif this.s2.isEmpty() {\n\t\tfor !this.s1.isEmpty() {\n\t\t\tthis.s2.Push(this.s1.Pop())\n\t\t}\n\t}\n\n\treturn this.s2.Peek()\n}\n\n/** Returns whether the queue is empty. */\nfunc (this *MyQueue) Empty() bool {\n\treturn len(this.s1) == 0 && len(this.s2) == 0\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919729995","body":"## 思路\n\n用单调栈完成\n\n重点:**每次比较保留栈顶的最大值，在写入栈**\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc maxChunksToSorted(arr []int) int {\n\tvar s []int\n\tfor _, value := range arr {\n\t\tif len(s) != 0 && s[len(s)-1] > value {\n\t\t\tmax := s[len(s)-1]\n\t\t\tfor len(s) != 0 && s[len(s)-1] > value {\n\t\t\t\ts = s[:len(s)-1]\n\t\t\t}\n\t\t\ts = append(s, max)\n\t\t} else {\n\t\t\ts = append(s, value)\n\t\t}\n\t}\n\treturn len(s)\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920641975","body":"## 思路\n- 算出链表大小\n- 取余算出找出链表第几步旋转\n- 交换指针旋转，返回结果\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc rotateRight(head *ListNode, k int) *ListNode {\n\tif k == 0 || head == nil || head.Next == nil {\n\t\treturn head\n\t}\n\n\tslow, fast := head, head\n\tn := 1\n\tfor fast.Next != nil {\n\t\tfast = fast.Next\n\t\tn++\n\t}\n\n\tk = k % n\n\tif k == 0 {\n\t\treturn head\n\t}\n\n\tfor i := 1; i < n - k; i++ {\n\t\tslow = slow.Next\n\t}\n\n\tres := slow.Next\n\tfast.Next = head\n\tslow.Next = nil\n\treturn res\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921427987","body":"## 思路\n\n-  添加一个虚拟头节点prev，记录下一个节点\n- 交换当前节点和下一个节点，prev的Next记录更新之后的节点\n- head 和 prev 同时进两次，只要循环一半的数量就能完成\n- **重点是如何交换之后被上一次节点记下来**\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n\t// base case\n\tif head == nil || head.Next == nil {\n\t\treturn head\n\t}\n\n\tprev := &ListNode{Next: head}\n\n\tres := prev\n\n\tfor head != nil && head.Next != nil {\n\t\tnext := head.Next\n\t\thead.Next = head.Next.Next\n\t\tnext.Next = head\n\n\t\tprev.Next = next\n\t\thead = next\n\n\t\tprev = prev.Next.Next\n\t\thead = head.Next.Next\n\t}\n\n\treturn res.Next\n}\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(logn)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922169664","body":"## 思路\n\n## 关键点\n\n-  **重点是快慢指针寻找中间值**\n- 找到中间值构造树\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sortedListToBST(head *ListNode) *TreeNode {\n\tvar f func(*ListNode) *TreeNode\n\tf = func(list *ListNode) *TreeNode {\n\t\t// base case\n\t\tif list == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif list.Next == nil {\n\t\t\treturn &TreeNode{Val: list.Val}\n\t\t}\n\n\t\tslow, fast := &ListNode{Next: list}, list\n\t\tfor fast != nil && fast.Next != nil {\n\t\t\tslow = slow.Next\n\t\t\tfast = fast.Next.Next\n\t\t}\n\t\troot := &TreeNode{Val: slow.Next.Val}\n\t\tright := slow.Next.Next\n\t\tslow.Next = nil\n\t\troot.Left = f(list)\n\t\troot.Right = f(right)\n\t\treturn root\n\t}\n\t\n\treturn f(head)\n}\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(logn)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922405688","body":"## 思路\n\n-  把a加到b结尾，把b加a结尾。有相交就会相遇\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n\tnHeadA,nHeadB := headA, headB\n\tfor nHeadA != nHeadB {\n\n\t\tnHeadA = nHeadA.Next\n\t\tnHeadB = nHeadB.Next\n\n\t\tif nHeadA == nil && nHeadB == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tif nHeadA == nil {\n\t\t\tnHeadA = headB\n\t\t}\n\t\tif nHeadB == nil {\n\t\t\tnHeadB = headA\n\t\t}\n\t}\n\treturn nHeadA\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a244629128":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590955","body":"```javascript\nvar addToArrayForm = function(A, K) {\n    //start from the last Index\n    let flag = A.length - 1\n    //if k <=0 jump out the loop\n    while(K) {\n        // if flag < 0 mean we still have carry left and K is not zero yet\n        if(flag < 0) {\n            //put the carray to the front\n            A.unshift(K % 10)\n        } else {\n            // k plus the last index value\n            K += A[flag]\n            // update the last index value by K % 10,if k is bigger than 9 we only take the units digit(个位数）\n            A[flag] = K % 10\n            //flag mins one for each loop\n            flag--;\n        \n        }\n        \n        K = Math.floor(K / 10)\n        \n    }\n    return A\n}\n// time O(n);\n//space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917049882","body":"<h1>思路</h1>\n两次遍历，第一次从左到右把最近距离更新到res array\n第二次 从右到左遍历，然后把第二次得到的最短距离和第一次相比取最小值\n更新 res array\n\n```javascript\nvar shortestToChar = function(s, c) {\n    //两个循环，设prev 为 INFINITY\n    //第一个循环从左到右，每次在s找到 c 这个字符 就更新 prev = i（c 这个字符的INDEX）\n    // 然后让最近更新的 c 字符 Index 和 当前 字符 INDEX 相减 取绝对值（因为从左到右，不取绝对值会得到负数）\n    let prev = Infinity;\n    let res = [];\n    for(let i =0; i<s.length;i++){\n        if(s[i] === c){\n            prev = i;\n        }\n        res[i] = Math.abs(prev-i);\n    }\n    //第一次循环之后 res 里面的结果，当前数值还没完全正确\n// I I I 0 1 0 0 1 2 3 4  ，I = Infinity\n    \n    // reset prev to INFINITY\n    prev = Infinity;\n    // 第二次循环从右到左， 跟第一次循环步骤一样\n    for(let j = s.length-1; j>=0; j--){\n        if(s[j] === c){\n            prev = j;\n        }\n        // 不同的地方是这里 对比第一次循环和第二次循环得到的值，然后取最小值更新res\n        res[j] = Math.min(res[j],prev-j);\n    }\n    return res;\n};\n\n//time O(n)\n// space O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917479802","body":"<h1>思路</h1>\r\n用额外array存相加的数字，pop的时候才把两个数字相加，就不用遍历数组把每个数字相加\r\n<h1>代码</h1>\r\njavascript\r\n\r\n```javascript\r\n//time O(1)\r\n//space O(n) extra space\r\n\r\nvar CustomStack = function(maxSize) {\r\n    this.size = maxSize;\r\n    this.sum = new Array(maxSize).fill(0);\r\n    this.values = [];\r\n};\r\n\r\n\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.values.length <this.size){\r\n        this.values.push(x);\r\n    } \r\n};\r\n\r\n\r\nCustomStack.prototype.pop = function() {\r\n   if(this.values.length){\r\n       let lastElementIndex = this.values.length-1;\r\n       let SumPosition = this.sum[lastElementIndex];\r\n       if(lastElementIndex>0){\r\n           this.sum[lastElementIndex-1]+= this.sum[lastElementIndex] \r\n       }\r\n        this.sum[lastElementIndex] = 0;\r\n       return this.values.pop() + SumPosition;\r\n   }\r\n    return -1;\r\n};\r\n\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n   let sumIndex = Math.min(this.values.length,k)-1;\r\n    this.sum[sumIndex]+= val;\r\n};\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917706602","body":"<h1>思路</h1>\n\n假如给的string是 \"abc10[cd]xyz\" \n\nstack 用来暂时保存 prevString 和 currNum\n\ncurrString保存字母\n\ncurrNum保存数字\n\n有四种情况\n\n   1.当前char是字母： 直接加到currString里面\n\n​    2.当前char是数字：  直接加到currNum里面，（line 20） 还有一个 currNum*10 是为了应对如果数字是more than 1 digit 的情况。 例如 \"10[cd]\" 这个string需要10个‘cd’重复 ，如果没有currNum *10， currNum 遇到第一个数字的时候会加一 currNum=1，遇到第二个数字0会加零 currNum+0= 1+0=1，得到的数字并不正确。 如果加上currNum*10 ，currNum 遇到第一个数字的时候会加一 currNum=1，遇到第二个数字0会把currNum先乘以10 再加零， currNum*10+0= 1x10+0=10;\n\n   3.当前char 是 '[' ： 如果遇到 [ 我们就把currsString push 到 stack， stack 里面的 string 就会变成 prevString因为马上要遇到下一个 new string，当前数字也push 到 stack，然后currString ， currNum reset 准备保存将要遇到的 new string 和 new number  \n\n4. 当前char 是 ’] ‘:   遇到 ’]‘ 就代表当前string已经结束了，所以我们把 需要重复的数字从stack pop 出来 然后 repeat 当前sring 再 拼接上 prevString\n\n```javascript\n//javascript\n\nvar decodeString = function(s) {\n    let stack = [];\n    let currString = \"\";\n    let currNum = 0;\n    \n    for(let i =0; i<s.length;i++){\n        let currChar = s[i]\n        if(currChar === \"[\"){\n            stack.push(currString);\n            stack.push(currNum);\n            //reset currString\n            currString = \"\";\n            //reset currNum\n            currNum = 0;\n        }else if(currChar === \"]\"){\n            let prevNum = stack.pop();\n            let prevString  = stack.pop();\n            currString= prevString + currString.repeat(prevNum);\n        }else if(currChar>= \"0\" && currChar <= \"9\"){\n            currNum = currNum*10 + Number(currChar);\n        }else{\n            currString+=currChar;\n        }\n    }\n    return currString;\n};\n//TIME O(n) not sure\n// space O(n) not sure\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918599289","body":"<h1>思路</h1>\n\n利用两个stack一个装数据\n\npushStack是专门放push的数据\n\npopStack 是放要pop的数据\n\n每次执行pop 都会先检查popStack是否为空是的话就从pushStack调去数据，不是的话就直接pop  popStack里面的数据\n\n是否empty 要检查两个stack的长度都为零才算empty\n<h1>代码</h1>\njavascript\n\n```javascript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0){\n        while(this.pushStack.length >0){\n            this.popStack.push(this.pushStack.pop());\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n      if(this.popStack.length === 0){\n        while(this.pushStack.length >0){\n            this.popStack.push(this.pushStack.pop());\n        }\n    }\n    return this.popStack[this.popStack.length -1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919636414","body":"```javascript\n//javascript \n\nvar maxChunksToSorted = function(arr) {\n    const sorted = arr.slice().sort((a,b)=>{return a-b});\n    let sum1 = 0;\n    let sum2 = 0;\n    let count = 0;\n    \n    for(let i = 0;i<arr.length;i++ ){\n        sum1+= arr[i];\n        sum2+= sorted[i];\n        if(sum1 === sum2){\n            count++;\n        }\n    }\n    return count;\n};\n//time O(nlog(n));\n//space O(n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920469337","body":"```javascript\nvar rotateRight = function(head, k) {\n    let lens = 1;\n    let tail = head;\n    while(tail && tail.next){\n        lens++;\n        tail =tail.next;\n    }\n    \n    //we're using modulo for the edge case of if the length is smaller than k\n    k = k% lens;\n   //edge case -> if k is 0, we don't need a rotation\n    if( k === 0){\n        return head;\n    }\n    let newTail = head;\n    //if space is not bigger than one we dont need to move the newTail\n    let space = lens-k;\n    //find the new tail\n    while(space > 1 ){\n        space --;\n        newTail = newTail.next;\n    }\n    \n     //save the new head and reset appropriately \n    let newHead = newTail.next;\n    tail.next = head;\n    newTail.next = null;\n    return newHead;\n};\n//time O(n)\n//space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921330859","body":"<h1>思路</h1>\n\n例子 1-2-3-4\n\n设置 dummyNode 是为了swap 第一 pair\n\n设置dummy之后当前currpointer 指向 dummy，first pointer 和 secondpointer 分别指向 第一和第二个元素\n\n```javascript\n// dummyNode -1 - 2 - 3-4\n//  curr                f   s  \n```\n\n这时候把两个元素位置交换 fpointer.next应该指向3 就是 spointer.next, spointer 指向 1 就是 spointer.next = f .然后curr 的下一步我们应该走去 2 就是 spointer的元素 curr.next= secondpointer;\n\n移动curr 每次走两步\n\n下一步 指针都分别走到这里重复上面操作\n\n```javascript\n// dummyNode -2 - 1 -  3 - 4\n// \t\t\t     curr  f\t  s\n```\n\n下一步curr走到了最后元素因为 curr.next 是 null 结束循环\n\n```javascript\n// dummyNode -2 - 1 -  4 - 3 - null\n// \t\t\t      \t               curr\n```\n\n\n\n返回 dummy.next 就是 head\n\n```javascript\nvar swapPairs = function(head) {\n    let dummy = new ListNode(-1);\n    dummy.next = head;\n    let curr = dummy;\n    \n    while(curr.next && curr.next.next){\n        let firstPointer = curr.next;\n        let secondPointer = curr.next.next;\n        \n        firstPointer.next = secondPointer.next;\n        secondPointer.next = firstPointer;\n        curr.next = secondPointer;\n        \n        curr=curr.next.next;\n    }\n    return dummy.next;\n    \n};\n\n//time O(n)\n//space O(1)\n```\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922342542","body":"```javascript\nvar getIntersectionNode = function(headA, headB) {\n    let fast = headA;\n    let slow = headB;\n    \n    while(fast !== slow){\n        fast = fast.next;\n        slow = slow.next;\n        if(fast === slow){\n            return fast;\n        }\n        if(fast === null){\n            fast = headB;\n        }\n        if(slow === null){\n            slow = headA;\n        }\n      \n    }\n    return fast;\n};\n// time O(n+m)\n//space O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhousibao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916592720","body":"```ts\nfunction addToArrayForm(arr: number[], k: number): number[] {\n    let n = arr.length - 1\n    const list = []\n    while( n >= 0 || k){\n        k += (arr[n] || 0)\n        list.push(k%10)\n        k = Math.floor(k/10)\n        n--\n    }\n    return list.reverse()\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917535816","body":"### TypeScript\r\n\r\n```ts\r\nclass CustomStack {\r\n    max:number\r\n    stack:number[]\r\n    constructor(maxSize: number) {\r\n        this.max = maxSize\r\n        this.stack = []\r\n    }\r\n\r\n    push(x: number): void {\r\n        if(this.stack.length < this.max){\r\n            this.stack.push(x)\r\n        }\r\n    }\r\n\r\n    pop(): number {\r\n        if(this.stack.length){\r\n            return this.stack.pop()\r\n        }\r\n        return -1\r\n    }\r\n\r\n    increment(k: number, val: number): void {\r\n        const maxNum = Math.min(k,this.stack.length)\r\n        for(let i = 0; i < maxNum; i++) {\r\n            this.stack[i] += val \r\n        }\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917809337","body":"## ts\n```ts\nfunction decodeString(s: string): string {\n    const stack = []\n    let str = ''\n    let num = ''\n    for(const i of s){\n        if(!isNaN(+i)){\n            num += i\n        } else if( i === '['){\n            stack.push(+num)\n            num = ''\n            stack.push(i)\n        } else if( i === ']'){\n            str = ''\n            while( stack[stack.length - 1] !== '['){\n                // 注意顺序\n                str = stack.pop() + str\n            }\n            // stack[stack.length - 1] === '['\n            stack.pop()\n            stack.push(str.repeat(stack.pop()))\n        } else {\n            stack.push(i)\n        }\n    }\n    return stack.join('');\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919650313","body":"```ts\n// 每一块和排序后的数字是一样的，只是排序不同。\n// 当某一区间和排序后的数字和相等时，即可进行分块\nfunction maxChunksToSorted(arr: number[]): number {\n    const sortArr = [...arr].sort((a,b) => a - b )\n    let sum1 = 0\n    let sum2 = 0\n    let count = 0\n\n    for(let i = 0; i< arr.length; i++){\n        sum1 += arr[i]\n        sum2 += sortArr[i]\n        if(sum1 === sum2){\n            count++\n            sum1 = sum2 = 0\n        }\n    }\n    return count\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920548998","body":"```ts\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    if(k === 0 || !head || !head.next) return head\n    \n    let len = 1\n    let cur = head\n    while(cur.next){\n        len++\n        cur = cur.next\n    }\n   \n    let n = len - k % len\n    if( n === len) return head\n\n\n    cur.next = head; // 变成循环链表\n    while (n--) {\n        cur = cur.next;\n    }\n\n    const res = cur.next;\n    cur.next = null;\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921409735","body":"```ts\n// cur -> qian -> hou\n// 交互后\n// cur -> hou -> qian\n\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    if(!head || !head.next) return head\n\n    const newList = new ListNode(0);\n    newList.next = head\n    let cur = newList\n    let qian = null\n    let hou = null\n    while(cur.next && cur.next.next){\n        // 获取前后节点\n        qian = cur.next\n        hou = cur.next.next\n        // 进行交换\n        cur.next = hou\n        qian.next = hou.next\n        hou.next = qian\n\n        cur = qian\n    }\n    return newList.next\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922166999","body":"```ts\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    if (!head) return null;\n\n    const list = [];\n    let cur = head;\n    while (cur) {\n        list.push(cur.val);\n        cur = cur.next;\n    }\n\n    const helper = (left:number, right:number) => {\n\t\tif (left > right) return null;\n\n\t\tlet index = Math.floor((right + left) / 2);\n\t\tlet newNode = new TreeNode(list[index]);\n\n\t\tnewNode.left = helper(left, index - 1);\n\t\tnewNode.right = helper(index + 1, right);\n\n\t\treturn newNode;\n\t};\n\n\treturn helper(0, list.length - 1);\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RocJeMaintiendrai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916592795","body":"## 题目\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/submissions/\n## 思路\n从最低位开始两两相加，如果计算结果大于10，需要进一位，在高一位的计算中加1。需要注意的是k是有可能比num的位数多，不要忽略这种情况。还有就是不能将num转为integer与k相加后再转为数组形式，因为可能会越界。\n## 代码\n``` java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n\t\tfinal int len = num.length;\n\t\tfor(int i = len - 1; i >= 0; i--) {\n\t\t\tint sum = num[i] + k % 10;\n\t\t\tk /= 10;\n\t\t\tif(sum >= 10) {\n\t\t\t\tk++;\n\t\t\t\tsum -= 10;\n\t\t\t}\t\n\t\t\tres.add(0, sum);\n\t\t}\n\t\tfor(; k > 0; k /= 10) {\n\t\t\tres.add(0, k % 10);\n\t\t}\n\t\treturn res;\n    }\n}\n```\n## 复杂度分析\n#### 时间复杂度\nn为num的长度，k为k的长度，如果k比n小，则时间复杂度为O(n),如果k的长度大于n，则复杂度应为O(k),所以时间复杂度应为O(max(n, k)).\n#### 空间复杂度\n除result外没有开辟新的空间，因此复杂度应为O(1).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917349744","body":"## 思路\n新建一个和s长度相同的array，全部填充上最大的长度可能即为s.length（） - 1， 然后遍历s，当遇到c时使用双指针向左右两边扫，初始一个offset变量为0，指针移动一次就加一，如果在array对应的idx的数大于当前offset，则代表该字母离当前c更近，更新为当前的offset。\n## 代码\n``` java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        final int len = s.length();\n        int[] res = new int[len];\n        Arrays.fill(res, len - 1);\n        for(int i = 0; i < len; i++) {\n            if(s.charAt(i) == c) {\n                int left = i;\n                int leftOffset = 0;\n                while(left >= 0 && res[left] > leftOffset) {\n                    res[left--] = leftOffset++;\n                }\n                int right = i + 1;\n                int rightOffset = 1;\n                while(right < len && res[right] > rightOffset) {\n                    res[right++] = rightOffset++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n## 复杂度分析\n### 时间复杂度\nO(N^2)\n### 空间复杂度\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917504383","body":"## 题目\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n## 思路\n使用空间换时间的方法，类似于堆中的延缓计算，多创建一个数组increament[]，每当调用increment方法时，将value加到该数组中，当pop时查看increment的value是否为0，如果不为0，加上该值再返回，将increament数组该位的值减一变为0.\n## 代码\n``` java\nclass CustomStack {\n    private int[] stack;\n    private int[] increment;\n    private int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        increment = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top != stack.length - 1) {\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top == -1) {\n            return -1;\n        }\n        int topValue = stack[top];\n        if(increment[top] != 0) {\n            topValue += increment[top];\n            increment[top] = 0;\n        }\n        top--;\n        return topValue;\n    }\n    \n    public void increment(int k, int val) {\n        int number = Math.min(k, top + 1);\n        for(int i = 0; i < number; i++) {\n            increment[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n## 复杂度分析\n### 时间复杂度\nO（1） for all operaions.\n### 空间复杂度\nO(maxSize) 创建了额外的数组\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917801689","body":"## 题目\nhttps://leetcode-cn.com/problems/decode-string/\n## 思路\n该问题需要由内向外扩展，很明显可以用到stack先进后出的特性。\n具体到问题上来，我们新创建额外两个stack，一个用来存数字，一个用来存字母。当遇到数字时，将数字记录下来为multi(要记得处理连续数字的情况)；当遇到字母时，直接append到res；当遇到'\\[\\' 符号时，将当前的res和multi压入各自的stack中，并且将multi和res初始化；当遇到'\\]\\'时，需要初始化一个tmp变量，pop出multi里的数字，并迭代加入res到tmp中去，最后要将结果初始为tmp + res.pop()。\n## 代码\n``` java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        Stack<Integer> numberStack = new Stack();\n        Stack<String> stringStack = new Stack();\n        int multi = 0;\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                numberStack.push(multi);\n                stringStack.push(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            } else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int curMulti = numberStack.pop();\n                for(int i = 0; i < curMulti; i++) {\n                    tmp.append(res);\n                }\n                res = new StringBuilder(stringStack.pop() + tmp);\n            } else if(c >= '0' && c <= '9') {\n                multi = multi * 10 + Integer.parseInt(c + \"\");\n            } else {\n                res.append(c);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n## 复杂度分析\n### 时间复杂度\nO(n)\n### 空间复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918733739","body":"## 题目\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n## 思路\n用两个stack，一个inStack一个outStack，当push操作时就直接将数添加到inStack, empty方法就查看是否两个stack都为empty，pop和peek时先看outStack是否为空，不是的话直接调用outStack的pop或者peek，是空的话就先将inStack的数据全倒入ouStack\n## 代码\n``` java\nclass MyQueue {\n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        dumpInStack();\n        return outStack.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        dumpInStack();\n        return outStack.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    //把inStack的倒入outStack\n    private void dumpInStack() {\n        if(outStack.isEmpty()) {\n            while(!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n    }\n}\n```\n## 复杂度分析\n### 时间复杂度\n所有操作均为O(1)\n### 空间复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919562212","body":"## 题目\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n## 思路\n如果可以将数组分为多个块，那么左边块的最大值也是需要小于右边块的最小值，可以使用一个单调递增栈来记录每个block的最大值，stack顶存的是前面块的最大值，新的数字如果大于这个数，就直接push进stack，否则一直pop stack到peek不大于当前值或stack为空，然后使用一个tmp记录该轮循环中的最大值，并push进stack。\n结果即为stack最终的size。\n## 代码\n``` java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for(int i = 0; i < arr.length; i++) {\n            int tmp = -1;\n            while(!stack.isEmpty() && stack.peek() > arr[i]) {\n                tmp = Math.max(tmp, stack.pop());\n            }\n\n            if(tmp != -1) {\n                stack.push(tmp);\n            } else {\n                stack.push(arr[i]);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n## 复杂度分析\n### 时间复杂度\n极端情况逆序时O(n)\n### 空间复杂度\n创建了额外的stack，时间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920374247","body":"## 题目\nhttps://leetcode-cn.com/problems/rotate-list/\n## 思路\n将list的尾部连上头部，然后head指针移动len - k - 1步,head移动到新的listnode的前一个node，然后断开。需要注意的是k可能大于list的长度，所以需要len - k % len.\n## 代码\n``` java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        ListNode index = head;\n        int len = 1;\n        while(index.next != null) {\n            index = index.next;\n            len++;\n        }\n        index.next = head;\n        for(int i = 1; i < len - k % len; i++) {\n            head = head.next;\n        }\n        ListNode res = head.next;\n        head.next = null;\n        return res;\n    }\n}\n```\n## 复杂度分析\n### 时间复杂度\nO(n)\n### 空间复杂度\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921069465","body":"## 题目\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\n## 思路\n使用两个index，index1指向要swap的pair nodes的前一个node，index2指向要swap的pair nodes的第一个node，依次进行pointer的改变。\n## 代码\n``` java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        ListNode cur = head;\n        while(cur != null && cur.next != null) {\n            ListNode nextStart = cur.next.next;\n            pre.next = cur.next;\n            cur.next.next  = cur;\n            cur.next = nextStart;\n            pre = cur;\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n}\n```\n## 复杂度分析\n### 时间复杂度\nO(n)\n### 空间复杂度\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921918912","body":"\n## 思路\n使用快慢指针找到list的中点，中点作为当前的root，然后对左右进行递归调用。\n## 代码\n``` java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        return toBST(head, null);\n    }\n\n    private TreeNode toBST(ListNode head, ListNode tail) {\n        if(head == tail) return null;\n        // find the middle node\n        ListNode slow = head, fast = head;\n        while(fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = toBST(head, slow);\n        root.right = toBST(slow.next, tail);\n        return root;\n    }\n}\n```\n## 复杂度分析\n### 时间复杂度\n所有数据遍历一遍，O(n)\n### 空间复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922386340","body":"## 题目\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n## 思路\n使用两个索引a和b，假设两个链表不相交的部分长度各是a和b，相交后的长度为c，那么索引a走到尾部后从headB再走，b也走到尾部后从headA走，那么都走了a + b + c的距离，因此如果有相交时a，b皆不为null。\n## 代码\n``` java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode a = headA, b = headB;\n        while(a != b) {\n            if(a == null) {\n                a = headB;\n            } else {\n                a = a.next;\n            }\n            if(b == null) {\n                b = headA;\n            } else {\n                b =b.next;\n            }\n        }\n        return a;\n    }\n}\n```\n## 复杂度分析\n### 时间复杂度\nO(n)\n### 空间复杂度\nO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ysy0707":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916593071","body":"```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int n = A.length;\n        List<Integer> res = new ArrayList<>();  // 可以用 LinkeList，或者 ArrayList 往后加，最后反转\n        int i = n - 1, sum = 0, carry = 0;\n        while (i >= 0 || K != 0) {  // 循环条件：两个数有一个没完\n            int x = i >= 0 ? A[i]: 0;\n            int y = K != 0 ? K % 10 : 0;\n                        \n            sum = x + y + carry;\n            carry = sum / 10;\n            K = K / 10;\n\n            i--;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917321390","body":"```\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int n = S.length();\r\n        int[] ans = new int[n];\r\n\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for(int i = 0; i < n; i++){\r\n            if(S.charAt(i) == C) prev = i;\r\n            ans[i] =i - prev;\r\n        } \r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = n - 1; i >= 0; i--){\r\n            if(S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N）\r\n空间复杂度：O(S) S为字符串长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917571830","body":"```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int size;\r\n    int[] increment;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        increment = new int[maxSize + 1];\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(size == stack.length){\r\n            return;\r\n        }\r\n        stack[size++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size == 0){\r\n            return -1;\r\n        }\r\n        int res = stack[size - 1];\r\n        if(increment[size] != 0){\r\n            res += increment[size];\r\n            increment[size - 1] += increment[size];\r\n            increment[size] = 0;\r\n        }\r\n        size--;\r\n        return res;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        increment[Math.min(k, size)] += val;\r\n    }\r\n}\r\n```\r\n时间复杂度： O（1）\r\n空间复杂度： O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917789879","body":"```\r\nclass Solution {\r\n    //c为数字：转化为数字num\r\n    //c为字母：在res尾部添加c\r\n    //c为‘[’：将当前num和res入栈stack，并将两者分别空置\r\n    //c为‘]’：stack出栈，res = 刚出栈的res + 当前res * 刚出栈的数字num\r\n\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int num = 0;\r\n        \r\n        LinkedList<Integer> stackNum = new LinkedList<>();\r\n        LinkedList<StringBuilder> stackRes = new LinkedList<>();\r\n\r\n        for(Character c : s.toCharArray()){\r\n            if(c >= '0' && c <= '9'){\r\n                num = num * 10 + c - '0';\r\n            }else if(c == '['){\r\n                stackNum.addLast(num);\r\n                stackRes.addLast(res);\r\n                num = 0;\r\n                res = new StringBuilder();\r\n            }else if(c == ']'){\r\n                int curNum = stackNum.removeLast();\r\n                StringBuilder tmp = new StringBuilder();\r\n                for(int i = 0; i < curNum; i++){\r\n                    tmp.append(res);\r\n                }\r\n                res = stackRes.removeLast();\r\n                res.append(tmp);\r\n            }else{\r\n                res.append(c);\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919041703","body":"```\r\nclass MyQueue {\r\n    public Stack<Integer> stackPush;\r\n    public Stack<Integer> stackPop;\r\n    \r\n    public MyQueue() {\r\n        stackPush = new Stack<>();\r\n        stackPop = new Stack<>();\r\n    }\r\n    \r\n    //入队就是把数据储存在stackPush中\r\n    public void push(int x) {\r\n        stackPush.push(x);\r\n    }\r\n    \r\n    //如果栈stackPop不为空，直接pop即可\r\n    //如果栈stackPop为空，需要先将栈stackPush中的数据倒腾到栈stackPop中，再pop\r\n    public int pop() {\r\n        if(!stackPop.isEmpty()){\r\n            return stackPop.pop();\r\n        }\r\n        while(!stackPush.isEmpty()){\r\n            stackPop.push(stackPush.pop());\r\n        }\r\n        return stackPop.pop();\r\n    }\r\n    \r\n    //如果栈stackPop不为空，直接peek即可\r\n    //如果栈stackPop为空，需要先将栈stackPush中的数据倒腾到栈stackPop中，再peek    \r\n    public int peek() {\r\n        if(!stackPop.isEmpty()){\r\n            return stackPop.peek();\r\n        }\r\n        while(!stackPush.isEmpty()){\r\n            stackPop.push(stackPush.pop());\r\n        }\r\n        return stackPop.peek();\r\n    }\r\n    \r\n    //判空需要两个栈都空\r\n    public boolean empty() {\r\n        return stackPush.isEmpty() && stackPop.isEmpty();\r\n    }\r\n}\r\n```\r\n时间复杂度: O(N)\r\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919727954","body":"**思路：辅助栈**\r\n遍历数组\r\n1.如果当前的数比前一个块的最大值小，也就是比栈顶元素小，并入前一个块\r\n要注意的是如果当前数比倒数第二个块的最大值也要小，前两个块也需要合并，因此这里需要用一个循环\r\n2.如果当前的数比前一个块的最大值要大，这个数形成一个新的块，把当前的数加入stack中\r\n3.如果栈为空，当前数直接入栈\r\n返回栈的长度\r\n```\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        int ans = 0;\r\n        for(int num:arr){\r\n            if(!stack.isEmpty() && num < stack.peek()){\r\n                int tmp = stack.pop();\r\n                while(!stack.isEmpty() && num < stack.peek()){\r\n                    stack.pop();\r\n                }\r\n                stack.push(tmp);\r\n            }\r\n            else{\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920520286","body":"```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        // 1. 结果不出现变化的特殊情况\r\n        if(k == 0 || head == null || head.next == null){\r\n            return head;\r\n        }\r\n\r\n        // 2. 计算出原链表的长度为n\r\n        int n = 1;\r\n        ListNode iter = head;\r\n        while(iter.next != null){\r\n            iter = iter.next;\r\n            n++;                                // 此时n记录的是链表的末尾节点\r\n        }\r\n\r\n        // 3. 找到移动k位后新链表的最后一个节点\r\n        int add = n - k % n;                    // add 记录的是新链表的最后一个节点\r\n        if(add == n){                           // 如果k 刚好为n的整数倍数，新链表将于原链表相同\r\n            return head;                        // 直接返回原链表即可\r\n        }\r\n\r\n        // 4. 处理逻辑\r\n        iter.next = head;                       // 将当前链表闭合为环\r\n        while(add-- > 0){                       // 将iter指向新链表的最后一个节点位置\r\n            iter = iter.next;   \r\n        }\r\n        ListNode ret = iter.next;               // 此时 ret为移动k位后新链表的头\r\n        iter.next = null;                       // 将环断开\r\n        return ret;                             // 返回新链表\r\n    }\r\n}\r\n```\r\n时间复杂度: O(N)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921865771","body":"```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummyHead = new ListNode(0);\r\n        dummyHead.next = head;\r\n        //创建一个虚拟头结点并指向原链表头结点\r\n        ListNode p = dummyHead;\r\n        //令 p 表示当前到达的节点，初始时 p = dummyHead。如果 p 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。\r\n        while (p.next != null && p.next.next != null){\r\n            //设置需要交换的两个节点分别为node1、node2，然后开始循环\r\n            ListNode node1 = p.next;\r\n            ListNode node2 = p.next.next;\r\n\r\n            //1. p指向node2\r\n            p.next = node2;\r\n\r\n            //2. node1指向剩余链表的头节点node2.next\r\n            node1.next = node2.next;\r\n\r\n            //3. node2指向node1\r\n            node2.next = node1;\r\n            \r\n            //4.挪动tmp、node1、node2\r\n            p = node1;\r\n        }\r\n    return dummyHead.next;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922329060","body":"```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        if(head.next == null) return new TreeNode(head.val);\r\n        //找到链表的中间节点作为平衡二叉搜索树的根节点\r\n        ListNode slow = head, fast = head, pre = null;\r\n        while(fast.next != null){\r\n            fast = fast.next.next != null? fast.next.next: fast.next;\r\n            pre = slow;\r\n            slow = slow.next;\r\n        }\r\n        //生成当前子树的根节点\r\n        TreeNode root = new TreeNode(slow.val);\r\n        //拆分左右链表\r\n        pre.next = null;\r\n        ListNode rhead = slow.next;\r\n        //递归先序遍历构建平衡二叉搜索树\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(rhead);\r\n        return root;        \r\n    }\r\n}\r\n```\r\n时间复杂度：O(NlogN)\r\n空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922333941","body":"```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null){\r\n            return null;\r\n        }\r\n        ListNode a = headA, b = headB;\r\n        while(a != b){\r\n            a = a == null? headB: a.next;\r\n            b = b == null? headA: b.next;\r\n        }\r\n        return a;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922502110","body":"**思路：通过快慢指针找到环的入口**\r\n\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head, slow = head;\r\n        while (true) {\r\n            if (fast == null || fast.next == null) return null;\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if (fast == slow) break;\r\n        }\r\n        fast = head;\r\n        while (slow != fast) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AstrKing":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916593572","body":"## 思路\n\n~~~bash\n直接从后往前加，然后最低位留对10的余数即可。\n~~~\n\n## 代码\n\n~~~java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n~~~\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917766453","body":"### 思路\n\n利用栈的特性\n\n### 代码\n\n~~~java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                stk.removeLast();\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n~~~\n\n### 时间复杂度：O(n)\n\n### 空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919015996","body":"### 思路\n\n采用双栈，一个当输入的，一个当输出的\n\n### 代码\n\n~~~java\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new LinkedList<Integer>();\n        outStack = new LinkedList<Integer>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n~~~\n\n### 时间复杂度：O(1)\n\n### 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919930191","body":"### 思路\n\n结合上一题，用单调递增栈，在遍历数组的过程中，如果一个数字比之前所有分块的最大值都要大，我们就把它作为一个新的分块，果数字小于之前某些分块的最大值，那这些分块都要被合成一个分块\n\n### 代码\n\n~~~java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n~~~\n\n### 空间复杂度：O(n)\n\n### 时间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920782862","body":"### 思路\n\n我们可以先将给定的链表连接成环，然后将指定位置断开\n\n### 代码\n\n~~~java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n~~~\n\n### 时间复杂度:O(n)\n\n### 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921432041","body":"### 思路\n\n用递归即可\n\n### 代码\n\n~~~java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n}\n~~~\n\n### 时间复杂度:O(n)\n\n### 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922271477","body":"### 思路\n\n分治+中序遍历\n\n### 代码\n\n~~~java\nclass Solution {\n    ListNode globalHead;\n\n    public TreeNode sortedListToBST(ListNode head) {\n        globalHead = head;\n        int length = getLength(head);\n        return buildTree(0, length - 1);\n    }\n\n    public int getLength(ListNode head) {\n        int ret = 0;\n        while (head != null) {\n            ++ret;\n            head = head.next;\n        }\n        return ret;\n    }\n\n    public TreeNode buildTree(int left, int right) {\n        if (left > right) {\n            return null;\n        }\n        int mid = (left + right + 1) / 2;\n        TreeNode root = new TreeNode();\n        root.left = buildTree(left, mid - 1);\n        root.val = globalHead.val;\n        globalHead = globalHead.next;\n        root.right = buildTree(mid + 1, right);\n        return root;\n    }\n}\n~~~\n\n### 时间复杂度：O(n)\n\n### 空间复杂度：O(logn)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JadeQi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916595505","body":"# 思路\n\n遍历数组整合成整数\n与k值相加\n刚开始前三个测试样例平安无事，从测4后开始疯狂溢出。\n\n把int 改成Long，短暂解决，测96后，又开始了一轮溢出.....\n\n# 解决方式：\n\n数组的最后一位与k的最后一位相加，注意进位量。\n\n# java\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for(int i = n-1; i >= 0; i--){\n            //数组最后一个与k的最后一位相加\n            int sum = num[i]+k%10;\n            k /= 10;\n            if(sum >= 10){\n                sum -=10;\n                //进位设置\n                k++;\n            }\n            res.add(sum);\n        }\n        //防止k的位数大于num\n        for(;k >0; k/=10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917405605","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        int[] ret = new int[s.length()];\n        int p = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) arr.add(i);\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\n            ret[i] = Math.abs(arr.get(p) - i);\n        }\n        return ret;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917883221","body":"```java\npublic class CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top =-1;\n    }\n    public void Push(int x) {\n        if(top!=stack.Length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    public int Pop() {\n        if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    public void Increment(int k, int val) {\n        int limit = Math.Min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917883367","body":"```java\nclass Day4LC394V0 {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for (Character c : s.toCharArray()) {\n            if (c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            } else if (c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for (int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            } else if (c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");    //记录数字\n            else res.append(c); //直接添加字符\n        }\n        return res.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918923489","body":"```java\nclass MyQueue {\nprivate:\n    stack<int> s1, s2;\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {}\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        s1.push(x);  \n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() \n    {\n        if(s2.size() == 0 && s1.size() == 0) return false;\n        else if(s2.size() != 0) \n        {\n            int temp = s2.top();\n            s2.pop();\n            return temp;\n        }\n        else\n        {\n            while(s1.size() != 0)\n            {\n                s2.push(s1.top());\n                s1.pop(); \n            }\n            int temp = s2.top();\n            s2.pop();\n            return temp;\n        }\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if(s2.size() == 0 && s1.size() == 0) return false;\n        else if(s2.size() != 0) return s2.top();\n        else\n        {\n            while(s1.size() != 0)\n            {\n                s2.push(s1.top());\n                s1.pop(); \n            }\n        } \n        return s2.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919720199","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n             LinkedList<Integer> list =  new LinkedList<>();\n             for(int i = 0; i < arr.length; i++){\n                 if(list.size() == 0){\n                     list.add(arr[i]);\n                     continue;\n                 }\n                 if(list.peekLast() <= arr[i]){\n                     list.add(arr[i]);\n                 }else{\n                     int first  = list.peekLast();\n                     while(list.size() > 0 && list.peekLast() > arr[i]){\n                         list.removeLast();\n                     }\n                     list.add(first);\n                 }\n             }\n             return list.size();\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunupdong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916599149","body":"## 思路：\n\n* 官方题解思路\n* 数组从后往前遍历，数组最后一位与K个位数相加，以此类推\n  * 需要判断相加大于10的情况\n  * 需要判断当k大于数组num时，数组遍历完，k值还有的情况\n  * 最后push进数组，返回时需反转\n\n``` js \n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  const numLength = num.length\n  let res = []\n\n  for (let i = numLength - 1; i >= 0; --i) {\n    // 每一位相加\n    let sum = num[i] + k % 10\n    // 得到除去参与相加的数\n    k = Math.floor(k / 10)\n\n    // 如果相加大于9，结果取个位数，十位数给k，参与下一次循环\n    if (sum > 9) {\n      sum -= 10\n      k++\n    }\n    res.push(sum)\n  }\n\n  /**\n   *  如果k的值大于数组num值，还要将剩余的k的每一位push到数组里\n   *  由于上面执行的操作，k会不断减少一位，如果到这里还剩余，说明大于数组num值，所以此次判断条件为k>0\n   *  for(k=k; k>0; k=Math.floor(k/10))\n   */\n  for (; k > 0; k = Math.floor(k / 10)) {\n    res.push(k % 10)\n  }\n\n  // 由于前面数组是push，个位数在第一个，所以数组要反转一下\n  res.reverse()\n  return res\n};\n```\n\n## 复杂度分析\n\n* 时间复杂度：O(max(n, log k))，其中n为数组的长度\n* 空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917425778","body":"## 思路\n\n* 利用indexof寻找右边界，第二个参数i为从下标 i 元素开始找\n\n``` js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n  // 设置左边界\n  let l = s[0] === c ? 0 : Infinity\n  // 设置右边界\n  let r = s.indexOf(c, 1);\n  const res = Array(s.length);\n\n  for (let i = 0; i < s.length; i++) {\n    //算出左右两边的最小距离\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n\n    // 如果遍历到右边界，然后右边界变成左边界，右边界从下表l+1开始找\n    if (i === r) {\n      l = r;\n      r = s.indexOf(c, l + 1);\n    }\n  }\n\n  return res;\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度： O(n) n为数组s的长度\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917562317","body":"## 思路\n\n* 对栈的基本操作，需要注意的是pop返回的是出栈的值或者是 -1 ,\n\n``` js\nclass CustomStack {\n\n  /**\n* @param {number} maxSize\n*/\n  constructor(maxSize) {\n    this.maxSize = maxSize\n    this.list = []\n  }\n  \n  /** \n   * @param {number} x\n   * @return {void}\n   */\n  push(x) {\n    if (this.list.length >= this.maxSize) return\n    this.list.push(x)\n  };\n\n  /**\n   * @return {number}\n   */\n  pop() {\n    if (!this.list.length) return -1\n    return this.list.pop()\n  }\n\n  /** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\n  increment(k, val) {\n    // 注意要设置i < this.list.length（刚开始没设置一直不对 v_v）\n    for (let i = 0; i < k && i < this.list.length; i++) {\n      this.list[i] += val\n    }\n  };\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度分析\n\n* 时间复杂度：constructor、push、pop的复杂度为O(1), increment的复杂度为k, k是该方法参数k的长度\n* 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917955864","body":"### 思路\n\n* 看题解的v~v, 将数字和[]里的字符分别放入numStact和strStact栈中，然后对应返回生成字符串\n\n### js\n\n``` js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  let numStact = []  // 倍数栈\n  let strStact = [] // 字符栈\n  let res = ''\n  let num = 0\n\n  for (let i of s) {\n    if (!isNaN(i)) { // 是否是数字\n    // * 10是因为可能是多位树\n      num = num * 10 + Number(i)\n    } else if (i === '[') {\n       /*\n        * 是否遇到‘[’\n        * 将之前的res和倍数放入对应的栈中\n        */\n      strStact.push(res) \n      res = ''\n      numStact.push(num)\n      num = 0\n    } else if (i === ']') {\n      /*\n        * 是否遇到‘]’\n        * 获取最后放入栈的字符\n        * repeat 批量返回res\n        */\n      res = strStact.pop() + res.repeat(numStact.pop())\n    } else {\n      res += i\n    }\n  }\n\n  return res\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n) n 为 s的长度\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918734604","body":"## 思路\n\n* 由于要在开头进行操作，而栈只能先进后出，所以使用双栈，一个进栈，一个出栈\n\n### js\n\n``` js\n/**\n * Initialize your data structure here.\n */\nclass MyQueue {\n  constructor() {\n    this.list = []\n    this.outList = []\n  }\n\n  /**\n   * Push element x to the back of queue. \n   * @param {number} x\n   * @return {void}\n   */\n  push(x) {\n    this.list.push(x)\n  };\n\n  /**\n   * Removes the element from in front of queue and returns that element.\n   * @return {number}\n   */\n  pop() {\n    this.pushOutList()\n    return this.outList.pop()\n  };\n\n  /**\n   * Get the front element.\n   * @return {number}\n   */\n  peek() {\n    this.pushOutList()\n    return this.outList[this.outList.length - 1]\n  };\n\n  /**\n   * Returns whether the queue is empty.\n   * @return {boolean}\n   */\n  empty() {\n    return this.list.length <= 0 && this.outList.length <= 0\n  };\n\n  /**\n   * 如果出栈的列表没值了，而进栈列表还有，将进栈列表的值给出栈列表\n   */\n  pushOutList(){\n    if (!this.outList.length) {\n      while (this.list.length > 0) {\n        this.outList.push(this.list.pop())\n      }\n    }\n  }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(1)，push和empty为O(1)，pop和peek为均摊O(1)， 所以平均复杂度为O(1)\n* 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919789475","body":"## 思路\n\n* 拷贝一份数组然后排序，排序前的数减去排序后的数据累加，计算等于0的次数，就是要返回的结果\n\n### js\n\n``` js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n  const copeArr = arr.slice(0, arr.length)\n  copeArr.sort((a, b) => a - b)\n\n  let num = 0\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    num += (arr[i] - copeArr[i])\n    if (num === 0) count++\n  }\n  return count\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n) n为数组的长度\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920999098","body":"## 思路\n\n* 将链表变成环形的，然后找到需要断开的点，赋值为null\n\n### js\n\n``` js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head) return null\n  let num = 0, now = head, tmp = null\n  // 这个循环是将链表变成环状，和获得链表的长度num\n  while(now){\n    num++\n    if(!now.next){\n      now.next = head\n      break\n    }\n    now = now.next\n  }\n\n  // 因为 链表的长度可能会小于k \n  k %= num  \n  \n  // 循环链表，找到需要断开的节点tmp\n  while(k++ < num){\n    console.log(k, head)\n    if(k === num) tmp = head\n    head = head.next\n  }\n\n  // 将找到的节点断开，也就是next赋值为next\n  tmp.next = null\n  \n  // 最后返回这个链表head\n  return head\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921857811","body":"## 思路\n\n* 看了题解，暂无其他思路（-…-）\n\n### js\n\n``` js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  // 如果节点为空或者长度为1，直接返回\n  if (!head || !head.next) return head\n\n  /**\n   * 在链表前面创建一个虚拟节点，指向head\n   * 拿到原链表第一个和第二个节点\n   */\n  let newNode = new ListNode()\n  let prev = head\n  let tail = head.next\n  newNode.next = head\n\n  while (prev && prev.next) {\n    //先获取原先节点的指针 \n    let nextNode = prev.next\n    let nNextNode = nextNode.next\n\n    // 交换位置，其实就是节点的指针改变\n    prev.next = nNextNode\n    nextNode.next = prev\n    newNode.next = nextNode\n\n    // 重新赋值交换节点，用于下一次循环\n    newNode = prev\n    prev = nNextNode\n  }\n\n  return tail\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922298279","body":"## 思路\n\n * 看题解后的\n * 递归，传入头尾指针\n * 快慢指针找出头尾范围的中间节点，然后生成树节点\n * 二叉搜索树左节点一定小于中间根几点，右节点一定大于中间根节点\n * 折半不断缩小头尾指针的范围，然后递归返回到左右节点\n\n### js\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function (head) {\n  if (!head) return null\n  return dfs(head, null)\n};\nfunction dfs(head, tail) {\n  if (head === tail) return null\n  let fast = head\n  let slow = head\n  while (fast !== tail && fast.next !== tail) {\n    slow = slow.next\n    fast = fast.next.next\n  }\n\n  let root = new TreeNode(slow.val)\n  root.left = dfs(head, slow)\n  root.right = dfs(slow.next, tail)\n  return root\n}\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922469016","body":"## 思路一\n\n* 使用哈希表 new Set()\n* 遍历headA，将headA的所有节点添加到哈希表中\n* 遍历headB，判断节点是否在哈希表中存在\n\n### js\n\n``` js\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let set = new Set()\n    while(headA){\n      set.add(headA)\n      headA = headA.next\n    }\n\n    while(headB){\n      if(set.has(headB)) return headB\n      headB = headB.next\n    }\n    return null\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n)  n为链表的节点数\n* 空间复杂度：$O(n)\n\n## 思路二\n\n* 双指针 l 和 l2 分别指向headA和headB，\n* 如果找到相等的，这直接返回\n* 如果循环结束还没找到相等的，下一轮将 l 指向headB， l2指向headA\n* 如果找到相等的，则返回 l 或者 l2, 如果没有找到，则返回null\n\n### js\n\n``` js\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n  let l = headA\n  let l2 = headB\n\n  while (l !== l2) {\n    if (!l) {\n      l = headB\n      continue;\n    }\n    if (!l2) {\n      l2 = headA\n      continue\n    }\n    l = l.next\n    l2 = l2.next\n  }\n  return l\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n) \n* 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Laurence-try":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916599312","body":"### 思路\r\n从k的个位开始，每一位加到num里面，用carry记录进位，并在下一位计算的时候算上carry值并更新carry值。需要对于num和k的长度difference的情况，分别讨论。\r\n### 代码\r\n使用代码: Python3\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        if not num:\r\n            return list(str(k))\r\n        if not k:\r\n            return num\r\n        c = 0\r\n        n_len = len(num)\r\n        pointer = n_len - 1\r\n        res = []\r\n        while pointer >= 0 or k > 0:\r\n            if pointer >= 0:\r\n                k_c = k % 10\r\n                k = k // 10\r\n                new_dig = (num[pointer] + k_c + c) % 10\r\n                c = (num[pointer] + k_c + c) // 10\r\n                num[pointer] = new_dig\r\n                pointer -= 1\r\n            else:\r\n                k = k + c\r\n                k_c = k % 10\r\n                k = k // 10\r\n                res.append(k_c)\r\n                c = 0\r\n        res = res[::-1]\r\n        if c > 0:\r\n            return [c] + num\r\n        else:\r\n            return res + num\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(max(num_len, k_len))， 其中num_len为num的长度， k_len为str(k)的长度\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917225738","body":"### 思路\n新建一个数组长度为n (n 是input数组的长度)， 并把里面所有elements设为n。\n正向遍历一遍， 在新建的数组里面更新第一个字母出现以后的所有distance，如果再次遇见字母，distance归0。\n然后在反向遍历一遍，覆盖刚刚新建的数组，同样从第一个字母出现以后开始覆盖，覆盖的条件是此时的distance要小于上一步更新的distance， 同样如果遇见字母，distance归0。\n\n### 代码\n使用语言：Python3\n```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s) for x in range (len(s))]\n        p = 0\n        count = 0\n        flag = False\n        while p < len(s):\n            if s[p] == c:\n                flag = True\n                count = 0\n                res[p] = 0\n            else:\n                if flag:\n                    count += 1\n                    res[p] = count\n            p += 1\n        count = 0\n        flag = False\n        p -= 1\n        while p >= 0:\n            if s[p] == c:\n                flag = True\n                count = 0\n                res[p] = 0\n            else:\n                if flag:\n                    count += 1\n                    if res[p] > count:\n                        res[p] = count\n            p -= 1\n        return res\n```\n***复杂度分析***\n时间复杂度：O(n)\n空间复杂度：O(1), compensate O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917624688","body":"### 思路\r\n初始化stack为Python的list，并设定此stack size的最大值\r\npush(): 在list的末尾append element when the size is not full (在栈顶加入element 在栈的长度小于最大长度的时候，如果大于等于最大长度了，不能添加）\r\npop(): 把list的末尾return出来（把栈顶的element return出来， 在栈有长度的时候，此时在栈里有elements），如果栈的长度为0，此时栈是空的，return -1\r\nincrement(): 把从栈尾（list的前面）的k遍历，并加上val\r\n\r\n### 代码\r\n使用语言：Python3\r\n```py\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.maxSize > len(self.stack):\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range (min(len(self.stack), k)):\r\n            self.stack[i] += val\r\n```\r\n***复杂度分析***\r\n时间复杂度：O(1) for push and pop, O(min(k, len(stack)) for increment\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917952727","body":"### 思路\n利用入栈和出栈，遍历string\n\n### 代码\n使用语言：Python3\n```py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = []\n        for char in s:\n            if char == ']':\n                rep = ''\n                repCount = ''\n                while res and res[-1] != '[':\n                    rep = res.pop() + rep\n                res.pop()\n                while res and res[-1].isnumeric():\n                    repCount = res.pop() + repCount\n                res.append(rep * int(repCount))\n            else:\n                res.append(char)\n        return ''.join(res)\n```\n***复杂度分析***\n时间复杂度：O(N)\n空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918749741","body":"### 思路\n使用两个栈，但是在Python中只用两个list实现。\n当时执行push()的时候，先把所有的elements全部pop出来存入另一个栈中，然后把元素加入原栈，最后把所有的元素全部pop存回原栈。\n当执行pop或者peek的时候，直接return list的最后一位元素，which就是队列的开头。只是pop需要移除，但是peek不用。\n在返回是否空时，可以去检查栈的长度，如长度大于0则不为空returnFalse，反之return True。\n### 代码\n使用语言：Python3\n```py\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []\n        self.stack_helper = []\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        while self.stack:\n            self.stack_helper.append(self.stack.pop())\n        self.stack_helper.append(x)\n        while self.stack_helper:\n            self.stack.append(self.stack_helper.pop())\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        return self.stack.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return False if self.stack else True\n```\n***复杂度分析***\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919613535","body":"### 思路\n两种方法：\n1. 如果 arr[:(i+1)] 的计数信息和 arr_sort[:(i+1)] 的计数信息一致,count+= 1说明可以把这一段分成一个chunk\n2. 单调栈\n### 代码\n使用语言：Python3\n```py\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr_sort = arr.copy()\n        arr_sort.sort()\n        count = 0\n        for i in range (len(arr)):\n            arr_sub = arr[:(i+1)]\n            arr_sort_sub = arr_sort[:(i+1)]\n            arr_sub.sort()\n            arr_sort_sub.sort()\n            if arr_sub == arr_sort_sub:\n                count += 1\n        return count\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for a in arr:\n            if stack and stack[-1] > a:\n                cur = stack[-1]\n                while stack and stack[-1] > a: \n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)\n```\n***复杂度分析***\n解法1：时间（O(n^3)(此解法可以继续优化不是最优解）；空间（O(n)）\n解法2：时间（O(n)）；空间（O(n)）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920678576","body":"### 思路\r\n利用快慢指针，快指针指到最后，慢指针指到(len(linkedlist)) - k。 需要注意的是，linkedlist的长度通过遍历一遍得到，但是如果长度小于k，k = k % len， 此时再去快慢指针。\r\n然后删除后节点，把最后的节点接回head\r\n### 代码\r\n使用语言：Python3\r\n```py\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if head:\r\n            p1 = p2 = p_count = head\r\n            l = 0\r\n            while p_count:\r\n                p_count = p_count.next\r\n                l += 1\r\n            k_1 = k % l\r\n            while p2.next:\r\n                if k_1 != 0:\r\n                    p2 = p2.next\r\n                    k_1 -= 1\r\n                else:\r\n                    p1 = p1.next\r\n                    p2 = p2.next\r\n            if p1.next:\r\n                tmp = p1.next\r\n            else:\r\n                return head\r\n            p1.next = None\r\n            p2.next = head\r\n            return tmp\r\n```\r\n***复杂度分析***\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921687563","body":"### 思路\n新建一个链表，用一个指针永远指向新建链表的head（code中用res表示，然后最后return res.next，因为head永远为空）\n此时用两个指针去指向链表，第一个指向head.next, 第二个指向head.next.next。此时第二个指针用来存不交换位置的node。然后把空链表的head的next连入第一个指针，head指针断开连入第三个指针，此时已经完成第一步交换pair。在这个过程中，还需要创造一个指针（此时的第三个指针）来储存此时head的位置，因为在接下来更新中需要移动head的指针。然后我们开始更新指针，移动head指针到第二个指针的位置，完成更新。接下来就在有head并且有head.next的情况下去重复以上的步骤。\n### 代码\n使用语言：Python3\n```py\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        res = ListNode()\n        res.next = head.next\n        pre = res\n        while head and head.next:\n            p1 = head.next\n            p2 = p1.next\n            p1.next = head\n            pre.next = p1\n            head.next = p2\n            pre = head\n            head = p2\n        return res.next\n```\n***复杂度分析***\n时间复杂度：O(n), n 为原链表长度\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922270283","body":"### 思路\nUse two pointers to find the middle of the linked list. One pointer is faster than another, which while traversing the linked list, the faster pointer move twice (Listnode.next.next), and the slower pointer move once (Listnode.next), at the same time, we need to save the position of the slower pointer before its moving. After the traversing, the slower pointer is at the middle of the linked list, and we also save the position of the listnode before the middle listnode. Then, we break the linedlist into two parts before the middle, save the middle node into the tree. And adding the listnode before the middle to the left, adding the listnode after the middle to the right recursively. Finally, return the node (root).\n### 代码\n使用语言：Python3\n```py\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        slow = head\n        fast = head\n        slow_pre = None\n        while fast and fast.next:\n            fast = fast.next.next\n            slow_pre = slow\n            slow = slow.next\n        if slow_pre:\n            slow_pre.next = None\n        node = TreeNode(slow.val)\n        if fast == slow:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n***复杂度分析***\n时间复杂度：O(logn)\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922466320","body":"### 思路\nWe can use two pointers to traverse two Linkedlist. Let one pointer pA point at headA, and another pointer pB point at headB. Let them traverse the list at the same speed. While pA reach the end of the list, we let pA point to headB. Similarly, while pB reach the end of the list, we let pB point to headA. While pA and pB point the same listnode, it is the intersection node. If list A does not intersect with list B the final pointer pA and pB will still equal but they are equal to None. To prove this, why when pA meets pB they are pointing the intersection, we can have the following proof. Let listA be two parts, one part is before the intersection and its length is a1, and another be after the intersection and its length is a2, same to listB, the length for first part is b1 and second part length is b2. While pA and pB meet, pA passed a1 + a2 + b1, and pB passed b1 + b2 + a1, since after the intersection the length is the same (which implies that b2 = a2). Thus, for pA, it passed distance become a1 + b2 + b1, which is the same distance that pB passed. The proof is finished.\n### 代码\n使用语言：Python3\n```py\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        pA = headA\n        pB = headB\n        if pA == pB:\n            return pA\n        while pA != pB:\n            if pA != None:\n                pA = pA.next\n            else:\n                pA = headB\n            if pB != None:\n                pB = pB.next\n            else:\n                pB = headA\n        return pA\n```\n***复杂度分析***\n时间复杂度：O(m + n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"machuangmr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916600573","body":"### 思路\n-  1、将数组的最后一个元素和k的个位开始相加，\n-  2、大于等于10 就向前进一位（k的前一位 + 1）\n-  3、 重复以上步骤知道数组和k的位数结束\n\n### 代码\n- 语言：Java\n```java\nclass Solution {\n    // 思路： 1、将数组的最后一个元素和k的个位开始相加，\n    //       2、大于10 就向前进一位（k的前一位 + 1）\n     //        3、 重复以上步骤知道数组和k的位数结束\n    public List<Integer> addToArrayForm(int[] num, int k) {\n     List<Integer> rest = new LinkedList<>();\n    int len = num.length - 1;\n    for(int i = len;i >= 0;i--) {\n        int total = num[i] + k % 10;\n        //取除过后一位的前面的值\n        k /= 10;\n        if(total >= 10) {\n            //大于10，则前面的值需要进1\n            k++;\n            total = total % 10;\n        }\n        rest.add(total);\n    }\n    while(k > 0) {\n        rest.add(k % 10);\n        k /=10;\n    }\n     Collections.reverse(rest);\n     return rest;\n    }\n}\n\n````\n### 复杂度\n- 空间复杂度：O(1)\n- 时间复杂度 O max(num.length, k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917422620","body":"### 思路\r\n- 遍历数组，将目标字符的下标的存储起来\r\n- 遍历字符串，将当前下标和字符下表进行计算\r\n- 计算每个下标和目标的值的最小值\r\n\r\n### 语言\r\n- java\r\n````\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n         int[] arr = new int[s.length()];\r\n        List<Integer> list = new ArrayList<>();\r\n        char[] chars = s.toCharArray();\r\n        for(int i = 0;i < chars.length;i++) {\r\n            if (chars[i] == c) {\r\n                list.add(i);\r\n            }\r\n        }\r\n        for (int i = 0;i < s.length();i++) {\r\n\r\n            // Math.abs(i - )\r\n            int num = getMin(i, list);\r\n            arr[i] = num;\r\n        }\r\n        return arr;\r\n    }\r\n     private static int getMin(int i, List<Integer> list) {\r\n        int[] nums = new int [list.size()];\r\n        for (int j = 0;j < list.size();j++) {\r\n            nums[j] = Math.abs(i - list.get(j));\r\n        }\r\n        Arrays.sort(nums);\r\n        return nums[0];\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度O(n)\r\n### 缺点：\r\n时间复杂度太高，必须优化\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917602582","body":"### 思路： \r\n- 利用数组维护一个题目中的栈，\r\n- push 将元素添加到数组中\r\n- pop 返回数组中最后一个元素\r\n- inc 只需要注意边界问题就好\r\n### 语言\r\n- java\r\n\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n    \r\n    int maxSize; // 初始化的最大长度\r\n    int currentSize = -1;// 当前数组的长度，默认为 -1\r\n    int[] customStack = null;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        customStack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(currentSize == maxSize - 1) {\r\n            return;\r\n        }\r\n        customStack[++currentSize] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(currentSize == -1) {\r\n            return -1;\r\n        }\r\n        int val = customStack[currentSize];\r\n        currentSize--;\r\n        return val;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(currentSize <= k -1) {\r\n            for(int i = 0;i <= currentSize;i++) {\r\n                customStack[i] += val;\r\n            }\r\n        } else{\r\n            for(int i = 0;i < k;i++) {\r\n                customStack[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度： O(k)\r\n- 空间复杂度：O（N）N为初始化栈的大小，即额外数组的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917866218","body":"### 思路\n- 构造一个stack 结构\n- 将所有的数字、[、字母全部压入栈中\n- 遇到 ] 时，将栈中元素弹出，直至遇到[\n- 将元素按照字母和数字区分，并进行计算\n### 语言\n- java\n### 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n         Stack<String> s2 = new Stack();\n        for(int i = 0;i < s.length();i++) {\n            if (Character.isDigit(s.charAt(i))) {\n                s2.push(String.valueOf(s.charAt(i)));\n                continue;\n            }\n            if ('['==(s.charAt(i)) || Character.isLowerCase(s.charAt(i))) {\n                s2.push(String.valueOf(s.charAt(i)));\n                continue;\n            }\n            if (']'== s.charAt(i)) {\n                List<String> c = new ArrayList<>();\n                while(!s2.peek().equals(\"[\") ) {\n                    c.add(String.valueOf(s2.pop()));\n                }\n                s2.pop();\n                Collections.reverse(c);\n                // 求[ 前面的数字\n                List<String> str = new ArrayList<>();\n                while(!s2.isEmpty() && Character.isDigit(s2.peek().charAt(0))) {\n                    str.add(String.valueOf(s2.pop()));\n                }\n                Collections.reverse(str);\n                String tmp = getUsdString(str);\n                String appResult  = getUsdString(c);\n                StringBuilder sb = new StringBuilder();\n                int count = Integer.parseInt(tmp);\n                while(count-- > 0) {\n                    sb.append(appResult);\n                }\n                s2.push(sb.toString());\n            }\n        }\n        \n        \n        List<String> rest = new ArrayList<>();\n        while (!s2.isEmpty()) {\n            rest.add(s2.pop());\n        }\n        Collections.reverse(rest);\n        return getUsdString(rest);\n     }\n\n     private static String getUsdString(List<String> str) {\n         StringBuilder sb = new StringBuilder();\n         for (String s : str) {\n             sb.append(s);\n         }\n         return sb.toString();\n     }\n}\n````\n\n### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919114141","body":"### 思路：\r\n- 利用两个栈s1，s2\r\n- 栈的数据结构是先进后出\r\n- 队列的数据结构是先进先出\r\n- 利用两个栈可以将数据进行逆序\r\n### 语言：\r\n- Java\r\n### 代码\r\n```java\r\nclass MyQueue {\r\n\r\n    Stack<Integer> s1 = null;\r\n    Stack<Integer> s2 = null;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        s1 = new Stack();\r\n        s2 = new Stack();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n         s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n          if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n````\r\n###   复杂度\r\n- 空间复杂度：O(n)\r\n- 时间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920045568","body":"### 思路：\n- 维护一个单调栈，将数据压入栈中\n- 压入数据注意：压入每个块中的最大的值，最小的值弹出即可\n- 结果为栈的大小\n### 语言\n- java\n### 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n         Stack<Integer> stack = new Stack<>();\n        for (int num : arr) {\n            if (!stack.isEmpty() && num < stack.peek()) {\n                int current = stack.pop();\n                while(!stack.isEmpty() && num < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(current);\n            } else {\n                stack.push(num);\n            }\n        }\n        return stack.size();\n    }\n}\n````\n### 复杂度\n- 时间复杂度O(n)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920559466","body":"### 思路\n- 将链表遍历求其长度\n- 将链表的最后一个节点的next指针指向头节点，即构成一个环形链表\n- 然后将链表的的 length - k % length 个节点的next 指针置空，即断开链表\n### 语言\n- java \n### 代码\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n         if (head == null || head.next == null) {\n            return head;\n        }\n        int length = 1;\n        ListNode tmp = head;\n        while (tmp.next != null) {\n            length++;\n            tmp = tmp.next;\n        }\n        int count = length - (k % length);\n        if (count == length) {\n            return head;\n        }\n        tmp.next = head;\n        while(count > 0) {\n\n            tmp = tmp.next;\n              count--;\n        }\n        ListNode rest = tmp.next;\n        tmp.next = null;\n        return rest;\n    }\n}\n````\n### 复杂度\n- 空间复杂度 O(1)\n- 时间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921616040","body":"### 思路：\n- 使用一个虚拟节点，dummy.next = head，方便我们处理问题，返回结果的时候，只需要返回的dummy.next;\n- 则根据题意有 temp->first->sec， 需要转换为 temp->sec->first\n- 则有 first.next = sec.next, sec.next= first, temp.next= sed,最后再将first 赋值给temp，进行下一次循环\n### 语言\n- java\n### 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n          if(head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode temp = dummy;\n        while(temp.next != null && temp.next.next !=null) {\n            ListNode next = temp.next;\n            ListNode nextNext = temp.next.next;\n            next.next = nextNext.next;\n            nextNext.next = next;\n            temp.next = nextNext;\n            temp = next;\n        }\n        return dummy.next;\n\n    }\n}\n````\n### 复杂度\n- 时间复杂度： O(n)\n- 空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922248242","body":"### 思路\r\n- 遍历链表找到中间节点\r\n- 中间节点左边的即为左子树\r\n- 中间节点右边的即为右子树\r\n- 递归构建二叉搜索树\r\n### 语言\r\n- java\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head != null) {\r\n  // 递归思路：\r\n        ListNode fastPoint = head;\r\n        ListNode slowPoint = head;\r\n        ListNode pre = null;\r\n        // 利用快慢指针，快指针每次走二步，慢指针每次走一步，快指针到达链表末尾，则慢指针到中间节点\r\n        while(fastPoint != null && fastPoint.next != null) {\r\n            // if(fastPoint.next == null || fastPoint.next.next == null) {\r\n            //     break;\r\n            // }\r\n            pre = slowPoint;\r\n            fastPoint = fastPoint.next.next;\r\n            slowPoint = slowPoint.next;\r\n        }\r\n         // 递归构建右子树\r\n        TreeNode treeNode = new TreeNode(slowPoint.val);\r\n        treeNode.right = sortedListToBST(slowPoint.next);\r\n        if(pre != null) {\r\n           // 这里如果该节点为不为空，则断开该节点和后面节点的指针，递归构建左子树\r\n            pre.next = null;\r\n            treeNode.left = sortedListToBST(head);\r\n        }\r\n       \r\n        return treeNode;\r\n    }\r\n        return null;\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度O(NlogN)\r\n- 空间复杂度O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922474685","body":"### 思路:利用hash表\n-  将链表A遍历，将链表A加入到hash表集合中\n-  然后将链比B遍历，判断当前节点是否存在链表A当中\n- 如果链表中A中存在则证明有相交节点\n### 代码\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) {\n            return null;\n        }\n        Set<ListNode> nodeSet = new HashSet<>();\n        ListNode tempA = headA;\n        while(tempA != null) {\n            nodeSet.add(tempA);\n            tempA = tempA.next;\n        }\n        ListNode  tempB = headB;\n        while(tempB != null) {\n            if(nodeSet.contains(tempB)) {\n                return tempB;\n            }\n            tempB = tempB.next;\n        }\n        return null;\n    }\n}\n````\n### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gaozizhong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916600638","body":"# 思路\r\n把K从个位数开始分解成单个值与num从个位开始（倒序）相加，存入数组。\r\n要注意K位数高于num的情况。\r\n最后把结果数组进行反转即可得到正确答案。\r\n\r\n# 代码：Go\r\n```\r\nfunc addToArrayForm(num []int, k int) (result []int) {\r\n\tfor  i := len(num) - 1 ; i >= 0 ; i--{\r\n\t\tsum := num[i] + k % 10\r\n\t\tk /= 10\r\n\t\tif sum >= 10{\r\n\t\t\tk ++\r\n\t\t\tsum -= 10\r\n\t\t}\r\n\t\tresult = append(result, sum)\r\n\t}\r\n\tfor ; k > 0; k /= 10 {\r\n\t\tresult = append(result, k % 10)\r\n\t}\r\n\treverse(result)\r\n\treturn result\r\n}\r\n\r\nfunc reverse(result []int) {\r\n\tfor i, n := 0, len(result); i < n/2; i++{\r\n\t\tresult[i], result[n-1-i] = result[n-1-i], result[i]\r\n\t}\r\n}\r\n```\r\n\r\n# 时间复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918266986","body":"#### 思路\r\n\r\n字符串从前到后用栈进行处理\r\n\r\n* 如果是数字，左括号，字母的话，直接入栈\r\n* 如果是右括号的话，直接把栈中最近左括号前的字母出栈，反转后乘以左括号前的数字\r\n* 以此类推，直到最后\r\n\r\n#### 代码：Go\r\n\r\n```go\r\nfunc decodeString(s string) string {\r\n    stack := []string{}\r\n    pointer := 0\r\n    for pointer < len(s) {\r\n        current := s[pointer]\r\n        if current >= '0' && current <= '9' {\r\n            digits := getDigits(s, &pointer)\r\n            stack = append(stack, digits)\r\n        } else if (current >= 'a' && current <= 'z') || (current >= 'A' && current <= 'Z') || current == '[' {\r\n            stack = append(stack, string(current))\r\n            pointer++\r\n        } else {\r\n            pointer++\r\n            sub := []string{}\r\n            for stack[len(stack)-1] != \"[\" {\r\n                sub = append(sub, stack[len(stack)-1])\r\n                stack = stack[:len(stack)-1]\r\n            }\r\n            for i := 0; i < len(sub)/2; i++ {\r\n                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n            }\r\n            stack = stack[:len(stack)-1]\r\n            repTime, _ := strconv.Atoi(stack[len(stack)-1])\r\n            stack = stack[:len(stack)-1]\r\n            t := strings.Repeat(getString(sub), repTime)\r\n            stack = append(stack, t)\r\n        }\r\n    }\r\n    return getString(stack)\r\n}\r\n\r\nfunc getDigits(s string, pointer *int) string {\r\n    digits := \"\"\r\n    for ; s[*pointer] >= '0' && s[*pointer] <= '9'; *pointer++ {\r\n        digits += string(s[*pointer])\r\n    }\r\n    return digits\r\n}\r\n\r\nfunc getString(v []string) string {\r\n    result := \"\"\r\n    for _, s := range v {\r\n        result += s\r\n    }\r\n    return result\r\n}\r\n```\r\n\r\n#### 时间复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920736242","body":"#### 思路\r\n\r\n* 求链表长度\r\n* 若链表长度小于移动次数，求余得N，即只需移动N次即可\r\n* 求单链表的倒数第 N 个节点，把第N个节点变成头节点即可\r\n\r\n\r\n\r\n#### 代码：Go\r\n\r\n```go\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    if head == nil || k == 0{\r\n        return head\r\n    }\r\n    tail := head\r\n    count := 0\r\n    for tail.next != nil{\r\n        count++  \r\n        tail = tail.Next\r\n    }\r\n    n := k % count\r\n    if n == 0{\r\n        return head\r\n    }\r\n    index := 0\r\n    new_tail := head\r\n    for index != count-n{\r\n        index++\r\n        new_tail = new_tail.Next\r\n    }\r\n    new_head := new_tail.Next\r\n    tail.Next = head\r\n    new_tail.Next = nil\r\n    \r\n    return new_head\r\n    \r\n}\r\n```\r\n\r\n#### 时间复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921778124","body":"#### 思路\r\n\r\n* 如果链表是空链表或只有一个节点，返回原来的值即可\r\n* 设置两个指针right和left,放到前两个节点。\r\n* right和left所指的节点进行交换，然后后移两个节点，如果不够两个节点，就可以退出返回了，如果够两个节点，就继续重复此步骤。\r\n\r\n#### 代码：Go\r\n\r\n```go\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    dummyHead := &ListNode{0, head}\r\n    temp := dummyHead\r\n    if temp.Next != nil && temp.Next.Next != nil{\r\n        left := temp.Next\r\n        right := temp.Next.Next\r\n        temp.Next = right\r\n        left.Next = right.Next\r\n    \tright.Next = left\r\n        temp = left\r\n    }\r\n    return dummyHead.Next\r\n}\r\n```\r\n\r\n#### 时间复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wang-hejie":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916601021","body":"## <font color=#A0522D>思路</font>\r\n\r\n从数组末尾开始往前遍历，每一位先和 k 相加。\r\n相加的和 %10 就是这一位应有的数值，相加的和 整除10 就是下一位的 k 。\r\n\r\n<font color=red>**注意：**</font>如果数组遍历结束后， k 仍然不为 0 ，那么需要将剩下的 k 加入到数组开头\r\n\r\n## <font color=#A0522D>复杂度</font>\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n\r\n## <font color=#A0522D>代码(Python3)</font>\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for i in range(len(num)-1, -1, -1):\r\n            k_add_num = num[i] + k\r\n            num[i] = k_add_num % 10\r\n            k = k_add_num // 10\r\n            # 提前退出循环的trick\r\n            if not k:\r\n                break\r\n        \r\n        if k:\r\n            while k:\r\n                num.insert(0, k % 10)\r\n                k = k // 10\r\n        \r\n        return num\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917325824","body":"## 思路\n\n先从左到右遍历s字符串数组，更新ans数组。记录当前遍历到最新的字符c下标prev。对于ans的第i个位置，它与它左侧最近字符c的距离是<font color=red>i - prev</font>。遍历结束后，**ans记录每一个位置距离它左侧字符c的最近距离。**\n\n再从右到左遍历s字符串数组，更新ans数组。记录当前遍历到最新的字符c下标prev。对于ans的第i个位置，它与它右侧最近字符c的距离是<font color=red>**prev - i，从prev - i和已经存放的i - prev中选择小的那个存入ans[i]。**</font>遍历结束后，ans记录每一个位置距离字符c的最近距离。\n\n<font color=red>注意：</font>从左到右遍历时，prev初始化成-inf；从右到左遍历时，prev初始化成inf。\n\n## 复杂度\n\n- 时间复杂度：O(n)，遍历了2遍s字符串\n- 空间复杂度：O(n)，n为ans数组大小\n\n## 代码(Python)\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        prev = float('-inf')\n        # 从左向右遍历\n        for i, char in enumerate(s):\n            if char == c:\n                prev = i\n            ans.append(i - prev)\n        \n        # 从右向左遍历\n        prev = float('inf')\n        for i in range(len(ans)-1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], prev - i)\n        \n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917653417","body":"## <font color=#A0522D>思路</font>\n\n空间换时间。我们实际上只在出栈时关心栈中的值，因此“栈底的 k 个元素的值都增加 val ”这一功能没必要真的去栈里花线性时间加，可以用一个hashmap暂存，其中键为需要加的最后一位元素的下标，值为需要加的 val 。要出栈时，就去hashmap里看一下当前元素是否需要加 val 即可。\n<font color=red>注意：</font>当一个元素出栈时若需要加 val ，当它出栈完毕后，需要更新hashmap，使它对应的键值对中的键-1。\n\n## <font color=#A0522D>复杂度</font>\n\n- 时间复杂度：`push`，`pop`和`inc`都是O(1)\n- 空间复杂度：O(n)，模拟栈的列表和hashmap的大小都是n\n\n## <font color=#A0522D>代码(Python)</font>\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.inc_dict = dict()  # 记录inc状态的hashmap\n        self.max_size = maxSize\n        self.size = 0\n\n    def push(self, x: int) -> None:\n        if self.size < self.max_size:\n            self.stack.append(x)\n            self.size += 1\n\n    def pop(self) -> int:\n        if not self.size:\n            return -1\n        self.size -= 1\n        pop_rslt = self.stack.pop()\n        if self.inc_dict.get(self.size):\n            pop_rslt += self.inc_dict[self.size]\n            # 更新inc_dict\n            if self.inc_dict.get(self.size-1):\n                self.inc_dict[self.size-1] += self.inc_dict[self.size]\n            else:\n                self.inc_dict[self.size - 1] = self.inc_dict[self.size]\n            self.inc_dict.pop(self.size)\n        return pop_rslt\n\n    def increment(self, k: int, val: int) -> None:\n        stop_limit = min(len(self.stack)-1, k-1)\n        if self.inc_dict.get(stop_limit):\n            self.inc_dict[stop_limit] += val\n        else:\n            self.inc_dict[stop_limit] = val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917919092","body":"## <font color=#A0522D>思路1</font>\n\n**利用栈思想解决。**\n1. 遍历字符串s。\n2. 字符依次入栈，直到遇到右括号 ']' 停下。\n3. 字符依次出栈，直到遇到左括号 '[' 停下，将刚才出栈的字符逆序排列成字符串string。\n4. 从栈中弹出紧邻左括号 '[' 左边的数字，直到不是数字停下，将数字逆序排列成整数n。\n5. 这组括号内的字符串最终为n遍string，压入栈中\n6. 继续1)\n\n## <font color=#A0522D>复杂度1</font>\n\n- 时间复杂度：O(S)，入栈要遍历一遍原始字符串s，出栈相当于遍历一遍解析后字符串S，S>=s\n- 空间复杂度：O(S)，S是解析后字符串长度\n\n## <font color=#A0522D>代码1(Python)</font>\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char != ']':\n                stack.append(char)\n            else:\n                temp_list_str = []\n                while True:\n                    if stack[-1] == '[':\n                        stack.pop()\n                        break\n                    temp_list_str.append(stack.pop())\n                temp_list_str.reverse()\n                temp_list_num = []\n                while True:\n                    if not stack or not stack[-1].isdigit():\n                        break\n                    temp_list_num.append(stack.pop())\n                temp_list_num.reverse()\n                temp_num = ''.join(temp_list_num)\n                temp_str = ''.join(temp_list_str) * int(temp_num)\n                stack.append(temp_str)\n        return ''.join(stack)\n```\n\n---\n\n## <font color=#A0522D>思路2</font>\n**递归思想解决**\n\n**递归入口：**\n从头开始遍历字符串s。最外层保存一个解析串decoded和一个计数器cnt，当遇到普通字符时，添加到decoded后面；当遇到数字时，添加到cnt后面；当遇到左括号 '[' 时，陷入下一层递归。\n下一层也新保存一个解析串decoded和一个计数器cnt，当遇到普通字符时，添加到decoded后面；当遇到数字时，添加到cnt后面；当遇到左括号 '[' 时，再陷入下一层递归。\n\n**递归出口：**\n当遇到右括号 ']' 时，递归结束，返回2个东西：当前这一层括号内的模式串pattern，以及当前右括号的下一个下标index。\n回到上一层，在陷入递归的地方拿到pattern和index。该层的解析串decoded后面添加pattern * cnt，重置cnt为空，并把遍历字符串s的指针跳到index位置。\n\n## <font color=#A0522D>复杂度2</font>\n\n- 时间复杂度：O(S)，最外层要遍历一遍原始字符串s，内层加在一起要遍历一遍解析后字符串S，S>=s\n- 空间复杂度：O(S)，S是解析后字符串长度\n\n## <font color=#A0522D>代码2(Python)</font>\n```python\nclass Solution:\n    def decodeString(self, s:str, i = 0) -> str:\n        decoded = ''\n        cnt = ''\n    \n        while i < len(s):\n            # 普通字符，直接拼接到decoded后面\n            if s[i].isalpha():\n                decoded += s[i]\n                i += 1\n            # 普通数字，直接拼接到cnt后面\n            elif s[i].isdigit():\n                cnt += s[i]\n                i += 1\n            # 左括号 '[' ，将括号内的字符串重复cnt次，再拼接到decoded后面\n            # 注意：括号内可能还会嵌套括号，要递归处理\n            elif s[i] == '[':\n                # 需要从递归中取2个东西：括号内的模式串，以及右括号的下一个下标index\n                pattern, index = self.decodeString(s, i+1)\n                pattern = pattern * int(cnt)  # 重复cnt次\n                decoded += pattern  # 拼接到decoded上\n                cnt = ''  # 重置计数器cnt\n                i = index\n            # 右括号 ']'，说明括号内的模式解析完毕\n            # 递归结束，返回需要的2个东西：括号内的模式串，以及右括号的下一个下标index\n            elif s[i] == ']':\n                return decoded, i + 1\n        return decoded\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918721752","body":"## <font color=#A0522D>思路</font>\n\n使用2个栈stack和inverse_stack。stack存放正序队列，但因为栈只能从尾pop，因此在队列pop时需要借助另一个栈inverse_stack。\n队列pop时，将stack栈依次弹出并压到inverse_stack中，此时inverse_stack内存放逆序队列，栈顶即为队头。这样之后队列pop和peak都是O(1)，直到inverse_stack中的元素pop空了，下一次pop就再将stack内的元素压过来。\n<font color=red>注意：</font>若队列push，直接压进stack就好，不用管当前inverse_stack的情况。\n\n## <font color=#A0522D>复杂度</font>\n\n- 时间复杂度：`push`为O(1)；`pop`和`peek`在inverse_stack为空时为O(n)，不为空时为O(1)，均摊为O(1)\n- 空间复杂度：O(n)，n为入栈元素个数\n\n## <font color=#A0522D>代码</font>\n\n```python\nfrom typing import *\n\n\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.inverse_stack = []\n        self.size = 0\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.size += 1\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.empty():\n            return None\n        if not len(self.inverse_stack):\n            self._stack_exchange(self.stack, self.inverse_stack)\n        self.size -= 1\n        return self.inverse_stack.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.empty():\n            return None\n        if not len(self.inverse_stack):\n            self._stack_exchange(self.stack, self.inverse_stack)\n        return self.inverse_stack[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if not self.size:\n            return True\n        else:\n            return False\n\n    def _stack_exchange(self, a: List, b: List) -> None:\n        for i in range(len(a)):\n            b.append(a.pop())\n\n\nif __name__ == '__main__':\n    my_queue = MyQueue()\n    my_queue.push(1)\n    my_queue.push(2)\n    my_queue.push(3)\n    param_2 = my_queue.pop()\n    param_3 = my_queue.peek()\n    param_4 = my_queue.empty()\n    print(f'param_2 = {param_2}\\n'\n          f'param_3 = {param_3}\\n'\n          f'param_4 = {param_4}')\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920702192","body":"## <font color=#A0522D>思路</font>\n\n先把链表尾接上头，形成一个环形链表，再把原来的头向左移动 k mod n 个节点 **(向左移动 k mod n 个节点 = 向右移动 n - (k mod n) 个节点，n 为总节点数)**，最后断开就可以了。\n\n## <font color=#A0522D>复杂度</font>\n\n- 时间复杂度：**O(n)**，n 为链表总节点数。\n- 空间复杂度：**O(1)**，不额外使用内存\n\n## <font color=#A0522D>代码</font>\n\n```python\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return None\n        # 先找到链表尾部。两个目的：\n        # 1. 把链表尾部.next 接到 head 上\n        # 2. 计算链表总结点数 node_num\n        p = head\n        node_num = 1  # 链表总结点数\n        while p.next:\n            node_num += 1\n            p = p.next\n        p.next = head  # 链表尾部.next 接到 head 上\n\n        # 现在需要 head 向左移动 (k mod node_num) 个节点\n        # 向左移动 (k mod node_num) 个节点 = 向右移动 node_num - (k mod node_num) 个节点\n        p = head\n        for _ in range(node_num - (k % node_num) - 1):\n            p = p.next\n        head = p.next\n        p.next = None\n\n        return head\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Francis-xsc":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916601314","body":"### 思路\n\n模拟加法，从个位开始加，如有进位，k--（用变量表示进位有点复杂）\n最后反转\n\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len=num.size();\n        vector<int>ans;\n        for(int i=len-1;i>=0;--i)\n        {\n            int t=num[i]+(k%10);\n            k/=10;\n            if(t>=10)\n            {\n                t%=10;\n                k++;\n            }\n            ans.push_back(t);\n        }\n        while(k)\n        {\n            ans.push_back(k%10);\n            k/=10;\n        };\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)，其中 N 为数组长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917319149","body":"### 思路\n\n从前到后扫一遍，再从后到前扫一遍，取较小值\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int p=-100000,len=s.length();\n        vector<int> ans(len);\n        for(int i=0;i<len;++i)\n        {\n            if(s[i]==c)\n                p=i;\n            ans[i]=i-p;\n        }\n        p=INT_MAX;\n        for(int i=len-1;i>=0;--i)\n        {\n             if(s[i]==c)\n                p=i;\n            ans[i]=ans[i]<p-i?ans[i]:p-i;\n        }\n        return ans;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N =s.len。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917559772","body":"### 思路\n\n数组模拟栈\n\n### 代码\n\n\n```cpp\n\nclass CustomStack {\nprivate:\n    int *s;\n    int pos;\n    int max;\npublic:\n    CustomStack(int maxSize) {\n        s=new int[maxSize];\n        pos=0;\n        max=maxSize;\n    }\n    \n    void push(int x) {\n        if(pos==max)\n            return;\n        s[pos++]=x;\n    }\n    \n    int pop() {\n        if(pos==0)\n            return -1;\n        return s[--pos];\n    }\n    \n    void increment(int k, int val) {\n        k=k<pos?k:pos;\n        for(int i=0;i<k;++i)\n            s[i]+=val;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：push(),pop():O(1) increment:O(N)，N=min(k,size())。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917745429","body":"### 思路\n\n两个栈\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int>num;\n        stack<string>str;\n        str.push(\"\");\n        int cnt=0,len=s.size();\n        for(int i=0;i<len;i++)\n        {\n            if(isdigit(s[i]))\n                cnt=cnt*10+s[i]-'0';\n            else if(isalpha(s[i]))\n                str.top()+=s[i];\n            else if(s[i]=='[')\n            {\n                str.push(\"\");\n                num.push(cnt);\n                cnt=0;\n            }\n            else if(s[i]==']')\n            {\n                int n=num.top();\n                num.pop();\n                string t=str.top();\n                str.pop();\n                for(int i=0;i<n;i++)\n                    str.top()+=t;\n            }\n        }\n        return str.top();\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918714880","body":"### 思路\n\n利用两个站栈模拟队列，其中一个栈的栈顶为队列头，另一个栈为辅助栈\n\n### 代码\n\n\n```cpp\n\nclass MyQueue {\nprivate:\n    stack<int>a,b;\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        while(!a.empty())\n        {\n            int t=a.top();\n            b.push(t);\n            a.pop();\n        }\n        a.push(x);\n        while(!b.empty())\n        {\n            int t=b.top();\n            a.push(t);\n            b.pop();\n        }\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        int t=a.top();\n        a.pop();\n        return t;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        return a.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return a.empty();\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：push():O(N)，pop()、peek()、empty():O(1)。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919647249","body":"### 思路\n\n单调栈，结果为单调栈的长度\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>s;\n        for(int x:arr)\n        {\n            if(s.empty()||x>=s.top())\n                s.push(x);\n            else{\n                int t=s.top();\n                while(!s.empty()&&s.top()>x)\n                    s.pop();\n                s.push(t);\n            }\n        }\n        return s.size();\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920506019","body":"### 思路\n\n快慢指针\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head||!head->next||k==0)\n            return head;\n        ListNode* fast=head,*slow=head;\n        int total=1;\n        while(fast->next)\n        {\n            fast=fast->next;\n            total++;\n        }\n        k%=total;\n        fast=head;\n        for(int i=0;i<k;i++)\n            fast=fast->next;\n        while(fast->next)\n        {\n            slow=slow->next;\n            fast=fast->next;\n        }\n        fast->next=head;\n        fast=slow->next;\n        slow->next=nullptr;\n        return fast;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921363787","body":"### 思路\n\n迭代：改变指针指向，注意保存前面的结点，注意保存新的头节点\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head||!head->next)\n            return head;\n        ListNode *ptr1=head,*ptr2=head->next,*ptr3=new ListNode(0,ptr1),*head_=ptr2;\n        while(ptr1&&ptr2&&ptr3)\n        {\n            ptr1->next=ptr2->next;\n            ptr2->next=ptr1;\n            ptr3->next=ptr2;\n            ptr3=ptr1;\n            ptr1=ptr1->next;\n            if(ptr1)\n                ptr2=ptr1->next;\n        }\n        return head_;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为链表长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922156750","body":"### 思路\r\n\r\n快慢指针法找中点，递归构造树\r\n\r\n### 代码\r\n\r\n\r\n```cpp\r\n\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        return create(head,nullptr);\r\n    }\r\n    ListNode* findMiddleNode(ListNode* left,ListNode* right){\r\n        ListNode* fast=left,*slow=left;\r\n        while(fast!=right&&fast->next!=right)\r\n        {\r\n            fast=fast->next->next;\r\n            slow=slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n    TreeNode* create(ListNode* left,ListNode* right){\r\n        if(left==right)\r\n            return nullptr;\r\n        ListNode* mid=findMiddleNode(left,right);\r\n        return new TreeNode(mid->val,create(left,mid),create(mid->next,right));\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(nlogN)\r\n- 空间复杂度：O(nlogN)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922402595","body":"### 思路\n\n双指针\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* a=headA,*b=headB;\n        while(a!=b)\n        {\n            a=a->next;\n            b=b->next;\n            if(!a&&!b)\n                return nullptr;\n            if(!a)\n                a=headB;\n            if(!b)\n                b=headA;\n        }\n        return a;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N=两链表长度和-相交部分长度。\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iambigchen":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916602214","body":"### 思路\n大数相加 每个位置相加，如果大于9，向前进一位\n\n### 代码\n```js\nvar addToArrayForm = function(num, k) {\n    k = String(k).split('')\n    var length = Math.max(num.length, k.length)\n    var res = new Array(length).fill(0)\n    for (let index = length-1; index >= 0; index--) {\n        var a = num.length > 0 ? num.pop() : 0\n        var b  = k.length > 0 ?  k.pop() : 0\n        var sum = res[index] + a + +b\n        res[index] = sum % 10\n        if (sum > 9) {\n            if (index-1 >= 0) {\n                res[index - 1] = 1\n            } else {\n                res.unshift(1)\n            }\n        }\n    }\n    return res\n};\n```\n\n### 复杂度\n\n时间： O(n)\n空间： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917378714","body":"### 思路\n遍历S，在每一项向左和右逐步添加，判断是否等于c，如果等于c就是最短距离\n\n### 代码\n```js\nvar shortestToChar = function(s, c) {\n    let res = []\n    for (let index = 0; index < s.length; index++) {\n       let diff = 0\n       while ((index-diff >=0 || diff+index < s.length) && s[index-diff] !== c && s[diff + index] !== c) {\n           diff++\n       }\n       res.push(diff)\n    }\n    \n    return res\n};\n```\n\n### 复杂度\n时间复杂度 O(n^2)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917591095","body":"### 思路\n用数组存储数据\n\n### 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.val = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.val.length < this.maxSize) {\n        this.val.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.val.length === 0) {\n        return -1\n    }\n    return this.val.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(var i =0; i< k;i++) {\n        if (i < this.val.length) {\n            this.val[i] = this.val[i] + val\n        }\n    }\n};\n```\n\n### 复杂度\n时间复杂度 O(n)\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918203886","body":"### 思路\n遍历s, 如果遇到数字和字符串，拼接起来，遇到`[` 则把拼接后的数字和字符串存起来，遇到`]`则把存起来的数字和字符串取出来，用数字倍数拼接字符串\n\n### 代码\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let repeatNum = []\n    let repeatStr = []\n    let str = ''\n    let num = ''\n    for (const c of s) {\n        if (!isNaN(c)) {\n            num += c\n        } else if (c ==='[') {\n            repeatStr.push(str)\n            repeatNum.push(Number(num))\n            str = '' \n            num = ''\n        } else if (c === ']') {\n            str = repeatStr.pop() + str.repeat(repeatNum.pop())\n        } else {\n            str += c\n        }\n    }\n    return str\n};\n```\n\n### 复杂度\n时间复杂度O(n)\n空间复杂度O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918742998","body":"### 思路\n用两个栈模拟队列，一个用于存，另外一个用于取值。在对队列取值时，遍历存值栈，把存值栈依次取出，放入取值栈，此时取值栈完成了反转。队列的pop和peek时，只需要获取取值栈的尾部即可\n\n### 代码\n```js\n/*\n * @lc app=leetcode.cn id=232 lang=javascript\n *\n * [232] 用栈实现队列\n */\n\n// @lc code=start\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.inStack = []\n    this.outStack = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this.outStack.length === 0) {\n        while(this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    return this.outStack.pop()\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this.outStack.length === 0) {\n        while(this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    var i  = this.outStack.pop()\n    this.outStack.push(i)\n    return i\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.inStack.length === 0 && this.outStack.length === 0\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n// @lc code=end\n```\n\n### 复杂度\n时间复杂度     push O(1)     pop O(n)    peek  O(n)   empty O(1)\n空间复杂度     push O(n)     pop O(1)    peek  O(1)   empty O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920146388","body":"### 思路\n一开始是比较原数组和排序后的数组计数信息一致来做的，但是写的有问题，一直报超时。后来仿着老师的第二种解法单调栈写了出来。\n\n### 代码\n```js\nlet stack = []\n  for (let i =0; i<arr.length;i++) {\n      if (stack.length === 0) {\n          stack.push(arr[i])\n          continue\n      }\n      if (stack[stack.length-1] <= arr[i]) {\n          stack.push(arr[i])\n      } else {\n          const cur = stack[stack.length - 1];\n          while(stack[stack.length-1] > arr[i] && stack.length) {\n              stack.pop()\n          }\n          stack.push(cur)\n      }\n  }\n  return  stack.length\n```\n\n### 复杂度\n时间复杂度： O(n)\n空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920211426","body":"### 思路\n用快慢指针，分别指到最后一个和倒数第k个。此时，慢指针的next即为head，将慢指针next指成null， 快指针指到head。\n\n### 代码\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head || !head.next) return head;\n    let length = 0\n    let cur = head\n    while(cur) {\n        cur = cur.next\n        length++\n    }\n    k = k % length\n    if (!k) {\n        return head\n    }\n    let fast = head\n    let slow = head\n    \n    while(k > 0) {\n        fast = fast.next\n        k--\n    }\n    while(fast.next) {\n        fast = fast.next\n        slow = slow.next\n    }\n    let res = slow.next\n    slow.next = null\n    fast.next = head;\n    return res\n};\n```\n\n### 复杂度\n时间复杂度 O(n)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921654846","body":"### 思路\r\n用两个虚拟指针，分别指向需要交换的两个节点的前后，用于辅助交换。\r\n\r\n### 代码\r\n```js\r\n/*\r\n * @lc app=leetcode.cn id=24 lang=javascript\r\n *\r\n * [24] 两两交换链表中的节点\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) return head;\r\n    let cur = head\r\n    let res = head.next\r\n    let pre = new ListNode()\r\n    pre.next = head\r\n\r\n    while(cur && cur.next) {\r\n        let next = cur.next\r\n        let nn = next.next\r\n\r\n        cur.next = nn\r\n        pre.next = next\r\n        next.next = cur\r\n\r\n        pre = cur\r\n        cur = nn\r\n    }\r\n\r\n    return res\r\n};\r\n// @lc code=end\r\n\r\n\r\n```\r\n\r\n### 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922231952","body":"### 分析\n使用快慢指针，找到链表的中间节点。中间节点即为树的根节点，递推构建中间节点左边和右边的子树\n\n### 代码\n```js\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if (!head) return null\n    return dfs(head, null)\n};\n\nfunction dfs (head, tail) {\n    if (head === tail) return null\n    let fast = head\n    let slow = head\n    while(fast != tail && fast.next != tail) {\n        fast = fast.next.next\n        slow = slow.next\n    }\n    let res = new TreeNode(slow.val)\n    res.left = dfs(head, slow)\n    res.right = dfs(slow.next, tail)\n    return res\n}\n// @lc code=end\n```\n\n### 复杂度\n时间复杂度 O(NlogN)\n空间复杂度 O(longN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922435122","body":"### 思路\n同时遍历两个链表，用相同速度。如果一个链表遍历结束则指向另外一个链表的表头。另外一个链表也是如此。这样如果两个链表在某点相遇，则该点就是相交点起始点\n\n### 代码\n```js\nvar getIntersectionNode = function(headA, headB) {\n    let curA = headA\n    let curB = headB\n    let flagA = true\n    let flagB = true\n    while(curA !== curB) {\n        if (!curA.next && flagA) {\n            flagA = false\n            curA = headB\n        } else {\n            curA = curA.next\n        }\n        if (!curB.next && flagB) {\n            flagB = false\n            curB = headA\n        } else {\n            curB = curB.next\n        }\n    }\n    return curA\n};\n```\n\n### 复杂度\n时间复杂度 O(N)\n\n空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Cartie-ZhouMo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916605114","body":"### 思路\r\n从低位到高位遍历num、k，求和，注意进位。如果 k > A，需将剩余数字转换并插到num前。\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        if k == 0: return num\r\n        flag = 0\r\n        for i in range(len(num)-1, -1, -1):\r\n            k, b = k//10, k%10\r\n            num[i], flag = (num[i] + b + flag)%10, (num[i] + b + flag)//10\r\n        tmp = []\r\n        k += flag\r\n        while k:\r\n            k, n = k//10, k%10\r\n            tmp.append(n)\r\n        return tmp[::-1] + num\r\n```\r\n**复杂度分析**\r\n- 时间：O(max(n, K)) K = k的位数, N = len(num)\r\n- 空间：O(max(1, K-n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917384183","body":"### 思路\n暴力法。遍历字符串，每个字符向左、右寻找最近的c。\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        for ind, ss in enumerate(s):\n            if ss == c:\n                ans.append(0)\n            else:\n                i = 1\n                dis = inf\n                while i <= ind:\n                    if s[ind-i] == c:\n                        dis = i\n                        break\n                    else:\n                        i += 1\n                i = 1\n                while i < len(s) - ind:\n                    if s[ind+i] == c:\n                        dis = min(dis, i)\n                        break\n                    else:\n                        i += 1\n                ans.append(dis)\n        return ans\n```\n**复杂度**\n- 时间：O(N^2) N=len(s)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917596641","body":"### 思路\npython list模拟栈，pop时判断长度是否=0，push时判断长度是否=maxSize。inc时判断k与长度关系。\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        self.len = 0\n\n\n    def push(self, x: int) -> None:\n        if self.len < self.maxSize:\n            self.stack.append(x)\n            self.len += 1\n\n\n    def pop(self) -> int:\n        if self.len == 0:\n            return -1\n        else:\n            self.len -= 1\n            return self.stack.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i < self.len:\n                self.stack[i] += val\n```\n**复杂度**\n- 时间：pop、push O(1), inc O(min(k, len))\n- 空间：O(len)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917786133","body":"### 思路\n遇到'['时，栈内保存当前子串和倍数。遇到']'时，弹出栈顶并与当前子串组合。\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        ans = ''\n        num = 0\n        for c in s:\n            if '0' <= c <= '9':\n                # 注意数字位数\n                num = num*10 + int(c)\n            elif c == '[':\n                stack.append((num, ans))\n                ans = ''\n                num = 0\n            elif c == ']':\n                cnt, tmp_str = stack.pop()\n                ans = tmp_str + ans*cnt\n            else:\n                ans += c\n        return ans\n```\n**复杂度**\n- 时间：O(N)\n- 空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918769131","body":"### 思路\n用两个栈模拟队列，入队同栈。出队时，借助辅助栈，先将数据放入辅助栈，此时队头在栈顶，出队，然后将数据放回去。\n### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.stack1 == []:\n            return None\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        x = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return x\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack1[0] if self.stack1 else None\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return self.stack1 == []\n```\n**复杂度**\n- 时间：push、peek O(1)，pop O(N)\n- 空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919643139","body":"### 思路\n维护一个单调栈，保存每块的最大值。\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for a in arr:\n            if stack and a < stack[-1]:\n                # 当前块最大值\n                ma = stack[-1]\n                # 若a<ma 表明a也在此块内\n                while stack and a < stack[-1]:\n                    stack.pop()\n                stack.append(ma)\n            else:\n                stack.append(a)\n        return len(stack)\n```\n**复杂度**\n- 时间：O(N)\n- 空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920508797","body":"### 思路\n先求链表长度len，k=k%len，之后将倒数第k个节点作为新的链表头，断开倒数第k+1与倒数第k个节点。\n### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        p = head\n        l = 1\n        while p.next:\n            p = p.next\n            l += 1\n        p.next = head\n        k = k % l\n        q = head\n        for i in range(l - k - 1):\n            q = q.next\n        head = q.next\n        q.next = None\n        return head\n```\n**复杂度**\n- 时间：O(N)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921630064","body":"### 思路\n使用虚拟头结点便于返回。q节点是待交换两节点的前一个，每次交换并移动q。nex节点是待交换两节点的后一个，注意保存避免交换后丢失。\n### 代码\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next: return head\n        p = ListNode(next=head)\n        q = p\n        while q.next and q.next.next:\n            q1 = q.next\n            q2 = q.next.next\n            q.next = q2\n            nex = q2.next\n            q2.next = q1\n            q = q1\n            q.next = nex\n        return p.next\n```\n**复杂度**\n- 时间：O(N)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922304017","body":"### 思路\n链表中点作为根，递归建立左右子树。注意叶节点的情况。\n### 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head: return None\n        # 找中点作为根 slow\n        fast = slow = head\n        # 断点\n        pre = None\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n\n        root = TreeNode(slow.val)\n        if fast == slow:\n            return root\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n```\n**复杂度**\n- 时间：O(nlogn)\n- 空间：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922426131","body":"### 思路\n先遍历两链表并求出长度，若最后未走到同一点说明未相交。否则，利用长度，令长的链表先走，之后两个一起走，相等即为交点。\n### 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        l1, l2 = 0, 0\n        a = headA\n        b = headB\n        while a:\n            l1 += 1\n            a = a.next\n        while b:\n            l2 += 1\n            b = b.next\n        # 不相交\n        if a != b:\n            return None\n        a = headA if l1 > l2 else headB\n        b = headB if l1 > l2 else headA\n        for i in range(abs(l1-l2)):\n            a = a.next\n        while a != b:\n            a = a.next\n            b = b.next\n        return a\n        # 参考题解 思路更简洁\n        # a = headA\n        # b = headB\n        # while a != b:\n        #     a = a.next if a else headB\n        #     b = b.next if b else headA\n        # return a\n```\n**复杂度**\n- 时间：O(N)\n- 空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ningli12":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916605335","body":"### **思路**\r\n- 从k的个位开始，从num最后一位开始加，用carry记录进位\r\n- 在下一位计算的时候算上carry值并更新carry值, k也需要更新。\r\n- 需要处理carry > 0的情况，在高一位的计算中加carry\r\n- 反转结果\r\n\r\n### **代码**\r\n\r\n- 使用代码: Java\r\n\r\n```\r\nclass Solution {\r\n        public List<Integer> addToArrayForm(int[] num, int k) {\r\n            List<Integer> res = new ArrayList<>();\r\n            if(num == null) return res;\r\n            int carry = 0;\r\n            int size = num.length -1;\r\n            while(k > 0 || size >= 0){\r\n                int curNum = size >= 0? num[size] : 0;\r\n                int curK = k % 10;\r\n                int curSum = curNum + curK + carry;\r\n                int curAdd = curSum % 10;\r\n                carry = curSum / 10;\r\n                size--;\r\n                k = k/10;\r\n                res.add(curAdd);\r\n            }\r\n            if(carry > 0) {\r\n                res.add(carry);\r\n            }\r\n            Collections.reverse(res);\r\n            return res;\r\n        }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n- 时间复杂度：O(max(n, log k))，其中n为数组的长度\r\n- 空间复杂度：O(max(n, log k)。使用的空间为数组和k的最大长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917220140","body":"## 思路 - Array遍历\r\n- 初始化result array.\r\n- 两次遍历\r\n- 第一次从左到右，遇到c，将其右边的依次从 i - pre。 pre不会超过Array的长度\r\n- 第二次从右到左，遇到c，将其左边 i - pre 比较并取min；\r\n\r\n## 代码\r\n```\r\nclass Solution {\r\n  public int[] shortestToChar(String S, char C) {\r\n        int n = S.length(), pre = -n, res[] = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            if (S.charAt(i) == C) pre = i;\r\n            res[i] = i - pre;\r\n        }\r\n        for (int i = pre - 1; i >= 0; i--) {\r\n            if (S.charAt(i) == C)  pre = i;\r\n            res[i] = Math.min(res[i], pre - i);\r\n        }\r\n        return res;\r\n    }\r\n }\r\n```\r\n\r\n## 思路 - DP\r\n- Array遍历\r\n- 初始化result array.\r\n- 遍历从左到右，遇到c，设为0，其余设为 size - 1;\r\n- 遍历从左1到右(i = 1)，和前一位（i - 1） + 1比较后取最小值\r\n- 遍历从右1到左（i = size - 2），和前一位（i + 1） + 1比较后取最小值\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int size = s.length();\r\n        int[] res = new int[size];\r\n        for(int i = 0; i < size; i++){\r\n            res[i] = s.charAt(i) == c? 0: size - 1;\r\n        }\r\n\r\n        for (int i = 1; i < size; i++){\r\n            res[i] = Math.min(res[i], res[i - 1] + 1);\r\n        }\r\n\r\n        for (int i = size - 2; i >= 0; i--){\r\n            res[i] = Math.min(res[i], res[i + 1] + 1);\r\n        }\r\n \r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度：\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917588150","body":"**思路**\r\n使用数组来记录增加的数值\r\n\r\n**代码**\r\n```\r\n    int n;\r\n    int[] inc;\r\n    Stack<Integer> stack;\r\n    public CustomStack(int maxSize) {\r\n        n = maxSize;\r\n        inc = new int[n];\r\n        stack = new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (stack.size() < n)\r\n            stack.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        int i = stack.size() - 1;\r\n        if (i < 0)\r\n            return -1;\r\n        if (i > 0)\r\n            inc[i - 1] += inc[i];\r\n        int res = stack.pop() + inc[i];\r\n        inc[i] = 0;\r\n        return res;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int i = Math.min(k, stack.size()) - 1;\r\n        if (i >= 0)\r\n            inc[i] += val;\r\n    }\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918063637","body":"## 思路\r\n- 利用两个stack，resStack / counterStack\r\n- 遍历表达式 当前字符记为c， index idx\r\n  - 如果 c 是数字,c 的下一位也是数字， 转为数字 压入counterStack\r\n  - 如果c == '[' ，向resStackk中压入空串 “”, idx++\r\n  - 如果是c == ']' 表示sub string结束, 所以我们把需要重复的数字从stack pop, 然后 repeat 当前sring. 拼接上\r\n\r\n\r\n## 代码\r\n```\r\npublic class Solution {\r\n    public String decodeString(String s) {\r\n        String res = \"\";\r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resStack = new Stack<>();\r\n        int idx = 0;\r\n        while (idx < s.length()) {\r\n            Character c = s.charAt(idx);\r\n            if (Character.isDigit(c)) {\r\n                int count = 0;\r\n                while (Character.isDigit(c)) {\r\n                    count = 10 * count + (c - '0');\r\n                    idx++;\r\n                }\r\n                countStack.push(count);\r\n            }\r\n            else if (c == '[') {\r\n                resStack.push(res);\r\n                res = \"\";\r\n                idx++;\r\n            }\r\n            else if (c == ']') {\r\n                StringBuilder temp = new StringBuilder (resStack.pop());\r\n                int repeatTimes = countStack.pop();\r\n                for (int i = 0; i < repeatTimes; i++) {\r\n                    temp.append(res);\r\n                }\r\n                res = temp.toString();\r\n                idx++;\r\n            }\r\n            else {\r\n                res += s.charAt(idx++);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## 时间复杂度\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918797628","body":"### 思路\r\n使用两个栈，一个输入栈，一个输出栈；\r\npush：保存到输入栈中。新元素添加到堆栈 s1 顶部，第一个元素保留为队列前元素\r\npop和peek的时候在输出栈为空的情况下，将所有的输入栈中的数据存到输出栈中， peek: 前端元素在推送元素时进行修改。当 s2 不为空时，front 元素位于 s2 的顶部\r\nempty： reutn输出栈与输入栈是否为空\r\n\r\n### 代码\r\n```\r\nclass MyQueue {\r\n    private Stack<Integer> s1;\r\n    private Stack<Integer> s2;\r\n    private int front;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        s1 = new Stack();\r\n        s2 = new Stack();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n       if (s1.isEmpty()){\r\n           front = x;\r\n       }\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (s2.isEmpty()){\r\n            while(!s1.isEmpty()){\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (!s2.isEmpty()){\r\n            return s2.peek();\r\n        }\r\n        return front;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n复杂度分析\r\n- T: push->O(1), pop->O(1),peek->O(1), empty->O(1)\r\n- S: push->O(n), pop->O(1),peek->O(1), empty->O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919670696","body":"## 思路\r\n想不出思路，看了题解\r\n借助一个sorted array(copy arr to new array and sort)，和原本的arr做比较。\r\nif Addition sortArr and arr contain the same elements, their sum should equal each other.就可以算作一个partition, 相同在这里的定义是差的和为0。\r\n\r\n## 代码\r\n```\r\n//addition sorted array\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int n = arr.length;\r\n        int[] sortArr = Arrays.copyOf(arr, n);\r\n        Arrays.sort(sortArr);\r\n        int sum = 0;\r\n        int ans = 0;\r\n        for(int i = 0; i < n; i++){\r\n            sum += arr[i] - sortArr[i];\r\n            if(sum == 0) ans++;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n## 复杂度\r\nTime: O(nlogn)-  Sort the array.\r\nSpace: O(n) - create the sortArr.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920612343","body":"### 思路\r\n- 计算列表n的长度, k = k%n (要考虑 k > n 的情况)\r\n- 使用快慢指针fast & slow pointer:  slow pointing to 新的尾部. fast pointing to旧尾巴, fast proceeds by k steps first, and then both slow and fast proceed one node each step until fast.next == null\r\n```\r\n            1->2->3 |->4->5\r\n                     k=2. \r\n                     \r\n            1->2->3 |->4->5\r\n                  s       f   \r\n```\r\n- 旧尾巴与头部连接成环: fast.next = head;\r\n- 新的头：newHead = slow.next;\r\n- 打破环: slow.next = null;\r\n- 返回 new_head。\r\n\r\n### 代码\r\n\r\n```\r\nclass Solution {\r\n  public ListNode rotateRight(ListNode head, int k) {\r\n    // base cases\r\n    if (head == null || head.next == null) return head;\r\n    \r\n    //find length of ListNode\r\n    int n = 0;\r\n    ListNode cur = head;\r\n    while (cur != null) {\r\n        n++;\r\n        cur = cur.next;\r\n    }\r\n      \r\n    //concider k > n \r\n    k = k % n;\r\n\r\n    //fast & slow pointer\r\n    //1->2->3 |->4->5\r\n    //         k=2. \r\n    //1->2->3 |->4->5\r\n    //      s       f\r\n    ListNode fast = head, slow = head;\r\n    while (fast.next != null) {\r\n        // use k as a counter\r\n        if (k <= 0) {\r\n            slow = slow.next;\r\n        }\r\n        fast = fast.next;\r\n        k--;\r\n    }\r\n    \r\n     //close to a ring\r\n    fast.next = head;\r\n      \r\n    //newHead\r\n    ListNode newhead = slow.next;\r\n      \r\n    //break ring\r\n    slow.next = null;\r\n\r\n    return newhead;\r\n  }\r\n```\r\n\r\n### Complexity\r\n- Time:  O(n) \r\n- Space: O(1). No extra space used.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921527993","body":"### 思路\r\n1.Use a dummy head dummy to simplify the code, dummy.next = head.\r\n2.Set pre, cur, next. exchange their positions\r\n3. prev = cur, contiue the next iteration.\r\n4.返回dummy.next\r\n\r\n### 代码\r\n\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        ListNode pre = dummy;\r\n        while ((head != null) && (head.next != null)) {\r\n            ListNode cur = head;\r\n            ListNode next = head.next;\r\n            pre.next = next;\r\n            cur.next = next.next;\r\n            next.next = cur;\r\n            pre = cur;\r\n            head = cur.next; // jump\r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922187360","body":"### 思路\r\n链表的中点是树的root，左半链表为左子树的节点，右半链表是右子树的节点；\r\n链表的中点通过快慢指针找到\r\n用递归来生成树\r\nreturn：root of tree\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        if (head.next == null) {\r\n            return new TreeNode(head.val);\r\n        }\r\n\r\n        //找到链表的中点slow\r\n        ListNode fast = head, slow = head;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n\r\n        //将中点左边的链表分开\r\n        ListNode prev = head;\r\n        while (prev.next != slow) {\r\n            prev = prev.next;\r\n        }\r\n        prev.next = null;\r\n        \r\n        //构造树\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(slow.next);\r\n        return root;\r\n    }\r\n}\r\n\r\n```\r\n### 复杂度\r\n- Time: O(nlogn)\r\n- Space: O(height) = O(logn) for recursive calls.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922442950","body":"### 思路\r\n遍历 list A ，hash set 记录节点, 然后遍历B, set里面包含B的节点就是交接点\r\n\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        Set<ListNode> set = new HashSet<>();\r\n        while (headA != null) {\r\n            set.add(headA);\r\n            headA = headA.next;\r\n        }\r\n\r\n        while (headB != null) {\r\n            if (set.contains(headB)) {\r\n                return headB;\r\n            }\r\n            headB = headB.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YQYCS":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916605762","body":"### 思路：\r\n        将K逐位分解，加入到A中\r\n### 代码\r\n```\r\nclass Solution:\r\n  def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        i = len(A) - 1\r\n        while K:\r\n            A[i] += K\r\n            K, A[i] = A[i] // 10, A[i] % 10\r\n            i -= 1\r\n            if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n        return A\r\n```\r\n### 复杂度分析\r\n        时间复杂度：O（N），需要遍历一遍数组，故为N\r\n        空间复杂度：O（1），不需要额外开辟空间\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917391160","body":"### 思路：\r\n对于各字符而言，它只关心离它最近的那个 C 字符，其他的它都不管。\r\n1、res需初始化，当字符为C时设为0，否则设置为空\r\n2、先从左往右遍历字符串 S，用res数组记录每个字符与左侧最后一个 C 字符的距离；\r\n3、再从右往左遍历字符串 S，将res数组值 和 每个字符与右侧最后一个 C 字符的距离 作大小比较，取最小值，即为距离的最小值。\r\n\r\n### 代码\r\npython代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1,n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n-2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n    \r\n        return res\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(N),N 是 S 的长度。\r\n空间复杂度：O(1)。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917618316","body":"### 思路\r\n    普通的栈只有栈顶元素是可见的(可以直接操作)，inc()中要实现的栈底k个元素值都增加，就需要让栈中的所有元素可见(直接对栈的值可直接操作)。\r\n    1、push 操作，判断当前元素的个数是否达到上限，如果没有达到，就把 top 后移一个位置并添加一个元素。\r\n    2、pop 操作，判断当前栈是否为空，非空返回栈顶元素的初始值加上增量 add[top]，在这之后，我们将增量向栈底进行传递，累加至 add[top - 1] 处。并将 top 前移一位，否则返回 -1。\r\n    3、inc 操作，使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置，用数组add记录每次inc操作---栈底的k个元素（栈的个数相比较取最小值）的值都增加 val,将 add[k - 1] 增加 val。只有在 pop 操作时，我们才需要知道栈顶元素的具体值，在其余的情况下，我们只要存储每个元素的增量就行了，在遇到 pop 操作时，我们返回栈顶元素的初始值加上增量 add[top]。\r\n\r\n### 代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.stk[self.top] + self.add[self.top]\r\n        if self.top != 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return ret\r\n\r\n    def inc(self, k: int, val: int) -> None:\r\n        lim = min(k - 1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n    时间复杂度：时间复杂度为 O(1)。\r\n    空间复杂度：空间复杂度为O(maxSize)，用了长度为 maxSize 的数组作为辅助空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918015041","body":"### 思路\r\n用栈处理，遇到 \"[\"，就要开始重复字符串了，另外重复的数字是可能存在多位的，\r\n所以需要往前找到不为数字的那⼀位，把数字转换出来。\r\n最后⽤把 stack ⾥⾯的字符串都串联起来即可\r\n\r\n### 代码\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def dfs(s, i):\r\n            res, multi = \"\", 0\r\n            while i < len(s):\r\n                if '0' <= s[i] <= '9':\r\n                    multi = multi * 10 + int(s[i])\r\n                elif s[i] == '[':\r\n                    i, tmp = dfs(s, i + 1)\r\n                    res += multi * tmp\r\n                    multi = 0\r\n                elif s[i] == ']':\r\n                    return i, res\r\n                else:\r\n                    res += s[i]\r\n                i += 1\r\n            return res\r\n        return dfs(s,0)\r\n```\r\n\r\n### 复杂度\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918975366","body":"### 思路\r\n#使⽤两个栈 s1, s2 就能实现⼀个队列的功能，s1是队头，s2是队尾\r\n\r\n### 代码\r\n```\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.s1 = []\r\n        self.s2 = []\r\n        self.front = None\r\n\r\n    def push(self, x: int) -> None:\r\n        if not self.s1: self.front = x\r\n        self.s1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n            self.front = None\r\n        return self.s2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.s2: \r\n            return self.s2[-1]\r\n        return self.front\r\n\r\n    def empty(self) -> bool:\r\n        if not self.s1 and not self.s2:\r\n            return True\r\n        return False\r\n```\r\n\r\n### 复杂度\r\n#时间复杂度：O(1)\r\n#空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919786393","body":"### 思路\r\n排序块定义：\r\n排序块 充分条件： 设此块中最大数字为 head , 若此块后面的所有数字都 >= head，则此块为排序块。\r\n排序块 最短长度为 1，即单个元素可以独立看作一个排序块。\r\n遍历一遍数组 arr ，动态判断到目前为止数字num最多能分出多少排序块，并保存每个排序块的最大值 head。每遍历到下个数字 num，动态判断前面所有的排序块是否成立，并更新所有排序块：\r\n1、当某排序块 num < head ：将此排序块[A]与 num 合并，形成新排序块[A | num]，最大值仍为 head；\r\n2、当某排序块 num >= head ：原排序块保留，并新加排序块 [num] 。\r\n在遍历过程中，通过维护栈的 headhead 序列，实现排序块的动态更新。\r\n### 代码\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n```\r\n### 复杂度\r\n#时间复杂度：O(1)\r\n#空间复杂度：O(1)\r\n\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922242716","body":"### 思路\r\n1、使用快慢指针找到链表的中间节点\r\n2、使用递归建立平衡二叉树，递归结束条件是只有一个子节点即(left=right)\r\n\r\n### 代码\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        \r\n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\r\n            if left == right:\r\n                return None\r\n            mid = getMedian(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n        \r\n        return buildTree(head, None)\r\n```\r\n\r\n### 复杂度\r\n时间复杂度O(logn)\r\n空间复杂度O(logn),logn为平衡二叉树的高度\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922404784","body":"### 思路\r\n参考题解\r\n### 代码\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A = headA\r\n        B = headB\r\n        while A != B:\r\n            A = A.next if A else headB\r\n            B = B.next if B else headA\r\n        return A\r\n```\r\n### 复杂度\r\n时间复杂度 O(a+b)\r\n空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916608620","body":"\n#idea: two iterations to add and decompose the num\n# time and space o(N)\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        nums = 0\n        length = len(num)\n        \n        for i in range(length):\n            nums += num[i] * (10**(length-1-i))\n        print(nums)\n        nums2= nums+k\n        list1 = []\n        if nums2 == 0:\n            return[0]\n        while nums2:\n            a= nums2%10\n            nums2 //= 10\n            list1.insert(0,a)\n        return list1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917218318","body":"#idea: iterate the string, use dictionary to save the distance and update\r\n```\r\nclass Solution:\r\n\tdef shortestToChar(self, s: str, c: str) -> List[int]:\r\n\t\tdic = {c:[]}\r\n\t\tlens = len(s)\r\n\t\toutput = []\r\n\t\tfor i in range(lens):\r\n\t\t\tif s[i] == c:\r\n\t\t\t\tdic[c].append(i)\r\n\t\tfor i in range(lens):\r\n\t\t\ttemp = [abs(i-k) for k in dic[c]]\r\n\t\t\toutput.append(min(temp))\r\n\t\treturn output\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917739217","body":"#idea all strings are separate by the num[], find each subpart string then merge\r\n```\r\nClass Solution:\r\n    def decodeString(self, s:str) -> str:\r\n        stack = []\r\n        strs,nums = '',''\r\n        for i in s:\r\n            if i.isdigit():\r\n                nums += i\r\n            elif i.isalpha():\r\n                strs += i\r\n            elif i == '[':\r\n                stack.append((strs,int(nums)))\r\n                strs,nums = '',''\r\n            elif i == ']':\r\n                prev,num = stack.pop()\r\n                strs = prev+num*strs\r\n        return a\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918748806","body":"# Idea: use two stacks\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack1.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.stack2:\r\n            return self.stack2[-1]\r\n        else:\r\n            return self.stack1[0]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return (len(self.stack1)+ len(self.stack2))== 0\r\n```\r\n\r\n#Time O(1)\r\n#Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919581309","body":"#idea: the max number in a chunk should be smaller or equal to the min of the rest of the list, otherwise\r\n\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        lists = []\r\n        temp = []\r\n        for i in range(len(arr)-1):\r\n            temp.append(arr[i])\r\n            if max(temp) <= min(arr[i+1:]):\r\n                lists.append(temp)\r\n                temp = []\r\n            else:\r\n                pass\r\n        if len(lists) == 0:\r\n            return 1\r\n        else:\r\n            return len(lists)+1\r\n```\r\n\r\n#Time O(n)\r\n#Space O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920532271","body":"\r\n#Idea: make the linkedlist into a circle and then find the break point\r\n\r\nDefinition for singly-linked list.\r\n```\r\nclass ListNode:\r\n     def __init__(self, val=0, next=None):\r\n         self.val = val\r\n         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        cur = head\r\n        count = 0\r\n        if head == None:\r\n            return None\r\n        while cur:\r\n            count += 1\r\n            \r\n            if cur.next == None:\r\n                cur.next = head\r\n                break\r\n            cur = cur.next\r\n        \r\n        pos = k% count \r\n        print(pos)\r\n        breakpoint = count - pos\r\n        if breakpoint == 0:\r\n            return head\r\n        else:\r\n            ans = cur\r\n            cur = cur.next \r\n            for i in range(breakpoint-1):\r\n                cur = cur.next \r\n            nextn = cur.next\r\n            cur.next = None\r\n            return nextn\r\n```\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921975423","body":"Idea: fast and slow pointers find root point, then recursion\r\nTime: O(nlogn), Space:(logn)\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return head\r\n        prev = None\r\n        slow = head\r\n        fast = head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            prev = slow\r\n            slow = slow.next\r\n\r\n        if prev:\r\n            prev.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922338453","body":" idea two pointers both iterate A+B or B+A meet at intersect\r\ntime O(N)\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        p1 = headA\r\n        p2 = headB\r\n        if headA == headB:\r\n            return headA\r\n        while p1.next:\r\n            p1 = p1.next\r\n            if p2.next:\r\n                p2 = p2.next\r\n            else:\r\n                p2 = headA\r\n        p1 = headB\r\n        if p2.next:\r\n            p2 = p2.next\r\n        else:\r\n            p2 = headA\r\n        if p1 == p2:\r\n            return p1\r\n        while p1.next:\r\n            p1 = p1.next\r\n            if p2.next:\r\n                p2 = p2.next\r\n            else:\r\n                p2 = headA\r\n            if p1 == p2:\r\n                return p1\r\n            \r\n        return None\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922506261","body":"Idea: fast and slow pointers:\r\n1. fast x2 slow x1, if meet, fast = head\r\n2. fast x1 and slow x1, if meet, return node\r\nTime: O(n)\r\nSpace:(1)\r\n\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast = head\r\n        slow = head \r\n        if fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        else:\r\n            return None\r\n        while slow != fast and fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            #print(slow.val)\r\n        if fast ==None:\r\n            return None\r\n        elif fast.next == None:\r\n            return None\r\n        fast = head\r\n       # print(fast.val)\r\n        #print(slow.val)\r\n        ans = 0\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n            \r\n            ans += 1\r\n        return fast\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"siyuelee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916610263","body":"## 思路：\n将K先加到数组最后一位，再从后向前遍历数组，依次进位\n## 代码\n```Python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n\n        num[-1] += k\n        for i in range(len(num) - 1, -1, -1):\n            carry, num[i] = divmod(num[i], 10)\n            if i > 0:\n                num[i-1] += carry\n        while carry:\n            num = [carry%10] + num\n            carry = carry//10\n        return num\n```\n## 复杂度分析\n    时间复杂度：O（N），需要遍历一遍数组，故为N\n    空间复杂度：O（1），不需要额外开辟空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917324513","body":"## 思路\nIterate twice - from the left and from the right. We will remember the index of the last char c that we've seen and append the distance to res[]. While interating from right to left, we will calc the distance agian and compare it with the one in res. Smaller ones would be the final results.\n\n## Code\n```Python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        prev = float('-inf')\n        res = []\n        for i, x in enumerate(s):\n            if x == c:\n                prev = i\n            res.append(i - prev)\n            \n        prev = float('inf')\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                prev = i\n            res[i] = min(res[i], prev - i)\n            \n        return res\n```\n## 复杂度分析\n时间复杂度O（n）\n空间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917481852","body":"```Python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        self.stack = [0] * maxSize\n        self.top = -1\n\n    def push(self, x):\n        if self.top < len(self.stack) - 1:\n            self.top += 1\n            self.stack[self.top] = x\n\n    def pop(self):\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stack[self.top + 1]\n        \n\n    def increment(self, k, val):\n        for i in range(min(k, self.top + 1)):\n            self.stack[i] += val\n        \n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917719702","body":"## 思路\n递归\n- 每次遇到[，我们进入下一个function。 \n- 每个function 返回 currentString\n- 父function拿到子function返回的currentString， 乘上base从而加到自己的currentString\n- 遇到]，当前function返回currentString\n- 遇到字符，加到currentString\n- 遇到数字，yongchar2digit提取数字\n\n```Python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        self.i = 0\n        # 1. what to do before enter the function\n        # 2. what does the function return\n        # 3. what to do after the function\n        def char2digit(s):\n            base = 0\n            i= 0\n            while s[i].isdigit():\n                base = 10 * base + int(s[i])\n                i = i + 1\n            return base,i\n\n        def dfs(s):\n            currentString = \"\"\n            # \"aa321s\"\n            while self.i < len(s):\n                if s[self.i].isdigit():\n                    base, length = char2digit(s[self.i:])\n                    self.i = self.i + length\n                    continue \n                elif s[self.i] == '[':\n                    self.i += 1\n                    ret = dfs(s)\n                    currentString += base * ret\n                elif s[self.i] == ']':\n                    self.i += 1\n                    return currentString\n                else:\n                    currentString += s[self.i]\n                    self.i += 1\n                # self.i += 1\n            return currentString\n        return dfs(s)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918771333","body":"## 思路\npush时，把s1里所有元素存入s2中，然后push新元素到s1底部，在把所有s2元素依次放回s1。pop时直接pop顶部元素即可。\n## Code\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: None\n        \"\"\"\n        while self.s1:\n            self.s2.append(self.s1.pop())\n        self.s1.append(x)\n        while self.s2:\n            self.s1.append(self.s2.pop())\n\n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        return self.s1.pop()\n\n    def peek(self):\n        \"\"\"\n        Get the front element.\n        :rtype: int\n        \"\"\"\n        return self.s1[-1]\n\n    def empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        return not self.s1\n```\nTime complexity : O(n). \nSpace complexity : O(n).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919703636","body":"## 思路\n完全不会，直接看答案 :)\nWe know that for each chunk if we sort and merge them the resulting array should also be sorted. And we also know that if the two arrays are the same, it means the count information and the sorted arrays should be exactly same. So the trick is to compare the original array and sorted array, we iterate i and for arr[:i] and sorted_arr[:i], if they are exactly same, we could have a chunck satisfying the requirements. The comparison could be enabled using dict.\n## Code\n```Python\n    def maxChunksToSorted(self, arr):\n        res, c1, c2 = 0, collections.Counter(), collections.Counter()\n        for a, b in zip(arr, sorted(arr)):\n            c1[a] += 1\n            c2[b] += 1\n            if c1 == c2: res += 1\n        return res\n```\n\n## Complexity:\nTime: O(nlogn) for sorting, O(N^2) for comparing\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920576469","body":"```Python\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next or k == 0:\n            return head\n        \n        # get the length of linkedlist\n        l = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            l += 1\n        \n        # get mod\n        k %= l\n        if k == 0: return head\n        \n        # link tail to head to get a circle\n        cur.next = head\n        \n        # head moves l-1-k steps\n        n = l-1-k\n        while n > 0:\n            head = head.next\n            n -= 1\n            \n        # keep the new head first and then cut the circle\n        new_head = head.next\n        head.next = None\n        \n        return new_head\n```\nO(N)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921454966","body":"### 递归\n```Python\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next: return head\n\n        new_head = head.next\n        head.next = self.swapPairs(new_head.next)\n        new_head.next = head\n        return new_head\n```\n### 迭代\nPlease note that we want to use a dummy to keep the address of the head because cur is moving towards the end and dummy can finally directly give us head of the list.\n```Python\nclass Solution(object):\n    def swapPairs(self, head):\n        if not head or not head.next: return head\n        \n        cur = ListNode(0)\n        cur.next = head\n        dummy = cur\n        while cur.next and cur.next.next:\n            node1 = cur.next\n            node2 = cur.next.next\n            cur.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            \n            # update pointer\n            cur = node1\n        return dummy.next\n```\nO(n)\nO(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922393908","body":"### 1. \nuse hash table to keep the nodes in A. Then there is a node in B is contained in hash table we could return the node. \n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        seen = dict()\n        cur = headA\n        while cur:\n            seen[cur] = 1\n            cur = cur.next\n        \n        cur = headB\n        while cur:\n            if cur in seen:\n                return cur\n            cur = cur.next\n        return None\n```\nComplexity: Time: O(N), Space: O(N)\n### 2. \ntwo pointers - starting from head A and head B. Then when the pointers reach the end, start from the other list's head. They travel same distance when they meet at the intersection. If they don't meet, pointer A and pointer B will both point Null. \n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not headA or not headB: return None\n        \n        # 2 pointers\n        pa = headA\n        pb = headB\n        while pa != pb:\n            pa = headB if not pa else pa.next\n            pb = headA if not pb else pb.next\n        return pa\n```\nComplexity: Time: O(N), Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916612541","body":"````\nvar addToArrayForm = function(num, k) {\n  let arr = [];\n  while (k !== 0) {\n    arr.unshift(k % 10);\n    k = Math.floor(k / 10);\n  }\n  let res = num.length > arr.length ? num : arr;\n  let i = 1;\n  while (i <= res.length) {\n    let add1 = num.length - i >= 0 ? num[num.length - i] : 0;\n    let add2 = arr.length - i >= 0 ? arr[arr.length - i] : 0;\n    let sum = add1 + add2;\n    if (sum >= 10) {\n      res[res.length - i] = sum % 10;\n      if (res.length - i - 1 >= 0) res[res.length - i - 1] += 1;\n      else res.unshift(1);\n    } else {\n      res[res.length - i] = sum;\n    }\n    i++;\n  }\n  return res;  \n};\n````\n时间复杂度：O(n), n为num和k长度较长的那个\n\n空间复杂度：O(n), n为k的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917418658","body":"````\nvar shortestToChar = function(s, c) {\n  let res = [];\n  let target = s.indexOf(c);\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      target = i;\n      res.push(0);\n    } else {\n      res.push(Math.abs(target - i));\n    }\n  }\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) {\n      target = i;\n      res[i] = 0;\n    } else {\n      res[i] = Math.min(res[i], Math.abs(target - i));\n    }\n  }\n  return res;\n};\n````\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917542145","body":"`````\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.arr = [];\n  this.length = maxSize;  \n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.arr.length < this.length) {\n    this.arr.push(x);\n  }  \n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.arr.length === 0) {\n    return -1;\n  } else {\n    return this.arr.pop();\n  }  \n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  let len = Math.min(this.arr.length, k);\n  for (let i = 0; i < len; i++) {\n    this.arr[i] += val;\n  }  \n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n````\n时间复杂度：O(maxSize)\n\n空间复杂度：O(maxSize)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918763828","body":"````\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n  this.firstStack = [];\n  this.lastStack = [];  \n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  let length = this.lastStack.length;\n  for (let i = 0; i < length; i++) {\n    this.firstStack.push(this.lastStack.pop())  \n  }\n  this.firstStack.push(x);  \n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  if (this.empty()) {\n    return null;  \n  } else {\n    let length = this.firstStack.length;\n    for (let i = 0; i < length; i++) {\n      this.lastStack.push(this.firstStack.pop());\n    }\n    return this.lastStack.pop();\n  }  \n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if (this.empty()) {\n    return null;  \n  } else {\n    return this.firstStack.length > 0 ? this.firstStack[0] : this.lastStack[this.lastStack.length - 1];  \n  }     \n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.firstStack.length === 0 && this.lastStack.length === 0;  \n};\n````\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919725561","body":"````\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  let stack = [arr[0]];\n  for (let i = 1; i < arr.length; i++) {\n    if (stack[stack.length - 1] > arr[i]) {\n      let cur = stack[stack.length - 1];\n      while (stack[stack.length - 1] > arr[i]) stack.pop();\n      stack.push(cur);\n    } else {\n      stack.push(arr[i]);\n    }\n  }\n  return stack.length;  \n};\n````\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921779058","body":"````\nvar swapPairs = function(head) {\n  let node = new ListNode(0, head);\n  let p = node;\n  while (p && p.next && p.next.next) {\n    let p1 = p.next;\n    let p2 = p.next.next;\n    p1.next = p2.next;\n    p2.next = p1;\n    p.next = p2;\n    p = p1;\n  }\n  return node.next;\n};\n````\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922281383","body":"````\nvar sortedListToBST = function(head) {\n  if (!head) return null;\n  return dfs(head, null);\n};\n\nvar dfs = function (head, tail) {\n  if (head === tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast !== tail && fast.next !== tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head, slow);\n  root.right = dfs(slow.next, tail);\n  return root;\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922404336","body":"````\nvar getIntersectionNode = function(headA, headB) {\n  let p1 = headA;\n  let p2 = headB;\n  while (p1 !== p2) {\n    p1 = p1 ? p1.next : headB;\n    p2 = p2 ? p2.next : headA;\n  }\n  return p1;\n};\n````","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SnowBallBears":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916612816","body":"## **题目**\n989. Add to Array-Form of Integer\n\n## **思路**\n\nPretty straightforward thoughts, adding up an array and a number, use carry and another array to take care of the all cases.\n\n## **代码**\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        \n        for i in range(len(num)-1,-1,-1):\n            curr = num[i] + k%10 + carry\n            k = k//10\n            carry = curr//10     \n            num[i] = curr % 10\n    \n        k = k + carry\n        prenum = []\n        \n        while(k>0):\n            prenum.insert(0, k%10)\n            k = k//10\n        \n        return prenum + num\n        \n```\n\n## **复杂度**\n\nSpace: O(max(1, K-N))\nTime: O(N + max(0,(K-N)^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917333033","body":"## **题目**\n821. Shortest Distance to a Character\n\n## **思路**\n\nUse two pointers to find the nearest target letter for each letter\n\n## **代码**\n\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [float('inf')] * n\n        \n        for i in range(n):\n            if s[i] == c:\n                res[i] = 0\n                continue\n            \n            left = right = i\n            while(left>=0):\n                if s[left] == c:\n                    res[i] = min(res[i], abs(left-i))      \n                    break\n                left = left-1\n            \n            while(right<n):\n                if s[right] == c:\n                    res[i] = min(res[i], abs(right-i))\n                    break\n                right = right+1\n        \n        return res\n        \n```\n\n## **复杂度**\n\nSpace: O(N)\nTime: O(N^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917546403","body":"## **题目**\n\n1381. Design a Stack With Increment Operation\n\n\n## **代码**\n\n      1. array\n   \n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.size = 0\n        self.nums = []\n\n    def push(self, x: int) -> None:\n        if self.size < self.max_size:\n            self.size += 1\n            self.nums.append(x)\n        \n    def pop(self) -> int:\n        if self.size > 0:\n            self.size -= 1\n            return self.nums.pop()\n        \n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,self.size)):\n            self.nums[i] += val\n\n\n```\n\n      2. prefix sum\n\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.size = 0\n        self.nums = []\n        self.prefix = [0] * (maxSize+1)\n\n    def push(self, x: int) -> None:\n        if self.size < self.max_size:\n            self.size += 1\n            self.nums.append(x)\n        \n    def pop(self) -> int:\n        if self.size > 0:\n            res = self.nums.pop() + self.prefix[self.size]\n            self.prefix[self.size-1] += self.prefix[self.size]\n            self.prefix[self.size] = 0\n            self.size -= 1\n            return res\n            \n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        self.prefix[min(k, self.size)] += val\n        \n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917838456","body":"## **题目**\n394. Decode String\n\n## **思路**\n\nstack \n\n## **代码**\n\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        \n        for c in s:\n            if c == ']':\n                sub_s = ''\n                while(stack and stack[-1]!='['):\n                    sub_s = stack.pop() + sub_s\n                \n                stack.pop()\n                \n                num = 0\n                count = 0\n                while(stack and stack[-1].isnumeric()):\n                    num = num * 10 ** count + int(stack.pop())   \n                    count+=1\n                stack.append(sub_s*num)\n                print(stack)       \n            else:\n                stack.append(c)\n            \n        return ''.join(stack)\n        \n```\n\n## **复杂度**\n\nSpace: O(N)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918775917","body":"## **题目**\n232. Implement Queue using Stacks\n\n## **思路**\n\nUse two stacks to do the pop operation \n\n## **代码**\n\n```\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []\n        self.helper_stack = []\n        \n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        \n        while(self.stack):\n            self.helper_stack.append(self.stack.pop())\n        \n        res = self.helper_stack.pop()\n        \n        while(self.helper_stack):\n            self.stack.append(self.helper_stack.pop())\n        \n        return res\n            \n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack[0]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.stack) == 0\n        \n```\n\n## **复杂度**\n\nSpace: O(N)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919693760","body":"\n## **题目**\n768. Max Chunks To Make Sorted II \n\n## **思路**\n\nMonotonic stack (didn't figure this out at the first try)\n\n## **代码**\n\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        \n        for num in arr:\n            if stack and stack[-1] > num:\n                mx = stack[-1]\n                \n                while(stack and stack[-1] > num):\n                    stack.pop()\n                \n                stack.append(mx)\n            \n            else:\n                stack.append(num)\n                \n        return len(stack)\n\n        \n```\n\n## **复杂度**\n\nSpace: O(N)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920555205","body":"## **题目**\n 61. Rotate List \n\n## **思路**\n\nUse slow and faster pointers\n\n## **代码**\n\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        \n        n = 0\n        curr = head\n        while(curr):\n            n+=1\n            curr = curr.next\n        \n        k = k % n\n        if k == 0 : return head\n        slow = fast = head\n        while(fast.next):\n            if k <= 0:\n                slow = slow.next\n            fast = fast.next\n            k-=1\n        \n\n        fast.next = head\n        new_head = slow.next\n        slow.next = None\n        \n        \n        return new_head\n\n```\n\n## **复杂度**\n\nSpace: O(1)\nTime: O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922212834","body":"\n## **题目**\n109. Convert Sorted List to Binary Search Tree\n\n## **思路**\n\nUse slow and fast pointers to find the middle node of the list and then use dfs to recursively build the tree\n\n## **代码**\n\n```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head: return head\n        return self.dfs(head, None)\n\n    def dfs(self, head, tail):\n        if head == tail: return None\n        \n        slow = fast = head\n        while(fast!=tail and fast.next!=tail):\n            slow = slow.next\n            fast = fast.next.next\n        \n        res = TreeNode(slow.val)\n        res.left = self.dfs(head, slow)\n        res.right = self.dfs(slow.next, tail)\n        \n        return res\n            \n\n        \n```\n\n## **复杂度**\n\nSpace: O(log(n))\nTime: O(nlog(n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922408706","body":"\n## **题目**\n160. Intersection of Two Linked Lists\n\n## **思路**\n\nFigured out the solution using hash table, get the constant space way by reading the solution. Using the **same distance** logic for this quesion\n\n## **代码**\n\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a = headA\n        b = headB\n        \n        while(a != b):\n            if not a:\n                a = headB\n            else:\n                a = a.next\n            \n            if not b:\n                b = headA\n            else:\n                b = b.next\n        \n        \n        return b\n            \n\n```\n\n## **复杂度**\n\nSpace: O(1)\nTime: O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BlueRui":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916613826","body":"# Algorithm\nI use a more general approach to handle cases when k is longer than num, and when overflow may happen.\n1. Convert k to an array of digits\n2. Iterate from the lowest digit to highest one to add num[i] and k[i]. Get the sum of num[i], k[i] and carry. Add sum % 10 to list, and set sum / 10 to the new value of carry. End iteration when we reach the length of the shorter one of num and k\n3. Iterate over the remaining length of num or k in the same way. \n\n# Complexity\n* Time complexity: O(max(num.length, k.length)) \n* Space complexity: O(max(num.length, k.length))\n\n# Code\nLanguage: Java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        \n        char[] kDigits = Integer.toString(k).toCharArray();\n        int[] numK = new int[kDigits.length];\n        for (int i = 0; i < kDigits.length; i++) {\n            numK[i] = kDigits[i] - '0';\n        }        \n        \n        int carry = 0;\n        int index = 0;\n        while (index < num.length && index < numK.length) {\n            int sum = num[num.length - 1 - index] + numK[numK.length - 1 - index] + carry;\n            result.add(sum % 10);\n            carry = sum / 10;\n            index++;\n        }\n        \n        while (index < num.length) {\n            int sum = num[num.length - 1 - index] + carry;\n            result.add(sum % 10);\n            carry = sum / 10;\n            index++;\n        }\n        \n        while (index < numK.length) {\n            int sum = numK[numK.length - 1 - index] + carry;\n            result.add(sum % 10);\n            carry = sum / 10;\n            index++;\n        }\n        \n        if (carry != 0) {\n            result.add(carry);\n        }\n        \n        Collections.reverse(result);\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917180234","body":"# Algorithm\n1. Work through the array from the left to find the closest char c to the right of each char in s.\n2. Then work through the array from the right to find the closest char c to the left of each char in s.\n3. Find the min distance of step 1 and 2.\n4. Step 2 and 3 can be combined.\n\n# Complexity\n* Time Complexity: We are going over the array exactly twice. O(N)\n* Space Complexity: We can use the same output array, so no extra space. O(1)\n\n# Code\nLanguage: Java\n```Java\npublic int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] result = new int[n];\n        Arrays.fill(result, n);\n        // Find closest c on the right of each char\n        int cur = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) != c) {\n                continue;\n            }\n            while (cur <= i) {\n                result[cur] = i - cur;\n                cur++;\n            }\n        }\n\n        // Update to get the closest c from both sides by comparing left side\n        cur = n - 1;\n        for (int i = n - 1; i >=0; i--) {\n            if (s.charAt(i) != c) {\n                continue;\n            }\n            while (cur >= i) {\n                result[cur] = Math.min(result[cur], cur - i);\n                cur--;\n            }\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917536831","body":"# Problem: [1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n# Algorithm\n* Use an array to implement ths stack\n* Use *index* to track the current number of elements in the array and the top of the stack.\n\n# Complexity\n* *push* operation time complexity is O(1) since we simply assign one value to the current index of the array.\n* *pop* operation time complexity is O(1).\n* *inc* operation time complexity is O(k) where k is the number of elements to increment.\n* Total space complexity of the stack is O(n) where n is the maxSize.\n\n# Code\nLanguage: Java\n```java\nclass CustomStack {\n    private int[] stack;\n    private int index = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (index == stack.length) {\n            return;\n        }\n        stack[index++] = x;\n    }\n    \n    public int pop() {\n        if (index == 0) {\n            return -1;\n        }    \n        return stack[--index];\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k; i++) {\n            if (i + 1 > index) {\n                return;\n            }\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917766581","body":"# Problem [394. Decode String](https://leetcode.com/problems/decode-string/)\n\n# Algorithm\n* Iterate over each character in the string and use a stack to keep track of visited character.\n  1. Keep pushing to the stack until we hit a ']' in string.\n  2. When we hit a ']' in string.\n     1. Keep popping from stack and form a substring until we get a '[' from stack.\n     2. Keep popping digits from stack until it is no longer a digit.\n     3. Convert popped out digits to a multiplier of the substring.\n     4. Decode the substring and push the decoded substring to the stack.\n\n# Complexity\nTime Complexity: O(N) where N is the length of the decoded string.\nSpace Complexity: O(N) where N is the length of the decoded string.\n\n# Code\nLanguage: Java\n\n``` Java\npublic String decodeString(String s) {\n   Deque<Character> stack = new ArrayDeque<>();\n   for (char c : s.toCharArray()) {\n       if (c != ']') {\n           stack.addFirst(c);\n           continue;\n       }\n       List<Character> decodedStr = new ArrayList<>();\n       while (stack.peekFirst() != '[') {\n           decodedStr.add(stack.removeFirst());\n       }\n       // Remove '['\n       stack.removeFirst();\n       \n       // Get multiplier\n       int num = 0;\n       int base = 1;\n       // Important to check if stack is empty first\n       while (!stack.isEmpty() && Character.isDigit(stack.peekFirst())) {\n           // It is very important to keep track of base, as the lower digits may be 0s like \"100\"\n           // Simply using num = num * 10 + stack.removeFirst() - '0' won't work.\n           num = num + (stack.removeFirst() - '0') * base;\n           base *= 10;\n       }\n       \n       // Put decoded string back to stack\n       for (int i = 0; i < num; i++) {\n           for (int j = decodedStr.size() - 1; j >= 0; j--) {\n               stack.addFirst(decodedStr.get(j));\n           }\n       } \n   }\n   char[] result = new char[stack.size()];\n   for (int i = stack.size() - 1; i >= 0; i--) {\n       result[i] = stack.removeFirst();\n   }\n   return new String(result);        \n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918588053","body":"# Problem [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)\n\n## Algorithm\n* Use two stacks to implement the queue\n* Each element will be first pushed into stack1.\n* If stack2 is not empty, we will pop from stack2. If stack2 is empty, when pop/peek is called on the queue, we pop all elements in stack1 and push them to stack2. After this, the head of the queue is at the top of stack2.\n\n## Complexity\n* *push()*: time complexity O(1).\n* *pop()*: amortized time complexity O(1). Each element will only be moved from stack1 to stack2 once with total time of O(n). If we pop *n* times, the amortized time for each *pop()* is O(1).\n* *peek()*: same as *pop()*.\n\n## Code\nLanguage: Java\n\n``` Java\nclass MyQueue {\n    Deque<Integer> stack1;\n    Deque<Integer> stack2;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack1 = new LinkedList<>();\n        stack2 = new LinkedList<>();   \n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        stack1.addFirst(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (!stack2.isEmpty()) {\n            return stack2.removeFirst();\n        }\n        while (!stack1.isEmpty()) {\n            stack2.addFirst(stack1.removeFirst());\n        }\n        return stack2.removeFirst();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (!stack2.isEmpty()) {\n            return stack2.peekFirst();\n        }\n        while (!stack1.isEmpty()) {\n            stack2.addFirst(stack1.removeFirst());\n        }\n        return stack2.peekFirst();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919582602","body":"# Problem [768. Max Chunks To Make Sorted II](https://leetcode.com/problems/max-chunks-to-make-sorted-ii/)\n\n## Algorithm\n* Sort *arr* to get a new sorted array *sorted*.\n* Get the prefix sums of *arr* and *sorted* as *sum1* and *sum2*. When the two sums are equal, there is a new partition.\n\n## Proof\n* A partition is valid if all the elements in it remains in the same range of indices (partition) in the sorted array.\n* Sufficiency\n  * Prove *If sum1 == sum2, then we have a valid partition.*\n  * Since the 2nd array is sorted (increasing), *sum2* is the sum of *i* smallest elements, the first *i* elements of the 1st array must contain the same elements for *sum1 == sum2*.\n* Necessity\n  * *For any valid partition, we must have sum1 == sum2.*\n  * By our definition of a valid partition, the partitions in the 1st array and 2nd array have the same elements. Hence we have *sum1 == sum2*.\n\n\n## Complexity\n* Time Complexity: Sort *O(NlogN)* + for loop *O(N)* = Total: *O(NlogN)* where N is the length of *arr*.\n* Space complexity: Introduced a new array. *O(N)*.\n\n## Code\nLanguage: Java\n``` Java\n    public int maxChunksToSorted(int[] arr) {\n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        int result = 0, sum1 = 0, sum2 = 0;\n        for(int i = 0; i < arr.length; i++) {\n            sum1 += arr[i];\n            sum2 += sorted[i];\n            if (sum1 == sum2) {\n                result++;\n            }\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920276275","body":"# Problem [61. Rotate List](https://leetcode.com/problems/rotate-list/)\n\n## Algorithm\n* First we find the length of the list divide it by *k* to find the min number of rotation needed.\n* Introduce a slow pointer and a fast pointer. The fast one is *k* nodes ahead of the slow one.\n* Move both pointers along the list at the same speed. When the fast one reaches the end, the slow one is at the new head.\n* Break the list at the new head and connect the old end to the old head.\n\n## Complexity\n* Time Complexity: We go over the list twice. *O(N)*.\n* Space Complexity: *O(1)*\n\n## Code\nLanguage: Java\n\n``` Java\npublic ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n\n        // Find length of list, and get the min k\n        int count = 0;\n        ListNode cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        k = k % count;\n        if (k == 0) {\n            return head;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head;\n        count = 0;\n        while (count < k) {\n            fast = fast.next;\n            count++;\n        }\n        // Find the new head\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        // slow.next is the new head\n        ListNode newHead = slow.next;\n        fast.next = head;\n        slow.next = null;\n        return newHead;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921250315","body":"# Problem [24. Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/description/)\n\n## Algorithm\n* We simply need to go over the list and swap each pair of nodes.\n* The key is to also keep track of the previous and next nodes of the pair of nodes.\n\n## Complexity\n* Time Complexity: *O(N)*\n* Space Complexity: *O(1)*\n\n## Code\nLanguage: Java\n``` Java\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy, cur = head;\n        while (cur != null && cur.next != null) {\n            ListNode next = cur.next;\n            ListNode temp = next.next;\n            pre.next = next;\n            next.next = cur;\n            cur.next = temp;\n            pre = cur;\n            cur = temp;\n        }\n        return dummy.next;        \n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922080593","body":"# Problem [109. Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n# Algorithm\n* Find the middle ListNode and use it as the root.\n* Recursively call the *sortedListToBST* method on the left half and right half, and assign their results as left and right children of the root.\n\n# Complexity\n* Time Complexity: *O(NlogN)*. At each level of the tree, we need *O(N)* to find the middle node. There are *logN* levels.\n* Space Complexity: *O(logN)* which is the height of the tree and the call stack.\n\n# Code\nLanguage: Java\n``` Java\npublic TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n\n        ListNode mid = findMid(head);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = sortedListToBST(head);\n        root.right =sortedListToBST(mid.next);\n        return root;\n    }\n\n    private ListNode findMid(ListNode head) {\n        ListNode pre = null;\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        pre.next = null;\n        return slow;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922336910","body":"# Problem [160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)\r\n\r\n## Algorithm\r\n* Traverse from the head of two lists, when any one of them reaches the end, continue from the head of the other list.\r\n* If there is an intersection, the two traversals will be at the same node at the intersection.\r\n* If there is no intersection, both traversal will go over both lists and end at null.\r\n\r\n## Complexity\r\n* Time Complexity: Worst case we need to completely traverse both lists, *O(N)* where *N* is the total number of nodes of both lists combined.\r\n* Space Complexity: *O(1)*.\r\n\r\n## Code\r\nLanguage: Java\r\n``` Java\r\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n    if (headA == null || headB == null) {\r\n        return null;\r\n    }\r\n    ListNode curA = headA;\r\n    ListNode curB = headB;\r\n    while (curA != curB) {\r\n        curA = curA == null ? headB : curA.next;\r\n        curB = curB == null ? headA : curB.next;\r\n    }\r\n    return curA;\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doveshnnqkl":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916614606","body":"# 思路\n* 从末尾开始遍历数组，最后一位与k最后一位相加，将K除以10取整，有进位加进位，循环\n* 数组遍历完  k还大于0，将k取余放入List, k除以10取整，循环\n* * *\n# 代码\n* 语言：Java\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       LinkedList<Integer> ret = new LinkedList();\n       int index  = 0 ;\n       for(int i = num.length - 1; i >= 0 ; i--){\n          int   sum =  num[i];\n         \n                sum +=  k % 10 + index;\n                 k = k/10;\n          \n          if(sum >= 10){\n              sum =  sum - 10;\n              k++;\n          }\n          ret.addFirst(sum);\n       }\n       while(k > 0){\n           ret.addFirst(k%10);\n           k = k/10;\n       }\n     \n       return ret;\n    }\n}\n```\n* * *\n# 复杂度\n* 时间复杂度O(n)\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917328807","body":"# 思路\n1.找出字符串中出现的字符的位置，放入List\n2.遍历字符串，找到List中第一个大于当前位置的数。\n3.如果找到的数位置是List 中下标为0， 新数组的数就是 list[0] - 遍历中的字符串当前位置\n4.如果找到的数位置下比0大， 比较  List 前一个数 和 找到的数， 分别做差求绝对值，取出较小的数。\n# 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n           int strLength =  s.length();\n           int[] res = new int[strLength]; \n           List<Integer> l =  new ArrayList<>();\n           for(int i = 0; i < strLength; i++){\n               char s2c =  s.charAt(i);\n               if(s2c == c){\n                   l.add(i);                 \n               }\n           }\n           for(int i = 0; i<strLength;i++){\n               int j = 0;\n               int num = l.get(j);\n               for(;j < l.size();j++){\n                   if(l.get(j) >= i){\n                       num = l.get(j);\n                       break;\n                   }\n               }\n               if(j == 0){\n                 res[i] = Math.abs(num - i);  \n               }else{\n                 res[i] = Math.min(Math.abs(l.get(j-1) -i),Math.abs(num - i));\n               }             \n           }        \n            return res;\n    }\n}\n```\n# 复杂度\n* 时间复杂度：O(n^2)\n* 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917574673","body":"# 思路\n    用Linkedlist当作栈，取一个变量当作指针，指针超过最大容量，不再往栈里存放数据。添加和入出栈操作指针加减一\n# 代码\n* java\n```java\nclass CustomStack {\n    private int index = -1;\n    private int max;\n    public LinkedList<Integer> list =  new LinkedList<>();\n    public CustomStack(int maxSize) {\n          max = maxSize;\n    }\n    \n    public void push(int x) {\n        if(index < max -1){\n           index++;\n           list.addLast(x);         \n        }\n    }\n    \n    public int pop() {\n           if(index == -1){\n               return index;\n           }\n           index--;\n           return list.removeLast();\n    }\n    \n    public void increment(int k, int val) {\n         int changeSize = 0;\n         int listSize = list.size();\n         LinkedList<Integer> temp =  new LinkedList<>();\n         while(changeSize < listSize){\n             if(changeSize < k){\n               temp.addLast(list.get(changeSize) + val);\n             }else{\n               temp.addLast(list.get(changeSize));\n             }\n             changeSize++;\n         }   \n         list =  temp;\n    }\n}\n```\n# 复杂度\n时间复杂度： O（N）\n空间复杂度： O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917833163","body":"# 思路\n遍历字符串，除了\"]\" ，其他一律入栈（数字可能需要拼接后再入栈），遇到\"]\" 开始出栈，从栈顶开始出栈直到遇到\"[\"，拼接出栈的这部分字母，再出栈一个就是这部分字母出现的次数，组合成字符串后重新入栈。最后将栈里所有字符拼接\n#代码\n* java \n```java\nclass Solution {\n    int ptr;\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        StringBuffer ret = new StringBuffer();\n        ptr = 0;    \n        while (ptr < s.length()) {\n             char c = s.charAt(ptr);\n             if(Character.isDigit(c)){\n                String intStr =   getIntStr(s);\n                stk.add(intStr);\n             }else if(Character.isLetter(c) || c == '['){\n                stk.add(Character.toString(c));      \n                 ptr++;       \n             }else{ //开始出栈   \n                 ptr++;          \n                 LinkedList<String> sub = new LinkedList<String>();\n                 while (!\"[\".equals(stk.peekLast())) {\n                    sub.add(stk.removeLast());\n                }              \n              // 移除\"[\"\n               stk.removeLast();\n             //   获得正整数\n               int repTime = Integer.parseInt(stk.removeLast());\n               Collections.reverse(sub);\n                StringBuffer t = new StringBuffer();\n                String o = getLinkedStr(sub);\n               while(repTime > 0){\n                   t.append(o);\n                   repTime--;\n               }\n                stk.add(t.toString());\n             }           \n        }\n\n        return  getLinkedStr(stk);\n    }\n\n    private String  getIntStr(String s){\n                StringBuffer sb =  new StringBuffer();\n                while(Character.isDigit(s.charAt(ptr))){                 \n                    sb.append(s.charAt(ptr++));                  \n                }\n                return sb.toString();\n    }\n\n    private String getLinkedStr(LinkedList list){\n         StringBuffer sb =  new StringBuffer();\n               for(int i = 0 ; i < list.size() ; i++){\n                   sb.append(list.get(i));\n               }\n               \n                return sb.toString();\n    }\n}\n```\n# 复杂度\n时间复杂度: O(n) \n\n空间复杂度: O(n) \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918737411","body":"# 思路 \n2个栈，存队列元素时，一个栈用于存数据，数据直接push进栈。取队列头元素的时候，将另一个栈push 进第一个栈pop的全部元素，反转第一个栈的元素，队列头就是栈顶元素 直接pop出。\n# 代码\n* java\n```java\nclass MyQueue {\n\n      Stack<Integer> s1;\n      Stack<Integer> s2;\n      int front;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        s1 =  new Stack<>();\n        s2 =  new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n       if(s1.empty()){\n           front = x;\n       }\n       s1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(!s2.empty()){\n           return s2.pop();\n        }else{\n            while(!s1.empty()){\n                  s2.push(s1.pop());\n            }\n        }\n        return s2.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(!s2.empty()){\n            return s2.peek();\n        }\n        return front;\n      \n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n         if(s1.empty() && s2.empty()){\n             return true;\n         }\n         return false;\n    }\n}\n```\n# 复杂度\n时间复杂度：存：O(1)，取：最坏情况下的时间复杂度 O(n)\n空间复杂度：存：O(n)，取：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919719733","body":"# 思路\n分块的原则是后一个块中的最小数字一定大于等于前一块中的最大数字。\n遍历数组，如果当前元素大于等于栈顶元素，入栈。反之，先记录栈顶元素（可看做块中最大元素），将栈顶元素出栈，继续比较出栈后的栈顶元素，如果还是比当前元素大，继续出栈，直到 栈空或者栈顶元素小于等于当前元素，再将记录的数（块中最大数）入栈。返回栈长度。\n# 代码\n* java\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n             LinkedList<Integer> list =  new LinkedList<>();\n             for(int i = 0; i < arr.length; i++){\n                 if(list.size() == 0){\n                     list.add(arr[i]);\n                     continue;\n                 }\n                 if(list.peekLast() <= arr[i]){\n                     list.add(arr[i]);\n                 }else{\n                     int first  = list.peekLast();\n                     while(list.size() > 0 && list.peekLast() > arr[i]){\n                         list.removeLast();\n                     }\n                     list.add(first);\n                 }\n             }\n             return list.size();\n    }\n}\n```\n# 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920610048","body":"# 思路\n求链表长度，移动k位就是k除以长度的余数。余数为0表示没有移动，大于0 就是把链表末尾 数量等于余数 个数的元素移到开头\n# 代码\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null){\n            return head;\n        }\n        int l = 0 ;\n        ListNode node = new ListNode();\n         node = head;       \n        ListNode ret = new ListNode();\n        ListNode ret1 = new ListNode();\n        ret1 = node;\n        while(head != null){\n            l++;\n            head = head.next;\n         }\n        int cyc =  k % l; //将链表末尾的cycle个元素移动到头部\n        if(cyc == 0){\n            return node;\n        }\n        int i = 1;\n        while(node != null){\n           if(i == (l - cyc)){\n               ret = node.next;\n               node.next = null;\n               break;\n           }\n           i++;\n           node = node.next;\n        }\n        ListNode ret2 = ret;\n        while(ret.next != null){\n            ret = ret.next;\n        }\n        ret.next = ret1;\n        return ret2 ;\n    }\n}\n```\n# 复杂度\n时间：O(n) 需要遍历2次链表，第一次求长度，第二次遍历到移动位置截断，截断后在截断位置继续遍历到末尾元素使末尾元素的下一个元素等于头元素 \n空间：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921404872","body":"# 思路\n遍历链表，每次遍历2个元素，交换。最后拼接上剩下的单个元素\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode ret =  new ListNode(0);\n        ListNode ret2 =  ret;\n        while(head != null && head.next != null){\n            ListNode temp =  head.next.next;//[3,4]\n            ret.next =  head.next; //[0,2,3,4]\n            head.next.next = head;//[0,2,1]\n            head.next = null;//[0,2]\n            ret = ret.next.next;          \n            head = temp;          \n        }\n        ret.next = head;\n        return ret2.next;             \n    }\n}\n```\n# 复杂度\n空间复杂度 O(1)  \n时间复杂度 O(n)  \n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922412496","body":"# 思路\n双指针\n同时遍历a,b链表，当遍历到a末尾，重定位到b链表头，当遍历到b末尾，重定位到a链表头，如过有a等于b 返回该节点，如果有a等于b等于Null,说明没有交点\n# 代码\njava\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != b){\n              a = a.next;\n              b = b.next;\n              if(a == null && b == null){\n                  return null;\n              }\n              if(a == null){\n                  a = headB;\n              }\n              if(b == null){\n                  b = headA;\n              }\n                      \n        } \n        return a;\n        \n    }\n}\n```\n# 复杂度\n时间复杂度O(n+m) n：a链表长度，m：b链表长度\n空间复杂度O(1) \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916615519","body":"# Understand:\n```\n1 <= num.length <= 10^4\n0 <= num[i] <= 9\nnum does not contain any leading zeros except for the zero itself.\n1 <= k <= 10^4\n\nmost significant -> least significant digit\n```\n\n# Plan: \n```\ngo backward, track carry and sum for the current digit\nuse LinkedList for result\n```\n\n# Review:\n```\nnum = [9, 9, 9], k = 1 -> 1000\n\n999\n  1\n \n1000\n\nnum = [1], k = 999\n\n  1\n999\n\n\nnum = [1], k = 9\n```\n\n# Evaluate:\n```\nm = num.length, n = number of digits in k, log(10)k\n\nTime: O(max(m, n))\n\nSpace: O(max(m, n)) for the output list\n```\n\n# Code: \n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> sum = new LinkedList<>();\n        int carry = 0, curDigit = 0;\n        \n        for (int i = num.length - 1; i >= 0; i--) {\n            curDigit = k % 10 + num[i] + carry;\n            carry = curDigit / 10;\n            curDigit = curDigit % 10;\n            k /= 10;\n            sum.addFirst(curDigit);\n        }\n        \n        while (k > 0) {\n            curDigit = k % 10 + carry;\n            carry = curDigit / 10;\n            curDigit = curDigit % 10;\n            k /= 10;\n            sum.addFirst(curDigit);\n        }\n        \n        if (carry == 1) {\n            sum.addFirst(carry);\n        }\n        \n        return sum;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917382405","body":"# https://leetcode.com/problems/shortest-distance-to-a-character/\n\n# Understand:\n```\n1 <= s.length <= 10^4\ns[i] and c are lowercase English letters.\nIt is guaranteed that c occurs at least once in s.\n```\n# Plan:\n```\n1. bruteforce: expand into left and right\n\ncurrent char == c, 0\notherwise, expand out to find the closest matches in the left and right (note, there might be no match)\n\n## Time: O(s.length() ^ 2)\n\n## Space: O(1)\n\n2. auxiliary list to store matched indices\n\nfind the closet match (by traversing)\n\nmatched indices list size = k, k is bounded by s.length()\n\n## Time: O(s.length()) + O(s.length() * k)\n\n## Space: O(k)\n\n3. dp: two lists to store the leftmost & rightmost matched indices\n\nleft to right traversal to build leftclosestIndices\nright to left traversal to build rightclosestIndices\n\ntraverse the s to compute the min distance\n\n3-1 optimization: get the closer (instead of right) indices in the second traversal \n3-2 optimization: prevent the final traversal, directly update closest distances in the array\n\n## Time: O(s.length())\n## Space: O(s.length())\n\n4. see the matched chars in s as boundaries/splitters\nsliding window\n\n## Time: O(s.length()) !!!, l and r will travel O(s.length())\n## Space: O(1)\n```\n# Review:\n```\nInput: s = \"loveleetcode\", c = \"e\"\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\n\n\"aaba\"\n\"b\"\n[2,1,0,1]\n```\n\n# Code: \n```jave\nclass Solution {\n    // 4. sliding window: see the matched chars in s as boundaries/splitters\n    // m**  -> intial l = 0, r = 0\n    // *m   -> initial l = -1, r = 1\n    public int[] shortestToChar(String s, char c) {\n        int[] distances = new int[s.length()]; // initialized as max's\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        \n        int l = 0, r = 0;\n        \n        l = s.charAt(0) == c ? 0 : -1; //-1:not finding left boundary for cur window\n        r = findNextRight(s, c, 0);\n        \n        for (int i = 0; i < s.length(); i++) {\n            // compare distances from l and r\n            if (l != -1) { // has left boundary\n                distances[i] = i - l;\n            }\n            if (r != -1) {\n                distances[i] = Math.min(distances[i], r - i);\n            }\n                \n            // slides to the next window when we reach the right boundary\n            if (i == r) {\n                l = r;\n                r = findNextRight(s, c, l + 1);\n            }\n        }\n        return distances;\n    }\n    \n    // time: O(s.length())\n    private int findNextRight(String s, char c, int start) {\n        int i = 0;\n        for (i = start; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                return i;\n            }\n        }\n        return -1; // cannot find a match after (including) start index\n    }\n    \n    // 3-2 optimization: prevent the final traversal, directly update closest distances in the array - clean \n    public int[] shortestToChar_3_2_clean(String s, char c) {\n        \n        int[] closest = new int[s.length()];\n        Arrays.fill(closest, Integer.MAX_VALUE);\n        \n        // find the closest \n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                closest[i] = 0;\n            }\n            // else !! if closest[i - 1] == Integer.MAX_VALUE, no match on its left\n            else if (i > 0 && closest[i - 1] != Integer.MAX_VALUE) {\n                closest[i] = closest[i - 1] + 1;\n            } \n        }\n\n        // the last val in closest won't be max given >=1 match exists\n        for (int i = s.length() - 1; i >= 0; i--) { \n            // no match on its left or cur index is closer to the right match\n            if (closest[i] == Integer.MAX_VALUE || \n                (i < s.length() - 1 && closest[i] > closest[i + 1] + 1)) {\n                closest[i] = closest[i + 1] + 1;\n            }\n        }\n        \n        return closest;\n    }\n    \n    // direction 3 - 1: clean \n    // time: O(s.length())\n    // space: O(s.length())\n    public int[] shortestToChar_3_1_clean(String s, char c) {\n        int[] distances = new int[s.length()]; // initialized as 0's\n        int[] closestIndices = new int[s.length()];\n        Arrays.fill(closestIndices, Integer.MAX_VALUE);\n        \n        // find the closest \n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                closestIndices[i] = i;\n            }\n            // else !! if closestIndices[i - 1] == Integer.MAX_VALUE, no match on its left\n            else if (i > 0 && closestIndices[i - 1] != Integer.MAX_VALUE) {\n                closestIndices[i] = closestIndices[i - 1];\n            } \n        }\n\n        // the last val in closestIndices won't be max given >=1 match exists\n        // find closest index on the right, think about ** * m, ***\n        for (int i = s.length() - 1; i >= 0; i--) { \n            // no match on its left or cur index is closer to the right match\n            if (closestIndices[i] == Integer.MAX_VALUE || \n                (i < s.length() - 1 && i - closestIndices[i] > closestIndices[i + 1] - i)) {\n                closestIndices[i] = closestIndices[i + 1];\n            }\n        }\n        // calculate the min distance\n        for (int cur = 0; cur < s.length(); cur++) {\n            if (s.charAt(cur) == c) {\n                continue;\n            }\n            distances[cur] = Math.abs(closestIndices[cur] - cur);\n        }\n        \n        return distances;\n    }\n    \n    // not clean\n    // 3-1 optimization: get the closer (instead of right) indices in the second traversal \n    public int[] shortestToChar3_1(String s, char c) {\n        int[] distances = new int[s.length()]; // initialized as 0's\n        \n        int[] closestIndices = new int[s.length()];\n        \n        int left = -1, right = -1;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                closestIndices[i] = i;\n                left = i;\n            } else {\n                closestIndices[i] = left;\n            }\n        }\n        \n        for (int i = s.length() - 1; i >= 0; i--) {  \n            if (s.charAt(i) == c) {\n                closestIndices[i] = i;\n                right = i;\n            } \n            // when to update closestIndices[i]\n            if (closestIndices[i] == -1 || (closestIndices[i] != -1 && right != -1 && i - closestIndices[i] > right - i)) { // note this condition\n                closestIndices[i] = right;\n            }\n        }\n        \n        for (int cur = 0; cur < s.length(); cur++) {\n            if (s.charAt(cur) == c) {\n                continue;\n            }\n            distances[cur] = Math.abs(closestIndices[cur] - cur);\n        }\n        \n        return distances;\n    }\n    \n    // not clean\n    // 3. dp: two lists to store the leftmost & rightmost matched indices\n    public int[] shortestToChar3(String s, char c) {\n        int[] distances = new int[s.length()]; // initialized as 0's\n        \n        int[] leftclosestIndices = new int[s.length()];\n        int[] rightclosestIndices = new int[s.length()];\n        \n        int left = -1, right = -1;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                leftclosestIndices[i] = i;\n                left = i;\n            } else {\n                leftclosestIndices[i] = left;\n            }\n        }\n        \n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                rightclosestIndices[i] = i;\n                right = i;\n            } else {\n                rightclosestIndices[i] = right;\n            }\n        }\n\n        for (int cur = 0; cur < s.length(); cur++) {\n            if (s.charAt(cur) == c) continue;\n            \n            if (leftclosestIndices[cur] != -1) {\n                distances[cur] = cur - leftclosestIndices[cur];\n            }\n            \n            if (rightclosestIndices[cur] != -1) {\n                if (distances[cur] != 0) {\n                    distances[cur] = \n                        Math.min(distances[cur], rightclosestIndices[cur] - cur);\n                } else {\n                    distances[cur] = rightclosestIndices[cur] - cur;\n                }\n                \n            }\n        }\n        \n        return distances;\n    }\n    \n    // 2. auxiliary list to store matched indices\n    public int[] shortestToChar2(String s, char c) {\n        int[] distances = new int[s.length()]; // initialized as 0's\n        \n        List<Integer> indices = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                indices.add(i);\n            }\n        }\n        \n        for (int cur = 0; cur < s.length(); cur++) {\n            if (s.charAt(cur) != c) {\n                for (int index : indices) {\n                    int dist = Math.abs(index - cur);\n                    if (distances[cur] == 0) {\n                        distances[cur] = dist;\n                    } else {\n                        if (distances[cur] > dist) {\n                            distances[cur] = dist;\n                        } else {\n                            break;// no need to keep on search\n                        }\n                    }\n                }\n            }\n        }\n        \n        return distances;\n    }\n    \n    // 1. bruteforce: expand into left and right\n    public int[] shortestToChar1(String s, char c) {\n        int[] distances = new int[s.length()]; // initialized as 0's\n        \n        for (int cur = 0; cur < s.length(); cur++) {\n            if (s.charAt(cur) != c) {\n                // expand into 2 directions\n                int left = cur - 1, right = cur + 1;\n                \n                for (int i = left; i >= 0; i--) {\n                    if (s.charAt(i) == c) {\n                        left = i;\n                        break;\n                    }\n                }\n                \n                for (int j = right; j < s.length(); j++) {\n                    if (s.charAt(j) == c) {\n                        right = j;\n                        break;\n                    }\n                }\n                \n                // check if found\n                if (left >= 0 && s.charAt(left) == c) {\n                    distances[cur] = cur - left;\n                }\n                if (right < s.length() && s.charAt(right) == c) {\n                    distances[cur] = distances[cur] == 0 ? right - cur : Math.min(distances[cur], right - cur);\n                }\n            }\n        }\n        return distances;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917575242","body":"# https://leetcode.com/problems/design-a-stack-with-increment-operation/\n\n# Understand:\n```\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\nAt most 1000 calls will be made to each method of increment, push and pop each separately.\n\nIncrements the bottom k elements of the stack by val. If there are less than k elements in the stack, just increment all the elements in the stack.\n```\n# Plan:\n```\n1. Bruteforce Logic:\ncapacity : the max capacity of the stack\nsize : the current size of stack\nuse array to store elements\n\nPush: if it is not full, push, size++\nPop: if it is empty, return -1; else size--, return stack[size]\nIncrement: iterate based on min(k, size) and increment \n\n// https://www.techiedelight.com/iterate-through-stack-java/\n\n## Complexity:\nTime: Pop, Push O(1); Increment O(min(k, size)) \nSpace: O(maxSize)\n\n2. prefix sum\nimprove time using auxiliary space\n\ninc array\n\npop: empty check,\n\nint ans = stack[size - 1] + inc[size - 1];\n        \n        // at least 1 element left after popping\n        if (size >= 2) {\n            inc[size - 2] += inc[size - 1];\n        }\n        \n        // clear that cell\n        inc[size - 1] = 0;\n        size--;\n\nExample：\n\nafter pushing, \nstack:[1,2,3]\n\ninc:[0,0,0]\n         k.val          inc            expected stack status\nincrement(3,3)       [0,0,3]            [4,5,6]\nincrement(2,1)       [0,1,3]            [5,6,6]\nincrement(1,1)       [1,1,3]            [6,6,6]\n\npop(): 3+3=6, inc:[1,1+3]\npop(): 2+4=6, inc:[5]\npop(): 1+5=6, inc:[]\n\n[\"CustomStack\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[3],[3,3],[2,1],[1,1],[],[],[]]\n\n->\n[null,null,null,null,null,null,null,6,6,6]\n\n\npush: check capacity, push, increment size\n\nincrement: empty check, inc[Math.min(k, size) - 1] += val;\n\n## Complexity:\nTime: Pop, Push. Increment O(1)\nSpace: O(maxSize/n) amortized, n=number of operations\n\n3. optimized prefix sum with lists representation\n每次栈 push 的时候，incrementals 也 push 一个 0,不用初始化maxsize的数组\n\n## Complexity:\n\nTime: Pop, Push. Increment O(1)\nSpace: O(max size/n) amortized, n=number of operations, max size bounded by the given maxSize\n\nhttps://stackoverflow.com/questions/43145395/time-complexity-while-deleting-last-element-from-arraylist-and-linkedlist\n\n\n[\"CustomStack\",\"push\",\"pop\",\"push\",\"increment\",\"pop\"]\n[[3],[1],[],[2],[5,100],[]]\n\n[null,null,1,null,null,102]\n```\n\n# Code: \n```java\n\n// 3. with lists\n\nclass CustomStack {\n    int capacity;\n    int size;\n    List<Integer> stack;\n    List<Integer> inc;\n    \n    public CustomStack(int maxSize) {\n        capacity = maxSize;\n        size = 0;\n        stack = new ArrayList<>();\n        inc = new ArrayList<>();\n    }\n    \n    public void push(int x) {\n        if (size < capacity) {\n            stack.add(x);  // stack: bottom -> top\n            inc.add(0);\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if (size == 0) return -1;\n        \n        int ans = stack.get(size - 1) + inc.get(size - 1);\n        // at least 1 element left after popping\n        if (size >= 2) {\n            inc.set(size - 2, inc.get(size - 2) + inc.get(size - 1));\n        }\n        \n        // remove the tail of inc and stack lists\n        inc.remove(size - 1); // by index, O(1)\n        stack.remove(size - 1); // this line is needed in list implementation, as we use stack[size] = x; in array but use add(x) in list implementation\n        \n        size--;\n        \n        return ans;\n    }\n    \n    public void increment(int k, int val) {\n        // empty check\n        if (size > 0) {\n            inc.set(Math.min(k, size) - 1, inc.get(Math.min(k, size) - 1) + val);\n        }\n    } \n}\n\n\n// 2.prefix sum\n/*\nclass CustomStack {\n    int capacity;\n    int size;\n    int[] stack;\n    int[] inc;\n    \n    public CustomStack(int maxSize) {\n        capacity = maxSize;\n        size = 0;\n        stack = new int[capacity];\n        inc = new int[capacity];\n    }\n    \n    public void push(int x) {\n        if (size < capacity) {\n            stack[size] = x;\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if (size == 0) return -1;\n        \n        int ans = stack[size - 1] + inc[size - 1];\n        \n        // at least 1 element left after popping\n        if (size >= 2) {\n            inc[size - 2] += inc[size - 1];\n        }\n        \n        // clear that cell\n        inc[size - 1] = 0;\n        \n        size--;\n        \n        return ans;\n    }\n    \n    public void increment(int k, int val) {\n        // empty check\n        if (size > 0) {\n            inc[Math.min(k, size) - 1] += val; // note - 1 here, in pop() we need to clear inc[cell] \n        }\n    } \n}\n*/\n\n// 1. bruteforce\n/*\nclass CustomStack {\n    int capacity;\n    int size;\n    int[] stack;\n    \n    public CustomStack(int maxSize) {\n        capacity = maxSize;\n        size = 0;\n        stack = new int[capacity];\n    }\n    \n    public void push(int x) {\n        if (size < capacity) {\n            stack[size] = x;\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if (size == 0) return -1;\n        size--;\n        return stack[size];// note this line\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < Math.min(k, size); i++) {\n            stack[i] += val;\n        }\n    }\n}\n*/\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917850385","body":"# https://leetcode.com/problems/decode-string/\n\n# Understand:\n```\n1 <= s.length <= 30\ns consists of lowercase English letters, digits, and square brackets '[]'.\ns is guaranteed to be a valid input.\nAll the integers in s are in the range [1, 300].\n\nInput: s = \"3[a2[c]]\"\nOutput: \"accaccacc\"\n\nk is guaranteed to be a positive integer\n\nyou may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k.\n```\n\n# Plan: \n```\n2 stacks, Stack<StringBuilder>, Stack<Integer> \n\nk can be greater than 10\n\nif we see digit, build the complete integer (curFreq * 10 + s.charAt(curIndex) - '0')\n\nif we see letter, build the complete string (by curStr.append(s.charAt(curIndex));)\n\nif we see [, push curStr and curFreq into respective stacks, reset\n\n*if we see ], \ncurStr is the string to repeat\npop the top string, append the repeated string after it, it becomes the curStr\n```\n\n# Review:\n```\nInput: s = \"a3[a2[c]]e\"\nOutput: \"aaccaccacce\"\n\n\nc\n\na   2\na   3\n\n\nacc\n\na  3\n\ncurStr: aaccaccacc\n\ncurStr: aaccaccacce\n```\n\n# Evaluate: \n```\nTime: O(decoded res length)\n\nSpace: O(decoded res length)\n```\n\n# Code:\n```java\nclass Solution {\n    public String decodeString(String s) {\n        if (s.length() == 1) return s;\n        Stack<Integer> freqStack = new Stack<>();\n        Stack<StringBuilder> strStack = new Stack<>();\n        \n        int curIndex = 0;\n        StringBuilder curStr = new StringBuilder();\n        int curFreq = 0;   \n        \n        while (curIndex < s.length()) {\n            if (Character.isLetter(s.charAt(curIndex))) {\n                curStr.append(s.charAt(curIndex));\n            }\n            else if (Character.isDigit(s.charAt(curIndex))) {\n                curFreq = curFreq * 10 + s.charAt(curIndex) - '0';\n            }\n            else if (s.charAt(curIndex) == '[') {\n                strStack.push(curStr);\n                curStr = new StringBuilder();\n                \n                freqStack.push(curFreq);\n                curFreq = 0;\n            } else if (s.charAt(curIndex) == ']') {  // this part needs caution\n                StringBuilder temp = curStr; // temp is the str to repeat\n                curStr = strStack.pop();\n                \n                StringBuilder resStr = new StringBuilder();\n                int freq = freqStack.pop();\n                \n                for (int i = 0; i < freq; i++) {\n                    curStr.append(temp);\n                }\n                \n            }\n            curIndex++;\n        }\n        return curStr.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918823935","body":"# https://leetcode.com/problems/implement-queue-using-stacks/\n\n# Understand:\n```\n1 <= x <= 9\nAt most 100 calls will be made to push, pop, peek, and empty.\nAll the calls to pop and peek are valid.\n```\n# Plan:\n```\n2 stacks,\n\nbefore each push & pop, make sure all elements are in the right stack\n\none stack for push only, one stack for pop only\n```\n\n# Logic:\n```\n1. popStack is only responsible for the queue's pop op AND peek op\n2. pushStack is only responsible for the queue's push op\n\nBefore push, push all elements from popStack if any to pushStack, then push into pushStack\n\nBefore pop/peek, feed all elements from pushStack if any to popStack, then pop/peek from popStack\n\nEmpty: check if both are empty\n\ncase: \npush 1,2,3,4\npop (get 1)\npush 5\npop (get 2)\n```\n\n# Complexities:\n```\nTime: \nPush/pop/peek: O(N) for N elements, O(1) amortized\nSpace: O(N)\n```\n\n# Code:\n```java\nclass MyQueue {\n    Stack<Integer> pushStack, popStack;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        pushStack = new Stack<>();\n        popStack = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n\n        pushStack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919705435","body":"# https://leetcode.com/problems/max-chunks-to-make-sorted-ii/\n\n# Understand:\n```\ncan contain duplicates\n0 <= arr[i] <= 10^8\n1 <= arr.length <= 2000\n```\n\n# Plan: \n```\n[1,2,3] -> 3\n[3,2,1] -> 1\n[2,3,1] -> 1\n[1,2,2] -> 3\n[1,2,2,1] -> 1\n\n        _______\n___-----\n\nmax of current block <= any value of next block\n\neach cell in stack stores the max of the current block\n```\n\n# Evaluate:\n```\nTime: O(n), n = arr.length\nSpace: O(n)\n```\n\n# Review: \n```\n1 3 4 5 2\n\ngiven 2:\n\nstack:\n5\n4\n3\n1 \n\n2 should be fused with \"3 4 5\" - \"2,3,4\" should be fused with 5 together\nthe block max = 5\n```\n\n# Code: \n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> monostack = new Stack<>();\n        for (int num : arr) {\n            // empty or top < num\n            if (monostack.isEmpty() || monostack.peek() <= num) { \n                monostack.push(num);\n            }\n            else {  // not empty && top > num\n                // find the block where num should belong \n                int endBlock = monostack.pop(); \n                \n                while (!monostack.isEmpty() && num < monostack.peek()) {\n                    monostack.pop();\n                }\n                monostack.push(endBlock);\n            }\n        }\n        return monostack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920593335","body":"# https://leetcode.com/problems/rotate-list/\n\n# Understand:\n```\nThe number of nodes in the list is in the range [0, 500].\n-100 <= Node.val <= 100\n0 <= k <= 2 * 10^9\n\nk can be larger than list.length\nhead can be null\n```\n\n# Plan:\n```\n1.get len of linkedlist\nk = k % len;\n\n2. fast & slow pointer\n\n1->2->3 |->4->5\n         k=2. \n         \n1->2->3 |->4->5\n      s       f   \n        \nget tail: fast pointing to tail \n\nfast proceeds by k steps first, and then both slow and fast proceed one node each step until fast.next == null\n\n// after find the fast and slow\nfast.next = head;\nhead = slow.next;\nslow.next = null;\n\nreturn head;\n```\n\n# Evaluate:\n```\nTime: O(n), n = len of list\nSpace: O(1)\n```\n# Code: \n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return null;\n        \n        int len = getLen(head);\n        k = k % len;\n        \n        ListNode fast = head, slow = head;\n        \n        while (fast.next != null) {\n            // use k as a counter\n            if (k <= 0) {\n                slow = slow.next;\n            }\n            fast = fast.next;\n            k--;\n        }\n        \n        fast.next = head;\n        head = slow.next;\n        slow.next = null;\n\n        return head;\n    }\n    \n    \n    // O(n) time\n    private int getLen(ListNode head) {\n        if (head == null) return 0;\n        int len = 0;\n        ListNode cur = head;\n        while (cur != null) {\n            len++;\n            cur = cur.next;\n        }\n        return len;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921518113","body":"\n# Understand:\n```\nThe number of nodes in the list is in the range [0, 100].\n0 <= Node.val <= 100\n```\n# Plan:\n```\nodd, even number\niteratively\n\ntwo pointers\ndummy node\n```\n# Evaluate:\n```\nTime: O(n), n = length of list\n\nSpace: O(1)\n```\n\n# Code: \n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // 0 or 1 node\n        if (head == null || head.next == null) return head;        \n        ListNode dummy = new ListNode(0, head);\n        ListNode cur = dummy, n1 = cur.next, n2 = n1.next;\n        ListNode nextNode = null;\n        while (n1 != null && n2 != null) {\n            nextNode = n2.next;\n            \n            cur.next = n2;\n            n2.next = n1;\n            n1.next = nextNode;\n            \n            cur = n1;\n            n1 = nextNode;\n            if (n1 == null) {\n                break;\n            }\n            n2 = n1.next;\n        }\n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922208126","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n```\r\n\r\n\r\n# Logic:\r\n```\r\nhttps://github.com/azl397985856/leetcode/blob/master/thinkings/balanced-tree.md\r\nhttps://algo91.herokuapp.com/solutionDetail?type=3&id=9&max_id=2\r\n\r\ntwo base cases\r\nfast, slow node, dummy head\r\ncut the root out, call recursion\r\n```\r\n# Complexity:\r\n```\r\nTime:\r\nT(n) = 2*T(n/2) + n/2\r\n\r\nO(nlogn)\r\n\r\nin total O(logn) layers in the tree, n/2 of work for each layer\r\n\r\nSpace:\r\nO(height) = O(logn), n = number of nodes\r\n```\r\n\r\n# Code:\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        // 2 base cases\r\n        if (head == null) return null;\r\n        // one node\r\n        if (head.next == null) {\r\n            return new TreeNode(head.val, null, null);\r\n        }\r\n        \r\n        // dummy head\r\n        ListNode dummy = new ListNode(-1, head);\r\n        // fast and slow pointers\r\n        ListNode fast = head, slow = head, pre = dummy;\r\n        \r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            pre = pre.next;\r\n        }\r\n        // cut in the middle\r\n        ListNode head2 = slow.next;\r\n        slow.next = null;\r\n        pre.next = null;\r\n        \r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(head2);\r\n        \r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922421437","body":"\n# Logic:\n```\nGet len(A), len(B)\nassume A is longer (otherwise swap)\n\nfast pointer moves len(A) - len(B) in A\nslow starts at 0 in B\n\nfast and slow move 1 step until they meet at the intersection\n```\n# Complexity:\n```\nTime: O(len(A) + len(B))\nSpace:O(1)\n```\n# Code:\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = getLen(headA);\n        int lenB = getLen(headB);\n        if (lenA < lenB) {\n            ListNode temp = headA;\n            headA = headB;\n            headB = temp;\n        }\n        ListNode fast = headA, slow = headB;\n        for (int i = 0; i < Math.abs(lenA - lenB); i++) {\n            fast = fast.next;\n        }\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n    \n    private int getLen(ListNode head) {\n        if (head == null) return 0;\n        if (head.next == null) return 1;\n        int len = 0;\n        ListNode cur = head;\n        while (cur != null) {\n            len++;\n            cur = cur.next;\n        }\n        return len;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuWF":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916616395","body":"- convert num to int\n- add num to k\n- iterate through total by making it a string, add to res list\n- time complexity: O(N), N is the num list length\n- space complexity: O(M), M is the num list length\n\n\n\nCode:\n\n```python\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n    total = 0\n    index = 0\n    \n    for n in num[::-1]:\n        total += (10 ** index) * n\n        index += 1\n    \n    total += k\n    \n    res = []\n    for digit in str(total):\n        res.append(int(digit))\n    \n    return res\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917335074","body":"### 📜Notes:\n\n2 pass solution:\n\n- forward iteration to mark res[i] distance closest to target character on the left\n- backward iteration to mark res[i] distance closest tot target character on the right\n- time: O(N), length of s\n- space: O(N)\n\n\n\n------\n\n\n\n### 💻Code:\n\n```python\n# 2 pass\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # len(s) is 1 bigger than max distance\n        res = [len(s)] * len(s)\n        \n        leftMost = rightMost = -1\n        \n        for i in range(len(s)):\n            if s[i] == c: leftMost = i\n            if leftMost != -1:\n                res[i] = i - leftMost\n        \n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c: rightMost = i\n            if rightMost != -1:\n                res[i] = min(res[i], rightMost - i)\n        \n        return res\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917489775","body":"### 📜Notes:\n\n- doubly linked list: access to both bottom and top stack\n- push: O(1)\n- pop: O(1)\n- increment: O(K), k is the number of values to increment\n\n\n\n------\n\n\n\n### 💻Code:\n\n```python\nclass Node:\n    \n    def __init__(self, val):\n        self.val = val\n        self.next = None\n        self.prev = None\n        \nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.head = None\n        self.tail = None\n        self.maxSize = maxSize\n        self.currSize = 0\n\n    def push(self, x: int) -> None:\n        if self.currSize >= self.maxSize: return\n        \n        self.currSize += 1\n        if self.head is None: \n            self.head = Node(x)\n            self.tail = self.head\n            return\n        \n        temp = self.tail\n        self.tail.next = Node(x)\n        self.tail = self.tail.next\n        self.tail.prev = temp\n        \n    def pop(self) -> int:\n        if self.currSize == 0: return -1\n        \n        self.currSize -= 1\n        res = self.tail.val\n        self.tail = self.tail.prev\n        \n        # re-init head and tail\n        if self.tail is None:\n            self.head = None\n            return res\n        self.tail.next = None\n        \n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        curr = self.head\n        for i in range(min(k, self.currSize)):\n            curr.val += val\n            curr = curr.next\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917767541","body":"### 💻Code:\n\n```python\n# use stack to store a pair number of times + the string to repeat\n# use currCount to store how many times to repeat current substring\n# use currString to store current string iterated so far\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        currString = ''\n        currCount = 0\n        stack = []\n        \n        for char in s:\n            if char.isdigit():\n                currCount = currCount * 10 + int(char)\n            elif char == '[':\n                # start of a new subtring\n                # store currCount and string\n                # reset currCount and string\n                \n                stack.append(currString)\n                stack.append(currCount)\n                currString = ''\n                currCount = 0\n            elif char == ']':\n                # end of this substring\n                # pop stack top string pair and add to current String\n                \n                count = stack.pop()\n                string = stack.pop()\n                currString = string +  count * currString\n            else:\n                currString += char\n                \n        return currString\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918691960","body":"### 💻Code:\n\n```python\n# push, empty: O(1)\n# pop, peek: O(N)\n\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        stack2 = []\n        while self.stack:\n            stack2.append(self.stack.pop())\n        res = stack2.pop()\n        \n        while stack2:\n            self.stack.append(stack2.pop())\n        \n        return res\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        stack2 = []\n        while self.stack:\n            stack2.append(self.stack.pop())\n        res = stack2[-1]\n        \n        while stack2:\n            self.stack.append(stack2.pop())\n        \n        return res\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.stack) == 0xxxxxxxxxx # use stack to store a pair number of times + the string to repeat# use currCount to store how many times to repeat current substring# use currString to store current string iterated so farclass Solution:    def decodeString(self, s: str) -> str:        currString = ''        currCount = 0        stack = []                for char in s:            if char.isdigit():                currCount = currCount * 10 + int(char)            elif char == '[':                # start of a new subtring                # store currCount and string                # reset currCount and string                                stack.append(currString)                stack.append(currCount)                currString = ''                currCount = 0            elif char == ']':# push, empty: O(1)# pop, peek: O(N)class MyQueue:    def __init__(self):        \"\"\"        Initialize your data structure here.        \"\"\"        self.stack = []    def push(self, x: int) -> None:        \"\"\"        Push element x to the back of queue.        \"\"\"        self.stack.append(x)    def pop(self) -> int:        \"\"\"        Removes the element from in front of queue and returns that element.        \"\"\"        stack2 = []        while self.stack:            stack2.append(self.stack.pop())        res = stack2.pop()                while stack2:            self.stack.append(stack2.pop())                return res    def peek(self) -> int:        \"\"\"        Get the front element.        \"\"\"        stack2 = []        while self.stack:            stack2.append(self.stack.pop())        res = stack2[-1]                while stack2:            self.stack.append(stack2.pop())                return res    def empty(self) -> bool:        \"\"\"        Returns whether the queue is empty.        \"\"\"        return len(self.stack) == 0                # end of this substring                # pop stack top string pair and add to current String                                count = stack.pop()                string = stack.pop()                currString = string +  count * currString            else:                currString += char                        return currString\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919670850","body":"### 💻Code:\n\n```python\n# monotonic stack (ascending)\n# We are looking for the largest number that is smaller than n in an ascending array\n# stack stores the largest value in each chunk when the chunk cannot be partitioned to smaller ones.\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        \n        for n in arr:\n            curr_max = n\n            while stack and stack[-1] > n:\n                curr_max = max(curr_max, stack.pop())\n            stack.append(curr_max)\n        \n        return len(stack)\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920528139","body":"### 💻Code:\n\n```python\n# find total number of node\n# use slow, fast node to find the prev node of the cut-off list\n# disconnect cut-off tail to front and connect to head\n# time: O(N), number of nodes in the list\n# space: O(1)\n\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return head\n        if k == 0: return head\n        slow = fast = head\n        \n        count = 0\n        while slow:\n            slow = slow.next\n            count += 1\n        if k % count == 0: return head\n        slow = head\n        for i in range(k % count):\n            fast = fast.next\n        \n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n            \n        temp = slow.next\n        slow.next = None\n        res = temp\n        while temp.next:\n            temp = temp.next\n        temp.next = head\n        \n        return res\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921434801","body":"### 💻Code:\n\n```python\n# recursion: deal with a pair every time until not head or no head.next\n# time: O(N)\n# space: O(1)\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: return head\n\n        dummy = ListNode(-1)\n        dummy.next = head.next\n        \n        next_batch = head.next.next\n        head.next.next = head\n        \n        head.next = self.swapPairs(next_batch)\n        \n        return dummy.next\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922178814","body":"### 💻Code:\n\n```python\n# find the middle value of given list\n# create a root with that value\n# recursively find its left part middle value and right part middle value\n# time/space: O(N)\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head: return head\n        \n        prev, slow, fast = None, head, head\n        \n        while fast and fast.next:\n            fast = fast.next.next\n            prev = slow\n            slow = slow.next\n        \n        if prev: \n            prev.next = None\n        \n        root = TreeNode(slow.val)\n        \n        if slow == fast: \n            return root\n        \n        left = head\n        right = slow.next\n        \n        root.left = self.sortedListToBST(left)\n        root.right = self.sortedListToBST(right)\n        \n        return root\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922357584","body":"### 💻Code:\n\n```python\n# find the middle value of given list\n# create a root with that value\n# recursively find its left part middle value and right part middle value\n# time/space: O(N)\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head: return head\n        \n        prev, slow, fast = None, head, head\n        \n        while fast and fast.next:\n            fast = fast.next.next\n            prev = slow\n            slow = slow.next\n        \n        if prev: \n            prev.next = None\n        \n        root = TreeNode(slow.val)\n        \n        if slow == fast: \n            return root\n        \n        left = head\n        right = slow.next\n        \n        root.left = self.sortedListToBST(left)\n        root.right = self.sortedListToBST(right)\n        \n        return root\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JoeyChengTor":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916620734","body":"### 思路\n\n从数组最后一位到第一位进行遍历, 每次与 k % 10 和 carry 相加, carry = k // 10\n\n每次加完 i 往前退一位, k // 10\n\n所有数组里的数加完有两种情况\n\n1. k 还有剩余\n2. carry 还有剩余\n\n因为 carry 也是加在 k 的最后一位, 所以 k = k + carry 一起处理\n\n每次向数组前面添加 k % 10, 之后 k 取 k // 10\n\n### 代码\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        carry = 0\n        # reverse loop through num and add with each digit of k\n        for i in range(len(num) - 1, -1, -1):\n            val = carry + num[i] + k % 10\n            carry, num[i] = val // 10, val % 10\n            k = k // 10\n        \n        # if there's carry or k left need to add to front of array\n        k = carry + k\n        \n        while k > 0:\n            num = [k % 10] + num\n            k = k // 10\n\n        return num\n```\n\n\n\n### 复杂度\n\n时间复杂度: O(n) 遍历数组\n\n空间复杂度: O(1) 不使用额外空间\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917332667","body":"## 思路\n\n先建立 output 数组所有值为最大值 n\n\n正向遍历一次, 每次遇到 c 更新 l 的值为 c 的位置, 如果左边有 c 的话就更新 output 的值为 i - l 即为跟距离最靠近的左边的 c 的距离\n\n反向遍历一次, 每次遇到 c 更新 r 的值为 c 的位置, 如果右边有 c 点话就更新 output 为 min(output, r - j)\n\n## 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        n = len(s)\n        output = [n for _ in range(n)]\n\n        # forward pass the string s and calculate the distance based on the closest characater c on the left of each item\n        l = None\n        for i, w in enumerate(s):\n            if w == c:\n                output[i] = 0\n                l = i\n            else:\n                if l is not None:\n                    output[i] = i-l\n\n        # backward pass the stirng s and calculate the distance based on closest character c on the right of each item\n        r = None\n        for j in range(n-1, -1, -1):\n            w = s[j]\n            if w == c:\n                output[j] = 0\n                r = j\n            else:\n                if r is not None:\n                    output[j] = min(output[j], r-j)\n\n        return output\n```\n\n## 复杂度\n\n时间复杂度: O(n) 两次遍历都是 O(n) 时间复杂度\n\n空间复杂度: O(1) 常数级空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917513194","body":"## 思路\n\n用一个 list 来模拟栈, 同一个 size variable 来记录现在的 size 大小, 用一个 maxSize 来记录最大的size 大小, 用一个 increments 数组来记录 increments\n\nincrements 数组当有一个increment时, 记录在最右边的元素对应的increment数组中, 利用了stack从右向左 pop 的特性, 所以虽然 increment 的是底部 k 元素, 第一个 pop 的肯定是这些元素中最靠右的元素\n\n当这个元素被 pop 时, 先把 increment 和这个元素本身相加, 然后把 increment 传递给左边一个元素\n\n### push\n\n如果小于 max size, 那么就 self.stack 加入元素 x, self.increments 加入0, self.size + 1\n\n### pop\n\n如果 self.size 是 0 代表 stack 为空, return -1\n\n否则 将 self.size - 1, 然后 pop 最后一个 increments 数组里的元素\n\n如果 size 还是 > 0, 代表左边还有要被 increment 的元素, 把 increment 加到 increments[self.size-1] 的位置\n\n返回 self.stack.pop() + increment, 即这个数和increment的和\n\n### increment\n\n赋值 increment 给 increments 数组里下标为 min(k-1, self.size-1) 的index里\n\n不需要给前面每个都赋值, 利用了 stack 从右向左 pop 的特性, 每次 increment 被pop之后, 再将值向左传递即可\n\n## 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.size = 0\n        self.maxSize = maxSize\n        self.increments = []\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.increments.append(0)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        else:\n            self.size -= 1\n            increment = self.increments.pop()\n            if self.size > 0:\n                self.increments[self.size-1] += increment\n            return self.stack.pop() + increment\n        \n\n    def increment(self, k: int, val: int) -> None:\n        if self.size > 0:\n            self.increments[min(k-1, self.size-1)] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 复杂度\n\n时间复杂度: O(1) \n\n空间复杂度: O(size / N) 额外空间是 self.stack 和 self.increments 相同大小, size 为 size 最大的大小, N 为操作数, 小于等于 maxSize","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917830957","body":"## 思路\n\n遍历所有的字母\n\n如果是 `[, 0-9, a-z` 的情况, 直接放入栈中\n\n如果是 `]` 的情况, 说明要开始出栈找出 单词 word 和 `[` 前面的数字\n\n向前pop, 每次加到 word 中 知道栈顶元素为 `[` 代表 word 已经全部 pop 完了\n\npop 一次, 将栈中的 `[` pop 出\n\n继续 pop 得到栈中的数字, 有两种情况\n\n1. 如果 len(stack) == 0 代表 pop 完了, 此时 count 是完整的\n2. 如果 stack[-1] 不是 digit 代表 pop 完了, 此时 count 也是完整的\n\n最后将 count * word 得到新的 string 并放入栈中\n\n最后将栈中元素按相反顺序变成 string 即可\n\n## 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n\n        stack = []\n        i = 0\n\n        for c in s:\n            if c == \"]\":\n                count = ''\n                word = ''\n                # get word\n                while stack[-1] != \"[\":\n                    word = stack.pop() + word\n                stack.pop() # pop out [\n                # get num\n                while len(stack) > 0 and stack[-1].isdigit():\n                    count = stack.pop() + count\n                stack += int(count) * word\n            else:\n                stack.append(c)\n        \n        return ''.join(stack)\n```\n\n## 复杂度\n\n时间复杂度: O(n) 遍历一次单词, 栈里每个元素最多也是操作常数次\n\n空间复杂度: O(n) 栈最大可以达到 O(n) 的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918747962","body":"## 思路\n\n用两个stack实现queue其实原理是把elements先加入一个stack, 在分别pop加入另一个stack,这样元素在第二个stack中就变成了先进先出的顺序\n\n每次 pop 或者 peak 时, 如果第一个 stack 为空, 那么将第二个 stack 里的所有元素加入第一个stack, 这样就实现了 queue\n\n要注意的是第二个stack只有为空的时候才能从第一个stack加入数到第二个stack, 否则第一个stack中后来进入的数被加入到第二个stack中时会比原先在第二个stack中的数先被pop, 这样是错误的, 所以一定要等到第二个stack中所有数都被pop之后才能从第一个stack中pop数到第二个stack中去\n\n## 代码\n\n```python\nfrom collections import deque\n\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.s1 = deque()\n        self.s2 = deque()\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.s2.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if len(self.s1) == 0:\n            while len(self.s2) > 0:\n                self.s1.append(self.s2.pop())\n        \n        return self.s1.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if len(self.s1) == 0:\n            while len(self.s2) > 0:\n                self.s1.append(self.s2.pop())\n        \n        return self.s1[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.s1) == 0 and len(self.s2) == 0\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n## 复杂度\n\n时间复杂度: O(1)\n\n​\tpush O(1) 因为只是添加元素到栈尾\n\n​\tpop O(1) 因为平均每个数只会被 从 stack2 copy 到 stack1 一次\n\n​\tpeek O(1) 因为平均每个数只会被 从 stack2 copy 到 stack1 一次\n\n​\tempty O(1) 因为就是判断两个 stack 的 length\n\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919702185","body":"## 思路\n\n遍历整个数组, 如果遇到这个数字比栈尾还大, 那么可以加入栈, 因为这样的情况是可以拆分成 chunks 的\n\n如果这个数字比栈尾的还小\n\n​\t就需要融合 这个数字和之前所有比这个数字大的成为一块, 并用其中最大的数代替 (就是现在栈尾的数), 因为如果这个数前面有比这个数小的数, 那么肯定无法形成 sorted array, 所以只能融合成一块 array\n\n​\t先记录栈尾的数字, 然后一直 pop 直到栈为空或者栈尾数字比这个数字小, 因为如果栈尾比这个数字小, 那么两边分别 sort 合起来还是 sorted array\n\n如果这个数字比栈尾的大\n\n​\t那么直接 append 到 stack 末端\n\n最后返回 stack 的长度\n\n## 代码\n\n```python\nimport collections\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n\n        count = collections.Counter()\n        diff = 0\n        res = 0\n\n        for x, sx in zip(arr, sorted(arr)):\n            if count[x] == -1:\n                diff -= 1\n            if count[x] == 0:\n                diff += 1\n            count[x] += 1\n\n            if count[sx] == 1:\n                diff -= 1\n            if count[sx] == 0:\n                diff += 1\n            count[sx] -= 1\n\n            if diff == 0:\n                res += 1\n                \n        return res\n```\n\n## 复杂度\n\n时间复杂度: O(n) 遍历数组复杂度 O(n), stack里的所有元素最多 进去一次 pop 一次 也是 O(n), 所以最后是 O(n)\n\n空间复杂度: O(n) 辅助栈道大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920527292","body":"## 思路\n\n先遍历链表, 得到链表长度 length, 并且把最后一个 node 和链表头相连\n\n然后对于 k, 因为 rotate k 次和 rotate k % length 次是一样的结果\n\n这样只需要找到需要断开链表的地方, 需要断开链表的地方是倒数第 k+1 和倒数第 k 元素之间, 因为已经得到 length, 所以从 head 走 l - k - 1 步到倒数第 k+1 个 node\n\n然后, 倒数第 k+1 个 node 指向 None, 倒数第 k 个 node 成为新的 head\n\n## 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        \n        p = head\n        l = 1\n        while p.next:\n            p = p.next\n            l += 1\n\n        # connect last node with head\n        p.next = head\n        \n        k = k % l\n\n        p1 = head\n        for i in range(l-k-1):\n            p1 = p1.next\n        new_head = p1.next\n        p1.next = None\n        \n        return new_head\n```\n\n## 复杂度\n\n时间复杂度: O(n) n 为链表长度, 因为遍历链表不到两次\n\n空间复杂度: O(1) 常数级别空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921375760","body":"## 思路\n\n如果 head 或者 [head.next](http://head.next) 是 None, 无需swap, 所以 return head\n\n令 i 为 head, new_head 是 [head.next](http://head.next) 因为是第一个 swap 的pair\n\n如果 i 和 [i.next](http://i.next) 都不是 None 进入循环\n\n如果有 prev, [prev.next](http://prev.next) = i.next, 将 prev 和 next 相连\n\n将 i 和 [i.next](http://i.next) 换位\n\n将 prev = i 并且 i = [i.next](http://i.next) 进入下一个循环\n\n最后返回 new_head\n\n## 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        \n        i = head\n        new_head = head.next\n        \n        prev = None\n\n        while i and i.next:\n            if prev:\n                prev.next = i.next\n            tmp = i.next\n            i.next = tmp.next\n            tmp.next = i\n            \n            prev = i\n            i = i.next\n\n        return new_head\n```\n\n## 复杂度\n\n时间复杂度: O(n) 遍历了整个链表, 所以是 O(n)\n\n空间复杂度: O(1) 常数级别空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922171101","body":"## 思路\n\n先用快慢指针法, 快指针走两步, 慢指针走一步找到中点\n\n从中点前面断开链表\n\n​\t于是左子树是 head 开头到中点前面的链表 构成的 Tree\n\n​\t右子树是 [slow.next](http://slow.next) 开头到结尾的链表 构成的 Tree\n\n​\t根节点 是 slow.val 构成的 TreeNode\n\n递归构造 Tree\n\n## 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n\n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(val=head.val)\n        \n        prev, slow, fast = None, head, head\n\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if prev:\n            prev.next = None\n\n        left = self.sortedListToBST(head)\n        right = self.sortedListToBST(slow.next)\n        \n        node = TreeNode(val=slow.val, left=left, right=right)\n\n        return node\n```\n\n## 复杂度\n\n时间复杂度: O(nlogn), logn 是递归的深度, n 是每次递归树每一层的复杂度 (每一层复杂度相同)\n\n空间复杂度: O(logn), 每一层是常数级空间, 递归的深度是 logn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922404890","body":"## 思路\n\n遍历链表A, 将所有节点加入 set\n\n遍历链表B, 如果节点在 set 中, 那么就是相交的节点, 返回这个节点\n\n否则就返回 None, 代表没有相交的节点\n\n## 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        d = set()\n        while headA:\n            d.add(headA)\n            headA = headA.next\n        \n        while headB:\n            if headB in d:\n                return headB\n            headB = headB.next\n        \n        return None\n```\n\n## 复杂度\n\n空间复杂度: O(m+n) m 是链表 A 的长度, n 是链表 B 的长度, 因为最坏遍历两个链表各一次\n\n时间复杂度: O(m+n) m 是链表 A 的长度, n 是链表 B 的长度, 因为最坏可能遍历两个链表的所有元素","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922524016","body":"## 思路\n\n使用快慢指针技巧, 慢指针走一步快指针走两步\n\n这样如果快指针先碰到None, 那么代表没有环\n\n否则快指针会和慢指针在环里相遇, 相遇时再用一个新的指针从head, 慢指针从相遇点都以速度1前进, 再一次相遇点即是环起点\n\n## 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n\n        if not head or not head.next:\n            return None\n\n        slow, fast = head.next, head.next.next\n\n        while fast and fast.next and fast != slow:\n            slow = slow.next\n            fast = fast.next.next\n\n        if not fast or not fast.next:\n            return None\n        \n        new = head\n\n        while new != slow:\n            new = new.next\n            slow = slow.next\n        \n        return slow\n```\n\n## 复杂度\n\n时间复杂度: O(n) n 为链表长度, 因为慢指针两次都没有遍历完整个链表, 快指针 走的路第一次是慢指针的 2 倍, 第二次相同, 所以时间复杂度是 O(n)\n\n空间复杂度: O(1) 只用了常数级别空间\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ForLittleBeauty":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916622948","body":"## 思路\n\n***\n\n将给定的list反转后遍历，遍历的每一位与k的最低位，进位数相加，记录进位，并把个位加入最终的结果数组。之后更新k。有两种情况：\n\n- list遍历完了k还有值，那么后面继续把k没用完的位数加入结果数组，这样总体时间复杂度由logk决定\n- k先到0，list还没遍历完，那么其实继续遍历list，并不需要做任何处理，因为k一直是0，相当于每次把list新的一位添加到最终结果数组后面\n\n最后判断一下进位数是否还有值即可。\n\n***\n\n## 代码\n\n***\n\n\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        result = []\n        carry = 0\n        for digit in num[::-1]:\n            temp = digit+k%10+carry\n            k=k//10 #下一轮的k值\n            carry = temp//10 #下一轮的进位\n            temp = temp%10 #当前这一位数\n            result.append(temp)\n\n        #如果k还没耗尽的话\n        while k>0:\n            temp = k%10+carry\n            k=k//10\n            carry = temp//10\n            temp = temp%10\n            result.append(temp)\n        \n        #如果进位值还没耗尽的话\n        if carry>0:\n            result.append(carry)\n        \n        return result[::-1]\n```\n\n\n\n***\n\n时间复杂度: O(max(logk,n))\n\n空间复杂度: O(1)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917416500","body":"## 思路\n\n***\n\n在每一个位置，可能存在一个左边的c，也可能存在一个右边的，那么先从左到右遍历一次，记录左边c与当前位置的距离，再从右到左遍历一次，记录右边c和左边c距离当前位置更近的距离\n\n***\n\n## 代码\n\n***\n\n\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans=[]\n        prev = -float('inf')\n        for i in range(len(s)):\n            if s[i]==c:\n                prev=i\n            ans.append(i-prev)\n        prev = float('inf')\n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                prev=i\n            ans[i] = min(prev-i,ans[i])\n        return ans\n```\n\n\n\n***\n\n时间复杂度: O(n)\n\n空间复杂度: O(1)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917656146","body":"## 思路\n\n***\n\n总体思路，初始化的时候创建两个数组，分别用来表示栈和值累加数组，使用top指针来指示当前栈顶元素。\n\n- push操作：当top指针比最大容量小的时候，右移指针，插入值\n- inc操作：取k与top中较小的那一个位置，把value添加到add数组里\n- pop操作：当前返回的是值，是栈顶元素加上add数组中的顶部元素的值。如果此时栈中还有元素，那么add[top-1]需要累积上add[top]的值\n\n***\n\n## 代码\n\n***\n\n\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = [0]*maxSize\n        self.add = [0]*maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top<len(self.stack)-1:\n            self.top+=1\n            self.stack[self.top] = x\n\n    def pop(self) -> int:\n        if self.top <= -1:\n            return -1\n        result = self.stack[self.top] + self.add[self.top]\n        #积累值转移\n        if self.top != 0:\n            self.add[self.top - 1] += self.add[self.top]\n        self.add[self.top] = 0\n        self.top -= 1\n        return result\n\n\n    def increment(self, k: int, val: int) -> None:\n        minNum = min(k - 1, self.top)\n        if minNum >= 0:\n            self.add[minNum] += val\n```\n\n\n\n***\n\n时间复杂度: O(1)\n\n空间复杂度: O(n)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918330093","body":"## 思路\r\n\r\n***\r\n\r\n总体思路，使用string变量，num变量，stack变量，在遍历中分四种情况处理字符串。\r\n\r\n- 当遇到字母的时候，加到string后面\r\n\r\n- 当遇到数字的时候，加到num后面\r\n\r\n- 当遇到'['的时候，把当前字母和数字入栈，把string和num变量清空\r\n\r\n- 当遇到']'的时候，把栈中存的string和num取出，拼接得到 \r\n\r\n  new_string = old_string+cur_string*num\r\n\r\n***\r\n\r\n## 代码\r\n\r\n***\r\n\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        number = \"\"\r\n        string = \"\"\r\n        for c in s:\r\n            if c.isalpha():\r\n                string+=c\r\n            elif c.isdigit():\r\n                number += c\r\n            elif c=='[':\r\n                stack.append((string,int(number)))\r\n                string = \"\"\r\n                number = \"\"\r\n            elif c==']':\r\n                temp,num = stack.pop()\r\n                string = temp+string*num\r\n        return string\r\n```\r\n\r\n\r\n\r\n***\r\n\r\n时间复杂度: O(n)\r\n\r\n空间复杂度: O(n)\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918713291","body":"## 思路\n\n***\n\n总体思路，使用两个栈模拟：\n\n- Init:创建两个栈，分为主栈和副栈\n\n- push: 把元素推到主栈末尾\n\n- pop: 当副栈没有元素的时候，把主栈的元素运一次到副栈\n\n- peek: 与pop操作大致相同，不同之处只是副栈的尾部元素只看值不弹出\n\n- empty: 两栈为空True否则False\n\n  \n\n***\n\n## 代码\n\n***\n\n\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.a = []\n        self.b = []\n\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.a.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.b:\n            while self.a:\n                self.b.append(self.a.pop())\n        return self.b.pop()\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if not self.b:\n            while self.a:\n                self.b.append(self.a.pop())\n        return self.b[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if len(self.a)== 0 and len(self.b) == 0:\n            return True\n        return False\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n\n\n***\n\n时间复杂度: O(n)\n\n空间复杂度: O(n)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920097640","body":"## 思路\n\n***\n\n总体思路，单调栈\n\n***\n\n## 代码\n\n***\n\n\n\n```python\nclass Solution:\n    #实在不会做，参考了一下其他学员做法，再理解\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: \n                stack.append(num)\n        return len(stack)\n```\n\n\n\n***\n\n时间复杂度: O(n)\n\n空间复杂度: O(n)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921011205","body":"## 思路\n\n***\n\n- 首先判断边界条件，如果链表为空或者k为0就不移动直接返回\n- 遍历一遍链表，得到尾结点，得到链表长度i\n- 把尾节点和头结点连起来\n- 从头结点走j步断开，返回即可。\n\n关键在于这个j怎么得到呢？如果我们要将链表右移k步，那其实就是把尾结点向前移动k步，那我们原来得到尾结点需要i步，现在就只需要j = i-k 步。 由于k可能大过i 所以最终为 j = i - k%i\n\n***\n\n## 代码\n\n***\n\n\n\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n\n        if head is None or k<1:\n            return head\n        first_node = head\n        \n        previous = None\n        current = head\n        i=0\n        while current is not None:\n            previous=current\n            current=current.next\n            i+=1\n\n        previous.next = first_node\n        current = first_node\n\n        j = i-k%i\n\n        t = 0 \n        previous = None\n        while t<j:\n            previous = current\n            current = current.next\n            t+=1\n            \n        previous.next = None\n\n        return current\n```\n\n\n\n***\n\n时间复杂度: O(n)\n\n空间复杂度: O(1)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921762643","body":"## 思路\n\n***\n\n利用python特性，直接让四个变量交换值，最后作简单处理即可完成\n\n***\n\n## 代码\n\n***\n\n\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        \n        # initialization\n        first_node = head\n        second_node = head.next\n        head = second_node\n        \n        #如果后面至少还存在两个结点\n        while second_node.next and second_node.next.next:\n            second_node.next,first_node.next,first_node,second_node = first_node,second_node.next.next,second_node.next,second_node.next.next\n        \n        second_node.next,first_node.next = first_node,second_node.next\n        return head\n```\n\n\n\n***\n\n时间复杂度: O(n)\n\n空间复杂度: O(1)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922330950","body":"## 思路\n\n***\n\n利用分治，先将链表转化为数组，选取中间结点作为root后不断分治，直到区间内不再存在元素\n\n***\n\n## 代码\n\n***\n\n\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        \n        arr = list()\n        while head:\n            arr.append(head.val)\n            head = head.next\n        #找到中间结点\n        def bfs(left,right):\n            if left>right:\n                return None\n            mid = left+(right-left)//2\n            root = TreeNode(arr[mid])\n            root.left = bfs(left,mid-1)\n            root.right = bfs(mid+1,right)\n            return root\n\n        return bfs(0,len(arr)-1)\n```\n\n\n\n***\n\n时间复杂度: O(n) 遍历链表\n\n空间复杂度: O(n) 数组最大为n\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"septasset":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916623473","body":"### **思路**\n\n1. 观察到A最大为10^10000,远超出long上限，因此不可把A转成数字后与k相加再写入结果数组\n2. 模拟手算，使用carry进位\n\n### **关键点**\n\n1. 从整数k中取出倒数第i位数字: k % (int)Math.pow(10, (i+1)) / (int)Math.pow(10, i)\n2. 循环次数取决于A,k中较大数的位数\n\n### **代码(Java)**\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> sumList = new LinkedList<Integer>();\n    Boolean carry = false;\n    int noDigits = Math.max(num.length, Integer.toString(k).length());\n    for (int i = 0; i<noDigits; ++i){\n        int k_digit = k % (int)Math.pow(10, (i+1)) / (int)Math.pow(10, i);\n        int num_digit = i<=num.length-1? num[num.length-1-i]:0;\n\n        int res = carry? k_digit + num_digit + 1 : k_digit + num_digit;\n        if (res>9){\n            res = res - 10;\n            carry = true;\n        }else{\n            carry = false;\n        }\n        sumList.add(0, res);\n    }\n    if (carry) sumList.add(0, 1);\n    return sumList;\n\n}\n```\n\n### **复杂度分析**\n\nm,n为A,k的位数时:\n\n- 时间：O（max(m,n)）\n- 空间：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917381556","body":"### **思路**\n\n1. 遍历字符串s, 记录所有的c出现的位置\n2. 遍历ans数组，计算最近距离有3种情况\n\n### **关键点**\n\n### **代码(Java)**\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        \n        List<Integer> occ = new ArrayList<Integer>();        \n        for (int i = 0; i<s.length(); ++i){\n            if (s.charAt(i)==c) occ.add(i);\n        }\n        \n        int leftInd = 0;\n        for (int j = 0; j<s.length(); ++j){\n            if (j<=occ.get(0)) ans[j] = occ.get(0)-j;\n            else if (j>=occ.get(occ.size()-1)) ans[j] = j-occ.get(occ.size()-1);\n            else{\n                int mi = (occ.get(leftInd) + occ.get(leftInd+1))/2;\n                if (j<=mi) ans[j] = j-occ.get(leftInd);\n                else ans[j] = occ.get(leftInd+1)-j;\n                \n                if (j==occ.get(leftInd+1)) leftInd++;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n### **复杂度分析**\n\n- 时间：O（n）\n- 空间：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917640170","body":"## Day 3\n\n### **思路**\n\n1. stack不记录单个元素，记录前缀和\n2. 记录increment信息，只在pop时使用和更新\n\n### **关键点**\n\n### **代码(Java)**\n\n```java\nclass CustomStack {\n    List<Integer> stack; // stack_pre\n    int maxCap;\n    int currSize;\n    \n    List<Integer> incNum;\n    List<Integer> incVal;\n    \n    public CustomStack(int maxSize) {\n        stack = new ArrayList<Integer>(maxSize);\n        maxCap = maxSize;\n        currSize = 0;\n        \n        incNum = new ArrayList<Integer>();\n        incVal = new ArrayList<Integer>();\n    }\n    \n    public void push(int x) {\n        if (currSize>=maxCap) return;\n        else {\n            if (currSize>=1) {                \n                stack.add(stack.get(currSize-1)+x);\n            }else {\n                stack.add(x);\n            }            \n            currSize++;\n        }\n    }\n    \n    public int pop() {\n        if (currSize<=0) return -1;\n        else {\n            int ele;\n            if (currSize>=2) ele = stack.get(currSize-1)-stack.get(currSize-2);\n            else ele = stack.get(currSize-1);\n            // compute ele with inc\n            for (int i =0; i<incNum.size(); ++i){\n                // System.out.println(ele);\n                if (currSize <= incNum.get(i)) {\n                   ele+= incVal.get(i);\n                   incNum.set(i, incNum.get(i)-1);\n                }\n            }\n            stack.remove(--currSize);\n            return ele;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        incNum.add(Math.min(k, currSize));\n        incVal.add(val);\n    }\n}\n```\n\n### **复杂度分析**\n\n- 时间：push和increment为O（1），pop为O(increment次数)\n- 空间：O(increment次数)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918013385","body":"### **思路**\n\n1. 字符串匹配 → 栈\n\n### **关键点**\n\n1. n[xxx]展开重新入栈\n2. n可能有两位以上\n\n### **代码(Java)**\n\n```java\nclass Solution {\n    public String decodeString(String s) {        \n        StringBuilder strB = new StringBuilder();\n        StringBuilder strB2 = new StringBuilder();\n        Deque<Character> stack = new LinkedList<Character>();\n        \n        for (int i = s.length()-1; i>=0; --i){\n            char chr = s.charAt(i);\n            if (chr == ']') stack.push(chr);\n            else if (Character.isLetter(chr)){\n                if (stack.size()==0) strB.insert(0, chr);\n                else {\n                    stack.push(chr);\n                }\n            }else { // '['\n                StringBuilder tmpt = new StringBuilder();\n                int ptr = i;\n                do {\n                    ptr--; \n                    if (!Character.isDigit(s.charAt(ptr))){\n                        break;\n                    }\n                    tmpt.insert(0, s.charAt(ptr));                    \n                } while (ptr>=1);\n                int repeat = Integer.parseInt(tmpt.toString());\n                \n                List<Character> inner = new ArrayList<Character>();\n                while (stack.peek() != ']'){\n                    inner.add(stack.pop());\n                }\n                stack.pop();\n                for (int r=0; r<repeat;++r){\n                    for (int j = inner.size()-1; j>=0; --j){\n                        stack.push(inner.get(j));\n                    }\n                }\n                \n                if (ptr==0 && Character.isDigit(s.charAt(ptr))) break;\n                else i=ptr+1;\n            }\n        }\n        while (stack.size()>0){\n            strB2.append(stack.pop());\n        }\n        return strB2.toString()+strB.toString();\n    }\n}\n```\n\n### **复杂度分析**\n\n- 时间：\n- 空间：","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918966831","body":"## Day 5\n\n### **思路**\n\n1. 从一个stack pop，push到另一个stack, 能做到reverse\n\n### **关键点**\n\n### **代码(Java)**\n\n```python\nclass MyQueue:\n    main_stack = None\n    help_stack = None\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        \n        self.main_stack = []\n        self.help_stack = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        while self.main_stack:\n            self.help_stack.append(self.main_stack.pop(-1))\n        self.main_stack.append(x)\n        while self.help_stack:\n            self.main_stack.append(self.help_stack.pop(-1))\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        return self.main_stack.pop(-1)\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.main_stack[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.main_stack) == 0\n```\n\n### **复杂度分析**\n\n- 时间：push为O（n）, 其余为O（1）\n- 空间：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919752487","body":"## Day 6\n\n### **思路**\n\n1. 单调栈：找出数组中单调非递减的元素，可以作为块的左边界\n2. 出栈元素不能丢弃，需要记录下来判断是否要合并块\n\n### **关键点**\n\n当前元素与栈顶元素相同\n\n### **代码(Python)**\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        stack2 = []\n        for i in range(len(arr)):\n            ind = None\n            if stack and ((arr[stack[-1]]>arr[i])): \n                stack.pop(-1)\n                ind = stack2.pop(-1)\n                while stack and ((arr[stack[-1]]>arr[i])): # check left\n                    stack.pop(-1)\n                    stack2.pop(-1)\n            stack.append(i)\n            if ind is not None:\n                while stack2 and arr[stack2[-1]]>arr[i]: # check right\n                    stack.pop(-1)\n                    stack2.pop(-1)\n                stack2.append(ind)\n            else:\n                if stack2 and arr[stack2[-1]]>arr[i]:\n                    stack.pop(-1)\n                else: stack2.append(i)\n        return len(stack)\n```\n\n### **复杂度分析**\n\n- 时间：O（n）\n- 空间：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920893020","body":"### **思路**\n\n1. 构造环，在合适的地方断开\n\n### **关键点**\n\n### **代码(Python)**\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head == None or head.next==None:\n            return head\n        \n        length = 0\n        curr = head\n        while curr.next != None:\n            length += 1\n            curr = curr.next\n        length += 1\n        \n        tail = curr\n        tail.next = head\n        k_eff = length - k % length\n        # print(length, tail.val, k_eff)\n        while k_eff>0:\n            tail = tail.next\n            k_eff -= 1\n        rotate_head = tail.next\n        tail.next = None\n        \n        return rotate_head\n```\n\n### **复杂度分析**\n\n- 时间：O（n）\n- 空间：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921523677","body":"### **关键点**\n\n执行顺序：swap但要保证可以寻找到下一个节点\n\n### **代码(Python)**\n\n```python\ndef swapPairs(self, head: ListNode) -> ListNode:\n\t\tif head is None: return head\n    sentinel = ListNode(-1, None)\n    stack = []\n    curr = head\n    last = sentinel\n    while curr:\n        if not stack:\n            stack.append(curr)\n            curr = curr.next\n        else:\n            new_first = curr      \n            curr = curr.next\n            new_second = stack.pop(-1)                            \n            new_first.next = new_second\n            last.next = new_first\n            last = new_second            \n    if stack:\n        last.next = stack.pop(-1)\n        last.next.next = None\n    else:\n        last.next = None\n    return sentinel.next\n```\n\n### **复杂度分析**\n\n- 时间：O（n）\n- 空间：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922209106","body":"### **思考**\n\n对树不熟悉，这题直接看的题解复现\n\n### **关键点**\n\n### **代码(Python)**\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head: return head\n        # find middle element\n        prev = None\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            prev = slow\n            slow = slow.next\n        root = TreeNode(slow.val)\n        if slow == fast:\n            return root\n        prev.next = None\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n```\n\n### **复杂度分析**\n\n- 时间：O（nlogn）\n- 空间：O（logn）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922421746","body":"## Day 10\n\n### **思考**\n\n双指针\n\n### **关键点**\n\n### **代码(Python)**\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        pointerA = headA\n        pointerB = headB\n        flagA = False\n        flagB = False\n        while pointerA != pointerB:\n            pointerA = pointerA.next\n            pointerB = pointerB.next\n            if not pointerA:\n                if flagA: break\n                pointerA = headB\n                flagA = True\n            if not pointerB:\n                if flagB: break\n                pointerB = headA\n                flagB = True\n        return pointerA if pointerA == pointerB else None\n```\n\n### **复杂度分析**\n\n- 时间：O（m+n）\n- 空间：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DoubleW2w":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916623658","body":"## 思路\n\n1. 当前位 = `(carry + a + b) % 10` \n2. 进位处理： 当前位 % 10\n3. 调整： `k /= 10`  \n4. 最后要判断是否还有进位  `215 + 806 = 1021`  多了一位  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<>();\n        int i = num.length - 1;\n        int carry = 0, sum = 0;\n        while(i>=0 || k > 0){\n            int a = i>=0 ? num[i] : 0;\n            int b = k!=0 ? k%10: 0;\n\n            //得到和\n            sum = carry + a + b;\n\n            //得到进位\n            carry = sum / 10;\n\n            //得到当前位\n            sum %= 10;\n\n            //调整两个加数\n            k /= 10;\n            i--;\n            ans.add(sum);\n        }\n        if(carry != 0) ans.add(carry);\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(max(n,logk))\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428816","body":"## 思路1:\n\n- 遍历一次字符串，用一个动态数组记录 `c` 在 字符串 `s` 出现的位置。\n- 遍历一次字符串，比较距离\n\n## 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] answer = new int[n];\n        List<Integer> list = new ArrayList<>();\n        int index = 0;\n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) == c) list.add(i);\n        }\n        for(int i = 0; i < n;i++){\n            //index 没到list的末尾  并且 下标i到list.get(index)的距离 > 下标到list.get(index+1) \n            //取后者距离\n            if(index < list.size() - 1 && Math.abs( list.get(index) - i ) > Math.abs( list.get(index+1) - i)){\n                index++;\n            }\n            answer[i] = Math.abs(list.get(index) - i);\n        }\n        return answer;\n    }\n}\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，两次遍历数组，都是$O(n)$\n- 空间复杂度：$O(n)$，在最坏的情况下，`list` 会存放 `n` 个元素","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920111138","body":"## 待补待补\n\n## 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920595837","body":"## 铺垫题目\n\n- 返回链表倒数第k个节点 [https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)\n- 删除链表的倒数第n个节点[https://leetcode-cn.com/problems/SLwz0R/](https://leetcode-cn.com/problems/SLwz0R/)\n\n## 思路\n\n- 利用双指针（快指针比慢指针先走K步，当快指针到达 `null` 时，慢指针此时指向倒数第k个，即快指针达到尾节点时，慢指针指向倒数第k+1个节点）\n\n```java\nListNode slow = head, fast = head;\n//先走K步\nfor(int i = 0; i < k; i++){\n    fast = fast.next;\n}\n//一起走\nwhile(fast != null) {\n    fast = fast.next;\n    slow = slow.next;\n}\nreturn slow;\n```\n\n- 剩下的就是修改节点的next指针。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if ( head == null || head.next == null) return head;\n        int size = 0;\n        ListNode cur = head;\n        while(cur != null){\n            cur = cur.next;\n            size++;\n        }\n        //保证了 size > k\n        k = k % size;\n        ListNode fast = head, slow = head;\n        while(fast.next != null){\n            fast = fast.next;\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n        }\n        //1->2->3->4->5  此时fast指向5，slow = 3\n        fast.next = head;  //4->5->1->2->3->4->5\n        ListNode res = slow.next; //把4记录下来\n        slow.next = null;   //4->5->1->2->3->null\n        return res;\n    }\n}\n\n```\n\n**复杂度分析**\n\n令 n 为链表节点个数。\n\n- 时间复杂度：$O(n)$，最多遍历两次链表\n- 空间复杂度：$O(1)$，无额外","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921763192","body":"## 思路\n\n题目考察的是指针的修改，因此要清楚每一步指针怎么修改\n\n- 假设链表为 `preA->A->B->nextB`\n- `A` 的next指针指向 `nextB` ==\\==\\==> `preA -> A -> nextB` +   `B -> nextB`\n- `B` 的next指针指向 `A` \\==\\==> `preA -> A -> nextB`  +  `B -> A`\n- `preA` 的next指针 指向 `B` =\\===\\=> `preA - > B -> A`  `A -> nextB`  \\==\\==\\==> `preA -> B -> A -> nextB`\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummyNode = new ListNode(0, head);\n        ListNode prev = dummyNode;\n        while(prev.next != null && prev.next.next != null){\n            //留下联系方式\n            ListNode temp = head.next.next;\n            prev.next = head.next;    // 将 prev 的 next 改为 head 的 next\n            head.next.next = head;    // 将 head 的 后继节点 的 next 改为 head\n            head.next = temp;         // 将 head 的 next 改为 缓存\n            //往下走\n            prev = head;\n            head = head.next;\n        }\n        return dummyNode.next;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为节点个数。\n\n- 时间复杂度：$O(n)$，遍历的次数是 $n/2$\n- 空间复杂度：$O(1)$，无额外的空间\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922328221","body":"## 题目地址(109. 有序链表转换二叉搜索树)\r\n\r\n[https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\r\n\r\n\r\n\r\n## 题目铺垫\r\n\r\n- [ ] [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)\r\n- [ ] [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)\r\n\r\n## 思路1:缓存\r\n\r\n**如果掌握了LC108题，可以将链表缓存到数组，然后进行操作了。方法是一样的**\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        List<Integer> nodes = new ArrayList<>();\r\n        while(head != null){\r\n            nodes.add(head.val);\r\n            head = head.next;\r\n        }\r\n        return sortedListToBST(nodes, 0, nodes.size());\r\n    }\r\n\r\n    private TreeNode sortedListToBST(List<Integer> nodes, int start, int end){\r\n        if(start >= end) return null;\r\n        int mid = start + (end - start) /2;\r\n        TreeNode root = new TreeNode(nodes.get(mid));\r\n        root.left = sortedListToBST(nodes, start, mid);\r\n        root.right = sortedListToBST(nodes, mid+1, end);\r\n        return root;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为链表长度。\r\n\r\n- 时间复杂度：$O(n)$，递归树内每个节点的时间复杂度为 $O(1)$，节点为n\r\n- 空间复杂度：$O(n)$，利用了数组对链表进行存储\r\n\r\n\r\n\r\n## 思路2：快慢指针+递归\r\n\r\n走到链表重点，建一个树节点，然后开始左右递归建左右子树。\r\n## 代码\r\n```java\r\nclass Solution {\r\n    //如何建树\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        return dfs(head, null);\r\n    }\r\n\r\n    public TreeNode dfs(ListNode head, ListNode tail){\r\n        if(head == tail) return null;\r\n        ListNode fast = head, slow = head;\r\n        while(fast != tail && fast.next != tail){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        //slow指向中间节点\r\n        //开始建树\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left  = dfs(head, slow);\r\n        root.right = dfs(slow.next, tail);\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为长度。\r\n\r\n- 时间复杂度：$O(nlogn)$，递归树的深度为 $logn$, 每一层都花$O(n)$去寻找中点（每一层的操作数为n）\r\n- 空间复杂度：$O(logn)$，递归树深度为 $logn$，递归函数空间复杂度为 $O(1)$\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"WeilanTao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916628293","body":"### 989 Easy\n\n### 思路\n\n这道题是一个模拟计算的题目。首先想到用一个变量carry来记录进位。获得个位：n%10；获得其他：n/0\n\n用一个while loop 遍历所有--只要`carry` 或 `num[]`或 `k` 没有用完， while loop 就对 carry 进行迭代, 并将此次迭代结果的个位存入结果集合`res`。\n\n在 Java 集合中选择 LinkedList 来储存结果，因为 Java 中 `LinkedList` 提供了接口 `addFirst()`。 LinkedList 在头尾插入复杂度都是O(1)。 若采用ArrayList 则需要调用接口`add(0, nums[i])` 或`Collections.reverse()` ； 相比之下都会降低性能。\n\n### 代码 Java\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        \n        int carry = 0;\n        \n        int len = num.length;\n        int i  =len-1;\n\n        LinkedList<Integer> res = new LinkedList<>();\n        \n        while(carry != 0  || k > 0 || i >= 0 ){\n         \n            if(i>=0){\n                carry += num[i];\n                i--;\n            }\n            \n            if(k>0){\n                int a = k%10;\n                carry+=a;\n                k=(k-a)/10;\n            }\n            \n            res.addFirst(carry % 10);\n            carry = carry/10;\n\n        }\n        \n        return res;\n    }\n}\n```\n\nRuntime: 2 ms, faster than 99.68% of Java online submissions for Add to Array-Form of Integer.\n\nMemory Usage: 41.2 MB, less than 35.41% of Java online submissions for Add to Array-Form of Integer.\n\n### 复杂度分析\n\n时间复杂度：O(max(nums[], k)+1) =>O(n)\n\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917345912","body":"### 821. Shortest Distance to a Character Easy\n\n### Idea\n\nThe basic idea of this problem is to find closest matching character `c` at the left and the right of the characters in the string. To do so, we scan the string from the left to right to find the left match; and scan from the right to left to find the right match. We will use pointer `p` to record the latest position update of `c` ; so the distance will be |i-p|. If any right match gives a smaller distance, then the record in the result array will be overwritten by the smaller one.\n\nCorner case: Either scanning from left to right or from right to left can encounter the case that left/right side doesn't have the matching character.\n\n* left side: \n  * When scanning from left to right and when no `c` occurs, the pointer `p` is set as `-s.length()`; so it means no matching character is at the left side and the recorded distance will be big enough to be overwritten by the matching at the right side.\n  * When scanning from right to left, \n    * if there is a matching character at the end of the string, then the pointer is already there as the result of the left-to-right scan. In this case the distance will be `p -  i`;\n    * If there is no matching character at the end of the string, then  `i - p` is negative in this case, which indicates the absence of the right matching. However, the absolute value of `p - i` equals `i - p`, so if we take absolute value, then there no chance for the left match to be overwritten in this case.\n    * So when it is scanning from right to left, we measure the distance by the absolute value.\n\n### Code  Java\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int p = -len;\n        int res[] =  new int[len];\n        \n        for(int i =0; i < len; i++){\n            if(s.charAt(i)==c){\n                p = i;\n            }\n    \n            res[i] = i - p;\n        }\n        \n        \n        for(int i = len-1; i >= 0; i--){\n            if(s.charAt(i) == c){\n                p = i;\n            }    \n            res[i] = Math.min(res[i], Math.abs(p - i));\n        }\n        \n        return res;\n    }\n}\n```\n\n\n\n### Complexity\n\nTime complexity: O(n)\n\nSpace complexity: O(n)\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917544535","body":"### 1381 Design a Stack With Increment Operation Medium\n\n### Idea\n\nTo construct a stack, we only manipulate top element in the stack as it's a FILO; plus the size of the stack is fixed in this question, so no worry about the overflow of the stack. Therefore, array is a good fit in this question. If we use LinkedList, we can also implement the same functionalities; but LinkedList will be a little bit slower than array in accessing adjacent elements, because LinkedList doesn't address memory consecutively in heap.\n\n### Code Java\n\n```java\nclass CustomStack {\n    private int size;\n    private int capacity;\n    private int [] stack;\n    \n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        size = -1;\n        capacity = maxSize - 1;\n    }\n    \n    public void push(int x) {\n        if(size >= capacity)\n            return;\n        \n        size++;\n        stack[size] = x;\n        \n    }\n    \n    public int pop() {\n        if(size < 0)\n            return -1;\n        int a = stack[size];\n        stack[size]=0;\n        size--;\n        return a;\n    }\n    \n    public void increment(int k, int val) {\n        int i = 0;\n        while(i <= size && i < k){\n            stack[i] += val;\n            i++;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\nRuntime: 5 ms, faster than 69.59% of Java online submissions for Design a Stack With Increment Operation.\n\nMemory Usage: 39.7 MB, less than 69.54% of Java online submissions for Design a Stack With Increment Operation.\n\n### Complexity\n\n* Time Complexity\n\n  ​\t`push(int x)`: O(1)\n\n  ​\t`pop()`: O(1)\n\n  ​\t`increment(int k, int val)`: O(n)\n\n* Space Complexity\n\n  ​\tO(n) for the array\n\n  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917804434","body":"### 394  Decode String Medium\n\n### Idea\n\nIn this question, the encoded string is composed by two parts: string cascading and sub-string in the brackets.\n\n* To cascade a string, use a while loop to scan all the components in the input s and use a `StringBuilder` to record all the decoded part.\n\n* To properly decode the sub-string in the bracket, we use a recursion that keep decoding the inner brackets and finally return a decoded sub-string. Then duplicate the decoded-substring according to the leading number.\n* Use stack to locate the matching open bracket and close bracket. \n* The Java API involved:\n  *  `s.indexOf(char c, int i )` find the index of `c` in a string stating from the index `i` \n  * `s.substring(int s, int e)` s is included; e is excluded\n  * `Integer.parseInt(str s)` convert a string to int \n\n### Code\n\n```java\nclass Solution {  \n    public String decodeString(String s) {\n        StringBuilder sb  = new StringBuilder();\n        int len = s.length();\n\n        int i = 0;\n        while(i < len){\n            char c = s.charAt(i);\n            if(c-'a' >= 0 && c-'z' <= 0){\n                sb.append(c);\n                i++;\n            }else if(c-'0' >= 0 && c -'9' <= 0){\n                //find the first open bracket\n                int strt =  s.indexOf(\"[\",i);\n                int end = findEnd(strt, len, s);\n                String mids= s.substring(strt+1, end);\n                String subs = decodeString(mids);\n                \n                //find the number\n                String numstr = s.substring(i,strt);\n                int num = Integer.parseInt(numstr);\n                \n                for(int j = 0; j < num ;j++){\n                    sb.append(subs);\n                }\n                i = end+1;\n            }\n        }\n           \n        return sb.toString();\n    }\n    \n    private int findEnd(int strt, int len, String s){\n        Deque<Character> brkt = new ArrayDeque<>();\n        brkt.push(s.charAt(strt));\n        for(int i = strt+1; i <= len ; i++){\n            char c = s.charAt(i);\n            if(c == '[')\n                brkt.push(c);\n            else if( c == ']')\n                brkt.pop();\n            \n            if(brkt.peek() == null)\n                return i;\n        }\n        return -1;\n    }\n}\n```\n\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Decode String.\n\nMemory Usage: 36.9 MB, less than 84.66% of Java online submissions for Decode String.\n\n### Complexity\n\nTime: O(N) \n\nSpace: O(N) for the stack \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918793534","body":"### 232 Implement Queue using Stacks Easy\n\n\n### code \n```java\nclass MyQueue {\n    Deque<Integer> stack1;\n    Deque<Integer> stack2;\n    \n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack1 = new ArrayDeque<>();\n        stack2 = new ArrayDeque<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n          if(stack1.peek()==null){\n                transfer(stack1, stack2);\n            }\n        stack1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n            if(stack2.peek()==null){\n                transfer(stack2, stack1);\n            }\n        return stack2.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(!empty()){\n            if(stack2.peek()==null){\n                transfer(stack2, stack1);\n            }\n            return stack2.peek();\n        }\n        return -1;\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack1.peek()==null && stack2.peek()== null;\n    }\n    \n    //s1 is empty and s2 will transfer to s2\n    private void transfer(Deque<Integer> s1, Deque<Integer> s2){\n        while(s2.peek()!=null){\n            s1.push(s2.pop());\n        }\n    }\n}\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n ```\n\n Runtime: 1 ms, faster than 13.85% of Java online submissions for Implement Queue using Stacks.\nMemory Usage: 38.7 MB, less than 7.83% of Java online submissions for Implement Queue using Stacks.\n\n ### Complexity\n * Time:\\\n    `push(int x)` O(n)\\\n    `pop()` O(n)\\\n    `peek()` O(n)\\\n    `empty()` O(1)\n\n * Space: O(n) for the two stack\n \n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920616646","body":"### 61 Rotate List Medium\r\n\r\n### idea\\\r\nThe key of this question is to consider all the corner cases and to take care of the index issue.\r\nI set `len` as the length of the LinkedList and `p` as the cut position\r\n* To take care of the case k>len, `p = len- k%len`\r\n* If p is at the end of the LinkedList, we return the LinkedList directly, no need to rotate anything\r\n* If p is at the last one index, then both h2 and t2 are the last node. To generalize this case, the condition is set as `p>1` when iterating the t2. \r\n* To take care of the moduler issue, and also the above issue, the LinkedList is indexed from 1. \r\n\r\n### code\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head== null || k ==0)\r\n            return head;\r\n        \r\n        int len =1;\r\n        ListNode t = head;\r\n        while(t.next!=null){\r\n            len++;\r\n            t=t.next;\r\n        }\r\n      \r\n        int p =  len-k%len;\r\n        \r\n        if(p == len)\r\n            return head;\r\n        \r\n        ListNode h1 = head;\r\n        ListNode t1 = h1;\r\n        \r\n        while(p>1){\r\n            t1=t1.next;\r\n            p--;\r\n        }\r\n        \r\n        ListNode h2= t1.next;\r\n        ListNode t2= h2;\r\n        while(t2.next!=null){\r\n            t2=t2.next;\r\n        }\r\n        \r\n        t1.next= null;\r\n        t2.next=h1;\r\n        head=h2;\r\n        return head;\r\n    }\r\n}\r\n```\r\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Rotate List.\r\nMemory Usage: 38.2 MB, less than 78.49% of Java online submissions for Rotate List.\r\n\r\n### Complexity\r\nTime: O(N)\r\nSpace: O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kennyxcao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916629214","body":"# 989. Add to Array-Form of Integer\r\n\r\n## Intuition\r\n\r\n1. Start from least significant digit in num and current sum as k.\r\n2. Compute digit sum at each position from right to left.\r\n3. Push least significant digit to the answer array.\r\n4. Shift current sum to right by 1 position.\r\n5. Repeat until all digits in both num and k are processed.\r\n6. Reverse the answer array for the final output.\r\n\r\n## Code\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nconst addToArrayForm = function(num, k) {\r\n  const n = num.length;\r\n  const ans = [];\r\n  let curr = k;\r\n  let i = n - 1;\r\n  while (i >= 0 || curr > 0) {\r\n    if (i >= 0) {\r\n      curr += num[i];\r\n    }\r\n    ans.push(curr % 10);\r\n    curr = ~~(curr / 10);\r\n    i -= 1;\r\n  }\r\n  return ans.reverse();\r\n};\r\n```\r\n\r\n## Complexity Analysis\r\n\r\n- Time: O(max(N, K))\r\n- Space: O(max(N, K)) for answer array\r\n- N = len(num)\r\n- K = len(k)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334975","body":"# 821. Shortest Distance to a Character\n\n## Intuition\n\nTwo Pass\n\n1. Iterate from left to right.\n    - Record the distance to the closest *c* on the left side.\n2. Iterate from right to left.\n    - Record the distance to the closest *c* on the right side.\n    - Only update the answer array if closest right is closer than closest left.\n\n## Code\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nconst shortestToChar = function(s, c) {\n  const n = s.length;\n  const ans = [];\n  let prev = -Infinity;\n  for (let i = 0; i < n; i++) { // left to right\n    if (s[i] === c) prev = i;\n    ans[i] = i - prev;\n  }\n  prev = Infinity;\n  for (let i = n - 1; i >= 0; i--) { // right to left\n    if (s[i] === c) prev = i;\n    ans[i] = Math.min(ans[i], prev - i);\n  }\n  return ans;\n};\n```\n\n## Complexity Analysis\n\n- Time: O(N)\n- Space: O(N) for answer array\n- N = len(s)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917542773","body":"# 1381. Design a Stack With Increment Operation\n\n## Intuition\n\n- Use array to simulate stack operations\n\n## Code\n\n```javascript\nclass CustomStack {\n  /**\n   * @param {number} maxSize\n   */\n  constructor(maxSize) { // Time: O(1)\n    this.maxSize = maxSize;\n    this.stack = [];\n  }\n\n  /** \n   * @param {number} x\n   * @return {void}\n   */\n  push(x) { // Time: O(1)\n    if (this.stack.length < this.maxSize) {\n      this.stack.push(x);\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  pop() { // Time: O(1)\n    return this.stack.length === 0 ? -1 : this.stack.pop();\n  }\n\n  /** \n   * @param {number} k\n   * @param {number} val\n   * @return {void}\n   */\n  increment(k, val) { // Time: O(n)\n    const limit = Math.min(k, this.stack.length);\n    for (let i = 0; i < limit; i++) {\n      this.stack[i] += val;\n    }\n  }\n}\n```\n\n## Complexity Analysis\n\n- Time\n  - constructor: O(1)\n  - push: O(1) amortized\n  - pop: O(1) amortized\n  - increment: O(min(k, maxSize))\n- Space: O(maxSize) for max stack size\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917732544","body":"# 394. Decode String\n\n## Intuition\n\n- Use stack to keep track of each level of repeated encoded_string\n\n## Code\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nconst decodeString = function(s) {\n  const stack = [];\n  let str = '';\n  let num = 0;\n  for (const char of s) {\n    if (/\\d/.test(char)) { // if char is a digit\n      num = num * 10 + parseInt(char, 10);\n    } else if (char === '[') { // save current outer level info and reset for inner level\n      stack.push([num, str]);\n      num = 0;\n      str = '';\n    } else if (char === ']') { // retrieve outer level count and repeat the inner str\n      const [count, outerStr] = stack.pop();\n      str = outerStr + str.repeat(count);\n    } else { // char is a letter\n      str += char;\n    }\n  }\n  return str;\n};\n```\n\n## Complexity Analysis\n\n- Time: O(maxK * n)\n- Space: O(sum(avgK * n))\n- maxK = max k within k[encoded_string] patterns in s\n- n = len(encoded_string)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918801693","body":"# 232. Implement Queue using Stacks\n\n## Intuition\n\n- Use 2 stacks\n  - stack1 for push\n  - stack2 for pop\n    - after receiving the elements of the stack1 in reverse order\n    - only pull elements from stack1 if stack2 is empty\n\n## Code\n\n```javascript\nclass MyQueue {\n  /**\n   * Initialize your data structure here.\n   */\n  constructor() { // Time: O(1)\n    this.stack1 = [];\n    this.stack2 = [];\n  }\n\n  /**\n   * Push element x to the back of queue.\n   * @param {number} x\n   * @return {void}\n   */\n  push(x) { // Time: O(1)\n    this.stack1.push(x);\n  }\n\n  /**\n   * Removes the element from in front of queue and returns that element.\n   * @return {number}\n   */\n  pop() { // Time: O(1) amortized\n    this.peek();\n    return this.stack2.pop();\n  }\n\n  /**\n   * Get the front element.\n   * @return {number}\n   */\n  peek() { // Time: O(1) amortized\n    if (this.stack2.length === 0) {\n      while (this.stack1.length > 0) {\n        this.stack2.push(this.stack1.pop());\n      }\n    }\n    return this.stack2[this.stack2.length - 1];\n  }\n\n  /**\n   * Returns whether the queue is empty.\n   * @return {boolean}\n   */\n  empty() { // Time: O(1)\n    return this.stack1.length === 0 && this.stack2.length === 0;\n  }\n}\n```\n\n## Complexity Analysis\n\n- Time: O(1) amortized\n- Space: O(n)\n- n = max queue size\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919743449","body":"# 768. Max Chunks To Make Sorted II\n\n## Intuition\n\n- Scan from left to right\n  - Compare diff in element occurrence between arr and sorted(arr)\n  - Whenever diff is zero, we can break at that position\n\n## Code\n\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nconst maxChunksToSorted = function(arr) {\n  const n = arr.length;\n  const counter = new Map();\n  const sorted = [...arr].sort((a, b) => a - b);\n  let ans = 0;\n  let diff = 0;\n  for (let i = 0; i < n; i++) {\n    const x = arr[i];\n    const y = sorted[i];\n    counter.set(x, (counter.get(x) || 0) + 1);\n    if (counter.get(x) === 0) {\n      diff -= 1;\n    } else if (counter.get(x) === 1) {\n      diff += 1;\n    }\n    counter.set(y, (counter.get(y) || 0) - 1);\n    if (counter.get(y) === -1) {\n      diff += 1;\n    } else if (counter.get(y) === 0) {\n      diff -= 1;\n    }\n    if (diff === 0) {\n      ans += 1;\n    }\n  }\n  return ans;\n};\n```\n\n## Complexity Analysis\n\n- Time: O(nlogn)\n- Space: O(n)\n- n = len(arr)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920559657","body":"# 61. Rotate List\n\n## Intuition\n\n- Traverse the linked list and find the length\n- Connect tail to head\n- Disconnect the next pointer of (length-k)-th node\n\n## Code\n\n```javascript\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nconst rotateRight = function(head, k) {\n  if (!head || k === 0) return head;\n  // calculate length of the list\n  let length = 1;\n  let tail = head;\n  while (tail.next) {\n    tail = tail.next;\n    length += 1;\n  }\n  // avoid unnecessary full cycles\n  k = k % length;\n  if (k === 0) return head;\n  // connect tail to head\n  tail.next = head;\n  // disconnect (length-k)-th node and (length-k+1)-th node\n  let curr = head;\n  let prev = null;\n  for (let i = 0; i < length - k; i++) {\n    prev = curr;\n    curr = curr.next;\n  }\n  prev.next = null;\n  return curr;\n};\n```\n\n## Complexity Analysis\n\n- Time: O(n)\n- Space: O(1)\n- n = len(list)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921368807","body":"# 24. Swap Nodes in Pairs\n\n## Intuition\n\n- Use a dummy node to gracefully handle the edge cases\n- Traverse and swap every two nodes in pairs\n\n## Code\n\n```javascript\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nconst swapPairs = function(head) {\n  const dummy = new ListNode(-1);\n  dummy.next = head;\n  let prev = dummy;\n  while (prev.next && prev.next.next) {\n    const n1 = prev.next;\n    const n2 = prev.next.next;\n    // From: prev -> n1 -> n2 -> ...\n    // To:   prev -> n2 -> n1 -> ...\n    prev.next = n2;\n    n1.next = n2.next;\n    n2.next = n1;\n    // move to prev node of next pairs\n    prev = n1;\n  }\n  return dummy.next;\n};\n```\n\n## Complexity Analysis\n\n- Time: O(n)\n- Space: O(1)\n- n = len(list)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922170775","body":"# 109. Convert Sorted List to Binary Search Tree\n\n## Intuition\n\n- Use fast and slow nodes to find the middle node\n- Choose the middle node at root\n- Repeat for dividing process for left and right side\n\n## Code\n\n```javascript\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nconst sortedListToBST = function(head) {\n  if (!head) return null;\n  return toBST(head, null);\n};\n\nfunction toBST(head, tail) {\n  if (head === tail) return null;\n  let slow = head;\n  let fast = head;\n  while (fast !== tail && fast.next !== tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  const root = new TreeNode(slow.val);\n  root.left = toBST(head, slow);\n  root.right = toBST(slow.next, tail);\n  return root;\n}\n```\n\n## Complexity Analysis\n\n- Time: O(nlogn)\n- Space: O(logn) for max depth of recursion call stack\n- n = len(list)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922403917","body":"# 160. Intersection of Two Linked Lists\n\n## Intuition\n\n```text\n  ----A----\n           ----C----\n------B----\n\nA + C + B == B + C + A\n```\n\n## Code\n\n```javascript\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nconst getIntersectionNode = function(headA, headB) {\n  if (!headA || !headB) return null;\n  let a = headA;\n  let b = headB;\n  while (a !== b) {\n    a = a === null ? headB : a.next;\n    b = b === null ? headA : b.next;\n  }\n  return a;\n};\n```\n\n## Complexity Analysis\n\n- Time: O(m + n)\n- Space: O(1)\n- m = len(listA)\n- n = len(listB)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james20141606":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916632276","body":"# Day 1 989. Add to Array-Form of Integer\n\n- Problem Link\n  - [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/submissions/)\n  - Other useful links:\n\n\n- Ideas\n  - convert list to string, then to int, add with k, convert back to list. \n- Complexity: \n  - Time: O(num.length)\n  - Space: O(num.length)\n\n- Code\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_str = ''.join([str(i) for i in num])\n        sum = int(num_str) + k\n        return [int(i) for i in str(sum)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917325775","body":"# Day 2 821. Shortest Distance to a Character\n\n- Problem Link\n  - [821. Shortest Distance to a Character](https://leetcode.com/problems/shortest-distance-to-a-character/submissions/)\n  - Other useful links:\n\n- Ideas\n  - Start from both sides, initiate position index as -len(s), iterate each character in s, update the position index if the character matches c, take absolute diff to find the closest from both sides and choose the smaller one as result.\n\n- Complexity: \n  - Time: O(s.length)\n  - Space: O(s.length)\n\n- Code\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str):\n        result = []\n        #start from left\n        loc = - len(s)\n        for i in range(len(s)):\n            if s[i] ==c:\n                loc = i\n            result.append(i-loc)\n        #then start from right\n        for i in range(len(s))[::-1]:\n            if s[i] ==c:\n                loc = i\n            result[i] = min(result[i], abs(i - loc))\n        return result\n```\n\n- other resources:","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917754534","body":"# Day 3 1381. Design a Stack With Increment Operation\n\n- Problem Link\n  - [1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n  - Other useful links:\n\n- Ideas\n  -  ideas from [here](https://leetcode.com/problems/design-a-stack-with-increment-operation/discuss/539716/JavaC%2B%2BPython-Lazy-increment-O(1)). the trick is we do not explicitly run increment the value for the bottom k elements. but log the inc value and only add it when poping a number. Thus the complexity will reduce from O(k) to O(1). We could use list for the stack and inc and they have same length. inc[i] means the value we should add if we pop the value ranging from stack[0] to stack[i]. So we could pop out inc[-1] and stack[-1] together and add inc[-1] to inc[-2].\n\n- Complexity: \n  - Time: O(1) \n  - Space: O(maxSize)\n\n- Code\n\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.list = []\n        self.inc = [] #log inc value and add to the number when poping a number\n        self.maxsize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.maxsize:\n            self.list.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.inc: return -1\n        if len(self.inc) >1:\n            self.inc[-2] += self.inc[-1]\n        return self.list.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, len(self.inc)) -1] +=val\n\n```\n\n- other resources:\n  - [intuition on the solution](https://leetcode.com/problems/design-a-stack-with-increment-operation/discuss/843182/lee215's-solution-with-more-explanation)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917796351","body":"# Day 4 394. Decode String\n\n- Problem Link\n  - [394. Decode String](https://leetcode.com/problems/decode-string/)\n  - Other useful links:\n\n- Ideas\n  -  ideas are from [official solution](https://leetcode-solution.cn/solutionDetail?type=3&id=4&max_id=2). We could use stack to store the information before the first ']'. When we meet the first ']' we will get the string before it, then get all the numbers before the string. \n  -  Note the += might cause error since it is reversed order. and not that `stack[-1] != '[':` is required to avoid [ in the string.\n\n- Complexity: \n  - Time: O(len(decoded_string))\n  - Space:  O(len(decoded_string))\n\n- Code\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c ==']':\n                string_to_repeat = ''\n                repeat_times = ''\n                while stack and stack[-1] != '[':\n                    string_to_repeat  =stack.pop() + string_to_repeat\n                stack.pop()  #pop out [\n                while stack and stack[-1].isnumeric():\n                    repeat_times  = stack.pop() + repeat_times\n                stack.append(string_to_repeat * int(repeat_times))\n            else:\n                stack.append(c)\n        return ''.join(stack)\n```\n\n- other resources:\n  - [official solution](https://leetcode-solution.cn/solutionDetail?type=3&id=4&max_id=2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918737672","body":"# Day 5: 232. Implement Queue using Stacks (stack, queue)\r\n\r\n- Problem Link\r\n  - [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)\r\n  - Other useful links:\r\n\r\n- Ideas\r\n  - Very classic question. the main idea is to use two stacks to implement the queue which is FIFO. [official solutiion](https://leetcode-solution.cn/solutionDetail?type=3&id=5&max_id=2). An inverse stack could help to store the original values when performing push. The stack will store the values in reversed order, so when performing the pop or peek, the first in will be first out. And the new value will be pushed to the bottom of the stack with the aid of the inverse stack. For all the operations we have to move all the values in the stack so the space and time complexity are both O(N)\r\n\r\n- Complexity: \r\n  - Time: O(N)\r\n  - Space: O(N)\r\n\r\n- Code\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.inverse_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.inverse_stack.append(self.stack.pop())\r\n        self.inverse_stack.append(x)\r\n        while self.inverse_stack:\r\n            self.stack.append(self.inverse_stack.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return True if len(self.stack) == 0 else False\r\n```\r\n\r\n- other resources:\r\n  - https://leetcode.com/problems/implement-queue-using-stacks/discuss/64284/Do-you-know-when-we-should-use-two-stacks-to-implement-a-queue","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919669398","body":"# Day 6: 768. Max Chunks To Make Sorted II (stack, monostack)\n\n- Problem Link\n  - [768. Max Chunks To Make Sorted II](https://leetcode.com/problems/max-chunks-to-make-sorted-ii/)\n\n\n- Ideas\n  - it is the first hard problem in the camp.\n  - naive solution: we know that for each chunk if we sort and merge them the resulting array should also be sorted. And we also know that if the two arrays are the same, it means the count information and the sorted arrays should be exactly same. So the trick is to compare the original array and sorted array, we iterate i and for arr[:i] and sorted_arr[:i], if they are exactly same, we could have a chunck satisfying the requirements. The comparison could be enabled using dict. But this is pretty slow. The time complexity is $O(N^2)$, and space complexity is O(N)\n  - to optimize the above solution a little bit, we could use one counter and remove the comparison between two arrays. Then the time complexity is O(NlogN), and space complexity is O(N)\n  - a **better** solution is to use monostonestack. It is a little tricky but the idea is: we are actually trying to represent each chunck using its largest value. Then for the next incoming values, if it is smaller, we should merge it to the previous chunck. and still use same value to represent the chunck. If the new value is larger, then we could have a new chunck. So it is similar to construct a monostone stack. Note that if a smaller value is coming, this means our previous chunck/monostone is wrong. We should pop out all the values which are larger than the new value (but still **keep** the last value in the stack since it is the representation of the chunck). And the length of the stack is the largest chunck number we could have. Then the time complexity is O(N), and space complexity is O(N)\n\n- Complexity: \n  - Time: O(N)\n  - Space: O(N)\n\n- Code\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, A: [int]) -> int:\n        stack = []\n        for a in A:\n            # if the new value is smaller than current values in stacks, the values which are bigger than new values \n            # should be poped out, this way we will merge the new value in the current chunck.\n            # but we should log the stack[-1] since it is the biggest value and the representation of the current chunck\n            if stack and stack[-1] > a:\n                cur = stack[-1]\n                while stack and stack[-1] > a:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)\n```\n\n- other resources:\n    - [monostack template](https://lucifer.ren/blog/2020/11/03/monotone-stack/)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920583142","body":"# Day 7: 61. Rotate List (linked list)\n\n- Problem Link\n  - [61. Rotate List](https://leetcode.com/problems/rotate-list/)\n\n- Ideas\n  -  the idea is quite straightforward: we need to break down the linked list at position k-th to the last, and concat the second part to the head. Note that if k could be larger than length. So we use `k%length`.\n  -  to break down the linked list, we could point the node k+1 to the last to null. And the **last node** in the original list to the head. And we return the k-th to the last node. which will satisfy the requirement.\n  -  to locate the k-th to the last node, we could directly iterate and find the location. Or we could use double pointer, which could be faster. the double pointer is from official solution\n\n- Complexity: \n  - Time: O(N)\n  - Space: O(1)\n\n- Code\n\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if head:\n            #double pointer\n            p1 = head\n            p2 = head\n            count = 1  #to calculate the list length\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1 #so after +=1, still ==0\n                    p2 = head\n                i += 1\n\n            while p2.next: #(n-k) to the last\n                p1 = p1.next #after the while (n-k steps), p1 locates the k to the last\n                p2 = p2.next #locates the last node\n                \n\n            if p1.next:\n                tmp = p1.next #k-th to the last node, will serve as new head, return this value\n            else:\n                return head\n            p1.next = None #change to pointing to the null\n            p2.next = head #last node point to the head, (concatenation)\n            return tmp\n```\n\n- other resources:\n    - [linked list](https://leetcode-solution.cn/solutionDetail?type=2&id=2002&max_id=2007)\n    - [wechat article](https://mp.weixin.qq.com/s?__biz=MzI4MzUxNjI3OA==&mid=2247485582&idx=1&sn=eff845460e91be97026c937b229c2989&chksm=eb88c497dcff4d81e08ac30951b160f0083bc9fe5a2b64b8e1ea9e0988e14a9df2b56515f508&token=450700782&lang=zh_CN#rd)\n    - https://leetcode.com/problems/rotate-list/discuss/348197/96-faster-Simple-python-solution-with-explanation","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921371112","body":"# Day 8: 24. Swap Nodes in Pairs (linked list)\r\n\r\n- Problem Link\r\n  - [24. Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/submissions/)\r\n\r\n- Ideas\r\n  -  we could iterate the linked list to swap the nodes. We need a dummy pre head, and represent the first two nodes as pre-1-2-n. Then we point pre to 2, and point 1 to n, and then point 2 to 1. After that we locate to the original first node. So we have pre-2-**1**-n.\r\n\r\n- Complexity: \r\n  - Time: O(N)\r\n  - Space: O(1)\r\n\r\n- Code\r\n\r\n```python\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        if not head or not head.next: return head\r\n        ans = ListNode()\r\n        ans.next = head #previous dummy node of first node\r\n        pre = ans #pre is used to iterate all the nodes, while ans remains at the beginning.\r\n        #pre-1-2-n\r\n        while pre.next and pre.next.next:\r\n            firstNode = pre.next\r\n            secondNode = pre.next.next\r\n            pre.next = secondNode #prehead point to the second  -->pre-2-n; 1 \r\n            firstNode.next = secondNode.next #first point to the next of second  -->pre-2; 1-n\r\n            secondNode.next = firstNode #second point to the original first  -->pre-2-1-n\r\n            pre = pre.next.next #locate to the first node of the current pair need to be swapped.\r\n        return ans.next #next of prehead, which is the first node of transformed list.\r\n```\r\n\r\n- other resources:\r\n    - [solution in lc](https://leetcode.com/problems/swap-nodes-in-pairs/discuss/171788/Python-or-Dummynode)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922169599","body":"# Day 9 109. Convert Sorted List to Binary Search Tree (linked list, BST)\n\n- Problem Link\n  - [109. Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n- Ideas\n  - sol1: convert to array and then find the middle point and recursively build the BST. \n  - sol2: another solution, use two pointers. the idea is that the left half of the linked list could be used to create left subtree and the right half for right subtree. So we could start from head and start from middle to create the two subtrees individually. This could be done using recursion. A fast and slow pointers could be used to locate the middle node.\n\n- Complexity:\n  - sol1:\n    - Time: O(N)\n    - Space: O(N)\n  - sol2:\n    - Time: O(NlogN)\n    - Space: O(logN)\n\n- Code\n\n```python\nclass Solution:\n    #convert to array and then find the middle point and recursively build the BST\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        arr = []\n        while head:\n            arr.append(head.val)\n            head = head.next\n        return self.binary_search_tree(arr,0,len(arr)-1)\n    def binary_search_tree(self,arr,start,end):\n        if start > end: return\n        mid = start + (end-start)//2\n        root=TreeNode(arr[mid])\n        root.left = self.binary_search_tree(arr, start, mid-1)\n        root.right = self.binary_search_tree(arr, mid+1, end)\n        return root\n```\n\n- other resources:\n    - [tree introduction in lc++](https://leetcode-solution.cn/solutionDetail?type=2&id=2003&max_id=2007)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922383677","body":"# Day 10 160. Intersection of Two Linked Lists (linked list, two pointers)\n\n- Problem Link\n  - [160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)\n\n- Ideas\n  - A naive solution is to use hash table to store the nodes in A. Then if we find a node in B is contained in set A we could return the node. Complexity: Time: O(N), Space: O(N)\n  - O(1) space solution. The tricky part is we could use two pointers, starting from head A and head B correspondingly. Then when the pointers reach the end, start from the other list's head. This will make sure they travel same distance when they meet at the intersection. Complexity: Time: O(N), Space: O(1)\n\n- Complexity:\n  - Time: O(N)\n  - Space: O(1)\n\n- Code\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        A = headA\n        B = headB\n        while A != B:\n            A = A.next if A  else headB\n            B = B.next if B  else headA\n        return A\n```\n\n- other resources:\n    - ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"muimi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916632424","body":"### 思路\n从后向前（从个位开始）遍历数组num，依次和K相加。\n\n相加的结果：个位数部分（取余）保存在返回结果里；十位之上部分（取模）作为新的K。\n\n当数组全部遍历之后，K不等于0时，将K的每一位插入结果的头部。\n\n生成结果时，每次插入都是0号位，使用LinkedList而不是ArrayList是为了获得更好的插入效率。\n\n### 代码\n\n```java\nclass Solution {\n  public List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> res = new LinkedList<>();\n    for (int i = num.length - 1; i >= 0; i--) {\n      res.add(0, (num[i] + k) % 10);\n      k = (num[i] + k) / 10;\n    }\n    while (k > 0) {\n      res.add(0, k % 10);\n      k /= 10;\n    }\n    return res;\n  }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N), 确切地说是max(N, log10(K))\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917343936","body":"### 思路\n\n求解最小路径可以抽象成， MIN（与左侧c的距离，与右侧c的距离）\n\n- 第一遍从左向右遍历，生成每个元素与左侧c的距离\n  - 当没有遇到c时，表示左侧没有c，赋予一个超过最大距离length的值\n- 第二遍从右向左遍历，生成每个元素与右侧c的距离，并与第一遍生成的左侧c距离比较，取最小值。\n  - 第一遍遍历之后，pos保存数组最后一个c的位置\n  - pos之后的元素的右侧不存在c，所以这次遍历只需要从pos-1开始\n\n### 代码\n\n````java\nclass Solution {\n  public int[] shortestToChar(String s, char c) {\n    int length = s.length();\n    int[] res = new int[length];\n    int pos = -length;\n    for (int i = 0; i < length; i++) {\n      if (s.charAt(i) == c) pos = i;\n      res[i] = i - pos;\n    }\n    // e.g.\n    // before loop: [length, length, 0, 1, 2, 3(pos-1), 0(pos), 1, 2]\n    // after  loop: [     2,      1, 0, 1, 2, 1       , 0     , 1, 2]\n    for (int i = pos - 1; i >= 0; i--) {\n      if (s.charAt(i) == c) pos = i;\n      res[i] = Math.min(res[i], pos - i);\n    }\n    return res;\n  }\n}\n````\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，两次循环\n- 空间复杂度：O(1)，返回变量之外，没有额外使用空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917595876","body":"### 思路\n使用数组作为底层数据结构实现一个栈\n\n### 代码\n\n````java\n\nclass CustomStack {\n  int[] stack;\n  int count;\n  public CustomStack(int maxSize) {\n    stack = new int[maxSize];\n\t\tcount = 0;\n  }\n  \n  public void push(int x) {\n    if (count < stack.length) stack[count++] = x;\n  }\n  \n  public int pop() {\n    if (count == 0) return -1;\n    return stack[--count];\n  }\n  \n  public void increment(int k, int val) {\n    int temp = Math.min(k, count);\n    for (int i = 0; i < temp; i++) {\n      stack[i] += val;\n    }\n  }\n}\n\n````\n\n### 复杂度\n- 时间复杂度： push是O(1)，pop是O(1)，increment是O(N)\n- 空间复杂度： O(1),没有使用额外的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918313124","body":"### 思路\n使用两个栈一个存放数字，一个存放字符串\n### 代码\n````java\nclass Solution {\n  public String decodeString(String s) {\n    Stack<Integer> intStack = new Stack();\n    Stack<StringBuilder> strStack = new Stack();\n    StringBuilder pattern = new StringBuilder();\n    int number = 0;\n\n    for (char ch : s.toCharArray()) {\n      if (Character.isDigit(ch)) {\n        number = number * 10 + ch - '0';\n      } else if (ch == '[') {\n        intStack.push(number);\n        strStack.push(pattern);\n        number = 0;\n        pattern = new StringBuilder();\n      } else if (ch == ']') {\n        StringBuilder temp = pattern;\n        pattern = strStack.pop();\n        for (int i = intStack.pop(); i > 0; i--) pattern.append(temp);\n      } else pattern.append(ch);\n    }\n    return pattern.toString();\n  }\n}\n````\n### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919116755","body":"### 思路\n\n使用一个input栈（对应push），一个output栈（对应pop和peek）\n\n### 代码\n\n````java\nclass MyQueue {\n  Stack<Integer> input;\n  Stack<Integer> output;\n\n  /** Initialize your data structure here. */\n  public MyQueue() {\n    input = new Stack<Integer>();\n    output = new Stack<Integer>();\n  }\n  \n  /** Push element x to the back of queue. */\n  public void push(int x) {\n    input.push(x);\n  }\n  \n  /** Removes the element from in front of queue and returns that element. */\n  public int pop() {\n    peek();\n    return output.pop();\n  }\n  \n  /** Get the front element. */\n  public int peek() {\n    if (output.isEmpty()) while (!input.isEmpty()) output.push(input.pop());\n    return output.peek();\n  }\n  \n  /** Returns whether the queue is empty. */\n  public boolean empty() {\n    return input.isEmpty() && output.isEmpty();\n  }\n}\n````\n\n### 复杂度\n\n- 时间复杂度:O(1)；pop或peek时，当output栈为空时需要进行k次操作，此后k次的pop无需额外操作。\n- 空间复杂度:O(N)；两个栈中的元素合计为N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920072415","body":"### 思路\n题目可以理解为，查找每个block中的最大值。采用单调栈来实现。\n对于一个递增的有序数组，每一个元素都可以独立划分为一个block。\n任意一个数组，等同于在有序数组中随机插入元素，相当于一个排序算法。\n### 代码\n````java\nclass Solution {\n  public int maxChunksToSorted(int[] arr) {\n    if (arr.length == 0) return 0;\n    Stack<Integer> stack = new Stack<>();\n    stack.push(arr[0]);\n    for (int i = 1; i < arr.length; i++) {\n      if (arr[i] >= stack.peek()) {\n        stack.push(arr[i]);\n      } else{\n        int temp = stack.pop();\n        while (!stack.isEmpty() && arr[i] < stack.peek()) stack.pop();\n        stack.push(temp);\n      }\n    }\n    return stack.size();\n  }\n}\n````\n### 复杂度\n- 时间复杂度：O(N)，遍历一遍数组\n- 空间复杂度：O(N)，使用stack作为单调栈来进行存储","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921010825","body":"### 思路\n将链表首尾相连成环，head和last分别向后移动len-k%len次，断开环\n\n### 代码\n````java\nclass Solution {\n  public ListNode rotateRight(ListNode head, int k) {\n    if (head == null || k == 0) return head;\n    ListNode last = head;\n    int len = 1;\n    while (last.next != null) {\n      last = last.next;\n      len++;\n    }\n    last.next = head;\n    k = len - k % len;\n    while (k-- > 0) {\n      head = head.next;\n      last = last.next;\n    }\n    last.next = null;\n    return head;\n  }\n}\n````\n### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921382230","body":"### 思路\n既然需要交换first和second，那么一成不变的只有first的pre。\n所以在head前引入preHead，并使用pre来遍历整个链表。\n### 代码\n````java\nclass Solution {\n  public ListNode swapPairs(ListNode head) {\n    ListNode preHead = new ListNode();\n    preHead.next = head;\n    ListNode pre = preHead;\n    while (pre.next != null && pre.next.next != null) {\n      ListNode first = pre.next;\n      ListNode second = pre.next.next;\n      pre.next = second;\n      first.next = second.next;\n      second.next = first;\n      pre = first;\n    }\n    return preHead.next;\n  }\n}\n````\n### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922170834","body":"### 思路\n中间节点设置为root\n中间的节点左侧为root的左枝\n中间的节点右侧为root的右枝\n\n### 代码\n````java\nclass Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n    if (head == null) return null;\n    if (head.next == null) return new TreeNode(head.val);\n\n    // 用快慢指针找到中心节点\n    ListNode preSlow = null, slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n      preSlow = slow;\n      slow = slow.next;\n      fast = fast.next.next;\n    }\n\n    TreeNode node = new TreeNode(slow.val);\n    // 截断中心节点左边的链表\n    preSlow.next = null;\n    node.left = sortedListToBST(head);\n    node.right = sortedListToBST(slow.next);\n\n    return node;\n  }\n}\n````\n### 复杂度\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(1)：没有使用额外的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922421742","body":"### 思路\nheadA 走到头之后，从headB开始；headB到头后，从headA开始。\n1. headA和headB长度相同，只需要遍历一次即可判断是否相交\n2. headA和headB长度不同，至多需要遍历两次（lenA+lenB）即可判断\n### 代码\n````java\npublic class Solution {\n  public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    if (headA == null || headB == null) return null;\n    ListNode currA = headA, currB = headB;\n    while (currA != currB) {\n      currA = currA == null ? headB : currA.next;\n      currB = currB == null ? headA : currB.next;\n    }\n    return currA;\n  }\n}\n````\n\n### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Mahalasu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916633989","body":"### 思路\r\n从后往前遍历，每一位都和k相加取个位，其他位继续与更前面的数字相加。如果遍历一边之后k仍大于0，说明所得结果位数大于num的长度，则将k中所有位的数字变成一个新的数组然后与num进行连接合并。\r\n\r\n##\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for idx in range(len(num) - 1, -1, -1):\r\n            temp = num[idx] + k\r\n            k = temp // 10\r\n            num[idx] = temp % 10\r\n        \r\n        if k:\r\n            return [int(i) for i in str(k)] + num\r\n        else:\r\n            return num\r\n```\r\n##\r\nTime: O(max(n, k))\r\nSpace: O(max(n, k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917257431","body":"## 思路\r\n\r\n### Naive Way\r\n\r\n遍历一遍找出所有的c所在的地方，然后遍历第二遍，将每一个字母与所有c所在的位置进行位置计算，取最短的一个\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        places = []\r\n        result = [float('inf') for _ in range(len(s))]\r\n        \r\n        for idx in range(len(s)):\r\n            if s[idx] == c:\r\n                places.append(idx)\r\n        \r\n        for idx in range(len(s)):\r\n            for cidx in places:\r\n                dist = abs(idx - cidx)\r\n                if abs(idx - cidx) < result[idx]:\r\n                    result[idx] = dist\r\n        \r\n        return result\r\n```\r\n\r\nT：O(MN)\r\nS：O(M)\r\nN为s长度，M为c所在的所有位置的个数\r\n##\r\n\r\n### 正序倒序遍历\r\n\r\n正序遍历得到每个位置到其左侧最近位置的距离，然后倒序遍历得到每个位置到其右侧最近位置的距离\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        length, pos = len(s), float('inf')\r\n        result = [length] * length\r\n        \r\n        for i in list(range(length)) + list(range(length)[::-1]):\r\n            if s[i] == c:\r\n                pos = i\r\n            result[i] = min(result[i], abs(i - pos))\r\n        \r\n        return result\r\n```\r\n\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917572192","body":"### 思路\r\n\r\n用另一个数组来记录需要增加的栈的最高位置和增加的量，在每次pop出的时候加上该量并传递给前一个量。\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.inc = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n            self.inc.append(0)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        if not self.inc:\r\n            return -1\r\n        if len(self.inc) > 1:\r\n            self.inc[-2] += self.inc[-1]\r\n        return self.stack.pop() + self.inc.pop()\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.inc:\r\n            self.inc[min(k, len(self.stack)) - 1] += val\r\n```\r\n\r\nT: O(1)\r\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917884095","body":"### 思路\r\n\r\n建立一个栈，遍历字符串，判断每个字符的类型，如果是[则说明后续字母是重复的，如果是]则说明重复字符串结束，需要出栈，剩下的数字和字符直接存储在栈中。\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        \r\n        for char in s:\r\n            if char == ']':\r\n                repeat = ''\r\n                num = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeat = stack.pop() + repeat\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    num = stack.pop() + num\r\n                stack.append(int(num) * repeat)\r\n            else:\r\n                stack.append(char)\r\n                \r\n        return \"\".join(stack)\r\n```\r\n\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918661722","body":"### 思路\r\n\r\n用两个栈实现队列，则在push或者pop的时候，选择其中一个操作将所有的item都添加到一个stack中，另一个操作就可以简单append或者pop，实现queue的功能。\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n        self.size = 0\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack1.append(x)\r\n        self.size += 1\r\n        \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n        result = self.stack2.pop()\r\n        while self.stack2:\r\n            self.stack1.append(self.stack2.pop())\r\n        self.size -= 1\r\n        return result\r\n       \r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack1[0]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return self.size == 0\r\n```\r\n\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920101293","body":"### 思路\r\n\r\n单调栈(无思路直接看答案...)\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, A: [int]) -> int:\r\n        stack = []\r\n        for a in A:\r\n            if stack and stack[-1] > a:\r\n                cur = stack[-1]\r\n                while stack and stack[-1] > a: stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(a)\r\n        return len(stack)\r\n```\r\n\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920596944","body":"### 思路\r\n\r\n先把链表练成环然后再求出新的tail和head在哪里，然后断开新的tail和head之间的connection，得到结果。需要注意的是新tail和head的计算方法。\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return head\r\n        \r\n        # connect as a ring\r\n        oldTail = head\r\n        n = 1\r\n        while oldTail.next:\r\n            oldTail = oldTail.next\r\n            n += 1\r\n        oldTail.next = head\r\n        \r\n        # get the new head and new tail\r\n        newTail = head\r\n        for i in range(n - k % n - 1):\r\n            newTail = newTail.next\r\n        newHead = newTail.next\r\n        \r\n        # break the connection between newTail and newHead\r\n        newTail.next = None\r\n        \r\n        return newHead\r\n```\r\n\r\nT: O(N)\r\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921424679","body":"### 思路\r\n\r\n递归，两个node作为一个unit，前面的node的指针指向下一次递归的返回值。\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    # recursive version\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        first_node = head\r\n        second_node = head.next\r\n        \r\n        first_node.next = self.swapPairs(second_node.next)\r\n        second_node.next = first_node\r\n        \r\n        return second_node\r\n```\r\nT: O(N)\r\nS: O(N) 递归栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922109286","body":"### 思路\r\n\r\nDivide and Conquer\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    \r\n    def findMiddle(self, head):\r\n        prevPtr = None\r\n        slowPtr = head\r\n        fastPtr = head\r\n        \r\n        while fastPtr and fastPtr.next:\r\n            prevPtr = slowPtr\r\n            slowPtr = slowPtr.next\r\n            fastPtr = fastPtr.next.next\r\n            \r\n        if prevPtr:\r\n            prevPtr.next = None\r\n        \r\n        return slowPtr\r\n    \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        \r\n        mid = self.findMiddle(head)\r\n        node = TreeNode(mid.val)\r\n        \r\n        if head == mid:\r\n            return node\r\n        \r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(mid.next)\r\n        return node\r\n```\r\n\r\nT: O(nlong)\r\nS: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922386392","body":"### 思路\r\n\r\n分别遍历两个链表，两个指针同时向后移动。当ptr1为空则跳到headB，同样ptr2为空则跳到headA，当两者相等时则返回此时的结点；不然则当两者都为空时，返回None。\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        ptr1 = headA\r\n        ptr2 = headB\r\n        \r\n        while ptr1 != ptr2:\r\n            ptr1 = ptr1.next\r\n            ptr2 = ptr2.next\r\n            \r\n            if not ptr1 and not ptr2:\r\n                return None\r\n            \r\n            if not ptr1:\r\n                ptr1 = headB\r\n            if not ptr2:\r\n                ptr2 = headA\r\n        \r\n        return ptr1\r\n```\r\n\r\nT: O(m + n)\r\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922500991","body":"### 思路\r\n\r\n快慢指针（讲义）\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next or not head.next.next:\r\n            return None\r\n        \r\n        slow = head.next\r\n        fast = head.next.next\r\n        \r\n        while slow != fast:\r\n            if not fast or not fast.next:\r\n                fast = None\r\n            else:\r\n                fast = fast.next.next\r\n            slow = slow.next\r\n        \r\n        if fast == None:\r\n            return None\r\n        \r\n        fast = head\r\n        while fast != slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        return fast\r\n```\r\n\r\nT: O(N)\r\nS: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZETAVI":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916634607","body":"## 思路\r\n\r\n从Num数组的**右侧开始往左遍历**数组,将遍历到的数**直接与K相加**,相加的结果取**最低位**插入到List输出链表的**头部**\r\n\r\n## 语言\r\n\r\nJava\r\n\r\n## 代码\r\n\r\n```java\r\npublic class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList<>();\r\n        int i;\r\n        for (i = num.length - 1; k > 0 || i >= 0; k /= 10, i--) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            list.add(0, k % 10);\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:\t$O(max(num.length(),logK))$\r\n\r\n​\t\t\t\t\t\t\t时间复杂度跟输入Num的长度和K的位数有关,又因为List的插入时间复杂度为$O(1)$所以插入可以忽略不计.\r\n\r\n- 额外空间复杂度: $O(1)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917370148","body":"## 思路(法一)\r\n\r\n利用库函数**indexOf(c)**来找到**后一个出现字母的位置**,比较前一个出现和后一个出现的距离,取最小值\r\n\r\n## 语言\r\n\r\nJava\r\n\r\n## 代码\r\n\r\n```java\r\npublic class Solution {\r\n   public int[] shortestToChar_1(String s, char c) {\r\n        int[] ans = new int[s.length()];\r\n        int fir = -1, sec = Integer.MAX_VALUE / 2, cur = 0;\r\n        fir = s.indexOf(c);\r\n        for (int i = 0; i < ans.length; i++) {\r\n            if (fir > i) {\r\n                ans[i] = fir - i;\r\n            } else if (fir == i) {\r\n                ans[i] = 0;\r\n                sec = s.indexOf(c, fir + 1) == -1 ? Integer.MAX_VALUE / 2 : s.indexOf(c, fir + 1);\r\n            } else if (i < sec) {\r\n                ans[i] = Math.min(Math.abs(fir - i), Math.abs(sec - i));\r\n            } else {\r\n                ans[i] = 0;\r\n                fir = sec;\r\n                sec = s.indexOf(c, fir + 1) == -1 ? Integer.MAX_VALUE / 2 : s.indexOf(c, fir + 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:\t$O(N^2)$\r\n\r\n​\t\t\t\t\t\t\t因为String类中indexOf()方法是暴力匹配方法时间复杂度为$O(N*M)$,而我们这里M=1,所以综上总的时间复杂度为$O(N^2)$\r\n\r\n- 额外空间复杂度: $O(N)$\r\n\r\n## 思路(法二)\r\n\r\n对于每个字符 S[i]，通过**顺序遍历和逆序遍历两次**,试图找出距离向左和向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n\r\n## 语言\r\n\r\nJava\r\n\r\n## 代码\r\n\r\n```java\r\npublic class Solution {\r\n    public int[] shortestToChar_2(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        //假设上一个出现的位置为Integer.MIN_VALUE / 2\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        //记录s[i]与前一个字符c的距离\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        //假设最后一个出现的位置为Integer.MAX_VALUE / 2\r\n        prev = Integer.MAX_VALUE / 2;\r\n\r\n        //计算s[i]与后一个字符c的距离,与原来的距离比较取最小值\r\n        for (int i = N - 1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:\t$O(N)$\r\n\r\n- 额外空间复杂度: $O(N)$\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657010","body":"## 思路(法一)\r\n\r\n用数组arr和一个变量top来模拟实现栈\r\n\r\n## 语言\r\n\r\njava\r\n\r\n## 代码\r\n\r\n```java\r\npublic class CustomStack {\r\n    private int[] arr;\r\n    private int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        arr=new int[maxSize];\r\n        top=-1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (top < arr.length-1 ) {\r\n            arr[++top]=x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (top >= 0) {\r\n            return arr[top--];\r\n        }return -1;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int end= Math.min(k, top + 1);\r\n        for (int i = 0; i < end; i++) {\r\n            arr[i]+=val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:CustomStack(),push(),pop()都为$O(1)$, 但是increment()时间复杂度为$O(k)$\r\n- 空间复杂度:$O(maxSize)$\r\n\r\n\r\n\r\n## 思路(法二)\r\n\r\n同样用数组来模拟实现栈,但是对increment()方法进行优化\r\n\r\n再用一个辅助数组add来记录increase的值, 利用==差分思想==, 在每次pop()时把add数组和原数组arr==相加输出==\r\n\r\n## 语言\r\n\r\njava\r\n\r\n## 代码\r\n\r\n```java\r\nclass CustomStack_PrefixSum {\r\n    private int[] arr;\r\n    private int[] add;\r\n    private int top;\r\n\r\n    public CustomStack_PrefixSum(int maxSize) {\r\n        arr=new int[maxSize];\r\n        add=new int[maxSize];\r\n        top=-1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (top < arr.length-1 ) {\r\n            arr[++top]=x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (top >= 0) {\r\n            int res=arr[top]+add[top];\r\n            if (top>=1){\r\n                add[top-1]+=add[top];\r\n            }\r\n            add[top--]=0;\r\n            return res;\r\n        }return -1;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int end= Math.min(k-1, top);\r\n        if (end>=0){\r\n            add[end]+=val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:CustomStack(),push(),pop(), increment()时间复杂度为都为$O(1)$\r\n- 空间复杂度:$O(maxSize)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918337206","body":"## 思路\r\n\r\n栈操作\r\n\r\n- 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\r\n- 如果当前的字符为字母或者左括号，直接进栈\r\n- 如果当前的字符为右括号，开始出栈,一直到左括号出栈\r\n\r\n## 语言\r\n\r\njava\r\n\r\n## 代码\r\n\r\n```java\r\npublic String decodeString(String s) {\r\n        Stack<Integer> add=new Stack<>();\r\n        Stack<String> str=new Stack<>();\r\n        StringBuilder builder = new StringBuilder();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i)>=48&&s.charAt(i)<=57){\r\n                int j=i;\r\n                while(s.charAt(j+1)>=48&&s.charAt(j+1)<=57){\r\n                    j++;\r\n                }\r\n                int num=Integer.parseInt(s.substring(i,j+1));\r\n                add.push(num);\r\n                i=j;\r\n            }else if(s.charAt(i)==91){\r\n                int j=i+1;\r\n                String temp = new String(\"\");\r\n                while (s.charAt(j)>=97&&s.charAt(j)<=122){\r\n                    temp+=(s.charAt(j));\r\n                    j++;\r\n                }\r\n                i=j-1;\r\n                str.push(temp);\r\n            }else if(s.charAt(i)==93){\r\n                int time=add.pop();\r\n                String base=str.pop();\r\n                StringBuilder builder1 = new StringBuilder();\r\n                while (time>0){\r\n                    builder1.append(base);\r\n                    time--;\r\n                }\r\n                if (!str.isEmpty()){\r\n                    base=str.pop();\r\n                }\r\n                else base=\"\";\r\n                base+=builder1.toString();\r\n                str.push(base);\r\n            }else {\r\n                String t=new String(\"\");\r\n                if (!str.isEmpty()){\r\n                    t = str.pop();\r\n                }\r\n                t+=s.charAt(i);\r\n                str.push(t);\r\n            }\r\n        }\r\n        return str.peek();\r\n    }\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度: $O(S)$,S表示解码后字符串长度\r\n- 空间复杂度:$O(S)$,S表示解码后字符串长度,维护栈,栈的总大小最终与S相同","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919228596","body":"## 思路\r\n\r\n使用两个栈,一个栈负责存储新Push()进来的数据,当需要==访问\\弹出队列头==时,把原栈的数据放到另一个栈中,实现==逆序==\r\n\r\n\r\n\r\n## 语言\r\n\r\njava\r\n\r\n## 代码\r\n\r\n```java\r\npublic class MyQueue {\r\n    LinkedList<Integer> stack  ;\r\n    LinkedList<Integer> queue ;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack = new LinkedList<>();\r\n        queue = new LinkedList<>();\r\n    }\r\n\r\n    /**\r\n     * Push element x to the back of queue.\r\n     * @复杂度分析\r\n     *      时间复杂度:O(1)\r\n     *      空间复杂度:O(n)\r\n     * */\r\n    public void push(int x) {\r\n        stack.push(x);\r\n    }\r\n\r\n    /**\r\n     * Removes the element from in front of queue and returns that element.\r\n     * @复杂度分析\r\n     *      时间复杂度:摊还时间复杂度为O(1)\r\n     *      空间复杂度:O(1)\r\n     * */\r\n    public int pop() {\r\n        if (queue.isEmpty()){\r\n            while (!stack.isEmpty()){\r\n                queue.push(stack.poll());\r\n            }\r\n        }\r\n        return queue.pop();\r\n    }\r\n\r\n    /**\r\n     * Get the front element.\r\n     * 时间复杂度:\r\n     *      摊还时间复杂度:O(1)\r\n     *      空间复杂度:O(1)\r\n     * */\r\n    public int peek() {\r\n        if (queue.isEmpty()){\r\n            while (!stack.isEmpty()){\r\n                queue.push(stack.poll());\r\n            }\r\n        }\r\n        return queue.peek();\r\n    }\r\n\r\n    /**\r\n     * Returns whether the queue is empty.\r\n     *时间复杂度:\r\n     *      时间复杂度:O(1)\r\n     *      空间复杂度:O(1)\r\n     * */\r\n    public boolean empty() {\r\n        if (stack.isEmpty()&&queue.isEmpty()){\r\n            return true;\r\n        }return false;\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- push()\r\n    - 时间复杂度:O(1)\r\n    - 空间复杂度:O(n)\r\n- pop()\r\n    - 摊还时间复杂度:O(1)\r\n    - 空间复杂度:O(1)\r\n- empty()\r\n    - 时间复杂度:O(1)\r\n    - 空间复杂度:O(1)\r\n- peek()\r\n    - 摊还时间复杂度:O(1)\r\n    - 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920139873","body":"## 思路\r\n\r\n先对原数组排序,排好序后找到原数组中每个对应位置(p)元素应该在的位置(q),从左往右遍历数组根据(p,q)的区间的包含关系可以不断扩大stk的大小.\r\n\r\n## 语言\r\n\r\njava\r\n\r\n## 代码\r\n\r\n```java\r\npublic int maxChunksToSorted(int[] arr) {\r\n        Stack<Pair<Integer, Integer>> stk = new Stack<>();\r\n        int[] sorted ;\r\n       sorted =arr.clone();\r\n       Arrays.sort(sorted);\r\n        int[] indexs = new int[arr.length];\r\n        for (int i = 0; i < arr.length; i++) {\r\n            int index =Search(sorted, arr[i]);\r\n            indexs[i]=index;\r\n        }\r\n        for (int i = 0; i < arr.length; i++) {\r\n            int left=Math.min(i,indexs[i]),right=Math.max(i,indexs[i]);\r\n            if (stk.isEmpty()){\r\n                stk.push(new Pair<>(left,right));\r\n            }else{\r\n                Pair<Integer, Integer> idx = stk.pop();\r\n                int preL=idx.getKey();\r\n                int preR=idx.getValue();\r\n                if (preL <= left && preR >= left && right > preR) {\r\n                    stk.push(new Pair<>(preL,right));\r\n                }\r\n                else if (left>preR){\r\n                    stk.push(new Pair<>(preL,preR));\r\n                    stk.push(new Pair<>(left,right));\r\n                }else {\r\n                    stk.push(new Pair<>(preL,preR));\r\n                }\r\n            }\r\n        }\r\n\r\n        return stk.size();\r\n    }\r\n     private int Search(int[] sorted, int a) {\r\n        int i=0;\r\n        while (sorted[i++]!=a);\r\n        sorted[--i]=-1;\r\n        return i;\r\n    }\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:$O(n*logn+n^2)$\r\n- 空间复杂度:$O(2n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921025541","body":"## 思路\r\n\r\n通过遍历找到链表的最后一个元素,并统计出链表的长度大小==size==。利用==（k%size）==的值来判断移动后链表的头节点位置，若（k%size）== 0 直接返回head，否则遍历到应该返回的头结点的前一个结点处，把它的next设置为==null==。\r\n\r\n## 语言\r\n\r\njava\r\n\r\n## 代码\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n     public ListNode rotateRight(ListNode head, int k) {\r\n\r\n        if (k==0||head==null)return head;\r\n        int size=1;\r\n        ListNode pre=null,cur=head;\r\n        while (cur.next!=null){\r\n            cur=cur.next;\r\n            size++;\r\n        }\r\n        if (k%size==0)return head;\r\n        cur.next=head;\r\n        cur=cur.next;\r\n        \r\n        int time=size-(k%size);\r\n        while (time-->0){\r\n            pre=cur;\r\n            cur=cur.next;\r\n        }\r\n        if (pre!=null){\r\n            pre.next=null;\r\n        }\r\n        return cur;\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:$O(n)$\r\n- 空间复杂度:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921885796","body":"## 思路\r\n\r\n链表操作(穿针引线法)\r\n\r\n\r\n\r\n## 语言\r\n\r\njava\r\n\r\n## 代码\r\n\r\n```java\r\npublic ListNode swapPairs(ListNode head) {\r\n        ListNode virHead = new ListNode(0, head);\r\n        ListNode cur=virHead;\r\n        while (cur.next!=null&&cur.next.next!=null){\r\n            ListNode t=cur.next;\r\n\r\n            cur.next=cur.next.next;\r\n            cur=cur.next;\r\n            t.next=cur.next;\r\n            cur.next=t;\r\n            cur=t;\r\n        }\r\n        return virHead.next;\r\n    }\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:$O(n)$\r\n- 空间复杂度:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922330156","body":"## 思路\r\n\r\n找到链表中点即为树的根，同时将链表拆为两段，该根的左节点为左边一段的中点，右节点为右边一段的中点，依次递归下去\r\n\r\n\r\n\r\n## 语言\r\n\r\njava\r\n\r\n## 代码\r\n\r\n```java\r\npublic TreeNode sortedListToBST(ListNode head) {\r\n        if (head==null) return null;\r\n        if (head.next==null) return new TreeNode(head.val);\r\n        ListNode dummy=new ListNode(-1,head),slow=dummy,fast=dummy,prev=head;\r\n        while (fast!=null&&fast.next!=null) {\r\n            prev=slow;\r\n            slow=slow.next;\r\n            fast=fast.next.next;\r\n        }\r\n        ListNode head2=slow.next;\r\n        prev.next=null;\r\n        TreeNode root=new TreeNode(slow.val);\r\n        if (prev!=dummy) {\r\n            root.left=sortedListToBST(head);\r\n        }\r\n        root.right=sortedListToBST(head2);\r\n        return root;\r\n    }\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:$O(n)$\r\n- 空间复杂度:$O(logN)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922495552","body":"## 思路\r\n\r\n用双指针逐一遍历链表,判断是否相等,若一趟循环中没有找到相等的则==交换遍历==,直到两者相等.\r\n\r\n## 语言\r\n\r\njava\r\n\r\n\r\n\r\n## 代码\r\n\r\n```java\r\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n    if (headA == null || headB == null) {\r\n        return null;\r\n    }\r\n    ListNode curA = headA , curB = headB;\r\n    while (curA != curB) {\r\n        curA = curA == null ? headB : curA.next;\r\n        curB = curB == null ? headA : curB.next;\r\n    }\r\n    return curA;\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 最差时间复杂度:$O(n)$\r\n- 空间复杂度:$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crystallili":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916642169","body":"### 思路\n把k当作carry 从num的末位开始做加法（做余），不断update k（做除）做为新的carry。最后判断k是否为0，不是为0就用相同方法把k的值放到linkedlist中。\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        for (int i = num.length-1; i>=0; i--) {\n            ans.add(0, (num[i]+k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k > 0) {\n            ans.add(0, k % 10);\n            k = k / 10;\n        }\n        return ans;\n    }\n}\n```\n### 复杂度\n- 空间只要生成linkedlist就行，所以是O(n)\n- 时间的话，因为一直insert在头部，所以每次是o(1), 做n次，所以也是o(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"benngfour":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916643778","body":"### 思路\r\n\r\n從 Array 尾部開始相加，然後計算剩下的；最後檢查 carryOver 的數字\r\n\r\n### 語言\r\n\r\nJavaScript\r\n\r\n### Code Solution\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let result = [];\r\n    let carryOver = 0;\r\n    const arrK = k.toString().split('');\r\n    let numLen = num.length;\r\n    let kLen = arrK.length;\r\n    if (kLen >= numLen) {\r\n        for (let j = numLen - 1; j >= 0; j--) {\r\n                let kNum = Number(arrK[kLen - 1]);\r\n                let sum = kNum + num[j] + carryOver;\r\n                if (sum < 10) {\r\n                    result.push(sum);\r\n                    carryOver = 0;\r\n                } else {\r\n                    result.push(sum - 10);\r\n                    carryOver = 1;\r\n                }\r\n                kLen--;\r\n        }\r\n        for (let i = kLen - 1; i >= 0; i--) {\r\n            let kNum = Number(arrK[i]);\r\n            if (kNum + carryOver >= 10) {\r\n                result.push((kNum + carryOver) - 10);\r\n                carryOver = 1;\r\n            } else {\r\n                result.push(kNum + carryOver);\r\n                carryOver = 0;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = kLen - 1; i >= 0; i--) {\r\n            let kNum = Number(arrK[i]);\r\n                let sum = kNum + num[numLen - 1] + carryOver;\r\n                if (sum < 10) {\r\n                    result.push(sum);\r\n                    carryOver = 0;\r\n                } else {\r\n                    result.push(sum - 10);\r\n                    carryOver = 1;\r\n                }\r\n            numLen--;\r\n        }\r\n        for (let j = numLen - 1; j >= 0; j--) {\r\n            if (num[j] + carryOver >= 10) {\r\n                result.push((num[j] + carryOver) - 10);\r\n                carryOver = 1;\r\n            } else {\r\n                result.push(num[j] + carryOver);\r\n                carryOver = 0;\r\n            }\r\n        }\r\n\r\n    }\r\n    if (carryOver > 0) {\r\n        result.push(1);\r\n    }\r\n    return result.reverse();\r\n};\r\n```\r\n\r\n### 複雜度分析\r\n\r\n- 時間複雜度 O(N): 沒有 nested for loop， 時間取決於最大的那個 Array length\r\n- 空間複雜度 O(1): 只佔用 result array","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917425008","body":"### 思路\n\n先獲取 input 字符在 s 的所有 index，然後 loop over s 中的字符，計算最短距離，再放入 answer 中\n\n### 語言\n\nJavaScript\n\n### Code Solution\n\n```\nvar shortestToChar = function(s, c) {\n    let answer = [];\n    let idx = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            idx.push(i);\n        }\n    }\n    for (let j = 0; j < s.length; j++) {\n        let shortestIdx = s.length;\n        for (let k = 0; k < idx.length; k++) {\n            shortestIdx = Math.min(Math.abs(j - idx[k]), shortestIdx);\n        }\n        answer.push(shortestIdx);\n    }\n    return answer;\n};\n```\n\n### 複雜度分析\n\n- 時間複雜度 O(N^2): nested for loop\n- 空間複雜度 O(2): one answer array, one idx array","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918784768","body":"### 思路\n\n用 Array 作為數據結構的基礎，然後再使用 JavaScript Array 內置的 function 實現題目的要求\n\n### 語言\n\nJavaScript\n\n### Code Solution\n\n```\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.queue = [];\n};\n\n/**\n * Push element x to the back of queue.\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.queue.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this.queue.length !== 0) {\n        return this.queue.shift();\n    } else {\n        return null;\n    }\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this.queue.length > 0) {\n        return this.queue[0];\n    } else {\n        return null;\n    }\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    if (this.queue.length === 0) {\n        return true;\n    } else {\n        return false;\n    }\n};\n```\n\n### 複雜度分析\n\n- 時間複雜度: 因為 Peek 使用了 Array 的 shift function， shift function 最差是 O(N)，其餘均是 O(1)\n- 空間複雜度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919725032","body":"### 思路\n\n參考單調盞\n\n### 語言\n\nJavaScript\n\n### Code Solution\n\n```\nclass Stack {\n    constructor() {\n        this.list = [];\n    }\n    push(value) {\n        return this.list.push(value);\n    }\n    peek() {\n        return this.list[this.list.length - 1];\n    }\n    pop() {\n        return this.list.pop();\n    }\n    size() {\n        return this.list.length;\n    }\n    isEmpty() {\n        return this.list.length === 0;\n    }\n}\n\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const stack = new Stack();\n    for (let i = 0; i < arr.length; i++) {\n        if (stack.isEmpty() || stack.peek() <= arr[i]) {\n            stack.push(arr[i]);\n        } else {\n            const temp = stack.pop();\n            while(stack.peek() > arr[i]) {\n                stack.pop()\n            }\n            stack.push(temp);\n        }\n    }\n    return stack.size();\n};\n```\n\n### 複雜度分析\n\n- 時間複雜度: O(N)\n- 空間複雜度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920982106","body":"### 思路\n\n1.找LinkedList的Length，k如果是length的倍數就會跟原本的一樣\n2.找到需要停下的點，開始loop over linkedlist，數到點之後斷開\n3.return newHead\n\n### 語言\n\nJavaScript\n\n### Code Solution\n\n```\nvar rotateRight = function(head, k) {\n    if (head === null) {\n        return null;\n    }\n    let len = 1;\n    let dummyHead = head;\n    while (dummyHead.next !== null) {\n        len++;\n        dummyHead = dummyHead.next;\n    }\n    let stopPos = len - k % len;\n\n    if (k === len || stopPos === len || k ===0 || len === 1) {\n        return head;\n    }\n    dummyHead.next = head;\n\n    while (stopPos) {\n        dummyHead = dummyHead.next;\n        stopPos--;\n    }\n\n    const newHead = dummyHead.next;\n    dummyHead.next = null;\n\n    return newHead;\n};\n```\n\n### 複雜度分析\n\n- 時間複雜度: O(N): loop linkedlist once\n- 空間複雜度 O(1)： only created dummyHead\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921502673","body":"### 思路\n\nSet one more head in front of the original list，loop over the list and swap the nodes.\n\n### 語言\n\nJavaScript\n\n### Code Solution\n\n```\nvar swapPairs = function(head) {\n    if (!head || head.next === null) {\n        return head;\n    }\n    let newHead = new ListNode(0);\n    newHead.next = head;\n    let temp = newHead;\n    while(temp.next && temp.next.next) {\n        const node1 = temp.next;\n        const node2 = temp.next.next;\n        temp.next = node2;\n        node1.next = node2.next;\n        node2.next = node1;\n        temp = node1;\n    }\n    return newHead.next\n};\n```\n\n### 複雜度分析\n\n- 時間複雜度: O(N): loop linkedlist once\n- 空間複雜度 O(1)： only created newHead\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922497632","body":"### 思路\n\n兩個LinkedList一起遍歷，檢測兩個nodes是否相等，其中一個到了盡頭就到另外一個遍歷。\n\n### 語言\n\nJavaScript\n\n### Code Solution\n\n```\nvar getIntersectionNode = function(headA, headB) {\n    if (!headA || !headB) return null;\n    let a = headA, b = headB;\n    while (a !== b) {\n        a = !a ? headB : a.next;\n        b = !b ? headA : b.next;\n    }\n    return a;\n};\n```\n\n### 複雜度分析\n\n- 時間複雜度: O(N): loop linkedlist once\n- 空間複雜度 O(1)：","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ergwang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916643891","body":"### 思路\r\n\r\n1. 看到题首先想到，变成整数然后直接加再变成数组返回，然后觉得要数组—整数—数组，要遍历两次，肯定时间复杂度高，**倒是没想到整数超范围，看了大家评论才发现**\r\n2. 然后想到直接从末尾加，满十进位就行，准备开整，看了题目给的返回值类型是list，又给提醒了，数组直接进位会出现溢出的情况\r\n3. List搞起来，跑通了，发现还要逆序，用到了Collections.reverse(list);  成了（相当于又遍历了一次）。用时超过38%的人，肯定不完美\r\n4. 去评论区找到了LinkedList ，直接调用双向链表的addFirst，一次遍历出结果，舒服了。\r\n\r\n\r\n\r\n\r\n\r\n### 代码\r\n\r\n\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        int over;\r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            // 获取进位值\r\n            over = (num[i] + k) / 10;\r\n            // 得当当前位的值\r\n            num[i] = (num[i] + k) % 10;\r\n            k = over;\r\n            list.addFirst(num[i]);\r\n        }\r\n        // 数组遍历完了，可能进位值是大于0，甚至大于十、百、千，继续进位\r\n        while (k > 0){\r\n            list.addFirst(k % 10);\r\n            k = k / 10;\r\n        }\r\n        return list;\r\n    }\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n—  时间复杂度：O(n)，其中n为数组长度。\r\n\r\n—  空间复杂度：O(n)，新建了一个链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917413303","body":"### 思路\n\n1. 首先想到一次遍历就得到结果，顺势得出两个指针，一个指向当前元素的左边目标值，一个只想右边目标值，去较小的距离存入数组中，（没动手）\n2. 看了大家的评论，用的是正反遍历的办法，正向遍历获取每个元素距离右边的目标值的距离，反向获取每个元素距离左边目标值的距离，两者取小的存入数组\n\n\n\n\n\n### 代码\n\n\n\n```java\npublic static int[] shortestToChar(String s, char c) {\n        char[] chars = s.toCharArray();\n        int[] temp = new int[chars.length];\n        // 找到第一个目标字符的索引\n        int rightIndex = findRightIndex(c, 0, chars);\n\n        // 正向遍历生成每个字符距离右边最近目标的距离\n        for (int i = 0; i < s.length() - 1; i++) {\n            temp[i] = Math.abs(rightIndex - i);\n            if (chars[i] == c){\n                rightIndex = findRightIndex(c, i, chars);\n            }\n        }\n        // 最后一位没考虑\n        temp[s.length() - 1] = (s.length() - 1) - rightIndex;\n\n        // 同理，反方向再来一次取两次最小值\n        int leftIndex= findLeftIndex(c, s.length()-1, chars);\n        for (int i = s.length() - 1; i > 0; i--) {\n            temp[i] = Math.min(Math.abs(i - leftIndex), temp[i]);\n            if (chars[i] == c){\n                leftIndex = findLeftIndex(c, i, chars);\n            }\n        }\n        // 第一位没考虑\n        temp[0] = leftIndex == 0? 0:temp[0];\n        return temp;\n    }\n\n    private static int findRightIndex(char c , int i, char[] chars){\n        for (int j = i+1; j < chars.length; j++) {\n            if (chars[j] == c){\n                return j;\n            }\n        }\n        return i;\n    }\n\n    private static int findLeftIndex(char c , int i, char[] chars){\n        for (int j = i-1; j >= 0; j--) {\n            if (chars[j] == c){\n                return j;\n            }\n        }\n        return i;\n    }\n\n```\n\n\n\n\n\n**复杂度分析**\n\n—  时间复杂度：O(3n)，其中n为字符串长度。字符串转为数组一次，正反遍历各一次（考虑转换的时候做一次判断就能变为2n了）\n\n—  空间复杂度：O(2n)，新增了一个字符数组和一个整数数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917593431","body":"### 思路\r\n\r\n1. 功能倒是很简单，之前有写过类似的东西\r\n2. 但是时间复杂度就是高啊，还得多看看大神写的代码\r\n\r\n3. 看到大家都用的数组，好像更简单，是我想复杂了？？？\r\n\r\n\r\n\r\n### 代码\r\n\r\n\r\n\r\n```java\r\nclass CustomStack {\r\n    private Integer size = 0;\r\n    private LinkedList<Integer> stack;\r\n    private final Integer maxSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        this.stack = new LinkedList<>();\r\n    }\r\n\r\n    /**\r\n     * void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\n     * @param x 元素\r\n     */\r\n    public void push(int x) {\r\n        if (this.size < this.maxSize){\r\n            stack.addFirst(x);\r\n            size++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\n     * @return 栈顶元素或-1\r\n     */\r\n    public int pop() {\r\n        if (size <= 0){\r\n            return -1;\r\n        }else {\r\n            size--;\r\n            return stack.removeFirst();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n     * @param k 栈底的 k 个元素\r\n     * @param val  增加 val\r\n     */\r\n    public void increment(int k, int val) {\r\n        int temp = (k > size? size : k);\r\n        for (int i = 0; i < temp; i++) {\r\n            this.stack.set(size-i-1,this.stack.get(size-i-1)+val);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n—  时间复杂度：\r\n\r\n1. pop()  : O (1)，直接改了虚拟size\r\n2. push() : O(1)，双向链表，直接加头上\r\n3. increment() : O(2n)，先遍历查找，修改后再遍历修改进去\r\n\r\n—  空间复杂度：\r\n\r\n1. pop()  : O (1)，没变\r\n2. push() : O(n)，每push一次，就加一个存储块\r\n3. increment() : O(1)，不变，再原基础修改了","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918761450","body":"### 思路\n\n1. 以前写过这个，但是基础数据结构不知道用啥，想着队列的话，就直接用一个双向链表时间，没想到就是最佳了\n\n\n\n\n\n### 代码\n\n\n\n```java\npublic class MyQueue {\n    \n    private LinkedList<Integer> list;\n    private Integer size = 0;\n    \n    /** Initialize your data structure here. */\n    public MyQueue() {\n        list = new LinkedList<>();\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        list.push(x);\n        size ++;\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        size--;\n        return list.removeLast();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        return list.getLast();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return size==0;\n    }\n}\n\n```\n\n\n\n\n\n**复杂度分析**\n\n—  时间复杂度：O(n)，其中n为数组长度。\n\n—  空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"A-PolarBear":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916649889","body":"### 思路\n逐位相加，并通过carry保存进位。需要注意K和num的长度关系。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int len = num.size();\n        int carry = 0;\n        int temp = 0;\n        int i=len-1;\n        while(i>=0||k!=0){\n            int A = i>=0?num[i]:0;\n            temp = A +k%10+carry;\n            carry = temp/10;\n            res.push_back(temp%10);\n            k/=10;\n            i--;\n        }\n        if(carry > 0){\n            res.push_back(carry);\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429905","body":"## 思路\n由每一个元素向两边搜索，找到最近的匹配字符，再转入下一个字符\n\n## 代码\n````c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        int prev = 0;\n        int next = 0;\n        for(int i = 0;i<s.size();i++){\n            prev = next = i;\n            while(prev>=0 || next < s.size()){\n                if(prev>=0&&s[prev]==c||next<s.size()&&s[next]==c){\n                    ans.push_back(next-i);\n                    break;\n                }\n                next++;\n                prev--;\n            }\n        }\n    return ans;\n    }\n};\n````\n## 复杂度分析\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657670","body":"## 思路\n用vector模拟栈\n\n## 代码\n````c++\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int size = 0;\n    int count = 0;\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        size = maxSize;\n    }\n    \n    void push(int x) {\n        if(count<size){\n            stk.insert(stk.begin(),x);\n            count++;\n        }\n    }\n    \n    int pop() {\n        if(count!=0){\n            int temp = stk[0];\n            stk.erase(stk.begin(),stk.begin()+1);\n            count--;\n            return temp;\n        }\n        else{\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int temp;\n        temp = min(count,k);\n        while(temp>=0){\n            stk[abs(count-temp)]+=val;\n            temp--;\n        }\n\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918334980","body":"## 思路\n栈\n\n## 代码\n````c++\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                stk.pop_back();\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                while (repTime--) t += o;\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919252335","body":"## 思路\n利用双栈，在出栈时将之前进栈的内容依次push到辅助栈中。队列为空的判断方法则是双栈都为空。\n\n## 代码\n````c++\nclass MyQueue {\nprivate:\n    stack<int> instk,outstk;\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        instk.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if(outstk.empty()){\n            while(!instk.empty()){\n                outstk.push(instk.top());\n                instk.pop();\n            }\n        }\n        int temp = outstk.top();\n        outstk.pop();\n        return temp;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if(outstk.empty()){\n            while(!instk.empty()){\n                outstk.push(instk.top());\n                instk.pop();\n            }\n        }\n        return outstk.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return instk.empty() && outstk.empty();\n    }\n};\n````","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921029513","body":"## 思路\n先首尾相连，然后找倒数第k+1个节点\n\n## 代码\n````c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        int cnt=0;\n        ListNode* temp_tail = head;\n        while(temp_tail->next!=NULL){\n            temp_tail=temp_tail->next;\n            cnt++;\n        }\n        if(k%cnt == 0) return head;\n        int rotate = cnt- k%cnt;\n        temp_tail->next=head;\n        ListNode* res;\n        for(int i = 0;i<rotate;i++){\n            temp_tail=temp_tail->next;\n        }\n        res = temp_tail->next;\n        temp_tail->next = NULL;\n        return res;\n    }\n};\n````","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mixtureve":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916652757","body":"思路：把 k 分成单个的数位，和 nums 的各个数字从后往前依次两两相加，同时注意进位\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> listK = new LinkedList<>();\r\n        int kIdx = 3;\r\n        while (k > 0) {\r\n            int digit = k % 10;\r\n            k = k / 10;\r\n            listK.add(0, digit);\r\n        }\r\n        int carryOver = 0;\r\n        int i = num.length - 1;\r\n        int j = listK.size() - 1;\r\n        List<Integer> result = new LinkedList<>();\r\n\r\n        while (i >= 0 || j >= 0) {\r\n\r\n            int a = i >= 0? num[i]: 0;\r\n            int b = j >= 0? listK.get(j): 0;\r\n\r\n            int curDigit = a + b + carryOver;\r\n\r\n            if (curDigit >= 10) {\r\n                carryOver = 1;\r\n            } else {\r\n                carryOver = 0;\r\n            }\r\n\r\n            result.add(0, curDigit % 10);\r\n             i--;\r\n            j--;\r\n        }\r\n\r\n        if (carryOver == 1) {\r\n            result.add(0, 1);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}`\r\nspace complexity: O(X) X指k的位数\r\ntime complexity: O(max(n, X))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917362155","body":"## 思路\r\n- 先过一遍string，记下所有字符c出现的 indes，放进 list 里\r\n- 遍历 string 的每个字符，用一个 pointer k 来指定该用的 list index 来与当前字符的 index 计算距离。do k++ when Math.abs(i - list.get(k)) > Math.abs(i - list.get( k + 1))\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        List<Integer> cIdxList = new ArrayList<>();\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                cIdxList.add(i);\r\n            }\r\n        }\r\n        int m = cIdxList.size();\r\n        int[] ret = new int[n];\r\n        int k = 0; // k is the pointer for cIdxList\r\n        for (int i = 0; i < n; i++) {\r\n            \r\n            if (k + 1 < m && Math.abs(i - cIdxList.get(k)) > Math.abs(i - cIdxList.get(k + 1))) {\r\n                k++;\r\n            }\r\n            ret[i] = Math.abs(i - cIdxList.get(k));\r\n            \r\n        }\r\n        return ret;\r\n        \r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为 string 长度, m 为 c在 string 出现的次数\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(m)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917588217","body":"## 思路\r\n- 用一个 array 去记录增量\r\n- 用 stack 模拟操作\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int n;\r\n    int[] increaseArr;\r\n    Stack<Integer> stack;\r\n    public CustomStack(int maxSize) {\r\n        n = maxSize;\r\n        increaseArr = new int[n];\r\n        stack = new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (stack.size() < n)\r\n            stack.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        int i = stack.size() - 1;\r\n        if (i < 0)\r\n            return -1;\r\n        if (i > 0)\r\n            increaseArr[i - 1] += increaseArr[i];\r\n        int res = stack.pop() + increaseArr[i];\r\n        increaseArr[i] = 0;\r\n        return res;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int i = Math.min(k, stack.size()) - 1;\r\n        if (i >= 0)\r\n            increaseArr[i] += val;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917899533","body":"\r\n## 思路\r\nStart traversing string s and process each character based on the following rules:\r\n\r\nCase 1) Current character is not a closing bracket ]. Push the current character to stack.\r\n\r\nCase 2) Current character is a closing bracket ].\r\n\r\nStart decoding the last traversed string by popping the string decodedString and number k from the top of the stack.\r\n\r\nPop from the stack while the next character is not an opening bracket [ and append each character (a-z) to the decodedString.\r\nPop opening bracket [ from the stack.\r\nPop from the stack while the next character is a digit (0-9) and build the number k.\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        // 3[a2[bc]]\r\n        // when meet ] poll out from stack\r\n        // a temp list to hold parsed string with in a []\r\n        \r\n        // 注意！！！！k的取值范围 k可能并不是一个digit\r\n    \r\n        Deque<Character> stack = new ArrayDeque<>();\r\n        char[] sArr = s.toCharArray();\r\n        for (int i = 0; i < sArr.length; i++) {\r\n            if (sArr[i] != ']') {\r\n                stack.push(sArr[i]);\r\n            } else {\r\n                List<Character> tempList = new ArrayList<>();\r\n                while(!stack.isEmpty() && stack.peek() != '[') {\r\n                    tempList.add(stack.pop());\r\n                }\r\n                stack.pop(); // pop out '['\r\n                int base = 1;\r\n                int num = 0;\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    num += (stack.pop() - '0') * base;\r\n                    base *= 10;\r\n                }\r\n              \r\n                // reverse order push into stack again\r\n                while (num-- > 0) {\r\n                    for (int j = tempList.size() - 1; j >= 0; j--) {\r\n                        stack.push(tempList.get(j));\r\n                    }\r\n                }   \r\n            }\r\n        }\r\n        \r\n        char[] result = new char[stack.size()];\r\n        int i = stack.size() - 1;\r\n        while (!stack.isEmpty()) {\r\n            result[i--] = stack.pop();\r\n        }\r\n        return new String(result);\r\n        \r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919285226","body":"## 思路\r\n用两个stack，一个用来push元素，一个用来peek和poll\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    // 1, 2, 3, 4\r\n    // [3, 4\r\n    // push 时候就随便放进s1，然后peek时候看s2是否为空，如果是空，就去s1里倒腾，不是空的话直接pop s2\r\n    // [2, 1\r\n    Deque<Integer> s1;\r\n    Deque<Integer> s2;\r\n    int size;\r\n    \r\n    /** Initialize your data structure here. */\r\n    \r\n    public MyQueue() {\r\n        s1 = new LinkedList<>();\r\n        s2 = new LinkedList<>();\r\n        size = 0;\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (!s2.isEmpty()) {\r\n            return s2.pop();\r\n        }\r\n        moveEle();\r\n        return s2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (!s2.isEmpty()) {\r\n            return s2.pop();\r\n        }\r\n        moveEle();\r\n        return s2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        if (size() == 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    // new method    \r\n    public int size() {\r\n        return s1.size() + s2.size();\r\n    }\r\n    \r\n    public boolean moveEle() {\r\n        while (!s1.isEmpty()) {\r\n            s2.push(s1.pop());\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$ for peek() and poll()\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920143574","body":"## 思路\r\nIterate through the array, each time all elements to the left are smaller (or equal) to all elements to the right (use two arrays to record the left and right elements), there is a new chunck.\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int n = arr.length;\r\n        int[] maxOfLeft = new int[n];\r\n        int[] minOfRight = new int[n];\r\n\r\n        maxOfLeft[0] = arr[0];\r\n        for (int i = 1; i < n; i++) {\r\n            maxOfLeft[i] = Math.max(maxOfLeft[i-1], arr[i]);\r\n        }\r\n\r\n        minOfRight[n - 1] = arr[n - 1];\r\n        for (int i = n - 2; i >= 0; i--) {\r\n            minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]);\r\n        }\r\n\r\n        int res = 0;\r\n        for (int i = 0; i < n - 1; i++) {\r\n            if (maxOfLeft[i] <= minOfRight[i + 1]) res++;\r\n        }\r\n\r\n        return res + 1;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920648050","body":"## 思路\r\n1. 计算链表长度，k与长度的模。\r\n2. 确定三个点，新 head：倒数 kth node 也是正数 ( len - n - 1)th，新 head 的前一个 node，原来的 tail\r\n3. 组合这三个node\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null || k == 0) {\r\n            return head;\r\n        }\r\n        \r\n        int length = 0;\r\n        ListNode cur = head;\r\n        ListNode prev = null;\r\n        while (cur != null) {\r\n            length++;\r\n            prev = cur;\r\n            cur = cur.next;\r\n        }\r\n        \r\n        ListNode tail = prev;\r\n        // 先把尾巴接上\r\n        tail.next = head;\r\n        \r\n        k = k % length;\r\n     \r\n        \r\n        // (n - k % n - 1)\r\n        cur = head;\r\n        for (int i = 0; i < length - k - 1; i++) {\r\n            cur = cur.next;\r\n        }\r\n        \r\n        ListNode next = cur.next;\r\n    \r\n        cur.next = null;\r\n      \r\n       \r\n        return next;\r\n        \r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921901733","body":"## 思路\nrecursion 做法：\n对每个字问题：\n1. 对第三个node call recursion， return newNode\n2. 把 head 指向 newNode，secode node 指向 head， return second node\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // base case\n        if (head == null || head.next == null) {\n            return head;\n        }\n        // base case 保证了链表至少有两个nodes，so next 一定不为null\n        ListNode next = head.next;\n        ListNode newHead = null;\n        \n        newHead = swapPairs(next.next);\n        \n        head.next = newHead;\n        next.next = head;\n        return next;\n        \n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为链表长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922331888","body":"## 思路\r\n1. 找到链表长度\r\n2. 用 inorder traversal 去重建树\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node \r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    private ListNode head;\r\n    \r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        int size = this.findSize(head);\r\n        this.head = head;\r\n        // Form the BST now that we know the size\r\n        return convertListToBST(0, size - 1);\r\n    }\r\n    \r\n    private TreeNode convertListToBST(int l, int r) {\r\n        // Invalid case\r\n        if (l > r) {\r\n          return null;\r\n        }\r\n\r\n        int mid = (l + r) / 2;\r\n\r\n        // First step of simulated inorder traversal. Recursively form\r\n        // the left half\r\n        TreeNode left = convertListToBST(l, mid - 1);\r\n\r\n        // Once left half is traversed, process the current node\r\n        TreeNode node = new TreeNode(head.val);\r\n        node.left = left;\r\n\r\n        // Maintain the invariance mentioned in the algorithm\r\n        head = head.next;\r\n\r\n        // Recurse on the right hand side and form BST out of them\r\n        node.right = convertListToBST(mid + 1, r);\r\n        return node;\r\n    }\r\n    \r\n    private int findSize(ListNode head) {\r\n        int c = 0;\r\n        while (head != null) {\r\n          head = head.next;  \r\n          c += 1;\r\n        }\r\n        return c;\r\n  }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(logn)$ call stack\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922496004","body":"## 思路\r\n如果有相交点，让两条链的指向头节点的 pointers 同时出发，当二者走的距离相同时就会相交。\r\n若A链先到头，则让 curA 指向B链的头， B链一样。这样就能让两个pointers走同样的路程了。\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode curA = headA;\r\n        ListNode curB = headB;\r\n        \r\n        while (curA != curB) {\r\n            if (curA == null && curB == null) {\r\n                return null;\r\n            } else if (curA == null) {\r\n                curA = headB;\r\n            } else if (curB == null) {\r\n                curB = headA;\r\n            }\r\n            \r\n            curA = curA.next;\r\n            curB = curB.next;\r\n        }\r\n        return curA;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freedom0123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916654651","body":"#  989、数组形式的整数加法\n\n## 思路\n\n本质上就是 手动模拟加法的过程\n\n这种思路同时适用于高精度加法\n\n```java\nclass Solution {\n    List<Integer> res = new ArrayList();\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> resTem = new ArrayList<>() ;\n        List<Integer> res  =new ArrayList<>();\n        int i = num.length-1;\n        int tem  = 0;//用来表示进位\n        while(i>=0 || k!=0){\n            if(i>=0){\n                tem+=num[i];\n                i--;\n            }\n            if(k!=0){\n                tem+=(k%10);\n                k= k/10;\n            }\n            resTem.add(tem%10);\n            tem = tem/10;\n        }\n        if(tem>0){\n            resTem.add(tem);\n        }\n        //最后将res 倒叙输出\n        for(int j  = resTem.size()-1;j>=0;j--){\n            res.add(resTem.get(j));\n        }\n        return  res;\n    }\n\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917326625","body":"时间复杂度：O(N)\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] answer = new int[s.length()];\n        //最后一次 c出现的位置，因为要求的是距离最近\n        int pre = Integer.MIN_VALUE/2;\n        //从前往后进行扫描，记住 c 在s[i] 的左边距 距离最近的一次\n        for(int i  = 0;i<s.length();i++){\n           if(s.charAt(i) == c){\n               //说明这就是 c 最后一次出现的位置\n               pre = i;\n           }\n           answer[i] =  i - pre;\n        }\n        pre = Integer.MAX_VALUE/2;\n         for(int i  = s.length()-1;i>=0;i--){\n           if(s.charAt(i) == c){\n               pre = i;\n\n           }\n           answer[i] = Math.min(answer[i],pre-i);\n        }\n\n        return answer;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917550269","body":"用数组模拟栈\n```\nclass CustomStack {\n    private int index;\n    private int[] stack;\n    //初始化\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        index = 0;\n    }\n    // 向栈中添加元素\n    public void push(int x) {\n        if(index >= stack.length){\n            return;\n        }\n        stack[index++] = x;\n\n    }\n    \n    public int pop() {\n        if(index == 0){\n            return -1;\n        }\n        return stack[--index];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i  = 0; i<k && i<index;i++){\n            stack[i]+=val;\n        }\n\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918132276","body":"```\nclass Solution {\n    public String decodeString(String s) {\n        //定义结果\n        StringBuffer buffer = new StringBuffer();\n        //用来 定义字符栈\n        LinkedList<String> listString = new LinkedList<>();\n        // 用来定义数字栈\n        LinkedList<Integer> listInt = new LinkedList<>();\n        for(int i = 0;i<s.length();){\n            if(s.charAt(i)!=']'){\n                char a = s.charAt(i);\n                if(a>'9' || a<'0'){\n                    //进入字符栈中\n                    listString.add(a+\"\");\n                    i++;\n                }else{\n                    //就是数字，进入数字栈中\n                    int j  = i+1;\n                    int tem = a-'0';\n                    while(s.charAt(j)<='9' && s.charAt(j)>='0' && j<s.length()){\n                        tem = tem *10 + (s.charAt(j)-'0');\n                        j++;\n                    }\n                    i = j;\n                    listInt.add(tem);\n                }\n            }else{\n                //用来取出字符栈中的元素\n                String temString = new String();\n                //用来拿出栈顶的数字\n                int temInt = listInt.getLast();\n                listInt.removeLast();\n                // 循环拿出 字符\n                while(!listString.isEmpty() && !listString.getLast().equals(\"[\")){\n                    temString = listString.getLast()+temString;\n                    listString.removeLast();\n                }\n                listString.removeLast();\n                StringBuffer sb = new StringBuffer();\n                for(int k = 1;k<=temInt;k++){\n                    sb.append(temString);\n                }\n                //如果说listInt不是空的，就将结果压在listString栈中\n                if(!listInt.isEmpty()){\n                    listString.add(sb.toString());\n                }else{\n                    //反之，加到结果中\n                    String ss = \"\";\n                    while(!listString.isEmpty()){\n                        ss = listString.getLast()+ss;\n                        listString.removeLast();\n                    }\n                    buffer.append(ss);\n                    buffer.append(sb);\n                }\n                i++;\n            }\n        }\n        if(!listString.isEmpty()){\n            for(int i =0;i<listString.size();i++){\n                buffer.append(listString.get(i));\n            }\n        }\n        return buffer.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918935245","body":"java使用LinkedList轻松搞定，时间复杂度都是O（1）\n```\nclass MyQueue {\n    private LinkedList<Integer> linkedList;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n         linkedList = new LinkedList<Integer>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        linkedList.add(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(empty()){\n            return 0;\n        }\n        int x = linkedList.getFirst();\n        linkedList.removeFirst();\n        return  x;\n\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(empty()){\n            return 0;\n        }\n        int x = linkedList.getFirst();\n        return  x;\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return linkedList.size() == 0;\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919882866","body":"```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        if(arr.length == 0 || arr == null){\n            return 0;\n        }\n        LinkedList<Integer> stack = new LinkedList<>();\n        for(int i   = 0; i<arr.length;i++){\n            int temp  =-1;\n            while(!stack.isEmpty() && stack.getLast() > arr[i]){\n                temp = Math.max(temp,stack.getLast());\n                stack.removeLast();\n            }\n            if(temp !=-1){\n                stack.add(temp);\n\n            }else{\n                stack.add(arr[i]);\n            }\n        }\n        return stack.size();      \n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920875633","body":"```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || k==0  || head.next==null){\n            return head;\n        }\n        int num = 1;\n        // 形成一个环形链表\n        ListNode headTem = new ListNode();\n        headTem = head;\n        //寻找未节点\n        while(headTem.next!=null){\n            headTem= headTem.next;\n            num++;\n        }\n        if(num == k){\n            return head;\n        }\n        //形成 一个循环链表\n        headTem.next = head;\n  \n        ListNode l1 = head;\n        for(int i =1;i<(num-k%num);i++){\n            l1 = l1.next;\n        }\n        ListNode res = l1.next;\n        l1.next = null;\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921766330","body":"```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922479808","body":"```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null){\n            return null;\n        }       \n        Set<ListNode> set = new HashSet<>();\n        ListNode h1 = headA;\n        while(h1!=null){\n            set.add(h1);\n            h1=h1.next;\n        }\n        ListNode h2 = headB;\n        while(h2!=null){\n            if(set.contains(h2) ){\n                return h2;\n            }\n            h2=h2.next;\n        }\n        return null;\n        \n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leolisgit":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916654773","body":"### 思路\n1. 看到这道题，想到一个类似的题目，是两个list相加。然后有点类似于merge sort中merge这一步。\n从末尾一直加到开头，如果有一个数组没有到头，就加到结果上。这种方法可以做，但是写起来比较繁琐，因为需要把int转化为数组先。\n2. 因为数据范围限制，没有办法把int 数组转换为数值相加。\n3. 其实每次我们只需要求得该位的余数即可。这样可以直接把k拿来用。使用k和数组每一位求和，取余数，然后除以10。这样就可以得到每一位的余数。\n需要注意如果最后和不为0，需要把每一位取出加入list中。\n\n### 代码\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        \n        int sum = k;\n        for (int i = num.length - 1; i >= 0; i--) {\n            sum += num[i];\n            list.add(0, sum % 10);\n            sum /= 10;\n        }\n        \n        while (sum > 0) {\n            list.add(0, sum % 10);\n            sum /= 10;\n        }\n        \n        return list;\n    }\n}\n```\n\n### 复杂度分析\n时间：O(N)  \n空间：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917340961","body":"### 思路\n1. 暴力解法就是记录所有字符出现的位置。然后对于每个字符，进行距离的比较。\n2. 优化\n    * 剪枝，一旦遇到字符的位置距离当前字符的位置开始增加，就可以跳出循环\n    * 对记录字符位置进行二分，可以把时间复杂度降低到O(nlog)\n\n**最优解**:\n从左到右和从右到左遍历两遍，因为最近距离不是到左边字符最近就是到右边，或者相等。\n如果左边没有遇到所求字符，那么该字符一定是到右边的最近。就设置一个虚拟的值。取length + 1即可。\n\n### 代码\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ret = new int[n];\n        \n        int temp = n + 1;\n        for (int i = 0; i < s.length(); i++) {\n            if (c == s.charAt(i)) {\n                temp = 0;\n            } else {\n                temp++;\n            }\n            ret[i] = temp;\n        }\n        \n        temp = n + 1;\n        for (int i = n - 1; i >= 0; i--) {\n            if (c == s.charAt(i)) {\n                temp = 0;\n            } else {\n                temp++;\n            }\n            ret[i] = Math.min(ret[i], temp);\n        }\n        return ret;\n    }\n}\n```\n\n### 复杂度分析\n1. 时间复杂度：O(n)\n2. 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917569465","body":"### 思路\n数组模拟栈。\n1. 暴力做法就每次做increment操作，把增加的值加到数组对应的位置, 时间复杂度为O(n)\n2. 使用presum来优化，但是这个presum相当于是从后往前加。使用一个add数组来保存增量。如果栈顶元素弹出，并且该位置有增量。\n就加上该增量。然后该位置的增量设置为0，因为是从bottom到该位置，该位置之前的元素也属于该增量的范围内。把该值加到之前的一个位置上。\n\n### 代码\n```\nclass CustomStack {\n\n    private int[] stack;\n    private int maxSize;\n    private int[] add;\n    private int cur;\n    \n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        this.maxSize = maxSize;\n        add = new int[maxSize];\n        cur = -1;\n    }\n    \n    public void push(int x) {\n        if (cur + 1 < maxSize) {\n            stack[++cur] = x;\n        }\n    }\n    \n    public int pop() {\n        if (cur < 0) {\n            return -1;\n        }\n        \n        if (cur > 0) {\n            add[cur - 1] += add[cur];\n        }\n        \n        int res = stack[cur] + add[cur];\n        add[cur] = 0;\n        cur--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int size = Math.min(k, cur + 1);\n        if (size > 0) {\n            add[size - 1] += val;\n        }\n    }\n}\n```\n\n### 复杂度：  \n时间：  \n1. push: O(1)  \n2. pop: O(1)  \n3. increment: O(1)   \n\n空间：O(n)  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917903881","body":"### 思路\r\n双栈，一个用来记录count，一个用来存储再次遇到 [ 之前已经构建好的字符串。\r\n1. 数字：需要把数字字符串转化为int\r\n2. 字母：直接添加到当前正在构建的字符串末尾\r\n3. [ ：把count压栈，把当前构建的字符压栈\r\n4. ] ：弹出count，以及之前构建好的字符串，把当前构建的字符串添加到之前构建好的字符串末尾count次。\r\n\r\n### 代码\r\n`\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int n = s.length();\r\n        \r\n        Stack<Integer> numStack = new Stack<>();\r\n        Stack<String> strStack = new Stack<>();\r\n        \r\n        StringBuilder builder = new StringBuilder();\r\n        int count = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            char ch = s.charAt(i);\r\n\r\n            if (Character.isDigit(ch)) {\r\n                count = count * 10 + ch - '0';\r\n            } else if (ch == '[') {\r\n                numStack.push(count);\r\n                strStack.push(builder.toString());\r\n                count = 0;\r\n                builder.setLength(0);\r\n            } else if (ch == ']') {\r\n                int num = numStack.pop();\r\n                StringBuilder temp = new StringBuilder(strStack.pop());\r\n                for (int j = 0; j < num; j++) {\r\n                    temp.append(builder);\r\n                }\r\n                builder = temp;\r\n            } else {\r\n                builder.append(ch);\r\n            }\r\n        }\r\n        return builder.toString();\r\n    }\r\n}\r\n`\r\n\r\n### 复杂度\r\n时间：O(n)  \r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918796636","body":"### 思路\n因为queue FIFO，所以pop/peek时候，stack底部的元素没有办法被访问。使用两个栈，一个负责接受push，一个栈用来pop/peek.\npop/peek的时候，如果输出栈为空，就把输入栈的元素导入到输出栈中。\n\n### 代码\n\n```java\nclass MyQueue {\n    \n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n\n### 复杂度\n时间：均摊时间复杂度 O(1)  \n空间：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919714435","body":"### 思路\n思考什么时候可以形成一个最小块。[1,2,3,4], 如果1出现在中间形成[2,3,1,4],那么[2,3,1]就构成了一个最小块。\n1. 如果当前数字比之前的块的最大值小，那么该数字一定属于前一个块 [2,3,1]\n2. 如果当前数字比之前的块的最大值大，那么该数字可以单独成块[4]。\n只考虑最大值，维护一个单调递增的栈，栈中元素为每个块的最大值，那么栈的大小，就是最终最多的块数。\n\n### 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int n : arr) {\n            if (stack.isEmpty()) {\n                stack.push(n);\n            } else {\n                if (n >= stack.peek()) {\n                    stack.push(n);\n                } else {\n                    int max = -1;\n                    while (!stack.isEmpty() && n < stack.peek()) {\n                        max = Math.max(max, stack.pop());\n                    }\n                    stack.push(max);\n                }\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n### 复杂度\n时间：O(n)  \n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920618684","body":"### 思路\n1. 因为旋转链表，尾部的节点会被挪到头节点。很容易发现其实这是一个环，如果 k > n, 其实并不需要真的向右挪动 k 次，挪动 k % n 是一样的。\n2. 因为是单链表，只能从头节点向后遍历，头指针向右移动，相当于向左rotate，和题目要求的方向刚好相反。因为是一个环，向右移动 k 个节点，等价于向左移动 n - k 个节点。\n\n### 代码\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        \n        if (head == null) return head;\n        \n        ListNode tail = head;\n        int len = 1;\n        while (tail.next != null) {\n            tail = tail.next;\n            len++;\n        }\n        tail.next = head;\n        \n        for (int i = 0; i < (len - k % len); i++) {\n            head = head.next;\n            tail = tail.next;\n        }\n\n        tail.next = null;\n        return head;\n    }\n}\n```\n### 复杂度\n时间：O(n)  \n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921529193","body":"### 思路\nDummy node 可以简化节点的插入。创建一个dummy node，然后确保后边有两个可以交换的节点。只需要交换这两个节点。之后把dummy node后移即可。  \nh -> n1 -> n2 -> n3 -----> h -> n2 -> n1 -> n3 -----> h -> n3\n\n### 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n        head = dummy;\n        \n        while (head.next != null && head.next.next != null) {\n            ListNode p1 = head.next;\n            ListNode p2 = head.next.next;\n            \n            p1.next = p2.next;\n            p2.next = p1;\n            head.next = p2;\n            \n            head = p1;\n        }\n        \n        return dummy.next;\n    }\n}\n```\n\n### 复杂度\n时间：O(n)  \n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922186977","body":"### 思路\n链表已经排好序。一个节点左边的子节点都小于该节点，已经符合二叉搜索树的定义。为了使二叉树平衡，关键是找到中点，这样左右子树节点最多相差1。\n1. 快慢指针找中点\n2. 递归构造平衡二叉搜索树\n需要注意的是，在构造左子树的时候，需要链表和根节点断开。\n\n### 代码\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode pre = null;\n        \n        while (fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        TreeNode node = new TreeNode(slow.val);\n        pre.next = null;\n        node.left = sortedListToBST(head);\n        node.right = sortedListToBST(slow.next);\n        \n        return node;\n    }\n}\n```\n\n### 复杂度\n时间：O(nlog(n))  \n空间：O(log(n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922407218","body":"### 思路\n1. 如果A和B的头节点都距离交点一样远，那么同时移动，必然相交。分别求出A,B的长度，然后在长度较长的链表上，先移动n步，n为两个链表的长度差。\n2. 看别人的题解，发现了一个更简单的思路，就是让链表形成环，如果相交，就会在交点处相遇，否则就是在为null的尾节点相遇。\n\n### 代码\nSolution - 1:\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = 1;\n        int lenB = 1;\n        \n        ListNode hA = headA;\n        ListNode hB = headB;\n        \n        while (hA != null) {\n            lenA++;\n            hA = hA.next;\n        }\n        \n        while (hB != null) {\n            lenB++;\n            hB = hB.next;\n        }\n        \n        while (lenA > lenB) {\n            headA = headA.next;\n            lenA--;\n        }\n        \n        while (lenB > lenA) {\n            headB = headB.next;\n            lenB--;\n        }\n        \n        while (headA != null && headB != null) {\n            if (headA == headB) {\n                return headA;\n            }\n            headA = headA.next;\n            headB = headB.next;\n        }\n        return null;\n    }\n```\nSolution - 2\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        \n        ListNode a = headA;\n        ListNode b = headB;\n        while (a != b) {\n            a = (a == null) ? headB : a.next;\n            b = (b == null) ? headA : b.next;\n        }\n        return a;\n    }\n```\n### 复杂度：\n时间：O(n)  \n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuliangyu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916655204","body":"'''\r\nGiven: array form number\r\nreturn: array form number + k \r\n\r\nsample: \r\nnum = [1,2,0,0], k = 34\r\n1200 + 34 = 1234\r\n[1, 2, 3, 4]\r\n\r\n1: \r\ngenerate a integer from array form\r\n[1, 2, 0, 0] => 1200\r\n''\r\n'1'\r\n'12'\r\n'120'\r\n'1200'\r\n\r\n2: k added\r\n1200 + 34 = 1234\r\n\r\n3.\r\nfn generateForm(1234) => return [1, 2, 3, 4]\r\n1234 % 10 = 4 \r\nappend to list res [4]\r\n\r\n1234 // 10 = 123\r\n123 % 10 = 3\r\n[4, 3]\r\n123 // 10 = 12\r\n...\r\n[4, 3, 2]\r\n[4, 3, 2, 1]\r\n\r\n4. \r\nreverse list !!!!\r\n[4, 3, 2, 1] => [1, 2, 3, 4]\r\n\r\ntime O(n)\r\nspace O(n)\r\n\r\n'''\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        if not num: return []\r\n        if k == 0: return num\r\n        \r\n        s = ''\r\n        for ele in num: \r\n            s = s + str(ele)\r\n        newNums = int(s) + k\r\n\r\n        res = self.generateForm(newNums)\r\n        return res[::-1]\r\n    \r\n    def generateForm(self, nums):\r\n        res = []\r\n        while nums:\r\n            digit = nums % 10\r\n            res.append(digit)\r\n            nums = nums // 10\r\n        \r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917352250","body":"'''\nGiven:\ns\nc\nans\nlen\nQuestion:\n0   1   2   3   4   5   6   7   8   9   10  11\nl   o   v   e   l   e   e   t   c   o   d   e\n3   2   1   0   1   0   0   1   2   2   1   0\n\n1 find index of e\n0, 1, 2, 3\n3, 5, 6, 11\n\n0: abs(0 - 3)\n1\n2\n3\n4 min(abs(4-3), abs(4-5))\n\nbisect(7 in [3, 5, 6, 11]), get the index of 3\nneed to comapre index of 2 and 3\n\n7 min(abs(7-6), abs(7 - 11))\n\n0 1 2 3\na a b a\n[2]\n[2, 1, 0, 1]\n\ntime O(nlogn)\n\n'''\n\nfrom collections import deque\nfrom typing import List\nfrom collections import OrderedDict\nfrom collections import defaultdict\nimport functools\nimport heapq\nimport bisect\n\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        if not s: return []\n        if len(s) == 0: return []\n\n        indexOfTarget = []\n        ans = [0] * len(s)\n\n        for i, ele in enumerate(s): \n            if ele == c:\n                indexOfTarget.append(i)\n        \n        for i, ele in enumerate(s):\n            if ele != c:\n                # 二分法找到index\n                index = bisect.bisect(indexOfTarget, i)\n                if 0 < index < len(indexOfTarget): \n                    ans[i] = min(abs(i - indexOfTarget[index]), abs(i - indexOfTarget[index - 1]))\n                elif index == 0:\n                    ans[i] = abs(i - indexOfTarget[index])\n                    # print(\"---------------------\")\n\n                elif index == len(indexOfTarget):\n                    # print(\"---------------------\")\n                    # print(i)\n                    # print(indexOfTarget[index - 1] )\n                    print(i - indexOfTarget[index - 1])\n\n                    ans[i] = abs(i - indexOfTarget[index - 1])\n                    \n        \n        return ans\n\n\n\n\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917551635","body":"from collections import deque\nfrom typing import List\nfrom collections import OrderedDict\nfrom collections import defaultdict\nimport functools\nimport heapq\nimport bisect\n\nclass CustomStack:\n    '''\n    maxSize = 3\n    1, 2, 3\n    4, not push\n    '''\n\n    def __init__(self, maxSize: int):\n        self.cap = maxSize\n        self.q = deque()\n\n    def push(self, x: int) -> None:\n        if len(self.q) < self.cap:\n            self.q.append(x)\n\n    def pop(self) -> int:\n        if self.q:\n            return self.q.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        '''\n        k = 4\n         i0    i1      i2\n        [1,     2,      3]\n        '''\n\n        for i in range(len(self.q)):\n            if i < k:\n                cur = self.q[i]\n                self.q[i] = cur + val\n\n\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917976254","body":"\n# @solution-sync:begin\n'''\n3[a2[c]]\nst\nst = 3 [ a 2 [ c\n]\nc\n2\nst = 3 [ a c c\nc c a\nreverse!\n3 * (a c c)\n\nacc acc acc\n\n\nwhile not [\n    push all char into stack\n\nmeet ]\npop all letters -> save to tmpStr\npop [\npop all digits -> save to tmpNum\nreverse(tmpStr)\ntmpNum * tmpStr -> push into stack\n\n3[a]2[bc]\nst = 3 [ a\na\n3\nst = aaa2[bc\ncb\n2\ncbcb\nreverse-> bcbc\naaa + bcbc\n\n'''\nfrom collections import deque\nfrom typing import List\nfrom collections import OrderedDict\nfrom collections import defaultdict\nimport functools\nimport heapq\nimport bisect\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        if not s: return \"\"\n\n        st = deque()\n\n        i = 0\n        while i < len(s):\n\n            # 不能在两个地方 同时对i + 1\n            if s[i] != ']':\n                st.append(s[i])\n            else: # == ]\n                tmpStr = \"\"\n                # error\n                while st and st[-1].isalpha():\n                    # print(poped)\n                    tmpStr = st.pop() + tmpStr\n\n                # get rid of [\n                if st:\n                    st.pop()\n\n                tmpNum = ''\n                while st and (st[-1].isdigit()):\n                    tmpNum = st.pop() + tmpNum\n                tmpNum = int(tmpNum)\n\n                tmpStr = tmpStr * tmpNum\n\n                for ele in tmpStr:\n                    st.append(ele)\n\n            # error\n            i += 1\n\n        return \"\".join(st)\n\n\n# @solution-sync:end\n\n\nif __name__ == '__main__':\n    s = \"100[leetcode]\"\n\n    result = Solution().decodeString(s)\n    print(result)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918956176","body":"from collections import deque\nfrom typing import List\nfrom collections import OrderedDict\nfrom collections import defaultdict\nimport functools\nimport heapq\nimport bisect\n\nclass MyQueue:\n    '''\n    q push\n    1, 2, 3, <- (4)\n\n    q pop\n    st1 = <- (1), 2, 3, 4\n    st2 = 4, 3, 2, 1\n    st2 pop 1\n    st1 = 2, 3, 4\n\n    '''\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = deque()\n        self.stackTmp = deque()\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        while self.stack:\n            self.stackTmp.append(self.stack.pop())\n\n        res = self.stackTmp.pop()\n\n        while self.stackTmp:\n            self.stack.append(self.stackTmp.pop())\n\n        return res\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack[0]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.stack) == 0\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919857597","body":"\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921564945","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head: return None\n        dummy = ListNode(0)\n        dummy.next = head\n\n        pre = dummy\n        begin = head\n        if head:\n            end = head.next\n        if end:\n            termintion = end.next \n\n        while end:\n            pre = self.swap(pre, begin, end, termintion)\n            if pre:\n                begin = pre.next\n            if begin:\n                end = begin.next\n            if end:\n                termintion = end.next\n\n            for _ in range(2):\n                if pre:\n                    pre = pre.next\n                if begin:\n                    begin = begin.next\n                if end:\n                    end = end.next\n                if termintion:\n                    termintion = termintion.next\n        \n        return dummy.next\n        \n\n\n\n\n    \n    def swap(self, pre, begin, end, termintion):\n        end.next = begin\n        pre.next = end\n        begin.next = termintion\n\n        return pre","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kirito1017":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916655676","body":"## 思路 \n###### 从最后一位 一位一位往上相加 并考虑是否有carry 如果长短不一样也没关系 判断一下就行。如果while loop结束后考虑下是否要最后append一个carry \n###### 每次都insert到第一个元素\n\n## 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] nums, int k) {\n        List<Integer> res = new ArrayList<>();\n        int i = nums.length - 1;\n        int carry = 0;\n        while (i >= 0 || k > 0) {\n            int two = k > 0 ? k % 10 : 0;\n            int one = i >= 0 ? nums[i] : 0;\n            int total = two + one + carry;\n            \n            carry = total / 10;\n            res.add(0, total % 10);\n            \n            i--;\n            k = k / 10;\n        }\n        \n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```\n## 复杂度\n###### 时间复杂度O(n), 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917348006","body":"## 将c的index存到treeset里面 然后iterate每个元素找左右最近的\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        \n        TreeSet<Integer> set = new TreeSet<>();\n        \n        char[] chars = s.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c) {\n                set.add(i);\n            }\n        }\n        \n        int[] res = new int[s.length()];\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c) {\n                res[i] = 0;\n            }\n            else {\n                Integer floor = set.floor(i);\n                Integer ceil = set.ceiling(i);\n                if (floor != null && ceil != null) {\n                    res[i] = Math.min(Math.abs(floor - i), Math.abs(ceil - i));\n                }\n                else if (floor!= null) {\n                    res[i] = Math.abs(floor - i);\n                }\n                else if (ceil != null) {\n                    res[i] = Math.abs(ceil - i);\n                }\n            }\n        }\n        \n        return res;\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921026692","body":"```Java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head==null || head.next==null || k==0) return head;\r\n        Stack<ListNode> stack=new Stack<>();\r\n        ListNode temp=head;\r\n        while(temp!=null){\r\n            stack.push(temp);\r\n            temp=temp.next;\r\n        }\r\n         if(k > stack.size()){\r\n            k = k % stack.size();\r\n        }else if(k == stack.size()){\r\n            k = 0;\r\n        }else{\r\n            k=k;\r\n        }\r\n        ListNode t=null;\r\n        while(stack.size()>0 && k>0){\r\n            \r\n             t=stack.pop();\r\n            t.next=head;\r\n            head=t;\r\n            k--;\r\n            \r\n        }\r\n       if(stack.size()!=0) {\r\n           stack.pop().next=null;\r\n       }\r\n        return head;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"FullStackH":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916657808","body":"# 思路\n逐位相加，carry保存进位\n\n# 代码\n\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    int len = num.length;\n    int count = 0;\n    int flag = 0;\n    List<Integer> ans = new ArrayList<>();\n    while (k > 0) {\n        int tmpNum = len - count - 1 < 0 ? 0: num[len - count - 1];\n        int sum = k % 10 + tmpNum + flag;\n        flag = sum / 10;\n        k /= 10;\n        count++;\n        ans.add(flag == 1 ? sum % 10 : sum);\n    }\n    for(int i = len - count - 1; i > -1; i--) {\n        int sum = num[i] + flag;\n        flag = sum / 10;\n        ans.add(flag == 1 ? sum % 10 : sum);\n    }\n    if (flag == 1) {\n        ans.add(1);\n    }\n    Collections.reverse(ans);\n    return ans;\n}\n\n# 复杂度\n时间复杂度O(n)\n空间复杂度O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429431","body":"JAVA:\n\n`class Solution {\n    public int[] shortestToChar(String s, char c) {\n        List<Integer> list = new ArrayList();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i) == c){\n                list.add(i);\n            }\n        }\n        int res[] = new int[s.length()];\n        \n        for(int i=0;i<s.length();i++){\n            int min=Integer.MAX_VALUE;\n            for(int j=0;j<list.size();j++){\n                int abs = Math.abs(i-list.get(j));\n                min = Math.min(abs,min);\n            }\n            res[i] = min;\n        }\n        return res;\n\n    }\n}`\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661081","body":"JAVA:\n`int[] data;\n    int head;\n\n    public CustomStack(int maxSize) {\n\n        data = new int[maxSize];\n        head = -1;\n    }\n    \n    public void push(int x) {\n\n        if (head == data.length - 1)\n            return;\n            \n        data[++head] = x;\n    }\n    \n    public int pop() {\n\n        if (head == -1)\n            return -1;\n\n        return data[head--];\n    }\n    \n    public void increment(int k, int val) {\n\n        for (int i = 0; i < Math.min(k, head + 1); i++)\n            data[i] += val;`\n时间复杂度：O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919288250","body":"JAVA：\nclass MyQueue {\n    private Stack<Integer> a;\n    private Stack<Integer> b;    \n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n    \n    public void push(int x) {\n        a.push(x);\n    }\n    \n    public int pop() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n    \n    public int peek() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n    \n    public boolean empty() {\n        return a.isEmpty() && b.isEmpty();\n    }\n}\n\n时间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920070448","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n- [ ]         stack<int> block;\n- [ ]         block.push(arr[0]);\n        int max = arr[0];\n        for(int i=1; i<arr.size(); ++i){\n            if(arr[i] >= block.top()){ \n                block.push(arr[i]);\n            }else { \n                max = block.top(); \n                block.pop();\n                while(!block.empty()){\n                    if(arr[i] >= block.top()){\n                        block.push(max);\n                        break;\n                    }\n                    block.pop();\n                }\n                if(block.empty()){ \n                    block.push(max);\n                }\n            }\n        }\n        return block.size(); \n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921029845","body":"public ListNode rotateRight(ListNode head, int k) {\n\tif (head == null || head.next == null || k == 0) return head;\n    \n    int count = 1; // 用来统计链表总结点数\n    ListNode tmp = head;\n    while (tmp.next != null) {\n        count++;\n        tmp = tmp.next;\n    }\n    k %= count;\n    // 当k为0时，不需要旋转，\n    if (k == 0) return head;\n    \n    // 不满足上述条件，必将进行旋转，所以先将首尾相连\n    tmp.next = head;\n    // 现在只需要找到倒数第k+1个节点\n    for (int i = 0; i < count - k; i++) {\n        tmp = tmp.next;\n    }\n    ListNode newHead = tmp.next;\n    tmp.next = null;\n    return newHead; \n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chun1hao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916659493","body":"```js\nvar addToArrayForm = function (num, k) {\n  let idx = num.length - 1;\n  let c = 0;\n  while (c || k) {\n    let curK = k % 10;\n    let curNum = idx >= 0 ? num[idx] : 0;\n    let sum = c + curK + curNum;\n    c = Math.floor(sum / 10);\n    sum %= 10;\n    if (idx >= 0) {\n      num[idx--] = sum;\n    } else {\n      num.unshift(sum);\n    }\n    k = Math.floor(k / 10);\n  }\n  return num;\n};\n```\n\n时间：O(N)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917424498","body":"```js\r\nvar shortestToChar = function(s, c) {\r\n    let ans = []\r\n    let prev = -Infinity\r\n    for(let i=0;i<s.length;i++){\r\n        if(s[i] === c) prev = i\r\n        ans[i] = i - prev\r\n    }\r\n    prev = Infinity \r\n    for(let i= s.length-1;i>=0;i--){\r\n        if(s[i] === c) prev = i\r\n        ans[i] = Math.min(prev - i, ans[i])\r\n    }\r\n    return ans\r\n};\r\n```\r\n空间 O(N)\r\n时间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917638057","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack = []\n    this.addVal = new Array(maxSize).fill(0)\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length < this.maxSize){\n        this.stack.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length){\n        let idx = this.stack.length - 1\n        let num = this.addVal[idx]\n        this.addVal[idx] = 0   \n        this.addVal[idx-1] += num      \n        return this.stack.pop() + num\n    }else{\n        return -1\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let idx = Math.min(k-1, this.stack.length-1)\n    this.addVal[idx] += val\n};\n```\n时间：O(1)  \n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917809489","body":"```js\nvar decodeString = function (s) {\n  let strStack = [];\n  let numStrack = [];\n  let tempNum = 0;\n  for (let i of s) {\n    if (!isNaN(i)) {\n      tempNum = tempNum * 10 + +i;\n    } else if (i === \"]\") {\n      let str = \"\";\n      let cur = strStack.pop();\n      let repeat = numStrack.pop();\n      while (cur && cur !== \"[\") {\n        str = cur + str;\n        cur = strStack.pop();\n      }\n      str = str.repeat(repeat);\n      strStack.push(str);\n    } else {\n      strStack.push(i);\n      if (tempNum) {\n        numStrack.push(tempNum);\n        tempNum = 0;\n      }\n    }\n  }\n  return strStack.join(\"\");\n};\n```\n时间 O(n)\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919205450","body":"```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.inStack = []\r\n    this.outStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.inStack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(this.outStack.length){\r\n        return this.outStack.pop()\r\n    }\r\n    while(this.inStack.length){\r\n        this.outStack.push(this.inStack.pop())\r\n    }\r\n    return this.outStack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(this.outStack.length){\r\n        return this.outStack[this.outStack.length - 1]\r\n    }\r\n    while(this.inStack.length){\r\n        this.outStack.push(this.inStack.pop())\r\n    }\r\n    return this.outStack[this.outStack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.inStack.length && !this.outStack.length\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920057646","body":"```js\nvar maxChunksToSorted = function(arr) {\n    let ans = 0\n    let arr1 = [...arr].sort((a, b)=> a-b)\n    let sum = 0\n    let sum1 = 0\n    for(let i=0;i<arr.length;i++){\n        sum += arr[i]\n        sum1 += arr1[i]\n        if(sum === sum1){\n            ans++\n        }\n    }\n    return ans\n};\n```\n时间： O(NlogN)\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920536159","body":"先形成环，新的头节点就是n-k处，然后断开\n```js\nvar rotateRight = function (head, k) {\n  if (!head) return head;\n  let len = 1;\n  let dummy = head;\n  while (dummy.next) {\n    len++;\n    dummy = dummy.next;\n  }\n  k %= len;\n  dummy.next = head;\n  for (let i = 1; i < len - k; i++) {\n    head = head.next;\n  }\n  let newHead = head.next;\n  head.next = null;\n  return newHead;\n};\n```\n时间：O(N)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921405503","body":"```js\nvar swapPairs = function (head) {\n  let dummy = new ListNode(0);\n  let pre = dummy;\n  dummy.next = head;\n  while (head && head.next) {\n    let next = head.next.next;\n    pre.next = head.next;\n    head.next.next = head;\n    head.next = next;\n    pre = head;\n    head = head.next;\n  }\n  return dummy.next;\n};\n```\n时间：O(N)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922166359","body":"```js\n\nvar sortedListToBST = function(head) { \n    if(!head) return null\n    let slow = head\n    let fast = head\n    let pre = null\n    while(fast && fast.next){\n        pre = slow\n        slow = slow.next\n        fast = fast.next.next\n    }    \n    let root = new TreeNode(slow.val)\n    if(pre){\n        pre.next = null\n        root.left = sortedListToBST(head)\n    }    \n    root.right = sortedListToBST(slow.next)\n    return root\n};\n```\n时间： O(NlogN)\n空间： O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922410212","body":"```\nvar getIntersectionNode = function(headA, headB) {\n    let dummyA = headA\n    let dummyB = headB\n    while(dummyA !== dummyB){\n        dummyA = dummyA ? dummyA.next : headB\n        dummyB = dummyB ? dummyB.next : headA\n    }\n    return dummyB\n};\n```\n时间：O(N)\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"m-z-w":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916661368","body":"```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let newArr = []\r\n    let numK = String(k).split('')\r\n    let maxLen = Math.max(num.length, numK.length)\r\n    let flag = 0\r\n    let cur = 0\r\n    while (cur < maxLen) {\r\n        console.log(cur)\r\n        if (num[cur] === undefined) {\r\n            num.unshift(0)\r\n        }\r\n        if (numK[cur] === undefined) {\r\n            numK.unshift(0)\r\n        } else {\r\n            numK[cur] = Number(numK[cur])\r\n        }\r\n        cur++\r\n    }\r\n    for (let i = maxLen - 1; i >= 0; i--) {\r\n         let n = num[i] + numK[i] + flag\r\n        flag = n >= 10 ? 1 : 0\r\n        n = n >= 10 ? n - 10 : n\r\n        newArr.unshift(n)\r\n    }\r\n    if (flag === 1) {\r\n        newArr.unshift(1)\r\n    }\r\n    return newArr\r\n};\r\n```\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917361821","body":"```javascript\nvar shortestToChar = function(s, c) {\n    const res = new Array(s.length)\n    let recentIndex = -s.length\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            res[i] = 0\n            recentIndex = i\n        } else {\n            res[i] = Math.abs(i - recentIndex)\n        }\n    }\n    for (let i = s.length - 1; i >= 0; i--) {\n        if (s[i] === c) {\n            res[i] = 0\n            recentIndex = i\n        } else {\n            const num = Math.abs(i - recentIndex)\n            res[i] = num > res[i] ? res[i] : num\n        }\n    }\n    return res\n};\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917628053","body":"```javascript\nvar CustomStack = function(maxSize) {\n    this.stack = []\n    this.length = maxSize\n    this.top = new Array(maxSize)\n    for (let i = 0; i < maxSize; i++) {\n        this.top[i] = 0\n    }\n};\n\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.length) {\n        this.stack.push(x)\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if (this.stack.length === 0) {\n        return -1\n    } else {\n        let maxIndex = this.stack.length - 1\n        let num = this.stack.pop()\n        const inc = this.top[maxIndex]\n        this.top[maxIndex - 1] += inc\n        this.top[maxIndex] = 0\n        return num + inc        \n    }\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    const min = Math.min(this.stack.length - 1, k - 1)\n    this.top[min] += val\n};\n```\n\n时间复杂度：push、pop、increment均为O(1)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917973690","body":"```javascript\nvar decodeString = function(s) {\n    const stack = []\n    let res = ''\n    let brackets = 0\n    let repeatStr = ''\n    let numStr = ''\n    for (let i = 0; i < s.length; i++) {\n        if (!isNaN(Number(s[i]))) {\n            numStr += s[i]\n            continue\n        } else if (numStr) {\n            stack.push(Number(numStr))\n            numStr = ''\n        }\n        if (s[i] !== ']') {\n            stack.push(s[i])\n        }\n        if (s[i] === '[') {\n            brackets++\n        } else if (s[i] === ']') {\n            brackets--\n            let str = ''\n            let a = stack.pop()\n            while (a !== '[') {\n                str = a + str\n                a = stack.pop()\n            }\n            a = stack.pop()\n            for (let i = 0; i < a; i++) {\n                repeatStr += str\n            }\n            if (brackets === 0) {\n                res += repeatStr\n            } else {\n                stack.push(repeatStr)\n            }\n            repeatStr = ''\n        } else if (isNaN(Number(s[i])) && brackets === 0) {\n            res += s[i]\n            stack.pop()\n        }\n    }\n    return res\n};\n```\n时间复杂度：O(n), n为s的长度\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920692761","body":"```javascript\nvar rotateRight = function(head, k) {\n    if (head === null || k === 0 || head.next === null) {\n        return head\n    }\n    let fast = head\n    let index = 0\n    let slow = head\n    while (index < k) {\n        index++\n        fast = fast.next\n        if (fast === null) {\n            fast = head\n        }\n    }\n    while (fast && fast.next) {\n        fast = fast.next\n        slow = slow.next\n    }\n    let newHead = slow.next\n    if (newHead === null) {\n        newHead = head\n    } else {\n        let tmp = slow.next\n        slow.next = null\n        while (tmp && tmp.next) {\n            tmp = tmp.next\n        }\n        tmp.next = head\n    }\n    return newHead\n};\n```\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921686877","body":"```javascript\nvar swapPairs = function(head) {\n    const dummyHead = new ListNode(0)\n    dummyHead.next = head\n    let temp = dummyHead\n    while (temp.next !== null && temp.next.next !== null) {\n        let node1 = temp.next\n        let node2 = temp.next.next\n        temp.next = node2\n        node1.next = node2.next\n        node2.next = node1\n        temp = node1\n    }\n    return dummyHead.next\n};\n```\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922250232","body":"```javascript\nvar sortedListToBST = function(head) {\n    const array = []\n    while (head) {\n        array.push(head.val)\n        head = head.next\n    }\n    const buildTree = (array, left, right) => {\n        if (left > right) return null\n        const mid = Math.floor(left + (right - left) / 2)\n        const root = new TreeNode(array[mid])\n        root.left = buildTree(array, left, mid - 1)\n        root.right = buildTree(array, mid + 1, right)\n        return root\n    }\n    return buildTree(array, 0, array.length - 1)\n};\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922427116","body":"```javascript\nvar getIntersectionNode = function(headA, headB) {\n    let nodeA = headA\n    let nodeB = headB\n    while (nodeA !== nodeB) {\n        nodeA = nodeA.next\n        nodeB = nodeB.next\n        if (nodeA === null && nodeB === null) {\n            return null\n        }\n        if (nodeA === null) {\n            nodeA = headB\n        }\n        if (nodeB === null) {\n            nodeB = headA\n        }\n    }\n    return nodeA\n};\n```\n时间复杂度：O(n) n为headA的长度加上headB从头结点到相交点的距离，如果没有相交点，则为headA加上headB的长度\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"KennethAlgol":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916664966","body":"思路: 将整个加数 k加入数组表示的数的最低位\n\n    class Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<Integer>();\n            int n = num.length;\n            for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n                if (i >= 0) {\n                    k += num[i];\n                }\n                res.add(k % 10);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n\n复杂度分析\n\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917927140","body":"思路: 使用栈,压入栈的思想\n代码: Java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919134832","body":"\n\n## 思路\n\n双栈\n\n将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\n\n每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\n\n## 语言\n\njava\n\n## 代码\n\n```java\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack1=new Stack<>();\n        stack2=new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(stack2.isEmpty()){\n            outStack1ToStack2();\n        }\n        return stack2.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(stack2.isEmpty()){\n            outStack1ToStack2();\n        }\n        return stack2.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack2.isEmpty()&&stack1.isEmpty();\n    }\n\n    public void outStack1ToStack2(){\n            while(!stack1.isEmpty()){\n                stack2.push(stack1.pop());\n            }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919965310","body":"## 思路\n\n排序块定义：\n\n排序块 充分条件： 设此块中最大数字为head , 若此块后面的所有数字都 >=head ，则此块为排序块。\n排序块 最短长度为 11，即单个元素可以独立看作一个排序块。\n\n**贪心法则** （划分出尽可能多的排序块）\n\n## 语言\n\njava\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920848948","body":"## 思路\n\n链表每个元素向右移两位\n\n## 语言\n\njava\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        int len = 1, index;\n        ListNode temp = head, newHead;\n        while (temp.next != null) { //计算链表长度len\n            len++;\n            temp = temp.next;\n        }\n        temp.next = head; //将链表连接成循环链表\n        k %= len; //旋转链表每len次循环一次，因此计算k对len的取余，避免重复操作\n        index = len - k; //找到要断开循环链表的节点纪录链表新的头结点\n        while (index-- > 0) {\n            temp = temp.next;\n        }\n        newHead = temp.next;\n        temp.next = null; //断开循环链表\n        return newHead;\n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921760708","body":"## 语言\n\njava\n\n## 递归解法\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922240927","body":"## 思路:\r\n\r\n单链表，链表找中间节点可以用快慢指针法\r\n\r\n## 语言\r\n\r\njava\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n\r\n        if (head.next == null) {\r\n            return new TreeNode(head.val);\r\n        }\r\n\r\n        // 快慢指针找中心节点\r\n        ListNode x = head, y = head, pre = null;\r\n        while (y != null && y.next != null) {\r\n            pre = x;\r\n            x = x.next;\r\n            y = y.next.next;\r\n        }\r\n        pre.next = null;\r\n       \r\n        // 以升序链表的中间元素作为根节点 root，递归的构建 root 的左子树与右子树。\r\n        TreeNode root = new TreeNode(x.val);\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(x.next);\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922485736","body":"## 语言\r\n\r\nJava\r\n\r\n```java\r\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n    if (headA == null || headB == null) return null;\r\n    ListNode pA = headA, pB = headB;\r\n    while (pA != pB) {\r\n        pA = pA == null ? headB : pA.next;\r\n        pB = pB == null ? headA : pB.next;\r\n    }\r\n    return pA;\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922498177","body":"## 思路\r\n\r\n双指针法,快慢指针\r\n\r\n## 语言\r\n\r\njava\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head, slow = head;\r\n        while (true) {\r\n            if (fast == null || fast.next == null) return null;\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if (fast == slow) break;\r\n        }\r\n        fast = head;\r\n        while (slow != fast) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Richard-LYF":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916665554","body":"def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n=0\n        for i in range(len(num)):\n            n=n*10+num[i]\n        n=str(n+k)\n        out=[]\n        for i in n:\n            out.append(int(i))\n        return out\n\n分享一个自己的思路，代码比较短，容易理解，但是好像用时和内存消耗没有很优秀\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917338500","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        a=[]\n        p=[]\n        for i in range(len(s)):\n            if s[i]==c:\n                p.append(i)\n        for i in range(len(s)):\n            k=[]\n            for j in p:\n                k.append(abs(j-i))\n            a.append(min(k))\n        return a\n        \n        #time complx   O(n)\n        #space complx  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917554160","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.space=[]\n        self.n=maxSize\n    def push(self, x: int) -> None:\n        if len(self.space)<self.n:\n            self.space.append(x)\n\n    def pop(self) -> int:\n        if self.space:\n            return self.space.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if k>=len(self.space):\n            for i in range(len(self.space)):\n                self.space[i]+=val\n        else:\n            for i in range(k):\n                self.space[i]+=val\n\n# time o(n)\n# space o(n)\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918244000","body":"class Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919178315","body":"class MyQueue(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.a=[]\n        self.b=[]\n\n\n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.a.append(x)\n\n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        while self.b:\n            return self.b.pop()\n        if not self.a:\n            return []\n        while self.a:\n            self.b.append(self.a.pop())\n        return self.b.pop()\n\n    def peek(self):\n        \"\"\"\n        Get the front element.\n        :rtype: int\n        \"\"\"\n        if self.b:\n            return self.b[-1]\n        if self.a:\n            return self.a[0]\n        return []\n\n\n\n\n    def empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        if not self.a:\n            if not self.b:\n                return True\n        return False \n\no(n),o(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920133737","body":"class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count=0\n        for i in range(len(arr)-1):\n            if max(arr[:i+1])<=min(arr[i+1:]):\n                count+=1\n        return count+1\n\n  0 n2\n  0 1     ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920624253","body":"# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n\n        l=0\n        ct=head\n        if ct.val!=None:\n            while ct.next!=None:\n                l+=1\n                ct=ct.next\n\n        l=l+1\n        k=k%l\n        for i in range(k):\n            current=head\n            kd=current\n            while current.next:\n                kd=current\n                current=current.next\n            current.next=head\n            kd.next=None\n            head=current\n        return head\n\n#0 n 0 1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921895715","body":"# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922331793","body":"class Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922489438","body":"public class Solution {\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\nif(headA == null || headB == null){\nreturn null;\n}\nListNode a = headA, b = headB;\nwhile(a != b){\na = a == null? headB: a.next;\nb = b == null? headA: b.next;\n}\nreturn a;\n}\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinmenghan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916667562","body":"\n## 题目地址()\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n\n## 题目描述\n\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<Integer>();\n        for (int i = num.length - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            list.add(k % 10);\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917395499","body":"\n## 题目地址()\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n```\n\n## 前置知识\n\n- 数组\n\n## 思路\n先记录字符c出现的位置，\n\n再记录遍历字符，根据记录的位置求最小值\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] ans = new int[N];\n\n        List<Integer> indexArr= new ArrayList<>();\n        // 记录 c的位置\n        for (int i = 0; i < N; i++) {\n            if (s.charAt(i) == c) {\n                indexArr.add(i);\n            }\n        }\n\n        // 遍历每个字符，取最小路径\n        for (int i = 0; i < N; i++) {\n            int temp = Integer.MAX_VALUE;\n           for(int j = 0; j < indexArr.size(); j++){\n               temp = Math.min(temp, Math.abs(i - indexArr.get(j)));\n           }\n           ans[i] = temp;\n        }\n        return ans;\n    }\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2 + n)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917531455","body":"\n## 题目地址()\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1); // 栈变为 [1]\ncustomStack.push(2); // 栈变为 [1, 2]\ncustomStack.pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2); // 栈变为 [1, 2]\ncustomStack.push(3); // 栈变为 [1, 2, 3]\ncustomStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100); // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100); // 栈变为 [201, 202, 103]\ncustomStack.pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop(); // 返回 -1 --> 栈为空，返回 -1\n\n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 前置知识\n\n- 数组\n- 前缀和\n\n## 公司\n\n- 暂无\n\n## 思路\n用数组和指针用来表示栈\n\ntop 来记录栈顶的位置\n\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\nclass CustomStack {\n\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n\n\n\n```\n\n\n**复杂度分析**\n\n令 maxSize 为数组长度。\n\n- 时间复杂度：$O(maxSize)$\n- 空间复杂度：$O(maxSize)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917863938","body":"\n## 题目地址()\n\n [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n## 题目描述\n\n```\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n \n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n示例 3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n示例 4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n```\n\n## 前置知识\n\n- 数组\n\n\n\n## 思路\n\n- 遍历数组，找出最里面的两个 [ ] \n-  取出[ 左侧的数字count，组装count遍字符串后\n-  替换掉之前的计算的字符串+数字\n \n\n\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\n  public static String decodeString(String s) {\n        StringBuilder sb = new StringBuilder(s);\n        while (sb.indexOf(\"[\") != -1) {\n            int leftIndex = sb.lastIndexOf(\"[\");\n            int rightIndex = sb.indexOf(\"]\", leftIndex);\n            String str = sb.substring(leftIndex + 1, rightIndex);\n            int i = leftIndex - 1, count = 0, base = 1;\n            while (i >= 0 && Character.isDigit(sb.charAt(i))) {\n                count += base * (sb.charAt(i) - '0');\n                base *= 10;\n                i--;\n            }\n            StringBuilder tmp = new StringBuilder();\n            for (int j = 0; j < count; j++) tmp.append(str);\n            sb = sb.replace(i + 1, rightIndex + 1, tmp.toString());\n        }\n        return sb.toString();\n    }\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918822839","body":"\n## 题目地址()\n\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/submissions/\n\n\n## 题目描述\n\n```\n使用栈实现队列的下列操作：\n\npush(x) -- 将一个元素放入队列的尾部。\npop() -- 从队列首部移除元素。\npeek() -- 返回队列首部的元素。\nempty() -- 返回队列是否为空。\n示例:\n\nMyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);\nqueue.peek(); // 返回 1\nqueue.pop(); // 返回 1\nqueue.empty(); // 返回 false\n说明:\n\n你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n假设所有操作都是有效的、 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\n```\n\n## 前置知识\n\n- 数组\n- 栈\n\n\n\n## 思路\n\n使用2个栈，一个栈是入队列，另一个栈是出队列，\n\n\n## 关键点\n\n- 转换，把入队的栈全部倒入出队的栈  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\nclass MyQueue {\n        Stack<Integer> in = new Stack();\n        Stack<Integer> out = new Stack();\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        \n\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        in.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        transfer();\n        return out.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        transfer();\n        return out.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n       \n        return in.empty() && out.empty();\n    }\n\n    public void transfer(){\n       if(!out.empty()){\n                return;\n        }\n\n        while(in.size() > 0){\n            out.push(in.pop());\n        }\n\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919718800","body":"\n## 题目地址\n\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/submissions/\n\n## 题目描述\n\n```\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\n\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n示例 1:\n\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\n示例 2:\n\n输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\n注意:\n\narr的长度在[1, 2000]之间。\narr[i]的大小在[0, 10**8]之间。\n```\n\n## 前置知识\n\n- 栈\n- 单调栈\n- 队列\n\n## 思路\n\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n\n        Stack<Integer> stack = new Stack<>();\n        for(int num : arr){\n            if(!stack.empty() && num < stack.peek()){\n                int head = stack.pop();\n                while(!stack.empty() && num < stack.peek()){\n                    stack.pop();\n                }\n                stack.push(head);\n            }else{\n                stack.push(num);\n            }\n        }\n        return stack.size();\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920566834","body":"\n## 题目地址()\n\n61. 旋转链表\n\n[https://leetcode-cn.com/problems/rotate-list/submissions/](https://leetcode-cn.com/problems/rotate-list/submissions/)\n\n## 题目描述\n\n```\n给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。\n\n示例 1:\n\n输入: 1->2->3->4->5->NULL, k = 2\n输出: 4->5->1->2->3->NULL\n解释:\n向右旋转 1 步: 5->1->2->3->4->NULL\n向右旋转 2 步: 4->5->1->2->3->NULL\n示例 2:\n\n输入: 0->1->2->NULL, k = 4\n输出: 2->0->1->NULL\n解释:\n向右旋转 1 步: 2->0->1->NULL\n向右旋转 2 步: 1->2->0->NULL\n向右旋转 3 步: 0->1->2->NULL\n向右旋转 4 步: 2->0->1->NULL\n```\n\n## 前置知识\n\n- 链表\n\n\n\n## 思路\n\n1、求链表长度\n2、判断右移后的步数和长度是否相等\n2.1、相等就代表没有发生变化，直接返回\n2.2、组成环形，根据剩余步数拿到当前指针所在的node，断开node的下一个节点\n3、返回\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n\n        // 如果head = null\n        if(k == 0 || head == null || head.next == null){\n            return head;\n        }\n\n        // 链表长度\n        int len = 1;\n        ListNode temp = head;\n        while(temp.next != null){\n            temp = temp.next;\n            len++;\n        }\n\n        \n        int steps = len - k % len;\n        // 如果相等，位置没有发生变化\n        if(steps == len ){\n            return head;\n        }\n\n        // 组成环形\n        temp.next = head;\n        while(steps > 0){\n            temp = temp.next;\n            steps--;\n        }\n\n        ListNode returnNode = temp.next;\n        temp.next = null;\n        return returnNode;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921456346","body":"\n## 题目地址(24. 两两交换链表中的节点)\n\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n## 题目描述\n\n```\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n \n\n示例 1：\n```\n\n![image](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n\n```\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n示例 2：\n\n输入：head = []\n输出：[]\n示例 3：\n\n输入：head = [1]\n输出：[1]\n \n\n提示：\n\n链表中节点的数目在范围 [0, 100] 内\n0 <= Node.val <= 100\n```\n\n## 前置知识\n\n- 链表\n\n## 公司\n\n- 暂无\n\n## 思路\n \n增加空head节点，\nhead.next 和head next.next交换\n前进2个节点\n返回时，把空head抛弃\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // 增加一个头节点\n        ListNode preHead = new ListNode();\n        preHead.next = head;\n\n        // 当前指针\n        ListNode currentNode = preHead;\n\n        while(currentNode != null && currentNode.next != null && currentNode.next.next != null){\n            ListNode f = currentNode;\n            ListNode s = currentNode.next;\n            ListNode t = s.next;\n\n            // 两两交换链表节点\n            f.next = t;\n            s.next = t.next;\n            t.next = s;\n\n            // 当前指针后移两位\n            currentNode = currentNode.next.next;\n        }\n\n        return preHead.next;\n\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922258182","body":"\n## 题目地址\n\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree\n\n## 题目描述\n\n```\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n示例:\n\n给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n```\n\n## 前置知识\n\n- 递归\n- 链表\n- 二叉树\n\n\n## 思路\n\n分治法采用的是快慢指针去找中间节点，然后递归构造树。时间复杂度O(nlogn)\n采用分治+中序遍历递归的建树\n\n由于给出的链表是有序的，而一棵排序二叉树的中序遍历正好是一个有序的列表，所以可以利用中序遍历进行树的构建。\n首先节点的范围我们确定为[left, right]\n中序遍历的格式：\ninorder(root.left)\nroot\ninorder(root.right)\n\n所以这里我们先构建左子树root.left\n然后头一个节点显然是最左节点 root.val\n最后递归构建右子树root.right\n\n需要设置一个全局变量globalHead,这让我们可以从前到后访问链表。\n\n时间复杂度O(n), 因为是不断的二分，所以空间复杂度位logn， 等于树的高度。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n       ListNode globalHead;\n    public TreeNode sortedListToBST(ListNode head) {\n\n        globalHead = head;\n        int len = getLenth(head);\n        return buildTree(0, len - 1);\n\n    }\n\n    public int getLenth(ListNode head){\n        int len = 0;\n        while(head != null){\n            len++;\n            head = head.next;\n        }\n        return len;\n    }\n    public TreeNode buildTree(int left, int right){\n        if(left > right) return null;\n        int mid = (left + right) / 2;\n        TreeNode root = new TreeNode();\n        root.left = buildTree(left, mid - 1);\n        root.val = globalHead.val;\n        globalHead = globalHead.next;\n        root.right = buildTree(mid + 1, right);\n        return root;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922469703","body":"\n## 题目地址\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n```\n\n![](https://tva1.sinaimg.cn/large/008i3skNly1gul6frn1lsj30km06pglt.jpg)\n\n```\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n \n\n示例 1：\n```\n\n![](https://tva1.sinaimg.cn/large/008i3skNly1gul6g0cmpej60km06pgls02.jpg)\n\n```\n\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n示例 2：\n```\n\n![](https://tva1.sinaimg.cn/large/008i3skNly1gul6gcen03j60ha06p0st02.jpg)\n\n```\n\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n示例 3：\n\n```\n\n![](https://tva1.sinaimg.cn/large/008i3skNly1gul6gprq2vj60am06p3yi02.jpg)\n\n```\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n0 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]\n \n\n进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- 链表\n- 双指针\n\n\n\n## 思路\n构建两个节点指针 A​ , B 分别指向两链表头节点 headA , headB ，做如下操作：\n\n指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：\na + (b - c)\na+(b−c)\n\n指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：\nb + (a - c)\nb+(a−c)\n\n如下式所示，此时指针 A , B 重合，并有两种情况：\n\na + (b - c) = b + (a - c)\na+(b−c)=b+(a−c)\n\n若两链表 有 公共尾部 (即 c > 0c>0 ) ：指针 A , B 同时指向「第一个公共节点」node 。\n若两链表 无 公共尾部 (即 c = 0c=0 ) ：指针 A , B 同时指向 null。\n\n\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n         if (headA == null || headB == null) return null;\n            ListNode pA = headA, pB = headB;\n            while (pA != pB) {\n                pA = pA == null ? headB : pA.next;\n                pB = pB == null ? headA : pB.next;\n            }\n            return pA;\n\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lxy030988":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916671424","body":"# 思路\n\n- 从末尾开始循环逐个相加，把结果存到一个数组里\n- 返回 翻转的数组\n\n# 代码 js\n\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  let len = num.length,\n    res = [],\n    next = 0,\n    ks = k.toString().split('').map(Number),\n    klen = ks.length,\n    maxlen = len > klen ? len : klen\n\n  for (let i = 0; i < maxlen; i++) {\n    let cur = num[len - 1 - i] || 0,\n      kcur = ks[klen - 1 - i] || 0\n\n    cur = cur + kcur + next\n    next = parseInt(cur / 10)\n    cur = cur % 10\n\n    res.push(cur)\n  }\n\n  if (next > 0) {\n    res.push(next)\n  }\n\n  return res.reverse()\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n) 数组的长度\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917398292","body":"# 思路\n\n- 先取到所有 c 的 index,存到数组里\n- 从头 循环字符串,与靠近右边的 c 比较,把结果存到一个数组 res 中\n- 从尾 循环字符串,与靠左边的 c 比较, 再把这个值与 res 中的结果比较\n\n# 代码 js\n\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n  let cs = []\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == c) {\n      cs.push(i)\n    }\n  }\n  let j = 0,\n    res = []\n  for (let i = 0; i < s.length; i++) {\n    res.push(Math.abs(i - cs[j]))\n\n    if (i == cs[j] && j < cs.length - 1) {\n      j++\n    }\n  }\n\n  for (let i = s.length - 1; i > 0; i--) {\n    if (Math.abs(i - cs[j]) < res[i]) {\n      res[i] = Math.abs(i - cs[j])\n    }\n\n    if (i == cs[j] && j > 0) {\n      j--\n    }\n  }\n\n  return res\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(3n)\n- 空间复杂度：O(3)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917625574","body":"# 思路\n\n- 借助数组实现\n- 把 maxSize 存起来 作为后面方法的比较使用\n\n# 代码 js\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.maxSize = maxSize\n  this.arr = []\n}\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.arr.length < this.maxSize) {\n    this.arr.push(x)\n  }\n}\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  if (this.arr.length) {\n    return this.arr.pop()\n  }\n  return -1\n}\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  let len = k < this.arr.length ? k : this.arr.length\n  for (let i = 0; i < len; i++) {\n    this.arr[i] += val\n  }\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n) 数组的长度\n- 空间复杂度：O(4)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918086916","body":"# 思路\n\n- 利用 栈 的思想,先进后出\n- 碰到 [ 入栈, 碰到 ] 出栈,并且暂存 k 和 要重复的字符串\n- 3[a2[c]] =>\n- 碰到[ stack= [3] str=['']\n- res = 'a'\n- 碰到[ stack= [3,2] str=['','a'] res=''\n- res='c'\n- 碰到] stack= [3] str=[''] res='acc'\n- 碰到] stack= [] str=[] res='accaccacc'\n\n# 代码 js\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  let stack = [],\n    str = [],\n    res = '',\n    num = 0\n  for (const char of s) {\n    if (char == '[') {\n      stack.push(num)\n      str.push(res)\n      res = ''\n      num = 0\n    } else if (char == ']') {\n      res = str.pop() + res.repeat(stack.pop())\n    } else if (!isNaN(char)) {\n      num = num * 10 + Number(char)\n    } else {\n      res += char\n    }\n  }\n  return res\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n) 字符串长度\n- 空间复杂度：O(4)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918924485","body":"# 思路\n\n- 两个栈 一个存入队列的栈 stack 一个存出队列的栈 fstack\n- 当 pop 或者 peek 的时候 检查一个存出队列的栈 fstack 里有没有数据,没有的话 就把所有 stack 里的数据出栈并放进去,这样刚好顺序就反过来了,再执行 fstack 出栈操作\n\n# 代码 js\n\n```js\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function () {\n  this.stack = [] //入队列\n  this.fstack = [] //出队列\n  // this.stack.push 入栈\n  // this.stack.pop 出栈\n  // this.stack.length 栈的size\n}\n\n/**\n * Push element x to the back of queue.\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.stack.push(x)\n}\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  if (!this.fstack.length) {\n    while (this.stack.length) {\n      this.fstack.push(this.stack.pop())\n    }\n  }\n  return this.fstack.pop()\n}\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  if (!this.fstack.length) {\n    while (this.stack.length) {\n      this.fstack.push(this.stack.pop())\n    }\n  }\n  return this.fstack[this.fstack.length - 1]\n}\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return !this.stack.length && !this.fstack.length\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n) 队列的长度\n- 空间复杂度：O(2) 借助两个栈实现\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920106726","body":"# 思路\n\n- 拷贝一个数组,进行排序\n- 2,1, 3, 4, 4\n- 1,2, 3, 4, 4\n- 比较两个数组,能分块的区域,里面的元素是一样的;那么这块区域元素和也是一样的\n\n# 代码 js\n\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n  const arr2 = [...arr]\n  arr2.sort((a, b) => a - b)\n\n  let count = 0,\n    sum1 = 0,\n    sum2 = 0\n\n  for (let i = 0; i < arr.length; i++) {\n    sum1 += arr[i]\n    sum2 += arr2[i]\n\n    if (sum1 == sum2) {\n      count++\n    }\n  }\n\n  return count\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(nlogn) sort 的时间复杂度\n- 空间复杂度：O(n) 数组的长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920552811","body":"# 思路\n\n- 计算链表的长度 n ,计算出从左往右 要在哪个位置断开链表 left\n- 连接链表首尾\n- 移动游标 cur 的位置,移动 left 次\n- 取 cur.next 然后再断开链表\n\n# 代码 js\n\n```js\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (k === 0 || !head || !head.next) {\n    return head\n  }\n\n  let n = 1,\n    cur = head\n  while (cur.next) {\n    cur = cur.next\n    n++\n  }\n\n  let left = n - (k % n)\n\n  cur.next = head\n  while (left) {\n    cur = cur.next\n    left--\n  }\n\n  let res = cur.next\n  cur.next = null\n  return res\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921801782","body":"# 思路\n\n- 设置一个哨兵节点\n- 循环遍历链表,交换位置\n\n# 代码 js\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  if (!head || !head.next) {\n    return head\n  }\n  let res = new ListNode()\n  res.next = head\n\n  let cur = res\n\n  while (cur.next && cur.next.next) {\n    let next1 = cur.next\n    let next2 = cur.next.next\n    cur.next = next2\n    next1.next = next2.next\n    next2.next = next1\n    cur = next1\n  }\n  return res.next\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n) 链表节点的长度\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922280201","body":"# 思路\n\n- 先把链表的每个节点存到数组中\n- 从数组中间开始递归\n\n# 代码 js\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function (head) {\n  const arr = []\n  while (head) {\n    arr.push(head.val)\n    head = head.next\n  }\n\n  const buildBST = (start, end) => {\n    if (start > end) return null\n    const mid = (start + end) >>> 1\n    const root = new TreeNode(arr[mid]) // 创建根节点\n    root.left = buildBST(start, mid - 1) // 递归构建左子树\n    root.right = buildBST(mid + 1, end) // 递归构建右子树\n    return root\n  }\n\n  return buildBST(0, arr.length - 1)\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922480890","body":"# 思路\n\n- 先把链表 A 都存到数组里\n- 再循环链表 B 查看能否找到链表 A 的节点\n\n# 代码 js\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n  const set = new Set()\n  let pre = headA\n  while (pre) {\n    set.add(pre)\n    pre = pre.next\n  }\n\n  pre = headB\n  while (pre) {\n    if (set.has(pre)) {\n      return pre\n    }\n    pre = pre.next\n  }\n\n  return null\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n+m) 两个链表的长度和\n- 空间复杂度：O(n) 链表 A 的长度\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"52HzEcho":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916675882","body":"#### 思路：类型转换\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n    return String(BigInt(num.join('')) + BigInt(k)).split('')\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429803","body":"\n```js\nvar shortestToChar = function(s, c) {\n    let array = [];\n    for (let i = 0; i < s.length; i++) {\n        array[i] = s.length;\n    }\n    for (let i = 0; i < s.length; i++){\n        if ( s.substring(i, i+1) === c){\n            for (let j = 0; j < s.length; j++){\n                array[j] = Math.min(Math.abs(i - j),array[j])\n            }\n        }\n    }\n    return array;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662701","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    return this.stack.length > 0 ? this.stack.pop() : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    let length = Math.min(k, this.stack.length);\n    for (let i = 0; i < length; i++) {\n        this.stack[i] += val;\n    }\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918054784","body":"```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n    let stack = [], num = '', str = '';\n    for (let i of s) {\n        if (/^[0-9]+.?[0-9]*$/.test(i)) { //如果是数字\n            num += i\n        } else if (i == '[') {  //遇到下一个的开头 入栈\n            stack.push({\n                num: num,\n                str: str\n            })\n            num = '';\n            str = '';\n        } else if (i == ']') { //出栈\n            let top = stack.pop()\n            str = top.str + str.repeat(top.num)\n        } else { // 如果是字母\n            str += i\n        }\n    }\n    return str\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918756441","body":"### 思路：利用数组操作\n```js\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.queue=[]\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.queue.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.queue.shift()\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.queue[0]\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.queue.length?false:true\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920147609","body":"```js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n\r\n    let stack = [];\r\n\r\n    for (let val of arr) {\r\n        // 大于栈顶元素，直接入栈，算一个块\r\n        if (!stack.length || stack[stack.length - 1] <= val) {\r\n            stack.push(val);\r\n        } else {\r\n            let curMax = stack.pop();\r\n            // val和这些弹出的元素算一个块\r\n            while (stack.length && stack[stack.length - 1] > val) {\r\n                stack.pop();\r\n            }\r\n            // 保存块中的最大值\r\n            stack.push(curMax);\r\n        }\r\n    }\r\n    return stack.length;\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920954838","body":"#### 思路：向右移动k次,将链表形成圆环\n                 1. 获取链表长度\n                 2. 闭环\n                 3. 移动len-k%len次\n```js\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n    if (!head || !head.next || !k) return head; //排除特殊情况\n    let len = 1, cur = head;\n    while (cur.next) {\n        cur = cur.next\n        len++\n    }\n    let cycle =len- k % len; //向右移动k-len次，那头部就是len-k%len\n    cur.next = head;\n    while (cycle) {\n        cur = cur.next\n        cycle--;\n    }\n    let res=cur.next;\n    cur.next=null;\n    return res\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922255662","body":"#### 思路：快慢指针找到中间节点，然后递归\n```js\nvar sortedListToBST = function (head) {\n    return buildTree(head, null)\n};\nvar buildTree = function (head, foot) {\n    if (!head || head === foot) return null;\n    let fast = head, slow = head;\n    while (fast !== foot && fast.next !== foot) { //快慢指针\n        slow = slow.next\n        fast = fast.next.next\n    }\n    let root = new TreeNode(slow.val); //分治\n    root.left = buildTree(head, slow)\n    root.right = buildTree(slow.next, foot)\n    return root\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HarryPangPang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916676513","body":"地位到高位逐位相加，最后的时候需要判断是否溢出\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\n var addToArrayForm = function(num, k) {\n    let res = []\n    let n = num.length\n    for(let i=n-1;i >=0; i--){\n        let sum = num[i]+ k%10\n        k = Math.floor(k/10)\n        if(sum>=10){\n            k++\n            sum -= 10\n        }\n        res.push(sum)\n    }\n\tfor(; k>0;k= Math.floor(k/10)){\n\t\tres.push(k%10)\n\t}\n    res.reverse()\n    return res\n};\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918984036","body":"class MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.s1 = []\n        self.s2 = []\n        self.front = None\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self.s1: self.front = x\n        self.s1.append(x)\n        \n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            self.front = None\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.s2: \n            return self.s2[-1]\n        return self.front\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if not self.s1 and not self.s2:\n            return True\n        return False","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iamtheUsername":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916676823","body":"### 思路\n\n```markdown\n1.由低位到高位逐位相加\n2.进行取余和整数除法\n3.判断进位是否大于0\n```\n\n### 代码(CPP)\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> array;\n\n        for(int i = num.size()-1;i >= 0;i --){\n            int r = num[i] + k;\n            array.push_back(r % 10);\n            k = r / 10;\n        }\n        //判断进位值\n        while(k > 0){\n            array.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(array.begin(),array.end());\n        return array;\n    }\n};\n```\n\n#### 复杂度分析\n\n$$\n时间复杂度：O(n)\n$$\n\n$$\n空间复杂度：O(n)\n$$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917399885","body":"##### 思路\n\n```markdown\n1.遍历一遍s,找出字符c所在的位置\n2.在第一个字符c前面的直接和字符c比较，在后面的直接和最后一个字符c比较\n3.位于两个字符中间的利用二分法\n```\n\n##### 代码(CPP)\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n\n        vector<int> pos;\n        int n = s.length();\n        for(int i = 0;i < n;i++){\n            if(s[i] == c) pos.push_back(i);\n        }\n\n        vector<int> ans;\n        for(int i = 0; i < n; i++){\n            auto ptr = lower_bound(pos.begin(), pos.end(), i);\n            if(ptr == pos.begin()){\n                ans.push_back(pos[0] - i);\n            }else if(ptr == pos.end()){\n                ans.push_back(i - pos.back());\n            }else {\n                int a = *ptr - i;\n                ptr--;\n                int b = i - *ptr;\n                ans.push_back(min(a, b));\n            }\n        }\n        return ans;\n    }\n};\n```\n\n##### 复杂度分析\n\n$$\n时间复杂度：O(nlogn)\n$$\n\n$$\n空间复杂度：O(n)\n$$\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922274154","body":"##### 代码（CPP）\n\n```c++\nclass Solution{\npublic:\n    vector<int> nums;\n    int index = 0, size = 0;\n    TreeNode* sortedListToBST(ListNode* head){\n        ListNode* p = head;\n        while(p){\n            nums.emplace_back(p->val);\n            p = p->next;\n            ++size;\n        }\n        return dfs(0,size);\n    }\n\tTreeNode* dfs(int cur, int size){\n        if(cur >= size)\n            return nullptr;\n        TreeNode* root = new TreeNode(0);\n        root->left = dfs(2*cur+1,size);\n        root->val = nums[index++];\n        root->right = dfs(2*cur+2,size);\n        return root;\n    }\n};\n```\n\n##### 复杂度\n\n```markdown\n时间复杂度：O(n)\n空间复杂度：O(n)\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HondryTravis":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916681677","body":"## 思路\r\n\r\n已知 k 不是 bigint 的情况下\r\n\r\n1. 通过对 k 不断累加 nums 的低位来维护 k\r\n2. 通过对 k 不断求模得到当前位，不断求商得到进位，维护 k 即可\r\n\r\n### 代码[javascirpt] Q & A\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n  const { floor } = Math\r\n  const n = num.length, ret = []\r\n\r\n  let i = n - 1\r\n\r\n  while (i >= 0 || k) {\r\n      // 出现 undefined 就要进位默认值 0\r\n      // num: [0], k = 23\r\n      k += (num[i] || 0)\r\n      ret.push(k % 10)\r\n      k = floor(k / 10)\r\n      i--\r\n  }\r\n\r\n  return ret.reverse()\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917370888","body":"### 思路\n\n1. 从当前下标找到的下标出发，分别向左、右两个方向去寻找目标字符 C\n2. 只在一个方向找到的话，直接计算字符距离\n3. 两个方向都找到的话，取两个距离的最小值(min)\n\n### 代码[js]\n\n```js\nvar shortestToChar = function (S, C) {\n    const result = []\n    \n    //  先找到前两个出现的位置\n    for (let i = 0, l = S.indexOf(C), r = S.indexOf(C, l + 1); i < S.length; i++) {\n        // 计算与左指针的距离\n        result[i] = Math.abs(l - i)\n        if (r === -1) continue\n\n        // 如果右指针存在,取较小的距离\n        result[i] = Math.min(result[i], r - i)\n\n        // 走到右指针则左右指针往下一个\n        if (i != r ) continue\n\n        (result[i] = 0, l = r, r = S.indexOf(C, r + 1))\n       \n    }\n    return result\n};\n```\n\n### 复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917618315","body":"### 思路\r\n\r\n使用数组模拟\r\n\r\n1. push: 当数组长度 >= maxSize 时不push否则添加\r\n2. pop: 只需要关心当前数组长度即可\r\n3. increment: 只需要关心当前数组长度和k的关系\r\n\r\n### 代码[js]\r\n\r\n```js\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = []\r\n    this.maxSize = maxSize || 0\r\n};\r\n\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length >= this.maxSize) return false\r\n    this.stack.push(x)\r\n};\r\n\r\nCustomStack.prototype.pop = function() {\r\n    return this.stack.length\r\n        && this.stack.pop()\r\n        || -1\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const length = Math.min(k, this.stack.length)\r\n    for (let i = 0; i < length; i++) this.stack[i] += val\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度: [push, pop] 为O(1) increment 为 O(n)\r\n\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918195105","body":"### 思路\n\n使用双栈，碰到 `[` 数字和当前字符串入栈，碰到 `]` 数字和字符串出栈。\n\n### 代码[js]\n\n```js\nvar decodeString = function(s) {\n    const countStack = [], strStack = []  // 一个放倍数，一个放拼接的\n    let num = 0, result = ''\n\n    for (const ch of s) {\n        if (!isNaN(ch)) num = num * 10 + Number(ch)\n        else if (ch === '[') {\n            strStack.push(result)\n            result = ''        \n            countStack.push(num) \n            num = 0               \n        } else if (ch === ']') { \n            const count = countStack.pop()\n            result = strStack.pop() + result.repeat(count)\n        } else result += ch                  \n            \n    }\n    return result\n};\n```\n\n### 复杂度分析\n\n时间复杂度: O(n)\n\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919002207","body":"### 思路\n\n使用两个栈，`in` 和 `out`\n\n1. `in` 用来输入，push 或者判空\n2. `out` 用来输出，只有当 out 为空的时候，才需要转置 in 栈，因为 out 里存的一直都是队列的头部\n\n### 代码[js]\n\n```js\nvar MyQueue = function() {\n  this.in = []\n  this.out = []\n};\n\nMyQueue.prototype.push = function(x) {\n  this.in.push(x)\n};\n\nMyQueue.prototype.pop = function() {\n  if (this.out.length) return this.out.pop()\n  else this.transpose()\n\n  return this.out.pop()\n};\n\nMyQueue.prototype.transpose = function() {\n  while (this.in.length) this.out.push(this.in.pop())\n}\n\nMyQueue.prototype.peek = function() {\n  if (this.out.length) return this.out[this.out.length - 1]\n  else this.transpose()\n\n  return this.out[this.out.length - 1]\n};\n\nMyQueue.prototype.empty = function() {\n  if (this.in.length | this.out.length) return false\n  else return true\n};\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(1)\n- 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919892016","body":"## 思路\n\n单调栈\n\n1. 栈顶记录最大值\n2. 遍历每个元素\n    1. 如果当前元素大于等于栈顶元素，入栈\n    2. 如果小于当前栈顶元素，循环出栈，直到当前元素大于等于栈顶元素\n    3. 重新更新 max\n\n## 代码[js]\n\n```js\nvar maxChunksToSorted = function (arr) {\n  const stack = []\n  const peek = array => array.length >= 1 ? array[array.length - 1] : 0\n\n  for (const n of arr) {\n    const max = peek(stack)\n\n    if (stack.length && n < max) {\n      // 循环出栈 \n      while (stack.length && n < peek(stack)) stack.pop()\n\n      // 更新 max\n      stack.push(max)      \n    } else stack.push(n)\n  }\n  // 返回高度\n  return stack.length\n};\n```\n\n## 复杂度分析\n\n时间复杂度: O(n)\n\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920929751","body":"### 思路\n\n让链表形成环，然后找到对应位置断开\n\n1. 优先遍历链表中的个数\n2. 对移动距离求模就是剩下需要在移动的距离 distance\n3. 如果恰好相等，返回原链表，否则就讲链表补充为环状开始计算，方便断开\n4. 当最终移动距离 distance 为 0 时，最后断开\n\n### 代码[js]\n\n```js\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next)  return head\n\n    // 优先遍历链表中的个数\n    let count = 1, cur = head\n    while (cur.next) (cur = cur.next, count ++)\n\n    // 对移动距离求模就是剩下需要在移动的距离\n    let distance = count - k % count\n\n    // 如果恰好相等，返回原链表\n    if (distance === count) return head\n\n    // 将链表补充为环\n    cur.next = head\n    while (distance) (cur = cur.next, distance --)\n\n    // 最后断开\n    const ret = cur.next\n    cur.next = null\n\n    return ret\n};\n```\n\n### 复杂度分析\n\n时间复杂度: O(n)\n\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921531709","body":"### 思路\n\n1. 创建伪头节点，对伪头节的 next 指向 head\n2. 先让 fake head 指向 head， 然后创建一个临时变量 temp 指向 fake head\n3. 当存在 temp.next.next 时，表示可以满足被交换的条件\n4. temp在一开始的时候需要修改指向，因为开始是 temp -> n1 -> n2 需要修改 为 temp -> n2 -> n1\n5. 然后修正 n1 n2 的指向\n6. 最后修改 temp 的指向\n7. 最后返回 fake head 的 next 即可\n\n### 代码[js]\n\n```js\nvar swapPairs = function (head) {\n  if (head === null || head.next === null) return head\n\n  // 建立伪头节点，让伪头节点的 next 指向当前的 head\n  const p = new ListNode(-1, head)\n  let temp = p\n\n  // 当链表 +1 +2 的节点存在时\n  while (temp.next && temp.next.next) {\n    // 每次取 next1 和 next2 节点\n    const [n1, n2] = [temp.next, temp.next.next]\n\n    // 对临时节点的 next 指向做调整\n    // t -> n2 -> n1\n    temp.next = n2\n    // 修改 next1 和 next2 的节点 next 做调整\n    n1.next = n2.next\n    n2.next = n1\n\n    // 交换完成之后更新 temp 的位置,知道交换完成\n    // before: t[cur] -> n2 -> n1\n    // after: n2 -> t[n1]\n    temp = n1\n  }\n  return p.next\n};\n```\n\n### 复杂分析\n\n时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。\n\n空间复杂度：O(1)。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922314318","body":"### 思路\n\n使用快慢双指针\n\n1. 让两个指针都指向head\n2. 快指针每次走两步，慢指针每次走一步，这样当 fast 走完的时候，slow 就是中心节点\n3. 根据slow构建中心节点，head 到 slow 构建左子树 和 slow.next 构建右子树，递归构建\n\n### 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function (head) {\n    if (head == null) return null\n\n    \n    // 保存 slow 的前一个节点\n    let slow = head, fast = head, preSlow\n\n    // 使用快慢指针，fast 每次走两步，slow 每次走一步\n    // 当 fast 指针先结束的时候，slow 就是中心节点\n    while (fast && fast.next) {\n        preSlow = slow   \n        slow = slow.next\n        fast = fast.next.next\n    }\n    \n    // 根据slow指向的节点值，构建节点\n    const root = new TreeNode(slow.val);    \n\n    // 如果preSlow有值，即slow左边有节点，需要构建左子树\n    if (preSlow != null) {\n        // 切断preSlow和中点slow\n        preSlow.next = null\n        // 递归构建左子树\n        root.left = sortedListToBST(head)\n    }\n    // 递归构建右子树\n    root.right = sortedListToBST(slow.next)\n\n    return root\n\n};\n```\n\n### 复杂度分析\n\n时间复杂度：O(nlogn)\n\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922473509","body":"### 思路\n\n双指针\n\n### 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let A = headA, B = headB\n\n    // 如果没有相交当 A, B 都为空时，退出循环\n    while (A !== B) (A = A ? A.next : headB, B = B ? B.next : headA)\n\n    return A || null\n};\n```\n\n### 复杂度分析\n\n时间复杂度：O(m+n)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Abby-xu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916682817","body":"### 思路\n\n- 列表转换为整数\n- 数字相加\n- 数字拆分成列表\n\n### 代码 （Python）\n\n~~~python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        if num == [0] and k == 0: return [0] \n        x = 0\n        out = []\n        for i in num:\n            x = x*10 + i \n        x += k\n        while x > 0:\n            out.append(x % 10)\n            x //= 10\n        return out[::-1]\n~~~\n\n### 复杂度\n\nTime: $O(n)$\n\nSpace: $O(n)$\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920349446","body":"### 思路\n\n- 获取长度\n- 确认rotation个数\n- 首尾相连\n- 循环，最后node指空\n\n### 代码 （Python）\n\n~~~python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n      if not head: return None\n      \n      #check the length\n      lastNode, length = head, 1\n      while lastNode.next:\n        lastNode = lastNode.next\n        length += 1\n       \n     \t# check the number of rotation\n      k = k % length\n      \n      # setlast node point to the first node\n      lastNode.next = head\n      \n      #traverse until (length - k) node\n      temp = head\n      for i in range(length - k - 1):\n        temp = temp.next\n      \n      #disconnect the first and last node\n      out = temp.next\n      temp.next = None\n      \n      return out\n~~~\n\n### 复杂度\n\nTime: $O(n)$\n\nSpace: $O(1)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921885202","body":"\n### 思路\n\n- Recursive \n\n\n\n### 代码 （Python）\n\n~~~python\nif not head or not head.next: return head\n        new_start = head.next.next\n        head, head.next = head.next, head\n        head.next.next = self.swapPairs(new_start)\n        return head\n~~~\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwpanda":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916683150","body":"**思路:**\n\nNumber和String的类型转换\n\n\n**代码：JavaScript**\n\n\n```\nconst addToArrayForm = (numArr, k) => {\n    if (numArr.length < 1) return [];\n​\n    //convert numArr to string integer\n    let numArrString = numArr.join('');\n  // convert the string integer into number\n    let num = BigInt(numArrString)+BigInt(k);\n​\n  //convert the number to array of strings\n    let strArr = num.toString().split('');\n  \n  //convert it back to integer\n    return strArr.map(i=>parseInt(i));\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917347554","body":"```javascript\n\nconst shortestToChar = (S, C) => {\n    let cIndices = [];\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === C) cIndices.push(i);\n    }\n    //console.log('cIndices is: ', cIndices);\n​\n    let result = Array(S.length).fill(Infinity);\n​\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === C) {\n            result[i] = 0;\n            continue;\n        }\n​\n        for (const cIndex of cIndices) {\n            const dist = Math.abs(cIndex - i);\n            //console.log(`i is ${i} and cIndex is ${cIndex} dist is ${dist}`);\n​\n            if (dist >= result[i]) break;\n​\n            result[i] = dist;\n            //console.log('result is ', result);\n        }\n    }\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917495664","body":"``` JavaScript\nconst CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n\nCustomStack.prototype.push = function(x) {\n  if(this.stack.length==this.maxSize) return;\n  \n  this.stack.push(x)\n};\n\n\nCustomStack.prototype.pop = function() {\n  if(this.stack.length ==0) return -1;\n  \n  return this.stack.pop();\n};\n\n\nCustomStack.prototype.increment = function(k, val) {\n  for(let i=0;i<k && i< this.stack.length;i++) {\n      this.stack[i] += val;\n  }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917848377","body":"``` JavaScript\nconst decodeString = function (s, i = 0) {\n\tlet letter = /[a-z]/i;\n\tlet number = /[0-9]/;\n\tlet openBracket = '[';\n\tlet closedBracket = ']';\n\n\tlet result = '';\n\tlet counter = '';\n\n\twhile (i < s.length) {\n\t\tif (letter.test(s[i])) {\n\t\t\tresult += s[i];\n\t\t\ti++;\n\t\t} else if (number.test(s[i])) {\n\t\t\tcounter += s[i];\n\t\t\ti++;\n\t\t} else if (s[i] === openBracket) {\n\t\t\tconst [window, nextIndex] = decodeString(s, i + 1);\n\n\t\t\tresult += window.repeat(Number(counter));\n\n\t\t\tcounter = '';\n\t\t\ti = nextIndex;\n\t\t\tcontinue;\n\t\t} else if (s[i] === closedBracket) {\n\t\t\treturn [result, i + 1];\n\t\t}\n\t}\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918637870","body":"### 时间复杂度：O(n)\n### 空间复杂度: O(n)\n\n``` JavaScript\nclass MyQueue {\n\tconstructor() {\n\t\tthis.helperStack = [];\n\t\tthis.outputStack = [];\n\t}\n\n\t//Pushes element x to the back of the queue.\n\tpush(x) {\n\t\tthis.outputStack.push(x);\n\t}\n\n\t//Removes the element from the front of the queue and returns it.\n\tpop() {\n\t\tif (this.helperStack.length === 0) {\n\t\t\twhile (this.outputStack.length !== 0) {\n\t\t\t\tthis.helperStack.push(this.outputStack.pop());\n\t\t\t}\n\t\t}\n\t\treturn this.helperStack.pop();\n\t}\n\n\t//Returns the element at the front of the queue.\n\tpeek() {\n\t\tif (this.helperStack.length === 0) {\n\t\t\twhile (this.outputStack.length !== 0) {\n\t\t\t\tthis.helperStack.push(this.outputStack.pop());\n\t\t\t}\n\t\t}\n\t\treturn this.helperStack[this.helperStack.length - 1];\n\t}\n\n\t//Returns true if the queue is empty, false otherwise.\n\tempty() {\n\t\treturn this.outputStack.length === 0 && this.helperStack.length === 0;\n\t}\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919690210","body":"###思路\n没思路，抄写答案\n``` JavaScript\nvar maxChunksToSorted = function (arr) {\n  const stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    a = arr[i];\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\n      const cur = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > a) stack.pop();\n      stack.push(cur);\n    } else {\n      stack.push(a);\n    }\n  }\n  return stack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920566554","body":"时间复杂度：O(N) ?\n空间复杂度：O(1)\n``` JavaScript\nvar rotateRight = function(head, l) {\n  // exit early if only one head\n  if (!head || !head.next) return head;\n  \n  // iterate and create ref to list nodes\n  const nodesByIndex = [];\n  let node = head;\n  \n  while (node) {\n      nodesByIndex.push(node);\n      node = node.next;\n  }\n  \n  // k index determines where to rotate the list\n  const k = l % nodesByIndex.length;\n  \n  // return head if rotation is at 0 index\n  if (k === 0) return head;\n  \n  // otherwise, point new head\n  const newHead = nodesByIndex[nodesByIndex.length - k]; //identify head\n  \n  // and create new tail;\n  const tailIndex = nodesByIndex.length - k - 1;\n  nodesByIndex[tailIndex].next = null; // set tail\n\n  // append new head to old heaad\n  return addNewHead(head, newHead);\n};\n\nconst addNewHead = (oldHead, newHead) => {\n  let node = newHead;\n  let last;\n  \n  while (node) {\n      last = node;\n      node = node.next;\n  }\n  \n  last.next = oldHead;\n  return newHead;\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922126813","body":"``` JavaScript\nconst sortedListToBST = (head) => {\n\tif (!head) return head;\n\tlet hashArr = [];\n\n\tlet pointer = head;\n\twhile (pointer) {\n\t\thashArr.push(pointer.val);\n\t\tpointer = pointer.next;\n\t}\n\n\t// build up the tree recursively\n\tconst helper = (left, right) => {\n\t\tif (left > right) return null;\n\n\t\tlet index = Math.floor((right + left) / 2);\n\t\tlet newNode = new TreeNode(hashArr[index]);\n\n\t\tnewNode.left = helper(left, index - 1);\n\t\tnewNode.right = helper(index + 1, right);\n\n\t\treturn newNode;\n\t};\n\n\treturn helper(0, hashArr.length - 1);\n};\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Nina1031":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916683771","body":"# 思路\n\n数组变为整数，求和，变为数组\n变整数 int(), 'sep'.join(str)\n变数组[int()]\n遍历数组 for item in list\n\n# 代码\n\n```python\nclass Solution(object):\ndef addToArrayForm(self, num, k):\n\"\"\"\n:type num: List[int]\n:type k: int\n:rtype: List[int]\n\"\"\"\np = int(''.join(str(item) for item in num)) # num为int array，需2str\nsum = p+k\nreturn [int(i) for i in str(sum)]\n```\n\n# 复杂度\n\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n空间复杂度用来估量程序运行时占用的临时空间大小，此问题中，占用内存取决于数组长度\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920082832","body":"# 思路\n\n每一块最小的不可以小于上一块最大的\n\n参考漾宝的：个数+和同，则排序后同\n若和同，则分桶\n若和不同，不可分桶，加入下一个，直到sum同\n\n\n# 代码\n\n```python\nclass Solution(object):\ndef maxChunksToSorted(self, arr):\n\"\"\"\n:type arr: List[int]\n:rtype: int\n\"\"\"\nsort_arr = sorted(arr)\nn = len(arr)\narr_sum = 0\nsort_sum = 0\nans = 0\nfor i in range(n):\narr_sum += arr[i]\nsort_sum += sort_arr[i]\nif arr_sum == sort_sum:\nans+=1\nreturn ans\n```\n\n# 复杂度\n\n时间复杂度：O(nlogn)\n空间复杂度：O(2n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fengchen321":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916689310","body":"# 思路\r\n参考题解\r\n从低位到高位计算，将数组低位与K值求和依次得到末位进行前向插入得到result。\r\n考虑k值太大，K值高位需再同一处理插入result\r\n# 代码\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int K) {\r\n        vector<int> result;\r\n        for (int i = A.size() - 1; i >= 0; i --) {\r\n            int num = A[i];\r\n            K += num; //得到末位和\r\n            int remind = K % 10;\r\n            result.insert(result.begin(), remind);  \r\n            K /= 10;\r\n        }\r\n        if (K) {\r\n            while (K > 9) { //如果K 比较大，那么此时还需要把K循环放进去\r\n                int remind = K % 10;\r\n                result.insert(result.begin(), remind);\r\n                K /= 10;\r\n            }\r\n            result.insert(result.begin(), K);\r\n        }\r\n        return result;\r\n\r\n    }\r\n}; \r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n )\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917416959","body":"# 思路\r\n左右循环遍历取最小距离值；\r\n# 代码\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.size();\r\n        vector<int> res(n,n);\r\n        int lastC = -n;\r\n        for(int i=0; i<n; i++){\r\n            if(S[i]==C) lastC = i;\r\n            res[i] = min(res[i], i-lastC);\r\n        }\r\n\r\n        for(int i=lastC-1; i>=0; i--){\r\n            if(S[i]==C) lastC = i;\r\n            res[i] = min(res[i], lastC-i);\r\n        }\r\n\r\n        return res;\r\n    }   \r\n};\r\n```\r\n# 复杂度分析\r\n时间复杂度: O(n)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917504490","body":"# 思路\r\nm数组含义：st中的前i个元素（包括i），都要加上m[i]\r\npush直接放就行，inc的时候，要更新一下m数组，当k超过st的元素个数，那就更新当前有的就可以了\r\npop的时候，只要加上 当前st的大小去对应m中的值是多少，就是ans\r\n然后把当前m[i]的值更新到前一个去\r\n# 代码\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    int mx;\r\n    vector<int> st,m;\r\n    //用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\n    CustomStack(int maxSize) {\r\n        st=vector<int>();\r\n        m=vector<int>(1001,0);\r\n        mx=maxSize;\r\n    }\r\n    //如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\n    void push(int x) {\r\n        if(st.size()==mx) return;\r\n        st.push_back(x);\r\n    }\r\n    //弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\n    int pop() {\r\n        if(st.empty()) return -1;\r\n        int idx=st.size();\r\n        int ans=st.back()+m[idx];\r\n        m[idx-1]+=m[idx];\r\n        m[idx]=0;\r\n        st.pop_back();\r\n        return ans;\r\n    }\r\n    //栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n    void increment(int k, int val) {\r\n         m[min(k,(int)st.size())]+=val;\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918271416","body":"# 思路\r\n官方题解\r\n# 代码\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    string getDigits(string &s, size_t &ptr) {\r\n        string ret = \"\";\r\n        while (isdigit(s[ptr])) {\r\n            ret.push_back(s[ptr++]);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string getString(vector <string> &v) {\r\n        string ret;\r\n        for (const auto &s: v) {\r\n            ret += s;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        vector <string> stk;\r\n        size_t ptr = 0;\r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n            if (isdigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                string digits = getDigits(s, ptr);\r\n                stk.push_back(digits);\r\n            } else if (isalpha(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.push_back(string(1, s[ptr++])); \r\n            } else {\r\n                ++ptr;\r\n                vector <string> sub;\r\n                while (stk.back() != \"[\") {\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(), sub.end());\r\n                // 左括号出栈\r\n                stk.pop_back();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = stoi(stk.back()); \r\n                stk.pop_back();\r\n                string t, o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime--) t += o; \r\n                // 将构造好的字符串入栈\r\n                stk.push_back(t);\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919119620","body":"# 思路\r\n\r\n题解leetcode\r\n>队列的特性是 FIFO（先入先出），而栈的特性是 FILO（先入后出）。\r\n知道两者特性之后，我们需要用两个栈来模拟队列的特性，一个栈为入队栈，一个栈为出对栈。\r\n当出队栈存在内容时，出队栈的栈顶，即为第一个出队的元素。\r\n若出队栈无元素，我们的需求又是出队的话，我们就需要将入队栈的内容反序导入出队栈，然后弹出栈顶即可。\r\n注意：根据栈的的特性，我们仅能使用 pushpush 和 poppop 操作。\r\n# 代码\r\n```cpp\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n时间复杂度：push 和 empty 为 O(1)，pop 和 peek 为均摊 O(1)。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 O(1)。\r\n\r\n空间复杂度：O(n)。其中 n 是操作总数。对于有 n 次push 操作的情况，队列中会有 n 个元素，故空间复杂度为 O(n)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920044302","body":"# 思路\r\n贪心算法：\r\n思路：只有对于某个位置，其左边（包括该数本身）的最大值不大于位置右侧的最小值，在该处就可以分段\r\n# 代码\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        int N = arr.size();\r\n        vector<int> lmax(N, INT_MIN);\r\n        vector<int> rmin(N, INT_MAX);\r\n        lmax[0] = arr[0];\r\n        rmin[N - 1] = arr[N - 1];\r\n        for (int i = 1; i < N; ++i) {\r\n            lmax[i] = max(lmax[i - 1], arr[i]);\r\n            rmin[N - 1 - i] = min(rmin[N - i], arr[N - 1 - i]);\r\n        }\r\n        int res = 1;\r\n        for (int i = 0; i < N - 1; ++i) {\r\n            res += lmax[i] <= rmin[i + 1];\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maqianxiong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916690979","body":"### 思路\n\n逐位相加，从最低位加到最高位，若是大于10，进位\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for(int i = n-1;i >= 0;i--){\n            int sum  = num[i] + k%10;\n            k/=10;\n            if(sum >=10){\n                k++;\n                sum -=10;\n            }\n            res.add(sum);\n        }\n        while(k > 0){\n            res.add(k%10);\n            k/=10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(maxlength(num,k))$\n- 空间复杂度 $O(1)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917318050","body":"### 思路\n\n官方题解\n\n从左向右遍历，记录等于c的位置prev，答案就是abs（i- prev）;\n\n从右向左遍历,   记录等于c的位置prev，答案就是abs（prev- i）。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N  = s.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE/2;\n        for(int i = 0;i < N;i++){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] =Math.abs( i - prev);\n        }\n        prev = Integer.MIN_VALUE/2;\n        for(int i = N-1;i >=0;i--){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i],Math.abs(prev-i));\n        }\n        return ans;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917518851","body":"### 思路\n\n使用数组模拟栈，用一个变量 `top` 来记录当前栈顶的位置。\n\n### 代码\n\n```java\nclass CustomStack {\n    int[] stack ;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top != stack.length - 1){\n            top ++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top == -1){\n            return -1;\n        }\n        top--;\n        return stack[top+1];\n\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k,top+1);\n        for(int i = 0;i < limit;i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918245510","body":"[394. 字符串解码 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/decode-string/)\n\n## 394\n\n### 思路\n\n分为四种情况，数字，字母，[ 和 ]时候分别讨论\n\n当为数字时候，可能为连续的数字的情况要考虑到\n\n### 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stackMulti = new LinkedList<>();\n        LinkedList<String> stackRes = new LinkedList<>();\n        for(Character c :s.toCharArray()){\n            if(c >= '0' && c <='9'){\n                multi  = multi*10 + Integer.parseInt(c + \"\");\n            }else if(c == '['){\n                stackMulti.addLast(multi);\n                stackRes.addLast(res.toString());\n                res = new StringBuilder();\n                multi = 0;\n            }else if(c == ']'){\n                StringBuilder tmp = new StringBuilder();\n                int curMulti = stackMulti.removeLast();\n                for(int i = 0; i < curMulti; i++){\n                    tmp.append(res);\n                } \n                res = new StringBuilder(stackRes.removeLast() + tmp);\n            }else{\n                res.append(c);\n            }\n            \n        }\n        return res.toString();\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918822928","body":"[232. 用栈实现队列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n### 思路\n\n- 双栈，inStack用于push，inStack push完成之后的pop 用于ouStack的push，这样outStack的元素的顺序跟inStack的顺序相反，相当于队列。\n\n### 代码\n\n```java\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        inStack = new LinkedList<Integer>();\n        outStack = new LinkedList<Integer>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(outStack.isEmpty()){\n            in2out();\n        }\n        return outStack.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(outStack.isEmpty()){\n            in2out();\n        }\n        return outStack.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out(){\n        while(!inStack.isEmpty()){\n            outStack.push(inStack.pop());\n        }\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919747603","body":"[768. 最多能完成排序的块 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\n\n### 思路\n\n- 前后两次遍历\n- 从前到后遍历一次，得到到目前位置最大的数head\n- 从后到前遍历一次，如果到当前的最小值tail比head要大，res+1\n\n### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int [] head = new int[arr.length];\n        head[0] = arr[0];\n        for(int i = 1; i <arr.length;i++){\n            head[i] = Math.max(head[i-1],arr[i]);\n        }\n        int tail = Integer.MAX_VALUE,res = 0;\n        for(int i = arr.length - 1;i >= 0;i--){\n            if(tail >=head[i]){\n                res++;\n            }\n            tail = Math.min(tail,arr[i]);\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920916222","body":"[61. 旋转链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/rotate-list/)\n\n### 思路\n\n- 快慢指针\n\n### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next ==null){\n            return head;\n        }\n        int count = 0;\n        ListNode now = head;\n        while(now!=null){\n            now = now.next;\n            count++;\n        }\n        k = k%count;\n        ListNode slow = head,fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n                fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921408485","body":"24. 两两交换链表中的节点 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n### 思路\n\n- 官方题解 迭代\n- 例如将A->B反转，定义A的前置preA，B的后置nextB，preA->A->B->nextB\n- A指向nexB B指向A preA指向B  更新PreA A B nextB 进行新一轮迭代 返回的时候B为头结点 \n- 更新当前节点，进行下一轮循环\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next ==null){\n            return head;\n        }\n        ListNode preNode = new ListNode(-1);\n        ListNode res;\n        preNode.next = head;\n        res = head.next;\n        ListNode firstNode = head;\n        ListNode secondNode = head;\n        ListNode nextNode = head;\n        while(firstNode !=null && firstNode.next != null){\n            secondNode = firstNode.next;\n            nextNode = secondNode.next;\n\n            //对链表更新\n            firstNode.next = nextNode;\n            secondNode.next = firstNode;\n            preNode.next = secondNode;\n\n            //更新指针位置\n             preNode = firstNode;\n             firstNode = nextNode;\n            \n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922211807","body":"[109. 有序链表转换二叉搜索树 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n### 思路\n\n- 官方题解，使用快慢指针定位重点，中点左边的值为左子树，中点右边的值为右子树，然后迭代\n\n### 代码\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head ==null) {return null;}\n        return dfs(head,null);\n    }\n    private TreeNode dfs(ListNode head,ListNode tail){\n        if(head==tail){return null;}\n        ListNode fast = head,slow = head;\n        while(fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = dfs(head,slow);\n        root.right = dfs(slow.next,tail);\n\n        return root;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(logN)$\n- 空间复杂度 $NO(logN)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922434891","body":"### 思路\n\n- 哈希集合\n- 首先遍历headA，并将链表headA中的每个节点加入哈希表集合中，然后遍历链表headB，判断B中的节点是否在哈希集合中，若在则返回当前节点，若不在，进行下一次遍历\n\n### 代码\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> hash = new HashSet<ListNode>();\n        ListNode temp = headA;\n        while(temp.next != null){\n            hash.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while(temp.next != null){\n            if(hash.contains(temp)){\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Menglin-l":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916691806","body":"### 思路\r\n---\r\n从低位往高位做加法，为避免最后结果需要反转，可选用LinkedList存储数字。\r\n\r\n### 代码\r\n---\r\n```Java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int leng = num.length - 1;\r\n\r\n        while (leng >= 0 || k != 0) {\r\n\r\n            if (leng >= 0) {\r\n                k += num[leng];\r\n                leng--;\r\n            }\r\n\r\n            res.addFirst(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n---\r\nTime: O(max(N, K)), 由数组num长度和数字k的位数两者中的较大值决定\r\n\r\nSpace: O(1), 在原数组中操作，没有额外开销\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917360370","body":"### 思路：\r\n#### 1.首先要确定S中每个字符C的位置，可用一个ArrayList存储；\r\n#### 2.再次遍历数组S，用当前字符与目标字符依次比较，计算最短距离。\r\n---\r\n\r\n### 代码部分：\r\n```Java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        \r\n        ArrayList<Integer> position = new ArrayList<>();\r\n        int[] res = new int[s.length()];\r\n        int point = 0;\r\n        \r\n        for (int i = 0; i < s.length(); i ++) {\r\n            if (s.charAt(i) == c) position.add(i);\r\n        }\r\n        \r\n        for (int j = 0; j < s.length(); j ++) {\r\n            \r\n            while (point < position.size() - 1 && Math.abs(position.get(point) - j) > Math.abs(position.get(point + 1) - j)) {\r\n                point ++;\r\n            }\r\n            \r\n            res[j] = Math.abs(position.get(point) - j);\r\n            \r\n            point = 0;\r\n        }\r\n        \r\n        return res;\r\n        \r\n    }\r\n}\r\n```\r\n---\r\n\r\n### 复杂度分析：\r\n#### Time: O(n^2)，第二个for循环中包含一个while循环，最坏情况需要再遍历一次数组，为n * n，可优化为n（先打卡再优化）.\r\n#### Space: O(n)，创建一个ArrayList，最坏情况下长度为n.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917586499","body":"### 思路\r\n#### 朴素的数组实现，因为题中对maxSize有限，使用数组不需要担心过高的开销。\r\n---\r\n\r\n### 代码部分\r\n```Java\r\nclass CustomStack {\r\n\tprivate int[] stack;\r\n\tprivate int size;\r\n\r\n\tpublic CustomStack(int maxSize) {\r\n\t\tstack = new int[maxSize];\r\n\t\tsize = 0;\r\n\t}\r\n\r\n\tpublic void push(int x) {\r\n\t\tif (size < stack.length) {\r\n\t\t\tstack[size ++] = x;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic int pop() {\r\n\t\tif (size > 0) {\r\n\t\t\treturn stack[-- size];\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tpublic void increment(int k, int val) {\r\n\t\tfor (int j = 0; j < k && j < size; j ++) {\r\n\t\t\tstack[j] += val;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n---\r\n\r\n### 复杂度\r\n出栈入栈的Time: O(1)\r\nincrement的Time: O(n)\r\nSpace: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917697295","body":"### 思路：\r\n#### 因为方括号可能内嵌，需从最内层decode，可使用一个辅助栈：\r\n#### 1. 将字符依次入栈，遇到第一个']'时出栈，至第一个'['前的数字截止.\r\n#### 2. 根据数字解码得到相应的字符串。\r\n#### 3. 将完成解码后的字符串重新入栈。\r\n#### 4. 重复1-3中操作。\r\n---\r\n\r\n### 代码部分：\r\n```Java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n\r\n        if (s == null || s.length() == 0) {\r\n            return \"\";\r\n        }\r\n\r\n        Stack<Character> stack = new Stack<>();\r\n\r\n        for (char c : s.toCharArray()) {\r\n            if (c != ']') {\r\n                stack.push(c);\r\n                // 遇到']'\r\n            } else {\r\n                StringBuilder sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) sb.insert(0, stack.pop());\r\n\r\n                String str = sb.toString();\r\n                stack.pop(); // 弹出匹配的'['\r\n\r\n                sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) sb.insert(0, stack.pop());\r\n\r\n                int cnt = Integer.valueOf(sb.toString());\r\n\r\n                // 根据数字解码得到相应的字符串\r\n                while (cnt > 0) {\r\n                    for (char cc : str.toCharArray()) stack.push(cc);\r\n\r\n                    cnt --;\r\n                }\r\n            }\r\n        }\r\n\r\n        StringBuilder res = new StringBuilder();\r\n        while (!stack.isEmpty()) res.insert(0, stack.pop());\r\n\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n---\r\n\r\n### 复杂度：\r\n#### Time: O(n^2)\r\n#### Space: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918458173","body":"### 思路：\r\n#### 用栈A模拟入队，栈B模拟出队。\r\n#### 元素入队时，push进栈A；出队时，将元素pop出栈A，再push进栈B，最后pop，以实现先进先出。\r\n#### (做完题了才知道还有“java中的Stack有设计上的缺陷，官方推荐使用Deque代替Stack”这个说法。。。先打卡。。。)\r\n---\r\n\r\n### 代码部分：\r\n```Java\r\nclass MyQueue {\r\n\r\n    private Stack<Integer> sA;\r\n    private Stack<Integer> sB;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        sA = new Stack<>();\r\n        sB = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        sA.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (!empty()) {\r\n            if (!sB.empty()) return sB.pop();\r\n            else {\r\n                while (!sA.empty()) {\r\n                    sB.push(sA.pop());\r\n                }\r\n            }\r\n            return sB.pop();\r\n        }\r\n        else return -1;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (!empty()) {\r\n            if (!sB.empty()) return sB.peek();\r\n            else {\r\n                while (!sA.empty()) {\r\n                    sB.push(sA.pop());\r\n                }\r\n            }\r\n            return sB.peek();\r\n        }\r\n        else return -1;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        if (sA.empty() && sB.empty()) return true;\r\n        else return false;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n### 复杂度：\r\n#### Time: O(1)\r\n#### Space: O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919430042","body":"### 思路：\r\n#### 数组中所有元素均大于等于0，并且是划分为连续的块，想到前缀和。先将数组排序，再与原来的无序数组一起从第一个元素开始累加，只要和相等了就能划出一个块。\r\n---\r\n\r\n### 代码部分：\r\n```Java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int preSum1 = 0, preSum2 = 0, cnt = 0;\r\n        int[] arrCopy = Arrays.copyOf(arr, arr.length);\r\n        Arrays.sort(arrCopy);\r\n        \r\n        for (int i = 0; i < arr.length; i ++) {\r\n            preSum1 += arr[i];\r\n            preSum2 += arrCopy[i];\r\n            \r\n            if (preSum1 == preSum2) cnt ++;\r\n        }\r\n        \r\n        return cnt;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n### 复杂度：\r\n#### Time: O(N * logN)\r\n#### Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920311944","body":"### 思路：\r\n#### 1.先遍历一遍链表，确定位置pos。\r\n#### 2.因为旋转后头结点改变，设置虚拟头结点dummy，便于后续操作。\r\n#### 3.指针cur指向需要旋转的第一个节点的前一个结点，用于最后断开链接。\r\n#### 4.旋转过程画图更好理解。\r\n---\r\n\r\n### 代码部分：\r\n```Java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return null;\r\n        \r\n        int n = 0;\r\n        ListNode dummy = new ListNode(-200, head);\r\n        ListNode tail = dummy.next;\r\n        \r\n        while (tail != null && tail.next != null) {\r\n            n ++;\r\n            tail = tail.next;\r\n        }\r\n        n ++;\r\n        \r\n        if (n == k) return head;\r\n        int pos = k > n ? n - k % n : n - k;\r\n        \r\n        ListNode cur = dummy;\r\n        \r\n        for (int i = 0; i < pos; i ++) {\r\n            cur = cur.next;\r\n        }\r\n        \r\n        tail.next = dummy.next;\r\n        dummy.next = cur.next;\r\n        cur.next = null;\r\n        \r\n        return dummy.next;\r\n        \r\n    }\r\n}\r\n```\r\n---\r\n\r\n### 复杂度：\r\n#### Time: O(N)，遍历链表两次\r\n#### Space: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921065613","body":"### 思路：\r\n#### 1.头节点会改变，增加dummy虚拟头节点便于操作。\r\n#### 2.初始化两个指针pre和cur，分别指向dummy和需要交换的第二个节点。\r\n#### 3.循环交换结束后，判断末尾没有节点和只有一个节点的情况。\r\n#### 4.返回dummy.next\r\n---\r\n\r\n### 代码部分：\r\n```Java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) return head;\r\n        \r\n        ListNode dummy = new ListNode(-1, head);\r\n        ListNode pre = dummy, cur = pre.next.next;\r\n        \r\n        while (cur != null) {\r\n            pre.next.next = cur.next;\r\n            cur.next = pre.next;\r\n            pre.next = cur;\r\n            \r\n            pre = pre.next.next;\r\n            \r\n            if (pre.next == null || pre.next.next == null) {\r\n                break;\r\n            }\r\n            \r\n            cur = pre.next.next;\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n### 复杂度：\r\n#### Time: O(N)，对链表一次遍历\r\n#### Space: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922117721","body":"### 思路：\r\n#### 1.用快慢指针找到中间的节点，即BST的根，\r\n#### 2.重复1中操作，按照根-左-右的顺序递归生成树，其中心思想是“先把根节点搞定，再用同样的方法去搞定左子树的根和右子树的根，从而生成一棵树”。\r\n---\r\n\r\n### 代码部分：\r\n```Java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) return null;\r\n        if (head.next == null) return new TreeNode(head.val);\r\n        \r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        ListNode preSlow = null;\r\n        \r\n        while (fast != null && fast.next != null) {\r\n            preSlow = slow;\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        \r\n        TreeNode root = new TreeNode(slow.val);\r\n        preSlow.next = null;\r\n        \r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(slow.next);\r\n        \r\n        return root;\r\n        \r\n    }\r\n}\r\n```\r\n---\r\n\r\n### 复杂度：\r\n#### Time: O(NlogN)\r\n#### Space: O(logN)，递归栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922344086","body":"### 思路：\r\n#### 1.用两个指针分别遍历两条链表，逐一比较，找相同的节点；\r\n#### 2.短的那条会先遍历完，如果没找到，将指针转向长的那条继续遍历；\r\n#### 3.如果有相同节点，返回该节点；如果没有，会一齐指向null，结束while循环，并返回null.\r\n---\r\n\r\n### 代码部分：\r\n```Java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) return null;\r\n        \r\n        ListNode aPtr = headA;\r\n        ListNode bPtr = headB;\r\n        \r\n        while (aPtr != bPtr) {\r\n            \r\n            if (aPtr == null)\r\n                aPtr = headB;\r\n            else \r\n                aPtr = aPtr.next;\r\n            \r\n            if (bPtr == null)\r\n                bPtr = headA;\r\n            else \r\n                bPtr = bPtr.next;\r\n            \r\n        }\r\n        return aPtr;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n### 复杂度：\r\n#### Time: O(N), 链表A长度+链表B长度\r\n#### Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hewenyi666":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916699491","body":"## 题目名称\n\n**989. 数组形式的整数加法**\n\n\n### 题目思路\n\n1.将 数字型数组 -> 字符串型数组  \n2.将数组中的字符串拼接, 用eval函数取出字符串中的数字 和 k 取和, 然后转为字符串  \n3.将字符串 -> 数字型的数组\n\n### code for python\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        list_str = [str(i) for i in num]\n        final_str = str(eval(\"\".join(list_str)) + k)\n        return [int(j) for j in final_str]\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917401537","body":"## 题目名称\n\n**821. 字符的最短距离**\n\n\n### 题目思路\n- 遍历一遍字符串ｓ，获取记录预期字符ｃ在ｓ中所有位置的列表 list_e\n- 定义一个方法: 获取输入字符 和 列表中所有元素 所有差值中绝对值最小的那个值\n- 遍历字符串s，每遍历到一个字符时，调用一次自定义方法，记录到数组中\n\n### code for Python3\n\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        list_e = [i for i in range(len(s)) if s[i] == c]\n        arr = []\n        for j in range(len(s)):\n            arr.append(self.get_abs_minnum(j, list_e))\n        return arr\n\n    def get_abs_minnum(self, first_num:int, li:List):\n        cur = pow(10, 4)\n        for v in li:\n            cur = min(cur, abs(v - first_num))\n        return cur\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N²)  \n　　原因: 双层循环, 每次遍历字符串s时,都会遍历一次list_e\n- 空间复杂度: O(N)   \n　　原因: list_e占用的空间大小和字符串s的长度有关\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917535705","body":"### 题目名称\n\n**1381. 设计一个支持增量操作的栈**\n\n### 题目链接\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n### 题目思路\nPython3用数组模拟栈操作\n\n### code for Python3\n\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.arr = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.arr) < maxSize:\n            self.arr.append(x)\n\n    def pop(self) -> int:\n        if self.arr:\n            return self.arr.pop()\n        else:\n            return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        if not self.arr:\n            return\n        elif len(self.arr) <= k:\n            for i in range(len(self.arr)):\n                self.arr[i] += val\n        else:\n            for i in range(k):\n                self.arr[i] += val\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918247451","body":"### 题目名称\n\n**394. 字符串解码**\n\n### 题目链接\n\nhttps://leetcode-cn.com/problems/decode-string/\n\n### 题目思路\n遍历字符串,遇到非']'就入栈, 遇到就 '[' 就出栈\n\n### code for Python3\n\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n                # pop 掉 \"[\"\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918874048","body":"### 题目名称\r\n\r\n**232. 用栈实现队列**\r\n\r\n### 题目链接\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n### 题目思路\r\n\r\n\r\n### code for Python3\r\n\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.arr = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.arr.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        target = self.arr[0]\r\n        self.arr.remove( self.arr[0] )\r\n        return target\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.arr[0]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.arr) == 0\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度: O(N)  主要是pop操作, 会从数组的头部删除元素\r\n- 空间复杂度: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920026737","body":"### 题目名称\n\n**768. 最多能完成排序的块 II**\n\n### 题目链接\n\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-by-leetco/\n\n### 题目思路\n看的题解! 对于这个分块 expect = sorted(arr)。在元素各不相同的情况下，找到最小的 k 只要满足 max(arr[:k+1]) == expect[k] 就可以了，这时候 arr[:k+1] 一定是 expect[:k+1] 的某种排列组合\n\n### code for Python3\n\n```\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.Counter()\n        counted = []\n        for x in arr:\n            count[x] += 1\n            counted.append((x, count[x]))\n\n        ans, cur = 0, None\n        for X, Y in zip(counted, sorted(counted)):\n            cur = max(cur, X)\n            if cur == Y:\n                ans += 1\n        return ans\n\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(NlogN)\n- 空间复杂度: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920921405","body":"### 题目名称\n\n**61. 旋转链表**\n\n### 题目链接\n\nhttps://leetcode-cn.com/problems/rotate-list/\n\n### 题目思路\n  把原来的链表尾部连上头，然后找倒数第k个点作为新的表头\n但值得注意的是，当k超过链表长度的时候就相当于链表重置了，所以需要k对节点长度取余\n\n### code for Python3\n\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        #就是把原来的链表尾部连上头，然后找倒数第k个点作为新的表头\n        if not head:\n            return \n        p = head\n        i = 1 #记录链表长度\n        while p.next:\n            p = p.next\n            i += 1\n        k = k % i #当k超过了；链表节点个数的时候就想当于循环了一次\n        p.next = head\n        for _ in range(i - k): #找到断开的点\n            p = p.next\n        res = p.next #新的起点\n        p.next = None #断开\n        return res\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921827352","body":"### 题目名称\n\n**24. 两两交换链表中的节点**\n\n### 题目链接\n\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n### 题目思路\n用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead\n\n\n### code for Python3\n\n```\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922237214","body":"### 题目名称\n\n**109. 有序链表转换二叉搜索树**\n\n### 题目链接\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\n\n### 题目思路\n「快慢指针法」官方题解中的做法\n\n### code for Python3\n\n```\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(nlogn)，其中 n 是链表的长度\n- 空间复杂度: O(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922459299","body":"### 题目名称\n\n**160. 相交链表**\n\n### 题目链接\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n### 题目思路\n对链表 A 中的每一个结点，我们都遍历一次链表 B 查找是否存在重复结点，第一个查找到的即第一个公共结点\n\n### code for Python3\n\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p = headA\n        while p:\n            q = headB\n            while q:\n                if p == q:\n                    return p\n                q = q.next\n            p = p.next\n        return p\n\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N²)\n- 空间复杂度: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JinMing-Gu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916700002","body":"【思路】\r\n要注意给定的数组位数过大时，数据大小超出整型数据范围。\r\n【代码】\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k)\r\n    {\r\n        int n = num.size();\r\n        long long a;\r\n        long long b = 0;\r\n        for(int i = 1; i <= n; i++)\r\n        {\r\n            double m = pow(10, n - i);\r\n            a = num[i - 1] * m;\r\n            b = b + a;\r\n        }\r\n        cout << b << endl;\r\n        cout << k << endl;\r\n        long long c = b + k;\r\n        cout << c << endl;\r\n        num.clear();\r\n        vector<int> rnum;\r\n        while(1)\r\n        {\r\n            if(c >= 10)\r\n            {\r\n                long long d = c % 10;\r\n                rnum.push_back(d);\r\n                c = c - d;\r\n                c = c / 10;\r\n            }\r\n            if(c < 10)\r\n            {\r\n                rnum.push_back(c);\r\n                break;\r\n            }\r\n        }\r\n        vector<int>::reverse_iterator riter;\r\n        for (riter = rnum.rbegin(); riter != rnum.rend(); riter++)\r\n            num.push_back(*riter);\r\n        for(auto it = num.begin(); it != num.end(); it++)\r\n            cout << *it << endl;\r\n        return num;\r\n        // reverse(rnum.begin(), rnum.end());\r\n        // for(auto it = rnum.begin(); it != rnum.end(); it++)\r\n        //     cout << *it << endl;\r\n        // return rnum;\r\n    }\r\n};\r\n```\r\n【复杂度】\r\n\r\n【参考】\r\nhttps://www.cnblogs.com/vranger/p/3502885.html","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917386239","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c)\r\n    {\r\n        vector<int> num;\r\n        int n = s.size();\r\n        for(int i = 0; i < n; i++)\r\n        {\r\n            if(s[i] == c)\r\n                num.push_back(i);\r\n        }\r\n        for(auto it = num.begin(); it != num.end(); it++)\r\n            cout << *it << endl;\r\n        int m = num.size();\r\n        vector<int> length;\r\n        vector<int> answer;\r\n        for(int i = 0; i < n; i++)\r\n        {\r\n            for(int j = 0; j < m; j++)\r\n            {\r\n                length.push_back(abs(num[j] - i));\r\n            }\r\n            cout << \"[\" << \" \";\r\n            for(auto it = length.begin(); it != length.end(); it++)\r\n                cout << *it << \" \";\r\n            cout << \"]\" << endl;\r\n            sort(length.begin(), length.end());\r\n            answer.push_back(length[0]);\r\n            length.clear();\r\n        }\r\n        return answer;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917973409","body":"```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) \r\n    {\r\n        string res = \"\";\r\n        stack <int> nums;\r\n        stack <string> strs;\r\n        int num = 0;\r\n        int len = s.size();\r\n        for(int i = 0; i < len; ++ i)\r\n        {\r\n            if(s[i] >= '0' && s[i] <= '9')\r\n            {\r\n                num = num * 10 + s[i] - '0'; // 123-->0*10+1-->1*10+2-->12*10+3\r\n            }\r\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\r\n            {\r\n                res = res + s[i];\r\n            }\r\n            else if(s[i] == '[') //将‘[’前的数字压入nums栈内， 字母字符串压入strs栈内\r\n            {\r\n                nums.push(num);\r\n                num = 0;\r\n                strs.push(res); \r\n                res = \"\";\r\n            }\r\n            else //遇到‘]’时，操作与之相配的‘[’之间的字符，使用分配律\r\n            {\r\n                int times = nums.top();\r\n                nums.pop();\r\n                for(int j = 0; j < times; ++ j)\r\n                    strs.top() += res;\r\n                res = strs.top(); //之后若还是字母，就会直接加到res之后，因为它们是同一级的运算\r\n                                  //若是左括号，res会被压入strs栈，作为上一层的运算\r\n                strs.pop();\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919136425","body":"```\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919617740","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> stack;\r\n        for(int i =0;i<arr.size();i++){\r\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\r\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\r\n            if(!stack.empty()&&stack.top()>arr[i]){\r\n                // 我们需要将融合后的区块的最大值重新放回栈\r\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\r\n                int cur = stack.top();\r\n                // 维持栈的单调递增\r\n                while(!stack.empty()&&stack.top()>arr[i]){\r\n                    sstackta.pop();\r\n                }\r\n                stack.push(cur);\r\n            }else{\r\n                stack.push(arr[i]);\r\n            }\r\n        }\r\n        // 栈存的是块信息，因此栈的大小就是块的数量\r\n        return stack.size();\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920918373","body":"```\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (k == 0 || head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        int n = 1;\r\n        ListNode* iter = head;\r\n        while (iter->next != nullptr) {\r\n            iter = iter->next;\r\n            n++;\r\n        }\r\n        int add = n - k % n;\r\n        if (add == n) {\r\n            return head;\r\n        }\r\n        iter->next = head;\r\n        while (add--) {\r\n            iter = iter->next;\r\n        }\r\n        ListNode* ret = iter->next;\r\n        iter->next = nullptr;\r\n        return ret;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921791083","body":"```\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (k == 0 || head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        int n = 1;\r\n        ListNode* iter = head;\r\n        while (iter->next != nullptr) {\r\n            iter = iter->next;\r\n            n++;\r\n        }\r\n        int add = n - k % n;\r\n        if (add == n) {\r\n            return head;\r\n        }\r\n        iter->next = head;\r\n        while (add--) {\r\n            iter = iter->next;\r\n        }\r\n        ListNode* ret = iter->next;\r\n        iter->next = nullptr;\r\n        return ret;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922281086","body":"```\r\nclass Solution {\r\npublic:\r\n    ListNode* getMedian(ListNode* left, ListNode* right) {\r\n        ListNode* fast = left;\r\n        ListNode* slow = left;\r\n        while (fast != right && fast->next != right) {\r\n            fast = fast->next;\r\n            fast = fast->next;\r\n            slow = slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n\r\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\r\n        if (left == right) {\r\n            return nullptr;\r\n        }\r\n        ListNode* mid = getMedian(left, right);\r\n        TreeNode* root = new TreeNode(mid->val);\r\n        root->left = buildTree(left, mid);\r\n        root->right = buildTree(mid->next, right);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        return buildTree(head, nullptr);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922408243","body":"```\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        unordered_set<ListNode *> visited;\r\n        ListNode *temp = headA;\r\n        while (temp != nullptr) {\r\n            visited.insert(temp);\r\n            temp = temp->next;\r\n        }\r\n        temp = headB;\r\n        while (temp != nullptr) {\r\n            if (visited.count(temp)) {\r\n                return temp;\r\n            }\r\n            temp = temp->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Bingbinxu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916700923","body":"**思路**\n将整数K作为移动的部分，不断与A的最后一位叠加，从而更新数组\n注意点：边界条件存在A>=K,和A<K的情况\n**代码**\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size()-1;\n        while(len>=0)\n        {\n            k = k + num[len];\n            num[len] = k % 10;\n            k = k / 10;\n            len--;\n        }\n        while(k>0)\n        {\n            num.insert(num.begin(),0);\n            num[0] = k % 10;\n            k = k /10;\n        }\n        return num;       \n    }\n};\n```\n**复杂度**\n时间复杂度O（N+max（0，K-N））\nwhile函数遍历N遍，若K超过N，还需要遍历K-N遍\n空间复杂度O（N+max（0，K-N））","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917339824","body":" **思路**\n 先找出数组s中含有c的字符下标\n 循环找出每个字符对应的c的下标距离，求出最短距离\n **代码**\n class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> cp;        \n        int len = s.size();\n        vector<int> sp; \n        for(int i = 0; i < len; i++)\n        {\n            if (s[i]== c)\n            {\n                cp.push_back(i);\n            }          \n        }\n       for(int i = 0; i < len; i++)\n        {\n            sp.push_back(abs(i -cp[0]));\n            for (int j =1; j < cp.size(); j ++)\n            {\n                int a = abs(i -cp[j]);\n                if(sp[i] > a)\n                {\n                    sp[i] = a;\n                }\n            }\n        }      \n       return sp;\n    }\n};\n **复杂度分析**\n 时间复杂度 循环遍历找出c，为O（N）；循环算距离O（N*K），K为s中含有c的个数\n 空间复杂度 O（N）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917769897","body":"**思路**\r\n遇到数字执行10进制的数字计算，前一个比后一个多10倍\r\n遇到[进行压栈处理\r\n遇到]进行出站处理\r\n遇到普通字符，加上就行\r\n**代码**\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        int num = 0;\r\n        string str = \"\";\r\n        string res = \"\";\r\n        stack<int> numstack;\r\n        stack<string> strstack;\r\n        int len = s.size();\r\n        for(int i = 0;i < len; i++)\r\n        {\r\n            if(s[i]>='0' && s[i]<='9')\r\n            {\r\n                num = 10*num + s[i] -'0';\r\n            }\r\n            else if(s[i]=='[')\r\n            {\r\n                numstack.push(num);\r\n                strstack.push(str);\r\n                num = 0;\r\n                str = \"\";\r\n            }\r\n            else if(s[i]==']')\r\n            {\r\n                int j = numstack.top();\r\n                numstack.pop();\r\n                for(int k = 0;k < j;k++ )\r\n                {\r\n                    strstack.top() += str;\r\n                }\r\n                str = strstack.top();\r\n                strstack.pop();\r\n            }\r\n            else\r\n            {\r\n                str +=s[i];\r\n            }\r\n\r\n        }\r\n        return str;\r\n\r\n    }\r\n};\r\n```\r\n**复杂度**\r\n时间复杂度遍历s，同时遍历里面重复[]的次数,复杂度为O（NUM的和）\r\n空间复杂度O([]里的lenth*num)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918707980","body":"**思路**\n利用两个栈进行出和入，栈之间转换的条件是第二个栈为空，并且一次性全交换完；\n而当第二栈不为空，两个栈分别进行出和入互不影响\n**代码**\n```C++\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n\n    }   \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stackin.push(x);\n    }   \n\n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if(stackout.empty())\n        {\n            while(!stackin.empty())\n            {\n                stackout.push(stackin.top());\n                stackin.pop();\n            }\n        }\n        int out = stackout.top();\n        stackout.pop();\n        return out;\n    }   \n\n    /** Get the front element. */\n    int peek() {\n        int fele =this-> pop();\n        stackout.push(fele);\n        return fele;\n    }  \n\n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return stackin.empty() && stackout.empty();\n    }\n    \nprivate:     \n    stack<int> stackin;\n    stack<int> stackout;\n\n};\n```\n**复杂度**\n时间复杂度：出栈入栈需要循环O（N），N为栈元素数量\n空间复杂度：需要额外一个栈进行出队操作，O（N）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919355441","body":"**思路**\n采用官方思路：利用单调栈存储\n遇到一个数小于栈的最大值，只保留最大值，否则就相当于增加一个块\n弹出递增的，以前的递增会因为一个低值而必须把这个低值包含进去\n**代码**\n```C++\nclass Solution {\npublic:\n     int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stack;\n        for(int i =0;i<arr.size();i++){\n            if(!stack.empty()&&stack.top()>arr[i]){\n                //遇到一个数小于栈的最大值，只保留最大值，否则就相当于增加一个块\n                int max = stack.top();\n                //弹出递增的，以前的递增会因为一个低值而必须把这个低值包含进去\n                while(!stack.empty()&&stack.top()>arr[i]){\n                    stack.pop();\n                }\n                stack.push(max);\n            }else{\n                stack.push(arr[i]);\n            }\n        }\n        return stack.size();\n    }\n};\n\n```\n**复杂度**\n时间复杂度：遍历O（N）\n空间复杂度：栈存储，最大O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920995603","body":"**思路**\n找到k的位置，进行分割\nk后面的尾部挪到头部，k指向null\n****\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        //boundary condition\n        if(head == nullptr || head->next == nullptr || k == 0){\n            return head;\n        }\n        ListNode * p = head;\n        int len = 0;\n        while(p->next != nullptr)\n        {\n            p = p->next;\n            len++;\n        }\n        k %= len;\n        ListNode *fa = head;\n        ListNode *sl = head;\n        \n        while (fa->next != nullptr) {\n            if (k-- <= 0) {\n                sl = sl->next;\n            }\n            fa = fa->next;\n        }\n        fa->next = head;\n        ListNode* rehead = sl->next; //make sl->next as the head\n        sl->next = nullptr; //make sl-nest as the tail \n        return rehead;\n        }\n};\n\n```\n**复杂度**\n时间复杂度：O（N）\n空间复杂度：O（1）","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922474360","body":"**思路**\r\n利用两个指针走A+B+C长度一定会相交，找出那个相交点\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(headA == NULL || headB == NULL){\r\n            return NULL;\r\n        }\r\n        ListNode *hA = headA;\r\n        ListNode *hB = headB;\r\n        while(hA != hB)\r\n        {\r\n            hA = hA == NULL ? headB : hA->next;\r\n            hB = hB == NULL ? headA : hB->next;\r\n        }\r\n        return hA;\r\n    }\r\n};\r\n```\r\n**复杂度**\r\n时间复杂度：遍历链表O（N）\r\n空间复杂度：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flame0409":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916703356","body":"### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n**思路：**\n\n1. 尝试了转整数进行相加后再次转回数组，遇到了越界问题。\n2. 按位相加\n\n**Java代码**\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n       List<Integer> res = new ArrayList<>();\n       for(int i = num.length-1; i >= 0 || k > 0 ; i--){\n           if(i >=0 ){\n               k = k + num[i];\n           }\n           res.add(0,  k % 10);\n           k = k / 10;\n       }\n       return res;\n    }\n```\n\n时间复杂度：*O(max(n,k)*n)*\n\n空间复杂度：*O(1)*\n\n优化：\n\n1.res尾插入，在返回前进行reverse\n\n时间复杂度：O(max(*n*,*k*))\n\n2.使用LinkedList\n\n时间复杂度：O(max(*n*,*k*))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917360057","body":"class Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = -10000;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) loc = i;\n            ans[i] = i - loc;\n        }\n\n        prev = 10000;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) loc = i;\n            ans[i] = Math.min(ans[i], loc - i);\n        }\n\n        return ans;\n    }\n}\n空间复杂度：O（n）\n时间复杂度：O（n）：两次遍历\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917533178","body":"### 1381.设计一个支持增量操作的栈(91每日)\n\njava：\n\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n     public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top != stack.length -1){\n            ++top;\n            stack[top] = x;\n        }\n\n    }\n    \n    public int pop() {\n\t\tif(top == -1){\n            return -1;\n        }\n        top--;\n        return stack[top+1];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0; i<Math.min(k, top+1); i++){\n            stack[i] += val;\n        } \n    }\n}\n```\n\n时间复杂度：除increment为O(k)外，其余操作为O（1）\n\n空间复杂度：O(maxSize)\n\n优化：如何降时间复杂度？\n\n使用incre[top]来表示栈的最上面需要累加的内容，每次pop时候进行累加\n\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n    \n    int incre[];\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        incre = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top != stack.length -1){\n            ++top;\n            stack[top] = x;\n        }\n\n    }\n    \n    public int pop() {\n\t\tif(top == -1){\n            return -1;\n        }\n        \n        int num_pop = stack[top] + incre[top];\n        if(top != 0){\n            incre[top -1] += incre[top];\n        }\n        incre[top] = 0;\n        top--;\n        return num_pop;\n    }\n    \n    public void increment(int k, int val) {\n        if(Math.min(k-1, top) >= 0){\n            incre[Math.min(k-1, top)] += val;\n        }\n    }\n}\n```\n\n时间复杂度：increment下降为O(1)\n\n空间复杂度O(2*maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917999634","body":"### 思路\n（最初想到的是用迭代，但是不太好控制，看了题解后选择使用栈，是在略菜，一边自己动手一边照着改）\n思路就是压栈，子字符串压栈，最后依次拿出来，与对应的重复次数做循环叠加后再入栈，作为上一个字符串的子字符串，最后完成全部的字符串\n\n```java\nclass Solution {\n     int ptr = 0 ;\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        int rep = 1; //rep设为重复次数\n        StringBuffer c_str = new StringBuffer();//用于压栈的子字符串\n       while(ptr < s.length()){\n           char chr = s.charAt(ptr);\n           if(Character.isDigit(chr)){\n               String digits = getDigits(s);//从ptr开始，为数字，依次进栈\n               stk.addLast(digits);\n           }\n           else if(Character.isLetter(chr)||chr == '['){\n               //开始字符压栈\n               stk.addLast(String.valueOf(s.charAt(ptr++)));\n           }\n           else{//右括号\n               ++ptr;//跳过括号，直接进行一个字符串的组装\n               LinkedList<String> sub = new LinkedList<>();\n               while (!\"[\".equals(stk.peekLast())){   // peeklast：检查队尾元素，出栈，遇见了左括号停止\n                   sub.addLast(stk.removeLast());\n               }\n               //子字符串翻转\n               Collections.reverse(sub);\n               stk.removeLast();//左字符串弹出\n               rep = Integer.parseInt(stk.removeLast());//取出重复字符串的string形式，转成int\n               StringBuffer stringBuffer = new StringBuffer();\n               String sub_str = getString(sub);\n               while(rep-- > 0){\n                   stringBuffer.append(sub_str);\n               }\n               stk.add(stringBuffer.toString());\n           }\n\n       }\n        return getString(stk);\n    }\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n\n}\n```\n\n复杂度分析：\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918718450","body":"思路：竹筒倒豆子，两个栈，一边接受进来的数据，遇见pop，全部倒到出去的栈。实现FIFO\n\n```java\nclass MyQueue {\n\n    Deque<Integer> instack;\n    Deque<Integer> outstack;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        instack = new LinkedList<>();\n        outstack = new LinkedList<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        instack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(outstack.isEmpty()){\n            while (!instack.isEmpty()) {\n                outstack.push(instack.pop());\n            }\n        }\n        return outstack.pop();\n\n        \n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(outstack.isEmpty()){\n             while (!instack.isEmpty()) {\n                outstack.push(instack.pop());\n            }\n        }\n        return outstack.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return (outstack.isEmpty()&&instack.isEmpty());\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n时间复杂度：O(1), pop的遍历复杂度为n，但是n次pop只需要进行一次的翻转，所以均摊复杂度为1\n\n空间复杂度：O(n), 需要两个栈，总大小为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919763559","body":"### [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)（91每日9.14）\n\n**思路：**\n\n使用单调栈融合：\n\nKey：单调减小的序列一定在一个块中\n\n1. 找到目前单调减小下标范围内最大值，入栈\n2. 下一个值大于最大值吗？\n3. 若大于，可作为下一个块入栈\n4. 若小于，需要融入前面的最大值所代表的块\n\njava\n\n```\npublic int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stk = new LinkedList<>();\n        //int top = 0;\n        for(int num : arr){\n            if(!stk.isEmpty() && num < stk.peek()){\n               int max = stk.pop();\n               while(!stk.isEmpty() && num < stk.peek()){\n                   stk.pop();\n               }\n               stk.push(max);\n            }\n            else {\n                stk.push(num);\n            }\n        }\n        return stk.size();\n\n    }\n```\n\n时间复杂度：O(N)，里面的while语句遍历次数为块内小数融堆时候的移动的次数。\n\n空间复杂度：顺序时为O(N)，逆序为O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920528393","body":"思路：\n\n- 先求出长度\n- k = k%len\n- 链接首位，成环\n- 头指针移动len -k，就成为了新的头指针\n- 解环\n\njava\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n\n\n        ListNode tail = new ListNode();\n        tail = head;\n        int len = 1;\n        while(tail.next != null){\n            len++;\n            tail = tail.next;\n        }\n        k = k % len;\n        tail.next = head;//先成环\n        for(int i = 0; i < len-k ; i++){\n            tail = tail.next;\n        }\n        ListNode res = tail.next;\n        tail.next = null;\n        return res;\n    }\n}\n```\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921390730","body":"思路：**\n\n不要怕变量多，变量多的话指针才会更加清晰。\n\n就是四个指针，中间两个换位置，头尾用于重新连接\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null)return head;\n        ListNode prehead = new ListNode();\n        prehead.next = head;\n        ListNode first = head;\n        ListNode ret = first.next;\n        while(first != null && first.next != null){\n            ListNode second = first.next;\n            ListNode behind = second.next;\n            //逆转\n            prehead.next = second;\n            second.next = first;\n            first.next = behind;\n\n            prehead = first;\n            first = behind;\n        }\n        return ret;\n    }\n}\n```\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922494945","body":"public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode iterA = headA, iterB = headB;\n        while (iterA != iterB) {\n            iterA = iterA == null ? headB : iterA.next;\n            iterB = iterB == null ? headA : iterB.next;\n        }\n        return iterA;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Zhi22":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916705363","body":"# 题目名称：989. 数组形式的整数加法\n## 题目链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer/\n## 思路\n1. 将k转成和num格式一致的数组\n2. 从后向前将两个数组按位相加，并将结果保存至一个新建的数组的末尾，并用变量保存是否进位\n3. 将新建数组逆转并返回\n## 代码\n* python3\n```python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        k_str = str(k)\n        k_arr = []\n        for ch in k_str:\n            k_arr.append(int(ch))\n        addOne = 0\n        ret = []\n        while num or k_arr or addOne:\n            ret.append(0)\n            if k_arr:\n                ret[-1] += k_arr[-1]\n                k_arr.pop()\n            if num:\n                ret[-1] += num[-1]\n                num.pop()\n            ret[-1] += addOne\n            addOne = 1 if ret[-1] > 9 else 0\n            ret[-1] %= 10\n        ret.reverse()\n        return ret\n```\n## 算法复杂度\n- 时间：O(N)\n- 空间：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428443","body":"# 题目名称：821. 字符的最短距离\n\n## 题目链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 思路\n双向遍历，取最小值\n## 代码\n* python3\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ls = len(s)\n        prev = float('inf')\n        ans = [float('inf') for _ in range(ls)]\n        for i in range(ls):\n            if s[i] == c:\n                prev = i\n            ans[i] = abs(i - prev)\n        for i in range(ls - 1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], abs(i - prev))\n        return ans\n```\n\n## 算法复杂度\n\n- 时间：O(2N)\n\n- 空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917656974","body":"## 思路\n用数组模拟栈，并用变量记录栈顶下标\n## 代码\n\n* python3\n\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.arr = [0] * maxSize\n        self.top = -1\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if self.top < self.maxSize - 1:\n            self.top += 1\n            self.arr[self.top] = x\n\n    def pop(self) -> int:\n        if self.top >= 0:\n            self.top -= 1\n            return self.arr[self.top + 1]\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.top + 1)):\n            self.arr[i] += val\n```\n\n## 算法复杂度\n\n- 时间：push和pop均为O(1), increment为O(N)\n\n- 空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918296704","body":"## 思路\n* 新建一个栈\n* 遍历字符串，除非遇到\" ] \"，依次将字符入栈，如果遇到 “ ] ”. 将栈中字符重复保存至最终的返回值中\n\n## 代码\n* python3\n\n```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        ans = []\n        for ch in s:\n            if ch == ']':\n                cur_stack = []\n                while ans[-1] != '[':\n                    cur_stack.append(ans.pop())\n                ans.pop()\n                order = 1\n                count = 0\n                while ans and ans[-1].isnumeric():\n                    count += (int(ans.pop()) * order)\n                    order *= 10\n                for _ in range(count):\n                    ans.extend(cur_stack[::-1])\n            else:\n                ans.append(ch)\n        return ''.join(ans)\n```\n\n## 算法复杂度\n\n- 时间：O(N)\n\n- 空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918898645","body":"## 思路\n使用两个后入先出栈，当pop时，将其中一个栈转移至另一个栈即可实现先入先出栈\n## 代码\n\n* python3\n\n```python3\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.in_stack = []\n        self.out_stack = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.in_stack.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.out_stack:\n            if self.in_stack:\n                while self.in_stack:\n                    self.out_stack.append(self.in_stack.pop())\n                return self.out_stack.pop()\n            else:\n                return -1        \n        else:\n            return self.out_stack.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if not self.out_stack:\n            if self.in_stack:\n                while self.in_stack:\n                    self.out_stack.append(self.in_stack.pop())\n            else:\n                return -1\n        return self.out_stack[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not bool(len(self.in_stack) or len(self.out_stack))\n```\n\n## 算法复杂度\n\n- 时间：除了pop为O(N)，其它均为O(1)\n\n- 空间：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921739883","body":"## 思路\n* 在链表前先插入一个假节点\n* 使用三个指针分别指向待换位的两节点及其之前的一个节点\n* 执行换位\n* 将三个指针指向新的待换位的两节点及其之前的一个节点，以此类推\n## 代码\n\n* python3\n\n```python3\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        dummy = ListNode(0, head)\n        pre, slow, fast = dummy, head, head.next\n        while fast:\n            next_node = fast.next\n            pre.next = fast\n            fast.next = slow\n            slow.next = next_node\n            pre = slow\n            if slow.next:\n                slow = slow.next\n            if slow.next:\n                fast = slow.next\n            else:\n                fast = None\n        return dummy.next\n```\n\n## 算法复杂度\n\n- 时间：O(N)\n\n- 空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dongzegithub":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916708579","body":"# [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n## 思路\r\n思路主要体现在加法模板：\r\n1. 和 = A的当前位 + B的当前位 + 进位\r\n2. 当前值 = 和 % 10\r\n3. 进位 = 和 / 10\r\n4. 循环条件： A/B所有位都遍历完成\r\n5. 最后检查一次进位，若不为0，则需要单独加一位\r\n\r\n## 代码\r\n```java\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int i = num.length - 1;\r\n        int carry = 0;\r\n        int sum = 0;\r\n        while (i >= 0 || k > 0) {\r\n            int n = i >= 0 ? num[i] : 0;\r\n            int m = k > 0 ? k % 10 : 0;\r\n            k = k/10;\r\n            i--;\r\n\r\n            sum = n + m + carry;\r\n            carry = sum / 10;\r\n            res.add(sum % 10);\r\n        }\r\n        if (carry != 0) {\r\n            res.add(carry);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```\r\n\r\n## 复杂度分析\r\n**复杂度为O(N)**\r\nwhile循环的复杂度为  `O(n + m)`  \r\n最后反转复杂度为 `O(x/2)` \r\n综合起来算法复杂度为O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917367896","body":"# [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n## 较优思路（参考官方）\n1. 距离最近的字符只存在于该字符的左右两端\n2. 从左向右遍历，preIndex记录上一个c字符的位置，此时`i - preIndex`即为最小距离\n3. 从右向左遍历，preIndex记录上一个c字符的位置，此时`preIndex - i`即为最小距离\n\n**注意**\npreIndex的初始值要可以兼容未遍历到字符c时的情况\n\n## 代码\n```java\n    public int[] shortestToChar(String s, char c) {\n        int length = s.length();\n        char[] chars = s.toCharArray();\n        int[] res = new int[length];\n\n        int preIndex = -(length * 2);\n        for (int i = 0; i < length; i++) {\n            if (chars[i] == c) {\n                preIndex = i;\n            }\n            res[i] = i - preIndex;\n        }\n\n        preIndex = length * 2;\n        for (int i = length - 1; i >= 0; i--) {\n            if (chars[i] == c) {\n                preIndex = i;\n            }\n            res[i] = Math.min(res[i], preIndex - i);\n        }\n        return res;\n    }\n```\n\n## 复杂度分析\n**时间复杂度为O(N)**\n遍历了两次，每次需要执行N次，总的时间复杂度还是为O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917644205","body":"# [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n## 思路\n该题目在于实现三个方法，而每个方法都可以做到O(1)的时间复杂度\n总思路：使用`originStack`存储原始值，使用`incrementArr`存储增值操作\n1. push： 将原始值入栈(originStack)\n2. pop: 栈不为空时，取出栈顶；此时需要把栈顶的increment向下传递  \n3. increment: 将增值记录在最上层元素对应的index上，保证可以向下传递\n\n## 代码\n```java\npublic class CustomStack {\n    private Stack<Integer> originStack = new Stack<>();\n\n    private int[] incrementArr;\n\n    private int maxSize;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        incrementArr = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (originStack.size() >= maxSize) {\n            return;\n        }\n        originStack.push(x);\n        // 新元素入栈，清空之前增量数组中的缓存值\n        incrementArr[originStack.size() - 1] = 0;\n    }\n\n    public int pop() {\n        if (originStack.isEmpty()) {\n            return -1;\n        }\n        int index = originStack.size() - 1;\n        int origin = originStack.pop();\n        if (index > 0) {\n            incrementArr[index - 1] = incrementArr[index - 1] + incrementArr[index];\n        }\n        return origin + incrementArr[index];\n    }\n\n    public void increment(int k, int val) {\n        if (k <= 0 || originStack.isEmpty()) {\n            return;\n        }\n        int index = Math.min(originStack.size(), k) - 1;\n        incrementArr[index] += val;\n    }\n\n    public int pop1() {\n        if (originStack.empty()) {\n            return -1;\n        }\n        int index = originStack.size() - 1;\n        int origin = originStack.pop();\n        // pop时，需要pop栈顶 + 增量数组当前值\n        return origin + incrementArr[index];\n    }\n\n    public void increment1(int k, int val) {\n        if (k <= 0) {\n            return;\n        }\n        int capacity = Math.min(originStack.size(), k);\n        for (int i = 0; i < capacity; i++) {\n            incrementArr[i] += val;\n        }\n    }\n}\n```\n\n## 复杂度分析\n所有操作的**时间复杂度为O(1)**\n空间复杂度为O(maxSize)：开辟了一个maxSize大小的辅助数组  \n**注：**为了使常数时间最小，还可以使用数组结构代替栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918308102","body":"# [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n## 思路\n由括号匹配问题联想到此题亦可以使用栈来解决，主要思路为\n1. 遍历字符串，非`]`字符进栈\n2. 遇到`]`字符开始出栈\n- 出栈如果是字符，则记录，直到遇到`[`字符\n- 继续出栈，通过数字得到重复次数，直到遇到非数字字符\n- 将所有出栈记录的字符按解析的次数再压入栈中\n3. 如此循环，直到遍历完给定字符串\n4. 倒序输出栈中的字符即可\n\n## 代码\n```java\npublic class CustomStack {\n    private Stack<Integer> originStack = new Stack<>();\n\n    private int[] incrementArr;\n\n    private int maxSize;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        incrementArr = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (originStack.size() >= maxSize) {\n            return;\n        }\n        originStack.push(x);\n        // 新元素入栈，清空之前增量数组中的缓存值\n        incrementArr[originStack.size() - 1] = 0;\n    }\n\n    public int pop() {\n        if (originStack.isEmpty()) {\n            return -1;\n        }\n        int index = originStack.size() - 1;\n        int origin = originStack.pop();\n        if (index > 0) {\n            incrementArr[index - 1] = incrementArr[index - 1] + incrementArr[index];\n        }\n        return origin + incrementArr[index];\n    }\n\n    public void increment(int k, int val) {\n        if (k <= 0 || originStack.isEmpty()) {\n            return;\n        }\n        int index = Math.min(originStack.size(), k) - 1;\n        incrementArr[index] += val;\n    }\n\n    public int pop1() {\n        if (originStack.empty()) {\n            return -1;\n        }\n        int index = originStack.size() - 1;\n        int origin = originStack.pop();\n        // pop时，需要pop栈顶 + 增量数组当前值\n        return origin + incrementArr[index];\n    }\n\n    public void increment1(int k, int val) {\n        if (k <= 0) {\n            return;\n        }\n        int capacity = Math.min(originStack.size(), k);\n        for (int i = 0; i < capacity; i++) {\n            incrementArr[i] += val;\n        }\n    }\n}\n```\n\n## 复杂度分析\n**时间复杂度为O(N)**\n只遍历了一遍字符串，所以时间复杂度为O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919231671","body":"# [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n## 思路\n栈实现队列思路比较简单，主要设计一个进栈和出栈  \n只要保证只有在出栈为空时再压入新元素即可达到目的\n\n## 代码\n```java\nclass MyQueue {\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n\n    }\n    \n    Stack<Integer> inStack = new Stack<>();\n    Stack<Integer> outStack = new Stack<>();\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (outStack.isEmpty()) {\n            while (!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.pop();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        if (outStack.isEmpty()) {\n            while (!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n```\n\n## 复杂度分析\n所有操作的**时间复杂度为O(1)**\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920136533","body":"# [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n[toc]\n## 思路\n此题可使用单调栈解决：  \n不管划分多少个块，每块的最大值，要保持单调递增。为实现上述条件，栈需满足\n1. 如果栈为空，或者栈顶小于等于当前元素，则直接将当前元素压入栈\n2. 否则，即情况为栈顶元素大于当前元素，不满足单调性，需要出栈\n- a. 记录当前栈顶，即此时的最大值\n- b. 栈中元素逐个出栈，直到符合条件1（栈为空 或 栈顶不大于当前值），保证了单调性\n- c. 此时再将a中记录的最大值压入栈中，作为当前块的最大值\n3. 遍历完数组，则栈大小即为块大小\n\n## 代码\n```java\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n\n        for (int cur : arr) {\n            if (stack.isEmpty() || stack.peek() <= cur) {\n                stack.push(cur);\n            } else {\n                int temp = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > cur) {\n                    stack.pop();\n                }\n                stack.push(temp);\n            }\n        }\n        return stack.size();\n    }\n```\n\n## 复杂度分析\n**时间复杂度为O(N)**：只遍历了一遍arr\n空间复杂度为O(N): 使用了辅助栈，并且最坏情况下可能压入arr中所有元素\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921011865","body":"# [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n[toc]\n## 思路\n链表题目，主要是通过画图分析，重点查看边界取值问题，本题目主要是以下步骤：   \n1. 遍历一遍链表，获得链表长度\n2. 将头尾相连(end.next = head)\n3. 求出需要迁移的距离(dist = n - (k % n))\n4. 从end处移动dist部，到达新头的前一个节点\n5. end.next 即为新head，返回结果前，也需要将环断开(end.next = null;)\n\n## 代码\n```java\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        ListNode iter = head;\n        int num = 1;\n        while (iter.next != null) {\n            iter = iter.next;\n            num++;\n        }\n        int add = num - (k % num);\n        if (add == num) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode res = iter.next;\n        iter.next = null;\n        return res;\n    }\n```\n\n## 复杂度分析\n**时间复杂度为O(N)**\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921903303","body":"```java\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode first = head;\n        ListNode second = head.next;\n        ListNode pre;\n        ListNode next = second.next;\n        \n        head = second;\n\n        while (true) {\n            first.next = second.next;\n            second.next = first;\n            pre = first;\n            pre.next = next;\n            if (next == null || next.next == null) {\n                break;\n            }\n            first = next;\n            second = next.next;\n            next = next.next.next;\n        }\n        return head;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916714070","body":"### 思路\r\n两数和按位相加的思路\r\n### js代码\r\n```JavaScript\r\n    let n = num.length-1,carry=0,res=[]\r\n    while(n>=0||k!=0){\r\n        const a = n>=0?num[n]:0\r\n        const b = k!=0?k%10:0\r\n        const sum = a+b+carry\r\n        carry = Math.floor(sum / 10)\r\n        res.push(sum%10)\r\n        n--\r\n        k = Math.floor(k / 10)\r\n    }\r\n    if (carry) res.push(carry)\r\n    return res.reverse()\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n + logk +reverse的长度 )，其中 n 为数组的长度；k以10为底的对数操作次数，来自于reverse的时间消耗\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917419827","body":"### 思路\r\n贪心\r\n\r\n### js代码\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  let res = []\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (s[i] === c) res[i] = i;\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\r\n  }\r\n\r\n  for (let i = 0; i < res.length; i++) {\r\n    res[i] = Math.abs(res[i] - i);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n )\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917630119","body":"### 思路\n用js的数组操作去实现栈\n### js代码\n```JavaScript\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(x);\n};\n\nCustomStack.prototype.pop = function() {\n    return this.stack.length ? this.stack.pop() : -1;\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    let length = Math.min(k, this.stack.length);\n    for (let i = 0; i < length; i++) {\n        this.stack[i] += val;\n    }\n};\n\n```\n### 复杂度分析\n- 时间复杂度 push:O(1)、pop：O(1)、increment：O(N) ，N为min(K， 栈中元素的个数)\n- 空间复杂度：O(N)，N为maxSize","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918087389","body":"### 思路\n栈的思路去实现\n### js代码\n```JavaScript\nfunction decodeString(S) {\n    let stack = [];\n    let numstr = '';\n    for (let s of S) {\n        if (Number.isInteger(+s)) {\n            numstr += s;\n            continue;\n        }\n        if (numstr) {\n            stack.push(+numstr);\n            numstr = '';\n        }\n        if (s != ']') {\n            stack.push(s);\n            continue;\n        }\n        let str = '';\n        while (stack.length && stack.slice(-1) != '[') {\n            let top = stack.pop();\n            top += str;\n            str = top;\n        }\n        stack.pop();\n        let count = +stack.pop();\n        let pushStr = str.repeat(count);  \n        stack.push(pushStr);\n    }\n    return stack.join('');\n}\n\n\n```\n\n### 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919201130","body":"### 思路\n用两个栈去互相倒\n### js代码\n```JavaScript\nlet  MyQueue = funtion (){\n  this.inStack = []\n  this.outStack = []\n}\nMyQueue.prototype.push = function(x){\n  this.inStack.push(x)\n}\nMyQueue.prototype.inOut = function(){\n  while(this.inStack.length){\n    this.outStack.push(this.inStack.pop())\n  }\n}\nMyQueue.prototype.pop = function(){\n  if(!this.outStack.length){\n    this.inOut()\n  }\n  return this.outStack().pop()\n}\nMyQueue.prototype.peek = function(){\n  if(!this.outStack.length){\n    this.inOut()\n  }\n  return this.outStack.slice(-1)\n}\nMyQueue.prototype.empty = function(){\n  return this.outStack.length === 0 && this.inStack.length === 0;\n}\n\n```\n\n### 复杂度分析\n- 时间复杂度 O(1)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919965153","body":"### 思路\n单调栈\n### js代码\n```JavaScript\nvar maxChunksToSorted = function (arr) {\n  const stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    a = arr[i];\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\n      const cur = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > a) stack.pop();\n      stack.push(cur);\n    } else {\n      stack.push(a);\n    }\n  }\n  return stack.length;\n};\n\n```\n\n### 复杂度分析\n- 时间复杂度: O(N) 其中 N 为数组长度\n- 空间复杂度: O(N) 其中 N 为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920825493","body":"### 思路\n旋转\n### js代码\n```JavaScript\nvar rotateRight = function (head, k) {\n  if (!head || !head.next) return head;\n  let count = 0,\n    now = head;\n  while (now) {\n    now = now.next;\n    count++;\n  }\n  k = k % count;\n  let slow = (fast = head);\n  while (fast.next) {\n    if (k-- <= 0) {\n      slow = slow.next;\n    }\n    fast = fast.next;\n  }\n  fast.next = head;\n  let res = slow.next;\n  slow.next = null;\n  return res;\n};\n\n```\n\n### 复杂度分析\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921713809","body":"### 思路\n实现某两个节点的两两互换，再将当前节点指向新的起点\n### js代码\n```JavaScript\nvar swapPairs = function (head) {\n  if (!head || !head.next) return head;\n  let res = head.next;\n  let now = head;\n  let preNode = new ListNode();\n  preNode.next = head;\n  while (now && now.next) {\n    let nextNode = now.next;\n    let nnNode = nextNode.next;\n    now.next = nnNode;\n    nextNode.next = now;\n    preNode.next = nextNode;\n    preNode = now;\n    now = nnNode;\n  }\n  return res;\n};\n\n```\n\n### 复杂度分析\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922256530","body":"### 思路\n### js代码\n```JavaScript\nvar sortedListToBST = function (head) {\n  if (!head) return null;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast != tail && fast.next != tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head, slow);\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n\n```\n\n### 复杂度分析\n- 时间复杂度: O(nlogn)\n- 空间复杂度: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922470176","body":"### 思路\n双指针\n### js代码\n```JavaScript\nvar getIntersectionNode = function (headA, headB) {\n  let a = headA,\n    b = headB;\n  while (a != b) {\n    a = a === null ? headB : a.next;\n    b = b === null ? headA : b.next;\n  }\n  return a;\n};\n\n```\n\n### 复杂度分析\n- 时间复杂度: O(n)\n- 空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GReyQT":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916716466","body":"## 思路\r\n直接在数组中相加，标记进位符号，对进位处进行处理\r\n\r\n\r\n## cpp\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n\r\n        bool up = false;    //进位标识符\r\n\r\n        vector<int> numk;\r\n        while (k > 0)\r\n        {\r\n            numk.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        reverse(numk.begin(), numk.end());  //逆转，尾部为个位数\r\n\r\n        vector<int> res;\r\n        num.size() >= numk.size() ? res = num: (res = numk,numk=num);\r\n\r\n        for (auto it = res.rbegin(); it != res.rend(); ++it)    //从个位开始相加\r\n        {\r\n            if (up)\r\n            {\r\n                *(it - 1) %= 10;\r\n                if ((*it += 1) >= 10)\r\n                {\r\n                    up = true;\r\n                }\r\n                else\r\n                {\r\n                    up = false;\r\n                }\r\n                \r\n            }\r\n\r\n            if (numk.size() > 0)\r\n            {\r\n                if ((*it += numk.back()) >= 10) \r\n                {\r\n                    up = true;\r\n                }\r\n\r\n                numk.pop_back();        //尾出\r\n            }\r\n\r\n        }\r\n\r\n\r\n        if (up) //表示头部需要进位\r\n        {\r\n            reverse(res.begin(), res.end());    //将头部置尾\r\n\r\n            auto it = res.end()-1;\r\n\r\n            *it %= 10;  //求余\r\n\r\n            res.push_back(1);   //尾插\r\n\r\n            reverse(res.begin(), res.end());    //恢复\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度分析\r\n-     时间复杂度：O(n + logk +reverse的长度 )，其中 n 为数组的长度；k以10为底的对数操作次数，来自于reverse的时间消耗\r\n-     空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917363774","body":"## 思路\r\n获取下标，进行下标相减取最小\r\n\r\n## cpp\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n\r\n        vector<int> ac,res;\r\n        int length = s.size();\r\n\r\n        for(int i=0; i < length; ++i)   //获取字符串的下标，及字符C的下标\r\n        {\r\n            res.push_back(i);\r\n            if(c == s[i])\r\n                ac.push_back(i);\r\n        }\r\n\r\n        for(auto it = res.begin(); it != res.end(); ++it)   //使字符串的下标减去字符C的下标并取最小值\r\n        {\r\n            int min = length;\r\n            for(auto at = ac.begin(); at != ac.end(); ++at)\r\n            {\r\n                int temp = abs((*it)-(*at));\r\n                if(min >= temp)\r\n                    min = temp;\r\n            }\r\n            *it = min;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917545294","body":"## 思路\r\n取巧使用自带的vector\r\n## cpp\r\n```cpp\r\nclass CustomStack {\r\nprivate:\r\n    int _size;\r\n    int _maxsize;\r\n    vector<int> stack;\r\n    \r\npublic:\r\n    CustomStack(int maxSize) {\r\n        _maxsize=maxSize;\r\n        _size=0;\r\n        \r\n    }\r\n    \r\n    void push(int x) {\r\n        if(_size < _maxsize)\r\n        {\r\n            stack.push_back(x);\r\n            _size++;\r\n        }            \r\n\r\n    }\r\n    \r\n    int pop() {\r\n        if(0 == stack.size())\r\n            return -1;\r\n        \r\n        int re = stack.back();\r\n        \r\n        stack.pop_back();\r\n        _size--;                   \r\n        \r\n        return re;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if(k > stack.size())\r\n            k=stack.size();\r\n            \r\n        int count=0;\r\n        for(auto it = stack.begin(); it != stack.end(); ++it)\r\n        {\r\n            if(count == k)\r\n                break;\r\n                \r\n            *it += val;\r\n            count++;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n##复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918135959","body":"## 思路\r\n还未解答出来，明天继续\r\n## cpp\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        vector<int> count;\r\n        vector<int> flag;    //括号的下标\r\n        \r\n        \r\n        vector<vector<string>> str;//处理多重括号\r\n        \r\n        \r\n        \r\n        \r\n        int size = s.size();\r\n        for(int i=0; i<size; ++i)\r\n        {\r\n            if(isdigit(s[i]))\r\n            {\r\n                count.push_back(s[i]);\r\n                flag.push_back(++i);    //[的下标\r\n                vector<string> f{\"[\"};\r\n                str.push_back(f);\r\n            }\r\n            else if(s[i] ==']')\r\n            {\r\n                string in;\r\n                for(int j=flag.back(); j<i; ++j)//获取[]中的字符\r\n                {\r\n                    in.push_back();\r\n                }\r\n                \r\n                string temp;\r\n                for(int j=0; j<count.back(); ++j)//翻倍\r\n                {\r\n                    temp.append(in);\r\n                }\r\n                \r\n                \r\n            }\r\n            else\r\n            {\r\n                \r\n            }\r\n            \r\n            \r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n##复杂度\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919107546","body":"## 思路\r\n一个栈作为数据存储栈\r\n一个作为数据处理时的中转栈\r\n## cpp\r\n```cpp\r\nclass MyQueue {\r\npublic:\r\n    stack<int> stack1,stack2;\r\n\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n        //创建，初始化清空\r\n        while(!stack1.empty())\r\n        {\r\n            stack1.pop();\r\n        }\r\n        while(!stack2.empty())\r\n        {\r\n            stack2.pop();\r\n        }\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        int del;\r\n        \r\n        while(!stack1.empty())\r\n        {\r\n            stack2.push(stack1.top());\r\n            stack1.pop();\r\n        }\r\n        del = stack2.top();\r\n        stack2.pop();\r\n        \r\n        while(!stack2.empty())\r\n        {\r\n            stack1.push(stack2.top());\r\n            stack2.pop();\r\n        }\r\n        \r\n        return del;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        int top;\r\n        \r\n        while(!stack1.empty())\r\n        {\r\n            stack2.push(stack1.top());\r\n            stack1.pop();\r\n        }\r\n        top = stack2.top();\r\n        \r\n        \r\n        while(!stack2.empty())\r\n        {\r\n            stack1.push(stack2.top());\r\n            stack2.pop();\r\n        }\r\n        \r\n        return top;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        if(stack1.empty())\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n##复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920072880","body":"## cpp\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        int n = arr.size();\r\n        unordered_map<int, int> num2cnt;\r\n        int res = 0;\r\n        int isEqual = 0;\r\n        vector<int> sortArr = arr;\r\n        sort(sortArr.begin(), sortArr.end());\r\n        for (int i = 0; i < n; ++i)\r\n        {\r\n            ++num2cnt[arr[i]];\r\n            if (num2cnt[arr[i]] == 0)\r\n            {\r\n                --isEqual;\r\n            }\r\n            else if (num2cnt[arr[i]] == 1)\r\n            {\r\n                ++isEqual;\r\n            }\r\n\r\n            // 需要去减去\r\n            --num2cnt[sortArr[i]];\r\n            // 同理\r\n            if (num2cnt[sortArr[i]] == 0)\r\n            {\r\n                --isEqual;\r\n            }\r\n            else if (num2cnt[sortArr[i]] == -1)\r\n            {\r\n                ++isEqual;\r\n            }\r\n            if (isEqual == 0)\r\n            {\r\n                ++res;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n##复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920897894","body":"## cpp\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (k == 0 || head == NULL || head->next == NULL) return head;\r\n        int size = 0;\r\n        ListNode* tmp = head;\r\n        while (tmp != NULL) {\r\n            tmp = tmp->next;\r\n            size++;\r\n        }\r\n        if (k % size == 0) return head;\r\n        k = k % size;\r\n        ListNode* dummyHead = new ListNode(0);\r\n        dummyHead->next = head;\r\n        ListNode* fast = dummyHead;\r\n        ListNode* slow = dummyHead; // 快慢指针\r\n        while (k-- && fast != NULL) {\r\n            fast = fast->next;\r\n        }\r\n        while (fast->next != NULL) {\r\n            fast = fast->next;\r\n            slow = slow->next;\r\n        }\r\n        dummyHead->next = slow->next;\r\n        fast->next = head;\r\n        slow->next = NULL;\r\n        head = dummyHead->next;\r\n        delete dummyHead;\r\n        return head;\r\n    }\r\n};\r\n\r\n```\r\n##复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916722801","body":"## 思路\n\n-\t从后往前加，记录进位，注意 k > n 的情况\n\n\n## 代码\n\n\n```\nvector<int> addToArrayForm_0(vector<int> &num, int k)\n{\n    vector<int> res;\n    // 从后往前加，记录进位\n    int flag = 0;\n    int i = num.size() - 1;\n    while(k || (i >= 0))\n    {\n        int tmp;\n        if (i >= 0)\n            tmp = num[i] + k % 10 + flag;\n        else\n        {\n            tmp = k % 10 + flag;\n        }\n        k = k / 10;\n        if(tmp > 9)\n        {\n            tmp = tmp % 10;\n            flag = 1;\n        }\n        else\n        {\n            flag = 0;\n        }\n        res.push_back(tmp);\n        i--;\n    }\n    if (flag)\n        res.push_back(1);\n\n    for (int i = 0; i < res.size() / 2; i++)\n    {\n        int tmp;\n        tmp = res[i];\n        res[i] = res[res.size() - i - 1];\n        res[res.size() - i - 1] = tmp;\n    }\n    return res;\n}\n\n```\n-\t时间复杂度: O(N)，空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917370770","body":"\r\n```\r\nvector<int> shortestTochar(string s, char c)\r\n    {\r\n        vector<int> res, index;\r\n        int len = s.length();\r\n        for(int i = 0; i < len; i++)\r\n        {\r\n            if(s[i] == c)\r\n            {\r\n                index.push_back(i);\r\n            }\r\n        }\r\n        int p = 0;\r\n        for (int i = 0; i < len; i++)\r\n        {\r\n            if (s[i] != c)\r\n            {\r\n                // 出现在第一个c的最左边\r\n                if (p == 0)\r\n                {\r\n                    res.push_back(abs(index[p] - i));\r\n                }\r\n                else  // 出现在中间\r\n                {\r\n                    if (i < index[p])\r\n                        res.push_back(((i - index[p - 1]) < (index[p] - i) ? (i - index[p - 1]) : (index[p] - i)));\r\n                    else\r\n                        res.push_back(i - index[p]);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                res.push_back(0);\r\n                if (p < index.size() - 1)\r\n                    p++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n```\r\n-\t时间复杂度: O(N)，空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917619488","body":"```\nclass CustomStack {\npublic:\n    CustomStack(int maxSize)\n    {\n        maxsize = maxSize;\n        data = {};\n        inc = {};\n        len = 0;\n    }\n\n    void push(int x)\n    {\n        if (len < maxsize)\n        {\n            data.push_back(x);\n            inc.push_back(0);\n            len++;\n        }\n    }\n\n    int pop()\n    {\n        if (len)\n        {\n            len--;\n            int res = data[len] + inc[len];\n            if (len)\n                inc[len - 1] += inc[len];\n            data.pop_back();\n            inc.pop_back();\n            return res;\n        }\n        return -1;\n    }\n\n    void increment(int k, int val)\n    {\n        if (k <= len)\n            inc[k-1] += val;\n        else\n            if (len)\n                inc[len-1] += val;\n    }\nprivate:\n    int maxsize;\n    vector<int> data;\n    vector<int> inc;\n    int len;\n};\n\n```\n-\t时间复杂度: O(1)，空间复杂度：O(len / N)，N为操作数，len为栈的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917925087","body":"```\nstring decodeString(string s)\n    {\n        vector<string> stack;\n        int len = s.length();\n        int stack_len = 0;\n        for (int i = 0 ; i < len; i++)\n        {\n            if (s[i] != ']')\n            {\n                stack.push_back(string(1, s[i]));\n                stack_len++;\n            }\n            else\n            {\n                string repeat_str = \"\";\n                while(stack_len && stack[stack_len - 1] != \"[\")\n                {\n                    repeat_str = stack[stack_len - 1] + repeat_str;\n                    stack.pop_back();\n                    stack_len--;\n                }\n                stack.pop_back();   // 弹出'['\n                stack_len--;\n                string num = \"\";\n                while(stack_len && stack[stack_len - 1] >= \"0\" && stack[stack_len - 1] <= \"9\")\n                {\n                    num = stack[stack_len - 1] + num;\n                    stack.pop_back();\n                    stack_len--;\n                }\n                string tmp = \"\";\n                for (int j = 0; j < atoi(num.c_str()); j++)\n                    tmp += repeat_str;\n                stack.push_back(tmp);\n                stack_len++;\n            }\n        }\n        string res = \"\";\n        for (int i = 0; i < stack.size(); i++)\n        {\n            res += stack[i];\n        }\n        return res;\n    }\n\n```\n-\t时间复杂度: O(N)，空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918865723","body":"```\nclass MyQueue\n{\npublic:\n    MyQueue()\n    {\n        len = 0;\n        backup_len = 0;\n        data = {};\n        databackup = {};\n    }\n\n    void push(int x)\n    {\n        data.push_back(x);\n        len++;\n    }\n\n    int pop()\n    {\n        if (backup_len == 0)\n        {\n            if (len != 0)\n            {\n                while (len)\n                {\n                    int tmp = data[len - 1];\n                    data.pop_back();\n                    databackup.push_back(tmp);\n                    len--;\n                    backup_len++;\n                }\n                int tmp = databackup[backup_len - 1];\n                databackup.pop_back();\n                backup_len--;\n                return tmp;\n            }\n            else\n            {\n                return -1;\n            }\n        }\n        else\n        {\n            int tmp = databackup[backup_len - 1];\n            databackup.pop_back();\n            backup_len--;\n            return tmp;\n        }\n    }\n\n    int peek()\n    {\n        if (databackup.size() == 0)\n        {\n            if (data.size() != 0)\n            {\n                while (len)\n                {\n                    int tmp = data[len - 1];\n                    databackup.push_back(tmp);\n                    data.pop_back();\n                    len--;\n                    backup_len++;\n                }\n                return databackup[backup_len - 1];\n            }\n            else\n            {\n                return -1;\n            }\n        }\n        else\n        {\n           return databackup[backup_len - 1];\n        }\n    }\n\n    bool empty()\n    {\n        if (len || backup_len)\n            return false;\n        return true;\n    }\nprivate:\n    int len;\n    int backup_len;\n    vector<int> data;\n    vector<int> databackup;\n};\n\n```\n-\t最坏时间复杂度: O(N)，平均时间复杂度: O(1)，空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920089162","body":"```\r\nint maxChunksToSorted(vector<int>& arr) {\r\n        vector<int> res;\r\n        int len = 0;\r\n        for (int i = 0; i < arr.size(); i++)\r\n        {\r\n            if (len == 0)\r\n            {\r\n                res.push_back(arr[i]);\r\n                len++;\r\n            }\r\n            else\r\n            {\r\n                int tmp = res[len - 1];\r\n                if (tmp <= arr[i])\r\n                {\r\n                    res.push_back(arr[i]);\r\n                    len++;\r\n                }\r\n                else\r\n                {\r\n                    int tmp = res[len - 1];\r\n                    while(len && (res[len - 1] > arr[i]))\r\n                    {\r\n                        res.pop_back();\r\n                        len--;\r\n                    }\r\n                    res.push_back(tmp);\r\n                    len++;\r\n                }\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n\r\n```\r\n-\t时间复杂度: O(N)，空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920212116","body":"```\r\nListNode* rotateRight(ListNode* head, int k)\r\n    {\r\n        if (k == 0)\r\n            return head;\r\n        ListNode *p = head;\r\n        int len = 0;\r\n        while(p->next)\r\n        {\r\n            len++;\r\n            p = p->next;\r\n        }\r\n        len++;\r\n        k = k % len;\r\n        p->next = head;\r\n        p = head;\r\n        int flag = 0;\r\n        // 找到尾节点\r\n        while(flag != (len - k - 1))\r\n        {\r\n            p = p->next;\r\n            flag++;\r\n        }\r\n        // 赋值头节点\r\n        ListNode *q = p->next;\r\n        //赋值尾节点\r\n        p->next = nullptr;\r\n        return q;\r\n    }\r\n\r\n```\r\n-\t时间复杂度: O(N)，空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921087442","body":"```\r\nListNode* swapPairs(ListNode *head)\r\n    {\r\n        if (head == nullptr)\r\n            return nullptr;\r\n        if (head->next == nullptr)\r\n            return head;\r\n        ListNode *L = head->next;\r\n        ListNode *tmp = head->next->next;\r\n        L->next = head;\r\n        L->next->next = tmp;\r\n        // 记录已交换的尾节点\r\n        ListNode *q = L->next;\r\n        // 记录待交换的第一个节点\r\n        ListNode *p = q->next;\r\n        while(q->next)\r\n        {\r\n            // 记录未交换的第一个节点\r\n            if(p->next == nullptr)\r\n                break;\r\n            tmp = p->next->next;\r\n            // 把待交换第二个节点赋值给q->next\r\n            q->next = p->next;\r\n            // 交换相邻的第一个节点和第二个节点\r\n            p->next->next = p;\r\n            p->next = tmp;\r\n            q = q->next->next;\r\n            p = q->next;\r\n        }\r\n        return L;\r\n    }\r\n\r\n```\r\n-\t时间复杂度: O(N)，空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922168420","body":"```\ndef sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n\n```\n-\t时间复杂度: O(NlogN)，空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922399110","body":"\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n\r\n```\r\n-\t时间复杂度: O(N)，空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Huangxuang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916726896","body":"# 题目：[989. 数组形式的整数加法]([https://leetcode.com/problems/add-to-array-form-of-integer/](https://leetcode.com/problems/add-to-array-form-of-integer/))\r\n\r\n### 思路\r\n\r\n- 如果转换成int在相加会越界\r\n- 先转换成 array 然后再用array 相加\r\n- 今天来不及了，明天改进一下，直接用arry 和数字相加\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        \r\n        //convert K to array type\r\n        ArrayList k_array = intToArray(k);\r\n        //add two arry together and return \r\n        return arraySum (num, k_array);\r\n    }\r\n    \r\n    private ArrayList<Integer> intToArray(int k) {\r\n        ArrayList <Integer> res = new ArrayList();\r\n        if (k == 0) {\r\n            res.add(0);\r\n            return res;\r\n        }\r\n        while (k > 0) {\r\n            int reminder = k % 10;\r\n            res.add(reminder);\r\n            k /= 10;\r\n        }\r\n        //reverse \r\n        ArrayList<Integer> reversed = new ArrayList();\r\n        for (int i = res.size() - 1; i >= 0; i--) {\r\n            reversed.add(res.get(i));\r\n        }\r\n        \r\n        return reversed;\r\n    }\r\n    \r\n    private ArrayList<Integer> arraySum(int[] num, ArrayList<Integer> x) {\r\n        ArrayList<Integer> res = new ArrayList();\r\n        int N = num.length; \r\n        int L = x.size();\r\n        int carray = 0;\r\n        for (int i = 0; i < Math.min(N, L); i++) {\r\n            int sum = num[N - 1 - i] + x.get(L -1 -i)+ carray;\r\n            res.add(sum % 10);\r\n            carray = sum / 10;\r\n            //carray = sum > 9 ? 1 :0;          \r\n        }\r\n        // add all other numbers directly, count carray in \r\n        if (N > L) {\r\n            //num[N - L - 1]  += carray;\r\n            for (int i = N - L - 1; i >= 0; i--) {\r\n                int sum = num[i] + carray;\r\n                res.add(sum % 10);\r\n                carray = sum / 10;\r\n            }\r\n        } \r\n        if (N < L) {\r\n            for (int i = L - N - 1; i >= 0; i--) {\r\n                int sum =  x.get(i) + carray;\r\n                res.add(sum % 10);\r\n                carray = sum / 10;\r\n            }\r\n        }      \r\n        if (carray == 1) {\r\n            res.add(1);\r\n        }\r\n    \r\n        \r\n        Collections.reverse(res);\r\n        return res;\r\n        \r\n    } \r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- \r\n\r\n### attention！\r\n\r\n**int 是2进制的32bit, 10位十进制的数，long是64位，20位10进制的数**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917444127","body":"# 题目：[821. Shortest Distance to a Character]([https://leetcode.com/problems/shortest-distance-to-a-character/](https://leetcode.com/problems/shortest-distance-to-a-character/))\r\n\r\n### 思路\r\n\r\n- 一个字母的左右两边都有可能有最小的距离，所以需要至少遍历两边\r\n- 第一次从左到右，找到距离左边最近的char c 的distance，记录在`res[i]`中如果没有记为i - (-length)\r\n- 第二次从右到左，找到距离右边c的distance，并更新最小距离.\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        \r\n        //find the samlest distance to char c on the left, \r\n        //int pos = Integer.MIN_VALUE;\r\n        int pos = -res.length;\r\n        for (int i = 0; i < res.length; i++) {\r\n            if (s.charAt(i) == c) {\r\n                //res[i] = 0;\r\n                pos = i;\r\n            }\r\n            res[i] = i - pos;\r\n            //System.out.println(\"left to right, res[\" + i + \"] = \" + res[i] );\r\n        }\r\n        \r\n        //find the samllest distance to char c on the right, \r\n        //update res[i] = min(left_dis, right_dis);\r\n        for (int i = res.length - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                pos = i;\r\n            }\r\n            res[i] = Math.min(Math.abs(pos - i), res[i]);\r\n           // System.out.println(\"left to right, pos = \" + pos );\r\n            //System.out.println(\"right to left, res[\" + i + \"] = \" + res[i] );\r\n        }\r\n        \r\n        return res; \r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：O(n)\r\n- 空间：O(n)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917566049","body":"# 题目：[1381. Design a Stack With Increment Operation]([https://leetcode.com/problems/design-a-stack-with-increment-operation/](https://leetcode.com/problems/design-a-stack-with-increment-operation/))\r\n\r\n### 思路\r\n\r\n- 用linkedlist 来实现\r\n- \r\n\r\n### 代码\r\n\r\n```java\r\nclass CustomStack {\r\n    public LinkedList<Integer> list;\r\n    public int maxSize;\r\n    public int size;\r\n\r\n    public CustomStack(int maxSize) {\r\n        // use linked list to implement this stack, always add element to the end, \r\n        //and get element from the end; then bottom k element are the first k element\r\n        list = new LinkedList();\r\n        this.maxSize = maxSize;\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (size >= maxSize) {\r\n            return;\r\n        }\r\n        list.add(x);\r\n        size++;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (size > 0) {\r\n            size--;\r\n            return list.pollLast(); \r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int l = Math.min(k, size);\r\n        for (int i = 0; i < l; i++) {\r\n            list.set(i, list.get(i) +val);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- increment的时间复杂度是On，其他是O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917909916","body":"# 题目：[394. Decode String]([https://leetcode.com/problems/decode-string/](https://leetcode.com/problems/decode-string/))\n\n### 思路\n\n- 用stack来遍历每个字符，如果找到第一个‘】’就该往前去找第一个【\n\n### 代码\n\n```java\npublic class Solution {\n    public String decodeString(String s) {\n        String res = \"\";\n        Stack<Integer> countStack = new Stack<>();\n        Stack<String> resStack = new Stack<>();\n        int idx = 0;\n        while (idx < s.length()) {\n            if (Character.isDigit(s.charAt(idx))) {\n                int count = 0;\n                while (Character.isDigit(s.charAt(idx))) {\n                    count = 10 * count + (s.charAt(idx) - '0');\n                    idx++;\n                }\n                countStack.push(count);\n            }\n            else if (s.charAt(idx) == '[') {\n                resStack.push(res);\n                res = \"\";\n                idx++;\n            }\n            else if (s.charAt(idx) == ']') {\n                StringBuilder temp = new StringBuilder (resStack.pop());\n                int repeatTimes = countStack.pop();\n                for (int i = 0; i < repeatTimes; i++) {\n                    temp.append(res);\n                }\n                res = temp.toString();\n                idx++;\n            }\n            else {\n                res += s.charAt(idx++);\n            }\n        }\n        return res;\n    }\n}\n```\n\n### **复杂度分析**\n\n- 时间空间都是O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918907468","body":"# 题目：[232. Implement Queue using Stacks]([https://leetcode.com/problems/implement-queue-using-stacks/](https://leetcode.com/problems/implement-queue-using-stacks/))\n\n### 思路\n\n- 就像汉诺塔游戏一样，需要两个位置来存放和调整顺序，pushStack 和popStack。popStack 里面存放的元素都是按照queue来摆放的，直接做pop或者peek操作就可以了。\n- push就正常push进pushStack里面去。pop 和peek的做法一样，把所有的pushstack里的元素放到popstack里面去，从popStack里面做pop 或者peek的操作\n- \n\n### 代码\n\n```java\nclass MyQueue {\n\n    /** Initialize your data structure here. */\n    Stack<Integer> pushStack = new Stack();\n    Stack<Integer> popStack = new Stack();\n    \n    public MyQueue() {\n        //do nothing is ok?\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        pushStack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        //if pop is not empty, pop from popStack\n        if (!popStack.isEmpty()) {\n            return popStack.pop();\n        } else {\n            //otherwise, move all elements from push to pop, and then pop from popStack\n            while (!pushStack.isEmpty()) {\n                popStack.add(pushStack.pop());\n            }\n            return popStack.pop();\n            \n        }\n        \n        //return -1;\n        \n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (!popStack.isEmpty()) {\n            return popStack.peek();\n        } else {\n            //otherwise, move all elements from push to pop, and then pop from popStack\n            while (!pushStack.isEmpty()) {\n                popStack.push(pushStack.pop());\n            }\n            return popStack.peek();\n            \n        }\n        \n        //return -1;\n        \n        \n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return (popStack.isEmpty() && pushStack.isEmpty());\n        \n    }\n}\n```\n\n### **复杂度分析**\n\n- pop 和peek 为On，其他为O1\n\n### attention！\n\n** ** \n\n## **延伸阅读**\n\n实际上现实中也有使用两个栈来实现队列的情况，那么为什么我们要用两个 stack 来实现一个 queue？\n\n其实使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作。一个栈是用来读的，另一个是用来写的。当且仅当读栈满时或者写栈为空时，读写操作才会发生冲突。\n\n当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个栈的实现中，只要写入栈不为空，那么`push`操作的锁就不会影响到`pop`。\n\n[https://stackoverflow.com/questions/2050120/why-use-two-stacks-to-make-a-queue/2050402#2050402](https://stackoverflow.com/questions/2050120/why-use-two-stacks-to-make-a-queue/2050402#2050402)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919761240","body":"# 题目：[768. Max Chunks To Make Sorted II]([https://leetcode.com/problems/max-chunks-to-make-sorted-ii/](https://leetcode.com/problems/max-chunks-to-make-sorted-ii/))\n\n### 思路\n\n- Algorithm: Iterate through the array, each time all elements to the left are smaller (or equal) to all elements to the right, there is a new chunck.\n- Use two arrays to store the left max and right min to achieve O(n) time complexity. Space complexity is O(n) too.\n- [https://leetcode.com/problems/max-chunks-to-make-sorted-ii/discuss/113462/Java-solution-left-max-and-right-min](https://leetcode.com/problems/max-chunks-to-make-sorted-ii/discuss/113462/Java-solution-left-max-and-right-min).\n\n### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        int[] maxOfLeft = new int[n];\n        int[] minOfRight = new int[n];\n\n        maxOfLeft[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n            maxOfLeft[i] = Math.max(maxOfLeft[i-1], arr[i]);\n        }\n\n        minOfRight[n - 1] = arr[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]);\n        }\n\n        int res = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (maxOfLeft[i] <= minOfRight[i + 1]) res++;\n        }\n\n        return res + 1;\n    }\n}\n```\n\n### **复杂度分析**\n\n- O(n) time complexity. Space complexity is O(n) too.\n\n### attention！\n\n** 从暴力解开始重新想一遍**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920656534","body":"# 题目：[]([https://leetcode.com/problems/rotate-list/](https://leetcode.com/problems/rotate-list/))\n\n### 思路\n\n- 采用快慢指针\n- 快指针与慢指针都以每步一个节点的速度向后遍历\n\n    （先抄了，明天重新写）\n\n- \n\n### 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        while(now != null){\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922227712","body":"# 题目：[109. Convert Sorted List to Binary Search Tree]([https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/))\n\n### 思路\n\n- 使用快慢双指针可定位中间元素\n- \n- \n\n### 代码\n\n```java\nclass Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null) return null;\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail) return null;\n      ListNode fast = head, slow = head;\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}\n```\n\n### **复杂度分析**\n\n- nlogn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922426064","body":"# 题目：[160. Intersection of Two Linked Lists]([https://leetcode.com/problems/intersection-of-two-linked-lists/](https://leetcode.com/problems/intersection-of-two-linked-lists/))\n\n### 思路\n\n- 保证走过得路程相同（两个list都走一遍），如果有交点，那么同样的速度（每次都走到next），同样的起始时间，那么最后肯定能在同一时间遇到（交点。）\n- \n\n### 代码\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode i = headA, j = headB;\n        \n        while (i != j) {\n            \n            i = i == null ? headB : i.next;\n            j = j == null ? headA : j.next;\n        }\n        \n        return i;\n    }\n}\n```\n\n### **复杂度分析**\n\n- 时间复杂度：（On）\n- 空间（O1）\n-","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Wu-zonglin":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916730474","body":"### 思路\n数据类型转换\n### 代码\n~~~ python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sum = int(''.join(map(str, num)))+k\n        return list(map(int,str(sum)))\n~~~\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917408062","body":"### 思路\n前后指针\n~~~ python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = []\n        cur = s.find(c)\n        pre = -float('inf')\n        for i in range(len(s)):\n            if i == cur and c in s[cur+1:] :\n                pre = cur\n                cur += 1 + s[cur+1:].find(c)\n                res.append(0)\n            else:\n                res.append(abs(i-cur) if abs(i-cur) <= abs(i-pre) else abs(i-pre))\n        return res\n~~~\n### 复杂度分析\n- 时间复杂度：`O(n)`\n- 空间复杂度：`O(n)`","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920104172","body":"### 思路\n辅助栈\n~~~python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n~~~\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n) ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921892880","body":"### 思路\n递归\n~~~python\nclass Solution(object):\n\tdef swapPairs(self, head):\n\t\t# 递归的终止条件\n\t\tif not (head and head.next):\n\t\t\treturn head\n\t\ttmp = head.next\n\t\thead.next = self.swapPairs(tmp.next)\n\t\ttmp.next = head\n\t\treturn tmp\n~~~\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JAYWX":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916738912","body":"# 思路\nK与num转化为列表  \n准备一个接收列表\n\n两列表同时从末尾往前根据索引取值  \n两值相加的结果c,  \n\n如果 c大于等于10,  \n十位用sum记录，为前一位计算做记录\n\n如果 c小于10，  \nsum记得清零\n\nc的个位加入接收列表\n\n注：循环结束记得把不为0的sum加入接收列表\n\n接收列表末尾为结果首位，最后把列表reverse一次\n\n\n# 代码\n```python\nfrom typing import List\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        A = num\n        a_len = len(A)\n        B = list(int(i) for i in str(k))\n        b_len = len(B)\n        big_num = max(a_len, b_len)\n\n        sum = 0\n        index_sum = 0\n        res = []\n        for i in range(big_num):\n            index_sum -= 1\n            a = 0 if a_len < abs(index_sum) else A[index_sum]\n            b = 0 if b_len < abs(index_sum) else B[index_sum]\n            c = a + b + sum\n            if c >= 10:\n                sum = c // 10 % 10\n                c = c // 1 % 10\n            else:\n                sum = 0\n            res.append(c)\n\n        if sum:\n            res.append(sum)\n\n        res.reverse()\n        return res\n```\n## 复杂度分析\n令 n 为数组长度。\n\n时间复杂度：$O(n)$  \n空间复杂度：$O(n)$  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351718","body":"# 思路\n找到所有c字符在s列表的索引, 放入一个列表 c_index_lst\n变量start和变量end表示在c_index_lst中的索引，\n根据s中的索引值i，与start和end做减法取绝对值，找到最小值，加入结果集res，\n当最小值为0时，start和end往前进一位，即start, end = end, end + 1，\n注意c_index_lst索引的边界值\n\n# 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        c_index_lst = []\n        _x = 0\n        for i in s:\n            if i == c:\n                c_index_lst.append(_x)\n            _x += 1\n\n        start = float('-inf')\n        c_index = 0\n        end = c_index_lst[c_index]\n        index = 0\n        res = []\n        for i in s:\n            c = min(abs(start - index), abs(end - index))\n            print(c)\n            res.append(c)\n            if c == 0:\n                start = end\n                if c_index + 1 < len(c_index_lst):\n                    c_index += 1\n                end = c_index_lst[c_index]\n            index += 1\n\n        return res\n```\n## 复杂度分析\n时间复杂度：$O(n)$  \n空间复杂度：$O(n)$  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917535841","body":"## 思路\n使用list构造栈；  \n为了在increment时，复杂度为O(1)，多用了一个列表，存val，  \n只有在pop时再计算输出的值；  \n空间换时间  \n\n注：  \npush时，incrementals列表append(0);  \npop时，需要判断好边界条件，incrementals列表的-2项元素等于自身加-1项\n\n\n## 代码 \n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n        self.size = 0\n        self.incrementals = []\n\n    def push(self, x: int) -> None:\n        if self.size != self.maxSize:\n            self.stack.append(x)\n            self.incrementals.append(0)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        self.size -= 1\n        if self.size > 0:\n            self.incrementals[-2] += self.incrementals[-1]\n        return self.incrementals.pop() + self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.incrementals:\n            self.incrementals[min(self.size, k) - 1] += val\n\n```\n### 复杂度分析\n时间复杂度：$O(1)$  \n空间复杂度：$O(n)$  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917985666","body":"## 思路\n循环s的各元素i放入栈res,  \n当元素i为']'时，从栈res往外取数据并进行字符合并，直到遇到'['；  \n之后开始数字的合并，直到栈往外取不是数字，最后的字符串=数字项*字符串；  \n再把算得字符串放入栈中，往下循环s的下各元素  \n注：  \n1. '['前的数字不一定是一位，可能是两位数字，如10[a]  \n2. 栈最后的边界条件，res为空，res[-1]报错 (查了好半天 =,=)\n\n\n\n\n\n## 复杂度分析\n时间复杂度：最坏$O(n^2)$  \n空间复杂度：$O(n)$  \n\n## 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = []\n        s = '1' + '[' + s + ']'\n        for i in s:\n            if i == ']':\n                x = res.pop()\n                _i = ''\n                while x != '[':\n                    _i = x + _i\n                    x = res.pop()\n                num_str = ''\n                while True:\n                    if not (res and res[-1].isdigit()):\n                        break\n                    num_str = res.pop() + num_str\n                _i = int(num_str) * _i\n                res.append(_i)\n            else:\n                res.append(i)\n\n        return res[-1]\n\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919040700","body":"## 思路\n使用list模拟队列，  \n定义两个变量：  \n\n* push_index，数据将要入队的索引位置；  \n* pop_index, 数据出队的索引位置；  \n\n入队 push_index += 1;  \n出队 根据pop_index索引返回list元素；pop_index += 1;\npeek 根据pop_index索引返回list元素；\n\n注：  \n1. 边界问题：如果 pop_index==push_index, 不能再pop，empty返回True，peek返回空\n2. pop完如果队列为空，重制队列\n\n\n## 复杂度分析\n时间复杂度：$O(1)$  \n空间复杂度：$O(n)$  \n\n## 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.pop_index = 0\n        self.push_index = 0\n        self.list = []\n\n    def push(self, x: int) -> None:\n        self.list.append(x)\n        self.push_index += 1\n\n    def pop(self) -> int:\n        if self.empty():\n            return \n            \n        res = self.list[self.pop_index]\n        self.pop_index += 1\n        \n        if self.empty():\n            self.pop_index = 0\n            self.push_index = 0\n            self.list = [] \n            \n        return res\n\n    def peek(self) -> int:\n        return self.list[self.pop_index] if self.pop_index != self.push_index else None\n\n    def empty(self) -> bool:\n        return self.pop_index == self.push_index\n        \n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920031560","body":"\n## 思路\n使用单调递增栈，其中存储最小一组的最大值，最后计算单调栈的长度\n\n\n## 复杂度分析\n时间复杂度：$O(n)$  \n空间复杂度：$O(n)$  \n\n## 代码\n```python\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        s = []\n        for i in arr:\n            if s and i < s[-1]:\n                max_point = s[-1]\n                while s and s[-1] > i:\n                    s.pop()\n                i = max_point\n            s.append(i)\n        return len(s)\n\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920867092","body":"## 思路\n使用stack(list列表)存储，各项链表节点；  \n根据 k % 列表长度，知道从倒数第 -(k%len(stack))-1 开始截断列表，  \n并拼接到stack[0]项前\n\n注：  \n空链表这种特殊输入判断\n\n## 复杂度分析\n时间复杂度：$O(n)$  \n空间复杂度：$O(n)$  \n\n## 代码\n```python\nclass Solution:\n    def rotateRight(self, head: [ListNode], k: int) -> [ListNode]:\n        stack = []\n        while True:\n            if not head:\n                break\n            stack.append(head)\n            head = head.next\n        if not stack:\n            return head\n        num = k % len(stack)\n        if num:\n            index = -1-num\n            become_last_node = stack[index]\n            become_last_node.next = None\n            become_first_front_node = stack[-1]\n            become_first_front_node.next = stack[0]\n            return stack[index+1]\n        else:\n            return stack[0]\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921699161","body":"## 思路\n引入一个前置节点，  \n使在一次循环中，定义三种节点变量： 前，中，后 节点；  \n起初：前->中->后->大后  \n改变：前->后->中->大后，中 变为 前，进入下一个循环\n\n注：\n循环的结束点：因为是每两个节点互换，一个循环里 中或者后 可能为空，循环退出\n\n\n\n## 复杂度分析\n时间复杂度：$O(n)$  \n空间复杂度：$O(1)$  \n\n## 代码\n```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \n        \nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        first = ListNode(0, head)\n        front_node = first\n\n        while front_node.next:\n            mid_node = front_node.next\n            next_node = mid_node.next\n            if not next_node:\n                break\n                \n            next_mid_node = next_node.next\n            next_node.next = mid_node\n            front_node.next = next_node\n            mid_node.next = next_mid_node\n            front_node = mid_node\n\n        return first.next\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922330077","body":"## 思路\n找链表中间节点作为根节点，然后再找中点两边的子链表的中点，一直递归下去直到子链表为空. \n\n## 复杂度分析\n时间：O(nlogn).  \n空间: O(logn)\n\n## 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return None\n        elif not head.next:\n            return TreeNode(head.val)\n\n        pre, slow, fast = None, head, head\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        root = TreeNode(slow.val)\n        pre.next = None\n\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n```\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922478006","body":"\n## 思路\n双指针，当一个链表走到末尾时，从另一个链表头部继续；  \n两个链表都是如此执行，  \n如果两个链表有交点，则期间必有相等的节点  \n如果两个链表没有节点，则走到末尾时，全部为None，也必然相等  \n\n注：  \n循环的终止条件  \n\n## 复杂度分析\n时间复杂度：$O(n)$  \n空间复杂度：$O(1)$  \n\n## 代码\n```python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        node_A = headA\n        node_B = headB\n        while node_A != node_B:\n            if node_A == None:\n                node_A = headB\n            else:\n                node_A = node_A.next\n            if node_B == None:\n                node_B = headA\n            else:\n                node_B = node_B.next\n        return node_A\n\n\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowenhe":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916747421","body":"```CPP\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int n = num.size() - 1;\n        int cur = k;\n        vector<int> result;\n        while(n >= 0 || cur)\n        {\n            if(n>=0)\n            {\n                cur = cur + num[n];\n            }\n            result.push_back(cur%10);\n            cur = cur / 10;\n            n--;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917373473","body":"## 思路\r\n分别左右遍历，取最小\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n\r\n\r\n        results = []\r\n        pos = float('-inf')\r\n        for i in range(len(S)):\r\n            if S[i] == C:\r\n                pos = i\r\n            results.append(i - pos)\r\n        pos = float('inf')\r\n        for i in range(len(S)-1,-1,-1):\r\n            if S[i] == C:\r\n                pos = i\r\n            results[i] = min(results[i],(pos - i))\r\n        return results\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917620191","body":"```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self._maxSize = maxSize\r\n        self._stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if (len(self._stack) < self._maxSize):\r\n            self._stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self._stack) > 0:\r\n            return self._stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self._stack))):\r\n            self._stack[i] += val\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918999847","body":"```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n\r\n        self.s = []\r\n\r\n    def push(self, x: int) -> None:\r\n\r\n        self.s.append(x)\r\n \r\n        \r\n\r\n    def pop(self) -> int:\r\n\r\n        return self.s.pop(0)\r\n\r\n    def peek(self) -> int:\r\n\r\n        return self.s[0]\r\n\r\n    def empty(self) -> bool:\r\n\r\n        return not self.s\r\n···","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920874401","body":"```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        num = 1\r\n        p = head\r\n        while(p.next):\r\n            num += 1\r\n            p = p.next\r\n\r\n        k = k % num\r\n        left = num - k\r\n        if left == num:\r\n            return head\r\n        right =  k\r\n\r\n        q = head\r\n        w = q\r\n        while(left > 0):\r\n            w = q\r\n            q = q.next\r\n            left -= 1\r\n\r\n        w.next = None\r\n        r = head\r\n        head = q\r\n\r\n        while(right > 0 and q.next):\r\n            q = q.next\r\n        q.next = r\r\n        # head = q\r\n\r\n\r\n        return head\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mglslg":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916756192","body":"时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n```java\r\n    /**\r\n     * 先前试图抖机灵将数组转换为数字然后加k再转回来\r\n     * 结果分分钟被测试用例[9,9,9,9,9,9,9,9,9,9]教做人\r\n     * 数组越界，只能乖乖按位相加了哎~~~\r\n     * 技巧：线性表从左向右增长使用Array，从右向左增长使用LinkedList::addFirst\r\n     * 这样就不必使用stack倒来倒去\r\n     */\r\n    class Solution {\r\n        public List<Integer> addToArrayForm(int[] num, int k) {\r\n            if (num.length == 0) {\r\n                return numToList(k);\r\n            }\r\n            LinkedList<Integer> result = new LinkedList<>();\r\n            int carry = 0;\r\n            int size = num.length;\r\n            LinkedList<Integer> kNum = numToList(k);\r\n            while (!kNum.isEmpty()) {\r\n                if (size > 0) {\r\n                    int x = kNum.pollLast() + num[size - 1];\r\n                    result.addFirst((x + carry) % 10);\r\n                    carry = (x + carry) / 10;\r\n                    size--;\r\n                } else {\r\n                    int x = kNum.pollLast();\r\n                    result.addFirst((x + carry) % 10);\r\n                    carry = (x + carry) / 10;\r\n                }\r\n            }\r\n            while (size > 0) {\r\n                int x = num[size - 1];\r\n                result.addFirst((x + carry) % 10);\r\n                carry = (x + carry) / 10;\r\n                size--;\r\n            }\r\n            if (carry > 0) {\r\n                result.addFirst(1);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        private LinkedList<Integer> numToList(int num) {\r\n            LinkedList<Integer> list = new LinkedList<>();\r\n            while (num / 10 > 0) {\r\n                list.addFirst(num % 10);\r\n                num = num / 10;\r\n            }\r\n            list.addFirst(num % 10);\r\n            return list;\r\n        }\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920633832","body":"思路：找到某一处位置断开链子并且拼到头上即可\r\n1、先遍历一圈得出链表长度\r\n2、之后取模看看链子需要从哪断开\r\n3、断开并拼接即可\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n\r\n```java\r\n    class Solution {\r\n        public ListNode rotateRight(ListNode head, int k) {\r\n            if (head == null) {\r\n                return null;\r\n            }\r\n            int length = 1;\r\n            ListNode tail = head;\r\n            while (tail.next != null) {\r\n                length++;\r\n                tail = tail.next;\r\n            }\r\n            ListNode p = head;\r\n            int n = length - k % length;\r\n            for (int i = 0; i < n - 1; i++) {\r\n                p = p.next;\r\n            }\r\n\r\n            tail.next = head;\r\n            head = p.next;\r\n            p.next = null;\r\n\r\n            return head;\r\n        }\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921583349","body":"### 思路：一图胜千言\r\n![image.png](https://pic.leetcode-cn.com/1631864688-ecgOcz-image.png)\r\n\r\n- **复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head==null){\r\n            return null;\r\n        }\r\n        ListNode p=head;\r\n        ListNode dummyHead=new ListNode(0);\r\n        ListNode pre=dummyHead;\r\n        ListNode post=null;\r\n        while(p!=null){\r\n            if(p.next!=null){\r\n                //红框中有两个节点\r\n                ListNode k=p.next;\r\n                //记录当前post节点\r\n                post=p.next.next;\r\n                //翻转p和k并连接到pre和post上\r\n                k.next=p;\r\n                p.next=post;\r\n                pre.next=k;\r\n                //移动红框\r\n                pre=p;\r\n                p=post;\r\n            }else{\r\n                //红框中只剩一个节点 \r\n                pre.next=p;\r\n                p=null;\r\n            }\r\n        }\r\n        return dummyHead.next;\r\n    }\r\n}\r\n```\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922446940","body":"### 思路\r\n\r\n一图胜千言\r\n![image.png](https://pic.leetcode-cn.com/1632045372-sNCvXT-image.png)\r\n\r\n重点注意循环的退出条件，我这里使用了一个sigA来标记p1是否已经走过一圈了\r\n\r\n### 代码\r\n\r\n```java\r\n\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        //用来标记A是否已经走过一圈了\r\n        boolean sigA=false;\r\n        ListNode p1=headA;\r\n        ListNode p2=headB;\r\n        ListNode tail1=null;\r\n        ListNode tail2=null;\r\n        while(true){\r\n            if(p1==p2){\r\n                return p1;\r\n            }\r\n            if(p1.next==null && sigA){\r\n                return null;\r\n            }\r\n            if(p1.next==null){\r\n                p1=headB;\r\n                sigA=true;\r\n            }else{\r\n                p1=p1.next;\r\n            }\r\n            if(p2.next==null){\r\n                p2=headA;\r\n            }else{\r\n                p2=p2.next;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n- **复杂度分析**\r\n- 时间复杂度：O(N+M)\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HouHao1998":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916760585","body":" public List<Integer> addToArrayForm(int[] num, int k) {\n\t\tList<Integer> sumList =new ArrayList<>();\n    \tif(num.length==1&&num[0]==0&&k==0){\n\t\t\tsumList.add(0);\n    \t\treturn sumList;\n\t\t}\n\t\tList<Integer> kList =new ArrayList<>();\n\t\twhile (k/10!=0){\n\t\t\tkList.add(k%10);\n\t\t\tk = k/10;\n\t\t}\n\t\tkList.add(k%10);\n\t\tint nl =num.length;\n\t\tint[] num2 = new int[nl];\n\t\tfor (int a:num) {\n\t\t\tnum2[--nl]=a;\n\t\t}\n\t\tnl =num.length-1;\n\t\tint kl =kList.size()-1;\n\t\tint go =0;\n\t\tint sun =0;\n\t\tint[] sum;\n\t\tsum =new int[Math.max(nl,kl)+2];\n\t\tfor (int i = 0; i <= Math.max(nl,kl); i++) {\n\t\t\tif(i<=nl&&i<=kl){\n\t\t\t\tsun = kList.get(i)+num2[i]+go;\n\t\t\t}else {\n\t\t\t\tsun = nl>kl?num2[i]+go:kList.get(i)+go;\n\t\t\t}\n\t\t\tsum[i]=sun%10;\n\t\t\tgo=sun/10;\n\t\t}\n\t\tif(go!=0){\n\t\t\tsum[sum.length-1]= go;\n\t\t}\n\n\t\tboolean a= true;\n\t\tfor (int i = sum.length-1; i >=0; i--) {\n\t\t\tif(sum[i]==0&&a){\n\t\t\t\tcontinue;\n\t\t\t}else {\n\t\t\t\ta=false;\n\t\t\t}\n\t\t\tsumList.add(sum[i]);\n\t\t}\n\treturn sumList;\n    }\n## 思路\n把数字变成倒叙数组，数组也直接倒叙，进位相加，再次倒叙\n复杂度分析\n\n数字或数组最长为n\n复杂度O（N）\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917426557","body":"**思路**\r\n双指针写法，遍历一次得到最优解\r\n```\r\n    public int[] shortestToChar(String s, char c) {\r\n\r\n    \tint[] arr= new int[s.length()];\r\n\t\tList<Integer> list = new ArrayList<>();\r\n\t\tfor (int i = 0; i <s.length(); i++) {\r\n\t\t\tif (s.charAt(i)==c){\r\n\t\t\t\tlist.add(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\tint l =0 ;\r\n\t\tint r =list.get(0) ;\r\n\t\tint ln =0 ;\r\n\t\tfor (int i = 0; i <s.length(); i++) {\r\n\t\t\tif(l==0&&i<r&&list.get(0)!=0){\r\n\t\t\t\tarr[i]=r-i;\r\n\t\t\t} else if(i==r){\r\n\t\t\t\tif(ln<list.size()-1) {\r\n\t\t\t\t\tl = r;\r\n\t\t\t\t\t++ln;\r\n\t\t\t\t\tr = list.get(ln);\r\n\t\t\t\t\tarr[i] = 0;\r\n\t\t\t\t}else {\r\n\t\t\t\t\tl=r;\r\n\t\t\t\t\tr=0;\r\n\t\t\t\t\tarr[i] = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t}else {\r\n\t\t\t\tarr[i]=Math.min(Math.abs(i-l), Math.abs(r-i));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn arr;\r\n    }\r\n```\r\n时间复杂度\r\nO（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917439405","body":"### 思路\r\n用数组实现，记录栈顶的大小\r\n### 代码\r\n```\r\nclass CustomStack {\r\n\t    int [] stack;\r\n\t    int now ;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack =new int[maxSize];\r\n        now=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(now<stack.length-1){\r\n            stack[++now]=x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(now==-1||stack==null){\r\n            return -1;\r\n        }\r\n        int p = stack[now];\r\n        now--;\r\n        return p;\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < k; i++) {\r\n            if(i<=now){\r\n                stack[i]=stack[i]+val;\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度查询插入都是O1\r\n累加是O（k）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917974958","body":"### 思路\r\n用的栈，数字和字母封开存放，存放之后，遇到]就取出最顶上的并传递\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n    \tString k=\"\" ;\r\n    \tString out=\"\" ;\r\n    \tint intK ;\r\n    \tboolean r = true;\r\n    \tString d=\"\" ;\r\n\t\tStack<Integer> stack = new Stack<>();\r\n\t\tStack<String> stack1 = new Stack<>();\r\n\t\tfor (int i = 0; i < s.length(); i++) {\r\n\t\t\tif(s.charAt(i)=='['){\r\n\t\t\t\tr=false;\r\n\t\t\t\tint x = i;\r\n\t\t\t\tk=\"\";\r\n\t\t\t\twhile (x>0){\r\n\t\t\t\t\tif(Character.isDigit(s.charAt(x - 1))){\r\n\t\t\t\t\t\tk= s.charAt(x - 1)+k;\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\tx=0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tx--;\r\n\t\t\t\t}\r\n\t\t\t\tstack.add(Integer.parseInt(k));\r\n\t\t\t\t x = i;\r\n\t\t\t\t d=\"\";\r\n\t\t\t\twhile (x<s.length()){\r\n\t\t\t\t\tif(Character.isDigit(s.charAt(x + 1))||s.charAt(x + 1)==']'){\r\n\t\t\t\t\t\tx=s.length();\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\td= d+s.charAt(x + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tx++;\r\n\t\t\t\t}\r\n\t\t\t\tstack1.add(d);\r\n\t\t\t}else\r\n\t\t\tif(s.charAt(i)==']'){\r\n\t\t\t\tintK=stack.pop();\r\n\t\t\t\td=stack1.pop();\r\n\t\t\t\tString dd=\"\";\r\n\t\t\t\tfor (int j = 0; j < intK; j++) {\r\n\t\t\t\t\tdd=dd+d;\r\n\t\t\t\t}\r\n\t\t\t\tif(!stack.empty()){\r\n\t\t\t\t\tdd = stack1.pop()+dd;\r\n\t\t\t\t\tif(i!=s.length()-1&&!Character.isDigit(s.charAt(i + 1))){\r\n\t\t\t\t\t\tint x=i;\r\n\t\t\t\t\t\twhile (x<s.length()){\r\n\t\t\t\t\t\t\tif(Character.isDigit(s.charAt(x + 1))||s.charAt(x + 1)==']'){\r\n\t\t\t\t\t\t\t\tx=s.length();\r\n\t\t\t\t\t\t\t}else {\r\n\t\t\t\t\t\t\t\tdd= dd+s.charAt(x + 1);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tx++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstack1.add(dd);\r\n\t\t\t\t}else {\r\n\t\t\t\t\tout=out+dd;\r\n\t\t\t\t}\r\n\t\t\t\tif(i<s.length()-1&&!Character.isDigit(s.charAt(i + 1))&&stack.empty()){\r\n\t\t\t\t\t\tint x=i;\r\n\t\t\t\t\t\twhile (x<s.length()-1){\r\n\t\t\t\t\t\t\tif(Character.isDigit(s.charAt(x + 1))){\r\n\t\t\t\t\t\t\t\tx=s.length();\r\n\t\t\t\t\t\t\t}else {\r\n\t\t\t\t\t\t\t\tout= out+s.charAt(x + 1);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tx++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}else {\r\n\t\t\t\tif(!Character.isDigit(s.charAt(i ))&&r){\r\n\t\t\t\t\tout =out+s.charAt(i);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn out;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 复杂度\r\n时间复杂度O(N)\r\n常数有点大","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918726766","body":"### 思路\r\n两个栈，存储的时候存在a栈，取的时候把a栈所有的元素全部倒到b栈，然后从b栈取出。取完之后把b栈元素放回a栈\r\n### 代码\r\n```Java\r\nclass MyQueue {\r\n    private  Stack<Integer> stack ;\r\n    private  Stack<Integer> stack2 ;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack =new Stack<>();\r\n        stack2 =new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        while (!stack.empty()){\r\n            stack2.push(stack.pop());\r\n        }\r\n        int x = stack2.pop();\r\n        while (!stack2.empty()) {\r\n            stack.push(stack2.pop());\r\n        }\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Get the front element.\r\n     */\r\n    public int peek() {\r\n        while (!stack.empty()) {\r\n            stack2.push(stack.pop());\r\n        }\r\n        int x = stack2.peek();\r\n        while (!stack2.empty()) {\r\n            stack.push(stack2.pop());\r\n        }\r\n        return x;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stack.empty();\r\n    }\r\n```\r\n复杂度\r\n时间复杂度\r\npush是O（1）\r\npop 和peek：O（n）n是栈的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919658583","body":"### 思路\r\n使用单调栈的写法，依次递增的数全部方到栈里，没递增的按照栈顶去比较，依次取出，然后再将最大的数放入。最后栈的数量就是结果\r\n### 代码\r\n```Java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n    \tStack<Integer> stack =new Stack<>();\r\n\r\n\t\tfor (int a:arr) {\r\n\t\t\tif(stack.empty()){\r\n\t\t\t\tstack.push(a);\r\n\t\t\t}else {\r\n\t\t\t\tmaxChunksToSorted(stack,a,stack.peek(),true);\r\n\t\t\t}\r\n\r\n\t\t}return stack.size();\r\n\r\n    }\r\n\tpublic Stack<Integer> maxChunksToSorted(Stack<Integer> stack,int a,int max,boolean b) {\r\n    \tif(!stack.empty()){\r\n\t\t\tif(stack.peek()<=a){\r\n\t\t\t\tif (b) {\r\n\t\t\t\t\tstack.push(a);\r\n\t\t\t\t}else {\r\n\t\t\t\t\tstack.push(max);\r\n\t\t\t\t}\r\n\t\t\t}else {\r\n\t\t\t\tstack.pop();\r\n\t\t\t\tmaxChunksToSorted(stack,a,max,false);\r\n\t\t\t}\r\n\t\t}else {\r\n\t\t\tif (b) {\r\n\t\t\t\tstack.push(a);\r\n\t\t\t}else {\r\n\t\t\t\tstack.push(max);\r\n\t\t\t}\r\n\t\t}\r\n\r\n    \treturn stack;\r\n\t}\r\n```\r\n### 复杂度分析\r\n\r\n- 时间复杂度:O(NlogN)\r\n- 空间复杂度:O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920539880","body":"### 思路\r\n链表问题，先建立头尾相连的链表，然后在右移的最后位置断开链表\r\n### 代码\r\n```Java\r\n\tclass Solution {\r\n\t\tpublic ListNode rotateRight(ListNode head, int k) {\r\n\t\t\tif (head == null) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tListNode now;\r\n\t\t\tListNode head1 = new ListNode();\r\n\t\t\tListNode next = head;\r\n\t\t\thead1.next = head;\r\n\t\t\tint i = 1;\r\n\t\t\twhile (next.next != null) {\r\n\t\t\t\tnext = next.next;\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\tnext.next = head;\r\n\t\t\tnext = next.next;\r\n\t\t\tk = k % i;\r\n\t\t\tfor (int j = 1; j < i - k; j++) {\r\n\t\t\t\tnext = next.next;\r\n\t\t\t}\r\n\t\t\tnow = next.next;\r\n\t\t\tnext.next = null;\r\n\t\t\treturn now;\r\n\t\t}\r\n\t}\r\n```\r\n### 复杂度\r\n时间复杂度O(N)\r\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921429412","body":"### 思路\r\n两个数为一组，进行链表的重连，记录最后一个数，做为下一组数的开头\r\n### 代码\r\n```Java\r\nclass Solution {\r\n  public ListNode swapPairs(ListNode head) {\r\n\tif(head==null||head.next==null){\r\n\t\t\treturn head;\r\n\t\t}\r\n\t\tListNode last = new ListNode();\r\n\t\tListNode new1 = head.next;\r\n\t\twhile (head!=null&&head.next!=null){\r\n\t\t\tListNode next = head.next;\r\n\t\t\thead.next = head.next.next;\r\n\t\t\tnext.next = head;\r\n\t\t\tlast.next = next;\r\n\t\t\tlast= head;\r\n\r\n\t\t\thead = head.next;\r\n\t\t}\r\n\t\treturn new1;\r\n\r\n    }\r\n}\r\n```\r\n### 复杂度\r\nT:   O(N)\r\nS:   O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922168920","body":"### 思想\r\n应为有序，选择快慢指针\r\n### 代码\r\n```Java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n\tTreeNode treeNode = new TreeNode();\r\n\t\tListNode fast = head;\r\n\t\tListNode slow = head;\r\n\t\tif(head==null){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif(head.next==null){\r\n\t\t\treturn new TreeNode(head.val);\r\n\t\t}\r\n\t\twhile (fast != null && fast.next != null) {\r\n\t\t\tListNode next ;\r\n\t\t\tfast=fast.next.next;\r\n\t\t\tnext=slow;\r\n\t\t\tslow = slow.next;\r\n\r\n\t\t\tif(fast==null||fast.next==null){\r\n\t\t\t\tnext.next=null;\r\n\t\t\t\ttreeNode.val = slow.val;\r\n\t\t\t\ttreeNode.left = sortedListToBST(head);\r\n\t\t\t\ttreeNode.right = sortedListToBST(slow.next);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn treeNode;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\nT：O(nlogn)\r\ns：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922478675","body":"\r\n### 代码\r\n```Java\r\n public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n         if(headA == null || headB == null) return null;\r\n        ListNode pA = headA, pB = headB;\r\n        while(pA != pB) {\r\n            pA = pA == null ? headB : pA.next;\r\n            pB = pB == null ? headA : pB.next;\r\n        }\r\n        return pA;\r\n    \r\n    }\r\n```\r\n### 复杂度\r\nT：O(N)\r\nS: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AruSeito":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916761326","body":"## 思路\r\n将k拆成数组，按照竖式相加的方式进行每位相加，如果相加和大于等于10，那么当前位取10的余数，前一位进1。如果是最后一位大于10，要在前面进行补加一位。\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  let kArray = k\r\n    .toString()\r\n    .split(\"\")\r\n    .map((kNum) => Number(kNum));\r\n  let flag = false;\r\n  const maxLength = Math.max(num.length, kArray.length);\r\n  while (kArray.length < maxLength) kArray.unshift(0);\r\n  while (num.length < maxLength) num.unshift(0);\r\n  for (let i = maxLength - 1; i >= 0; i--) {\r\n    let tmpSum = num[i] + kArray[i];\r\n    if (tmpSum >= 10) {\r\n      if (i - 1 < 0) {\r\n        flag = true;\r\n        kArray.unshift(0);\r\n      }\r\n      kArray[i - 1 < 0 ? i : i - 1] += 1;\r\n      tmpSum = tmpSum % 10;\r\n    }\r\n    kArray[flag ? i + 1 : i] = tmpSum;\r\n  }\r\n\r\n  return kArray;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(3m-n+Max(m,n))$ m代表k的位数，n代表num的长度，对k进行拆分的时候split是一个m，map又一个m，再两个位数补全的时候是|m-n|\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917343698","body":"## 思路\r\n暴力法：直接遍历一遍，把出现过的每个索引存起来。然后再遍历s，计算出每个字符跟每个索引的差值，将最小值放到结果里。\r\n\r\n## 代码\r\n\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n    let index = [],res=[],i=0;\r\n    for(let i = 0 ; i < s.length;i++){\r\n        if(s[i] === c){\r\n            index.push(i);\r\n        }\r\n    }\r\n    for(let i = 0 ; i < s.length;i++){\r\n        let tmp = Number.MAX_SAFE_INTEGER\r\n        for(let j = 0 ; j <index.length;j++){\r\n            tmp = Math.min(tmp,Math.abs(index[j]-i))\r\n        }\r\n        res.push(tmp)\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n时间复杂度： O（N）；\r\n空间复杂度：O（N）；其实是O（2N）？？？最坏的时候index里把每个字符的索引都存了，再加上结果值，N足够大的时候常数就被省略了。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917565302","body":"## 思路：\r\n简单的栈实现。\r\n## 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = new Array(maxSize);\r\n    this.maxSize = maxSize;\r\n    this.index = 0;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.index < this.maxSize){\r\n        this.stack[this.index++] = x; \r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.index !==0){\r\n        return this.stack.splice(--this.index,1)\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i = 0 ; i<this.index && k>0;i++,k--){\r\n        this.stack[i] = this.stack[i]+val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917820752","body":"## 思路\n遇到非]进栈，遇到]就出栈，遇到[前将出栈的拼成一个字符串，然后[之前的所有数字都出栈拼成重复次数，按照重复次数重复前面拼成的字符串，拼成的结果再放到栈里去，最终结果就是栈里的各个项拼成的字符串\n```javascript\nvar decodeString = function (s) {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    switch (s[i]) {\n      case \"]\": {\n        let str = \"\";\n        while (stack[stack.length - 1] !== \"[\") {\n          str = stack.pop() + str;\n        }\n        stack.pop();\n        let number = 0,\n          count = 0;\n        while (stack[stack.length - 1] >= 0 && stack[stack.length - 1] <= 9) {\n          number = number + stack.pop() * Math.pow(10, count++);\n        }\n        let sum = \"\";\n        while (number > 0) {\n          sum += str;\n          number--;\n        }\n        stack.push(sum);\n        break;\n      }\n      default: {\n        if (Number(s[i]) >= 0 && Number(s[i]) <= 9) {\n          stack.push(Number(s[i]));\n        } else {\n          stack.push(s[i]);\n        }\n      }\n    }\n  }\n  return stack.join(\"\");\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918722577","body":"## 思路\n队列：先进先出\n栈列：先进后出\n一个栈为入队栈，一个栈为出对栈。如果出队栈没有元素，就需要把入对栈的内容全都弹到出对栈中，出对栈就一定是按照队列的出队顺序排列的\n```javascript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function () {\n  this.stack1 = [];\n  this.stack2 = [];\n};\n\n/**\n * Push element x to the back of queue.\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.stack1.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  if (!this.stack2.length) {\n    while (this.stack1.length) {\n      this.stack2.push(this.stack1.pop());\n    }\n  }\n  return this.stack2.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  if (!this.stack2.length) {\n    while (this.stack1.length) {\n      this.stack2.push(this.stack1.pop());\n    }\n  }\n  return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return !this.stack1.length && !this.stack2.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920103372","body":"## 思路\n单调栈。\n\n```javascript\nvar maxChunksToSorted = function (arr) {\n    let stack = []\n    for (let i = 0; i < arr.length; i++) {\n        if (stack.length === 0 || stack[stack.length-1] <= arr[i]) {\n            stack.push(arr[i]);\n        } else {\n            const tmp = stack.pop();\n            while (stack[stack.length-1] > arr[i]) {\n                stack.pop();\n            }\n            stack.push(tmp);\n        }\n    }\n    return stack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920716268","body":"## 思路\n快慢指针：先数出来有几个节点，然后求出来相对于原来的图形实际走的步数（n）。如果实际走0步，那就是他本身，相当于旋转了一圈。如果不为0，快指针先走n步，慢指针再走，直到快指针走到头。这时候慢指针指向的应该是最后一个节点，快指针指向的是要接到头上的。一顿操作结束。\n```\nvar rotateRight = function (head, k) {\n  if (k === 0 || head === null) return head;\n  let slow = head,\n    fast = head,\n    countNode = head,\n    num = 0;\n  while (countNode) {\n    countNode = countNode.next;\n    num++;\n  }\n  let realMove = k % num;\n  if (realMove === 0) {\n    return head;\n  }\n  while (realMove > 0) {\n    fast = fast.next;\n    realMove--;\n  }\n  while (fast.next) {\n    fast = fast.next;\n    slow = slow.next;\n  }\n  let result = slow.next;\n  slow.next = null;\n  fast.next = head;\n\n  return result;\n};\n```\n\n空间复杂度：O（1）\n时间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921835575","body":"```javascript\nvar swapPairs = function (head) {\n  if (!head || !head.next) return head;\n  let res = head.next;\n  let now = head;\n  let preNode = new ListNode();\n  preNode.next = head;\n  while (now && now.next) {\n    let nextNode = now.next;\n    let nnNode = nextNode.next;\n    now.next = nnNode;\n    nextNode.next = now;\n    preNode.next = nextNode;\n    preNode = now;\n    now = nnNode;\n  }\n  return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922167884","body":"```javascript\nvar sortedListToBST = function (head) {\n  if (!head) return null;\n  const dg = (start, end) => {\n    if (start == end) return null;\n    let fast = start,\n      slow = start;\n    while (fast != end && fast.next != end) {\n      fast = fast.next.next;\n      slow = slow.next;\n    }\n    let root = new TreeNode(slow.val);\n    root.left = dg(start, slow);\n    root.right = dg(slow.next, end);\n    return root;\n  };\n  return dg(head, null);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922486729","body":"## 思路\n双指针，相遇的情况为A和B走了相同的距离。\n```javascript\nvar getIntersectionNode = function (headA, headB) {\n  let first = headA, second = headB;\n  while (first !== second) {\n    first = first ? first.next : null;\n    second = second ? second.next : null;\n    if (first === null && second === null) return null;\n    if (first === null) first = headB\n    if (second === null) second = headA;\n  }\n  return first;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922499722","body":"## 思路\r\n快慢指针，第一次相遇，把慢指针放到链表头去，然后再一步步走，和快指针相遇了这个地方就是环的起点\r\n\r\n```javascript\r\nvar detectCycle = function (head) {\r\n  if (!head || !head.next) return null;\r\n  let slow = head,\r\n    fast = head;\r\n  while (fast && fast.next) {\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n    if (fast === slow) {\r\n      slow = head;\r\n      while (slow !== fast) {\r\n        slow = slow.next;\r\n        fast = fast.next;\r\n      }\r\n      return slow;\r\n    }\r\n  }\r\n\r\n  return null;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BreezePython":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916762658","body":"## 思路\r\n\r\n数学题…\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num, k) :\r\n        n = reduce(lambda x, y: x * 10 + y, num) + k\r\n        return [0] if n == 0 else [int(i) for i in str(n)]\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917021301","body":"## 思路\n1. 既然我们需要找到最短距离，那么首先应该获取到该字符在字符串 s 中的所有下标位置。\n2. 使用O(n)的时间遍历一次字符串，并将等于目标字符的下标添加至动态数组arr中。\n3. 初始化指针p，指向arr的0位置\n4. 创建 ret 数组，长度为len(s)\n5. 再次遍历s的过程中，我们需要判断当满足以下两点条件时，指针 p 右移一位\n   1. p小于arr最大下标\n   2. 前下标i 到 p + 1的绝对距离比到 p 的绝对距离小\n6. 每次将 p - i 的绝对距离添加至 ret[i] 中\n7. 最终返回ret即可\n\n## 代码\n**Python:**\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ret, p, arr = [], 0, [i for i in range(len(s)) if s[i] == c]\n        for i, j in enumerate(s):\n            if p < len(arr) - 1 and abs(arr[p] - i) > abs(arr[p + 1] - i):\n                p += 1\n            ret.append(abs(arr[p] - i))\n        return ret\n```\n**Java:**\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        int[] ret = new int[s.length()];\n        int p = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) arr.add(i);\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\n            ret[i] = Math.abs(arr.get(p) - i);\n        }\n        return ret;\n    }\n}\n```\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917590927","body":"## 思路\n\n二维数组记录增量值\n\n## 代码\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.size = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) == self.size:\n            return\n        self.stack.append([x, 0])\n\n    def pop(self) -> int:\n        if self.stack:\n            x, val = self.stack.pop()\n            if self.stack:\n                self.stack[-1][1] += val\n            return x + val\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if not self.stack:\n            return\n        k = min(len(self.stack), k)\n        self.stack[k - 1][1] += val\n```\n## 复杂度\n- 时间复杂度： O(1)\n- 空间复杂度： O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918181233","body":"## 解题思路\n\n解法可能过于简单粗暴，时间比较紧先记录下解题\n1. 循环字符串s\n2. 非 \"]\" 默认全部入栈\n3. 遇到\"]\"时\n   - 维护strs和repeat两个空字符串\n   - 先while循环获取所有字符串，条件为stack[-1] != '[' (因为题目明确无异常场景，故此处无需判断栈是否为空)\n   - strs = stack.pop() + strs\n   - 执行一次stack.pop() 删掉“[”\n   - 再次while循环，条件为栈存在且栈顶为数字类型的字符串 （“3[a]”场景，必须判断栈不为空）\n   - repeat = stack.pop() + repeat\n   - 现在栈中压入int(repeat) * strs即可\n\n## 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in s:\n            if i == ']':\n                strs = ''\n                repeat = ''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop() + repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n```\n\n## 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918966313","body":"## 思路\n通过两个栈的先入先出，实现队列操作。\n\n## 代码:\n```python\nclass MyQueue:\n    def __init__(self):\n        self.stack1, self.stack2 = [], []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        return self.stack2[-1] if self.stack2 else self.stack1[0]\n\n    def empty(self) -> bool:\n        return len(self.stack1) + len(self.stack2) == 0\n```\n\n## 复杂度分析\n- 时间复杂度：push empty peek时间复杂度是 O(1)，pop 平均时间复杂度是 O(1)\n- 空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919859394","body":"## 思路\n没思路先用哈希表比较暴力提交通过。\n\n分析哈希表中的不断clear，考虑栈的压入弹出。\n在保存每块的最大值前提下使用单调栈，可完成解题。\n\n## 代码\n\n**哈希表暴力**\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        ret, s, tmp, new_arr = 0, defaultdict(int), defaultdict(int), sorted(arr)\n        for i, val in enumerate(arr):\n            s[new_arr[i]] += 1\n            tmp[val] += 1\n            if s == tmp:\n                s.clear()\n                tmp.clear()\n                ret += 1\n        return ret\n```\n\n**单调栈**\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i in arr:\n            if stack and i < stack[-1]:\n                head = stack[-1]\n                while stack and i < stack[-1]:\n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(i)\n        return len(stack)\n```\n\n## 复杂度分析\n哈希表暴力：\n- 时间复杂度： O(n ^ 2)\n- 空间复杂度： O(n)\n\n单调栈：\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920720590","body":"## 思路\n\n这道解题需要拆分成6个步骤完成：\n1. 首先获取链表的长度\n2. 针对K大于链表长度的情况进行求余，若k为0表示链表完成一次循环滚动，直接返回链表\n3. 创建快慢指针，两者相距K，快指针先行K步，然后快慢指针一同向前滚动\n4. 当结束滚动，慢指针的next即为新的头节点，fast指针在队尾\n5. 此时将新节点指向slow.next,然后断开slow.next，再将fast指针指向原链表头部\n6. 返回新的头节点，结束。\n\n## 代码\n\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # 若链表为空，返回head\n        if not head:\n            return head\n        # 获取链表的长度\n        n = 0\n        cur = head\n        while cur:\n            n += 1\n            cur = cur.next\n        # 若k的长度大于n，将k对n求余\n        k = k % n\n        # 若k==0表示循环了一整遍，直接返回head\n        if k == 0:\n            return head\n        # 创建快慢指针\n        slow = fast = head\n        # fast指针先走k步\n        while k:\n            fast = fast.next\n            k -= 1\n        # 让fast指针走到队尾\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        # 此时show.next为新的链表头\n        new_head = slow.next\n        # 断开slow.next\n        slow.next = None\n        # 链表首位相接\n        fast.next = head\n        # 返回新的链表头\n        return new_head\n\n```\n\n## 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921865109","body":"## 代码\n```python\nclass Solution:\n    def swapPairs(self, head):\n        ret = ListNode()\n        ret.next = head\n        tmp = ret\n        while tmp.next and tmp.next.next:\n            t3 = tmp.next.next.next\n            t2 = tmp.next\n            tmp.next = tmp.next.next\n            tmp.next.next = t2\n            t2.next = t3\n            tmp = t2\n        return ret.next\n\n```\n## 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922278679","body":"## 思路\n既然要左右绝对值不超过一，就递归寻找中位数，去构造子树\n## 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head):\n        def get_mid(left, right):\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n\n        def tree(left, right):\n            if left == right:\n                return None\n            mid = get_mid(left, right)\n            root = TreeNode(mid.val)\n            root.left = tree(left, mid)\n            root.right = tree(mid.next, right)\n            return root\n\n        return tree(head, None)\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922445703","body":"## 思路\n- 假设相交前A链表的长度为x,B链表的长度为z\n- 两个链表相交的点为图中的w\n- 相交后共同的长度为y。\n- 我们分别创建p1、p2两个指针指向A、B\n- 当p1或者p2走到头时，则将指针重新指向另外的一个链表。\n- 当p1、p2相等时终止，返回p1或p2就是第一个相交节点。\n- 因为p1、p2走过的路程都是x+y+z！\n## 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA, headB):\n        x, y = headA, headB\n        while x != y:\n            x = x.next if x else headB\n            y = y.next if y else headA\n        return x\n```\n## 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HZHENGZHI":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916763651","body":"**思路** \n模拟手算加法过程。当两数之和小于10，则直接加入到list中，当遇到两数之和大于10的时候，需要将1带入进行运算\n\n**代码**\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> linkedList=new LinkedList<>();\n        int temp=0;\n        for (int i = num.length-1; i >=0; i--) {\n            temp=k%10;\n            k=k/10;\n            if(num[i]+temp>=10)\n            {\n                k++;\n                linkedList.addFirst((temp+num[i])%10);\n            }\n            else\n            {\n                linkedList.addFirst(temp+num[i]);\n            }\n            if(i==0)\n            {\n                while (k!=0)\n                {\n                    temp=k%10;\n                    k=k/10;\n                    linkedList.addFirst(temp);\n                }\n            }\n        }\n        return linkedList;\n    }\n```\n**复杂度分析**\nn为num长度，m为k的长度\n+ 空间复杂度$O(n)$\n+ 空间复杂度$O(max(n,m-n))$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917309006","body":"**思路**\n每一次都查找到距离当前字符最近的字符c的位置，进行相减处理。当减到自己为0后，查找下一个字符c所在位置\n**代码**\n```java\npublic int[] shortestToChar(String s, char c) {\n        int []ans=new int[s.length()];\n        char chars[]=s.toCharArray();\n        int j=0;\n        int temp=0;\n        for (int i = 0; i < chars.length; i++) {\n            while (j<chars.length &&chars[j]!=c  )\n            {\n                j++;\n            }\n            if(i-j!=0)\n            {\n                if(j<chars.length && chars[temp]==c &&chars[j]==c)\n                {\n                    ans[i]=Math.min(Math.abs(temp-i),Math.abs(j-i));\n\n                }\n                else if(j<chars.length && chars[j]==c)\n                {\n                    ans[i]=Math.abs(i-j);\n                }\n                else if(chars[temp]==c)\n                {\n                    ans[i]=Math.abs(temp-i);\n                }\n            }\n            if(i-j==0)\n            {\n                ans[i]=0;\n                temp=j;\n                j++;\n            }\n        }\n        return ans;\n    }\n```\n**复杂度**\n+ 空间复杂度$O(n)$\n+ 时间复杂度$O(n*m)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917517759","body":"**思路**\n用数组模拟一个栈，push考虑栈是否为满，pop考虑栈是否为空\n**代码**\n```java\nclass CustomStack {\n    int stack[];\n    int index;\n    public CustomStack(int maxSize) {\n        stack=new int[maxSize];\n        index=0;\n    }\n    public void push(int x) {\n        if(index<stack.length)\n        {\n            stack[index]=x;\n            index++;\n        }\n    }\n    public int pop() {\n        if(index==0)\n        {\n            return -1;\n        }\n        else\n        {\n            return stack[--index];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        if(index>=k)\n        {\n            for(int i=0;i<k;i++)\n            {\n                stack[i]=stack[i]+val;\n            }\n        }\n        else\n        {\n            for(int i=0;i<index;i++)\n            {\n                stack[i]=stack[i]+val;\n            }\n        }\n    }\n}\n```\n**复杂度**\n+ 空间复杂度$O(1)$\n+ 时间复杂度$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918230306","body":"**思路**\n利用栈提取处数字和字母\n**代码**\n```java\npublic String decodeString(String s) {\n        Stack<Integer> numstack = new Stack<>();\n        Stack<String> strstack = new Stack<>();\n        String res = \"\";\n        int num = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (Character.isDigit(c)) {\n                num = num * 10 + c - '0';\n            } else if (c == '[') {\n                numstack.push(num);\n                strstack.push(res);//将未遇到[之前的字母加入栈,同时也可以防止stack出现空栈出栈异常问题，用来存放上一次解码的数据\n                num = 0;\n                res = \"\";//置空后的res用于存储[]内的字符串\n            } else if (Character.isLetter(c)) {\n                res += c;\n            } else if (c == ']') {\n                String temp = \"\";\n                int count = numstack.pop();\n                for (int j = 0; j < count; j++) {\n                    temp = temp + res;\n                }\n                res = strstack.pop() + temp;//strstack用于存储上次解码后的结果\n               \n            }\n        }\n        return res;\n    }\n```\n**复杂度**\n+ 空间复杂度$O(n)$\n+ 时间复杂度$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918690248","body":"**思路**\n利用两个栈保存队列的出队和入队顺序\n**代码**\n```java\nclass MyQueue {\n        Stack<Integer> in;\n        Stack<Integer> out;\n        /** Initialize your data structure here. */\n        public MyQueue() {\n            in=new Stack<>();\n            out=new Stack<>();\n        }\n\n        /** Push element x to the back of queue. */\n        public void push(int x) {\n            in.push(x);\n            out.clear();\n            for (int i=in.size()-1; i >=0; i--) {\n                out.push(in.get(i));\n            }\n             \n        }\n\n        /** Removes the element from in front of queue and returns that element. */\n        public int pop() {\n            in.clear();\n            \n            int data=out.pop();\n            for (int i =out.size()-1; i >=0; i--) {\n                in.push(out.get(i));\n            }\n            return data;\n        }\n\n        /** Get the front element. */\n        public int peek() {\n            return out.peek();\n        }\n\n        /** Returns whether the queue is empty. */\n        public boolean empty() {\n            return in.isEmpty();\n        }\n}\n```\n**复杂度**\n+ 空间复杂度$O(1)$\n+ 时间复杂度$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920092733","body":"**思路**\r\n当块内之和相同时，就可以进行分块\r\n**代码**\r\n```java\r\npublic int maxChunksToSorted(int[] arr) {\r\n        int sum1=0;\r\n        int sum2=0;\r\n        int ans = 0;\r\n        int sort[] = Arrays.copyOf(arr, arr.length);\r\n        Arrays.sort(sort);\r\n        for (int i = 0; i < arr.length; i++) {\r\n          sum1+=arr[i];\r\n          sum2+=sort[i];\r\n          if(sum1==sum2)\r\n          {\r\n              ans++;\r\n          }\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n**复杂度**\r\n+ 时间复杂度$O(nlogn)$\r\n+ 空间复杂度$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920971370","body":"**思路**\n统计出链表的个数，然后求余，即可知道需要旋转几次\n**代码**\n```java\n public ListNode rotateRight(ListNode head, int k) {\n        if(head==null)\n            {\n            return head;\n        }\n        ListNode temp=new ListNode(1);\n        temp.next=head;\n        temp=temp.next;\n        int count=0;\n        ListNode rotate=new ListNode(1);\n        rotate.next=head;\n        while(temp!=null)\n            {\n            count++;\n            temp=temp.next;\n            }\n        if(k%count==0)\n        {\n         return head;\n        }\n        ListNode first=head;\n        for(int i=0;i<count-k%count;i++){\n         head=head.next;\n}\n        ListNode newhead=head;\n        for(int i=0;i<k%count-1;i++)\n        {\n          head=head.next;\n}\n        ListNode kk=first;\n        for(int i=0;i<count-k%count-1;i++)\n            {\n            first=first.next;\n            }\n        first.next=null;\n        head.next=kk;\n        return newhead;\n    }\n```\n**复杂度**\n+ 时间复杂度$O(n)$\n+ 空间复杂度$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921868961","body":"**思路**\n利用递归完成翻转\n**代码**\n```java\npublic ListNode swapPairs(ListNode head) {\n        if(head==null || head.next==null)\n        {\n            return head;\n        }\n        ListNode next=head.next;\n        head.next=swapPairs(next.next);\n        next.next=head;\n        return next;\n    }\n```\n**复杂度**\n+ 时间复杂度O(N)\n+ 空间复杂度O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922443241","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n示例 2：\n\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n0 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]\n\n \n\n进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n将A的所有节点存入hashset，再遍历整个B查看B中是否存在相同地址的节点\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        HashSet<ListNode> set=new HashSet<>();\n        while(headA!=null)\n        {\n            set.add(headA);\n            headA=headA.next;\n        }\n        while (headB!=null)\n        {\n            if(set.contains(headB))\n            {\n                return headB;\n            }\n            headB=headB.next;\n        }\n        return null;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"max-qaq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916766187","body":"## 思路\n\n从个位开始，向高位加\n\n## 关键点\n\n- \n\n## 代码\n\n- \n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        int i = n - 1;\n        int carry = 0;\n        List<Integer> list = new ArrayList<>();\n        while(i>=0 || k > 0){\n            int sum = 0;\n            int num1 = i>=0? num[i] : 0;\n            int num2 = k>0? k%10 : 0;\n            sum = num1 + num2 + carry;\n            carry = sum / 10;\n            list.add(sum % 10);\n            i--; k/=10;\n        }\n        if(carry != 0) list.add(carry);\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917443011","body":"821. 字符的最短距离\r\n难度简单194\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n示例 1：\r\n输入：s = \"loveleetcode\", c = \"e\" 输出：[3,2,1,0,1,0,0,1,2,2,1,0] 解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。 距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。 距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。 对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。 距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。 \r\n提示：\r\n示例 2：\r\n输入：s = \"aaab\", c = \"b\" 输出：[3,2,1,0] \r\n\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n思路\r\n找最短距离，遍历两次，一次从左往右，一次从右往左\r\n以后比较两端距离的都可以这么做吧（大概）\r\n关键点\r\n代码\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int ptr = Integer.MAX_VALUE / 2;\r\n        char [] chs = s.toCharArray();\r\n        int n = chs.length;\r\n        int [] tag = new int[n];\r\n        for(int i=0;i<n;i++){\r\n            if(chs[i] != c){\r\n                tag[i] = Math.abs(i - ptr);\r\n            }else{\r\n                tag[i] = 0;\r\n                ptr = i;\r\n            }\r\n        }\r\n        for(int i=n-1;i>=0;i--){\r\n            if(chs[i] != c){\r\n                if(Math.abs(i - ptr) < tag[i]){\r\n                    tag[i] = Math.abs(i - ptr);\r\n                }\r\n            }else{\r\n                tag[i] = 0;\r\n                ptr = i;\r\n            }\r\n        }\r\n        return tag;\r\n    }\r\n}\r\n复杂度分析\r\n令 n 为数组长度。\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661673","body":"### 思路\r\n\r\n数组模拟栈\r\n\r\n### 代码\r\n\r\n~~~Java\r\nint[] data;\r\n    int head;\r\n\r\npublic CustomStack(int maxSize) {\r\n\r\n    data = new int[maxSize];\r\n    head = -1;\r\n}\r\n\r\npublic void push(int x) {\r\n\r\n    if (head == data.length - 1)\r\n        return;\r\n        \r\n    data[++head] = x;\r\n}\r\n\r\npublic int pop() {\r\n\r\n    if (head == -1)\r\n        return -1;\r\n\r\n    return data[head--];\r\n}\r\n\r\npublic void increment(int k, int val) {\r\n\r\n    for (int i = 0; i < Math.min(k, head + 1); i++)\r\n        data[i] += val;\r\n}\r\n```\r\n\r\n### \r\n~~~\r\n\r\n### 复杂度分析\r\n\r\n#### 时间复杂度：\r\n\r\n#### 空间复杂度：\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918312197","body":"## 思路：括号嵌套，可以用栈\r\n\r\n## 关键点：两个栈\r\n\r\n## 代码：\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Deque<Integer> numstack = new LinkedList<>();\r\n        Deque<String> sstack = new LinkedList<>();\r\n        StringBuilder res = new StringBuilder(\"\");//结果\r\n        int mult = 0;//倍数\r\n\r\n        for(Character ch : s.toCharArray()){\r\n            if(ch == '['){\r\n                numstack.addLast(mult);\r\n                sstack.addLast(res.toString());\r\n                mult = 0;\r\n                res = new StringBuilder(\"\");\r\n            }else if(ch == ']'){\r\n                int cur_mult = numstack.removeLast();\r\n                StringBuilder tempsb = new StringBuilder(\"\");\r\n                for(int i=0;i<cur_mult;i++){\r\n                    tempsb.append(res.toString());\r\n                }\r\n                res = new StringBuilder(sstack.removeLast() +tempsb.toString() );\r\n            }else if(ch >= '0' && ch <= '9'){\r\n                mult = mult * 10 + Integer.parseInt(ch + \"\");\r\n            }else{\r\n                res.append(ch);\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析：\r\n\r\n时间复杂度：遍历一次，O(n)\r\n\r\n空间复杂度：应该也是O(n)\r\n自己独立做不出。。要加油啊","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919099930","body":"## 思路：双栈，一个用输入，一个用输出\r\n\r\n## 关键点：输出栈空了之后再放数据，减小时间复杂度\r\n\r\n## 代码：\r\n\r\n```java\r\nclass MyQueue {\r\n    \r\n    Deque<Integer> inputStack;\r\n    Deque<Integer> outputStack;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inputStack = new LinkedList<>();\r\n        outputStack = new LinkedList<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inputStack.addLast(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(outputStack.isEmpty()){\r\n            while(!inputStack.isEmpty()){\r\n                outputStack.addLast(inputStack.removeLast());\r\n            }\r\n        }\r\n        return outputStack.removeLast();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(outputStack.isEmpty()){\r\n            while(!inputStack.isEmpty()){\r\n                outputStack.addLast(inputStack.removeLast());\r\n            }\r\n        }\r\n        return outputStack.getLast();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inputStack.isEmpty()&&outputStack.isEmpty();\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 复杂度分析：\r\n\r\n时间复杂度：均摊O(n)\r\n\r\n空间复杂度：应该也是O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920993701","body":"## 思路：看成环，然后把结尾断开一下就好了\n\n## 关键点：算一下结尾的位置\n\n## 代码：\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(k == 0 || head == null || head.next == null) return head;\n        ListNode pre = head;\n        int n = 1;\n        while(pre.next != null){\n            n++;\n            pre = pre.next;\n        }\n        int add = n - k%n;\n        if(add == n) return head;\n        pre.next = head;\n        while(add != 0){\n            add--;\n            pre = pre.next;\n        }\n        ListNode res = pre.next;\n        pre.next = null;\n        return res;\n\n\n    }\n}\n```\n\n## 复杂度分析：\n\n时间复杂度：O(n) 遍历两次\n\n空间复杂度：应该也是O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916768752","body":"# 思路\n类型转换+数位迭代计算\n\n# 代码\n``` python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:    \n        a_ = ''\n        for i in num:\n            a_ += str(i)\n        a_ = ''.join(a_)\n        sum_result = int(a_) + k\n        \n        res_array = []\n        while(sum_result>0):\n            res_array.insert(0, sum_result%10)\n            sum_result = sum_result // 10\n        if len(res_array) == 0:\n            res_array.append(0)\n        return res_array    \n```\n\n# 复杂度分析\n* 时间复杂度O(N)\n* 空间复杂度O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BpointA":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916771959","body":"### 思路\n模拟竖式的运算。首先将两个数转化为长度相同的数组，再从末位向前计算，依次进位。\n### python3代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        add=[int(i) for i in str(k)]\n        if len(add)>len(num):\n            a=[0]+add\n            b=[0]*(len(add)-len(num)+1)+num\n        else:\n            a=[0]+num\n            b=[0]*(len(num)-len(add)+1)+add\n        res=[0]*len(a)\n        for i in range(len(a)-1,0,-1):\n            k=a[i]+b[i]+res[i]\n            res[i]=k%10\n            res[i-1]=k//10\n        if res[0]==0:\n            return res[1:]\n        return res\n```\n### 复杂度\n时间复杂度：O(n) n为较长数组的长度\n\n空间复杂度：O(n)  n为答案数组的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917035360","body":"### 思路\n分别遍历两次数组。\n第一次从右向左遍历，记录s每个字母与最近的c的距离。第二次从左向右遍历，同步将距离更新为左右中较小的距离。\n\n### python3代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res=[len(s)]*len(s)\n        temp=len(s)\n        for i in range(len(s)-1,-1,-1):\n            if s[i]!=c and temp==len(s):\n                continue\n            elif s[i]==c:\n                temp=i\n                res[i]=0\n            else:\n                res[i]=temp-i\n        temp=-1\n        for i in range(len(s)):\n            if s[i]!=c and temp==-1:\n                continue\n            elif s[i]==c:\n                temp=i\n                res[i]=0\n            else:\n                res[i]=min(res[i],i-temp)\n        return res                              \n```\n### 复杂度分析\n时间复杂度：O(n) 其中n为数组长度，具体时间复杂度为O(2n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917433958","body":"### 思路\r\n直接利用栈的基本操作实现\r\n\r\n### Python3代码\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.m=maxSize\r\n        self.stk=[]\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stk)<self.m:\r\n            self.stk.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stk)==0:\r\n            return -1\r\n        return self.stk.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(k):\r\n            if i<len(self.stk):\r\n                self.stk[i]+=val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：increment为O(k)，insert和pop为O(1)\r\n\r\n空间复杂度：O(maxsize)\r\n\r\n### 优化\r\n可利用差分法思想，利用add数组累积求和，这样increment的时候只需记录增量，将其时间复杂度同样降到O(1)。\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.m=maxSize\r\n        self.stk=[]\r\n        self.add=[]\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stk)<self.m:\r\n            self.stk.append(x)\r\n            self.add.append(0)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stk)==0:\r\n            return -1\r\n        v=self.stk.pop()\r\n        i=self.add.pop()\r\n        if len(self.add)>0:\r\n            self.add[-1]+=i\r\n        return v+i\r\n        \r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        t=min(len(self.stk),k)\r\n        if t>=1:\r\n            self.add[t-1]+=val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917908130","body":"### 思路 \r\n想到类似基本计算器的栈，但是实操没出来。最后自己用递归做的，依次解开括号，得到答案。\r\n\r\n### Python代码\r\n```Python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        if \"]\" not in s:\r\n            return s\r\n        idx=s.index(\"]\")\r\n        j=idx\r\n        while j>=0 and s[j]!=\"[\":\r\n            j-=1\r\n        t=j-1\r\n        while s[t].isdigit():\r\n            t-=1\r\n        k=int(s[t+1:j])\r\n        words=s[j+1:idx]\r\n        replace=words*k\r\n        s_new=s[:t+1]+replace+s[idx+1:]\r\n        return self.decodeString(s_new)\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(n^2) n为字符串长度\r\n\r\n空间复杂度：O(n)\r\n\r\n### 优化\r\n学习了官方题解的栈思想，括号匹配这种其实只要一个栈就够了，之前想歪了。改成栈之后只用一次遍历，时间复杂度为O(n)。\r\n```Python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        i=0\r\n        stk=[]\r\n        while i<len(s):\r\n            if s[i]!=\"]\":\r\n                stk.append(s[i])\r\n            else:\r\n                word=\"\"\r\n                while stk[-1]!=\"[\":\r\n                    word=stk.pop()+word\r\n                stk.pop()\r\n                num=0\r\n                k=0\r\n                while len(stk)>0 and stk[-1].isdigit():\r\n                    num=pow(10,k)*int(stk.pop())+num\r\n                    k+=1\r\n                stk.append(word*num)\r\n            i+=1\r\n        return \"\".join(stk)\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918375325","body":"### 思路\n使用双栈。一个输入，一个输出。在输出栈用pop，将结果push到输入栈，即可保持输出栈pop结果与队列相同。\n\n### Python3代码\n```Python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.instk=[]\n        self.outstk=[]\n        \n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.instk.append(x)\n        \n       \n  \n    \n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if len(self.outstk)==0:\n            while len(self.instk)>0:\n                self.outstk.append(self.instk.pop())\n        \n        return self.outstk.pop()\n        \n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if len(self.outstk)==0:\n            while len(self.instk)>0:\n                self.outstk.append(self.instk.pop())\n        \n        return self.outstk[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.instk)==0 and len(self.outstk)==0\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### 复杂度\n时间复杂度：O(1)，均是push和pop的组合\n\n空间复杂度：O(n)，n为栈长度，共利用了两个栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919352047","body":"### 思路\n因为做过非重复版本，第一反应就是拿排序后的数组与原数组对应位置的最大值进行对比，考虑重复情况，增加了一个最大值计数数组。这样，只有当原数组在对应位置有指定数量的最大值时，才能分块（虽然过了，但是有点不知道怎么证明，有点类似贪心？）\n\n### Python3代码\n```Python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        c=0\n        #排序数列\n        x=arr[:]\n        x.sort()\n        #排序数列计数\n        count=[0]*len(arr)\n        count[0]=1\n        #原数列最大值\n        mx=[0]*len(arr)\n        mx[0]=arr[0]\n        #原数列最大值计数\n        mc=[0]*len(arr)\n        mc[0]=1\n  \n        \n        for i in range(1,len(arr)):\n            mx[i]=max(mx[i-1],arr[i])\n            if arr[i]==mx[i-1]:\n                mc[i]=mc[i-1]+1\n            else:\n                if arr[i]>mx[i-1]:\n                    mc[i]=1\n                else:\n                    mc[i]=mc[i-1]\n            if x[i]==x[i-1]:\n                count[i]=count[i-1]+1\n            else:\n                count[i]=1\n       \n      \n        for i in range(len(arr)):\n            \n            if mx[i]==x[i] and mc[i]==count[i] :\n                c+=1\n        return c\n```\n###\n时间复杂度：O(nlogn) ，排序数列复杂度\n\n空间复杂度：O(n)，新建的数组\n\nn为arr长度\n        \n         ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920182216","body":"### 思路\n第一步，计算链表长度，k与长度的模。这里有两种特殊情况，一是模为零，则直接返回head，另一种是长度为0，返回None。\n第二步，根据模，确定三个点，start(旋转后的head)，pre（原链表start的前一个节点），point（原链表最后结点）\n第三步，pre的next设为None(防止成环)，point的next设为head，return start即可\n\n### Python3代码\n```Python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        c=0\n        t=head\n        while t!=None:\n            c+=1\n            t=t.next     \n        if c==0:\n            return None\n       \n        idx=k%c\n        if idx==0:\n            return head\n        pre=None\n        start=head\n        j=0\n        while j<c-idx:\n            pre=start\n            start=start.next\n            j+=1\n        pre.next=None\n        res=start\n        cnt=0\n        point=start\n        while point.next!=None:\n            point=point.next\n        point.next=head\n            \n        return res\n```        \n        \n        \n### 复杂度\n时间复杂度 ：O(n)       \n空间复杂度：O(1)\n        \n        \n        \n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921047718","body":"### 思路\r\n递归。每次递归只需完成前两个节点的交换，递归出口为单节点（原节点数为奇数）和零节点（原节点数为偶数）\r\n\r\n### Python3代码\r\n```Python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if head==None or head.next==None:\r\n            return head\r\n        a=head\r\n        b=head.next\r\n        c=self.swapPairs(head.next.next)\r\n        b.next=a\r\n        a.next=c\r\n        return b\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)\r\n\r\n### 补充\r\n迭代方法\r\n```Python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if head==None or head.next==None:\r\n            return head\r\n        dummy=ListNode(0)\r\n        dummy.next=head\r\n        t=dummy\r\n        while t.next!=None and t.next.next!=None:\r\n            p1=t.next\r\n            p2=t.next.next\r\n            p1.next=p2.next\r\n            p2.next=p1\r\n            t.next=p2\r\n            t=t.next.next\r\n        return dummy.next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921963688","body":"### 思路\n快慢指针找中点，再从中点做左右切割，利用递归得到树。递归出的条件：链表没有节点。\n### Python3代码\n```Python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if head==None:\n            return head\n        if head.next==None:\n            return TreeNode(head.val)\n        slow=head\n        fast=head\n        pre=None\n        while fast!=None and fast.next!=None:\n            fast=fast.next.next\n            pre=slow\n            slow=slow.next\n        pre.next=None\n        left=self.sortedListToBST(head)\n        right=self.sortedListToBST(slow.next)\n        t=TreeNode(slow.val)\n        t.left=left\n        t.right=right\n        return t\n```\n\n### 复杂度\n时间复杂度：O(nlogn)        \n空间复杂度：O(logn)\n（logn为构造二叉树需要的空间）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922336790","body":"### 思路\n暴力法，利用数组求解。用两个数组存储两个链表的节点，再从末尾开始扫描，直到找到不同的值为止。\n\n### Python3代码\n```Python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        lst1=[]\n        lst2=[]\n        a=headA\n        while a!=None:\n            lst1.append(a)\n            a=a.next\n        \n        b=headB\n        while b!=None:\n            lst2.append(b)\n            b=b.next     \n        lst1.reverse()  \n        lst2.reverse()\n        n=min(len(lst1),len(lst2))\n        if lst1[0]!=lst2[0]:\n            return None\n        for i in range(1,n):\n            if lst1[i]!=lst2[i]:\n                return lst1[i-1]\n        if len(lst1)<len(lst2):\n            return lst1[-1]\n        else:\n            return lst2[-1]\n```\n\n### 复杂度\n时间复杂度：O(m+n)，遍历两次链表，m,n为两个链表的长度\n\n空间复杂度：O(m+n)，构建了两个数组\n\n### 优化\n利用数学推导，可发现在一次遍历，O(1)空间复杂度下完成此题的策略。其逻辑是，当一个结点走到链表终点的时候，将其挪到另一链表起点。这样，二者在相交点时走过的路一样长，可以跳出循环。\n```Python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n       a=headA\n       b=headB\n       while a!=b:\n           if a==None:\n               a=headB\n           else:\n               a=a.next\n           if b==None:\n               b=headA\n           else:\n               b=b.next\n       return a\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922500129","body":"### 思路\r\n单指针，用哈希表辅助查找。如果碰到None则返回None，如果指针指向的结点已经在哈希表中，则返回该结点。\r\n\r\n### Python3代码\r\n```Python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        has=set()\r\n        t=head\r\n        while t!=None:\r\n            if t in has:\r\n                return t\r\n            has.add(t)\r\n            t=t.next\r\n        return None\r\n        \r\n```\r\n\r\n### 复杂度\r\n时间复杂度:O(n) 遍历一次链表\r\n\r\n空间复杂度:O(n) 利用哈希表求解\r\n\r\n### 优化\r\n利用数学推导，可得到通过快慢指针找入口的方法。其本质是，快指针在相遇时已比慢指针多跑了n圈，将快指针移到头部，二者以相同速度移动，就能在入口相遇。遍历了两次链表，但能将空间复杂度缩为 O(1)\r\n```Python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow=head\r\n        fast=head\r\n        while fast!=None and fast.next!=None:\r\n            fast=fast.next.next\r\n            slow=slow.next\r\n            if fast==slow:\r\n                break\r\n        if fast==None or fast.next==None:\r\n            return None\r\n        fast=head\r\n        while fast!=slow:\r\n            fast=fast.next\r\n            slow=slow.next\r\n        return fast\r\n\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sxr000511":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916776310","body":"\n\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n \n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n \n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 思路\n模仿加法计算过程，通过商和余数完成进位\n\njs里没整型数据，需要Math.floor()向下取整，要不然`/`得到的是小数\n\n## 关键点\n有几个边界条件要考虑\n\n1. 输入[0] 23 或者  [0],10000---》数组短，数据长，不能在数组结束就跳出循环\n\n```javascript\n        const x = i >= 0 ? A[i] : 0\n        const y = K != 0 ? K % 10 : 0\n```\n2. 输入 [2,1,5],806   ---》最高位有进位，不能跳出循环\n\n```javascript\n if (carry) res.push(carry)\n```\n3. 循环的条件是：(i >=0 || K != 0)，K不为零用来处理数组短的情况\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(A, K) {\n    const res = []\n    let i = A.length - 1, carry = 0\n    while (i >=0 || K != 0) {\n        //处理边界条件\n        const x = i >= 0 ? A[i] : 0\n        const y = K != 0 ? K % 10 : 0\n\n        const sum = x + y + carry\n        res.push(sum % 10)\n        carry = Math.floor(sum / 10)\n\n        i--\n        K = Math.floor(K / 10)\n    }\n    //处理最高位进位\n    if (carry) res.push(carry)\n    return res.reverse()\n};\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351193","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 思路\n\n### 自己的版本\n\n很简单的做法，三个指针\n\nindex ：定位字符\n\nfront：字符前或空\n\nend：字符后一个或空\n\n通过判断`s[index]`, 's[front]', 's[end]' 是否和 c相同即可，相同push进abs坐标\n\n\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n//  match 返回所有index 直接用+- min 计算\nvar shortestToChar = function(s, c) {\n    let index = 0;\n    let front = index +1;\n    let end = index - 1;\n    let answer = [];\n    let len  = s.length - 1;\n    while(index <= len ){\n    let head = s[front]?s[front]:'';\n    let tail = s[end]?s[end]:'';\n    if( s[index] ===c){\n        answer.push(0);\n        index++;\n        front = index +1;\n        end = index - 1;\n    }else if( head === c){\n        answer.push( Math.abs(front-index));\n        index++;\n        front = index +1;\n        end = index - 1;\n    }else if( tail === c){\n        answer.push(Math.abs(end-index));\n        index++;\n        front = index +1;\n        end = index - 1;\n    }else{\n        front++;\n        end--;\n    }\n    }\n    return answer\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917627494","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n\n## 思路\n\n### 我的版本：（菜狗）\n\n没啥好讲的，好简单的思路，js总是不讲武德\n\n### 通过hashMap 保存 inc操作\n\n![](https://pic.leetcode-cn.com/9e63bf59b9f83c4407bf0ef6a7a58a14b9e63fe01bc91b9a56c189982439acdd-custom_stack.png)\n\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n### 1. array模拟stack\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize;\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\nif( this.stack.length < this.maxSize){\n    this.stack.push(x);\n    return null;\n}else{\n    return null;\n}\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if( this.stack.length === 0 ){\n        return -1\n    }else{\n        return this.stack.pop();\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let helper = [];\n     k = k > this.stack.length ? this.stack.length : k;\n    for ( let i = this.stack.length-1 ; i >= 0 ; i--){\n        helper.push(i >= k ? this.stack.pop() : this.stack.pop()+val)\n    }\n    for ( let i = helper.length-1 ; i >= 0 ; i--){\n        this.stack.push(helper.pop())\n    }\n};\n\n//或者……………………\nCustomStack.prototype.increment = function(k, val) {\n      if(k>= this.stack.length ){\n        this.stack = this.stack.map(item => item+val)\n    }else{\n        for(let i=0;i<k;i++){\n            this.stack[i] += val\n        }\n    }\n};\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n### 2.  通过hashMap ：\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.list = []\n  this.maxSize = maxSize\n  this.hashMap = {}\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nCustomStack.prototype._setInc = function (key, value) {\n  if (!(key in this.hashMap)) {\n    this.hashMap[key] = 0\n  }\n  this.hashMap[key] += value\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nCustomStack.prototype._getInc = function (key) {\n  return this.hashMap[key] || 0\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype._size = function () {\n  return this.list.length\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this._size() < this.maxSize) {\n    this.list.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  const top = this._size() - 1\n  const inc = this._getInc(top)\n\n  let item = this.list.pop()\n  if (item === void 0) {\n    return -1\n  }\n\n  item += inc\n  const newTop = top - 1\n  this._setInc(newTop, inc)\n  this.hashMap[top] = 0\n  return item\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  const size = this._size()\n  k = k < size ? k - 1 : size - 1\n  this._setInc(k, val)\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：\n1. 方法1\n$O(1)$ push pop      $O(k)$inc取决于修改几个\n\n2. 方法2\n时间复杂度 O(1) 的增量操作，不过代价就是额外的 O(n) 空间。\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918221764","body":"\n## 题目地址(394. 字符串解码)\n\nhttps://leetcode-cn.com/problems/decode-string/\n\n## 题目描述\n\n```\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n \n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n\n示例 3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n示例 4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst decodeString = (s) => {\n    let numStack = [];        // 存倍数的栈\n    let strStack = [];        // 存 待拼接的str 的栈\n    let num = 0;              // 倍数的“搬运工”\n    let result = '';          // 字符串的“搬运工”\n    for (const char of s) {   // 逐字符扫描\n        if (!isNaN(char)) {   // 遇到数字\n            num = num * 10 + Number(char); // 算出倍数\n        } else if (char == '[') {  // 遇到 [\n            strStack.push(result); // result串入栈\n            result = '';           // 入栈后清零\n            numStack.push(num);    // 倍数num进入栈等待\n            num = 0;               // 入栈后清零\n        } else if (char == ']') {  // 遇到 ]，两个栈的栈顶出栈\n            let repeatTimes = numStack.pop(); // 获取拷贝次数\n            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\n        } else {                   \n            result += char;        // 遇到字母，追加给result串\n        }\n    }\n    return result;\n};\n\n\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919271410","body":"\n## 题目地址(232. 用栈实现队列)\n\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n## 题目描述\n\n```\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\n实现 MyQueue 类：\n\nvoid push(int x) 将元素 x 推到队列的末尾\nint pop() 从队列的开头移除并返回元素\nint peek() 返回队列开头的元素\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n \n\n说明：\n\n你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n进阶：\n\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\n\n \n\n示例：\n\n输入：\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n\n\n \n\n提示：\n\n1 <= x <= 9\n最多调用 100 次 push、pop、peek 和 empty\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\n```\n\n\n\n## 思路\n\n栈：先入后出\n\n队列：先入先出\n\n思路：\n\n1. 第一个栈用来尾插\n\n2. 第二个栈用来头删：\n   1. 为空，把stack1 全都pop出来，push进stack2，stack2再pop就是先入先出头删的顺序\n   2. 不为空，直接pop stack2\n\n\n\n```javascript\nvar CQueue = function() {\nthis.stack1 = []; this.stack2 = [];\n};\n\n/** \n * @param {number} value\n * @return {void}\n */\nCQueue.prototype.appendTail = function(value) {\nthis.stack1.push(value);\nreturn null\n};\n\n/**\n * @return {number}\n */\nCQueue.prototype.deleteHead = function() {\nif( this.stack2.length === 0 )\n{this.stack2 = this.stack1.reverse(); this.stack1 = [];}\nreturn this.stack2.pop()||-1;\n\n\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919606672","body":"\n## 题目地址(768. 最多能完成排序的块 II)\n\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n\n## 题目描述\n\n```\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\n\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n示例 1:\n\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n\n\n示例 2:\n\n输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n\n\n注意:\n\narr的长度在[1, 2000]之间。\narr[i]的大小在[0, 10**8]之间。\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n    const sorted = [...arr];\n    sorted.sort((a, b) => a - b);\n\n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n\n        if (sum1 === sum2) {\n            count++;\n            sum1 = sum2 = 0; // 这行不要也可以啦\n        }\n    }\n\n    return count;\n};\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920913036","body":"\n## 题目地址(61. 旋转链表)\n\nhttps://leetcode-cn.com/problems/rotate-list/\n\n## 题目描述\n\n```\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n\n \n\n示例 1：\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n\n示例 2：\n\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n\n \n\n提示：\n\n链表中节点的数目在范围 [0, 500] 内\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head || !head.next) return head;\n  let count = 0,\n    now = head;\n  while (now) {\n    now = now.next;\n    count++;\n  }\n  k = k % count;\n  let slow = (fast = head);\n  while (fast.next) {\n    if (k-- <= 0) {\n      slow = slow.next;\n    }\n    fast = fast.next;\n  }\n  fast.next = head;\n  let res = slow.next;\n  slow.next = null;\n  return res;\n};\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921415742","body":"\n## 题目地址(24. 两两交换链表中的节点)\n\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n## 题目描述\n\n```\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n \n\n示例 1：\n\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n\n示例 2：\n\n输入：head = []\n输出：[]\n\n\n示例 3：\n\n输入：head = [1]\n输出：[1]\n\n\n \n\n提示：\n\n链表中节点的数目在范围 [0, 100] 内\n0 <= Node.val <= 100\n\n \n\n进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\n```\n\n## 思路\n\n### 1. 递归\n\n后序遍历：后面所有的节点都已经处理好了【后序遍历： 迭代在操作的前面】\n\n```javascript\ndef dfs(head):\n    if not head or not head.next: return head\n    res = dfs(head.next)\n    # 主逻辑（改变指针）在进入后面的节点的后面，也就是递归返回的过程会执行到\n    head.next.next = head\n    head.next = None\n\n    return res\n```\n时间on 空间on （递归调用栈）\n\n题解：\n\n```javascript\nvar swapPairs = function(head) {\n    if (head === null|| head.next === null) {\n        return head;\n    }\n//第二个node是newHead\n    const newHead = head.next;\n//递归newHead.next 表示newHead.next后面的都已经处理好了，旧头接上了，来处理新头（来处理最开始的俩）\n    head.next = swapPairs(newHead.next);\n    newHead.next = head;\n    return newHead;\n};\n```\n\n### 2. 迭代：以每两个node为一组，添加虚拟头节点\n\n添加一个虚拟头节点，因为head也要被更改\n\n再把这个虚拟头拷贝一份出来， 用作迭代\n\n1. 虚拟头记录新头\n\n2. 内部更改方向\n\n3. 新尾部指向原来的尾部\n\n4. 把虚拟头移动到第二个上面\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    var newhead = new ListNode();\n    newhead.next = head;\n    var myhead = newhead;\n    while(myhead.next !==null  && myhead.next.next !== null ){\n    var fast = myhead.next.next;\n    var slow = myhead.next;\n    // start to exchange\n    myhead.next = fast;\n    slow.next = fast.next;\n    fast.next = slow;\n    myhead = slow;\n    }\nreturn newhead.next\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922279647","body":"\n## 题目地址(109. 有序链表转换二叉搜索树)\n\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\n\n## 题目描述\n\n```\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n示例:\n\n给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n\n```\n\n## 思路\n提供的单链表 已经按 升序排列 \n\n### 1. 快慢指针，分治递归\n\n【递归】\n\n1. 获取当前链表的中点\n\n2. 以链表中点为根\n\n3. 中点左边的值都小于它,可以构造左子树【参数是左子树的头和左子树的尾 head + slow】\n\n4. 同理构造右子树【右子树的头 +  右子树的尾  slow.next（右子树的头） + tail （右子树的尾）】\n\n5. 【循环】第一步---》递归\n\n### 2. 在递归基础上，用数组减少查询\n\n可以使用数组将链表的值存储,以空间换时间。\n\n```javascirpt\n// 变数组res[]\nvar sortedListToBST = function (head) {\n  let res = [];\n  while (head) {\n    res.push(head.val);\n    head = head.next;\n  }\n  return dfs(res, 0, res.length - 1);\n};\n\n// 查找位置不用On，用数组存起来以后变o1\nfunction dfs(res, l, r) {\n  if (l > r) return null;\n  let mid = parseInt((l - r) / 2 + r);\n  let root = new TreeNode(res[mid]);\n// 左侧\n  root.left = dfs(res, l, mid - 1);\n//右侧  \nroot.right = dfs(res, mid + 1, r);\n  return root;\n}\n```\n\n## 关键点\n\n【时间复杂度】如果有递归那就是：递归树的节点数 * 递归函数内部的基础操作数\n\n【总的空间复杂度 】如果有递归那就是： 递归深度 * 每一层基础操作数\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if(!head){\n        return null;\n    }\n    return dfs(head,null);\n};\n// 分治\nfunction dfs( head, tail){\n    if( head === tail) {\n        return null;\n    }\n    let fast = head;\n    let slow = head;\n    // 二倍快慢指针\n    while( fast !== tail && fast.next !== tail){\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    let root = new TreeNode(slow.val);\n    // 上一段\n    root.left = dfs( head, slow);\n    // 下一段\n    root.right = dfs( slow.next , tail);\n\n    return root;\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为链表长度。\n\n画出如下的**递归树**。\n\n![](https://tva1.sinaimg.cn/large/008i3skNly1gqmduc0j3dj314d0jk7ju.jpg)\n\n由于递归树的深度为 logn因此【空间复杂度就是 logn 】\n\n 递归函数内部的空间复杂度，由于递归函数内空间复杂度为 O(1），\n\n因此总的空间复杂度为 O(logn)。\n\n时间复杂度：递归树的【深度为 logn】，每【一层的基本操作数为 n】，因此总的【时间复杂度为O(nlogn)】\n\n空间复杂度：空间复杂度为O(logn)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922469545","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n示例 2：\n\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n0 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]\n\n \n\n进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 思路\n\n### 1. 哈希表法\n把一个single linked存到哈希表里（注意存的是节点），\n\n【有相交是说从此处开始节点相同】\n\n再遍历另一个linked 看 哈希表里有没有has\n\n时间on 空间on\n\n### 2. 数学推理法\n\n使用两个指针如指针 a, b 分别指向 A, B 这两条链表的头节点, 两个指针以相同的速度向后移动。\n\n当 a 到达链表 A 的尾部时，将它重定位到链表 B 的头节点；\n\n当 b 到达链表 B 的尾部时，将它重定位到链表 A 的头节点；\n\n若在此过程中 a, b 指针相遇，则相遇节点为两链表相交的起始节点，否则说明两个链表不存在相交点。\n\n（ 原理 ：A+C  +  B   ===   A+B + C ）\n\n时间on 空间o1\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\n\n// //////////////////////////////\n// 1. 哈希法\n//  哈希表里添加的是节点，不是节点的值\n// 链表有相交 ： 找到相交的节点\n// var getIntersectionNode = function(headA, headB) {\n//     var rem = new Set();\n//     while(  headA !== null){\n//         rem.add( headA );\n//         headA = headA.next;\n//     }\n//     while ( headB !== null ){\n//         if( rem.has( headB )){\n//             return headB\n//         }else{\n//             headB = headB.next;\n//         }\n//     }\n//     return null;\n// };\n\n// 2. 数学推理 A+C +B   ===  A+B +C\nvar getIntersectionNode = function (headA, headB) {\n  let a = headA,\n    b = headB;\n  while (a != b) {\n    a = a === null ? headB : a.next;\n    b = b === null ? headA : b.next;\n  }\n  return a;\n};\n\n```\n\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"july-aha":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916798881","body":"# 思路\nJavaScript api解决\n\n# 代码\n```javascript\nvar addToArrayForm = function (num, k) {\n    return (BigInt(num.join(\"\")) + BigInt(k)).toString().split('')\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917630173","body":"```Javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    } else {\n        return;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    if (this.stack.length > 0) {\n        return this.stack.pop();\n    } else {\n        return -1;\n    }\n\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    if (this.stack.length < k) {\n        return this.stack = this.stack.map((item) => item + val)\n    } else {\n        return this.stack = this.stack.map((item,index) => { return index < k ? item + val : item })\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919133945","body":"```javascript\nMyQueue.prototype.peek = function () {\n   if (!this.b.length) {\n        while (this.a.length) {\n            this.b.push(this.a.pop());\n        }\n    }\n    let last = this.b.pop();\n    this.b.push(last)\n    return last;\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    if(!this.a.length && !this.b.length){\n        return true;\n    }else{\n        return false;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919831886","body":"```javascript\nvar maxChunksToSorted = function (arr) {\n    //最大值栈 \n    let maxStack = [arr[0]];\n    let max = arr[0]\n    for (let i = 1; i < arr.length; i++) {\n\n        if (arr[i] >= max) {\n            //将大于最大值的入栈 \n            max = arr[i]\n            maxStack.push(arr[i])\n        } else {\n            while (maxStack.length && arr[i] < maxStack[maxStack.length - 1]) {\n                maxStack.pop()\n            }\n            maxStack.push(max)\n        }\n\n    }\n    return maxStack.length\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xyinghe":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916799914","body":"#### 链接：\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n#### 思路：\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/jian-dan-yi-dong-javacpythonjs-pei-yang-a8ofe\n\n数组从右往左遍历每一个元素（i--)；\n\n整数每次个位数用到后去掉；\n\n用carry记录进位；\n\n反转结果集；\n\n#### 题解：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int carry = 0;\n        int l1 = num.length -1 ;\n\n        while(l1 >= 0 || k != 0){\n            int x = l1 < 0 ? 0 : num[l1];\n            int y = k == 0 ? 0 : k % 10;\n\n            int sum = x + y + carry;\n            res.add(sum % 10);\n            carry = sum / 10;\n\n            l1--;\n            k = k / 10;\n        }\n        if(carry != 0){\n            res.add(carry);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420695","body":"#### 链接：\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n#### 思路：\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/821zi-fu-de-zui-duan-ju-chi-shi-yong-zhi-n7o9/\n\n首先应该获取到该字符在字符串 s 中的所有下标位置；\n使用O(n)的时间遍历一次字符串，并将等于目标字符的下标添加至动态数组arr中。\n初始化指针p，指向arr的0位置；\n创建 ret 数组，长度为len(s)；\n再次遍历s的过程中，我们需要判断当满足以下两点条件时，指针 p 右移一位\np小于arr最大下标；\n前下标i 到 p + 1的绝对距离比到 p 的绝对距离小；\n每次将 p - i 的绝对距离添加至 ret[i] 中；\n最终返回ret即可；\n\n#### 题解：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        int[] ret = new int[s.length()];\n        int p = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) arr.add(i);\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\n            ret[i] = Math.abs(arr.get(p) - i);\n        }\n        return ret;\n    }\n}\n\n```\n\n#### 复杂度：\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917992928","body":"public String decodeString(String s) {\n        \n        Stack<Character> stack = new Stack<>();\n        \n        for(char c : s.toCharArray())\n        {\n            if(c != ']') \n                stack.push(c); // 把所有的字母push进去，除了]\n            \n            else \n            {\n                //step 1: 取出[] 内的字符串\n                \n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\n                    sb.insert(0, stack.pop());\n                \n                String sub = sb.toString(); //[ ]内的字符串\n                stack.pop(); // 去除[\n                \n                \n                //step 2: 获取倍数数字\n                    \n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek()))\n                    sb.insert(0, stack.pop());\n                    \n                int count = Integer.valueOf(sb.toString()); //倍数\n                \n                \n                //step 3: 根据倍数把字母再push回去\n                \n                while(count > 0)\n                {\n                    for(char ch : sub.toCharArray())  \n                        stack.push(ch);\n                    count--;\n                }\n            }\n        }\n        \n      //把栈里面所有的字母取出来\n        StringBuilder retv = new StringBuilder();\n        while(!stack.isEmpty())\n            retv.insert(0, stack.pop());\n\n        return retv.toString();\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916802793","body":"# 思路\n先将k转成数组，再利用双指针分别从k和num的最后一位开始按位计算。注：需要考虑最后一次进位的情况。\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=989 lang=javascript\n *\n * [989] 数组形式的整数加法\n */\n\n// @lc code=start\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  const kArr = (k + '').split('')\n  let temp = 0\n  const ret = []\n  let i = num.length - 1\n  let j = kArr.length - 1\n  while(i >= 0 || j >= 0) {\n    const sum = (num[i] || 0) + parseInt(kArr[j] || 0) + temp\n    ret.unshift(sum % 10)\n    temp = parseInt(sum / 10)\n    i--\n    j--\n  }\n  if (temp) {\n    ret.unshift(temp)\n  }\n\n  return ret\n};\n// @lc code=end\n\n```\n\n# 复杂度分析\n时间复杂度：O(max(n, log k))，其中 n 为数组的长度。log k为k的位，即log 10(k)，10为底k的对数。\n空间复杂度：O(max(n, log k))。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917425586","body":"# 思路\n- 先正序遍历数组，找目标字符跟右边元素的距离\n- 再反序遍历数组，找目标字符与左边元素的距离，同时取两次距离的最小值\n\n# 代码\njavascript\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  let dis = Infinity\n  const ret = []\n  for (let i = 0; i < s.length; i++) {\n    const cur = s[i]\n    if (cur === c) {\n      dis = 0\n    } else {\n      dis++\n    }\n    ret.push(dis)\n  }\n\n  for (let i = s.length - 1; i >= 0; i--) {\n    const cur = s[i]\n    if (cur === c) {\n      dis = 0\n    } else {\n      dis++\n    }\n    ret[i] = Math.min(dis, ret[i])\n  }\n\n  return ret\n};\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，需要遍历两次数组，正序和反序\n- 空间复杂度：O(n)，返回结果的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917656547","body":"# 思路\n- push方法要限制超过长度时不入栈\n- pop方法为了让所有操作都为O(1)的话，在出栈时再进行增加操作\n  - 出栈时要取出对应的增加值，并与栈顶值相加\n  - 由于数据出栈了，对应位置的加值无用，故对应位置的加值设为0，即默认值\n  - 由于inc方法的k是指栈底的 k 个元素，故此时下一位的加值要加上此次取出的加值，inc方法是栈底k个元素都增加val。\n- increment方法在对应的位置累加上加值即可 O(1)\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=1381 lang=javascript\n *\n * [1381] 设计一个支持增量操作的栈\n */\n\n// @lc code=start\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.size = maxSize\n  this.stack = []\n  this.add = []\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length < this.size) {\n    this.stack.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  // 方法一\n  // return this.stack.pop() || -1\n\n  // 方法二\n  const len = this.stack.length\n  if (len === 0) {\n    return -1\n  }\n\n  const add = this.add[len] || 0\n  // 由于只记录当前栈顶的增加值\n  // 故要更新下一个栈顶\n  this.add[len - 1] = this.add[len - 1] || 0\n  this.add[len - 1] += add\n  // 出栈后，对应位置的增加值无用，重置为0\n  this.add[len] = 0\n\n  const curr = this.stack.pop()\n\n  return curr + add\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  // 方法一\n  // const len = Math.min(this.stack.length, k)\n  // for (let i = 0; i < len; i++) {\n  //   this.stack[i] += val\n  // }\n\n  // 方法二\n  const index = Math.min(this.stack.length, k)\n  this.add[index] = this.add[index] || 0\n  this.add[index] += val\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n// @lc code=end\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(1)，三个方法都是O(1)\n- 空间复杂度：O(n)，一个栈空间和一个加值存放空间，两个都是n的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918044378","body":"# 思路\n- 使用栈来存放最终的输出的内容\n- 遍历字符串\n  - 当非]右括号时，直接入栈\n  - 当遇到]右括号时，开始出栈，直到遇到[左括号。此时的子字符串是要重复的字符串\n  - 继续出栈，取重复次数的数值，考虑到大于9的情况，需要不断取栈的值并判断是否为数字\n  - 由于栈是最终的结果，再加上需要考虑2[3[ab]]嵌套括号的情况，故待重复的子字符串在组合后，要重新入栈中\n\n# 代码\njavascript\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  const stack = []\n  let ret = ''\n  for (let i = 0; i < s.length; i++) {\n    const cur = s[i]\n    if (cur !== ']') {\n      stack.push(cur)\n      continue\n    }\n\n    // 找括号内的字符串\n    let sub = ''\n    while(stack[stack.length - 1] !== '[') {\n      sub = stack.pop() + sub\n    }\n    // remove [\n    stack.pop()\n\n    // 找括号前的数字\n    let top = stack[stack.length - 1]\n    let num = ''\n    while(!isNaN(Number(top))) {\n      num = stack.pop() + num\n      top = stack[stack.length - 1]\n    }\n\n    // 重复对应的字符串\n    sub = sub.repeat(Number(num))\n    stack.push(...sub)\n  }\n  return stack.join('')\n};\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，只遍历了一次字符串，当中可能涉及出栈的操作\n- 空间复杂度：O(n)，只用一个栈来存放最终的结果，当中有重复的字符串，最终是大于s.length","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918690390","body":"# 思路\n使用双栈，在push方法时，将数据反序再插入，即存放数据的栈出栈放入另一个栈实现反序，最后还原原来的顺序。\n\n# 代码\njavascript\n\n```javascript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n  this.stack = []\n  this.helpStack = []\n};\n\n/**\n * Push element x to the back of queue.\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  let cur = null;\n  while ((cur = this.stack.pop())) {\n    this.helpStack.push(cur)\n  }\n  this.helpStack.push(x)\n\n  while ((cur = this.helpStack.pop())) {\n    this.stack.push(cur)\n  }\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  return this.stack.pop()\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  return this.stack[this.stack.length - 1]\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.stack.length === 0\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，在push方法需要全部出栈入栈，故为O(n)，其他都是O(1)\n- 空间复杂度：O(n)，两个栈，但是同时只有一个栈不为空","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920019590","body":"# 思路\n- 滑动窗口\n- 一段区间内，若原数组的总和与排序后的数组的总和相等，则说明该区间排序后所在的位置与全部排序后相对应\n- 判断可以分块后，故要将重新保持一致，找下一个分块\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=768 lang=javascript\n *\n * [768] 最多能完成排序的块 II\n */\n\n// @lc code=start\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  const sortArr = [...arr].sort((a, b) => a - b)\n  let sum1 = 0\n  let sum2 = 0\n  let count = 0\n  for (let i = 0; i < arr.length; i++) {\n    // 判断原数组与排序后的数组的总和是否一样\n    sum1 += arr[i]\n    sum2 += sortArr[i]\n    // 若一样，则说明当前区间可以排序最终的结果，可以分块\n    if (sum1 === sum2) {\n      count += 1\n      // 由于已经分块，故要将重新保持一致，找下一个分块\n      // 其实两个结果都相等才能成立分块，已经保持一致了，下面的可不用置零\n      // 考虑到可以溢出的问题，建议设置为零\n      sum1 = 0\n      sum2 = 0\n    }\n  }\n  return count\n};\n// @lc code=end\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(NlogN)，只遍历一次数组，但是数组的排序更加耗时，数组排序大概是O(NlogN)\n- 空间复杂度：O(N)，用了三个变量，还有存放排序后的数组，故为O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920770812","body":"# 思路\n- 先遍历链表求出链表的长度\n- 将链表首尾相连成环，再移动相应的位置\n- 在k小于len时，实际移动的次数为len - k次\n  - 但k有可能大于len，此时可以减少不必要的移动，真实的k可以为k % len，故为len - k % len次\n\n# 代码\njavascript\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n  if (!head || !head.next) {\n    return head\n  }\n\n  // 统计长度\n  let len = 1\n  let last = head\n  while (last.next) {\n    last = last.next\n    len++\n  }\n\n  // 计算移动位置\n  let willMove = len - k % len\n\n  // 成环\n  last.next = head\n\n  // 移动位置\n  while (willMove > 1) {\n    head = head.next\n    willMove--\n  }\n  // 找到新的头节点\n  // 断环\n  const newHead = head.next\n  head.next = null\n\n  return newHead\n};\n\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，必须先遍历一次链表算出长度，正常情况下，只需要移动 len - k % len。最坏情况下，要遍历两次。\n- 空间复杂度：O(1)，只需要常数的空间的变量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921661400","body":"# 思路\n- 当链表不足两个节点时，不用互换\n- 用一个新链表来记录转换的结果，默认头部为空节点。同时需要用一个变量指向尾节点。\n- 判断是否区间是否有两个节点\n  - 有则进行互换\n  - 互换后，将新节点连接到新链表上（即与上次的结果相连接）\n  - 移动新链表的指向到尾节点（方便于将新结果连接上次的结果）\n  - 下移到下一个区间\n- 当不足两个节点时，将剩余的节点连接到新链表上\n- 返回转换好的新链表\n\n# 代码\njavascript\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n  if (!head || !head.next) {\n    return head\n  }\n\n  const dummy = new ListNode()\n  dummy.next = head\n  let current = dummy\n  while (head && head.next) {\n    // 更新新链的节点\n    current.next = head.next\n    // 交换两个节点\n    const temp = head.next.next\n    head.next.next = head\n    head.next = temp\n    // 移动到下一次的开始节点\n    current = current.next.next\n    head = temp\n  }\n  return dummy.next\n};\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，只需要遍历一次链表\n- 空间复杂度：O(1)，只需要常数的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922324898","body":"# 思路\n- 链表已经按升序排序\n- 最终结果是二叉搜索树\n  - 二叉搜索树的定义是，根节点>=左节点，根节点<=右节点\n- 获取当前链表的中点\n- 以链表中点为根\n- 中点左边的值都小于等于它，可以构造左子树\n- 中点右边的值都大于等于它，构造右子树\n# 代码\njavascript\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n  return buildTree(head, null)\n};\n\nfunction buildTree(left, right) {\n  if (left === right) {\n    return null\n  }\n\n  const mid = getMidNode(left, right)\n  const root = new TreeNode(mid.val)\n  root.left = buildTree(left, mid)\n  root.right = buildTree(mid.next, right)\n  return root\n}\n\nfunction getMidNode(left, right) {\n  let fast = left\n  let slow = left\n  while (fast !== right && fast.next !== right) {\n    slow = slow.next\n    fast = fast.next.next\n  }\n  return slow\n}\n```\n\n# 复杂度分析\n- 时间复杂度：O(nlogn)，每次只处理一个节点，需要找剩下节点的中间，即nlogn\n- 空间复杂度：O(1)，除了返回的搜索树，其他都是常数空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922473443","body":"# 思路\n- 当不相交部分的长度一样时，故两个指针同时前进，最终相遇\n- 当不相交部分的长度不一致时，可使用双指针消除不相交部分的长度差\n  - 两指针分别从a,b链表头节点开始，同时前进\n  - 当有一个指针走到尾节点时，改成指向另一个链表\n  - 当两个指针都进行了交换时，此时链表的长度差消除\n  - 即可以当成不相交部分长度一致了，同时前进最终会相遇\n# 代码\njavascript\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n  if (!headA || !headB) {\n    return null\n  }\n  let pA = headA\n  let pB = headB\n  while (pA !== pB) {\n    if (!pA) {\n      pA = headB\n    } else {\n      pA = pA.next\n    }\n\n    if (!pB) {\n      pB = headA\n    } else {\n      pB = pB.next\n    }\n  }\n\n  return pA\n};\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，每个链表最多被遍历两次，即2*n次，n = lenA + lenB\n- 空间复杂度：O(1)，只用了常数空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922500953","body":"# 思路\n- 双指针的方法\n- 首先要判断是否链表有环\n- 当链表有环时，两个指针会在环内相遇\n- 存在环外长度 = 相遇点到入环点长度 + n次环的长度\n- 因此，相遇后将另一个指针重新从表头部走，最终将再入环点相遇\n# 代码\njavascript\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n  let slow = head\n  let fast = head\n\n  while (fast && fast.next && fast.next.next) {\n    slow = slow.next\n    fast = fast.next.next\n\n    // 相遇了\n    while (slow === fast) {\n      // 相遇点到入环点的距离等于链头到入环点的距离\n      slow = head\n      while (slow !== fast) {\n        slow = slow.next\n        fast = fast.next\n      }\n      return slow\n    }\n  }\n  return null\n};\n```\n\n# 复杂度分析\n- 时间复杂度：O(n)，对于慢指针，走a+b到相遇点，后面再走c到入环点，刚好把整个链表走完\n- 空间复杂度：O(1)，只用了两个指针空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"OASans":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916809316","body":"### 思路\n逐位相加，直接加到num里面。如果加后大于10则在k上进行调整\n\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k % 10\n            if num[i] >= 10:\n                k = k // 10 + num[i] // 10\n                num[i] = num[i] % 10\n            else:\n                k = k // 10\n            i -= 1\n            if i < 0 and k:\n                num.insert(0, 0)\n                i = 0\n        return num\n```\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429743","body":"### 思路\n数组/字符串的前后遍历\n\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(s):\n            if x == c: prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c: prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n```\n\n### 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917608289","body":"### 思路\n用一个数组来维护栈，一个变量来维护栈当前长度\n\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize\n        self.stack = []\n        self.length = 0\n\n    def push(self, x: int) -> None:\n        if self.length >= self.maxsize:\n            return\n        self.stack.append(x)\n        self.length += 1\n\n    def pop(self) -> int:\n        if self.length == 0:\n            return -1\n        self.length -= 1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        k = k if self.length > k else self.length\n        for i in range(0, k):\n            self.stack[i] += val\n```\n\n### 复杂度分析\n* 时间：push、pop为O(1)，increment为O(k)\n* 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918333107","body":"### 思路\n使用栈辅助运算\n\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        if s == '':\n            return ''\n\n        def isNum(char):\n            if '0' <= char <= '9':\n                return True\n            return False\n\n        stack = []\n        num_buf = ''\n        char_buf = ''\n        for ch in s:\n            if isNum(ch):\n                if char_buf != '':\n                    stack.append(char_buf)\n                    char_buf = ''\n                num_buf += ch\n            elif ch == '[':\n                stack.append(num_buf)\n                num_buf = ''\n                stack.append(ch)\n            elif 'a' <= ch <= 'z':\n                char_buf += ch\n            elif ch == ']':\n                if char_buf != '':\n                    stack.append(char_buf)\n                    char_buf = ''\n                chars = []\n                while stack[-1] != '[':\n                    chars.insert(0, stack.pop())\n                stack.pop()\n                num = int(stack.pop())\n                chars = ''.join(chars)\n                string_buf = ''\n                while num > 0:\n                    string_buf += chars\n                    num -= 1\n                stack.append(string_buf)\n        if char_buf != '':\n            stack.append(char_buf)\n\n        res = ''\n        for ch in stack:\n            res += ch\n        return res\n```\n\n### 复杂度分析\n时间：O(N)\n\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919070026","body":"### --思路--\n用两个栈来模拟队列的操作，stack2作为翻转stack1的工具\n\n在两个栈之间互相倒腾\n\n### --代码--\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if self.stack2:\n            while self.stack2:\n                self.stack1.append(self.stack2.pop())\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not self.stack1 and not self.stack2\n```\n\n### --复杂度分析--\n时间：均摊为O(1)\n\n空间：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920914499","body":"### 思路\n先遍历一遍，计算节点总数，并将链表首尾相连\n\n然后从头开始遍历，数到第n-k%n个节点时断开即可\n\n### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        node = head\n        count = 1\n        while node.next:\n            node = node.next\n            count += 1\n        k = k % count\n        if k == 0:\n            return head\n        tail = node\n        tail.next = head\n        k = count - k\n        while k > 0:\n            tail = head\n            head = head.next\n            k -= 1\n        tail.next = None\n        return head\n```\n\n### 复杂度分析\n* 时间：O(n)\n* 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921898565","body":"### 思路\n加一个虚拟头结点，然后顺序遍历下去，每两个交换一下就行了\n### 代码\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        fake_head = ListNode(0, head)\n        pre_node = fake_head\n        while pre_node.next and pre_node.next.next:\n            node1 = pre_node.next\n            node2 = pre_node.next.next\n            node1.next = node2.next\n            node2.next = node1\n            pre_node.next = node2\n            pre_node = node1\n        return fake_head.next\n```\n### 复杂度分析\n* 时间：O(n)\n* 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922171925","body":"### --思路--\n顺序遍历进行节点计数，找到中间的节点作为当前树的root。断开中间节点与两边链表的连接，将两边的两个链表递归的结果作为root的left和right\n\n### --复杂度分析\n* 时间：O(nlogn)\n* 空间：O(logn)\n\n### --代码--\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        count = 0\n        node = head\n        while node:\n            count += 1\n            node = node.next\n        root_idx = count // 2\n        fake_head = ListNode(0, head)\n        pre_node = fake_head\n        while root_idx > 0:\n            root_idx -= 1\n            pre_node = pre_node.next\n        if not pre_node.next:\n            return None\n        root = TreeNode(pre_node.next.val)\n        right = pre_node.next.next\n        pre_node.next = None\n        root.left = self.sortedListToBST(fake_head.next)\n        root.right = self.sortedListToBST(right)\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922496320","body":"### 思路\n双指针，遍历\n\n### 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return None\n        a, b = headA, headB\n        while a != b:\n            if a:\n                a = a.next\n            else:\n                a = headB\n            if b:\n                b = b.next\n            else:\n                b = headA\n        return a\n```\n\n### 复杂度分析\n* 时间：O(n)\n* 空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cy-sues":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916817098","body":"# 思路\n\n从末位开始将数组和k的每一位相加，若大于10则在下一步运算中进一位，ArrayList添加这些数字，最后反转。\n\n# 代码\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> arr = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            arr.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            arr.add(k % 10);\n        }\n        Collections.reverse(arr);\n        return arr;\n    }\n}\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917425418","body":"# 思路\n分别从字符串的左右遍历，经过C点时保存位置，记录后边遍历非C点的距离，碰见C点更新，最后选择两个方向的最小值，参考了官方的解法\n# 代码\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917536837","body":"# 代码\nclass CustomStack {\n\n    int [] data;//数组代替栈\n    int head;//头指针位置\n    public CustomStack(int maxSize) {\n        data=new int[maxSize];//maxSize 是栈中最多能容纳的元素数量\n        head=-1;\n    }\n    \n    public void push(int x) {\n        if(data.length-1==head) \n            return;//栈在增长到 maxSize 之后则不支持 push 操作\n        head++;\n        data[head]=x;\n    }\n    \n    public int pop() {\n        if (head==-1) return -1;//栈为空时返回 -1 。\n        return data[head--];\n    }\n    \n    public void increment(int k, int val) {\n            if (head+1<k)//如果栈中元素总数小于 k ，则栈中的所有元素都增加 val \n            for(int i=0;i<head+1;i++)\n            {\n                data[i]+=val;\n            }\n            else\n            for(int j=0;j<k;j++)\n            {\n                data[j]+=val;\n            }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918283767","body":"# 代码\nclass Solution {\n   public String decodeString(String s) {\n        char[] chars = s.toCharArray();\n        Deque<Integer> stackNum = new ArrayDeque<>();\n        Deque<String> stack = new ArrayDeque<>();\n        StringBuilder sb = new StringBuilder();\n        int num = 0;\n        for (int i = 0; i < chars.length ; i++) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                num = num * 10 + Integer.parseInt(chars[i] + \"\"); //两位数以上的数字计算\n            } else if (chars[i] == '[') {\n                stackNum.addLast(num); //不能在上一步加入数字队列，可能会有两位数以上的数字\n                stack.addLast(sb.toString()); //第一个待处理的字符串\n                sb = new StringBuilder(); //清空结果\n                num = 0; \n            } else if (chars[i] == ']') {\n                StringBuilder temp = new StringBuilder();\n                int n = stackNum.removeLast(); //上一步的结果，从栈弹出\n                while (n > 0) {\n                    temp.append(sb);\n                    n--;\n                }\n                sb = new StringBuilder(stack.removeLast() + temp); //更新原来的字符串结果\n            } else {\n                sb.append(chars[i]);\n            }\n        }\n        return sb.toString();\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918871291","body":"# 代码\nclass MyQueue {\n    Deque<Integer> out, in;\n    public MyQueue() {\n        in = new ArrayDeque<>();\n        out = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        while (!out.isEmpty()) in.addLast(out.pollLast());\n        in.addLast(x);\n    }\n    \n    public int pop() {\n        while (!in.isEmpty()) out.addLast(in.pollLast());\n        return out.pollLast();\n    }\n    \n    public int peek() {\n        while (!in.isEmpty()) out.addLast(in.pollLast());\n        return out.peekLast();\n    }\n    \n    public boolean empty() {\n        return out.isEmpty() && in.isEmpty();\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920107578","body":"# 思路\n看答案前没头绪\n# 代码\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        if (arr.length == 0) return 0;\n        int[] mins = new int[arr.length];\n        mins[arr.length - 1] = arr[arr.length - 1];\n        for (int i = arr.length - 2; i >= 0; i--) {\n            mins[i] = Math.min(arr[i], mins[i + 1]);\n        }\n        int count = 1;\n        int pre = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (pre > mins[i]) {\n                if (arr[i] > pre) pre = arr[i];\n            } else {\n                count++;\n                pre = arr[i];\n            }\n        }\n        return count;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920882018","body":"# 思路\n先将链表闭环，在分析断开。\n# 代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;//判断节点数\n        }\n        int add = n - k % n;//右移数量\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;//尾节点连接头\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;//ret为头节点\n        iter.next = null;//断开，iter成为尾节点\n        return ret;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921843434","body":"# 思路 \n递归，画图理解\n# 代码\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        //终止条件\n        if(head==null||head.next==null){\n            return head;\n        }\n        ListNode tNode=head.next;//新的链表\n        head.next=swapPairs(tNode.next);//递归\n        tNode.next=head;\n        return tNode;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922269978","body":"### 代码\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {//建树\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);//左右子树递归\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {//获取中子位节点，偶数节点情况下中间两个节点任一都可\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shenzhengkang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916818186","body":"思路\n1. 当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n2.AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\n伪代码\nwhile ( A 没完 || B 没完)\n    A 的当前位\n    B 的当前位\n    和 = A 的当前位 + B 的当前位 + 进位carry\n    当前位 = 和 % 10;\n    进位 = 和 / 10;\n    判断还有进位吗；\n\n代码\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize) {\n    int* res = malloc(sizeof(int) * fmax(10, numSize + 1));\n    *returnSize = 0;\n    for (int i = numSize - 1; i >= 0; --i) {\n        int sum = num[i] + k % 10;\n        k /= 10;\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res[(*returnSize)++] = sum;\n    }\n    for (; k > 0; k /= 10) {\n        res[(*returnSize)++] = k % 10;\n    }\n    for (int i = 0; i < (*returnSize) / 2; i++) {\n        int tmp = res[i];\n        res[i] = res[(*returnSize) - 1 - i];\n        res[(*returnSize) - 1 - i] = tmp;\n    }\n    return res;\n}\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918156084","body":"1.思路\n本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应。\n①构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n②当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n③当 c 为字母时，在 res 尾部添加 c；\n④当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\n记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\n记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n进入到新 [ 后，res 和 multi 重新记录。\n\n⑤当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\nlast_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\ncur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]的2.\n\n2.代码\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int n=s.size();\n        vector<int> numS;\n        vector<string> charS;\n        int a=0;\n        string ret;\n        for(int i=0;i<n;i++){\n            if(isdigit(s[i])){\n               a=a*10+s[i]-'0';\n            }else if( s[i]=='['){\n                numS.push_back(a);\n                string tmp;\n                charS.push_back(tmp);\n                a=0;\n            }else if( s[i]==']'){\n                int num=numS.back();\n                string s1=charS.back();\n                charS.pop_back();\n                if(charS.size())\n                {\n                    for(int i=0; i< num; i++){\n                        charS.back() +=s1;\n                    }   \n                }else {\n                    for(int i=0; i< num; i++){\n                        ret +=s1;\n                    }              \n                }\n                numS.pop_back();\n            }else{\n                if(charS.size()){\n                    charS[charS.size()-1].push_back(s[i]);\n                }else{\n                    ret.push_back(s[i]);   \n                }\n            }\n        }\n        return ret;\n    }\n};\n3.复杂度\n遍历一遍s需要的时间为O(s.size());","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linrAx":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916825233","body":"# 思路\r\n\r\n将数组从低位到高位加到k上,最后反转\r\n\r\n# 代码\r\n\r\n语言支持:java\r\n\r\n```java\r\nclass Solution {`\r\n\r\n  public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n​    List<Integer> res = new ArrayList<>();\r\n\r\n​    for(int i = num.length-1;i >= 0|| k >0;i--,k/=10){\r\n\r\n​      if(i>=0){\r\n\r\n​        k+=num[i];\r\n\r\n​      }\r\n\r\n​      res.add(k%10);\r\n\r\n​    }\r\n\r\n​    Collections.reverse(res);\r\n\r\n​    return res;\r\n\r\n  }\r\n\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n\r\n时间复杂度  O(max(n,log k)) , n为数组长度\r\n\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917421526","body":"# 思路\n\n 左遍历一遍，存储距离，右遍历一遍，两者最小值为最近距离\n\n# 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] res = new int[N];\n        int prev  = -10001;\n        for(int i=0;i<N;++i){\n            if (s.charAt(i)==c) prev =i;\n            res[i] = i - prev;\n        }\n        prev  = 10001;\n        for(int i=N-1;i>=0;--i){\n            if (s.charAt(i)==c) prev =i;\n            res[i] = Math.min(prev -i,res[i]);\n        }\n        return  res;\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度    O(N) \n\n空间复杂度    O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917637676","body":"# 思路\n\n用数组作为底层构建栈\n\n# 代码\n\n```java\nclass CustomStack {\n    int[] stack;\n    int count;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        count = 0;    \n    }\n    \n    public void push(int x) {\n        if(count < stack.length) stack[count++] = x;     \n    }\n    \n    public int pop() {\n        if(count == 0) return -1;\n        return  stack[--count];\n    }\n    \n    public void increment(int k, int val) {\n        int temp = Math.min(k,count);\n        for (int i = 0; i <temp;i++){\n            stack[i] +=val;\n        }\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度 push、pop 为O(1) , increment 为O(N)\n\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918284863","body":"# 思路\n\n遍历字符串，对不同情况做出相应操作\n\n1、字符为数字,计算倍数\n\n2、字符为字母，直接加到`res`中\n\n3、字符为左括号`( '[' )`,进行递归,递归的返回值为当前已遍历到的索引 `i` 和子字符串`tmp`\n拿到返回值后将`tmp`乘以`num`后加到`res`中，并重置`num`\n\n4、字符为右括号`(']')`,返回当前索引 `i` 以及在当前递归层的循环过程中生成的子字符串`res`\n\n5、返回最终字符串`res`\n\n# 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度  O(n)\n\n空间复杂度  O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920086898","body":"# 思路\n\n官方思路 滑动窗口\n\n# 代码 \n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度 `O(NlogN) ` N为`arr`长度\n\n空间复杂度 `O(N)`\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921880557","body":"## 思路\n\n官方思路 递归两两交换链表中的节点\n\n## 代码\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n    }\n}\n```\n\n## 复杂度\n\n时间复杂度 O(n)\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922328420","body":"### **思路：快慢指针**\r\n\r\n快慢指针起初都指向头结点，分别一次走两步和一步，当快指针走到尾节点时，慢指针正好走到链表的中间。断成两个链表，分而治之。\r\n\r\n### **代码**\r\n\r\n```javascript\r\nconst sortedListToBST = (head) => {\r\n  if (head == null) return null;\r\n  let slow = head;\r\n  let fast = head;\r\n  let preSlow; // 保存slow的前一个节点\r\n\r\n  while (fast && fast.next) {\r\n    preSlow = slow;        // 保存当前slow\r\n    slow = slow.next;      // slow走一步\r\n    fast = fast.next.next; // fast走两步\r\n  }\r\n  const root = new TreeNode(slow.val);     // 根据slow指向的节点值，构建节点\r\n\r\n  if (preSlow != null) {   // 如果preSlow有值，即slow左边有节点，需要构建左子树\r\n    preSlow.next = null;   // 切断preSlow和中点slow\r\n    root.left = sortedListToBST(head);     // 递归构建左子树\r\n  }\r\n  root.right = sortedListToBST(slow.next); // 递归构建右子树\r\n  return root;\r\n};\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：O(nlogn)\r\n  空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922491676","body":"### 思路\n\n判断两个链表是否相交，用哈希集合存储链表节点\n\n### 代码\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<ListNode>();\n        ListNode temp = headA;\n        while (temp != null) {\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while (temp != null) {\n            if (visited.contains(temp)) {\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n```\n\n### 复杂度\n\n- 时间复杂度： O(M+N)\n- 空间复杂度:：O(M)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"L-mx-wq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916826948","body":"思路:逐位相加，大于10加到下一位\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n\n复杂度分析\n时间复杂度：O(max⁡(n,logk))\n其中 n 为数组的长度。\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921446403","body":"语言:C++\n代码：\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Okkband":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916827469","body":"### 思路\r\n面向测试用例的编程\r\n\r\n``` CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size();\r\n        int cnt = 0;\r\n        int pre = 0;\r\n        int tmp = 0;\r\n        while(k / 10 || k % 10 || cnt < n){\r\n            cnt += 1;\r\n            if (cnt > n){\r\n                tmp = pre + 0 + k % 10;\r\n            } else {\r\n                tmp = pre + num[n - cnt] + k % 10;\r\n            }\r\n            k /= 10;\r\n            pre = 0;\r\n            if (tmp >= 10){\r\n                pre = 1;\r\n                tmp -= 10;\r\n            }\r\n            if (cnt > n){\r\n                num.insert(num.begin(), tmp);\r\n            } else {\r\n                num[n - cnt]  = tmp;\r\n            }\r\n            \r\n        }\r\n        if (pre == 1) num.insert(num.begin(), 1);\r\n        return num;\r\n    }\r\n};\r\n```\r\n#### 时间复杂度\r\nO(n, m), 其中n, 为num的长度，m为k的位数\r\n#### 空间复杂度\r\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917408303","body":"``` CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ans(n, 0);\r\n        int pre = INT_MIN / 2;\r\n        for (int i=0; i<n; i++){\r\n            if (s[i] == c){\r\n                pre = i;\r\n            }\r\n            ans[i] = i - pre;\r\n        }\r\n        pre = INT_MAX / 2;\r\n        for (int i=n-1; i>=0; i--){\r\n            if (s[i] == c){\r\n                pre = i;\r\n            }\r\n            ans[i] = min(ans[i], pre - i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657270","body":"``` CPP\r\n\r\nclass CustomStack {\r\nprivate:\r\n    vector<int> vec;\r\n    int top;\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        vec.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top != vec.size() - 1){\r\n            vec[++top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) return -1; \r\n        else \r\n        {\r\n            top--;\r\n            return vec[top+1];\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int idx = min(k, top+1);\r\n        for(int i=0; i<idx; i++){\r\n            vec[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n### 时间复杂度：push: O(1), pop: O(1), increment: O(n)\r\n### 空间复杂度：O(n), n为栈的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918312588","body":"``` CPP\r\nclass Solution {\r\nprivate:\r\n    string src;\r\n    int ptr;\r\n    int getDigits(){\r\n        int ret = 0;\r\n        while(ptr < src.size() && isdigit(src[ptr])){\r\n            ret = ret * 10 + src[ptr++] - '0';\r\n        }\r\n        return ret;\r\n    }\r\n    string getString() {\r\n        if (ptr == src.size() || src[ptr] == ']'){\r\n            return \"\";\r\n        }\r\n        char cur = src[ptr];\r\n        int cnt = 1;\r\n        string res;\r\n        if (isdigit(cur)) {\r\n            cnt = getDigits();\r\n            ++ptr;\r\n            string str = getString();\r\n            ++ptr;\r\n            while(cnt--){\r\n                res += str;\r\n            }\r\n        } else if (isalpha(cur)){\r\n            res = string(1, src[ptr++]);\r\n        }\r\n        return res + getString();\r\n    }\r\npublic:\r\n    string decodeString(string s) {\r\n        src = s;\r\n        ptr = 0;\r\n        return getString();\r\n    }\r\n};\r\n```\r\n### 时间复杂度： O(N)\r\n### 空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918833835","body":"```CPP\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n    void in2out(){\r\n        while(!inStack.empty()){\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if (outStack.empty()){\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n        \r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (outStack.empty()){\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return (outStack.empty() && inStack.empty());\r\n    }\r\n};\r\n```\r\n#### 时间复杂度： O(n)\r\n#### 空间复杂度： O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920993881","body":"### 思路：\r\n1. 先遍历一遍链表，求出链表的长度n\r\n2. 使用快慢指针，两个相差得到倒数第k+1个节点，也就是要断开的位置的前面的节点。\r\n3. 断开链表，首位相接\r\n4. 使用dummy节点，可以避免空链表的判断问题。\r\n```CPP\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        int n = 0;\r\n        ListNode* dummy = new ListNode(0, head);\r\n        ListNode* fast = dummy;\r\n        ListNode* slow = dummy;\r\n        while(head != nullptr){\r\n            head = head->next;\r\n            n++;\r\n        }\r\n        head = fast->next;\r\n        int cnt = 0;\r\n        while(fast->next != nullptr) {\r\n            fast = fast->next;\r\n            cnt++;\r\n            if (cnt > (k%n)) {\r\n                slow = slow->next;\r\n            }\r\n        }\r\n        fast->next = head;\r\n        ListNode* ans = slow->next;\r\n        slow->next = nullptr;\r\n        return ans;\r\n    }\r\n};\r\n```\r\n###  时间复杂度：O(N)\r\n### 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921514608","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode* dummy = new ListNode(0, head);\r\n        ListNode* tmp = dummy;\r\n        while(tmp->next != nullptr && tmp->next->next != nullptr){\r\n            ListNode* tmp1 = tmp->next;\r\n            ListNode* tmp2 = tmp->next->next;\r\n            tmp->next = tmp2;\r\n            tmp1->next = tmp2->next;\r\n            tmp2->next = tmp1;\r\n            tmp = tmp1;\r\n        }\r\n        return dummy->next;\r\n    }\r\n};\r\n```\r\n#### 时间复杂度：O(N)\r\n#### 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922269036","body":"```CPP\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\nprivate:\r\n    TreeNode* buildTree(ListNode*& head, int left, int right){\r\n        if (left > right) return nullptr;\r\n        TreeNode* root = new TreeNode();\r\n        int mid = (left + right + 1) / 2;\r\n        root->left = buildTree(head, left, mid-1);\r\n        root->val = head->val;\r\n        head = head->next;\r\n        root->right = buildTree(head, mid+1, right);\r\n        return root;\r\n    }\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        int cnt = 0;\r\n        ListNode* tmp = head;\r\n        while(tmp){\r\n            cnt++;\r\n            tmp = tmp->next;\r\n        }\r\n        return buildTree(head, 0, cnt-1);\r\n    }\r\n};\r\n```\r\n### 时间复杂度：O(N)\r\n### 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922414754","body":"```CPP\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (headA == nullptr || headB == nullptr) return nullptr;\r\n        ListNode* pA = headA;\r\n        ListNode* pB = headB;\r\n        while(pA != pB){\r\n            if (pA == nullptr){\r\n                pA = headB;\r\n            } else {\r\n                pA = pA->next;\r\n            }\r\n            if (pB == nullptr){\r\n                pB = headA;\r\n            } else {\r\n                pB = pB->next;\r\n            }\r\n        }\r\n        return pA;\r\n    }\r\n};\r\n```\r\n### 时间复杂度：O(m+n), m,n 为两链表的长度\r\n### 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryzhao5":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916830080","body":"# 思路\r\n从后往前遍历数组，同时取出非负整数的个位数，与其相加，传入新的数组中\r\n# 代码\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> result = new LinkedList<>();\r\n        int temp = 0;\r\n        for(int i = num.length - 1; i >= 0; i--){\r\n            temp = k%10;\r\n            k = k/10;\r\n            if(num[i] + temp >= 10){\r\n                k++;\r\n                result.addFirst((num[i] + temp) % 10);\r\n            }\r\n            else{\r\n                result.addFirst((num[i] + temp) % 10);\r\n            }\r\n\r\n            if(i == 0){\r\n                while(k != 0){\r\n                    temp = k % 10;\r\n                    k = k / 10;\r\n                    result.addFirst(temp);\r\n                     \r\n                }\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n# 时间复杂度\r\nO(max(m,n))\r\n\r\n# 空间复杂度\r\nO(max(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917418274","body":"# 思路\r\n从左往右遍历一遍数组，找出离它最近的且在左边的字符c的距离\r\n从右往左遍历一遍数组，找出离它最近的且在右边的字符c的距离，和上边的距离比较，取最小值\r\n\r\n# 代码\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] result = new int[len];\r\n        Arrays.fill(result, len);\r\n\r\n        //找左边的最近距离\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                result[i] = 0;\r\n            }\r\n            else if(i > 0){\r\n                result[i] = result[i-1] + 1;\r\n            }\r\n        }\r\n\r\n        for(int i = len - 1; i >= 0; i--){\r\n            if(s.charAt(i) == c){\r\n                result[i] = 0;\r\n            }\r\n            else if(i < len - 1){\r\n                result[i] = Math.min(result[i+1] + 1, result[i]);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n# 时间复杂度\r\nO（n）\r\n\r\n# 空间复杂度\r\nO（）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917611888","body":"# 思路\r\n正常设计\r\n# 代码\r\n\r\n```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;//指向最上层的已存元素\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != stack.length - 1){\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top != -1){\r\n            return stack[top--];\r\n        }\r\n        else{\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int min = Math.min(k, top+1);\r\n        for(int i = 0; i < min; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n# 时间复杂度\r\nincrement为ON，其他均为O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917879571","body":"思路：\n建立一个栈，将每个字母遍历，如果没有遇到]，就加入栈中，如果遇到[，则先弹出字母，再弹出数字，根据字母和数字经过处理后加入栈中，直到遍历完字母，栈中即为结果\n\n```\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c: s.toCharArray()){\n            if(c != '['){\n                stack.push(c);\n            }\n            else{\n                StringBuffer sb = new StringBuffer();\n                while(!stack.isEmpty() && Character.isLetter(stack.peek())){\n                    sb.insert(0, stack.pop());\n                }\n\n                String sub = sb.toString();\n                stack.pop();\n\n                sb = new StringBuffer();\n\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    sb.insert(0, stack.pop());\n                }\n\n                int count = Integer.parseInt(sb.toString());\n                \n                while(count > 0){\n                    for(char ch: sub.toCharArray()){\n                        stack.push(ch);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while (!stack.isEmpty()) {\n            res.insert(0, stack.pop());\n        }\n\n        return res.toString();\n    }\n}\n```\n\n时间复杂度空间复杂度均为O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918783503","body":"#代码\r\n\r\n`class MyQueue {\r\n    Stack<Integer> stack1;\r\n    Stack<Integer> stack2;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack1 = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        stack2 = new Stack<>();\r\n        while(!stack1.isEmpty()){\r\n            stack2.push(stack1.pop());\r\n        }\r\n        int res = stack2.pop();\r\n        while(!stack2.isEmpty()){\r\n            stack1.push(stack2.pop());\r\n        }\r\n\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        stack2 = new Stack<>();\r\n        while(!stack1.isEmpty()){\r\n            stack2.push(stack1.pop());\r\n        }\r\n        int res = stack2.peek();\r\n        while(!stack2.isEmpty()){\r\n            stack1.push(stack2.pop());\r\n        }\r\n\r\n        return res;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stack1.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */`\r\n\r\n# 时间复杂度\r\nON\r\n# 空间复杂度\r\nON","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920794093","body":"# 代码\r\n\r\n`\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        int length = 0;\r\n        ListNode head2 = head;\r\n        while(head2 != null){\r\n            length++;\r\n            head2 = head2.next;\r\n        }\r\n\r\n        k = k % length;\r\n        length = length - k - 1;\r\n        ListNode slow = head;\r\n        while(length > 0){\r\n            slow = slow.next;\r\n        }\r\n\r\n        ListNode fast = slow.next;\r\n\r\n        head2 = head;\r\n        while(head2.next != null){\r\n            head2 = head2.next;\r\n        }\r\n        head2.next = head;\r\n        slow.next = null;\r\n        head = fast;\r\n        \r\n        return head;\r\n        \r\n    }\r\n}\r\n`","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922435586","body":"# 解法\r\n双指针法\r\n设A和B未重合的部分长度分别是a和b，重合部分的长度是c\r\n则a+c+b=b+c+a时，两者相遇在重合处\r\n\r\n# 代码\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode pA = headA, pB = headB;\r\n        if(pA == null || pB == null){\r\n            return null;\r\n        }\r\n\r\n        while(pA != pB){\r\n            if(pA == null){\r\n                pA = headB;\r\n            }\r\n            else{\r\n                pA = pA.next;\r\n            }\r\n\r\n            if(pB == null){\r\n                pB = headA;\r\n            }\r\n            else{\r\n                pB = pB.next;\r\n            }\r\n        }\r\n\r\n        return pA;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n时间复杂度 OM+N\r\n空间复杂度 O1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mosihan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916836424","body":"## 题目\n\n989. [数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 思路\n\n提取数组的数字，加K，加完后转为string，将string拆分为list填充\n\n### code\n\n```python\nA = [9,9,9,9,9,9,9,9,9,9]\nK = 1\n\nA_sum=0\nfor i in range(len(A)):\n  A_part=A[i]*10**(len(A)-i-1)\n  A_sum=A_sum+A_part\n\nprint(A_sum)\n\nak=A_sum+K\nlist1=[]\nak_s=str(ak)\nfor j in range(len(ak_s)):\n  list1.append(int(ak_s[j]))\n\nprint(ak_s)\n```\n\n### 复杂度\n\n+ 时间复杂度\n\n  O(max(m,n))\n\n+ 空间复杂度\n\n  O(max(m,n))\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917048782","body":"## 题目\n\n[821字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n### 思路\n\n正则化匹配符合要求的index，对原数组的每个索引与匹配好的数组索引做差，取绝对值后的min即为该索引到目标字符的最小距离\n\n### code\n\n```python\nimport re\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        f=re.finditer(c[0],s)\n\n        s_index=[]\n        for i in f:\n            s_index.append(i.span()[0])\n        print(s_index)\n\n        index1=range(len(s))\n        index2=[]\n        dis_min=float(\"inf\")\n        for j in index1:\n            for k in s_index:\n                dis_min=min(dis_min,abs(k-j))\n            index2.append(dis_min)\n            dis_min=float(\"inf\")\n\n        return index2\n```\n\n### 复杂度\n\n+ 时间复杂度\n\n  O(m*n)\n\n+ 空间复杂度\n\n  O(m*n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917475157","body":"## 题目\n\n[1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n### 思路\n\nclass 内创建空list1，通过maxsize限制list1的长度\n\n### code\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n      self.list1=[]\n      self.num=0\n      self.maxsize=maxSize\n\n    def push(self, x: int) -> None:\n      if self.num<self.maxsize:\n        self.list1.append(x)\n        self.num+=1\n\n\n    def pop(self) -> int:\n      if self.num==0:\n        return -1\n      self.num-=1\n      return self.list1.pop()\n\n    def increment(self, k: int, val: int) -> None:\n      if k>=len(self.list1):\n        for i in range(len(self.list1)):\n          self.list1[i]+=val\n      else:\n        for i in range(k):\n          self.list1[i]+=val\n```\n\n### 复杂度\n\n+ 时间复杂度\n\n  O(1)\n\n+ 空间复杂度\n\n  O(1)\n\n# [题解](https://leetcode-solution.cn/solutionDetail?type=3&id=3&max_id=2)\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922487290","body":"160. 相交链表\n思路\n官方题解\n\n代码\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n复杂度\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"babbomax98":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916838767","body":"#### 思路\n因为是数据形式的相加，那么首先考虑因为LinkedList的add的时间复杂度是1，AyyayList的add的时间复杂度是N，所以此处选用LinkedList，\n然后以数组的下标作为循环的条件，每次给传入的int值除以10来去除最后一位数，当坐标i>=0时，加上k和10取余的值，通过LinkedList的add(int index, E element)方法插入到链表头\n最后返回即可\n#### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        List<Integer> res = new LinkedList<Integer>();\n        int n = A.length;\n        for (int i = n - 1; i >= 0 || K > 0; --i, K /= 10) {\n            if (i >= 0) {\n                K += A[i];\n            }\n            res.add(0,K % 10);\n        }\n        return res;\n    }\n}\n```\n#### 复杂度分析\n时间复杂度：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917408655","body":"#### 思路\n 此题使用双指针,定义一个index值指向下一个C和上一个C的坐标，然后另一个指针从第一个开始移动，与记录C坐标的值做对比，然后每当遍历到C传入的值就更新一次index，如果与传入的值不相等，那就通过计算，给本次循环的返回数组存入与上个C坐标距离和下个C坐标距离的小值，最终得到结果\n\n#### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] result=new int[N];\n        int indexNext=S.indexOf(C);//双指针，indexNext表示下一个C的下标， \n        int index=indexNext;//index表示前一个C的坐标\n    // 通过这里的赋值使在只有左边有C字符的时候（此时index = indexNext）的时候\n    //index也在当前字符的右边，否则在左右都有C字符的时候，当前字符必在index和indexNext的中间。\n       for(int i = 0; i < S.length(); i++){\n            if(S.charAt(i) == C){//每当遍历到C就更新index和indexNext\n                result[i] = 0;\n                index = i;\n                indexNext = S.indexOf(C, i+1);\n                //注意：这里如果当前是最后一个C时，此时indexNext为-1，这也保证了上面的情况3\n\n            }else{\n                result[i] = Math.min(Math.abs(index - i), Math.abs(indexNext - i));//\n            }\n        }\n       return result;\n    }\n}\n```\n\n#### 复杂度分析\n时间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917615490","body":"#### 思路\n根据题意直接创建对应的栈方法\n#### 代码\n```java\n\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack=new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top!=stack.length-1){\n            ++top;\n            stack[top]=x;\n        }\n\n    }\n    \n    public int pop() {\n        if(top==-1)\n            return -1;\n        --top;\n        return stack[top+1];\n\n    }\n    \n    public void increment(int k, int val) {\n        int li=Math.min(k,top+1);\n        for(int i=0;i<li;i++){\n            stack[i]+=val;\n        }\n\n    }\n}\n```\n#### 复杂度分析\n时间复杂度O（N）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918129535","body":"#### 思路\n定义一个数值记录[前的倍数，再定义一个记录[]中的字符串，当遇到]时，执行一个循环将中括号中的字符串遍历输出其的倍数次，如果字符串大于0或者小于9且不在括号里边的时候，就证明前面的数字不是个位数，需要相乘相加，得到多位数正确的值，\n#### 代码\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res= new StringBuilder();\n        int no=0;\n        LinkedList<Integer> stack_no=new LinkedList<>();\n        LinkedList<String> stack_res=new LinkedList<>();\n        for(Character c:s.toCharArray()){\n            if(c=='['){\n                //记录倍数\n                stack_no.addLast(no);\n                //开始在尾部添加新遍历到的元素\n                stack_res.addLast(res.toString());\n                no=0;\n                res=new StringBuilder();\n            }else if(c==']'){\n                StringBuilder tmp=new StringBuilder();\n                int tmo_no=stack_no.removeLast();\n                for(int i=0;i<tmo_no;i++){\n                    tmp.append(res);\n                }\n                res=new StringBuilder(stack_res.removeLast()+tmp);\n            }else if(c>='0'&&c<='9'){\n                no=no*10+Integer.parseInt(c+\"\");\n            }else\n                res.append(c);\n        }\n    return res.toString();\n    }\n}\n```\n#### 复杂度分析\n时间复杂度O（N）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919085632","body":"#### 思路\n直接按照题意写\n#### 代码\n```java\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        inStack=new LinkedList<>();\n        outStack=new LinkedList<>();\n\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(outStack.isEmpty()){\n            inout();\n        }\n    return outStack.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(outStack.isEmpty()){\n            inout();\n        }\n    return outStack.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n    public void inout(){\n        while(!inStack.isEmpty()){\n            outStack.push(inStack.pop());\n        }\n    }\n}\n```\n\n#### 复杂度分析\n时间复杂度O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919995012","body":"#### 思路\n参考官方题解，\n\n#### 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                //删除栈顶元素\n                int head = stack.removeLast();\n                //与当前的前两个位置的数作比较\n                while(!stack.isEmpty() && num < stack.getLast()) \n                    stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n#### 复杂度分析\n时间复杂度：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920910439","body":"#### 思路\n先将链表的长度求出，然后将链表的尾的下一个节点设置为链表的头节点，形成一个闭环的链表，然后旋转，如果旋转的次数大于链表的长度，那么只需要将他旋转k % 链表的长度次即可，\n#### 代码\n```java\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        //边界值\n        if(k==0||head==null||head.next==null){\n            return head;\n        }\n        int n = 1;\n        ListNode linked = head;\n        //计算链表的长度\n        while (linked.next != null) {\n            linked = linked.next;\n            n++;\n        }\n        //形成环形链表\n        linked.next = head;\n        //计算需要旋转几位\n        int newhead = n - k % n;\n        //如果和n相等，则代表不需要旋转，直接返回\n        if (newhead == n) {\n            return head;\n        }\n        //遍历让linked链表指向其最后一个节点，来为后续回复非环形链表准备\n        while (newhead-- > 0) {\n            linked = linked.next;\n        }\n        //新的头节点\n        ListNode res = linked.next;\n        linked.next = null;\n        return res;\n    }\n}\n```\n#### 复杂度分析\n\n时间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921809468","body":"#### 思路\n先考虑边界值，然后新建一个head的下一个节点开始的链表，使用递归，最后返回这个新的链表即可\n#### 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null ||head.next == null){\n            return head;\n        }\n        ListNode res = head.next;\n        head.next = swapPairs(res.next);\n        res.next = head;\n        return res;\n\n    }\n}\n```\n#### 复杂度分析\n时间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922469395","body":"#### 思路\n使用双指针，一个指针指向A的头节点，一个指针指向B的头节点，然后同时进行下一步，当a指针走完A链时指向B链的头节点，B指针类似，如果没有相交，则两个节点都为null时会返回结果，如果相交时，则在交点会返回结果\n#### 代码\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n\n\n        ListNode NodeA = headA;\n        ListNode NodeB = headB;\n\n        while(NodeA != NodeB ){\n           NodeA = NodeA!=null ? NodeA.next:headB;\n           NodeB = NodeB!=null ? NodeB.next:headA;  \n        }\n        return NodeA;\n    }\n}\n```\n#### 复杂度分析\n时间复杂度：O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"EggEggLiu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916840372","body":"# 思路\n取num和k的低位，逐级相加\n\n# 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ret;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            ret.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            ret.push_back(k % 10);\n        }\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n};\n```\n\n# 复杂度分析\n时间O(max(n, logk))\n\n空间O(max(n, logk))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428821","body":"# 思路\r\n\r\n先扫描一遍记录下与`c`相同的字符位置，再扫描一遍确定输出结果\r\n\r\n# 代码\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res;\r\n        vector<int> position;\r\n        const size_t len = s.size();\r\n        for (int i = 0; i < len; ++i) {\r\n            if (s[i] == c) {\r\n                position.push_back(i);\r\n            }\r\n        }\r\n        int ptr = 0;\r\n        const size_t size = position.size();\r\n        for (int i = 0; i < len; ++i) {\r\n            if (i == position[ptr]) {\r\n                res.push_back(0);\r\n            } else if (i < position[ptr]) {\r\n                res.push_back(position[ptr] - i);\r\n            } else {\r\n                if (ptr == size - 1) {\r\n                    res.push_back(i - position[ptr]);\r\n                } else {\r\n                    if (i - position[ptr] < abs(i - position[ptr + 1])) {\r\n                        res.push_back(i - position[ptr]);\r\n                    } else {\r\n                        res.push_back(abs(i - position[ptr + 1]));\r\n                        ++ptr;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n# 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917555474","body":"# 思路\n用\"一个数组 + 栈顶指针\"实现栈，push-O(1)，pop-O(1)，inc-O(n)\n# 代码\n```cpp\nclass CustomStack {\n    int size;\n    int top;\n    vector<int> simStack;\npublic:\n    CustomStack(int maxSize) {\n        size = maxSize;\n        top = 0;\n    }\n    \n    void push(int x) {\n        if (top < size) {\n            simStack.push_back(x);\n            ++top;\n        }\n    }\n    \n    int pop() {\n        if (top) {\n            --top;\n            int ret = simStack.back();\n            simStack.pop_back();\n            return ret;\n        }\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < k && i < top; ++i) {\n            simStack[i] += val;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918180450","body":"# 思路\r\n\r\n准备两个栈，一个存数字，一个存翻倍字符串\r\n\r\n# 代码\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    string getDigits(string &s, size_t &ptr) {\r\n        string ret = \"\";\r\n        while (isdigit(s[ptr])) {\r\n            ret.push_back(s[ptr++]);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string getString(vector <string> &v) {\r\n        string ret;\r\n        for (const auto &s: v) {\r\n            ret += s;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        vector <string> stk;\r\n        size_t ptr = 0;\r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n            if (isdigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                string digits = getDigits(s, ptr);\r\n                stk.push_back(digits);\r\n            } else if (isalpha(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.push_back(string(1, s[ptr++])); \r\n            } else {\r\n                ++ptr;\r\n                vector <string> sub;\r\n                while (stk.back() != \"[\") {\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(), sub.end());\r\n                // 左括号出栈\r\n                stk.pop_back();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = stoi(stk.back()); \r\n                stk.pop_back();\r\n                string t, o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime--) t += o; \r\n                // 将构造好的字符串入栈\r\n                stk.push_back(t);\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n};\r\n```\r\n\r\n# 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922490763","body":"# 思路\n\ncpp暴力遍历，直接可以通过\n\n# 代码\n\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        for (ListNode *p = headA; p != nullptr; p = p->next) {\n            for (ListNode *q = headB; q != nullptr; q = q->next) {\n                if (p == q)\n                    return p;\n            }\n        }\n        return nullptr;\n    }\n};\n\n```\n\n# 复杂度\n\n时间：O(n^2)\n\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carinSkyrim":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916845902","body":"## 代码\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        left = int(''.join(list(map(str, num))))\n        return [int(i) for i in str(left+k)]\n\n```\n## 复杂度\n时间复杂度 O(n)   \n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917626421","body":"## 思路\n前后遍历\n\n## 代码\n```python \nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        r = [len(s) for i in range(len(s))]\n        tmp = len(s)\n        for left in range(len(r)):\n            if s[left] == c:\n                tmp = 0\n            r[left] = min(tmp, r[left])\n            tmp += 1\n\n        tmp = len(s)\n        for right in range(len(r)-1, -1, -1):\n            if s[right] == c:\n                tmp = 0\n            r[right] = min(tmp, r[right])\n            tmp += 1\n        return r\n```\n## 复杂度  \n时间复杂度 O(n)  \n空间复杂度 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917631183","body":"## 代码\n```python\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxsize = maxSize\n        self.list = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.list) == self.maxsize:\n            return\n        self.list.append(x)\n\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.list) == 0:\n            return -1\n        tmp = self.list[-1]\n        self.list = self.list[:-1]\n        return tmp\n\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        tmp = min(k, len(self.list))\n        for i in range(tmp):\n            self.list[i] += val\n        return\n``` \n## 复杂度\n时间复杂度: O(1), O(1), O(min(k, cnt))  \n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918221168","body":"## 思路  \n递归   \n## 代码\n```python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if not s:\n            return ''\n\n        def helper(s, start):\n            tmpnum = 0\n            index = start\n            r = ''\n            while index < len(s):\n                if ord('0') <= ord(s[index]) <= ord('9'):\n                    tmpnum = tmpnum*10 + int(s[index])\n                    index += 1\n                elif s[index] == '[':\n                    tmpr, location = helper(s, index+1)\n                    r += tmpnum * tmpr\n                    index = location + 1\n                    tmpnum = 0\n                elif s[index] == ']':\n                    return r, index\n                else:\n                    r += s[index]\n                    index += 1\n            return r\n        return helper(s, 0)\n```\n## 复杂度   \n时间复杂度 O(n)\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919203009","body":"## 代码\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stackin = []\n        self.stackout = []\n\n\n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stackin.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        if self.stackout:\n            return self.stackout.pop()\n        else:\n            while self.stackin:\n                self.stackout.append(self.stackin.pop())\n            return self.stackout.pop()\n\n\n    def peek(self):\n        \"\"\"\n        Get the front element.\n        :rtype: int\n        \"\"\"\n        if self.stackout:\n            return self.stackout[-1]\n        else:\n            while self.stackin:\n                self.stackout.append(self.stackin.pop())\n            return self.stackout[-1]\n\n\n    def empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        if not self.stackin and not self.stackout:\n            return True\n        else:\n            return False\n\n```\n## 复杂度 \n时间 O(n)   \n空间 O(n)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921833530","body":"```python\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n\n        start = tmp = ListNode(0, head)\n        slow = head\n        fast = head.next\n\n        while fast:\n            tmpnext = fast.next\n            tmp.next = fast\n            fast.next = slow\n            slow.next = tmpnext\n            tmp = slow\n            if not tmpnext:\n                return start.next\n            else:\n                slow = tmpnext\n                fast = tmpnext.next\n\n        return start.next\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922467586","body":"## 思路\n先各遍历一遍AB，然后算差值，最后重新遍历找公共点\n## 代码\n```python\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not headA or not headB:\n            return None\n\n        indexa = 0\n        tmpa = headA\n        indexb = 0\n        tmpb = headB\n\n        while tmpa.next:\n            tmpa = tmpa.next\n            indexa += 1\n        while tmpb.next:\n            tmpb = tmpb.next\n            indexb += 1\n\n        if tmpa != tmpb:\n            return None\n\n\n        tmpa = headA\n        tmpb = headB\n        if indexa > indexb:\n            pre = indexa-indexb\n            while pre > 0:\n                tmpa = tmpa.next\n                pre -= 1\n        else:\n            pre = indexb-indexa\n            while pre > 0:\n                tmpb = tmpb.next\n                pre -= 1\n        while tmpa != tmpb:\n            tmpa = tmpa.next\n            tmpb = tmpb.next\n        return tmpa\n```\n## 复杂度\n时间复杂度 O(M+N)    \n空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Brandylulu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916862006","body":"## 思路\nlist→string→int→list\n## 代码\nclass Solution:\n\n       def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n\n             n = len(A)\n\n             x = 0\n\n             for i in range(n):\n\n                  x = x + A[i] * (10**(n-i-1))\n\n             return str(x+k)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ivalkshfoeif":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916863413","body":"```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int i = num.length - 1;\n        int carry = 0;\n        List<Integer> ans = new ArrayList();\n        while(k !=0 || i >= 0){\n            //int n1 = (i >=0)? num[i]: 0;\n            int n = k % 10;\n            n += (i >=0)? num[i]: 0;\n            n += carry;\n            int temp = n%10;\n            carry = n / 10;\n            ans.add(temp);\n            k /= 10;\n            i--;\n        }\n        if (carry != 0){\n            ans.add(carry);\n        }\n        Collections.reverse(ans);\n        return ans;\n        \n    }\n}\n```\nO(N) O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420151","body":"```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int prev = -10000;\n        char[] sChars = s.toCharArray();\n        int[] ans = new int[sChars.length];\n        for (int i = 0; i < sChars.length; i++){\n            if (sChars[i] == c){\n                prev = i;\n            }\n            ans[i] = i - prev;\n        }\n        prev = 100000;\n        for (int i = sChars.length - 1; i >= 0; i--){\n            if (sChars[i] == c){\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n        return ans;\n    }\n}\n```\nO(N) O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918305597","body":"```\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack();\n        int repeatTimes = 0;\n        char[] sChars = s.toCharArray();\n        for (char sChar: sChars){\n            if (sChar == ']'){\n                char a = stack.pop();\n                List<Character> temp = new ArrayList();\n                while (a != '['){\n                    temp.add(a);\n                    a = stack.pop();\n                }\n                Collections.reverse(temp);\n                \n            \n                List<Character> times = new ArrayList();\n                char n = stack.pop();\n                while (n >= '0' && n <='9'){\n                    times.add(n);\n                    if (stack.isEmpty()){\n                        break;\n                    }\n                    n = stack.pop();\n                }\n                if (!(n >= '0' && n <= '9')){\n                    stack.push(n);\n                }\n                Collections.reverse(times);\n                for (char ch: times){\n                    repeatTimes = repeatTimes * 10 + ch - '0';\n                }\n                \n           \n                \n                for (int i = 0; i < repeatTimes; i++){\n                    for (char ch: temp){\n                        stack.push(ch);\n                    }\n                }\n                repeatTimes = 0;\n            }else {\n                stack.push(sChar);\n            }\n        }\n        StringBuilder ans = new StringBuilder();\n        for (char ch: stack){\n            ans.append(ch);\n        }\n        return ans.toString();\n    }\n}\n```\n写复杂了，但是打卡时间过了，直接交\nO（N） O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918769510","body":"```\nclass MyQueue {\n    private Stack<Integer> s1;\n    private Stack<Integer> s2;\n    private int front;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        s1 = new Stack();\n        s2 = new Stack();\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n       if (s1.isEmpty()){\n           front = x;\n       }\n        s1.push(x);\n        \n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (s2.isEmpty()){\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n        }\n        return s2.pop();\n        \n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (!s2.isEmpty()){\n            return s2.peek();\n        }\n        return front;\n        \n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return s1.isEmpty() && s2.isEmpty();\n        \n    }\n}\n```\nO(1)O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920130850","body":"最容易理解的答案\n```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        int[] maxOfLeft = new int[n];\n        int[] minOfRight = new int[n];\n\n        maxOfLeft[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n            maxOfLeft[i] = Math.max(maxOfLeft[i-1], arr[i]);\n        }\n\n        minOfRight[n - 1] = arr[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]);\n        }\n\n        int res = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (maxOfLeft[i] <= minOfRight[i + 1]) res++;\n        }\n\n        return res + 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920968647","body":"```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        ListNode newTail = head;\n        ListNode p = head;\n        ListNode newHead = head;\n        \n        \n        int l = 0;\n        while(p != null){\n            p = p.next;\n            l++;\n        }\n        if (l == 0 || l == 1) return head;\n        p = head;\n        k = k % l;\n        // when k == zero throw error\n        if (k == 0) return head;\n        while(k > 0){\n            p = p.next;\n            k--;\n        }\n        while(p.next != null){\n            p = p.next;\n            newTail = newTail.next;\n        }\n        newHead = newTail.next;\n        \n        p.next = head;\n        newTail.next = null;\n        \n        \n        \n        return newHead;\n    }\n}\n```\n自己写得。太丑了，看答案学习下","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921836840","body":"```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n        ListNode p = dummy;\n        while(p.next != null && p.next.next != null){\n            ListNode first = p.next;\n            ListNode second = p.next.next;\n            first.next = second.next;\n            second.next = first;\n            p.next = second;\n            p = first;\n        }\n        return dummy.next;\n        \n    }\n}\n```\nO（N） O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921936808","body":"```\nclass Solution {\n    ListNode i;\n    public TreeNode sortedListToBST(ListNode head) {\n        int length = 0;\n        ListNode p = head;\n        i = head;\n        while (p != null){\n            length++;\n            p = p.next;\n        }\n        \n        return buildTree(0, length - 1);\n        \n    }\n    private TreeNode buildTree(int lo, int hi){\n        if (lo > hi){\n            return null;\n        }\n        TreeNode node = new TreeNode();\n        int mid = lo + (hi - lo)/2;\n        node.left = buildTree(lo,mid - 1);\n        node.val = i.val;\n        i = i.next;\n        node.right = buildTree(mid+1,hi);\n        return node;\n    }\n    \n}\n```\nO(N) O(logN)\n通过数组长度预设一个Tree, 然后中序遍历赋值\n也可以把List转换成数组，然后中序遍历","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922491706","body":"public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n\n        while(p1 != null || p2 != null){\n\n            if (p1 == p2){\n                return p1;\n            }\n\n            if (p1 == null){\n                p1 = headB;\n            }else{\n                p1 = p1.next;\n            }\n            if (p2 == null){\n                p2 = headA;\n            }else {\n                p2 = p2.next;\n            }\n\n\n        }\n        return null;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922511006","body":"```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n\n        while(fast != null){\n            if (fast.next == null){\n                return null;\n            }\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow){\n                ListNode p = head;\n                while(p != slow){\n                    p = p.next;\n                    slow = slow.next;\n                }\n                return p;\n            }\n        }\n        return null;\n        \n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Socrates2001":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916864816","body":"- 时间：2021年9月10日13:34:46\n- 题目：[989.数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n- 思路：逐位相加（最低位开始），将结果逐个放入动态分配的数组中。若某两位相加大于10，则只和的将个位放入数组，十位在适当的数中(k)进1。最后将得到的数组内的数倒置，即为所求。\n\n## c\n\n```c\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n   int *res = (int *)malloc(sizeof(int) * fmax(10, numSize+1));\n   *returnSize = 0;\n   int i, sum, temp;\n\n   for(i=numSize-1; i>=0; i--)\n   {\n       sum = num[i] + k%10;\n       k /= 10;\n       if(sum >= 10)\n       {\n           k++;\n           sum -= 10;\n       }\n       res[(*returnSize)++] = sum;\n   }\n\n   for(; k>0; k/=10)\n   {\n       res[(*returnSize)++] = k % 10;\n   }\n\n   for(i=0; i < (*returnSize)/2; i++)\n   {\n       temp = res[i];\n       res[i] = res[(*returnSize)-1-i];\n       res[(*returnSize)-1-i] = temp;\n   }\n\n    return res;\n}\n```\n\n\n\n- 时间复杂度：O(max(n, lgk)) 其中n为数组长度\n\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917377555","body":"- 时间：2021年9月11日17:26:00\n- 题目：[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n- 思路：先从左到右遍历一遍，计算出（部分）各元素到指定字符的距离，然后再反向遍历一遍，计算出（部分）各元素到指定元素的距离（只有小于之前的距离才能进行相应赋值）。\n\n## C implementation\n\n```c\nint* shortestToChar(char * s, char c, int* returnSize){\n    unsigned int * answer = malloc(sizeof(int) * strlen(s));\n    int i;\n\n    *returnSize = 0; \n    for(i=0; i<strlen(s); i++)\n    {\n        if(s[i] != c)\n            continue;\n\n        for(; (*returnSize)<=i; (*returnSize)++)\n            answer[(*returnSize)] = i - (*returnSize);\n    }\n\n    *returnSize = strlen(s) - 1;\n    for(i=strlen(s)-1; i>=0; i--)\n    {\n        if(s[i] != c)\n            continue;\n\n        for(; (*returnSize)>=i; (*returnSize)--)\n            if((*returnSize) - i < answer[(*returnSize)])\n                answer[(*returnSize)] = (*returnSize) - i;\n    }\n\n    (*returnSize) = strlen(s);\n    \n    return answer;\n}\n```\n\n\n\n- 时间复杂度：O(n²)\n\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917610733","body":"- 时间：2021年9月12日18:25:24\n- 题目：[1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n- 思路：按部就班。\n\n## C implementation\n\n```c\ntypedef struct {\n    int topOfStack;\n    int capacity;\n    int * array;\n\n} CustomStack;\n\n\nCustomStack* customStackCreate(int maxSize) {\n    CustomStack * s = malloc(sizeof(CustomStack));\n    if(s == NULL)\n    {\n        printf(\"Out of space!\");\n        return NULL;\n    }\n    s->array = malloc(sizeof(int) * maxSize);\n    if(s->array == NULL)\n    {\n        printf(\"Out of space!\");\n        return NULL;\n    }\n    s->capacity = maxSize;\n    s->array[s->topOfStack] = -1;\n\n    return s;\n}\n\nvoid customStackPush(CustomStack* obj, int x) {\n    if(obj->array[obj->topOfStack] != obj->capacity-1)\n    {\n        printf(\"Full stack!\");\n        return;\n    }\n    obj->array[++obj->topOfStack] = x;\n    \n}\n\nint customStackPop(CustomStack* obj) {\n    if(obj->array[obj->topOfStack] == -1)\n    {\n        printf(\"Empty stack!\");\n        return -1;\n    }\n    return obj->array[obj->topOfStack--];\n}\n\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\n    int i;\n\n    if(k >= obj->capacity)\n        for(i=0; i<obj->capacity; i++)\n            obj->array[i] += val;\n    else\n        for(i=0; i<k; i++)\n            obj->array[i] += val;\n}\n\nvoid customStackFree(CustomStack* obj) {\n    if(obj != NULL)\n    {\n        free(obj->array);\n        free(obj);\n    }\n}\n\n/**\n * Your CustomStack struct will be instantiated and called as such:\n * CustomStack* obj = customStackCreate(maxSize);\n * customStackPush(obj, x);\n \n * int param_2 = customStackPop(obj);\n \n * customStackIncrement(obj, k, val);\n \n * customStackFree(obj);\n*/\n```\n\n\n\n- 时间复杂度：除了增量操作为O(min(k, maxSize) )外，其他均为O(1)。\n\n- 空间复杂度：O(1)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918048072","body":"- 时间：2021年9月13日18:16:40\n- 题目：[394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n- 思路：光看转换规则是空的，只有看懂程序的流程和每个语句的功能方能真正理解该程序。\n\n## C implementation\n\n```c\n#define MAX_STACK_SIZE 3000\n\nchar * decodeString(char * s){\n    int len = strlen(s);\n    char * strStack = malloc(sizeof(char) * MAX_STACK_SIZE);\n    int top = -1;\n\n    for(int i=0; i<len; i++)\n    {\n        char c = s[i];\n        if(c != ']')\n            strStack[++top] = c;\n        else\n        {\n            char * tmpStack = malloc(sizeof(char) * MAX_STACK_SIZE);\n            int tmpTop = -1;\n            while(strStack[top] != '[') //将相应字符串逆序放入中转栈\n            {\n                tmpStack[++tmpTop] = strStack[top];\n                top--;\n            }\n            top--; //相当于是将‘[’出栈\n            \n            char * cpyStr = malloc(tmpTop + 2); //之所以加2，是因为当前的tmpTop值为字符串长度-1，还有一个1是给‘\\0’用的\n            for(int j=tmpTop; j>=0; j--)\n                cpyStr[tmpTop - j] = tmpStack[j]; //该循环完成后顺便也将tmpStack里的字符逆序了，即还原成原有顺序\n            cpyStr[++tmpTop] = '\\0';\n\n            int timesOfStr = 0;\n            int exp = 0;\n            while(top>=0 && strStack[top] >= '0' && strStack[top] <= '9') //计算相应字符串的倍数\n            {\n                timesOfStr += (strStack[top] - '0') * pow(10, exp);\n                top--;\n                exp++;\n            }\n\n            int l = strlen(cpyStr);\n            for(int j=0; j<timesOfStr; j++) //翻倍相应字符串\n                for(int n=0; n<l; n++)\n                    strStack[++top] = cpyStr[n];\n            free(tmpStack);\n            free(cpyStr);\n        }\n    }   \n    strStack[++top] = '\\0';\n    return strStack;       \n}\n```\n\n\n\n- 时间复杂度：O(n³)，其中n为输入字符串长度\n\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919107541","body":"- 时间：2021年9月14日07:49:38\n- 题目：[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n- 思路：在栈的结构上多设置了一个bottom变量。\n\n## C implementation\n\n```c\ntypedef struct {\n    int top;\n    int bottom;\n    int * array;\n} MyQueue;\n\n/** Initialize your data structure here. */\n\nMyQueue* myQueueCreate() {\n    MyQueue * queue = malloc(sizeof(MyQueue));\n    if(queue == NULL)\n    {\n        printf(\"Out of space!\");\n        return NULL;\n    }\n    queue->array = malloc(sizeof(int) * 100);\n    if(queue->array == NULL)\n    {\n        printf(\"Out of space!\");\n        return NULL;\n    }\n    queue->bottom = queue->top = 0;\n    \n    return queue;\n}\n\n/** Push element x to the back of queue. */\nvoid myQueuePush(MyQueue* obj, int x) {\n    obj->array[obj->top++] = x;\n}\n\n/** Removes the element from in front of queue and returns that element. */\nint myQueuePop(MyQueue* obj) {\n    bool myQueueEmpty(MyQueue* obj);\n\n    if(!myQueueEmpty(obj))\n        return obj->array[obj->bottom++];\n    else\n    {\n        printf(\"Empty queue!\");\n        return -1;\n    }\n}\n\n/** Get the front element. */\nint myQueuePeek(MyQueue* obj) {\n    bool myQueueEmpty(MyQueue* obj);\n\n    if(!myQueueEmpty(obj))\n        return obj->array[obj->bottom];\n    else\n    {\n        printf(\"Empty queue!\");\n        return -1;\n    }\n}\n\n\n/** Returns whether the queue is empty. */\nbool myQueueEmpty(MyQueue* obj) {\n    if(obj->bottom == obj->top)\n        return 1;\n    else \n        return 0;\n}\n\nvoid myQueueFree(MyQueue* obj) {\n    if(!myQueueEmpty(obj))\n    {\n        free(obj->array);\n        free(obj);\n    }\n}\n```\n\n\n\n- 时间复杂度：O(1)\n\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919858377","body":"- 时间：2021年9月15日17:19:26\n- 题目：[768. Max Chunks To Make Sorted II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\n- 思路：找局部最大值，前一块内所有数最大值小于后面所有的数，用栈实现，将数组第一个数入栈，遍历数组，若当前值大于等于栈顶元素，则当前值入栈，否则保存栈顶元素，比较当前值和栈内元素，若当前值小则继续出栈直到当前值大于栈内所有元素或栈为空，再将保存的局部最大值入栈，依此类推，返回栈内元素个数。即所求最大块数。\n\n## C implementation\n\n```c\nint maxChunksToSorted(int* arr, int arrSize){\n    int * monotoStack = malloc(sizeof(int) * arrSize);\n    int top = -1;\n    monotoStack[++top] = arr[0];\n    int temp = 0;\n\n    for(int i=1; i<arrSize; i++)\n    {\n        if(monotoStack[top] <= arr[i])\n            monotoStack[++top] = arr[i];\n        else\n        {\n            temp = monotoStack[top];\n            while(top != -1 && monotoStack[top] > arr[i])\n                top--;\n            monotoStack[++top] = temp; \n        }\n    }\n    top++;\n\n    return top;\n}\n```\n\n\n\n- 时间复杂度：O(n)，其中n为参数数组长度\n\n- 空间复杂度：O(n)，其中n为辅助数组长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920951760","body":"- 时间：2021年9月16日22:13:05\n- 题目：[61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n- 思路： 将旋转链表模拟成尾部删除，头部插入的形式，即每旋转一次，将链表末端节点删除，并将删除元素插入链表为头节点。\n\n  \n\n```c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nint lenOfList(struct ListNode * head)\n{\n    struct ListNode * p = head;\n    int length = 0;\n\n    while(p != NULL)\n    {\n        length++;\n        p = p->next;\n    }\n    return length;\n}\nstruct ListNode * findBeforeLast(struct ListNode * head)\n{\n    struct ListNode * tmpNode = head;\n    \n    while(tmpNode->next->next != NULL)\n    tmpNode = tmpNode->next;\n    return tmpNode;\n    \n}\nint delete(struct ListNode * head)\n{\n    struct ListNode * beforeLast = findBeforeLast(head);\n    struct ListNode * lastNode = beforeLast->next;\n    int val = lastNode->val;\n\n    beforeLast->next = NULL;\n    free(lastNode);\n    return val;\n}\nvoid insert(struct ListNode ** head, int val)\n{\n    struct ListNode * tmpNode;\n    struct ListNode * newNode = malloc(sizeof(struct ListNode));\n\n    newNode->val = val;\n    tmpNode = *head;\n    *head = newNode;\n    newNode->next = tmpNode;\n}\nstruct ListNode* rotateRight(struct ListNode* head, int k){\n    int length;\n\n    length = lenOfList(head);\n    if(length == 0)\n        return NULL;\n    else if(length == 1)\n        return head;\n    else if(length >= 2)\n    {\n        k = k % length;\n        for(int i=0; i<k; i++)\n        insert(&head, delete(head));\n        return head;\n    }\n    return NULL;\n}\n```\n\n\n\n- 时间复杂度：O(n)，其中n为链表长度，主要是求链表长度花的时间较多（相对于其他函数）。插入删除皆为O(1)。\n\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921772158","body":"- 时间：2021年9月17日20:26:19\n- 题目：[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n- 思路：为了更好确保头指针的不变性（在多次swap下），先对链表头两个节点（如果该链表有的话）swap，然后再通过循环对后面的每个swapPair进行swap，并记录每次swapPair的第二节点的地址，方便下次swap。\n\n\n\n## C implementation\n\n```c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nvoid partSwapList(struct ListNode **p)\n{\n    struct ListNode *p1, *p2;\n    p1 = (*p)->next;\n    p2 = p1->next;\n    p1->next = p2->next;\n    p2->next = p1;\n    (*p)->next = p2;\n    *p = p1;\n}\nstruct ListNode* swapPairs(struct ListNode* head){\n    if(head != NULL && head->next != NULL)\n    {\n        struct ListNode *p1, *p2, *tp;\n        p1 = head;\n        p2 = p1->next;\n        p1->next = p2->next;\n        p2->next = p1;\n        head = p2;\n        tp = p1;\n        while(tp->next != NULL && tp->next->next != NULL)\n        {\n            partSwapList(&tp); //通过tp保存交换对交换后的第二个节点的地址，C中没有引用，但可以通过多级指针达到同样的效果。当然，也可以不用函数，直接在本函数进行所有交换。\n        }\n        return head;\n    }\n    return head;\n}\n```\n\n- 时间复杂度：O(n)，其中n为链表的长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922249986","body":"## C implementation\n\n```c\nstruct ListNode* preMid(struct ListNode *head){       //找链表中间结点的前一个结点\n    struct ListNode* slow=head,*fast=head,*preslow=head;\n    while(fast!=NULL&&fast->next!=NULL)\n    {\n        preslow=slow;\n        slow=slow->next;\n        fast=fast->next->next;\n    }\n    return preslow;\n}\nstruct TreeNode* newTreeNode(int x){\n    struct TreeNode* root=(struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val=x;\n    root->left=root->right=NULL;\n    return root;\n}\nstruct TreeNode* sortedListToBST(struct ListNode* head){\n    if(head==NULL) return NULL;                             //递归的终止条件:链表中只有0或1个元素\n    if(head->next==NULL) return newTreeNode(head->val);\n    struct ListNode* premid=preMid(head);\n    struct ListNode* mid=premid->next;\n    premid->next=NULL;              //断开链表 分为前后两部分\n    struct TreeNode* root=newTreeNode(mid->val);\n    root->left=sortedListToBST(head);\n    root->right=sortedListToBST(mid->next);\n    return root;\n}\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922440876","body":"- 时间：2021年9月19日16:43:50\n- 题目：[160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n- 思路：双指针法。即分别用a，b指向A，B两条链的链首。如果a与b相等则则表示找到了相交节点，否则a，b同时后移。当a，b皆为空时，表示没有相交节点；当a为空时，使a指向链B之首；当b为空时，使b指向链A之首。直到a与b相等，此时a所指即相交节点。\n\n\n\n## C implementation\n\n```c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\ntypedef struct ListNode *pointToNode;\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\n    pointToNode a, b;\n    a = headA;\n    b = headB;\n\n    while(a != b)\n    {\n        a = a->next;\n        b = b->next;\n        if(a == NULL && b == NULL)\n            return NULL;\n        if(a == NULL)\n            a = headB;\n        if(b == NULL)\n            b = headA;\n    }\n    return a;\n}\n```\n\n\n\n- 时间复杂度：O(n)，其中n为链表总的节点数\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Just-focus":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916865049","body":"## 代码\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n) n为较长数组的长度\r\n空间复杂度：O(n) n为答案数组的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917416783","body":"### 代码\r\n\r\n```js\r\nvar shortestToChar = function(S, C) {\r\n    let arrC = [-Infinity], res = [];\r\n    for(let i = 0; i < S.length; i++) if(S[i] === C) arrC.push(i);\r\n    arrC.push(Infinity);\r\n    for(let i = 0; i < S.length; i++) {\r\n        if(S[i] === C) {\r\n            arrC.shift();\r\n            res.push(0);\r\n        }else {\r\n            res.push(Math.min(i - arrC[0], arrC[1] - i))\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度分享\r\n\r\n时间复杂度: O(n)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917647469","body":"### 代码\r\n\r\n```js\r\nclass CustomStack {\r\n  constructor(maxSize) {\r\n    this._maxSize = maxSize\r\n    this._size = 0\r\n    this._content = {}\r\n  }\r\n  push(x) {\r\n    if(this._size < this._maxSize) {\r\n      this._content[++this._size] = x\r\n    }\r\n  }\r\n  pop() {\r\n    if(this._size === 0) {\r\n      return -1\r\n    } else {\r\n      const topStackValue = this._content[this._size]\r\n      delete this._content[this._size--]\r\n      return topStackValue\r\n    }\r\n  }\r\n  increment(k, val) {\r\n    if(this._size === 0) {\r\n      return\r\n    }\r\n    for (let index = 1; index <= this._size && index <= k; index++) {\r\n      this._content[index] += val\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(1)。\r\n空间复杂度：O(n)。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919049315","body":"### 代码\r\n\r\n```js\r\nvar MyQueue = function() {\r\n  this.in = []\r\n  this.out = []\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n  this.in.push(x)\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n  if (this.out.length) return this.out.pop()\r\n  else this.transpose()\r\n\r\n  return this.out.pop()\r\n};\r\n\r\nMyQueue.prototype.transpose = function() {\r\n  while (this.in.length) this.out.push(this.in.pop())\r\n}\r\n\r\nMyQueue.prototype.peek = function() {\r\n  if (this.out.length) return this.out[this.out.length - 1]\r\n  else this.transpose()\r\n\r\n  return this.out[this.out.length - 1]\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n  if (this.in.length | this.out.length) return false\r\n  else return true\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(1)\r\n空间：O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922241087","body":"### 代码\r\n\r\n```js\r\nvar sortedListToBST = function(head) {\r\n\r\n  if (!head) return null;\r\n  const nums = [];\r\n\r\n  while(head) {\r\n    nums.push(head.val);\r\n    head = head.next;\r\n  }\r\n  return dfs(nums, 0, nums.length - 1);\r\n\r\n  function TreeNode(val) {\r\n    this.val = val;\r\n    this.left = this.right = null;\r\n  }\r\n\r\n  function dfs(arr, low, high) {\r\n    if (low > high) return null;\r\n    let mid = Math.floor((low + high) / 2);\r\n    let node = new TreeNode(arr[mid]);\r\n\r\n    node.left = dfs(arr, low, mid - 1);\r\n    node.right = dfs(arr, mid + 1, high);\r\n\r\n    return node;\r\n  }\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916865936","body":"思路\n\n平铺直叙\n\n\n\n代码（Python）\n\n    class Solution:\n        def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n            List=num[:]\n            res=[]\n            sum=0\n            Len=len(List)\n            i=Len-1\n            q=1\n            while i>=0:\n                sum=sum+List[i]*q\n                i-=1\n                q*=10\n            sum+=k\n            while sum!=0:\n                res.append(sum%10)\n                sum//=10\n            res.reverse()\n            if len(res)==0:\n                res.append(0)\n            return res\n\n\n\n复杂度\n\n时间：O(n)\n\n空间：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917377278","body":"821. 字符的最短距离\n\n思路\n\n先确定字符C在字符串S中的位置，其次设置两个值left和right分别代表当前字符距左边和右边字符C的距离（要考虑越界情况），最后比大小。\n\n代码（Python）\n\n    class Solution:\n        def shortestToChar(self, s: str, c: str) -> List[int]:\n            ans = [-1] * len(s)\n            Len = len(s)\n            num = []\n            for i in range(Len):\n                if c == s[i]:\n                    ans[i] = 0\n                    num.append(i)\n            Len1 = len(num)\n            left, right = 0, 1\n            if right >= Len1:\n                right = Len1 - 1\n            for i in range(Len):\n                if i >= num[right]:\n                    left += 1\n                    right += 1\n                if right >= Len1:\n                    right = Len1 - 1\n                if left >= Len1:\n                    left = Len1 - 1\n                if ans[i] != 0:\n                    ans[i] = min(abs(num[left] - i), abs(num[right] - i))\n            \n    \n    \n            return ans\n\n复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：o(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917565149","body":"# 1381.设计一个支持增量操作的栈\n\n## 思路\n\n平铺直叙\n\n## 代码(python)\n\n    class CustomStack:\n    \n        def __init__(self, maxSize: int):\n            self.maxSize = maxSize\n            self.Len = 0\n            self.Stack=[]\n    \n        def push(self, x: int) -> None:\n            if self.Len < self.maxSize:\n                self.Stack.append(x)\n                self.Len += 1\n    \n        def pop(self) -> int:\n            if self.Len == 0:\n                return -1\n            else:\n                self.Len -= 1\n                t = self.Stack[self.Len]\n                del self.Stack[self.Len]\n                return t\n    \n        def increment(self, k: int, val: int) -> None:\n            for i in range(self.Len):\n                if i < k:\n                    self.Stack[i] += val\n                else:\n                    break\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918024406","body":"# 394. 字符串解码\n\n## 思路\n\n平铺直叙\n\n\n\n## 遇到的问题\n\n+ 数字的处理，很容易忽略12，123之类的\n+ [[]]，嵌套的处理\n+ 栈类元素的删除，下标的确定\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        # res用来模拟栈\n        res=[]\n        ans=\"\"\n        # flag=0代表没有[]未处理\n        flag=0\n\n        Len=len(s)\n        for i in range(Len):\n            # 如果是字母且不处于[]中,直接放入答案中\n            if s[i].isalpha() and flag==0:\n                ans+=s[i]\n                continue\n\n            # 如果是字母且不等于]，直接压入栈\n            if s[i]!=\"]\":\n                res.append(s[i])\n\n            # flag值的设定,以及处理一个[]\n            if s[i]==\"[\":\n                flag+=1\n            elif s[i]==\"]\":\n                flag-=1\n\n                # 找到最近的一个[\n                index=0\n                for j in range(len(res)-1,-1,-1):\n                    if res[j]==\"[\":\n                        index=j\n                        break\n\n                # t代表[]的字母\n                t=\"\"\n                for j in range(index+1,len(res)):\n                    if res[j].isdigit()==False:\n                        t+=res[j]\n                # 栈内多余的元素删除\n                del res[index:len(res)]\n                # 解决数字问题，例如12，231之类的\n                count=index-1\n                while True:\n                    if res[count].isdigit():\n                        count-=1\n                    else:\n                        break\n                    if count<0:\n                        break\n                # 字母需要重复多少次\n                num=0\n                for j in range(count+1,index):\n                    num=num*10+int(res[j])\n                t=t*num\n\n                # 删除使用过的数字，例如3，34之类的,也可以写成 del res[count+1:index]\n                Len1=len(res)-index+count+1\n                while len(res)!=Len1:\n                    del res[count+1]\n                \n                # 直接放入答案，还是压入栈\n                if flag!=0:\n                    for j in t:\n                        res.append(j)\n                else:\n                    ans=ans+t\n\n        return ans\n```\n\n\n\n## 复杂度\n\n时间复杂度：O(N^2)，但我感觉速度可能要稍微快一点。可能是分析的有问题\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919194168","body":"# 232. 用栈实现队列\n\n## 思路\n\n平铺直叙\n\n## 代码（Python）\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.Queue = []\n        self.head = 0\n        self.tail = 0\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.Queue.append(x)\n        self.tail += 1\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        t = self.Queue[self.head]\n        del self.Queue[self.head]\n        self.tail -= 1\n        return t\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.Queue[self.head]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if self.head == self.tail:\n            return True\n        else:\n            return False\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n\n```\n\n## 时间复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920056495","body":"# 768. 最多能完成排序的块 II\n\n## 思路\n\n1. 整个区间找到最小值Min，然后把Min和之后的元素作为一个新区间，重新寻找最小值，如此反复\n2. 区间里最小值要比之前区间里的最大值要大\n\n\n\n## 代码(Python)\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        for i in range(len(arr)):\n            arr[i] = int(arr[i])\n        count = 0\n        indexA = 0\n        Len = len(arr)\n        Max = 0\n        indexB = indexA\n        while indexA <= Len - 1:\n            indexA = arr.index(min(arr[indexA:]), indexA)\n            count += 1\n            Max1 = max(arr[indexB:indexA + 1])\n            if arr[indexA] < Max:\n                count -= 1\n            if Max1 > Max:\n                Max = Max1\n            indexA += 1\n        return count\n```\n\n\n\n## 时间复杂度\n\n时间复杂度：O(N^2)\n\n空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921014343","body":"# 61. 旋转链表(代码不正确)\n\n## 思路\n\n1. 确定偏移量，分为A+B\n2. 把A+B变成B+A\n\n## 代码（Python）\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # p,q指向头节点\n        p = head\n        q = head\n        # 记录链表的长度\n        Len = 0\n        while p:\n            p = p.next\n            Len += 1\n\n        # 偏移的长度(考虑链表长度为零的情况)\n        if Len == 0:\n            distance = 0\n        else:\n            distance = k % Len\n        distance = Len - distance\n\n        # 切分链表为A+B（目的是变成B+A），使q指向A区域的末节点，p指向B区域的首个结点\n        p = head\n        i = 1\n        while i <= distance and p:\n            p = p.next\n            if i == distance - 1:\n                q = p\n        # ans指向B区域的首个结点，也就是最终答案\n        ans = p\n        # pre指向整个链表的最后一个结点\n        pre = head\n        while p:\n            pre = p\n            p = p.next\n\n        pre.next = head\n        q.next = None\n\n        return ans\n\n```\n\n\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921769218","body":"# 24. 两两交换链表中的节点\n\n## 思路\n\n1. 链表是否为空\n2. 不为空，处理最开始两个结点A->B-C变成B->A-C\n3. 处理接下来的结点，如A->B->C->D变成A->C->B->D\n\n\n\n##代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        ans=pre=last=head\n        if head:\n            last=head.next\n            if last:\n                pre.next=last.next\n                last.next=pre\n                ans=last\n                \n                while True:\n                    tmp=pre\n                    pre=pre.next\n                    if pre:\n                        last=pre.next\n                        if last:\n                            pre.next=last.next\n                            last.next=pre\n                            tmp.next=last\n                        else:\n                            break\n                    else:\n                        break\n\n\n\n            \n            return ans\n        else:\n            return head\n\n```\n\n\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922277112","body":"# 109. 有序链表转换二叉搜索树\n\n## 思路\n\n参考了官方题解，用递归的方法做\n\n\n\n## 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        value=[]\n        while head:\n            value.append(head.val)\n            head=head.next\n        return sortedListToBST(value,0,len(value))\n    \ndef sortedListToBST(value,start,end):\n    if start>=end:\n        return None\n    mid=start+(end-start)//2\n    root=TreeNode(value[mid])\n    root.left=sortedListToBST(value,start,mid)\n    root.right=sortedListToBST(value,mid+1,end)\n    return root\n\n\n\n\n\n\n\n\n```\n\n\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922485981","body":"# 160. 相交链表\n\n## 思路\n\n官方题解\n\n## 代码\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ray-hr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916875507","body":"# 思路   \r\n输出位=x+y+carry   \r\n将A设为LinkedList双向链表   \r\n# 代码  \r\n\r\n````java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        int n = A.length;\r\n        LinkedList<Integer> res = new LinkedList<>();  // 使用双向链表 LinkeList，或者 ArrayList 最后反转\r\n        int i = n - 1, sum = 0, carry = 0;\r\n        while (i >= 0 || K != 0) {  // 循环条件：两个数有一个没完\r\n            int x = i >= 0 ? A[i]: 0;\r\n            int y = K != 0 ? K % 10 : 0;\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            K = K / 10;\r\n            i--;\r\n            res.add(0, sum % 10);\r\n        }\r\n        if (carry != 0) res.add(0, carry);\r\n        return res;\r\n    }\r\n}    \r\n````\r\n# 复杂度  \r\n时间复杂度：O(max(n, lgk))  其中n为数组长度   \r\n空间复杂度：\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917397071","body":"#思路 \r\n最小数组，左右遍历比较大小\r\n#代码  \r\n```` java  \r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    } \r\n````  \r\n#复杂度 \r\n时间复杂度：O(N)O(N)，其中 NN 是 S 的长度，我们需要遍历字符串两次。  \r\n空间复杂度：O(N)O(N)，ans 数组的大小。  ","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921013458","body":"# 思路 \n链表成环，断开 \n# 代码 \n```` java \nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n\n```` \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"PearlCoastal":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916884534","body":"## 思路\n- 从末尾开始做加法\n- 注意处理进位的方式\n    ·新建一个数组b=[]来处理进位，当 [2] + 998 时， carry = 100，b = [1, 0, 0]\n- 取模运算 **%**，和取整运算 **//**的区别\n    · 86 % 10 = 6 \n    · 86 // 10 = 8\n- 数组的加法运算：把两个数组连在一起\n    · A = [1, 2, 3], B = [2, 3, 4]\n    · A + B = [1, 2, 3, 2, 3, 4]\n## 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: [int], k: int) -> [int]:\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            curr_sum = num[i] + k % 10 + carry\n            num[i] = curr_sum % 10\n            carry = curr_sum // 10\n            k //= 10\n        \n        carry += k\n        b = []\n        while carry:\n            b = [(carry % 10)] + b\n            carry //= 10\n\n        return b + num\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917402504","body":"## 思路\n\n两次遍历字符串。\n\n第一次从左到右， 找到当前字符最左边的 c ;\n\n第二次从右到左， 找到当前字符最右边的 c ;\n\n下标为 i 的字符距离字符 c 最近的距离就是 min(i - left, right - i)。\n\n## 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        left, right = float('-inf'), float('inf')\n        ans = []\n        for i, num in enumerate(s):\n            if num == c:\n                left = i\n            ans.append(i - left)\n        \n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                right = i\n            ans[i] = min(ans[i], right - i)\n        return ans\n```\n\n## 复杂度分析\n- 时间复杂度： O(n)\n- 空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917581200","body":"## 思路\r\n**模拟。**\r\n\r\n用数组模拟栈。\r\n\r\n栈大小为 size = maxSize。\r\n\r\n1. push 操作要考虑当前栈满时， 不允许 push 。\r\n\r\n2. pop 操作要考虑当前栈空时， 返回 -1 。\r\n\r\n3. increment 操作时， 对倒数 k 个元素叠加 val， 考虑当栈大小小于 k 的情况， 取 min(k, len(stack) 。\r\n\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.size:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n    def increment(self, k: int, val: int) -> None:\r\n        if not len(self.stack):\r\n            return\r\n        for i in range(min(len(self.stack), k)):\r\n            self.stack[i] += val\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度\r\n  1. push O(1)\r\n  2. pop O(1)\r\n  3. increment O(k)\r\n- 空间复杂度： O(k)\r\nk 为栈 maxSize","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918106525","body":"## 思路\n递归。\n\n1. \"[\": 开启新的一轮递归。 并且生成字符串。\n\n2. \"]\": 返回字符串内容， 并结束当前字符串。\n\n\n## 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n\n        def dfs(position: int):\n            \n            res = \"\"\n            multi_round = 0\n\n            while position < len(s):\n\n                if '0' <= s[position] <= '9':\n                    multi_round = multi_round*10 + int(s[position])\n                \n                elif s[position] == '[':\n                    position, tmp = dfs(position + 1)\n                    res += multi_round * tmp\n                    multi_round = 0\n                \n                elif s[position] == ']':\n                    return position, res\n                \n                else:\n                    res += s[position]\n                \n                position += 1\n            return res\n        \n        return dfs(0)\n```\n\n## 复杂度分析\n- 时间复杂度： O(n)\n- 空间复杂度： O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918925164","body":"## 思路\n记住两个数据结构的特点， 然后一模拟画一画就可以啦。\n\n**栈：** 后进先出。\n\n**队列：** 先进先出。\n\n## 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not self.stack1 and not self.stack2\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n## 复杂度分析\n\n- 时间复杂度： \n\n  - push() 时间复杂度是 O(1)； \n  - peek()/pop() 均摊时间复杂度是 O(1)， \n  - 单步操作的最坏时间复杂度是 O(N)\n\n\n- 空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920073589","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920834337","body":"\n## 思路\n\n虽然题目叫旋转链表， 但其实是要求链表断开的位置。\n\n先遍历一次链表， 求的链表长度 `length`\n\n而截断链表的位置就在 `k % length` 。\n\n快慢指针 `fast， slow`\n\n先让 `fast` 走 `k` 步， 然后 `fast slow` 一起走， 当 `fast` 走到尾节点时， `slow` 正好指向倒数`第 k + 1 个节点`。\n\n断开链表。\n\n`new_head` 指向 倒数`第 k 个节点`， `倒数第 k + 1 个节点`指向` None`。\n\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head:\n            return\n        length, cur = 0, head\n        while cur:\n            length += 1\n            cur = cur.next\n        k = k % length\n\n        fast, slow = head, head\n        for i in range(k):\n            fast = fast.next\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n            \n        fast.next = head\n        new_head = slow.next\n        slow.next = None\n\n        return new_head\n```\n## 复杂度分析\n- 时间复杂度： O(n) 要将链表全部节点遍历一次才能知道链表长度\n- 空间复杂度： O(1)\n           ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921810985","body":"```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n\n        if not head or not head.next:\n            return head\n        \n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922306981","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922483166","body":"## 思路\n链表题很多都是计算步数的。\n\n假设两个链表有公共节点， 节点数为 C\n\n链表 1 的总节点数为 A\n\n链表 2 的总节点数为 B\n\n假设 A > B\n\n链表 2 遍历完成之后开始遍历链表 1 走过的步数为 B + A - C\n\n此时为两链表的第一个公共节点。\n\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\n        node1, node2 = headA, headB\n        while node1 != node2:\n            node1 = node1.next if node1 else headB\n            node2 = node2.next if node2 else headA\n        return node1\n```\n\n## 复杂度分析\n- 时间复杂度： O(a + b)\n- 空间复杂度： O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nekomoon404":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916884660","body":"【思路——数组模拟加法过程】\n\n类似用数组模拟大数加法，即模拟人手算的过程，从低位开始，逐位相加，逢十进一，即：\n\n 当前位 = (数A的当前位 + 数B的当前位 + 低位的进位carry) % 10。\n \n 当最后的进位不为0时，需要添加到答案数组的起始位置，可以用 `vector` 的 `insert` 函数，如 `res.insert(res.begin(), carry)`；\n \n 或者我们可以在存答案数组时，从低位到高位存，即`res[0]`表示最低位，这样在运算过程中一直向数组的尾部插入元素即可，最后再将数组翻转。\n\n【C++代码】\n\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    int n = num.size();\n    vector<int> res;\n\n    int i = n - 1, sum = 0, carry = 0;\n    while(i >= 0 || k != 0) {\n        int a = i >= 0 ? num[i] : 0;\n        int b = k != 0 ? k % 10 : 0;\n\n        sum = a + b + carry;\n        carry = sum / 10;\n        res.push_back(sum % 10);\n\n        i--;\n        k /= 10;\n    }\n\n    if(carry != 0)\n        res.push_back(carry);\n    reverse(res.begin(), res.end());\n\n    return res;\n}\n```\n\n时间复杂度： $O(N)$，记 $N= \\max(n, \\log k)$，即表示答案数组的长度， `while` 遍历是 $O(N)$ 的复杂度，翻转数组也是 $O(N)$ 的复杂度。\n\n空间复杂度： $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428300","body":"【思路——前后遍历数组】\n\n对于字符串s中的每个字符`s[i]`，找他它边最近的字符c和它右边最近的字符c，两个距离取最小值就是`res[i]`。\n\n而找离 `s[i]`左边最近的字符`c`，可以从左到右遍历数组，每次遇到字符`c`就更新下标`prev`的值，然后计算`s[i]`离`prev`的距离，就是`i-prev`；反之，从右向左遍历数组，求`res[i]`和距离`prev-i`的最小值。\n\n过程中涉及到求最小值，我们可以给`prev`初始一个很大的正值，如`INT_MAX`；如果担心运行过程中对大数的加减等操作会导致越界，可以初始成“不那么大的数”，常用的是`0x3f3f3f3f`；本题初始`prev=INT_MAX`不会越界。\n\n```c++\nconst int INF = 0x3f3f3f3f;\nvector<int> shortestToChar(string s, char c) {\n    int n = s.size();\n    vector<int> res(n, 0);\n\n    int prev = INF;\n    for(int i = 0; i < n; i++){\n        if(s[i] == c)  prev = i;\n        res[i] = i - prev;\n    }\n\n    prev = INF;\n    for(int i = n - 1; i >= 0; i--){\n        if(s[i] == c)  prev = i;\n        res[i] = min(abs(res[i]), prev - i);\n    }\n\n    return res;\n}\n```\n\n时间复杂度：$O(n)$，两次遍历数组；\n\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917620392","body":"【思路1——数组模拟栈】\n\n题目要求的三个操作中前两个操作`push`和`pop`都是栈的常规操作，而增量操作`increment`需要对栈底元素操作，而STL中栈的栈底是不可见的，那我们可以直接用数组来模拟栈。\n\n```c++\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int top;\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != stk.size() - 1)\n            stk[++top] = x;\n    }\n    \n    int pop() {\n        if(top == -1)\n            return -1;\n        return stk[top--];\n    }\n    \n    void increment(int k, int val) {\n        int cnt = min(k, top + 1);\n        for(int i = 0; i < cnt; i++)\n            stk[i] += val;\n    }\n};\n```\n\n时间复杂度： `push`和`pop`操作是$O(1)$；增量操作是$O(k)$，需要遍历数组的前k各元素，依次加上val。\n\n空间复杂度： $O(maxSize)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918250287","body":"【思路1——用栈来辅助匹配】\n\n栈用来解决括号匹配问题一直可以的，题目中由于涉及字符串的多次拼接，可以开一个存字符串的栈；字符串重复的次数可以再用一个存数字的栈。\n\n初始化 `string str = \"\"` 和 `int multi = 0`， 从左向右遍历字符串中的元素：\n\n1. 如果是数字，就累积到 `multi` 上，因为可能是给多位数字，即用多个数字字符表示一个整数；\n2. 如果是字母，就接到`str`后面；\n3. 如果是左括号，因为在之后的操作中`['`左边的这部分字符串是不会发生变化的，那我们把`str`压到字符串栈中，再把`multi`压到数字栈中；之后再次初始化它们；\n4. 如果是右括号，则当前`str`中保存的就是括号内的字符串，因为在遇到左括号时`str`已“归零”， 那我们弹出字符串栈的栈顶，就是左括号前面的字符串`last_str`，弹出数字栈的栈顶`multi`，则当前解码的字符串就等于`last_str + str * multi`。\n\n```c++\nstring decodeString(string s) {\n    stack<int> num_stk;\n    stack<string> str_stk;\n\n    int multi = 0;\n    string str = \"\";\n    for(auto ch : s) {\n        if(isdigit(ch)){\n            multi = multi * 10 + ch - '0';\n        }\n        else if(isalpha(ch)){\n            str += ch;\n        }\n        else if(ch == '[') {\n            num_stk.push(multi);\n            str_stk.push(str);\n            str = \"\";\n            multi = 0;\n        }\n        else if(ch == ']') {\n            string last_str = str_stk.top();\n            str_stk.pop();\n            int cur_multi = num_stk.top();\n            num_stk.pop();\n            while(cur_multi--){\n                last_str += str;\n            }\n            str = last_str;\n        }\n    }\n    return str;\n}\n```\n\n时间复杂度： $O(N)$，遍历一次字符串。\n\n空间复杂度： 栈的空间最坏情况下是$O(N)$，如`2[2[2[a]]]`。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919151052","body":"【思路——双栈实现队列】\n\n朴素的想法是设一个主栈，`push`元素时压入主栈，需要队头元素（也就是栈底元素）时，就将主栈的元素依次弹出再压入辅助栈，这样相当于将元素的顺序反转，辅助栈顶的元素就是队头元素了。但这样`pop`和`peak`操作的时间复杂度就是$O(n)$了。\n\n优化的方法是从主栈元素倒腾到辅助栈的时机入手，只在辅助栈为空时，才将元素倒腾到辅助栈；并且可以用一个变量`front`来记录当主栈为空时，压入栈中的第一个元素。当要进行弹出操作时：\n\n1. 如果辅助栈为空，则将主栈中的元素倒腾到辅助栈中，之后辅助栈顶元素就是队头元素；\n2. 如果辅助栈不为空，那辅助栈顶就是队头元素；（这时即使主栈有元素，它们的入队顺序一定是晚于辅助栈中的元素的）\n\n这样弹出操作的均摊复杂度就是 $O(1)$，计算过程可以看[leetcode题解](https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode/)\n\n\n```c++\nclass MyQueue {\npublic:\n    stack<int> s1;\n    stack<int> s2;\n    int front = 0;\n    /** Initialize your data structure here. */\n    MyQueue() {\n\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        if(s1.empty())  //当in为空时，front记录压入栈中的第一个元素\n            front = x;\n        s1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if(s2.empty()){\n            while(!s1.empty()){\n                int tmp = s1.top();\n                s1.pop();\n                s2.push(tmp);\n            }\n        }\n        int ans = s2.top();\n        s2.pop();\n        return ans;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if(s2.empty())\n            return front;\n        else\n            return s2.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n};\n```\n\n时间复杂度： 每种操作的均摊时间复杂度都是$O(1)$；\n\n空间复杂度： $O(n)$，用了额外的空间来存队列的元素。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920012025","body":"【思路——单调递增栈存每个排序块中的最大值】\n\n要实现将数组分块后分别排序每一块，合并在一起后得到整个数组的升序序列，对于某一块，记录此块中元素的最大值为 $head$，则要保证此块后面的元素都 $>=head$，且要使每一块中包含的元素尽可能少。\n\n朴素的做法是：遍历数组，用双指针的方法来找到包含元素尽可能少的满足条件的块（向后遍历，元素都大于等于当前块的最大元素），记录块数，再越过此排序块重新指定双指针的位置开始下一次查找，这样时间复杂度是 $O(n^2)$。\n\n优化方法：分好之后的排序块中的最大值必然是递增的，所以可以用单调栈来维护这些块中的 $head$。用 $head$ 来记录当前块中的最大值，遍历数组，当前元素 $num$：\n\n1. 若栈为空或$num >= head$，则说明 $num$ 现在可以单独作为排序块，压入栈中，更新 $head$；\n2. 若栈不为空且$num < head$，则说明$num$要合并进当前的排序块，否则会破坏排序块的条件，那先将栈顶弹出；但$num$可能小于之前的那些排序块中的最大元素，从而破坏排序块的条件，因此要循环地判断$num$是否小于栈顶元素，若小于就将栈顶弹出；最后我们得到一个满足条件的排序块，它的最大值仍然是$head$，所以再将$head$压入栈中。\n\n最后返回栈中元素的个数就是排序块的数量。\n\n【C++代码】\n\n\n```c++\nint maxChunksToSorted(vector<int>& arr) {\n    stack<int> stk;\n    int head = 0;\n    for(int num : arr){\n        if(stk.empty() || num >= head){\n            head = num;      //head保存当前排序快的最大值\n            stk.push(head);\n        }\n        if(!stk.empty() && num < head){   //如果num比head小，说明需要合并区间，这个区间的最大值仍然是haed\n            stk.pop();  //先将head弹出\n            while(!stk.empty() && num < stk.top()){   //比较num与前面排序块中的最大值，若num更小，则需要合并排序块，排序块中的最大值仍然是head\n                stk.pop();\n            }\n            stk.push(head);   //最后再将当前排序块中的最大值即head压入栈中\n        }\n    }\n    return stk.size();\n}\n```\n\n时间复杂度： $O(N)$，遍历一次数组，栈中的元素至多入栈出栈一次\n\n空间复杂度： $O(N)$，当数组是升序排列时，排列块的数量等于数组的长度，即栈占用线性大小额外空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920937459","body":"【思路——遍历链表】\n\n将链表中每个节点向右移动k个位置，就相当于让链表中倒数第k个节点当新的头节点，把它前面的节点接到原链表结尾的后边。分为下面几步：\n\n1. 先遍历链表，统计节点个数；\n2. 找到**倒数第k个节点前面那个节点**，记为 `prev` ；\n3. 从`prev`后面“断开”，`prev`的下一个节点为新的头节点，让`prev->next`指向空；再让原链表的尾节点的next指向原头节点。\n\n【C++代码】\n\n```c++\nListNode* rotateRight(ListNode* head, int k) {\n    if(!head)  return head;\n    \n    ListNode* tmp = head;\n    //统计原链表中节点的个数\n    int cnt = 1;\n    while(tmp->next){\n        tmp = tmp->next;\n        cnt ++;\n    }  //tmp指向原链表的尾节点\n\n    k %= cnt;\n    if(k == 0)\n        return head;\n    \n    int step = cnt - k - 1;\n    ListNode* prev = head;\n    while(step--){\n        prev = prev->next;\n    }\n\n    ListNode* cur = prev->next;\n    prev->next = nullptr;\n    tmp->next = head;\n    return cur;\n}\n```\n\n时间复杂度： $O(N)$，两次遍历链表；\n\n空间复杂度： $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921838368","body":"【思路——链表节点的next指针操作】\n\n题目要求我们从头开始，两个一对交换链表中相邻的两个节点，记我们要交换的两个节点为 k1 和 k2；记k1前面一个节点为 prev，用题目中的例子即是`prev->k1->k2->3->4....`，要交换k1和k2需要三步操作：\n\n```cpp\nprev->next = k2;\nk1->next = k2->next;\nk2->next = k1;\n```\n\n交换后得到`prev->k2->k1->3->4....`，为交换后面的节点我们需要移动这三个指针，让prev指向k1，k1指向3，k2指向4，也是需要三步：\n\n```cpp\nprev = k1;\nk1 = k1->next;\nk2 = k1->next;\n```\n\n当然也要判断能不能向后走了，**交换完后**若要想后走就要保证后面的两个节点是存在的，即`k1->next && k1->next->next`为真。\n\n为了方便处理边界条件，可以设一个虚拟头节点dummy，让dummy->next指向head；开始时让prev，k1和k2都指向dummy，发现执行一次上面的三步走法，刚好可以走成`prev->k1->k2->3->4...`；那我们只需要特判一下head是否为空就行了，其他情况都在while循环里了。最后返回dummy->next即可\n\n【C++代码】\n\n```cpp\nListNode* swapPairs(ListNode* head) {\n    if(!head)  return head;\n\n    ListNode* dummy = new ListNode(-1);\n    dummy->next = head;\n\n    ListNode* prev = dummy;\n    ListNode* k1 = dummy;\n    ListNode* k2 = dummy;\n    \n    while(k1->next && k1->next->next){\n        prev = k1;\n        k1 = k1->next;\n        k2 = k1->next;\n\n        prev->next = k2;\n        k1->next = k2->next;\n        k2->next = k1;\n    }\n\n    return dummy->next;\n}\n```\n\n时间复杂度： $O(N)$，遍历了一次链表；\n\n空间复杂度： $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922281359","body":"### Day 09\n\n[109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n【思路——快慢指针找链表中点+递归】\n\n每次用快慢指针找到链表的中点，作为根节点；处理左边的链作为左子树，处理右边的链作为右子树，这样递归下去。\n\n【C++代码】\n\n```c++\nTreeNode* sortedListToBST(ListNode* head) {\n    if(!head)  return nullptr;\n    return toBST(head, nullptr);\n}\n\nTreeNode* toBST(ListNode* head, ListNode* tail){\n    if(head == tail)  return nullptr;\n    ListNode* fast = head;\n    ListNode* slow = head;\n\n    while(fast != tail && fast->next != tail){\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n\n    TreeNode* root = new TreeNode(slow->val);\n    root->left = toBST(head, slow);\n    root->right = toBST(slow->next, tail);\n\n    return root;\n}\n```\n\n时间复杂度： $O(n \\log n)$，找链表中点是$O(n)$，递归共$O(\\log n)$层；\n\n空间复杂度： $O(\\log n)$，考虑递归调用栈的开销。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922475310","body":"【思路——双指针】\n\n让两个指针 p 和 q 分别指向链表A和B的头节点，两个指针同时向后移，若 p 到达链表A的尾部空节点，就让它指向链表B的头节点； q 同理。\n\n这样若交点存在，当两个指针走过的距离是 ”a + b + c\"时，它们一定会在交点相遇；当交点不存在时，两个指针走过距离“a + b\" 时，都会指向空节点，即相等，跳出循环，返回 p 即返回空节点。\n\n```c++\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    ListNode* p = headA;\n    ListNode* q = headB;\n\n    while(p != q) {\n        if(p) p = p->next;\n        else p = headB;\n\n        if(q) q = q->next;\n        else q = headA;\n    }\n\n    return p;\n}\n```\n\n时间复杂度： $O(n)$\n\n空间复杂度： $O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen-ds":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916884680","body":"# 思路\n\n从最低位开始相加，按逆序存储在vector中，最后把vector逆序一下就可以。\n\n# 代码\nC++\n```\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    vector<int> res;\n    int carry = 0;\n    int i = num.size() - 1;\n    while (i >= 0 || k || carry) {\n        int tmp = i >= 0 ? num[i--] + carry + k%10 : carry + k%10;\n        carry = tmp /10;\n        k /= 10;\n        res.push_back(tmp%10);\n    }\n    reverse(res.begin(), res.end());\n    return res;\n}\n```\n\n# 复杂度\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917328606","body":"# 思路\n从左边和从右边分别遍历，记录上一个指定字符位置和当前位置的距离，最后遍历一遍取最小值\n# 代码\n```\nvector<int> shortestToChar(string s, char c) {\n        vector<int> right;\n        vector<int> res;\n        int prev = INT_MAX / 2;\n        for(int i = s.size() - 1; i >= 0; i--) {\n            if(s[i] == c) {\n                prev = i;\n            }\n            right.push_back(prev - i);\n        }\n\n        prev = INT_MIN / 2;\n        for(int i = 0; i < s.size(); i++) {\n            if(s[i] == c) {\n                prev = i;\n            }\n            res.push_back(min(i - prev, right[s.size()-i-1]));\n        }\n        return res;\n    }\n```\n# 复杂度\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"minuet-red":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916889747","body":"标准加法模板\r\n时间复杂度O(n),空间复杂度O(n)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\tvector<int> addToArrayForm(vector<int>& num, int k) {\r\n\t\treverse(num.begin(), num.end());\r\n\t\tvector<int>res;\r\n\t\tint carry = 0;\r\n\t\tfor (int i = 0; i < num.size() || k>0; i++) {\r\n\t\t\t// num的当前位\r\n\t\t\tint a = (i < num.size() ? num[i] : 0);\r\n\t\t\t// 模拟加法公式\r\n\t\t\tint sum = a + k % 10 + carry;\r\n\t\t\tres.emplace_back(sum % 10);\r\n\t\t\tk /= 10;\r\n\t\t\tcarry = sum / 10;\r\n\t\t}\r\n\t\tif (carry > 0) {\r\n\t\t\tres.emplace_back(carry);\r\n\t\t}\r\n\t\treverse(res.begin(), res.end());\r\n\t\treturn res;\r\n\t}\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917314402","body":"对每个字符左右寻找最小的，遇到边界输出另一边\r\n如果该字符为c，则直接给0\r\n\r\n时间O(n)\r\n空间O(1)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\tvector<int> shortestToChar(string s, char c) {\r\n\t\tint len = s.size();\r\n\t\tvector<int>answer;\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tif (s[i] == c) {\r\n\t\t\t\tanswer.push_back(0);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tint j = i;\r\n\t\t\tint k = i;\r\n\t\t\twhile (s[j] != c) {\r\n\t\t\t\tj--;\r\n\t\t\t\tif (j < 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (s[k] != c) {\r\n\t\t\t\tk++;\r\n\t\t\t\tif (k >= len) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tint la = i - j;\r\n\t\t\tint lb = k - i;\r\n\r\n\t\t\tif (j < 0) {\r\n\t\t\t\tanswer.push_back(lb);\r\n\t\t\t}\r\n\t\t\telse if (k >= len) {\r\n\t\t\t\tanswer.push_back(la);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tanswer.push_back(min(la, lb));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn answer;\r\n\t}\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917642461","body":"简单模拟\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n\tCustomStack(int maxSize) {\r\n\t\tm_maxSize = maxSize;\r\n\t}\r\n\r\n\tvoid push(int x) {\r\n\t\tif (stack.size() < m_maxSize) {\r\n\t\t\tstack.push_back(x);\r\n\t\t}\r\n\t}\r\n\r\n\tint pop() {\r\n\t\tif (stack.size() > 0) {\r\n\t\t\tint top = stack.back();   // 返回栈最后一个元素\r\n\t\t\tstack.pop_back();         // 弹出栈最后一个元素\r\n\t\t\treturn top;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid increment(int k, int val) {\r\n\t\tif (k > stack.size()) {\r\n\t\t\tk = stack.size();\r\n\t\t}\r\n\t\tfor (int i = 0; i < k; i++) {\r\n\t\t\tstack[i] += val;\r\n\t\t}\r\n\t}\r\n\r\n\tvector<int>stack;\r\n\tint m_maxSize;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917795154","body":"时间复杂度O(n)\r\n空间复杂度O(n)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\tstring decodeString(string s) {\r\n\t\tstring res;   // 字符串形式的栈\r\n\t\tfor (int i = 0; i < s.size(); i++) {    // 遍历整个string\r\n\t\t\tif (s[i] != ']') {\r\n\t\t\t\tres += s[i];\r\n\t\t\t}\r\n\t\t\telse if (s[i] == ']') {                  // 如果到']'就往回走\r\n\t\t\t\tstring saveStr = \"\";            // 每次循环初始化\r\n\t\t\t\tstring saveNum = \"\";\r\n\t\t\t\twhile (res.back() != '[') {   // 前面一定有'['\r\n\t\t\t\t\tsaveStr = res.back() + saveStr;   // 记录括号内的字符串\r\n\t\t\t\t\tres.pop_back();           // 往前走\r\n\t\t\t\t}\r\n\t\t\t\tres.pop_back();               // 去掉'['\r\n\t\t\t\twhile (res.size() != 0 && isdigit(res.back())) {   // 前面是数字且不越界都成立才循环\r\n\t\t\t\t\tsaveNum = res.back() + saveNum;          // 记录前面的数字\r\n\t\t\t\t\tres.pop_back();           // 往前走\r\n\t\t\t\t} // 得到数字和数字作用的字符串，已解出当前括号\r\n\t\t\t\tint n = stoi(saveNum);\r\n\t\t\t\twhile (n--) {\r\n\t\t\t\t\tres += saveStr;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918695764","body":"```cpp\r\nclass MyQueue {\r\npublic:\r\n\tMyQueue() {\r\n\t}\r\n\r\n\tvoid push(int x) {\r\n\t\tqueue.push_back(x);\r\n\t}\r\n\r\n\tint pop() {\r\n\t\tint front = queue.front();\r\n\t\tqueue.pop_front();\r\n\t\treturn front;\r\n\t}\r\n\r\n\tint peek() {\r\n\t\treturn queue.front();\r\n\t}\r\n\r\n\tbool empty() {\r\n\t\treturn queue.empty();\r\n\t}\r\n\r\n\tdeque<int>queue;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919609014","body":"遍历数组 arr 中的每个数字 num ；\r\n当栈 stack 不为空且数字 num<栈顶值 时： （代表此 num 会改变前面排序块分布）\r\n栈顶 pop() 出栈，并保存栈顶值为 head。 （此情况下，新排序块最大值还为 head ，因此先暂存）\r\n当 stack 不为空且数字 num<栈顶值 时，循环栈顶 pop() 出栈。 （判断加入 num 需要合并的所有排序块，每 pop() 一个 head代表合并一个块）\r\n将保存的栈顶值 head重新 push() 入栈。 （将 head 重新加入，作为新排序块的最大值）\r\n当栈 stack 为空或数字 num>=栈顶值 时： （代表此 num 不影响前面排序块分布）\r\n将 num 数字 push() 入栈。 （加入单个元素的新排序块 [num]）\r\n遍历完成后，栈中保存 所有排序块的对应最大值 head ，因此返回栈 stack 长度即可获得排序块数量。\r\n时间复杂度 O(N) ：遍历一遍 arr为 O(N)，修正排序块最多遍历一遍 arr 为 O(N)；\r\n空间复杂度 O(N) ：极端情况下排序块数量等于数组长度，此时 stack 占用线性大小额外空间。\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\tint maxChunksToSorted(vector<int>& arr) {\r\n\t\tstack<int>stk;\r\n\t\tfor (auto& i : arr) {\r\n\t\t\tif (!stk.empty() && i < stk.top()) {\r\n\t\t\t\tint head = stk.top();\r\n\t\t\t\tstk.pop();\r\n\t\t\t\twhile (!stk.empty() && i < stk.top()) {\r\n\t\t\t\t\tstk.pop();\r\n\t\t\t\t}\r\n\t\t\t\tstk.push(head);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tstk.push(i);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn stk.size();\r\n\t}\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920842040","body":"时间复杂度 O(N)\r\n空间复杂度 O(1)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\tListNode* rotateRight(ListNode* head, int k) {\r\n\t\tif (head == nullptr || head->next == nullptr) return nullptr;\r\n\t\tListNode* cur = head;\r\n\t\tint num = 0;\r\n\t\twhile (cur != nullptr) {\r\n\t\t\tcur = cur->next;\r\n\t\t\tnum++;\r\n\t\t}\r\n\t\tk %= num;\r\n\t\tif (k == 0) return head;\r\n\t\tListNode* slow = head;\r\n\t\tListNode* fast = head;\r\n\t\tint count = 0;\r\n\t\twhile (fast->next != nullptr) {\r\n\t\t\tfast = fast->next;\r\n\t\t\tcount++;\r\n\t\t\tif (count > k) {\r\n\t\t\t\tslow = slow->next;\r\n\t\t\t}\r\n\t\t}\r\n\t\tListNode* newHead = slow->next;\r\n\t\tslow->next = nullptr;\r\n\t\tfast->next = head;\r\n\r\n\t\treturn newHead;\r\n\t}\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921611510","body":"时间复杂度 O(n)\r\n空间复杂度 O(1)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\tListNode* swapPairs(ListNode* head) {\r\n\t\tListNode* dummyNode = new ListNode;\r\n\t\tListNode* pre = dummyNode;\r\n\t\tpre->next = head;\r\n\t\twhile (pre->next != nullptr && pre->next->next != nullptr) {\r\n\t\t\tListNode* first = pre->next;\r\n\t\t\tListNode* second = pre->next->next;\r\n\t\t\tpre->next = second;\r\n\t\t\tfirst->next = second->next;\r\n\t\t\tsecond->next = first;\r\n\t\t\tpre = first;\r\n\t\t}\r\n\r\n\t\treturn dummyNode->next;\r\n\t}\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922482505","body":"class Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a = headA\r\n        b = headB\r\n        while a != b:\r\n            if a is not None:\r\n                a = a.next\r\n            else:\r\n                a = headB\r\n            if b is not None:\r\n                b = b.next\r\n            else:\r\n                b = headA\r\n        return a","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LAGRANGIST":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916891700","body":"## 思路\r\n\r\n* 用 carry 记录上一位是否有进位， carry =  ( A[i]+B[i]+carry ) **>=** 10 ? 1 : 0  （注意这里是大于等于而不是大于）\r\n* 当前位 cur 可以表示为 ( A[i]+B[i]+carry ) % 10 \r\n* 处理完 num 的所有数字后，再处理k（如果k的位数比 num 大）\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n## 代码\r\n\r\n```c++\r\n#include <bits./stdc++.h>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nvector<int> addToArrayForm(vector<int> &num, int k)\r\n{\r\n    int carry = 0;\r\n    int cur = 0;\r\n    vector<int> res;\r\n    while (!num.empty())\r\n    {\r\n\r\n        cur = (num.back() + k % 10 + carry) % 10;\r\n        carry = (num.back() + k % 10 + carry) >= 10 ? 1 : 0;//看看这一位是否要进位到下一位\r\n        k /= 10;//去除k最后一位数字\r\n        res.push_back(cur);//res先反向保存，之后调用reverse调转之后再返回\r\n        num.pop_back();//去除num最后一位数字\r\n    }\r\n\r\n    while(k!= 0)//k位数比num大\r\n    {\r\n        cur = (k % 10 + carry) % 10;\r\n        carry = (k % 10 + carry) >= 10 ? 1 : 0;\r\n        k /= 10;\r\n        res.push_back(cur);\r\n    }\r\n\r\n    if(carry)//最后一次还要进位\r\n    {\r\n        res.push_back(1);\r\n    }\r\n\r\n    reverse(res.begin(), res.end()); //反转输出才是正确的\r\n    return res;\r\n}\r\n\r\n//TestDrive\r\nint main()\r\n{\r\n    vector<int> num = {2,1,5};\r\n    int k = 806;\r\n    vector<int> ans = addToArrayForm(num,k);\r\n    for (auto it = ans.begin(); it != ans.end();it++)\r\n    {\r\n        cout << *it << \" \";\r\n    }\r\n}\r\n```\r\n\r\n***\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n\r\n\r\n### 时间复杂度\r\n\r\n此方法需要遍历一个 num 和 int类型数字 k 的每一位\r\n\r\n所以时间复杂度是：O( max(N , K ) ) , 其中N和K分别是 num 和 k 的位数 \r\n\r\n\r\n\r\n### 空间复杂度\r\n\r\n利用了一个辅助 `vector<int> res` 其大小为max（N , K)\r\n\r\n所以空间复杂度是O( max(N, K ) )","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917353759","body":"G## 思路\r\n\r\n* res [ i ] 记录的是第 i 个元素与离他最近的字符 c 的距离，它左边的 c 和右边的 c 到他距离中比较小的那一个就是最短距离\r\n\r\n* 初始化数组 res 全部为 -1\r\n\r\n* 从左向右遍历一遍\r\n\r\n\t* 如果发现 c，用 pre 来保存 c 的下标\r\n\t* 如果不是 c 但是没有找到c（pre == -1）就啥也不做跳过\r\n\r\n\t* 如果不是 c 并且 找到了 c (pre 不是 -1) 的话，就将res [ i ] 的值更新为 i - pre\r\n\r\n* 将pre重新归为 -1 （非常重要，我在这个地方就犯错了）\r\n\r\n* 从右向左遍历一遍\r\n\r\n\t* 如果发现 c，用 pre 来保存 c 的下标\r\n\t* 如果不是 c 但是没有找到c（pre == -1）就啥也不做跳过\r\n\r\n\t* 如果不是 c 并且 找到了 c (pre 不是 -1) 的话，就将res [ i ] 的值更新为 min ( res [ i ] , pre - i )\r\n\t\t* 但是这里要注意如果 res [ i ] 在从左向右结束后值为 -1 的话上述min值会是-1，所以单独判断一下是不是 -1，是的话直接将其更新为pre - i\r\n\r\n***\r\n\r\n\r\n\r\n\r\n\r\n## 代码\r\n\r\n```c++\r\nclass Solution\r\n{\r\npublic:\r\n    vector<int> shortestToChar(string s, char c)\r\n    {\r\n        int pre = -1;                        //用来记录上一个找到的 c,-1表示还没有找到\r\n        vector<int> res(s.size(), -1);       // -1 表示还没有找到对应的最近距离\r\n        for (int i = 0; i < s.length(); i++) //从 0 走到最后（从左到右扫描）\r\n        {\r\n            if (s[i] == c)\r\n            {\r\n                res[i] = 0;\r\n                pre = i; //记录下c的位置\r\n            }            //if\r\n\r\n            else if (pre != -1) //已经发现了他之前的一个c\r\n            {\r\n                res[i] = i - pre;\r\n            }\r\n\r\n            //如果没发现c就保持-1不变\r\n\r\n        } //for前到后\r\n\r\n        pre = -1; //这个很关键啊，第一次写就忘记重新归位了\r\n\r\n        for (int i = s.size() - 1; i >= 0; i--)\r\n        {\r\n            if (s[i] == c)\r\n            {\r\n                res[i] = 0;\r\n                pre = i; //记录下c的位置\r\n            }            //if\r\n\r\n            else if (pre != -1)\r\n            {\r\n                if (res[i] == -1)//防止后面的 min 里面因为 -1 更小就保留成 -1 了\r\n                {\r\n                    res[i] = pre - i;\r\n                }\r\n                else\r\n                    res[i] = min(res[i], pre - i); //如果从后往前扫的距离短了就更新\r\n            }\r\n\r\n        } //for从后到前\r\n\r\n        return res;\r\n\r\n    } //shortesToChar\r\n};    //Solution\r\n\r\n```\r\n\r\n***\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n\r\n\r\n### 时间复杂度\r\n\r\n遍历了两次数组，复杂度是 O( n )\r\n\r\n\r\n\r\n### 空间复杂度\r\n\r\n用了一个 vector 用于保存返回的数组，复杂度是 O( n )\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917623076","body":"## 题目描述\r\n\r\n#### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n难度中等\r\n\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 `CustomStack` ：\r\n\r\n- `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\r\n- `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 `x` 添加到栈顶。\r\n- `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 **-1** 。\r\n- `void inc(int k, int val)`：栈底的 `k` 个元素的值都增加 `val` 。如果栈中元素总数小于 `k` ，则栈中的所有元素都增加 `val` 。\r\n\r\n \r\n\r\n**示例：**\r\n\r\n```\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n```\r\n\r\n \r\n\r\n**提示：**\r\n\r\n- `1 <= maxSize <= 1000`\r\n- `1 <= x <= 1000`\r\n- `1 <= k <= 1000`\r\n- `0 <= val <= 100`\r\n- 每种方法 `increment`，`push` 以及 `pop` 分别最多调用 `1000` 次\r\n\r\n***\r\n\r\n## 思路\r\n\r\n* 前两个函数实现就是普通的栈功能\r\n* 关键是第三个函数 inc 的实现：初步设计思路（今天作业好多先不考虑前缀和做法了，模拟方法过了再说）\r\n* IMPROVE ME !!!\r\n\r\n***\r\n\r\n## 代码\r\n\r\n> cpp 面向对象还没怎么学，用 c 写了这题\r\n\r\n```c\r\ntypedef struct {\r\n    int data[1001];\r\n    int top;\r\n    int maxSize;\r\n} CustomStack,*pt;//pt as the pointer of CumstomStack\r\n\r\n\r\nCustomStack* customStackCreate(int maxSize) {\r\n    pt stk = (CustomStack *)malloc(sizeof(CustomStack));\r\n    memset(stk, 0, sizeof(CustomStack));\r\n\r\n    stk->top = -1;//mark -1 as empty,maxSize -1 as full\r\n                 // and top is the index of the top element\r\n    stk->maxSize = maxSize;\r\n    return stk;\r\n}\r\n\r\nvoid customStackPush(CustomStack* obj, int x) {\r\n    if(obj->top < obj->maxSize - 1)//栈不满\r\n    {\r\n        obj -> data[++(obj->top)] = x;\r\n    }\r\n}\r\n\r\nint customStackPop(CustomStack* obj) {\r\n    if(obj->top != -1)//栈不空\r\n    {\r\n        int top_value = obj -> data[obj->top];\r\n        obj->top--;\r\n        return top_value;\r\n    } \r\n    return -1;\r\n}\r\n\r\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\r\n    for(int i = 0;i<k;i++)\r\n    {\r\n        obj -> data[i]+=val;\r\n    }\r\n}\r\n\r\nvoid customStackFree(CustomStack* obj) {\r\n     free(obj);\r\n}\r\n\r\n/**\r\n * Your CustomStack struct will be instantiated and called as such:\r\n * CustomStack* obj = customStackCreate(maxSize);\r\n * customStackPush(obj, x);\r\n \r\n * int param_2 = customStackPop(obj);\r\n \r\n * customStackIncrement(obj, k, val);\r\n \r\n * customStackFree(obj);\r\n*/\r\n```\r\n\r\n***\r\n\r\n## 复杂度分析\r\n\r\n### 时间复杂度\r\n\r\ninc 是 O( k ) 其他两个是 O( 1 )\r\n\r\n### 空间复杂度\r\n\r\n辅助空间只有一些单个变量所以空间复杂度是 O( 1 )","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918317397","body":"## 题目描述\r\n\r\n#### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n难度中等\r\n\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 *encoded_string* 正好重复 *k* 次。注意 *k* 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 *k* ，例如不会出现像 `3a` 或 `2[4]` 的输入。\r\n\r\n \r\n\r\n**示例 1：**\r\n\r\n```\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n```\r\n\r\n**示例 2：**\r\n\r\n```\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n```\r\n\r\n**示例 3：**\r\n\r\n```\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n```\r\n\r\n**示例 4：**\r\n\r\n```\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n```\r\n\r\n\r\n\r\n***\r\n\r\n\r\n\r\n## 思路\r\n\r\n- 本题难点在于括号内嵌套括号，需要**从内向外**生成与拼接字符串，这与栈的**先入后出**特性对应。\r\n- 借助两个栈strs 和 nums 分别保存字符串和数字\r\n- 遍历 S ：\r\n\t- 如果遇到数字就开始记录数字直到  ' [ '\r\n\t- 如果是字母就 `strs.top() += s[i]`\r\n\t- 如果是 ’ [ ' 就将记录的数字入栈并且归零，然后讲后面的字符入栈直到不是字母为止\r\n\t- 如果是 ‘ ] ' 则将栈顶的 nums.top( ) 倍的 strs.top( )加入到栈顶的后一个元素后面然后让其成为新的栈顶\r\n\r\n***\r\n\r\n## 代码\r\n\r\n```c++\r\n#include <iostream>\r\nusing namespace std;\r\n#include <bits/stdc++.h>\r\n\r\n/*\r\n迭代实现思路：\r\n    借助两个栈 stack <string> strs 和 stack <int> nums;\r\n    并且将结果保存到字符串 ans 里面\r\n    遍历 s： \r\n    1. 如果遇到数字则开始记录数字\r\n    2. 如果遇到字母则 strs.top() += s[i] \r\n    3. 如果遇到 [ 则将记录的数字入栈,将其后面的字符串入栈直到遇到不是字母的东西\r\n    4. 如果是 ‘ ] ' 则将栈顶的 nums.top( ) 倍的 strs.top( )加入到栈顶的后一个元素后面然后让其成为新的栈顶 \r\n\r\n*/\r\n\r\nstring decodeString(string s)\r\n{\r\n    stack<int> nums;\r\n    stack<string> strs;\r\n    int multi = 0;\r\n    string res = \"\";\r\n    int i = 0;\r\n    strs.push(res);\r\n    while(i < s.length())\r\n    {\r\n        if (s[i] <= '9' && s[i] >= '0') //情况1\r\n        {\r\n            multi = 10 * multi + s[i] - '0';\r\n            i++;\r\n        }\r\n        if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) //情况2\r\n        {\r\n            string to_be_added = strs.top();\r\n            strs.pop();\r\n            to_be_added += s[i];\r\n            strs.push(to_be_added);\r\n            i++;\r\n        }\r\n        if (s[i] == '[')\r\n        {\r\n            nums.push(multi);\r\n            i++;\r\n            multi = 0;\r\n            string temp = \"\";   //清零很重要\r\n            while ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) //将 [ 后面的字符部分入栈，\r\n            {\r\n                temp += s[i];\r\n                ++i;\r\n            }\r\n            strs.push(temp);\r\n            temp = \"\";//养成习惯，用来记录的变量用完后就清零(例如cnt,flag那些)\r\n        }\r\n        if(s[i] == ']')\r\n        {\r\n            string to_be_multiplied = strs.top();\r\n            strs.pop();\r\n            string to_be_added = strs.top();\r\n            strs.pop();\r\n            \r\n            for (int i = 0; i < nums.top(); i++)\r\n            {\r\n                to_be_added += to_be_multiplied;\r\n            }\r\n            strs.push(to_be_added);//现在top就是相对来说最内层的了\r\n            nums.pop();\r\n            ++i;//这里一开始漏\r\n        }\r\n      \r\n    }\r\n    return strs.top();\r\n}\r\n\r\n//test drive\r\nint main()\r\n{\r\n    // freopen(\"input.txt\", \"r\", stdin);\r\n    // freopen(\"output.txt\", \"w\", stdout);\r\n    \r\n    string input = \"\";\r\n    cin >> input;\r\n    cout << decodeString(input)<<endl;\r\n    return 0;\r\n}\r\n```\r\n\r\n***\r\n\r\n## 复杂度分析\r\n\r\n时间复杂度和空间复杂度均为 O( n )\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919085831","body":"## 思路\r\n\r\n* 栈是只有一头可以操作，队列是两头，那么把栈的两个栈底拼接起来就可以像队列一样了\r\n* 而且栈是先入后出，那么两次先入后出就是负负得正那样变成先入先出了\r\n\r\n\r\n\r\n## 代码\r\n\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n      stack<int> inStack, outStack;//Two stacks to be a queue\r\n\r\n    //将instack里面所有元素转移到outstack\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\n\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        int top;\r\n        if(!outStack.empty())\r\n        {      \r\n            top = outStack.top();\r\n            outStack.pop();\r\n            return top;\r\n      \r\n        }\r\n    \r\n        else\r\n        {\r\n            in2out();\r\n            top = outStack.top();\r\n            outStack.pop();\r\n            return top;\r\n\r\n        }\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(!outStack.empty())\r\n        {\r\n            return outStack.top();\r\n        }\r\n        else\r\n        {\r\n            in2out();\r\n            int x = outStack.top();\r\n            return x;\r\n        }\r\n    }\r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return(inStack.empty()&&outStack.empty());\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n时间： 均摊复杂度是 O( 1 )  \r\n空间： 复杂度是 O( n )\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920107453","body":"## 题目描述\r\n\r\n\r\n\r\n#### [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n*这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为`2000`，其中的元素最大为`10**8`。*\r\n\r\n`arr`是一个可能包含**重复元素**的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n\r\n我们最多能将数组分成多少块？\r\n\r\n**示例 1:**\r\n\r\n```\r\n输入: arr = [5,4,3,2,1]\r\n输出: 1\r\n解释:\r\n将数组分成2块或者更多块，都无法得到所需的结果。\r\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \r\n```\r\n\r\n**示例 2:**\r\n\r\n```\r\n输入: arr = [2,1,3,4,4]\r\n输出: 4\r\n解释:\r\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\r\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \r\n```\r\n\r\n**注意:**\r\n\r\n- `arr`的长度在`[1, 2000]`之间。\r\n- `arr[i]`的大小在`[0, 10**8]`之间。\r\n\r\n通过次数5,005\r\n\r\n提交次数9,953\r\n\r\n\r\n\r\n## 思路\r\n\r\n* 维护一个单调栈使得局部递减，整体递增\r\n\r\n\r\n\r\n## 代码\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> stk;\r\n        for(int i =0;i<arr.size();i++){\r\n            if(!stk.empty()&&stk.top()>arr[i]){\r\n               \r\n                int cur = stk.top();\r\n                // 维持栈的单调递增\r\n                while(!stk.empty()&&stk.top()>arr[i]){\r\n                    stk.pop();\r\n                }\r\n                stk.push(cur);\r\n            }else{\r\n                stk.push(arr[i]);\r\n            }\r\n        }\r\n        // 栈存的是块信息，因此栈的大小就是块的数量\r\n        return stk.size();\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n时间复杂度是 O ( n )\r\n\r\n最坏情况下空间复杂度是 O （n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920904660","body":"## 题目描述\r\n\r\n#### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\n给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。\r\n\r\n \r\n\r\n**示例 1：**\r\n\r\n![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)\r\n\r\n```\r\n输入：head = [1,2,3,4,5], k = 2\r\n输出：[4,5,1,2,3]\r\n```\r\n\r\n**示例 2：**\r\n\r\n![img](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)\r\n\r\n```\r\n输入：head = [0,1,2], k = 4\r\n输出：[2,0,1]\r\n```\r\n\r\n \r\n\r\n**提示：**\r\n\r\n- 链表中节点的数目在范围 `[0, 500]` 内\r\n- `-100 <= Node.val <= 100`\r\n- `0 <= k <= 2 * 109`\r\n\r\n***\r\n\r\n\r\n\r\n## 思路\r\n\r\n* 我的思路麻烦了其实，一开始想到双指针找到倒数第 k 个处理下头尾就完事了\r\n* 但是发现样例里面有 k 大于长度的情况，得，那得 k %= length了\r\n* 那就遍历一次求 length，然后再按照上面双指针来一次\r\n* 正确思路其实应该利用 length 和 k算出现在 p 要走的步数就行了，用不着双指针\r\n\r\n***\r\n\r\n## 代码\r\n\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(!head)//空链表直接返回\r\n        {\r\n            return head;\r\n        }\r\n        ListNode *p = head;\r\n        ListNode *q = head;\r\n        int cnt = 0;\r\n        \r\n        while(p->next != nullptr)\r\n        {\r\n            cnt++;\r\n            p = p->next;\r\n        }//求出链表长度-1,即为cnt\r\n\r\n        k %= (cnt+1);//求出最小需要的位移\r\n        p = head;//归位\r\n\r\n        for(int i = 0;i < k;i++)//双指针法使得 p 下一个就是将来的头, p -> next 要设为空\r\n        {\r\n            q = q->next;\r\n        }\r\n        while(q->next!=nullptr)\r\n        {\r\n            p = p->next;\r\n            q = q->next;\r\n        }\r\n        //现在 p下一个是倒数第 k个， 而 q在尾部,接下来处理头尾\r\n        q -> next = head;//连成环了\r\n        q = p->next;\r\n        p -> next = nullptr;\r\n        return q;\r\n    }   \r\n}\r\n```\r\n\r\n***\r\n\r\n## 复杂度分析\r\n\r\n时间复杂度是 O( n )\r\n\r\n空间复杂度是 O( 1 )``","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921067927","body":"## 题目描述\r\n\r\n#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\r\n\r\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n\r\n**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。\r\n\r\n \r\n\r\n**示例 1：**\r\n\r\n![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\r\n\r\n```\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n```\r\n\r\n**示例 2：**\r\n\r\n```\r\n输入：head = []\r\n输出：[]\r\n```\r\n\r\n**示例 3：**\r\n\r\n```\r\n输入：head = [1]\r\n输出：[1]\r\n```\r\n\r\n \r\n\r\n**提示：**\r\n\r\n- 链表中节点的数目在范围 `[0, 100]` 内\r\n- `0 <= Node.val <= 100`\r\n\r\n \r\n\r\n**进阶：**你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\r\n\r\n***\r\n\r\n## 思路\r\n\r\n* 采用递归的思路，但是由于是两个一组递归，所以base case为只有一个或者一个都没有的情况\r\n* 递归关系式为： res[n] = a[2] + a[1] + res[n-2]\r\n\r\n\r\n\r\n## 代码\r\n\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n\r\ntypedef ListNode* pt;\r\n\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if(!head || !head->next)//base case\r\n        {\r\n            return head;\r\n        }\r\n        pt p = head;\r\n        pt q = head->next;\r\n        pt leftover = q->next;\r\n        q->next = p;\r\n        p->next = swapPairs(leftover);\r\n        return q;\r\n    }\r\n};\r\n```\r\n\r\n***\r\n\r\n## 复杂度分析\r\n\r\n时间复杂度为 O(n)\r\n\r\n空间复杂度为 O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922295253","body":"class Solution:\n    def sortedListToBST(self, head):\n        def get_mid(left, right):\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n\n        def tree(left, right):\n            if left == right:\n                return None\n            mid = get_mid(left, right)\n            root = TreeNode(mid.val)\n            root.left = tree(left, mid)\n            root.right = tree(mid.next, right)\n            return root\n\n        return tree(head, None)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922374271","body":"## 题目描述\r\n\r\n\r\n\r\n#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\r\n\r\n给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。\r\n\r\n图示两个链表在节点 `c1` 开始相交**：**\r\n\r\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\r\n\r\n题目数据 **保证** 整个链式结构中不存在环。\r\n\r\n**注意**，函数返回结果后，链表必须 **保持其原始结构** 。\r\n\r\n \r\n\r\n**示例 1：**\r\n\r\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\r\n\r\n```\r\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\r\n输出：Intersected at '8'\r\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\r\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\r\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\r\n```\r\n\r\n**示例 2：**\r\n\r\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)\r\n\r\n```\r\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\r\n输出：Intersected at '2'\r\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\r\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\r\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\r\n```\r\n\r\n**示例 3：**\r\n\r\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)\r\n\r\n```\r\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\r\n输出：null\r\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\r\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\r\n这两个链表不相交，因此返回 null 。\r\n```\r\n\r\n \r\n\r\n**提示：**\r\n\r\n- `listA` 中节点数目为 `m`\r\n- `listB` 中节点数目为 `n`\r\n- `0 <= m, n <= 3 * 104`\r\n- `1 <= Node.val <= 105`\r\n- `0 <= skipA <= m`\r\n- `0 <= skipB <= n`\r\n- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`\r\n- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA + 1] == listB[skipB + 1]`\r\n\r\n \r\n\r\n**进阶：**你能否设计一个时间复杂度 `O(n)` 、仅用 `O(1)` 内存的解决方案？\r\n\r\n***\r\n\r\n## 思路\r\n\r\n* 两个长度分别为a, b则长的那一个链表先走abs(a-b)步\r\n* 然后两个一起走就会相遇在相交的地方\r\n\r\n***\r\n\r\n## 代码\r\n\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int getListLength(ListNode *head)\r\n    {\r\n        if(!head)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        int cnt = 0;\r\n\r\n        while(head)\r\n        {\r\n            cnt++;\r\n            head = head -> next;\r\n        }\r\n        return cnt;\r\n    }\r\n\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        int lenA = getListLength(headA);\r\n        int lenB = getListLength(headB);\r\n        ListNode *longer = (lenA>=lenB)? headA:headB;\r\n        ListNode *shorter = (longer == headA)?headB:headA;\r\n        int gap = lenA>lenB?(lenA-lenB):(lenB-lenA);\r\n        for(int i = 0;i<gap;i++)\r\n        {\r\n            longer = longer->next;\r\n        }\r\n        while(longer!=shorter)\r\n        {\r\n            longer = longer->next;\r\n            shorter = shorter -> next;\r\n        }\r\n        return longer;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n* 时间复杂度 O(n) \r\n\r\n* 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mokrs":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916900111","body":"## 思路一\n\n从低位到高位，逐位相加，相加结果直接修改原数组\n\n## 分析\n\n- 时间复杂度：$O(max(n,  logK))$\n\n- 空间复杂度：$O(1)$\n\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    int i = num.size() - 1;\n    int plus = 0;\n\n    while (i >= 0 && k > 0){\n        int t = num[i] + plus + k % 10;\n        plus = t >= 10 ? 1 : 0;\n        num[i] = t % 10;\n        k /= 10;\n        --i;\n    }\n\n    while (i >= 0){\n        int t = num[i] + plus;\n        plus = t >= 10 ? 1 : 0;\n        num[i] = t % 10;\t\t\t\n        --i;\n    }\n\n    while (k > 0){\n        int t = plus + k % 10;\n        plus = t >= 10 ? 1 : 0;\n        num.insert(num.begin(), t % 10);\n        k /= 10;\t\t\t\n    }\n\n    if (plus > 0){\n        num.insert(num.begin(), plus);\n    }\n\n    return num;\n}\n```\n\n## 思路二\n\n从低位到高位，逐位相加，相加结果以逆序方式存储，最后对数组进行翻转\n\n## 分析\n\n- 时间复杂度：$O(max(n,  logK))$\n\n- 空间复杂度：$O(n)$\n\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    vector<int> res;\n    int i = num.size() - 1;\n    int plus = 0;\n    while (i >= 0 || k > 0){\n        int sum = plus;\n        sum += i >= 0 ? num[i] : 0;\n        sum += k > 0 ? k % 10 : 0;\n        plus = sum >= 10 ? 1 : 0;\n        res.push_back(sum % 10);\n        k /= 10;\n        --i;\n    }\t\n\n    if (plus > 0){\n        res.push_back(plus);\n    }\n\n    reverse(res.begin(), res.end());\n    return res;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917390211","body":"## 思路\r\n\r\n分为三种情况：\r\n\r\n1. 只有左边有字符c：距离为 `c的索引 - 字符的索引`\r\n2. 左右都有字符c：取与两个c的距离更小者\r\n3. 只有右边有字符c：距离为 `字符的索引 - c的索引`\r\n\r\n```c++\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res(s.length());  \r\n    //使用r1和r2分别记录依次出现的两个字符c的索引\r\n    //由于字符s长度<=10000，将r2初始值设置为10001，则情况1可与情况2作相同处理\r\n    int i = 0, r1 = 0, r2 = 10001;\r\n   \t\r\n    while (i < s.length()){\r\n        //从索引i起，在s中找到第一个c的索引，记为r1\r\n        //如未找到，r1为s最后一个字符的索引+1\r\n        while (r1 < s.length() && s[r1] != c){\r\n            ++r1;\r\n        }\r\n        //计算索引i到r之间各字符的结果，即取i与r1和r2差值的更小者\r\n        for (; i < r1; ++i)\t{\r\n            //未找到c时，即出现情况3，结果为i与最后一个c的索引的差值\r\n            if (r1 == s.length()){\r\n                res[i] = i - r2;\r\n            }          \r\n            //情况1与情况2\r\n            else{\r\n                res[i] = min(abs(r1 - i), abs(i - r2));\r\n            }\r\n        }\r\n\r\n        r2 = r1;\r\n        ++r1;\r\n        i = r1;\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n\r\n## 分析\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917610928","body":"## 思路\n使用一个数组来模拟，用一个变量记录top的位置\n\n```c++\nclass CustomStack {\nprivate:\n\tvector<int> vec;\n\tint maxSize;\n\tint top;\n\npublic:\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;\n\t\ttop = -1;\t\t\n    }\n    \n    void push(int x) {\n        if (top < (int)(vec.size()) - 1){\n\t\t\tvec[++top] = x;\n\t\t}\n\t\telse if (vec.size() < maxSize){\n\t\t\tvec.push_back(x);\n\t\t\t++top;\n\t\t}\t\n    }\n    \n    int pop() {\n        if (top > -1){\n\t\t\treturn vec[top--];\n\t\t}\n\t\telse{\n\t\t\treturn -1;\n\t\t}\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < k && i <= top; ++i){\n\t\t\tvec[i] += val;\n\t\t}\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：push和pop为O(1)，increment为O(k)\n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919060259","body":"```c++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> stk_in, stk_out;\r\n    \r\npublic:\r\n    MyQueue() {\r\n    }\r\n       \r\n    void push(int x) {\r\n        stk_in.push(x);\r\n    }\r\n       \r\n    int pop() {\r\n        if (stk_out.empty()) {\r\n\t\twhile (!stk_in.empty()) {\r\n                    stk_out.push(stk_in.top());\r\n                    stk_in.pop();\r\n                    }\r\n\t\t}\r\n\t\tint element = stk_out.top();\r\n\t\tstk_out.pop();\r\n\t\treturn element;\r\n    }\r\n\r\n    int peek() {\r\n        if (stk_out.empty()) {\r\n\t\twhile (!stk_in.empty()) {\r\n                    stk_out.push(stk_in.top());\r\n                    stk_in.pop();\r\n                    }\r\n\t\t}\r\n\t\treturn stk_out.top();\t\r\n    }\r\n   \r\n    bool empty() {\r\n        return stk_in.empty() && stk_out.empty();\r\n    }   \r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间：push 和 empty 为 O(1)，pop 和 peek 操作由于只有在`stk_out`为空时才会执行`stk_in`到`stk_out`数据转移，因此均摊复杂度为 O(1)\r\n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920844709","body":"## 思路\n\n- 如果k大于链表长度，则旋转后的结果与 `k=k % 链表长度`时的结果一致，因此首先遍历链表，得到链表长度\n- 旋转链表，相当于将链表头尾链接后，再从`链表长度-k`处断开，并将断开处的结点作为头结点返回\n\n```c++\nListNode* rotateRight(ListNode* head, int k) {\n    if (head == nullptr || k == 0){\n        return head;\n    }\n\n    ListNode* p = head;\n\n    int cnt = 1;\n    while (p -> next != nullptr){\n        ++cnt;\n        p = p->next;\n    }\n    p->next = head;\n\n    k = cnt - k % cnt;\n    p = head;\n    while (k > 1){\n        p = p->next;\n        --k;\n    }\t\t\n\n    head = p->next;\n    p->next = nullptr;\n\n    return head;\n}\n```\n\n## 复杂度\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921844908","body":"## 思路\r\n\r\n画了半天图，才发现不知道怎么插入打卡里，暂时先本地保存吧^^\r\n\r\n```c++\r\nListNode* swapPairs(ListNode* head) {\r\n    if (head == nullptr || head->next == nullptr){\r\n        return head;\r\n    }\r\n\r\n    ListNode *p = new ListNode(0, head), *q = head->next;\r\n    head = q;\r\n    while (p && q){\r\n        p->next->next = q->next;\r\n        q->next = p->next;\r\n        p->next = q;\r\n        p = q->next;\r\n        if (p->next == nullptr){\r\n            break;\r\n        }\r\n        q = p->next->next;\r\n    }\r\n    return head;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间：O(n)\r\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922273103","body":"## 思路\n\n因为要构建平衡二叉树，因此根结点为链表的中间位置。找到链表中间位置，使用慢快指针，快指针每次走2步，慢指针走1步，当快指针到达链表尾部时，慢到达链表中间位置。然后再分别递归调用左右链表，作为中间结点的左右子树。\n\n```c++\nTreeNode* sortedListToBST(ListNode* head) {\n    if (head == nullptr){\n        return nullptr;\n    }\n    else if (head->next == nullptr){\n        return new TreeNode(head->val);\n    }\n\n    ListNode *fast = head, *slow = head, *prior = head;\n    head = slow;\n    while (fast && fast->next){\n        fast = fast->next->next;\t\n        prior = slow;\n        slow = slow->next;\n    }\n    prior->next = nullptr;\n    TreeNode* node = new TreeNode(slow->val, sortedListToBST(head), \n                                  sortedListToBST(slow->next));\n\n    return node;\n}\n```\n\n## 复杂度\n\n- 时间：O(nlogn)\n- 空间：O(logn)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922440032","body":"## 思路\r\n\r\n分别遍历两个链表，如果两个链表的尾结点不一样则表明两个链表不相交，返回。否则指向较长链表的指针先移动两个链表的长度差(n)步，然后两个指针一起移动，当两个指针指向了同一结点即为相交的开始结点\r\n\r\n```c++\r\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n    ListNode* p1 = headA;\r\n    ListNode* p2 = headB;\r\n\r\n    int n = 0;\r\n    while (p1->next){\r\n        n++;\r\n        p1 = p1->next;\r\n    }\r\n\r\n    while (p2->next){\r\n        n--;\r\n        p2 = p2->next;\r\n    }\r\n\r\n    //尾结点不同，则两个链表必不相交\r\n    if (p1 != p2){\r\n        return nullptr;\r\n    }\r\n\r\n    //统计使p1指向较长链表头结点，p2指向较短链表头结点\r\n    p1 = n>0 ? headA : headB;\r\n    p2 = p1 == headA ? headB : headA;\r\n    \r\n    n = abs(n);\r\n    //p1先走n步\r\n    for (int i = 0; i<n; i++){\r\n        p1 = p1->next;\r\n    }\r\n\r\n    //两个链表一起移动，当两个指针指向是一结点时，即为相交的起始节点\r\n    while (p1 != p2){\r\n        p1 = p1->next;\r\n        p2 = p2->next;\r\n    }\r\n\r\n    return p1;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间：O(n)\r\n- 空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"niyaolanggeyo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916902429","body":"# 思路\n\n总体思路仿照的是，加法计算过程。采用最低位向前依次递进的方式。最后逆序输出。\n\n# 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> res = new ArrayList<Integer>();\n\n        for (int i = n - 1; i >= 0 || k > 0; i--) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n            k /= 10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n# 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420615","body":"# 思路\n通过使用双指针来计算当前位置的最小距离。当索引等于右指针的位置后，及时地更新两个指针的位置。这样可以保证最小距离的计算结果的正确性。\n\n# 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        int first = s.indexOf(c);\n        int second = s.indexOf(c, first+1) != -1 ? s.indexOf(c, first+1) : first;\n        for (int i=0; i<s.length();i++){\n            int dis1 = Math.abs(i - first);\n            int dis2 = Math.abs(i - second);\n            result[i] = dis1 <= dis2 ? dis1 : dis2;\n            if(i == second){\n                first = second;\n                second = s.indexOf(c, first+1) != -1 ? s.indexOf(c, first+1) : first;\n            }\n        }\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917648973","body":"# 思路\n\n- 因为本题给出了最多元素个数，所以选择数组来模拟栈的操作\n- 使用s来表示栈顶元素的索引\n- 出栈和入栈的时候，要考虑到是否已空或者已满\n\n# 代码\n\n```java\nclass CustomStack {\n    private int[] stack;\n    private int s;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        s = 0;\n    }\n    \n    public void push(int x) {\n        if (s == stack.length){\n            return;\n        }\n        stack[s++] = x;\n    }\n    \n    public int pop() {\n        if (s == 0) return -1;\n        return stack[--s];\n    }\n    \n    public void increment(int k, int val) {\n        int b = Math.min(k, s);\n        for (int i = 0; i < b; i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n\n# 复杂度\n\n- 时间复杂度：\n\n  push：O(1)\n\n  pop：O(1)\n\n  increment：O(min(k, s))\n\n- 空间复杂度：\n\n  O(maxSize)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922325338","body":"# 思路\n\n将中间节点作为平衡二叉树的根节点，划分左右部分为左右子树的节点，递归左右子链表，再寻找其中的中间节点，如此不断循环\n\n# 代码\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n        ListNode left = head, right = head, pre = null;\n        while (right.next != null) {\n            right = right.next.next != null ? right.next.next : right.next;\n            pre = left;\n            left = left.next;\n        }\n        TreeNode root = new TreeNode (left.val);\n        pre.next = null;\n        ListNode t = left.next;\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(t);\n        return root;\n    }\n}\n```\n\n# 复杂度\n\n时间复杂度：O(nlogn)\n\n空间复杂度：O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bowlofnoodles":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916904082","body":"## 思路\n常规思路\n\n## 代码\n``` javascript\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n```\n\n## 复杂度分析\n+ 时间复杂度：O(N)\n+ 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Moin-Jer":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916904187","body":"### 思路\r\n---\r\n转化为两个数组，从后往前对应位置相加，最后再进行反转\r\n### 代码\r\n----\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n        char[] ch = String.valueOf(k).toCharArray();\r\n        int i = num.length - 1, j = ch.length - 1, carry = 0;\r\n        while (i >= 0 || j >= 0 || carry > 0) {\r\n            int x = (i >= 0 ? num[i] : 0);\r\n            int y = (j >= 0 ? ch[j] - '0' : 0);\r\n            int sum = x + y + carry;\r\n            list.add(sum % 10);\r\n            carry = sum / 10;\r\n            --i;\r\n            --j;\r\n        }\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n---\r\n+ 时间复杂度：O(max(nums.length, logk))\r\n+ 空间复杂度：O(logk)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917360042","body":"### 思路\n---\n数组的正向遍历和反向遍历取最值\n### 代码\n---\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] ch = s.toCharArray();\n        int len = ch.length;\n        int[] ans = new int[len];\n        \n        int pre = -len;\n        for (int i = 0; i < len; ++i) {\n            if (ch[i] == c) {\n                pre = i;\n            }\n            ans[i] = i - pre;\n        }\n\n        pre = 2 * len;\n        for (int i = len - 1; i >= 0; --i) {\n            if (ch[i] == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i], pre - i);\n        }\n        return ans;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度： O(N)\n+ 空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917561760","body":"### 思路\n---\n使用数组模拟栈\n\n### 代码\n---\n```java\nclass CustomStack {\n\n    int[] stack;\n    int capacity, size;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        capacity = maxSize;\n        size = 0;\n    }\n    \n    public void push(int x) {\n        if (size < capacity) {\n            ++size;\n            stack[size - 1] = x;\n        }\n    }\n    \n    public int pop() {\n        int ans = -1;\n        if (size > 0) {\n            ans = stack[size - 1];\n            --size;\n        }\n        return ans;\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < size && i < k; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度： O(1)\n+ 空间复杂度： O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918273621","body":"### 思路\n---\n使用栈存储未匹配的字符\n### 代码\n---\n```java\nclass Solution {\n    public String decodeString(String s) {\n        char[] ch = s.toCharArray();\n        int len = ch.length;\n        Deque<String> stack = new LinkedList<>();\n        int num = 0;\n        for (int i = 0; i < len; ++i) {\n            if (ch[i] != ']') {\n                if (ch[i] >= '0' && ch[i] <= '9') {\n                    num = num * 10 + ch[i] - '0';\n                } else if (ch[i] == '[') {\n                    stack.push(num + \"\");\n                    stack.push(ch[i] + \"\");\n                    num = 0;\n                } else {\n                    stack.push(ch[i] + \"\");\n                }\n            } else {\n                String str = \"\";\n                while (!\"[\".equals(stack.peek())) {\n                    str = stack.pop() + str;\n                }\n                stack.pop();\n                int n = Integer.parseInt(stack.pop());\n                String res = \"\";\n                for (int j = 0; j < n; ++j) {\n                    res += str;\n                }\n                stack.push(res);\n            }\n        }\n        String ans = \"\";\n        while (!stack.isEmpty()) {\n            ans = stack.pop() + ans;\n        }\n        return ans;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(N) \n+ 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919101889","body":"### 思路\n---\n使用两个栈，一个代表进栈，一个代表出栈，模拟队列实现\n### 代码\n---\n```java\nclass MyQueue {\n\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        inStack = new LinkedList<>();\n        outStack = new LinkedList<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (outStack.isEmpty()) {\n            while (!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (outStack.isEmpty()) {\n            while (!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度： O(1)\n+ 空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920031906","body":"### 思路\n---\n使用栈保存前面一块的最大值\n### 代码\n---\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new LinkedList<>();\n        for (int i = 0; i < arr.length; ++i) {\n            if (!stack.isEmpty() && arr[i] < stack.peek()) {\n                int head = stack.pop();\n                while (!stack.isEmpty() && arr[i] < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(head);\n            } else {\n                stack.push(arr[i]);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度： O(N)\n+ 空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920614061","body":"### 思路\n---\n先闭合为环， 找到真正的头节点，再断开头节点的前一个节点\n### 代码\n---\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        ListNode h = head, pre = null, tail = head;\n        int size = 1;\n        while (h.next != null) {\n            ++size;\n            h = h.next;\n            tail = h;\n        }\n        k %= size;\n        if (k == 0) {\n            return head;\n        }\n        tail.next = head;\n        h = head;\n        for (int i = 0; i <= size - 1 - k; ++i) {\n            pre = h;\n            h = h.next;\n        }\n        pre.next = null;\n        return h;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度： O(N)\n+ 空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921410322","body":"### 思路\n---\n找到反转后的头节点，将上一块的为节点连接到头节点，并将上一块的下一个节点连接到头节点的下一个节点\n### 代码\n---\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(-1, head);\n        ListNode pre = dummy, cur = head;\n        while (cur != null && cur.next != null) {\n            ListNode next = cur.next;\n            pre.next = next;\n            cur.next = next.next;\n            next.next = cur;\n            pre = cur;\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度： O(N)\n+ 空间复杂度： O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922160106","body":"### 思路\n---\n找到链中点作为根节点的值，将链表分为两部分，递归处理左右子树\n### 代码\n---\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n        ListNode pre = null, h1 = head, h2 = head;\n        while (h2 != null && h2.next != null) {\n            pre = h1;\n            h1 = h1.next;\n            h2 = h2.next.next;\n        }\n        TreeNode root = new TreeNode(h1.val);\n        pre.next = null;\n        h2 = h1.next;\n        h1 = head;\n        root.left = sortedListToBST(h1);\n        root.right = sortedListToBST(h2);\n        return root;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度： O(NlogN)，递归深度为 logn，每一层都需要遍历整个链表\n+ 空间复杂度： O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916906152","body":"### 思路\r\n\r\n先mark\r\n\r\n### 代码\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n    const ret = [];\r\n    let i = num.length - 1, carry = 0;\r\n    while (i >= 0 || k != 0) {\r\n        let x = i >= 0 ? num[i] : 0;\r\n        let y = k !== 0 ? k % 10 : 0;\r\n\r\n        const sum = x + y + carry;\r\n\r\n        ret.push(sum % 10);\r\n        carry = Math.floor(sum / 10);\r\n\r\n        i--;\r\n        k = Math.floor(k / 10);\r\n    }\r\n    if (carry) {\r\n        ret.push(carry);\r\n    }\r\n    return ret.reverse();\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917431013","body":"### 思路\r\n\r\n两次遍历\r\n(先mark)\r\n\r\n### 代码\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    //两个循环，设prev 为 INFINITY\r\n    //第一个循环从左到右，每次在s找到 c 这个字符 就更新 prev = i（c 这个字符的INDEX）\r\n    // 然后让最近更新的 c 字符 Index 和 当前 字符 INDEX 相减 取绝对值（因为从左到右，不取绝对值会得到负数）\r\n    let prev = Infinity;\r\n    let res = [];\r\n    for(let i =0; i<s.length;i++){\r\n        if(s[i] === c){\r\n            prev = i;\r\n        }\r\n        res[i] = Math.abs(prev-i);\r\n    }\r\n    //第一次循环之后 res 里面的结果，当前数值还没完全正确\r\n// I I I 0 1 0 0 1 2 3 4  ，I = Infinity\r\n    \r\n    // reset prev to INFINITY\r\n    prev = Infinity;\r\n    // 第二次循环从右到左， 跟第一次循环步骤一样\r\n    for(let j = s.length-1; j>=0; j--){\r\n        if(s[j] === c){\r\n            prev = j;\r\n        }\r\n        // 不同的地方是这里 对比第一次循环和第二次循环得到的值，然后取最小值更新res\r\n        res[j] = Math.min(res[j],prev-j);\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917656508","body":"### 思路\r\n\r\n用额外array存相加的数字，pop的时候才把两个数字相加，就不用遍历数组把每个数字相加\r\n\r\n(先mark)\r\n\r\n### 代码\r\n\r\n```js\r\n//time O(1)\r\n//space O(n) extra space\r\n\r\nvar CustomStack = function(maxSize) {\r\n    this.size = maxSize;\r\n    this.sum = new Array(maxSize).fill(0);\r\n    this.values = [];\r\n};\r\n\r\n\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.values.length <this.size){\r\n        this.values.push(x);\r\n    } \r\n};\r\n\r\n\r\nCustomStack.prototype.pop = function() {\r\n   if(this.values.length){\r\n       let lastElementIndex = this.values.length-1;\r\n       let SumPosition = this.sum[lastElementIndex];\r\n       if(lastElementIndex>0){\r\n           this.sum[lastElementIndex-1]+= this.sum[lastElementIndex] \r\n       }\r\n        this.sum[lastElementIndex] = 0;\r\n       return this.values.pop() + SumPosition;\r\n   }\r\n    return -1;\r\n};\r\n\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n   let sumIndex = Math.min(this.values.length,k)-1;\r\n    this.sum[sumIndex]+= val;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919090257","body":"## 思路\r\n\r\n先mark\r\n\r\n## 代码\r\n\r\n```js\r\nvar MyQueue = function() {\r\n  this.in = []\r\n  this.out = []\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n  this.in.push(x)\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n  if (this.out.length) return this.out.pop()\r\n  else this.transpose()\r\n\r\n  return this.out.pop()\r\n};\r\n\r\nMyQueue.prototype.transpose = function() {\r\n  while (this.in.length) this.out.push(this.in.pop())\r\n}\r\n\r\nMyQueue.prototype.peek = function() {\r\n  if (this.out.length) return this.out[this.out.length - 1]\r\n  else this.transpose()\r\n\r\n  return this.out[this.out.length - 1]\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n  if (this.in.length | this.out.length) return false\r\n  else return true\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922324019","body":"### 思路\r\n\r\n\r\n(mark 先抄作业)\r\n\r\n### 代码\r\n\r\n```js\r\nconst sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  const sorted = [];\r\n  let cur = head;\r\n\r\n  while (cur) {\r\n    sorted.push(cur.val);\r\n    cur = cur.next;\r\n  }\r\n\r\n  const generate = (l, r) => {\r\n    if (l > r) return null;\r\n    const mid = Math.floor((r + l) / 2);\r\n    let val = sorted[mid];\r\n    const node = new TreeNode(val);\r\n    node.left = generate(l, mid - 1);\r\n    node.right = generate(mid + 1, r);\r\n    return node;\r\n  };\r\n\r\n  return generate(0, sorted.length - 1);\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Shinnost":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916906847","body":"### 思路\n将数字`k`作为一个整体由低位到高位进行相加，从而不断进位。因为每一次同位加法都有可能发生进位，进位数大于10对加法运算没有影响。初始化：`i = len(num) - 1`。将数字`k`与`num[i]`相加，对结果取个位数作为新的`num[i]`；将结果除以10作为新的`k`。`i -= 1`。不断执行上述过程，直至`k`第一次为0时停止。因为`k`是作为一个整体往`num`上加的，当最后的结果的位数大于转换成数字的`num`的位数时，索引`i`会超过数组`num`的索引范围，故需要进行判断并添加`num`的长度使得上述过程能够正常运行，即对`num`的前几个元素添加适当的0。\n\n### 实现(python)\n```python\n## https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/pythonc-san-chong-jie-fa-by-milomusiala-7wc5/\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n\n        while k != 0:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k != 0:\n                num.insert(0, 0)\n                i = 0\n\n        return num\n```\n\n### 复杂度分析\n1. 时间复杂度：$O(n^2)$。遍历数组嵌套python的list.insert()。\n2. 空间复杂度：$O(1)$。原地操作，使用了常数级空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917404762","body":"### 思路\n\n双指针法。从头至尾遍历字符串。索引`left`和`right`指向相邻的两个字符`c`，对`left`和`right`之间的字符按照规则进行编号。初始化：`left = -len(s), right = 0`。终止条件：`right != len(s)`\n\n### 实现(python)\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        length = len(s)\n        left, right = -length - 1, 0\n        while right != length:\n            while right != length and s[right] != c:\n                right += 1\n\n            if right != length:\n                if left == -length - 1:\n                    for i in range(right + 1):\n                        ans.append(right - i)\n                else:\n                    for i in range(left + 1, right + 1):\n                        if i - left < right - i:\n                            ans.append(i - left)\n                        else:\n                            ans.append(right - i)\n                left, right = right, right + 1\n            elif s[-1] != c:\n                for i in range(left + 1, length):\n                    ans.append(i - left)\n        return ans\n```\n\n### 复杂度分析\n\n1. 时间复杂度：$O(n^2)$。相当于嵌套遍历了两次字符串。\n2. 空间复杂度：$O(1)$。除返回值外，只使用了常数级空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917654301","body":"### 思路\n\n使用大小为`maxSize`的数组记录栈信息，用变量`top`来记录栈顶的位置并对数组进行相应的操作。进行优化：使用大小为`maxSize`的数组`add`记录`increment()`的操作。其原理为：由于`increment()`是一个批量操作，对于索引在`[0, min(k - 1, top))`的元素加的是同一个`val`，所以可只对位置为`min(k - 1, top)`的元素进行操作，通过`pop()`时输出实际栈顶值，并通过`add[top - 1], add[top] = add[top], 0`向前传播`incremrnt()`操作时的信息\n\n\t关键点：\n\n\t- `top`代表的是当前栈顶的索引，当前元素的实际个数为`top + 1`\n\t- `lim = min(k - 1, self.top)`：因为是对数组进行操作，索引从0开始\n\t- 当`self.top == 0`时，代表所有的信息已经传递到第一个元素了，故不需要向前传递以免超出索引值\n\n### 实现(python)\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.add = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        ret = self.stk[self.top] + self.add[self.top]\n        if self.top != 0:\n            self.add[self.top - 1] += self.add[self.top]\n        self.add[self.top] = 0\n        self.top -= 1\n        return ret\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k - 1, self.top)\n        if lim >= 0:\n            self.add[lim] += val\n```\n\n### 复杂度分析\n\n1. 渐进时间复杂度：均为O(1)$。\n2. 渐进空间复杂度：$O(maxSize)$。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918310054","body":"### 思路\n\n字符`'['`作为入栈标志，字符`']'`作为出栈标志。每次出栈时拼接当前`k[encoded_string]`与上一个包含该`k[encoded_string]`的`k[encoded_string]`的剩余部分，可假设最开始的字符串`s`由一个`[]`包裹，且已经完成入栈操作。即由最内层`[]`向外进行解码。\n\n关键点：\n\n- 初始化：`res, multi = '', 0`。\n- 拼接：`res = last_res + res * cur_multi`\n\n### 实现(python)\n\n```python\n# https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], '', 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = '', 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + res * cur_multi\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)\n            else:\n                res += c\n        return res\n```\n\n### 复杂度分析\n\n1. 时间复杂度：$O(n)$。共遍历一遍字符串。\n2. 空间复杂度：$O(n)$。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919182349","body":"### 思路\n\n栈A先进后出 + 栈B后进先出 = 队列先进先出。\n\n关键点\n\n- 入队时入栈A，出队时出栈B(当栈B非空时直接出栈，否则将栈A的所有元素压到栈B再进行出栈)\n- `front`元素的处理：若栈B非空，即为栈B的栈顶，否则为当栈A为空时的第一个入栈元素\n\n### 实现(python)\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.front = 0\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if len(self.s1) == 0:\n            self.front = x\n        self.s1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if len(self.s2) == 0:\n            while len(self.s1) != 0:\n                self.s2.append(self.s1.pop())\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if len(self.s2) != 0:\n            return self.s2[-1]\n        return self.front\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.s1) == 0 and len(self.s2) == 0\n```\n\n### 复杂度分析\n\n1. 时间复杂度：push(): $O(1)$，pop(): 摊还时间复杂度$O(1)$，其余$O(1)$。\n2. 空间复杂度：push(): $O(n)$，其余$O(1)$。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920945591","body":"### 思路\n\n先遍历一遍得到链表长度`n`。由于`k`可能大于`n`，所以向右移动`k`次等同于向右移动`k % n`，根据规律可知需要将第`n - k % n`个结点作为新的链表的尾部，第`n - k % n + 1`个结点作为新链表的头部，且原来的链表的尾部与头部相接。\n\n  关键点：\n\n- 链表长度`n <= 1`时不论`k`为何值其结果与原链表相同\n- `k == 0`、`k % n == 0 `时其结果与原链表相同\n- 其他情况下原链表的尾始终会指向原链表的头，故在第一次遍历链表后，可将尾指向头，再从头结点遍历到第`n - 1 - k % n`个结点处(头结点作为第0个结点)，将该结点指向空，返回该结点指向空之前的下一个结点，即打破环结构。\n\n### 实现(python)\n\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or not head or not head.next:\n            return head\n\n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n\n        k %= n\n        if k == 0:\n            return head\n\n        cur.next = head\n        cur = head\n        i = 0\n        while i != n - 1 - k:\n            cur = cur.next\n            i += 1\n        ret = cur.next\n        cur.next = None\n        return ret\n```\n\n### 复杂度分析\n\n1. 时间复杂度：$O(n)$。最多需要遍历两遍链表。\n2. 空间复杂度：$O(1)$。只需要常数级空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921885596","body":"### 思路\n\n遍历链表，每两个结点进行交换。\n\n关键点：\n\n- 创建哑结点`dummyHead`，令`dummyHead.next = head`，将头结点作为普通结点进行处理。\n- 令`temp`表示当前结点，在`temp.next`、`temp.next.next`均非空时进行结点交换。\n- 原顺序：`temp -> node1 -> node2`。更改顺序：`temp -> node2`、`node1 -> node2.next`、`node2 -> node1`、`temp = node1`。\n\n### 实现(python)\n\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummyHead = ListNode(0)\n        dummyHead.next = head\n        temp = dummyHead\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n        return dummyHead.next\n```\n\n### 复杂度分析\n\n1. 时间复杂度：$O(n)$。需遍历一遍链表。\n2. 空间复杂度：$O(1)$。只使用了常数级空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922330180","body":"### 思路\n\n**构造出的二叉搜索树的中序遍历结果就是原链表**。中序遍历的顺序是：左子树 - 根节点 - 右子树。取`mid = (left + right + 1) // 2`，`mid`为根节点，其左子树为`[left, mid - 1]`，右子树为`[mid + 1, right]`。通过递归函数`buildTree(left, right)`按照中序遍历的顺序构造二叉搜索树。\n\n关键点：\n\n- 当`left > right`时，表示由`[left, right]`构成的范围无节点\n- 当`left == right`时，表示有一个节点\n- 根据**构造出的二叉搜索树的中序遍历结果就是原链表**的原则填充每次递归函数中根节点的值\n\n### 实现(python)\n\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getLength(head: ListNode) -> int:\n            ret = 0\n            while head:\n                ret += 1\n                head = head.next\n            return ret\n\n        def buildTree(left: int, right: int) -> TreeNode:\n            if left > right:\n                return None\n            mid = (left + right + 1) // 2\n            root = TreeNode()\n            root.left = buildTree(left, mid - 1)\n            nonlocal head\n            root.val = head.val\n            head = head.next\n            root.right = buildTree(mid + 1, right)\n            return root\n\n        return buildTree(0, getLength(head) - 1)\n```\n\n### 复杂度分析\n\n1. 时间复杂度：$O(n)$。\n2. 空间复杂度：$O(logn)$。为递归过程中栈的最大深度，即为平衡二叉树的高度$O(logn)$。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922485766","body":"### 思路\n\n双指针法。链表`A`、`B`的长度分别为`a`、`b`，设其共有节点长度为`c`。指针`pa`先遍历完链表`A`再从链表`B`开始遍历到交点共走了`a + (b - c)`步；指针`pb`先遍历完链表`B`再从链表A开始遍历到交点共走了`b + (a - c)`步。据此原理，两指针同时开始遍历，若`pa`、`pb`均指向`None`，表示两个链表无交点，若`pa`、`pb`均指向同一个节点，表示该节点即为交点。\n\n关键点：\n\n- 当其中一个链表为空链表时，返回`None`\n\n### 实现(python)\n\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return None\n        pa, pb = headA, headB\n        while pa != pb:\n            pa = pa.next if pa else headB\n            pb = pb.next if pb else headA\n        return pa\n```\n\n### 复杂度分析\n\n1. 时间复杂度：$O(m+n)$。最多遍历一次两个链表。\n2. 空间复杂度：$O(1)$。只使用了常数级空间。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kendj-staff":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916907412","body":"```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int index = num.length - 1;\r\n        int carry = 0;\r\n        while (k != 0 || index >= 0) {\r\n            int knum = k % 10;\r\n            k = k / 10;\r\n\r\n            int numTemp = index < 0 ? 0 : num[index];\r\n            int temp =  knum + numTemp + carry;\r\n\r\n            res.add(temp % 10);\r\n            carry = temp >= 10 ? 1 : 0;\r\n            index --;\r\n        }\r\n        if (carry == 1) {\r\n            res.add(carry);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917364656","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int prev = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            res[i] = i - prev;\n        }\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            res[i] = Math.min(prev - i, res[i]);\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917917172","body":"\r\n思路 数组模拟，原本还傻用Linkedlist 常复习常新\r\n```java\r\nclass CustomStack {\r\n    int maxLen;\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        top = -1;\r\n        maxLen = maxSize;\r\n        stack = new int[maxSize];\r\n    }\r\n    public void push(int x) {\r\n        if (top < maxLen - 1) {\r\n            stack[++top] = x;\r\n        }\r\n        \r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        if (top >= 0) {\r\n            return stack[top--];\r\n        } \r\n        return top;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if (top == -1) {return;}\r\n        k = Math.min(k, stack.length);\r\n        for (int i = 0; i < k; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918194074","body":"```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        //Deque<String> letterStack = new LinkedList<String>();\r\n        //Deque<String> numStack = new LinkedList<Integer>();\r\n        Deque<String> stack = new LinkedList<String>();\r\n\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (']' != s.charAt(i)) {\r\n                stack.push(String.valueOf(s.charAt(i)));\r\n            } else {\r\n                StringBuffer letterSb = new StringBuffer();\r\n                while (Character.isLetter(stack.peek().charAt(0)) && stack.peek().charAt(0) != '[') {\r\n                    letterSb.insert(0,stack.pop());\r\n                }\r\n                stack.pop();\r\n\r\n                StringBuffer numSb = new StringBuffer();\r\n                while ( !stack.isEmpty() && Character.isDigit(stack.peek().charAt(0))) {\r\n                    numSb.insert(0,stack.pop());\r\n                }\r\n\r\n                int count = Integer.parseInt(numSb.toString());\r\n                StringBuffer sb = new StringBuffer();\r\n                while (count > 0) {\r\n                    sb.append(letterSb.toString());\r\n                    count--;\r\n                }\r\n                \r\n                stack.push(sb.toString());\r\n            }\r\n        }\r\n        StringBuffer resbuff = new StringBuffer();\r\n        for(String str : stack) {\r\n            resbuff.insert(0,str);\r\n        }\r\n        return resbuff.toString();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919275465","body":"思路 双栈\r\n```java\r\nclass MyQueue {\r\n    Deque<Integer> instack;\r\n    Deque<Integer> outstack;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        instack = new LinkedList<Integer>();\r\n        outstack = new LinkedList<Integer>(); \r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        instack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (!outstack.isEmpty()) {\r\n            return outstack.pop();\r\n        }\r\n        while(!instack.isEmpty()) {\r\n            outstack.push(instack.pop());\r\n        }\r\n        return outstack.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (outstack.isEmpty()) {\r\n            while (!instack.isEmpty()) {\r\n                outstack.push(instack.pop());\r\n            }\r\n        }\r\n        return outstack.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        if (outstack.isEmpty() && instack.isEmpty()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920148204","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> stack = new LinkedList<Integer>();\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (stack.size() == 0 || arr[i] >= stack.peek()) {\r\n                stack.push(arr[i]);\r\n            } else if (arr[i] < stack.peek()) {\r\n                int head = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(head);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920999162","body":"`\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null) {return head;}\r\n        ListNode cur = head;\r\n        int len = 0;\r\n        while (cur != null) {\r\n            cur = cur.next;\r\n            len++;\r\n        }\r\n        k = k % len;\r\n        \r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n\r\n        // for (int i = 0; i < k; i++) {\r\n        //     fast = fast.next;\r\n        // }\r\n        while (fast.next != null) {\r\n            if (k -- <= 0) {\r\n                slow = slow.next; //找的是尾节点即旋转n个节点后链表的末尾节点\r\n            }\r\n            fast = fast.next;\r\n            // slow = slow.next;\r\n        }\r\n        fast.next = head;\r\n        head = slow.next;\r\n        slow.next = null;\r\n\r\n        return head;\r\n\r\n    }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921906725","body":"\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null) {return head;}\n        int index = 0;\n        ListNode newHead = new ListNode();\n        newHead.next = head;\n        ListNode cur = newHead;\n        while (cur.next != null && cur.next.next != null) {\n            ListNode temp = cur.next.next;\n            cur.next.next = temp.next;\n            temp.next = cur.next;\n            cur.next = temp;\n            cur = cur.next.next;\n        }\n\n        return newHead.next;\n    }\n}\n           ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922328941","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return toBST(head, null);\n\n    }\n    public TreeNode toBST(ListNode start, ListNode end) {\n        if (start == end) {\n            return null;\n        }\n        ListNode mid = findMid(start, end);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = toBST(start, mid);\n        root.right = toBST(mid.next, end);\n        return root;\n    }\n    public ListNode findMid(ListNode start, ListNode end) {\n        ListNode fast = null;\n        ListNode slow = start;\n        if (start.next != end && start.next.next != end) {\n            fast = start.next.next;\n        } else {\n            fast = start;\n        }\n        while (fast.next != end) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922409730","body":"```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode A = headA;\n        ListNode B = headB;\n        while (A != B) {\n            A = A == null ? headB : A.next;\n            B = B == null ? headA : B.next;\n        }\n        return A;\n    }\n}\n```\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Joyce94":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916909438","body":"###思路\r\n从后往前，逐个相加\r\n\r\n###代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        # num比k长\r\n        # num比k短\r\n        carry = 0\r\n        for i in range(n - 1, -1, -1):\r\n            cur = num[i] + carry + k % 10\r\n            num[i], carry = cur % 10, cur // 10 \r\n            k = k // 10 \r\n        \r\n        # k += carry\r\n        while k != 0 or carry != 0:\r\n            cur = carry + k % 10\r\n            num.insert(0, cur % 10)\r\n            carry = cur // 10 \r\n            k = k // 10 \r\n        return num \r\n```\r\n\r\n###复杂度\r\n时间复杂度 o(min(n,m))\r\n空间复杂度 o(1))","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917779924","body":"#####思路\n两个栈，一个字母栈，一个数字栈\n左括号开始就进入字母栈，右括号就开始出栈(出栈生成的结果要重新入字母栈)，括号也要进栈，标志边界\n        # a：3 2          -> a：3         -> a：\n        # b：[ a [ c ]    -> b：[ a c c ] -> b：a c c a c c a c c\n        # res: a c c a c c a c c\n        # a：3       -> a：2              -> a：\n        # b：[ a ]   -> b：a a a [ b c ]  -> b：a a a b c b c \n        # res:\n\n#####代码\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        '''\n        case: \"100[leetcode]\"\n        '''\n        stack_num = []\n        stack_alpha = []\n        flag = False \n        for i in range(len(s)):\n            cur = s[i]\n            if cur.isdigit():\n                if flag is False:\n                    stack_num.append(int(cur))\n                else:\n                    pre = int(stack_num.pop())\n                    num = pre * 10 + int(cur) \n                    stack_num.append(num)\n                flag = True\n            elif cur == ']':\n                flag = False\n                word = ''\n                while len(stack_alpha) > 0:\n                    tmp = stack_alpha.pop()\n                    if tmp == '[':\n                        break\n                    word += tmp\n                # 逆序退出栈\n                count = int(stack_num.pop())\n                while count > 0:\n                    # for ele in word:\n                    for j in range(len(word) - 1, -1, -1):\n                        stack_alpha.append(word[j])\n                    count -= 1 \n            else:\n                flag = False\n                stack_alpha.append(cur)\n        if len(stack_num) != 0:\n            return ''    \n        return ''.join(stack_alpha)\n```\n\n#####复杂度\n时间复杂度：o(n)\n空间复杂度：o(n)\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922468454","body":"## 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if headA is None or headB is None:\n            return None \n        lenA, lenB = 0, 0 \n        pNode = headA\n        while pNode != None:\n            lenA += 1 \n            pNode = pNode.next \n        pNode = headB\n        while pNode != None:\n            lenB += 1 \n            pNode = pNode.next\n        \n        # diff = abs(lenA - lenB)\n        diff = 0 \n        p1, p2 = headA, headB\n        if lenA > lenB:\n            diff = lenA - lenB\n            while diff:\n                p1 = p1.next\n                diff -= 1 \n        else:\n            diff = lenB - lenA\n            while diff:\n                p2 = p2.next\n                diff -= 1 \n        \n        while p1 != p2:\n            p1 = p1.next\n            p2 = p2.next\n        return p1 \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asterqian":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916909443","body":"### 思路\r\n两数相加从个位开始，自然想到从后往前遍历数组并且也从k的个位开始向前加，唯一要考虑的是进位问题，包括99+1=100这样的edge case。\r\n### 题解\r\n```C++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    vector<int> res;\r\n    int i = num.size() - 1;\r\n    int sum = 0;\r\n    int carry = 0;\r\n    while (i >= 0 || k != 0) {\r\n        int x = i < 0 ? 0 : num[i];\r\n        int y = k % 10;\r\n        sum = x + y + carry;\r\n        carry = sum / 10;\r\n        sum %= 10;\r\n        res.push_back(sum);\r\n        k /= 10;\r\n        --i;\r\n    }\r\n    if (carry != 0) { res.push_back(1); }\r\n    // faster than using insert in front every time\r\n    reverse(res.begin(), res.end());\r\n    return res;\r\n}   \r\n```\r\n### 复杂度分析\r\n###### 时间复杂度：O(max(N, K))，N为数组长度，K为k的长度（注：reverse的时间复杂度也为O(max(N, K))）\r\n###### 空间复杂度：O(max(N, K))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917349012","body":"### 思路\n计算relative distance类型，第一反应是用dp来储存。这道题由于c可能在左右两边，因此需要遍历两边才能得到shortest path。\n### 题解\n```C++\nvector<int> shortestToChar(string s, char c) {\n    vector<int> memo(s.size(), 0);\n    int prev = INT_MIN/2;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == c) {\n            // mark the pos of c last seen\n            prev = i;\n        } else {\n            // loop from i == 0, thus if c is seen, prev must be smaller than i\n            // if is not seen, i - INT_MIN will become a large positive number\n            memo[i] = i - prev; \n        }\n    }\n    int prev = INT_MAX/2;\n    for (int i = s.size() - 1; i >= 0; --i) {\n        if (s[i] == c) {\n            prev = i;\n        } else {\n            // loop from right to left, either curr is the best solution \n            // or a closer pos of c occurred after i, then prev - i is positive\n            // if not, prev - i would be a large positive number(thats why prev is updated as INT_MAX/2)\n            memo[i] = min(memo[i], prev - i);\n        }\n    }\n    return memo;\n}   \n```\n### 复杂度分析\n###### 时间复杂度：O(2N)，N为数组长度\n###### 空间复杂度：O(N)，因为是一维的数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917567240","body":"### 思路\nUsing underlying array structure\n### 题解\n```C++\npublic:\n    int max = 0;\n    vector<int> arr;\n    CustomStack(int maxSize) {\n       max = maxSize;\n       arr.reserve(max);\n    }\n    \n    void push(int x) {\n        if (arr.size() == max) return;\n        arr.push_back(x);    \n    }\n    \n    int pop() {\n        if (arr.size() == 0) return -1;\n        int last = arr.back();\n        arr.pop_back();\n        return last;\n    }\n    \n    void increment(int k, int val) {\n        /*for (int i = 0; i < min(k, arr.size()); ++i) {\n            arr[i] += val;\n        }*/\n        int size = arr.size() < k ? arr.size() : k;\n        for (int i = 0; i < size; ++i) {\n            arr[i] += val;\n        }\n    }\n```\n### 复杂度分析\n###### 时间复杂度：O(1) for push and pop，O(min(k, arr.size()) for increment\n###### 空间复杂度：O(N)，用了array来模拟stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918022962","body":"## 思路\n看到有括号的操作首先想起栈\n## 代码\n~~~C++\nstring decodeString(string s) {\n    stack <int> nums;\n    stack <string> str;\n    int num = 0;\n    string res = \"\";\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] >= '0' && s[i] <= '9') {\n            num = num * 10 + s[i] - '0';\n        } else if (s[i] == '[') {\n            nums.push(num);\n            num = 0;\n            str.push(res);\n            res = \"\";\n        } else if (s[i] == ']') {\n            int time = nums.top();\n            nums.pop();\n            for(int j = 0; j < time; ++j) {\n                str.top() += res;\n            }\n            res = str.top();\n            str.pop();\n        } else {\n            res += s[i];\n        }\n    }\n    return res;\n}\n~~~\n## 复杂度分析\n###### 时间复杂度: O(N) 遍历一次，N为s的长度, worst case O(N^2)\n\n###### 空间复杂度: O(2N) 两个stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918855595","body":"## 思路\n通过两个栈互相交换数据，利用FILO的规则实现队列\n## 代码\n~~~C++\nclass MyQueue {\npublic:\n    stack <int> sIn;\n    stack <int> sOut;\n    /** Initialize your data structure here. */\n    MyQueue() {\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        sIn.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if (sOut.empty()) {\n            while (!sIn.empty()) {\n                sOut.push(sIn.top());\n                sIn.pop();\n            }\n        }\n        int num = sOut.top();\n        sOut.pop();\n        return num;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n         if (sOut.empty()) {\n            while (!sIn.empty()) {\n                sOut.push(sIn.top());\n                sIn.pop();\n            }\n        }\n        return sOut.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return sIn.empty() && sOut.empty();\n    }\n};\n~~~\n## 复杂度分析\n###### 时间复杂度: push() & empty(): O(1),pop() & peek(): amortized O(1)\n\n###### 空间复杂度: O(N) 两个stack，总data量为N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919827276","body":"## 思路\n看到chunks合并想到单调栈操作，根据题意本题是单调递减栈\n## 代码\n~~~C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> s;\n        for (int i = 0; i < arr.size(); ++i) {\n            if (!s.empty() && s.top() > arr[i]) {\n                int temp = s.top();\n                s.pop();\n                while(!s.empty() && s.top() > arr[i]) {\n                    s.pop();\n                }\n                s.push(temp);\n            } else {\n                s.push(arr[i]);\n            }\n        }\n        return s.size();\n    }\n};\n~~~\n## 复杂度分析\n###### 时间复杂度: worst case: O(2N), 倒序排列的arrp push一次pop一次\n\n###### 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920696013","body":"## 思路\nrotate linked list需要做很多->next設置，所以想到用閉合鏈表\n## 代码\n~~~C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == nullptr || head->next == nullptr) return head;\n        ListNode* temp = head;\n        int n = 1;\n        while (temp->next) {\n            temp = temp->next;\n            ++n;\n        }\n        int rotate = n - k % n;\n        if (rotate == n) return head;\n        temp->next = head;\n        while (rotate--) {\n            temp = temp->next;\n        }\n        ListNode* res = temp->next;\n        temp->next = nullptr;\n        return res;\n    }\n};\n~~~\n## 复杂度分析\n###### 时间复杂度: O(N)\n\n###### 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921418596","body":"## 思路\n因爲第一個listnode會變，所以要引入一個dummy node來遍歷\n## 代码\n~~~C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) return head;\n        // creat dummy node\n        ListNode* preHead = new ListNode();\n        preHead->next = head;\n        ListNode* temp = preHead;\n        while (temp->next && temp->next->next) {\n            ListNode* curr = temp->next;\n            ListNode* next = temp->next->next;\n            temp->next = next;\n            curr->next = next->next;\n            next->next = curr;\n            // temp update to the last swapped listnode\n            temp = curr;\n        }\n        return preHead->next;\n    }\n};\n~~~\n## 复杂度分析\n###### 时间复杂度: O(N)\n\n###### 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922187005","body":"## 思路\r\n因为是有序链表和bst，联想到bst中序遍历的特性就是sorted。引入快慢指针来找到链表的中间值作为root\r\n## 代码\r\n~~~C++\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n       if (!head) return nullptr;\r\n       if (!head->next) return new TreeNode(head->val);\r\n       ListNode* l = head;\r\n       ListNode* r = head;\r\n       ListNode* pre = nullptr;\r\n       while (r && r->next) {\r\n           pre = l;\r\n           l = l->next;\r\n           r = r->next->next;\r\n       }\r\n       // used to distinguish the left-half and right-half of the linkelist\r\n       pre->next = nullptr;\r\n       TreeNode* root = new TreeNode(l->val);\r\n       root->left = sortedListToBST(head);\r\n       root->right = sortedListToBST(l->next);\r\n       return root;\r\n    }\r\n};\r\n~~~\r\n## 复杂度分析\r\n###### 时间复杂度: O(NlogN）遍历链表寻找中间值为N，总共logN次recursion\r\n\r\n###### 空间复杂度: O(logN) non-tail recursive, recursion所用的stack为平衡二叉树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922450597","body":"## 思路\nhashset寻找重复结点\n## 代码\n~~~C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* temp = headA;\n        unordered_set<ListNode*> visited;\n        while (temp) {\n            visited.insert(temp);\n            temp = temp->next;\n        }\n        temp = headB;\n        while (temp) {\n            if (visited.count(temp)) {\n                return temp;\n            }\n            temp = temp->next;\n        }\n        return nullptr;\n    }\n};\n~~~\n## 复杂度分析\n###### 时间复杂度: O(N+M)，N为链表A长度，M为链表B长度\n\n###### 空间复杂度: O(N)，N为链表A长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmstart":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916910988","body":"```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n​    List<Integer> res = new ArrayList<>();\n​    for(int i = num.length-1;i >= 0|| k >0;i--,k/=10){\n​      if(i>=0){\n​        k+=num[i];\n​      }\n​      res.add(k%10);\n​    }\n​    Collections.reverse(res);\n​    return res;\n  }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Tomtao626":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916911109","body":"## 思路\r\n> + 将整个加数 kk 加入数组表示的数的最低位\r\n## 代码\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n## 复杂度分析\r\n> + 时间: O(max(n,logk))，其中 nn 为数组的长度。\r\n> + 空间: O(1)。除了返回值以外，使用的空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917414568","body":"## 思路\r\n> + 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n## 代码\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```\r\n## 复杂度\r\n> + 时间:O(N)\r\n> + 空间:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917647271","body":"## 思路\r\n> + 使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.stk[self.top] + self.add[self.top]\r\n        if self.top != 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return ret\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k - 1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n```\r\n## 复杂度\r\n> + 时间:  O(1)\r\n> + 空间: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918265095","body":"## 思路\r\n> + 递归\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def dfs(s, i):\r\n            res, multi = \"\", 0\r\n            while i < len(s):\r\n                if '0' <= s[i] <= '9':\r\n                    multi = multi * 10 + int(s[i])\r\n                elif s[i] == '[':\r\n                    i, tmp = dfs(s, i + 1)\r\n                    res += multi * tmp\r\n                    multi = 0\r\n                elif s[i] == ']':\r\n                    return i, res\r\n                else:\r\n                    res += s[i]\r\n                i += 1\r\n            return res\r\n        return dfs(s,0)\r\n```\r\n## 复杂度\r\n> + 空间: O(N)\r\n> + 时间: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919250519","body":"## 思路\r\n> + 设两个栈分别为 a, b，我们 使用 a 的栈顶模拟队尾，使用 b 的栈顶模拟队头\r\n## 代码\r\n```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.a = []\r\n        self.b = []\r\n    def push(self, x: int) -> None:\r\n        while self.b:\r\n            self.a.append(self.b.pop())\r\n        self.a.append(x)\r\n        while self.a:\r\n            self.b.append(self.a.pop())\r\n    def pop(self) -> int:\r\n        return self.b.pop()\r\n    def peek(self) -> int:\r\n        return self.b[-1] \r\n    def empty(self) -> bool:\r\n        return len(self.b) == 0\r\n```\r\n## 复杂度\r\n> + 时间: O(1)\r\n> + 空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920038576","body":"## 思路\r\n> + 前缀和-直接比较前缀和数组中相等元素的个数即可\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        cnt = 0\r\n        nums = sorted(arr, reverse=False)\r\n        for i in range(len(arr)):\r\n            nums[i] += nums[i-1] if i > 0 else 0\r\n            arr[i] += arr[i-1] if i > 0 else 0\r\n            cnt += 1 if arr[i] == nums[i] else 0\r\n        return cnt\r\n```\r\n## 复杂度\r\n+ > 时间: O(N)\r\n+ > 空间: O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921855681","body":"## 思路\r\n> + 递归\r\n## 代码\r\n```python\r\nclass Solution(object):\r\n\tdef swapPairs(self, head):\r\n\t      if not (head and head.next):\r\n\t           return head\r\n\t      p = ListNode(-1)\r\n\t      cur,head,stack = head,p,[]\r\n\t      while cur and cur.next:\r\n\t\t     _,_ = stack.append(cur),stack.append(cur.next)\r\n\t\t     cur = cur.next.next\r\n\t\t     p.next = stack.pop()\r\n\t\t     p.next.next = stack.pop()\r\n\t\t     p = p.next.next\r\n\t       if cur:\r\n\t\t    p.next = cur\r\n\t       else:\r\n\t\t    p.next = None\r\n\t       return head.next\r\n```\r\n## 复杂度\r\n> + 时间: O(1)\r\n> + 空间: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lizzy-123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916911369","body":"思路：\n     1. 将数组 reverse 以下，这样从0开始低位数\n      2. 将数字求出数组形式--这时得到数组应该是从低位数到高位数\n     3. 将上面两个数组相同索引数字相加，这个相加的就是从低位到高位，如果相加数大于10，将数据减10.\n    4. 将得到数据reverse。\n代码：\n\tvector<int> addToArrayForm(vector<int>& num, int k) {\n\t\tvector<int> result;\n\t\tint n = num.size();\n\t\treverse(num.begin(), num.end());\n\t\tfor (int i = 0; i <n; ++i) {\n\t\t\tint sum = num[i] + k % 10;\n\t\t\tk /= 10;\n\t\t\tif (sum >= 10) {\n\t\t\t\tk++;\n\t\t\t\tsum -= 10;\n\t\t\t}\n\t\t\tresult.push_back(sum);\n\t\t}\n\t\tfor (; k > 0; k /= 10) {\n\t\t\tresult.push_back(k % 10);\n\t\t}\n\t\treverse(result.begin(), result.end());\n\t\treturn result;\n\t}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917409029","body":"vector<int> shortestToChar(string s, char c) {\r\n    int n = s.size();\r\n    std::vector<int> results(n,0);\r\n   // std::vector<int> tmp;\r\n   int last = 1e4;\r\n   int lastIndex = 0;\r\n    for(int i=0;i<n;++i)\r\n    {\r\n        if(s[i]==c)\r\n        {\r\n             for(int j = i;j>=lastIndex;--j)\r\n               {\r\n                  int dis = min(i-j,abs(last-j));\r\n                  results[j] = dis; \r\n                 \r\n                  \r\n               } \r\n                last = i;\r\n               lastIndex= i;         \r\n        }\r\n    }\r\n   \tif (lastIndex<n)//还有部分在指定字符右边\r\n\t\t{\r\n\t\t\tfor (int j = lastIndex + 1; j < n;j++)\r\n\t\t\t{\r\n\t\t\t\tresults[j] = j - lastIndex;\r\n\t\t\t}\r\n\t\t}\r\n  return results;\r\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917608406","body":"时间复杂度：push,top,初始化，O(1)，inc复杂度O(maxSize);\r\n空间复杂度：因为需要一个辅助空间，所以复杂度O(maxSize)\r\n\r\n`void push(int x) {\r\n if(maxM!=nums.size()-1)\r\n {\r\n     maxM++;\r\n    nums[maxM] = x;\r\n }\r\n    \r\n}\r\n\r\nint pop() {\r\nif(maxM==-1)return -1;\r\n    maxM--;\r\n    return nums[maxM+1];\r\n}\r\n\r\nvoid increment(int k, int val) {\r\n    \r\n    int minX = min(k,maxM+1);\r\n    for(int i=0;i<minX;++i)\r\n    {\r\n        nums[i]+=val;\r\n    }\r\n}\r\n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918302665","body":"思路：使用栈将带有数字的转为为字符串\r\n`string decodeString(string s) {\r\n\t\tint n = s.size();\r\n\t\tvector<string> stk;\r\n\r\n\t\tfor (int i = 0; i<n; i++)\r\n\t\t{\r\n\t\t\tchar c = s[i];\r\n\t\t\tif (c == ']')\r\n\t\t\t{\r\n\t\t\t\tvector<string> subStr;\r\n\t\t\t\twhile (stk.back() != \"[\")\r\n\t\t\t\t{\r\n\t\t\t\t\tsubStr.push_back(stk.back());\r\n\t\t\t\t\tstk.pop_back();\r\n\t\t\t\t}\r\n\t\t\t\tstk.pop_back();\r\n\t\t\t\tstring strNum = \"\";\r\n\t\t\t\twhile (stk.size()>0&&stk.back()<=\"9\"&&stk.back()>=\"0\")\r\n\t\t\t\t{\r\n\t\t\t\t\tstrNum = strNum+stk.back();\r\n\t\t\t\t\tstk.pop_back();\r\n\t\t\t\t}\r\n\t\t\t\treverse(strNum.begin(), strNum.end());\r\n\t\t\t\tint k = stoi(strNum);\r\n\t\t\t\t//stk.pop_back();\r\n\t\t\t\treverse(subStr.begin(), subStr.end());\r\n\t\t\t\tstring tmp = \"\";\r\n\t\t\t\tfor (int j = 0; j<subStr.size(); j++)\r\n\t\t\t\t{\r\n\t\t\t\t\ttmp += subStr.at(j);\r\n\t\t\t\t}\r\n\t\t\t\tstring tmp1 = \"\";\r\n\t\t\t\twhile (k--)\r\n\t\t\t\t{\r\n\t\t\t\t\ttmp1 = tmp1 + tmp;\r\n\t\t\t\t}\r\n\t\t\t\tstk.push_back(tmp1);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstk.push_back(string(1,c));\r\n\t\t\t}\r\n\t\t}\r\n\t\tstring result = \"\";\r\n\t\tfor (int m = 0; m<stk.size(); m++)\r\n\t\t{\r\n\t\t\tresult += stk.at(m);\r\n\t\t}\r\n\t\treturn result;\r\n\t}`\r\n\r\n时间复杂度：O(n);\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919082246","body":"因为队列是先进县出，而栈是后进先出，所以使用2个栈，一个用于进栈一个用于出栈，顺序刚好和对列一致，所以在pop()和peek()时，需要检测下出栈中是否有内容，若有，就出栈\r\n\r\n`class MyQueue {\r\n\r\nprivate:\r\n\tstack<int> st1;\r\n\tstack<int> st2;\r\npublic:\r\n\t/** Initialize your data structure here. */\r\n\tMyQueue() {\r\n\t\t\r\n\t}\r\n\r\n\t/** Push element x to the back of queue. */\r\n\tvoid push(int x) {\r\n\t\tst1.push(x);\r\n\t}\r\n\r\n\t/** Removes the element from in front of queue and returns that element. */\r\n\tint pop() {\r\n\t  \r\n\t   if (st2.empty())\r\n\t   {\r\n\t\t   while (!st1.empty())\r\n\t\t   {\r\n\t\t\t   st2.push(st1.top());\r\n\t\t\t   st1.pop();\r\n\t\t   }\r\n\t    }\r\n\t   int result = st2.top();\r\n\r\n\t   st2.pop();\r\n\t  return result;\r\n\t  \r\n\t}\r\n\r\n\t/** Get the front element. */\r\n\tint peek() {\r\n\t\tint result = pop();\r\n\t\tst2.push(result);\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/** Returns whether the queue is empty. */\r\n\tbool empty() {\t  //需要保证2个占中元素都为空\r\n\t\t\tif (st1.empty()&&st2.empty())\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t}\r\n};`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919988563","body":"思路：如果当前值大于栈顶元素，直接压入栈中，如果当前元素小于栈元素，直接跟栈顶元素比较\r\n\t弹出比当前元素大的值，然后将最大值继续放入栈中，最后返回的是栈大小\r\n\r\n`\tint maxChunksToSorted(vector<int>& arr) {\r\n\t\tstack<int>maxStk;\r\n\t\tmaxStk.push(arr[0]);\r\n\t\tint n = arr.size();\r\n\t\tfor (int i = 1; i < n;i++)\r\n\t\t{\r\n\t\t   if (arr[i]>=maxStk.top())\r\n\t\t   {\r\n\t\t\t   maxStk.push(arr[i]);\r\n\t\t   }\r\n\t\t   else\r\n\t\t   {\r\n\t\t\t   int currMax = maxStk.top();\t maxStk.pop();\r\n\t\t\t   while (!maxStk.empty())\r\n\t\t\t   {\r\n\t\t\t\t   int currMax = maxStk.top();\t\r\n\t\t\t\t   if (currMax>arr[i])\r\n\t\t\t\t   {\r\n\t\t\t\t\t   maxStk.pop();\r\n\t\t\t\t   }\r\n\t\t\t\t   else\r\n\t\t\t\t   {\r\n\t\t\t\t\t   break;\r\n\t\t\t\t   }\r\n\t\t\t   }\r\n\t\t\t   maxStk.push(currMax);\r\n\t\t   }\r\n\t\t}\r\n\t\t\r\n\t\treturn maxStk.size();\r\n\t}`\r\n\r\n时间复杂度和空间复杂度都是O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920960440","body":"主要是找到移动k位置后的节点，然后作为头指针，前面的那个节点next为空，最后一个指针指向头节点\r\n`  ListNode* rotateRight(ListNode* head, int k) {\r\n   if(head==nullptr||k==0||head->next==nullptr)\r\n   {\r\n      return head;\r\n   }\r\n   ListNode * node = head;\r\n   int n = 0;\r\n   while(node!=nullptr)\r\n   {\r\n      node = node->next;\r\n      n++;\r\n   }\r\n   k = k%n;\r\n   ListNode * slow = head;\r\n   ListNode * fast = head;\r\n   while(k--)\r\n   {\r\n       fast = fast->next;\r\n   }\r\n\r\n   while(fast->next!=nullptr)\r\n   {\r\n      slow = slow->next;\r\n      fast = fast->next;\r\n   }\r\n   fast->next = head;\r\n   head = slow->next ;\r\n   slow->next = nullptr;\r\n   return head;\r\n\r\n    }`\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921838656","body":"//需要创建呀节点，然后进行两两交换\r\n`  ListNode* swapPairs(ListNode* head) {\r\n     ListNode* pre = new ListNode(0);//建立一个\r\n     pre->next = head;\r\n     ListNode* temp = pre;\r\n \r\n    while(temp->next!=nullptr&&temp->next->next!=nullptr)\r\n    {\r\n         ListNode * start = temp->next;\r\n         ListNode * end   = temp->next->next;\r\n         temp->next = end;\r\n\r\n         start->next = end->next;\r\n         end->next   = start;\r\n         temp = start;\r\n    }\r\n\r\n    return pre->next;\r\n    }`\r\n\r\n时间复杂度：O(n);\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922324849","body":"**思路**\r\n1. 根据快慢指针找到中位数\r\n2. 将中位数作为根节点\r\n3. 递归实现上面过程\r\n\r\n**代码**\r\n\r\n\r\n`\r\n//使用双指针方法得到中位数\r\nListNode* getMid(ListNode* left,ListNode* right)\r\n{\r\n    ListNode *slow = left;\r\n    ListNode *fast = left;\r\n    while(fast!=right&&fast->next!=right)\r\n    {\r\n       slow = slow->next;\r\n       fast = fast->next->next;\r\n    }\r\n    return slow;\r\n}\r\n\r\nTreeNode * buildTree(ListNode* left,ListNode* right)\r\n{\r\n   if(left==right) return nullptr;\r\n\r\n   ListNode *mid = getMid(left,right);\r\n   TreeNode * root = new TreeNode(mid->val);\r\n   root->left = buildTree(left,mid);\r\n   root->right = buildTree(mid->next,right);\r\n   return root;\r\n}\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n    //因为要构造‘平衡二叉树’，所以要查找中位数作为根节点。\r\n        return  buildTree(head,nullptr);\r\n    }\r\n\r\n`\r\n\r\n**复杂度分析**\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922400226","body":"**思路**\r\n1. 使用暴力法，循环2个链表，查找到相同点，但是这种方法到时间过限制。\r\n2. 所以可以将暴力法该为vector存储A链表节点，然后在遍历B节点时，判断下是否存在于vector之中。\r\n3. 快慢指针法。快慢指针大部分用于链表中，可以方便快速得到所需解，例如查找中位数，判断是否链表为环，查找倒数第K个节点。\r\n\r\n**代码**\r\n‘    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n       //上面方法超过时间限制，将上面方法改为哈希表，会减少时间消耗\r\n       //下面采用双指针方法\r\n       ListNode * nodeA  = headA;\r\n       ListNode * nodeB  = headB;\r\n\r\n       if(headA==NULL||headB==NULL) return NULL;\r\n       while(1)\r\n       {\r\n           if(nodeA==nodeB) return nodeB;\r\n           if(nodeA==NULL)nodeA = headB;\r\n           else nodeA = nodeA->next;\r\n           if(nodeB==NULL)nodeB = headA;\r\n           else nodeB = nodeB->next;\r\n       }\r\n    }’\r\n\r\n**复杂度分析**\r\n时间复杂度：O(m+n)\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Poidaze7":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916918813","body":"### 思路\n\n先将列表转换成字符串再转换成数字，与k相加，再转回列表\n\n### 代码\n\n```python\ndef to_list(num):\n        return [int(i) for i in str(num)]\n\ndef to_num(num_list):\n    return int(''.join([str(i) for i in num_list]))\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        l = to_num(num) + k\n        return to_list(l)\n```\n\n### 总结\n\n总觉得不看题解的话，自己思想有点跑偏，希望慢慢转变\n\n### 复杂度分析\n\n- 时间：=。=\n- 空间：好像挺高","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917543417","body":"### 字符的最短距离\n\n\n\n- 链接\n\n  [字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n- 思路\n\n  1. 先遍历出c在s中的位置索引\n  2. 再次遍历计算每个元素到各个c的最短距离\n\n- 代码\n\n  ```python\n  class Solution:\n      def shortestToChar(self, s: str, c: str) -> List[int]:\n          dis =[]\n          loc = [i for i in range(len(s)) if s[i] == c]\n          for i in range(len(s)):\n              dis.append(min([abs(i - l) for l in loc]))\n          return dis\n  ```\n\n  \n\n- 复杂度\n\n  - 时间：$O(N^2)$\n  - 空间：$O(N^2)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917589633","body":"### **设计一个支持增量操作的栈**\n\n\n\n- 链接\n\n  [设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n- 思路\n\n  - 数组模拟栈实现功能\n\n- 代码\n\n  ```python\n  class CustomStack:\n  \n      def __init__(self, maxSize: int):\n          self.__maxSize__ = maxSize\n          self.__arr__ = []\n          self.__len__ = 0\n  \n      def push(self, x: int) -> None:\n          if self.__len__ < self.__maxSize__:\n              self.__arr__.append(x)\n              self.__len__ += 1\n  \n  \n      def pop(self) -> int:\n          if self.__len__ == 0 : return -1\n          else :\n              self.__len__ -= 1\n              return self.__arr__.pop()\n  \n  \n      def increment(self, k: int, val: int) -> None:\n          if self.__len__ < k : self.__arr__ = [i + val for i in self.__arr__]\n          else :\n              for i in range(k):\n                  self.__arr__[i] += val\n  ```\n\n  \n\n- 复杂度\n\n  - 时间：pop、push $O(1)$\tncrement $O(N)$\n  - 空间：$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918314756","body":"### **394. 字符串解码**\n\n\n\n- [**394. 字符串解码**](https://leetcode-cn.com/problems/decode-string/)\n\n- 思路\n\n  自己没有做出来，参考了题解，重点标记\n\n- 代码\n\n  ```python\n  class Solution:\n      def decodeString(self, s: str) -> str:\n          stack = []\n          for i in s:\n              if i == ']':\n                  strs = ''\n                  repeat = ''\n                  while stack[-1] != '[':\n                      strs = stack.pop() + strs\n                  stack.pop()\n                  while stack and stack[-1].isdigit():\n                      repeat = stack.pop() + repeat\n                  stack.append(int(repeat) * strs)\n                  continue\n              stack.append(i)\n          return ''.join(stack)\n  ```\n\n  \n\n- 复杂度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919062794","body":"### **232. 用栈实现队列**\n\n\n\n- [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n- 思路\n\n  利用list实现\n\n- 代码\n\n  ```python\n  class MyQueue:\n  \n      def __init__(self):\n          \"\"\"\n          Initialize your data structure here.\n          \"\"\"\n          self.stack1 = []\n          self.stack2 = []\n  \n  \n      def push(self, x: int) -> None:\n          \"\"\"\n          Push element x to the back of queue.\n          \"\"\"\n          while self.stack2:\n              self.stack1.append(self.stack2.pop())\n          self.stack1.append(x)\n          while self.stack1:\n              self.stack2.append(self.stack1.pop())\n  \n  \n      def pop(self) -> int:\n          \"\"\"\n          Removes the element from in front of queue and returns that element.\n          \"\"\"\n          return self.stack2.pop()\n          \n  \n  \n      def peek(self) -> int:\n          \"\"\"\n          Get the front element.\n          \"\"\"\n          return self.stack2[-1]\n  \n  \n      def empty(self) -> bool:\n          \"\"\"\n          Returns whether the queue is empty.\n          \"\"\"\n          return False if self.stack2 else True\n  ```\n\n  \n\n- 复杂度\n\n  - 时间：$O(1)$\n  - 空间：$O(n)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920088064","body":"### **768. 最多能完成排序的块 II**\n\n\n\n- 链接\n\n  [**768. 最多能完成排序的块 II**](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\n\n- 思路\n\n  参考题解\n\n- 代码\n\n  ```python\n  class Solution:\n      def maxChunksToSorted(self, A: [int]) -> int:\n          stack = []\n          for a in A:\n              # 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\n              # 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\n              if stack and stack[-1] > a:\n                  # 我们需要将融合后的区块的最大值重新放回栈\n                  # 而 stack 是递增的，因此 stack[-1] 是最大的\n                  cur = stack[-1]\n                  # 维持栈的单调递增\n                  while stack and stack[-1] > a: stack.pop()\n                  stack.append(cur)\n              else:\n                  stack.append(a)\n          # 栈存的是块信息，因此栈的大小就是块的数量\n          return len(stack)\n  ```\n\n  \n\n- 复杂度\n\n  - 时间：$O(N)$\n  - 空间：$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920973158","body":"### 61. 旋转链表\n\n\n\n- 链接\n\n  [**61. 旋转链表**](https://leetcode-cn.com/problems/rotate-list/)\n\n- 思路\n\n  参考官方题解\n\n- 代码\n\n  ```python\n  class Solution:\n      def rotateRight(self, head: ListNode, k: int) -> ListNode:\n          # 双指针\n          if head:\n              p1 = head\n              p2 = head\n              count = 1\n              i = 0\n              while i < k:\n                  if p2.next:\n                      count += 1\n                      p2 = p2.next\n                  else:\n                      k = k % count\n                      i = -1\n                      p2 = head\n                  i += 1\n  \n              while p2.next:\n                  p1 = p1.next\n                  p2 = p2.next\n  \n              if p1.next:\n                  tmp = p1.next\n              else:\n                  return head\n              p1.next = None\n              p2.next = head\n              return tmp\n  ```\n\n  \n\n- 复杂度\n\n  - 时间：O(n)\n  - 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921787951","body":"学习官方题解：\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n\n        if not head or not head.next: return head\n        ans = ListNode()\n        ans.next = head.next\n        pre = ans\n        while head and head.next:\n            next = head.next\n            n_next = next.next\n\n            next.next = head\n            pre.next = next\n            head.next = n_next\n            # 更新指针\n            pre = head\n            head = n_next\n        return ans.next\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"edge-wzw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916919493","body":"**思路**\n\n1.自己的思路\n\n逆序遍历数组，每次将位置i的元素与k求和得到新的k，将新k的最低位(k % 10)替换num[i]，同时k移除最低位(k /= 10);\n\n如果k在数组遍历后不为0，例如num=[0], k =100,则将100转换为列表[1,0,0]；\n\n最后将元素存入列表中返回。\n\n**代码**\n\n```java\nclass Day1LC989V0 {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        //逆序遍历数组，每次将位置i的元素与k求和得到新的k，将和的最低位(k % 10)替换num[i]，同时k移除最低位(k /= 10);\n        for (int i = num.length - 1; i >= 0; i--) {\n            k = num[i] + k;\n            num[i] = k % 10;\n            k = k / 10;\n            //如果遍历时k为0,则无需继续求和，直接退出遍历\n            if (k == 0) break;\n        }\n        List<Integer> list = new ArrayList<>();\n        //如果k在遍历后不为0，例如num=[0], k =100,则将100转换为列表[1,0,0]\n        while (k != 0){\n            list.add(k % 10);\n            k /= 10;\n        }\n        //将list的元素逆序存入res列表中\n        for (int i = list.size() - 1; i >= 0; i--) {\n            res.add(list.get(i));\n        }\n        //将求和后的num元素添加到res列表中\n        for (int i : num) {\n            res.add(i);\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917321246","body":"**思路**\n\n1.自己的思路\n\n对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\n\n`idx`记录上一个字符 C 出现的位置，从左向右遍历时初始值为 `s.length() - 1(最坏情况字符在s末尾)` ；从右向左遍历时初始值为 `0(最坏情况字符在s头部)` \n\n从左向右遍历，最短距离为`abs(i - idx)`。\n\n从右向左遍历，最短距离为`abs(i - idx)`。\n\n对比两次遍历的结果，取最小值为最短距离。\n\n**代码**\n\n```java\nclass Day2LC821vV0 {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        char[] strs = s.toCharArray();\n        int idx = s.length() - 1;\n        for (int i = 0; i < strs.length; i++) {\n            if (strs[i] == c){\n                idx = i;\n            }\n            res[i] = Math.abs(i - idx);\n        }\n        idx = 0;\n        for (int i = strs.length - 1; i >= 0; i--) {\n            if (strs[i] == c){\n                idx = i;\n            }\n            res[i] = Math.min(Math.abs(i - idx), res[i]);\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917577021","body":"**思路**\n\n1.自己的思路\n\n数组模拟\n\n**代码**\n\n```java\n/**\n * 数组模拟\n */\nclass CustomStack {\n    int[] arr;\n    int size = 0;\n\n    public CustomStack(int maxSize) {\n        this.arr = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (size < arr.length){\n            arr[size++] = x;\n        }\n    }\n\n    public int pop() {\n        if (size == 0){\n            return -1;\n        }\n        int res = arr[size - 1];\n        size--;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i < Math.min(size, k); i++) {\n            arr[i] += val;\n        }\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：push()、pop()的时间复杂为O(1)，increment()为O(k)；\n- 空间复杂度：O(maxSize)\n\n2.力扣官方题解\n\n我们用一个辅助数组 add 记录每次 inc 操作。具体地，如果 inc 操作是将栈底的 k 个元素（将 k 与栈中元素个数取较小值）增加 val，那么我们将 add[k - 1] 增加 val。这样做的目的在于，只有在 pop 操作时，我们才需要知道栈顶元素的具体值，在其余的情况下，我们只要存储每个元素的增量就行了。\n\n因此在遇到 pop 操作时，我们返回栈顶元素的初始值加上增量 add[top]。在这之后，我们将增量向栈底进行传递，累加至 add[top - 1] 处，这样 inc 操作的时间复杂度也减少至 O(1) 了。\n\n**代码**\n\n```java\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if (top != 0) {\n            add[top - 1] += add[top];\n        }\n        add[top] = 0;\n        --top;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k - 1, top);\n        if (limit >= 0) {\n            add[limit] += val;\n        }\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：所有操作的渐进时间复杂度均为 O(1)\n- 空间复杂度：这里用到了两个长度为 `maxSize` 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917882613","body":"**思路**\n\n1.栈+迭代\n\n构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n当 c 为字母时，在 res 尾部添加 c；\n当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\n记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\n记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n进入到新 [ 后，res 和 multi 重新记录。\n当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\nlast_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\ncur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n返回字符串 res。\n\n**代码**\n\n```java\n/**\n * 栈+迭代\n */\nclass Day4LC394V0 {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for (Character c : s.toCharArray()) {\n            if (c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            } else if (c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for (int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            } else if (c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");    //记录数字\n            else res.append(c); //直接添加字符\n        }\n        return res.toString();\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n2.递归\n\n总体思路与辅助栈法一致，不同点在于将 [ 和 ] 分别作为递归的开启与终止条件：\n\n当 s[i] == ']' 时，返回当前括号内记录的 res 字符串与 ] 的索引 i （更新上层递归指针位置）；\n当 s[i] == '[' 时，开启新一层递归，记录此 [...] 内字符串 tmp 和递归后的最新索引 i，并执行 res + multi * tmp 拼接字符串。\n遍历完毕后返回 res。\n\n**代码**\n\n```java\n/**\n * 递归\n */\nclass Day4LC394V1 {\n    public String decodeString(String s) {\n        return dfs(s, 0)[0];\n    }\n\n    private String[] dfs(String s, int i) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        while (i < s.length()) {\n            if (s.charAt(i) >= '0' && s.charAt(i) <= '9')\n                multi = multi * 10 + Integer.parseInt(String.valueOf(s.charAt(i)));\n            else if (s.charAt(i) == '[') {\n                String[] tmp = dfs(s, i + 1);\n                i = Integer.parseInt(tmp[0]);\n                while (multi > 0) {\n                    res.append(tmp[1]);\n                    multi--;\n                }\n            } else if (s.charAt(i) == ']')\n                return new String[]{String.valueOf(i), res.toString()};\n            else\n                res.append(String.valueOf(s.charAt(i)));\n            i++;\n        }\n        return new String[]{res.toString()};\n    }\n\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922475853","body":"**思路**\n\n1.自己的思路\n\n如果两个链表相交，则遍历时符合下式，其中c为A,B链表的公共部分：\n\nA = a + c\n\nB = b + c\n\nA + B = a + c + b + c = b + c + a + c\n\n如果不相交，则有：\n\nA = a\n\nB = b\n\nA + B = a +b = b + a \n\n因此两次遍历即可找到交点\n\n**代码**\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode nodeA = headA;\n        ListNode nodeB = headB;\n        while (nodeA != nodeB) {\n            nodeA = nodeA == null ? headB: nodeA.next;\n            nodeB = nodeB == null ? headA: nodeB.next;\n        }\n        return nodeA;  \n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"20donkey":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916920617","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n-1; i>=0;--i){\n            int sum = num[i] + k%10;\n            k/=10;\n            if(sum>=10){\n                k++;\n                sum-=10;\n            }\n            res.add(sum);\n        }\n        for(;k>0;k/=10){\n            res.add(k%10);\n        }\n        Collections.reverse(res);\n            return res;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420530","body":"思路\n官方题解\n代码（python）\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(S):\n            if x == C: prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in xrange(len(S) - 1, -1, -1):\n            if S[i] == C: prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kashinggo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916922619","body":"# 思路\r\n模拟题，逐位遍历，一开始用carry保存进位，后面发现要考虑太多，k++更省心。\r\nps. 因为是数组，如果用 add(0, sum)，每次都需要移动N次；链表的 addFirst 或最后 reverse 更优\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n        // 第一天打卡数组 模拟题 \r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum > 9) k++;\r\n            sum %= 10;\r\n            res.add(sum);\r\n        }\r\n\r\n        while (k != 0) {\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        \r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n## 时间复杂度 \r\n*O(max(N, K))*，N 为数组长度，K 为数字 k 的位数\r\n## 空间复杂度 \r\n*O(max(N, K))*，额外的 list 用于返回结果 ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917427920","body":"# 思路\n本来用了中心扩散法，一看别人的思路更好，就是两次遍历，判断左边和右边最近的目标字符，何者距离更小。\n\n# 代码\n```java\nclass Solution {\n    // 第二天打卡 字符串题\n    public int[] shortestToChar(String s, char c) {\n        \n        // 转成 char 数组方便处理\n        char[] ca = s.toCharArray();\n        int len = ca.length;\n        int[] res = new int[len]; \n\n        // 从头到尾 即离该字符较近的 c 在前面\n        // 除以2是因为防止加减溢出 第一次时写懵逼\n        int idx = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (ca[i] == c) {\n                idx = i;\n            }\n            res[i] = i - idx;\n        }\n\n        // 从尾到头 即离该字符较近的 c 在后面\n        idx = Integer.MAX_VALUE / 2;\n        for (int i = len - 1; i >= 0; i--) {\n            if (ca[i] == c) {\n                idx = i;\n            }\n            // 取两者更小的值\n            res[i] = Math.min(res[i], idx - i);\n        }\n\n        return res;\n    }\n}\n```\n\n# 复杂度\n## 时间复杂度 *O(N)* \n遍历两次，N为字符串长度\n## 空间复杂度 *O(N)* \n字符数组和结果数组，长度都为N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662224","body":"# 思路\n有点巧妙，用数组记录要增加的值，出栈时处理。\n\n# 代码\n```java\nclass CustomStack {\n\n    Stack<Integer> stack;\n    int[] arr;\n    int maxSize = -1;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new Stack<>();\n        arr = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (stack.size() < maxSize) {\n            stack.push(x);\n        }\n    }\n    \n    public int pop() {\n        int i = stack.size() - 1;\n        if (i < 0) return -1;\n        if (i > 0) {\n            arr[i - 1] += arr[i];\n        }\n        int res = stack.pop() + arr[i];\n        arr[i] = 0;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if (i >= 0) {\n            arr[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n# 复杂度\n## 时间复杂度\n*O(n)*\n## 空间复杂度\n*O(n)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918333892","body":"# 思路\nMonday Blue，上来占个位先～\n大致思路和表达式求值类似。\nJava 用 StringBuilder 效率较高。\n\n# 代码\nK神\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n\n```\n# 复杂度\n## 时间\n*O(N)* 遍历参数字符串\n## 空间\n*O(N)* StringBuilder 和栈的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919287490","body":"# 思路\n负负得正\n一个栈1作输入，另一个栈2输出\n每次输出栈空时，把输入栈内容全弹出，并放入栈2\n\n# 代码\n```java\nclass MyQueue {\n    Stack<Integer> s1;\n    Stack<Integer> s2;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        s1 = new Stack<>();\n        s2 = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty()) {\n                s2.push(s1.pop());\n            }\n        }   \n        return s2.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty()) {\n                s2.push(s1.pop());\n            }\n        }\n        return s2.peek();\n    }   \n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return s1.isEmpty() && s2.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n# 复杂度\n## 时间\npush  *O(1)* \npop、peek *O(N)*\n## 空间\n*O(N)*","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921907500","body":"# 思路\n递归解决，画图直观。\n\n# 代码\n/**\n ```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode p = head.next;\n        head.next = swapPairs(head.next.next);\n        p.next = head;\n        return p;\n    }\n}\n```\n# 复杂度\n*O(N)* 一次遍历\n*O(N)* 系统递归栈深度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DAXIAdaxia":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916922772","body":"### Java\n\n---\n\n**思路**：\n\n按照加法思路，从个位开始进行加运算，这里直接直接和 k 进行相加，然后取余得到最低位的数值，此值为相加后的结果，如此循环。注意有可能 num 还有剩余，而k已经为0了，这是只需把 num 剩下没运算的数值加到 List 尾部即可，最后对 List 进行反转，即可得到相加后的结果。\n\n\n\n**代码**：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int index = num.length - 1;\n        while(k != 0){\n            int sum = 0;\n            if(index >= 0){\n                sum = k % 10 + num[index];\n                index--;\n            }else{\n                sum = k % 10;\n            }\n            res.add(sum % 10);\n            k = k / 10 + sum / 10;\n        }\n        for(int i = index; i >= 0; i--)\n            res.add(num[i]);\n\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n\n\n**复杂度**：\n\n* **时间复杂度**：O(N)\n* **空间复杂度**：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917399190","body":"### Java\n\n---\n\n**思路**：\n\n1. 使用集合 indexList 记录字符 c 在字符串中的位置\n2. 计算字符串中每个字符距离字符 c 的距离\n   * 若是存在于两个字符 c 的中间，则需要比较距离那边比较近\n\n\n\n**代码**：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        ArrayList<Integer> indexList = new ArrayList<>();\n        for(int i = 0; i < len; i++)\n            if(s.charAt(i) == c)\n                indexList.add(i);\n\n        int[] res = new int[len];\n        int index = 0;\n\n        for(int i = 0; i < len; i++){\n            if(s.charAt(i) != c){\n                if(index > 0){\n                    res[i] = Math.min(Math.abs(i - indexList.get(index)), Math.abs(i - indexList.get(index - 1)));\n                }else{\n                    res[i] = Math.abs(i - indexList.get(index));\n                }\n            }else{\n                res[i] = 0;\n                if(index < indexList.size() - 1)\n                    index++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n* **时间复杂度**：O(N)，其中 N 为字符串的长度\n\n* **空间复杂度**：O(M)，其中 M 为字符串中字符 c 的个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917653444","body":"### Java\n\n---\n\n**思路**：\n\n1. 使用一个长度为 maxSize 的数组来作为栈，变量 curSize 来标识当前已经入栈的长度\n   * 当 curSize >= maxSize ，则说明栈满，元素不能再进栈了\n   * 当 curSize <= 0，说明栈中已经没有元素可以出栈了，直接返回 -1\n   * 给栈底 k 个元素增加 val 值时，当 k < curSize，栈底 k 个元素直接加 val；当 k >= curSize，栈中所有的元素都加上 val 值\n\n\n\n**代码**：\n\n```java\nclass CustomStack {\n\n    int[] stack;\n    int maxSize;\n    int curSize;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        this.maxSize = maxSize;\n        this.curSize = 0;\n    }\n    \n    public void push(int x) {\n        if(curSize >= maxSize) return;\n        stack[curSize++] = x;\n    }\n    \n    public int pop() {\n        if(curSize <= 0) return -1;\n        int popValue = stack[curSize - 1];\n        curSize--;\n        return popValue;\n    }\n    \n    public void increment(int k, int val) {\n        int i = 0;\n        while(i < curSize && i < k){\n            stack[i] += val;\n            i++; \n        }\n    }\n}\n```\n\n\n\n**复杂度**分析：\n\n* **时间复杂度**：入栈和出栈的时间复杂度都是O(1)，给k个栈底元素增加val的时间复杂度为O(k)\n* **空间复杂度**：O(N)，需要使用一个数组来存放元素\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918204445","body":"### Java\n\n---\n\n**思路**：\n\n一般遇到括号类的首先应该想到栈\n\n* 如果遇到数字，则需要把连续的数字进栈\n* 如果遇到 '[' 或 字母则直接进栈\n* 如果遇到 ']' 则需要出栈，直到遇到 ’[‘，’[‘ 前则为需要重写字符串的次数，完成重写之后再次进栈\n\n**代码**：\n\n```java\nclass Solution {\n\n    int p;\n\n    public String decodeString(String s) {\n        LinkedList<String> stack = new LinkedList<>();\n        p = 0;\n        while(p < s.length()){\n            char ch = s.charAt(p);\n            if(Character.isDigit(ch)){\n                stack.addLast(getDigital(s));\n            }else if(ch == '[' || Character.isLetter(ch)){\n                stack.addLast(String.valueOf(ch));\n                p++;\n            }else{\n                p++;\n                LinkedList<String> subStr = new LinkedList<>();\n                while(!\"[\".equals(stack.peekLast())){\n                    subStr.add(stack.removeLast());\n                }\n                Collections.reverse(subStr);\n                stack.removeLast();\n                int repCount = Integer.parseInt(stack.removeLast());\n                String repStr = getString(subStr);\n\n                StringBuffer sb = new StringBuffer();\n\n                while(repCount > 0){\n                    sb.append(repStr);\n                    repCount--;\n                }\n\n                stack.addLast(sb.toString());\n            }\n        }\n        return getString(stack);\n    }\n\n    public String getDigital(String s){\n        StringBuffer sb = new StringBuffer();\n        while(Character.isDigit(s.charAt(p))){\n            sb.append(String.valueOf(s.charAt(p)));\n            p++;\n        }\n        return sb.toString();\n    }\n\n    public String getString(List<String> list){\n        StringBuffer sb = new StringBuffer();\n        for(String s : list)\n            sb.append(s);\n        return sb.toString();\n    }\n}\n```\n\n\n\n**复杂度**分析：\n\n* **时间复杂度**：O(N)，N为字符串的长度\n* **空间复杂度**：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918999851","body":"### Java\n\n---\n\n**思路**：\n\n使用两个栈即可实现队列\n\n* pushStack 用来接收入队的元素，popStack 用来进行出队操作\n* 元素入队没啥好考虑的，直接把元素压入到 pushStack 即可；\n* 元素出队：\n  * 当 pushStack 和 popStack 都为空时，说明队列中没有元素，则直接返回 -1 \n  * 当 popStack 为空，而 pushStack 不为空时，则把 pushStack 的元素出栈，入到 popStack 中，经过这波操作，可以发现 popStack 栈顶元素即为队列先入的元素，所以直接把 popStack  栈顶元素出栈即为队列先入元素\n  * 当 popStack 不为空时，直接把 popStack  栈顶元素出栈即为队列先入元素\n* 查看队列最先入的元素，注意点也和元素出队类似\n* 判断队列是否为空，只要 pushStack 和 popStack 不同时为空，则队列不为空。\n\n**代码**：\n\n```java\nclass MyQueue {\n\n    Deque<Integer> pushStack;\n    Deque<Integer> popStack;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        pushStack = new LinkedList<>();\n        popStack = new LinkedList<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        pushStack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        int res = 0;\n        if(pushStack.isEmpty() && popStack.isEmpty()){\n            res = -1;\n        }else if(popStack.isEmpty()){\n            while(!pushStack.isEmpty()){\n                popStack.push(pushStack.pop());\n            }\n            res = popStack.pop();\n        }else{\n            res = popStack.pop();\n        }\n        return res;\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        int res = 0;\n        if(popStack.isEmpty() && pushStack.isEmpty()){\n            res = -1;\n        }else if(popStack.isEmpty()){\n            while(!pushStack.isEmpty()){\n                popStack.push(pushStack.pop());\n            }\n            res = popStack.peek();\n        }else{\n            res = popStack.peek();\n        }\n        return res;\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return popStack.isEmpty() && pushStack.isEmpty() ? true : false;\n    }\n}\n```\n\n\n\n**复杂度**分析：\n\n* **时间复杂度**：O(1)， 入队和出队时间复杂度都为O(1)\n* **空间复杂度**：O(N)，需要使用两个栈来存储进队元素\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922476847","body":"**思路**：\n\n使用双指针 p1 和 p2，分别指向两个链表 headA 和 headB 的头结点，然后两个指针同时往后移动一步，当指针为null时，则 p1 指向 headB， p2 指向 headA 直到 p1 和 p2相同时退出循环。退出循环有两种情况，即两个链表没有相交点时，p1 和 p2 同时为 null，当两个链表有相交点时， p1 和 p2 同时指向相交点。\n\n**代码**：\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n\n        if(headA == null || headB == null) return null;\n\n        ListNode curA = headA, curB = headB;\n\n        while(curA != curB){\n            if(curA == null){\n                curA = headB;\n            }else{\n                curA = curA.next;\n            }\n            if(curB == null){\n                curB = headA;\n            }else{\n                curB = curB.next;\n            }\n        }\n        return curA == null ? null : curA;\n    }\n}\n\n```\n\n\n\n**复杂度分析**：\n\n* **时间复杂度**：O(M+N)，其中 M 为链表 headA 的长度， N 为链表 headB  的长度。\n\n* **空间复杂度**：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"potatoMa":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916923321","body":"### 思路\n***\n先在对应位置一一相加，再进行进位操作\n### 代码\n***\nJavascript code:\n```javascript\nvar addToArrayForm = function(num, k) {\n    let temp = 0;\n    const kLen = k.toString().length;\n    for (let i = 0;i < kLen;i++) {\n        if (num.length < kLen) num.unshift(0);\n        temp = k % 10;\n        k = Math.floor(k / 10);\n        num[num.length - 1 - i] += temp;\n    }\n    const nLen = num.length;\n    for (let i = nLen - 1;i > 0;i--) {\n        if (num[i] >= 10) {\n            num[i - 1] += 1\n            num[i] = num[i] % 10;\n        }\n    }\n    if (num[0] >= 10) {\n        num[0] = num[0] % 10;\n        num.unshift(1);\n    }\n    return num;\n};\n```\n### 复杂度分析\n***\n时间复杂度O(max(N,logk))<br/>\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917350423","body":"### 思路1\n\n***\n\n空间换时间：先记录每一个字符C出现的下标，再遍历一次字符串S，通过下标相减的绝对值找出每个字符距离C最近的距离\n\n### JavaScript代码\n\n***\n\n```javascript\nvar shortestToChar = function(s, c) {\n    const targetIndex = [];\n    for (let i = 0;i < s.length;i++) {\n        if (s[i] === c) {\n            targetIndex.push(i);\n        }\n    }\n    const res = [];\n    for (let i = 0;i < s.length;i++) {\n        let min = Infinity;\n        for (let ti of targetIndex) {\n            if (min <= Math.abs(i - ti)) {\n                break;\n            }\n            min = Math.abs(i - ti);\n        }\n        res.push(min);\n    }\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N * K)，K是字符C在字符串S中出现的次数，K <= N\n\n空间复杂度：O(K)\n\n### 思路2\n\n***\n\n贪心，先从左往右遍历S，计算每个下标离左边距离C最近的距离，再从右往左遍历计算一次，如有更小的距离则覆盖\n\n### JavaScript代码\n\n***\n\n```javascript\nvar shortestToChar = function(s, c) {\n    let targetIndex = null;\n    const res = new Array(s.length);\n    for (let i = 0;i < s.length;i++) {\n        if (s[i] === c) targetIndex = i;\n        if (targetIndex === null) {\n            res[i] = Infinity;\n        } else {\n            res[i] = Math.abs(i - targetIndex);\n        }\n    }\n    targetIndex = null;\n    for (let i = s.length - 1;i > -1;i--) {\n        if (s[i] === c) targetIndex = i;\n        if (targetIndex !== null) {\n            res[i] = Math.min(res[i], Math.abs(i - targetIndex));\n        }\n    }\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917562392","body":"### 思路\n\n***\n\n简单的栈实现+保存增量，通过哈希表保存每个下标的增量，在pop时再进行increment\n\n### JavaScript代码\n\n***\n\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = new Array();\n    this.maxSize = maxSize;\n    this.hashMap = new Map();\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.maxSize > this.stack.length) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    const k = this.stack.length - 1;\n    if (k < 0) return -1;\n    const hashValue = this.hashMap.get(k) || 0;\n    this.hashIncrement(k - 1, hashValue);\n    this.hashMap.set(k, 0);\n    return this.stack.pop() + hashValue;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(index, val) {\n    const k = Math.min(this.stack.length - 1, index - 1);\n    if (k < 0) {\n        return;\n    }\n    this.hashIncrement(k, val);\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.hashIncrement = function(index, val) {\n    if (!this.hashMap.has(index)) {\n        this.hashMap.set(index, val);\n    } else {\n        this.hashMap.set(index, this.hashMap.get(index) + val);\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：push:O(1)、pop:O(1)、increment:O(1)、pop:O(1)\n\n空间复杂度：O(N)、N为min(k, maxSize)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918262721","body":"### 思路\n\n***\n\n使用栈对字符串进行记录，在出现\"]\"之前，将\"[\"、数字及字母推入栈中。出现了\"]\"之后，先找出\"[\"顶部的所有字母，再找出\"[\"底部的数字，将前面找出的字母以数字的倍数推入栈中。然后继续遍历，最终得出结果。\n\n### JavaScript代码\n\n***\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    if (!s.includes('[')) return s;\n    const stack = [];\n    for (let c of s) {\n        if (c !== ']') {\n            stack.push(c);\n        } else {\n            const temp = [];\n            let top = stack.pop();\n            while (top !== '[') {\n                temp.unshift(top);\n                top = stack.pop();\n            }\n            let count = '';\n            while (!isNaN(stack[stack.length - 1])) {\n                count = `${stack.pop()}${count}`;\n            }\n            while (count > 0) {\n                stack.push(...temp);\n                count--;\n            }\n        }\n    }\n    return stack.join('');\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(S + |s|) = O(S);\n\n空间复杂度：O(S)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919279794","body":"### 思路\n\n***\n\n双栈实现队列\n\n### JavaScript代码\n\n***\n\n```javascript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        while(this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return this.outStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        while(this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    if (!this.outStack.length) {\n        while(this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return !this.outStack.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：push:O(1)、empty:O(1)、pop:O(1)、peek:O(1)\n\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920097653","body":"> 没有思路，看了下题解思路后自己写了一遍，小漾yyds！\n\n### 思路1：滑动窗口\n\n***\n\n原数组与排好序后的数组比较，当窗口内的数字和相等则可以分为一个块。\n\n### 代码\n\n***\n\nJavaScript Code\n\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const sortedArr = [...arr].sort((a, b) => a - b);\n    let sum1 = 0, sum2 = 0, res = 0;\n    for (let i = 0;i < sortedArr.length;i++) {\n        sum1 += sortedArr[i];\n        sum2 += arr[i];\n        if (sum1 === sum2) {\n            res++;\n        }\n    }\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(NlogN + N) = O(NlogN)\n\n空间复杂度：O(N)\n\n### 思路2：单调栈\n\n***\n\n通过遍历数组间接找出每个块中的最大值，当遇到更大的值时则可以将其置为新的块，推入栈顶；遇到较小的值时，则降栈顶依次弹出找到小于等于该值的项，并进行合并。\n\n### 代码\n\n***\n\nJavaScript Code\n\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const stack = [];\n    for (let i = 0;i < arr.length;i++) {\n        if (!stack.length || stack[stack.length - 1] <= arr[i]) {\n            stack.push(arr[i]);\n        } else if (stack[stack.length - 1] === arr[i]) {\n            continue;\n        } else if (stack[stack.length - 1] > arr[i] && stack.length !== 1) {\n            let top = stack.pop();\n            while (stack[stack.length - 1] > arr[i]) {\n                stack.pop();\n            }\n            stack.push(top);\n        }\n    }\n    return stack.length;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920989380","body":"### 思路\n\n***\n\n快慢指针，k对链表的长度取余后获得差值，再根据差值进行链表的截取\n\n### 代码\n\n***\n\nJavascript Code\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head || !head.next || !k) return head;\n    let slow = head, fast = head, n = 1;\n    while (fast.next) {\n        n++;\n        fast = fast.next;\n    }\n    k = k % n;\n    if (k === 0) return head;\n    fast = head;\n    while (k > 0) {\n        fast = fast.next;\n        k--;\n    }\n    while(fast.next) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    const res = slow.next;\n    fast.next = head;\n    slow.next = null;\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921709188","body":"### 思路\n\n***\n\n新建一个伪头保存头节点，用临时变量保存下一个和下两个节点，进行两两互换。\n\n### 代码\n\n***\n\nJavascript code\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    const newHead = new ListNode(0);\n    newHead.next = head;\n    let temp = newHead;\n    while (temp.next && temp.next.next) {\n      const one = temp.next;\n      const two = temp.next.next;\n      temp.next = two;\n      one.next = two.next;\n      two.next = one;\n      temp = one;\n    }\n    return newHead.next;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922329980","body":"### 思路\n\n***\n\n使用快慢指针找出链表的中间节点作为二叉树的根节点，通过递归分别构建左右子树\n\n### 代码\n\n***\n\nJavascript Code\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if (head === null) return null;\n    let slow = head;\n    let fast = head;\n    let preSlow;\n    while (fast && fast.next) {\n        preSlow = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    const root = new TreeNode(slow.val);\n    if (preSlow != null) {\n        preSlow.next = null;\n        root.left = sortedListToBST(head);\n    }\n    root.right = sortedListToBST(slow.next);\n    return root;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：树的层级O(logN) * 查找中点O(N/2) = O(NLogN)\n\n空间复杂度：递归深度O(logN)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922488951","body":"### 思路\n\n***\n\n通过双指针间接找到两链表的差值，再通过差值使两指针相遇（如果存在相交），最终返回指针即可。\n\n### 代码\n\n***\n\nJavascript Code\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    if (!headA || !headB) return null;\n    let a = headA, b = headB;\n    while (a !== b) {\n        a === null ? a = headB : a = a.next;\n        b === null ? b = headA : b = b.next;\n    }\n    return a;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：最多遍历链表两次，即O(N)\n\n空间复杂度：只使用常数大小的空间，即O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vincentLW":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916927171","body":"代码\n```\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int cur = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry;\n            k = k > 0 ? k / 10 : 0;\n            i = i >= 0 ? i - 1 : -1;\n            carry = cur / 10;\n            cur = cur % 10;\n            res.add(cur);\n        }\n        if (carry == 1) res.add(carry);\n        Collections.reverse(res);\n        return res;\n    }\n```\n时间复杂度：$O(n)$\n空间复杂度：$O(n)$\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919143816","body":"```\r\nvar MyQueue = function() {\r\n    this.data = []\r\n    this.temp = []\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    this.data.push(x)\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    if(!this.temp.length){\r\n        while(this.data.length){\r\n             this.temp.push(this.data.pop())\r\n        }\r\n       \r\n    } \r\n    return this.temp.pop()\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n   if(!this.temp.length){\r\n        while(this.data.length){\r\n             this.temp.push(this.data.pop())\r\n        }\r\n    } \r\n    return this.temp[this.temp.length-1]\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n   return !this.data.length && !this.temp.length\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920975555","body":"**思路**\r\n1.链表的指针移动\r\n```\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    l := 0\r\n    var last *ListNode\r\n\r\n    node := head\r\n    for node != nil {\r\n        l++\r\n        last = node\r\n        node = node.Next\r\n    }\r\n\r\n    if l == 0 {\r\n        return head\r\n    }\r\n\r\n    k = k % l\r\n\r\n    if k == 0 {\r\n        return head\r\n    }\r\n    newHead := head\r\n    var newLast *ListNode\r\n    kk := l - k\r\n    for i := 0; i < kk; i++ {\r\n        newLast = newHead\r\n        newHead = newHead.Next\r\n    }\r\n\r\n    last.Next = head\r\n    newLast.Next = nil\r\n\r\n    return newHead\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921863457","body":"```\r\n/* 两两交换节点\r\n思路\r\n1.两个两个一组进行翻转\r\n2.翻转后第一个点需要连接下一组的第一个点\r\n3.如果不够两个点不动\r\n\r\n解法\r\n1.迭代\r\n2.递归\r\n*/\r\n\r\n/* 迭代\r\n思路\r\n1.添加dummy 进行三个node一组\r\n2.先是否能够进行翻转\r\n3.再进行翻转\r\n4.移动结点\r\n\r\n*/\r\nvar swapPairs = function (head) {\r\n  const dummy = new ListNode(0);\r\n  dummy.next = head;\r\n\r\n  /* temp 是 上一个组的最后一个元素 */\r\n  let temp = dummy;\r\n\r\n  /* 一定要判断temp.next 和 temp.next.next,\r\n   因为后面会有 node1.next node2.next  */\r\n  while (temp.next && temp.next.next) {\r\n    const node1 = temp.next;\r\n    const node2 = temp.next.next;\r\n\r\n    // 交换node1 node2\r\n    node1.next = node2.next;\r\n    node2.next = node1;\r\n    /* 改变dummy的指向 为后来做准备 */\r\n    temp.next = node2;\r\n\r\n    // 改变指针\r\n    temp = node1;\r\n  }\r\n\r\n  return dummy.next;\r\n};\r\n\r\n/* 复杂度\r\n时间  O(n)\r\n空间 O(1)\r\n*/\r\n\r\n\r\n\r\n/* 递归\r\n1.层层递归，判断是否有2个元素（终止条件），没有就返回head\r\n2.递归返回 最后一组的第一个元素\r\n3.返回后k组元素连接，K组内交换\r\n*/\r\nvar swapPairs = function (head) {\r\n  // 如果不存在2个元素\r\n  if (!head || !head.next) {\r\n    return head;\r\n  }\r\n\r\n  const node1 = head;\r\n  const node2 = head.next;\r\n  node1.next = swapPairs(node2.next);\r\n  node2.next = node1;\r\n  return node2;\r\n};\r\n\r\n/* 复杂度\r\n时间  O(n)\r\n空间 O(n)\r\n*/\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzcyx":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916929362","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        ArrayList list=new ArrayList<Integer>();\n        int f=num.length-1;int carry=0;\n        while(f>=0&&k!=0)\n        {\n            int a=(num[f]+k%10+carry)%10;carry=(num[f]+k%10+carry)/10;\n            list.add(a);\n            f--;k/=10;\n        }\n        while(k>0)\n        {\n            int a=(k%10+carry)%10;carry=(k%10+carry)/10;list.add(a);\n            k/=10;\n        }\n        while(f>=0)\n        {\n            int a=(num[f]+carry)%10;carry=(num[f]+carry)/10;list.add(a);\n            f--;\n        }\n        if(carry>0)list.add(1);\n         Collections.reverse(list);\n         return list;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917326518","body":" \n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int pre=Integer.MIN_VALUE/2;int dist[]=new int[s.length()];\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)==c)\n            {\n                pre=i;\n            }\n            dist[i]=i-pre;\n        }\n        pre=Integer.MAX_VALUE/2;\n        for(int i=s.length()-1;i>=0;i--)\n        {\n            if(s.charAt(i)==c)\n            {\n                pre=i;\n            }\n            dist[i]=Math.min(dist[i],Math.abs(pre-i));\n        }\n        return dist;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917538598","body":"class CustomStack {\n\n    int []s;int maxSize;int top=-1;\n    public CustomStack(int maxSize) {\n        this.maxSize=maxSize;\n        s=new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(top+1<maxSize)s[++top]=x;\n        \n    }\n    \n    public int pop() {\n        if(top==-1)return -1;\n        return s[top--];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k&&i<=top;i++)\n            s[i]+=val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916930744","body":"### **思路**\n\n倒着过一遍num，和k逐位相加。\n\n1. k的位数：用取mod和地板除可以直接把k用掉的位置扔掉，同时如果要进位，直接进位到k上即可。是一种比较便捷的方式。\n2. 一开始想用先初始化n长度的list存储结果，但是其实list长度很难定，所以可以直接用reverse，reverse复杂度是O(n)\n3. 注意会有k长度比num大的情况的！并不都是k长度小于n\n4. 加法问题记得再研究下模板\n\n    [力扣](https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/)\n\n### **代码**\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # 可能会有k长度大于num的情况\n        # 反转列表\n        res = []\n        n = len(num) - 1\n        for i in range(n, -1, -1):\n            cur_sum = k % 10 + num[i]\n            k = k // 10\n            if cur_sum < 10:\n                res.append(cur_sum)\n            else:\n                res.append(cur_sum % 10)\n                k += 1\n        while k:\n            res.append(k % 10)\n            k //= 10\n        res.reverse()\n        return res\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(min(n,k)) reverse复杂度是O(n) 所以是n长度和k长度最小值\n- 空间复杂度：O(1) 没有额外空间","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917651282","body":"思路\n用数组（在python中一个list）模拟栈\n\n代码\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.stack = list()\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            pop_item = self.stack[-1]\n            self.stack = self.stack[:-1]\n            return pop_item\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n复杂度分析\n时间复杂度：push O(1)；pop O(1); increment O(N)\n空间复杂度：O(N) 这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918208858","body":"### **思路**\n\n不是']'就全部入栈，碰到']'开始解码，解码就是一个个拆出来，碰到'['停止拆字符串，碰到数字就另外算要重复的数字是多少。这里有两个地方容易错，一个是数字未必是个位数，一个是出栈之后的str不要直接拼到结果上，继续入栈（不然这样的case无法通过\"3[a2[c]]\"），最后把栈当作结果join一下即可。\n\n### **代码**\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i, char in enumerate(s):\n            if char != ']':\n                stack.append(char)\n            elif char == ']':\n                repeat_s = ''\n                while stack and stack[-1] != '[':\n                    repeat_s = stack.pop() + repeat_s\n                stack.pop() # pop 掉'['\n                cnt = ''\n                while stack and stack[-1].isdigit(): # 可能有多个数字\n                    cnt = stack.pop() + cnt\n                repeat_s = repeat_s * int(cnt)\n                stack.append(repeat_s) # 这里是一个要点，重复的字符串直接压回栈里\n        return ''.join(stack)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n) 遍历\n- 空间复杂度：O(n) 用了辅助站","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918820732","body":"### **思路**\n\n相当于两个栈容器，互相倒来倒去。\n\n### **代码**\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.stack2:\n            return self.stack2.pop()\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.stack2:\n            return self.stack2[-1]\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.stack1) + len(self.stack2) == 0\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n) 最坏O(n)，最好O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920141700","body":"### **思路1：单调栈**\n\n一开始的做法是**找单调递增的地方，在每个单调递增的地方切块，是不对的。**也就是扫描数组，记录下一个大于数i的数，如果是单调递增的，下一个比数i大的数就是1，记录递增的数量（每次加1），递增数量和就是结果，但是[4,2,2,1,1]过不了！所以题目还有一层意思就是**每一个块要比前一个块大**，每个块的最小要比前一个块的最大要大。\n\n### **代码**\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        \n        stack = []\n        for i, v in enumerate(arr):\n            if stack and stack[-1] > v:\n                cur = stack[-1]\n                while stack and stack[-1] > v:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(v)\n\n        return len(stack)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920526732","body":"### **思路**\r\n\r\n先计算链表的长度，记为cnt，k对链表长度取余是要旋转的次数，旋转几次，就是倒数第几个链表拆出来作为头，相当于找到要旋转断开的地方，拆成两个链表，把后面的链表拼到前面的链表上，后面链表指向头，前面链表指向None\r\n\r\n### **代码**\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head:\r\n            return\r\n        cnt = 0\r\n        cur = head\r\n        while cur:\r\n            cur = cur.next\r\n            cnt += 1\r\n        k = k % cnt\r\n        cur = head\r\n        cut = 0\r\n        res = None\r\n        while cur.next:\r\n            cut += 1\r\n            if cut == cnt - k:\r\n                tmp = cur.next\r\n                cur.next = None\r\n                cur = tmp\r\n                res = cur\r\n            else:\r\n                cur = cur.next\r\n        if res:\r\n            cur.next = head\r\n        return res if res else head\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921588957","body":"### **思路：双指针**\n\n加一个dummy头，需要两个指针作为prev和cur，为什么需要一个dummy呢？这样可以容易找头节点，因为最后返回肯定是要头节点的。\n\n### **代码**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head:\n            return head\n        dummy_node = ListNode(-1)\n        dummy_node.next = head\n        prev_node, cur_node= dummy_node, head\n        while cur_node and cur_node.next:\n            next_node = cur_node.next\n            prev_node.next = next_node\n            next_cur_node = next_node.next\n            next_node.next = cur_node\n            cur_node.next = next_cur_node\n            prev_node, cur_node = cur_node, next_cur_node\n        return dummy_node.next\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922327249","body":"### **思路：递归+双指针**\n\n把链表想象成一个绳子，每次操作是从中间把绳子拎起来。用递归的方式把问题缩小，每次找到中间的节点作为root，左边接链表的前半部分sort后的二叉搜索树，后面接链表后半部分sort后的二叉搜索树。其中中间节点用快慢指针找到。\n\n### **代码**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        \"\"\"\n        递归输入：链表\n        递归返回：高度平衡二叉搜索树\n        递归出口not root\n        递归逻辑：找到链表中点，左边拼sorted(左节点)，右边拼sorted(右节点)\n        \"\"\"\n        if not head:\n            return\n        pre_node = None\n        slow, fast = head, head\n        # 找到链表的中点\n        while fast and fast.next:\n            pre_node = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 切断\n        if pre_node:\n            pre_node.next = None\n        \n        cur_node = TreeNode(slow.val)\n        if fast == slow: # 注意相等的时候要返回 这里自己写的时候没注意到导致爆栈\n            return cur_node\n        cur_node.left = self.sortedListToBST(head)\n        cur_node.right = self.sortedListToBST(slow.next)\n        return cur_node\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(nlogn) 递归复杂度可以画出递归栈。每一层递归的操作是，寻找链表中间节点，第一次是n，第二次是两块分别找，是n/2+n/2，第三次是4个n/4，每一次都是n，也就是说递归的时候，每次找中间节点用时n，一共有logn层，所以是n*logn\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922452276","body":"### **思路1：哈希**\n\n比较直接，遍历a全部放进哈希表，遍历b如果见到已经在哈希表中的则就是要找的节点，否则没有交点\n\n### **代码**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA, headB):\n        a = headA\n        b = headB\n        if not a or not b:\n            return None\n        hash = {}\n        while a:\n            hash[a] = 1\n            a = a.next\n        while b:\n            if b in hash:\n                return b\n            else:\n                b = b.next\n        return None\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n### **思路2：双指针**\n\nheada交点前面长度是a，headb交点前面长度是b，相交的部分长度是c。那指针1走完a一整段再走b，指针b走完b一整段再走a，一定走的长度一样。如果两者不相交，在走完a+b+c之后也会在None处相等，所以循环的出口是指针1d的值==指针2的值\n\n### **代码**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA, headB):\n        a = headA\n        b = headB\n        while a != b:\n            if not a:\n                a = headB\n            else: \n                a = a.next\n            if not b:\n                b = headA\n            else:\n                b = b.next\n        return a\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jaysonss":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916934318","body":"## 思路\n\n把k转化成数组K，然后让A和K从低位到高位进行相加操作，注意进位问题。\n\n## 关键点\n\n- 如果遍历到最高位后有进位，需要在结果里加上1\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```dart\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> kList = new ArrayList<>();\n\n        while (k != 0) {\n            kList.add(k % 10);\n            k /= 10;\n        }\n        Collections.reverse(kList);\n        int i = num.length - 1;\n        int j = kList.size() - 1;\n        List<Integer> retList = new ArrayList<>();\n        int delta = 0;\n\n        while (i >= 0 || j >= 0) {\n            int a = i >= 0 ? num[i] : 0;\n            int b = j >= 0 ? kList.get(j) : 0;\n            int v = a + b + delta;\n            \n            if (v > 9) {\n                retList.add(v % 10);\n                delta = 1;\n            } else {\n                retList.add(v);\n\t\tdelta = 0;\n            }\n            i--;\n            j--;\n        }\n\n        if (delta == 1) {\n            retList.add(1);\n        }\n        Collections.reverse(retList);\n        return retList;\n    }\n\n}\n```\n\n**复杂度分析**\n\n时间复杂度：k的取值范围是1-10000，数组K最大长度为5，主要看num的长度，因此为O(n)\n\n空间复杂度：保存结果的List长度主要由num决定，因此为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428343","body":"## 思路\n\n遍历数组，如果当前字符不是目标字符就记录下位置，如果是目标字符就查看下缓存的所有非目标字符的位置，\n\n这里存在两种情况：第一种是之前还没遍历到目标字符，则位置差可以直接计算出来。第二种是之前有记录过最后一个目标字符的位置，此时需要比较哪个距离更小。处理完成后更新最后一个字符索引继续遍历。\n\n## 关键点\n\n- 边界条件：如果遍历结束还有很多非目标字符被缓存，需要计算它们和最后一个目标字符位置的距离\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int lastIdx = -1;\n        int[] disArr = new int[s.length()];\n        int disIdx = 0;\n        List<Integer> idxList = new ArrayList<>();\n\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                boolean hasLastIdx = lastIdx == -1;\n                for (int idx : idxList) {\n                    disArr[disIdx++] = hasLastIdx ? i - idx : Math.min(i - idx, idx - lastIdx);\n                }\n                disArr[disIdx++] = 0;\n                lastIdx = i;\n                idxList.clear();\n            } else {\n                idxList.add(i);\n            }\n        }\n        if(!idxList.isEmpty()){\n            for(int idx: idxList){\n                disArr[disIdx++] = idx-lastIdx;\n            }\n        }\n        return disArr;\n    }\n}\n```\n\n**复杂度分析**\n\n时间复杂度：就遍历了一次字符串，所以为O(n)\n\n空间复杂度：缓存非目标字符位置的List和数组长度相关，最坏情况下可能就是字符串长度，因此为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917659430","body":"## 思路\n\n用数组来模拟栈，用指针记录下栈顶的索引即可。\n\n## 关键点\n\n-  无\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass CustomStack {\n\t\t\n    int[] _data;\n\n    int idx = -1;\n\n    public CustomStack(int maxSize) {\n        _data = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (idx == _data.length - 1)\n            return;\n        _data[++idx] = x;\n    }\n\n    public int pop() {\n        if (idx == -1)\n            return -1;\n        return _data[idx--];\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i <= Math.min(k - 1, idx); i++) {\n            _data[i] = _data[i] + val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：push和pop操作都是O(1)，increase是O(min(k,idx)), idx为栈目前的大小\n- 空间复杂度：数组占用为O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919154691","body":"## 思路\n\n每次往栈中push元素的时候都先把栈中的所有元素pop出来放到辅助栈里。\n\n在添加完元素后再把辅助栈里的元素依次pop出来放回到原来的栈里。\n\n以添加两个元素为例：\n\n|       | 栈1  | 栈2  |\n| ----- | ---- | ---- |\n| 添加a | A    | Null |\n| 添加b | B    | A    |\n|       | BA   | Null |\n\n\n\n## 关键点\n\n-  无\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass MyQueue {\n\n    Stack<Integer> stack;\n\n    Stack<Integer> reverseStack;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack = new Stack<>();\n        reverseStack = new Stack<>();\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        while(!stack.isEmpty()){\n            reverseStack.push(stack.pop());\n        }\n        stack.push(x);\n        while(!reverseStack.isEmpty()){\n            stack.push(reverseStack.pop());\n        }\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        return stack.pop();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        return stack.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack.isEmpty();\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：push n次为Σn，平均时间复杂度为O(n);其他操作为O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920023837","body":"## 思路\n\n使用滑动窗口的思想，窗口默认为遍历起点的元素。\n\n+ 如果新元素比窗口中所有值都大就继续遍历\n\n+ 如果新元素比窗口中最大值小就把它以及它之前未纳入窗口的元素都纳入窗口\n+ 窗口建立好后就从结尾处重复上述过程\n\n## 关键点˜\n\n-  无\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int count = 0;\n        int idx = 0;\n\n        while(idx < arr.length){\n            idx = getBlockEnd(idx, arr)+1;\n            count++;\n        }\n        return count;\n    }\n\n    private int getBlockEnd(int start,int[] arr){\n        if(start >= arr.length)return arr.length;\n        int end = start;\n        int blockMax = arr[start];\n        int max = arr[start];\n\n        for(int idx = start;idx < arr.length;idx++){\n            if(max > arr[idx]){\n                //扩大窗口，同时更新窗口最大值\n                end = idx;\n                max = blockMax;\n            }else{\n                blockMax = Math.max(blockMax,arr[idx]);\n            }\n        }\n        return end;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：每次遍历都是从上次遍历的结尾处开始，所以为O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920947081","body":"## 思路\n\n移动k次，链表长度为n，题目的意思就是把右侧(k%n)个元素和前面的元素做位置对调，题目就转化成了寻找倒数第(n-k%n)个元素\n\n## 关键点˜\n\n-  无\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n      \t//边界条件\n        if(head == null || head.next == null || k ==0)return head;\n        int len = 0;\n        ListNode cp = head;\n\n        while(cp != null){\n            len++;\n            cp = cp.next;\n        }\n        int count = k % len;\n\n        if(count == 0)return head;\n        ListNode start = head;\n        ListNode end = head;\n        \n        for(int i=0;i<count;i++){\n            end = end.next;\n        }\n\n        while(end!=null && end.next != null){\n            end = end.next;\n            start = start.next;\n        }\n\n        ListNode newHead = start.next;\n        start.next = null;\n        end.next = head;\n        return newHead;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921790018","body":"## 思路\n\n用两个指针代表一组元素，首先记录下它们后面的两个节点（也可能为一个或者0个）\n\n+ 如果接下来没有元素了就不处理\n+ 如果只有一个节点剩下就令left.next=last即可\n+ 如果有两个节点要令left.next = last.next，这样下一组元素交换位置后链表才不会断\n\n记下第一个分组的right节点并返回即可\n\n最后，要处理边界条件（head==null || head.next == null)\n\n## 关键点˜\n\n-  无\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n        ListNode left = head;\n        ListNode right = head.next;\n        ListNode newHead = right;\n\n        while (left != null && right != null) {\n            ListNode rightNext = right.next;\n            ListNode rightNextNext = rightNext == null ? null : rightNext.next;\n\n            right.next = left;\n            //如果最后只有一个节点需要特殊处理\n            left.next = rightNextNext == null ? rightNext : rightNextNext;\n\n            left = rightNext;\n            right = rightNextNext;\n        }\n        return newHead;\n    }\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922309571","body":"## 思路\n\n+ 首先是找根节点：链表中间位置的点\n+ 找到根节点root后，递归找到root左边链表的根节点leftRoot和右边链表的根节点rightRoot\n\n## 关键点˜\n\n-  该解法会改变原有链表，需要确定是否可以修改\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null){\n            return null;\n        }\n\n        if(head.next == null){\n            return new TreeNode(head.val);\n        }\n        ListNode root = head;\n        int len = 0;\n        while(root!=null){\n            len++;\n            root = root.next;\n        }\n        ListNode pre = null;\n        ListNode treeRoot = head;\n        \n        for(int i=0;i<len / 2;i++){\n            pre = treeRoot;\n            treeRoot = treeRoot.next;\n        }\n\n        if(pre!=null){\n           // 令左边链表断开和root的联系\n            pre.next = null;\n        }\n        //找到左根节点\n        TreeNode leftRootNode = sortedListToBST(head);\n        //找到右根节点\n        TreeNode rightRootNode = sortedListToBST(treeRoot.next);\n        TreeNode rootNode = new TreeNode(treeRoot.val);\n        rootNode.left = leftRootNode;\n        rootNode.right = rightRootNode;\n        return rootNode;\n\n    }\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：\n\n```\nF(n）=\t找根节点:n + 递归：2F(n/2)。不会画图下面的表达式凑合表达：\n n             \nn/2       n/2           \nn/4  n/4  n/4  n/4\n ......\n1 1 1 1 1 1 1 1 1 1 1\n这颗递归树的高度是logn，每一层都是n，所以时间复杂度是O(nlogn)\n```\n\n\n\n- 空间复杂度\n\n  主要是递归带来的函数栈，根据上面的图调用之和为:\n\n  `1+2+4+8+....+n`，这是个等比数列，因子为2，个数为logn，易得复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922490448","body":"## 思路\n\n+ 获取两个链表的长度，计算其差值\n+ 根据差值调整headA和headB，使得两条链表可以同时到达终点\n+ 如果有交点，遍历时必然会出现aPtr==bPtr\n\n## 关键点˜\n\n-  无\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA==null || headB==null)return null;\n\n        int aLen = len(headA);\n        int bLen = len(headB);\n        int offset = aLen - bLen;\n        ListNode aPtr = headA;\n        ListNode bPtr = headB;\n        \n        while(offset!=0){\n            if(offset<0){\n                bPtr = bPtr.next;\n                offset++;\n            }else{\n                aPtr = aPtr.next;\n                offset--;\n            }\n        }\n      \n        while(aPtr != null && aPtr != bPtr){\n            aPtr = aPtr.next;\n            bPtr = bPtr.next;\n        }\n        return aPtr;\n    }\n\n    int len(ListNode node){\n        ListNode cp = node;\n        int len = 0;\n      \n        while(cp!=null){\n            len++;\n            cp = cp.next;\n        }\n        return len;\n    }\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Bochengwan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916934555","body":"### 思路\r\n\r\n从个位开始加，如果加到最后比原数组长，则把多余的位数append到左边。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n\r\n        digits = len(A)-1\r\n        \r\n        left = K\r\n        \r\n        while left!=0 and digits != -1:\r\n            result = left+A[digits]\r\n            left, A[digits] = result//10, result%10\r\n            digits-=1\r\n            \r\n        if digits == -1 and left!=0:\r\n            while left!=0:\r\n                A = [left%10]+A\r\n                left = left//10\r\n\r\n        return A\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917422452","body":"### 思路\r\n\r\n两次扫描，一次从左到右，一次从右到左，然后第二次需要比较第一次的结果，取较小的那个。\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\n        distance = [sys.maxsize]*len(S)\r\n        prev_c = -sys.maxsize\r\n        for i in range(len(S)):\r\n            if S[i]==C:\r\n                prev_c = i\r\n            distance[i] = i-prev_c\r\n        prev_c = sys.maxsize\r\n        \r\n        for i in range(len(S)-1,-1,-1):\r\n            if S[i]==C:\r\n                prev_c = i\r\n            distance[i] = min(prev_c-i,distance[i])\r\n        return distance\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661940","body":"### 思路\r\n\r\n通过数组模拟stack。\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.myStack = []\r\n        self.delta = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.myStack)<self.maxSize:\r\n            self.myStack.append(x)\r\n            self.delta.append(0)\r\n        \r\n        \r\n        \r\n\r\n    def pop(self) -> int:\r\n        if len(self.myStack)==0:\r\n            return -1\r\n        delta = self.delta.pop()\r\n        \r\n        if self.delta:\r\n            self.delta[-1]+=delta\r\n        return self.myStack.pop()+delta\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        length = len(self.myStack)\r\n        if length ==0:\r\n            return None\r\n        inc_length = k\r\n        if k>length:\r\n            inc_length = length\r\n        \r\n        self.delta[inc_length-1]+=val\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：pop O(1), PUSH O(1), INCREMENT O(min(k, N),其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917664701","body":"### 思路\r\n\r\n利用两个栈，一个存数字，一个存字符，每次遇到括号进行处理。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        bracket_stack = []\r\n        number_stack = []\r\n        c = ''\r\n        n = ''\r\n        for e in s:\r\n            \r\n            if e.isdigit():\r\n                n+=e\r\n            elif e == '[':\r\n                bracket_stack.append(c)\r\n                number_stack.append(n)\r\n                n = ''\r\n                c = ''\r\n            elif e == ']':\r\n                \r\n                c = (bracket_stack.pop() + c*int(number_stack.pop()))\r\n            else:\r\n                c += e\r\n        return c\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(m+n), m = len(number_stack), n = len(bracket_stack）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918843131","body":"### 思路\r\n通过两个stack，第一次pop的之后会把主stack里面的element reverse，之后的pop则从辅助stack里直接pop就可以了（知道辅助stack变空）。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass MyQueue:\r\n    \r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.main_stack = []\r\n        self.aux_stack = []\r\n        \r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        if len(self.main_stack) == 0:\r\n            self.front = x\r\n        self.main_stack.append(x)\r\n            \r\n        \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if len(self.aux_stack)==0:\r\n            \r\n            self.aux_stack = self.main_stack[::-1]\r\n            self.main_stack = []\r\n        return self.aux_stack.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if len(self.aux_stack) == 0:\r\n            return self.front\r\n        return self.aux_stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        print(self.aux_stack,self.main_stack)\r\n        return len(self.main_stack)==0 and len(self.aux_stack)==0\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1) Push，O(1) POP, 其中 N 为数组长度。\r\n- 空间复杂度：O(n)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920701077","body":"### 思路\r\n\r\n先找到总长度，再找到需要从左move的长度，然后再rotate。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not k:\r\n            return head\r\n        \r\n        \r\n        \r\n        curr = head\r\n        l_len = 1\r\n        while curr.next:\r\n            curr = curr.next\r\n            l_len+=1\r\n        move = k%l_len\r\n        \r\n        curr.next = head\r\n        \r\n        curr = head\r\n        \r\n        for _ in range(l_len-move-1):\r\n            curr = curr.next\r\n        result = curr.next\r\n        curr.next = None\r\n        return result\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921535604","body":"### 思路\r\n\r\n创建一个dummy node 方便return结果。然后需要一个prev指向前面的tail，并且在通过first和second来交换节点。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        \r\n        if not head or not head.next:\r\n            return head\r\n        dummy = ListNode(-1,head)\r\n        \r\n        prev = dummy\r\n        \r\n        while head and head.next:\r\n           \r\n            first, second = head, head.next\r\n            first.next = second.next\r\n            second.next = first\r\n            prev.next = second\r\n            prev = first\r\n            head = first.next\r\n            \r\n            \r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922425526","body":"### 思路\r\n\r\n把一条链表的所有点存入hashset,然后检测第二个链表的节点，第一个在hashset里的则是重合点\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        node_set = set()\r\n        \r\n        while headA:\r\n            node_set.add(headA)\r\n            headA = headA.next\r\n        while headB:\r\n            if headB in node_set:\r\n                \r\n                return headB\r\n            headB = headB.next\r\n        return None\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maxsarratt":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916935148","body":"### 代码\r\n\r\n```java\r\n// Time: O(max(n, log(k))) ; Space: O(max(n, log(k)))\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        if (num == null || num.length == 0) {\r\n            return new LinkedList<>();\r\n        }\r\n\r\n        List<Integer> result = new LinkedList<>();\r\n\r\n        int carry = 0;\r\n        int index = num.length - 1;\r\n        while (index >= 0 || k != 0) {\r\n            int sum = carry;\r\n\r\n            if (index >= 0) {\r\n                sum += num[index--];\r\n            }\r\n            if (k != 0) {\r\n                sum += k % 10;\r\n            }\r\n\r\n            result.add(0, sum % 10);\r\n            carry = sum / 10;\r\n            k /= 10;\r\n        }\r\n\r\n        if (carry != 0) {\r\n            result.add(0, carry);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334801","body":"### 代码\r\n\r\n```java\r\n// Time: O(n); Space: O(n)\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {        \r\n        int len = s.length();\r\n\r\n        List<Integer> list = new LinkedList<>();\r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n               list.add(i);\r\n            }\r\n        }\r\n        \r\n        int p = 0;\r\n        int[] res = new int[len];\r\n        \r\n        for (int i = 0; i < len; i++) {\r\n            if (p < list.size() - 1 && Math.abs(list.get(p) - i) > Math.abs(list.get(p + 1) - i)) {\r\n                p++;\r\n            }\r\n            res[i] = Math.abs(list.get(p) - i);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-918136334","body":"```\r\ntype CustomStack struct {\r\n    MaxSize int\r\n    Stack []int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack{maxSize, []int{}}\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if len(this.Stack) < this.MaxSize {\r\n        this.Stack = append(this.Stack, x)\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if len(this.Stack) == 0 {\r\n        return -1\r\n    }\r\n    \r\n    val := this.Stack[len(this.Stack)-1]\r\n    this.Stack = this.Stack[:len(this.Stack)-1]\r\n    return val\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    for i := 0; i < k && i < len(this.Stack); i++ {\r\n        this.Stack[i] += val\r\n    }\r\n}\r\n ```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918136680","body":"```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n          int s_len = s.size();\r\n        stack<int> numstack;\r\n        stack<string> strstack;\r\n        int num = 0;\r\n        string cur_str=\"\";\r\n        string res = \"\";\r\n        for(int i = 0; i < s_len; i++) {\r\n            if(s[i]>='0' && s[i]<='9') {\r\n                num = 10*num + s[i]-'0';\r\n            }\r\n            else if((s[i]>='a' && s[i]<='z') || (s[i]>='A' && s[i]<'Z')) {\r\n                cur_str += s[i];\r\n                // cout<< cur_str;\r\n            }\r\n            else if(s[i]=='['){\r\n                strstack.push(cur_str);\r\n                numstack.push(num);\r\n                num = 0;\r\n                cur_str=\"\";\r\n            }\r\n            else if(s[i]==']'){\r\n                int k = numstack.top();\r\n                numstack.pop();\r\n                for(int j = 0; j <k; j++){\r\n                    strstack.top() += cur_str;\r\n                }\r\n                cur_str = strstack.top();\r\n                strstack.pop();\r\n                \r\n            }\r\n    }\r\n    return cur_str;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919073145","body":"```\r\nclass MyQueue:\r\n    main_stack = None\r\n    help_stack = None\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        \r\n        self.main_stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.main_stack:\r\n            self.help_stack.append(self.main_stack.pop(-1))\r\n        self.main_stack.append(x)\r\n        while self.help_stack:\r\n            self.main_stack.append(self.help_stack.pop(-1))\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.main_stack.pop(-1)\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.main_stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.main_stack) == 0\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920948760","body":"```\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n\r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n\r\n        k %= n\r\n        if k == 0:\r\n            return head\r\n\r\n        cur.next = head\r\n        cur = head\r\n        i = 0\r\n        while i != n - 1 - k:\r\n            cur = cur.next\r\n            i += 1\r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921530728","body":"```\r\ndef swapPairs(self, head: ListNode) -> ListNode:\r\n\t\tif head is None: return head\r\n    sentinel = ListNode(-1, None)\r\n    stack = []\r\n    curr = head\r\n    last = sentinel\r\n    while curr:\r\n        if not stack:\r\n            stack.append(curr)\r\n            curr = curr.next\r\n        else:\r\n            new_first = curr      \r\n            curr = curr.next\r\n            new_second = stack.pop(-1)                            \r\n            new_first.next = new_second\r\n            last.next = new_first\r\n            last = new_second            \r\n    if stack:\r\n        last.next = stack.pop(-1)\r\n        last.next.next = None\r\n    else:\r\n        last.next = None\r\n    return sentinel.next\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bxcharlie":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916935576","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& B, int k) {\n         vector<int> result;\n    for (int i = B.size() - 1; i >= 0; i --) {\n        int num = B[i];\n        k += num; \n        int remind = k % 10;\n        result.insert(result.begin(), remind);\n        k /= 10;\n    }\n    if (k) {\n        while (k > 9) { \n            int remind = k % 10;\n            result.insert(result.begin(), remind);\n            k /= 10;\n        }\n        result.insert(result.begin(), k);\n    }\n    return result;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917424870","body":"# C++ \n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> answer(s.size());\n        int prev = -100000;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == c) {\n                prev = i;\n            }\n            answer[i] = i - prev;\n        }\n        prev = 20000;\n        for (int i = s.size() - 1; i >= 0; i--) {\n            if (s[i] == c){\n                prev = i;\n            }\n            answer[i] = min(answer[i], prev - i);\n        }\n        return answer;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657004","body":"```C++\nclass CustomStack {\nprivate:\n    int m_maxSize = 0;\n    vector<int> stk;\npublic:\n    CustomStack(int maxSize) {\n        m_maxSize = maxSize;\n    }\n    \n    void push(int x) {\n        if(stk.size() == m_maxSize){\n            return;\n        }\n        stk.push_back(x);\n    }\n    \n    int pop() {\n        if(stk.empty()){\n            return -1;\n        }\n        int top = stk.back();\n        stk.pop_back();\n        return top;\n    }\n    \n    void increment(int k, int val) {\n        int i = 0;\n        while(i < k && i < stk.size()){\n            stk[i] += val;\n            i++;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918296121","body":"```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res;\n        stack<pair<int, string>> stk;\n        int count = 0;\n        for(auto c : s){\n            if(isdigit(c)){\n                 count = count*10 + (c-'0');\n            }\n        else if(c == '['){\n            stk.push({count,res});\n            count = 0;\n            res = \"\";\n        }\n        else if(c == ']'){\n            auto p = stk.top();\n            stk.pop();\n            string tmp = res;\n            for(int i = 1; i < p.first; i++){\n                res += tmp;\n            }\n            res = p.second + res;\n        }\n        else{\n            res += c;\n        }\n    }\n    return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919256702","body":"```java\nclass MyQueue {\n    Queue<Integer> queue;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        queue = new LinkedList<Integer>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        queue.add(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        return queue.poll();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        return queue.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920080140","body":"```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> sta;\n        for(int i = 0; i<arr.size(); i++){\n            if(!sta.empty() && sta.top() > arr[i]){\n                int head  = sta.top();\n                while(!sta.empty() && sta.top() > arr[i]){\n                    sta.pop();\n                }\n                sta.push(head);\n            }else{\n                sta.push(arr[i]);\n            }\n        }\n        return sta.size();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920991996","body":"```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode *pst = head;\n        ListNode *last = NULL;\n        int count = 0;\n        while(pst != NULL){\n            ++count;\n            last = pst;\n            pst = pst->next; \n        }\n        if(count == 0){\n            return head;\n        }\n        int actual = k % count;\n        last -> next = head;\n        pst = head;\n        for(int i = 0;i < count - actual - 1;++i){\n            pst = pst->next;\n        }\n        head = pst->next;\n        pst->next = NULL;\n        return head;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921858478","body":"```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode fakeHead(0,head);\n        ListNode *pre = &fakeHead, *p = head;\n        while(p && p->next){\n            pre->next = p->next;\n            pre = p->next;\n            p->next = pre->next;\n            pre->next = p;\n            p = p->next;\n            pre = pre->next;\n        }\n        return fakeHead.next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922326756","body":"```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* create(ListNode* head, ListNode* end){\n        if(head == nullptr || head == end) return nullptr;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast != end && fast  -> next != end){\n            slow = slow -> next;\n            fast = fast -> next -> next;\n        }\n        TreeNode* root = new TreeNode(slow -> val);\n        root -> left = create(head, slow);\n        root -> right = create(slow -> next, end);\n        return root;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n          return create(head, nullptr);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922486471","body":"```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n         if (!headA || !headB) {\n            return NULL;\n        }\n        ListNode *a = headA, *b = headB;\n        while (a != b) { \n            a = a ? a->next : headB; \n            b = b ? b->next : headA; \n        }\n        return a;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zszs97":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916938349","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 1 】2021-09-10 - 989. 数组形式的整数加法 \r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n1、注意进位\r\n2、如果全部加完还有进位，需要特殊处理。 比如 A = [2], K = 998\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> sum;\r\n        int size = num.size();\r\n        for(int i = size-1;i>=0;i--)\r\n        {\r\n            int nsum = num[i] + k % 10;\r\n            k/= 10;\r\n            if(nsum>=10)\r\n            {\r\n                k++;\r\n                nsum-=10;\r\n            }\r\n            sum.push_back(nsum);\r\n        }\r\n        //如果全部加完还有进位 如2+998\r\n        while(k>0)\r\n        {\r\n            sum.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(sum.begin(),sum.end());\r\n        return sum;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(1)\r\n+ 时间复杂度 O(n + logk + resLength)，其中 n 为数组的长度；resLength是res这个vector的长度，来自于reverse的时间消耗\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917423261","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 2 】2021-09-11 - (821. 字符的最短距离)\r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n+ 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\r\n+ 只在一个方向找到的话，直接计算字符距离\r\n+ 两个方向都找到的话，取两个距离的最小值\r\n+ 正反两趟遍历，比较与c的距离，取小的值\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> str(s.length());\r\n\r\n        for(int i = 0;i<s.length();i++)\r\n        {\r\n            if(s[i] == c) continue;\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n            while(left >0 || right <= s.length()-1){  //left:往左边的指针 right：往右边的指针\r\n                if(s[left] == c) {\r\n                    dist = i-left;\r\n                    break;\r\n                }\r\n                if(s[right] == c){\r\n                    dist = right -i;\r\n                    break;\r\n                }\r\n                if(left>0) left--;\r\n                if(right<s.length()-1) right++;\r\n            }\r\n            str[i] = dist;\r\n        }\r\n        return str;\r\n        \r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(N)\r\n+ 时间复杂度 O(N)，其中 N 为数组的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917590698","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 3 】2021-09-12 - (1381. 设计一个支持增量操作的栈)\r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n+ 用数组模拟栈 设置top和最大长度\r\n+ 只用判断k和长度的大小，哪个小就循环多少次的增加val\r\n\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);  //resize()设置当前容器大小\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top != stack.size()-1)\r\n        {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if( top == -1)\r\n        return -1;\r\n        --top;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int y = min(top+1,k);\r\n        for(int i = 0;i<y;i++)\r\n            stack[i]+=val;\r\n        \r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(maxSize)\r\n+ 时间复杂度 O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918319855","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 4 】2021-09-13 - (394. 字符串解码)\r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n+ 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\r\n+ 如果当前的字符为字母或者左括号，直接进栈\r\n+ 如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字，就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    string getDigits(string &s, size_t &ptr) {\r\n        string ret = \"\";\r\n        while (isdigit(s[ptr])) {\r\n            ret.push_back(s[ptr++]);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string getString(vector <string> &v) {\r\n        string ret;\r\n        for (const auto &s: v) {\r\n            ret += s;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        vector <string> stk;\r\n        size_t ptr = 0;\r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n            if (isdigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                string digits = getDigits(s, ptr);\r\n                stk.push_back(digits);\r\n            } else if (isalpha(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.push_back(string(1, s[ptr++])); \r\n            } else {\r\n                ++ptr;\r\n                vector <string> sub;\r\n                while (stk.back() != \"[\") {\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(), sub.end());\r\n                // 左括号出栈\r\n                stk.pop_back();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = stoi(stk.back()); \r\n                stk.pop_back();\r\n                string t, o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime--) t += o; \r\n                // 将构造好的字符串入栈\r\n                stk.push_back(t);\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(S) S为字符串长度\r\n+ 时间复杂度 O(S)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919123953","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 5 】2021-09-13 - (232. 用栈实现队列)\r\n-------------------\r\n\r\n\r\n### 题目思路\r\n+ 将一个栈当作输入栈，用于压入push 传入的数据；另一个栈当作输出栈，用于pop 和peek 操作。\r\n+ 每次pop或peek时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\r\n \r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度：O(n)O(n)。其中 nn 是操作总数。对于有 n 次 push 操作的情况，队列中会有 nn 个元素，故空间复杂度为 O(n)\r\n+ 时间复杂度：push 和empty 为 O(1)，pop 和 peek 为均摊 O(1)。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919980208","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 6 】2021-09-15 - (768. 最多能完成排序的块 II)\r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n+ 单调栈\r\n\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> stack;\r\n        for(int i =0;i<arr.size();i++){\r\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\r\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\r\n            if(!stack.empty()&&stack.top()>arr[i]){\r\n                // 我们需要将融合后的区块的最大值重新放回栈\r\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\r\n                int cur = stack.top();\r\n                // 维持栈的单调递增\r\n                while(!stack.empty()&&stack.top()>arr[i]){\r\n                    sstackta.pop();\r\n                }\r\n                stack.push(cur);\r\n            }else{\r\n                stack.push(arr[i]);\r\n            }\r\n        }\r\n        // 栈存的是块信息，因此栈的大小就是块的数量\r\n        return stack.size();\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(N) N为数组长度\r\n+ 时间复杂度 O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920679414","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 7 】2021-09-16 - (61. 旋转链表)\r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n+ 记给定链表的长度为 n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n 次即可。因为每 n 次移动都会让链表变为原状。\r\n+ 这样我们可以知道，新链表的最后一个节点为原链表的第 (n - 1) - (k mod n)个节点（从 0 开始计数）。这样，我们可以先将给定的链表连接成环，然后将指定位置断开。\r\n+ 具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n - 1) - (k mod n) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。\r\n+ 特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。\r\n\r\n\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(k==0 || head == nullptr ||head->next == nullptr) //链表为0或者链表只有一个数据或者不移动\r\n        {\r\n            return head;\r\n        }\r\n        int n = 1; //长度\r\n        ListNode* iter = head;\r\n        while(iter->next!=nullptr){\r\n            iter = iter->next;\r\n            n++;\r\n        }\r\n        int add = n-k%n;//新链表的最后一个节点\r\n        if(add == n){\r\n            return head;\r\n        }\r\n        iter->next = head;\r\n        while(add--){\r\n            iter = iter->next;\r\n        }\r\n        ListNode* ret = iter->next;\r\n        iter->next = nullptr;\r\n        return ret;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(1)\r\n+ 时间复杂度 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921399439","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 8 】2021-09-17 - (24. 两两交换链表中的节点)\r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n+ 反转链表\r\n+ 递归\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        ListNode* newHead = head->next;\r\n        head->next = swapPairs(newHead->next);\r\n        newHead->next = head;\r\n        return newHead;\r\n    }\r\n};\r\n\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(n) n为链表的节点数量\r\n+ 时间复杂度 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922279351","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 9 】2021-09-18 - (109. 有序链表转换二叉搜索树)\r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n+ 可以找出链表元素的中位数作为根节点的值\r\n+ 根据中位数的性质，链表中小于中位数的元素个数与大于中位数的元素个数要么相等，要么相差 11。此时，小于中位数的元素组成了左子树，大于中位数的元素组成了右子树，它们分别对应着有序链表中连续的一段。在这之后，我们使用分治的思想，继续递归地对左右子树进行构造，找出对应的中位数作为根节点，以此类推。\r\n+ 对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题。这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解，这种算法设计策略叫做分治法。\r\n+ 找出链表中位数节点的方法多种多样，其中较为简单的一种是「快慢指针法」。初始时，快指针和慢指针均指向链表的左端点。我们将快指针向右移动两次的同时，将慢指针向右移动一次，直到快指针到达边界（即快指针到达右端点或快指针的下一个节点是右端点）。此时，慢指针对应的元素就是中位数。\r\n\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    ListNode* getMedian(ListNode* left, ListNode* right) {\r\n        ListNode* fast = left;\r\n        ListNode* slow = left;\r\n        while (fast != right && fast->next != right) {\r\n            fast = fast->next;\r\n            fast = fast->next;\r\n            slow = slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n\r\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\r\n        if (left == right) {\r\n            return nullptr;\r\n        }\r\n        ListNode* mid = getMedian(left, right);\r\n        TreeNode* root = new TreeNode(mid->val);\r\n        root->left = buildTree(left, mid);\r\n        root->right = buildTree(mid->next, right);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        return buildTree(head, nullptr);\r\n    }\r\n};\r\n\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(nlogn) n为链表长度\r\n+ 时间复杂度 O(nlogn)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922483958","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 10】2021-09-19 - (160. 相交链表)\r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n+ 双指针\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (headA == nullptr || headB == nullptr) {\r\n            return nullptr;\r\n        }\r\n        ListNode *pA = headA, *pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == nullptr ? headB : pA->next;\r\n            pB = pB == nullptr ? headA : pB->next;\r\n        }\r\n        return pA;\r\n    }\r\n};\r\n\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(1) \r\n+ 时间复杂度 O(m+n) m和n分别为A,B的长度\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yj9676":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916941829","body":"## LC989 数组形式的整数加法\r\n### Array\r\n\r\n---\r\n### 思路\r\n与LC2 两数相加类似，从末位开始逐位相加，最后判断carry是否为0\r\n\r\n```\r\nwhile (元素A不为null或者未结束 || 元素B不为null或者未结束)\r\n    currA\r\n    currB\r\n\r\n    sum = currA + currB + carry\r\n\r\n    curr = sum % 10;\r\n    carry = sum / 10;\r\n```\r\n#### Solution\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<Integer>();\r\n        int step = len - 1;\r\n        int sum = 0;\r\n        int carry = 0;\r\n\r\n        while (step >= 0 || k != 0){\r\n            int x = step >= 0 ? num[step] : 0;\r\n            int y = k != 0 ? k % 10 : 0;\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            k = k / 10;\r\n\r\n            ans.add(sum % 10);\r\n            step--;\r\n        }\r\n\r\n        if (carry != 0){\r\n            ans.add(carry);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n* 时间复杂度 : *O(max(num.length, logk))*\r\n\r\n* 空间复杂度 : *O(1)* \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917395387","body":"## LC821 字符的最短距离\n### String\n\n---\n### 思路\n遍历两次，一次从左遍历，一次从右遍历，判断两次距离上次字符C所在位置距离的最短\n\n#### Solution\n\n```\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int len = S.length();\n        int[] ans = new int[len];\n        int cPosition = -100000;\n\n        for (int i = 0; i < len; ++i) {\n            if (S.charAt(i) == C) cPosition = i;\n            ans[i] = i - cPosition;\n        }\n\n        cPosition = 100000;\n        for (int i = len-1; i >= 0; --i) {\n            if (S.charAt(i) == C) cPosition = i;\n            ans[i] = Math.min(ans[i], cPosition - i);\n        }\n\n        return ans;\n    }\n}\n\n```\n\n**复杂度分析**\n\n* 时间复杂度 : *O(n)*\n\n* 空间复杂度 : *O(n)* \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917627418","body":"[TOC]\n## LC1381 设计一个支持增量操作的栈 [Medium]\n**Design a Stack With Increment Operation**\n\n- None\n- [link](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n---\n### 思路1\nstack是已知顶部元素的结构，需要一个变量记录最顶部当前位置\npop和push常规stack操作\n对于Inc函数，需要整个stack元素都已知，可以采用数组来模拟\n\n#### Solution1\n\n```\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        int maxSize = stack.length;\n        if(top != maxSize - 1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top > -1){\n            int popNum = stack[top];\n            top--;\n            return popNum;\n        }else{\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n         int maxAdded = Math.min(k, top+1);\n         for(int i=0; i<maxAdded; i++){\n             stack[i] += val;\n         }\n    }\n}\n\n```\n**复杂度分析**\n\n* 时间复杂度 : 初始化/push/pop *O(1)*, Inc *O(k)*\n\n* 空间复杂度 : *O(maxSize)* \n\n---\n### 思路2\n如果采用数组模拟需要遍历数组的所有元素\n可以采用一个add[]数组，记录每次执行inc函数前k个变化的增量\n再进行pop操作时只需要top+增量就可以知道最终值,然后将最顶端的值往下传递，add[top-1] += add[top]\n\n#### Solution2\n\n```\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        int maxSize = stack.length;\n        if(top != maxSize - 1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1){\n            return -1;\n        }\n        int ans = stack[top]+add[top];\n        if (top>0){\n            add[top-1] += add[top];\n        }\n        add[top] = 0;\n        top--;\n        return ans;\n    }\n    \n    public void increment(int k, int val) {\n         int maxAdded = Math.min(k-1, top);\n         if (maxAdded >= 0){\n             add[maxAdded] += val;\n         }\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度 : *O(1)*\n\n* 空间复杂度 : *O(maxSize)* \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918268576","body":"[TOC]\n## LC394 字符串解码 [Medium]\n**Decode String**\n\n- Stack / DFS\n- [link](https://leetcode.com/problems/decode-string/)\n---\n### 思路1 [Stack]\n题中方括号成对出现，解题思路类似括号匹配（[LC20 有效括号](https://leetcode-cn.com/problems/valid-parentheses/)）\n可以采用一个stack作为辅助，将非 **\"]\"** 都压入stack中，如果遇到 **\"]\"** ,则pop出来，判断是否是字符，遇到 **\"[\"** 则pop后，开始判断是否是数字，再将字符串按倍数扩展押入stack中\n\n### Solution\n\n```\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()){\n            if (c != ']'){\n                stack.push(c);\n            }else{\n                StringBuilder sb = new StringBuilder();\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())){\n                    sb.insert(0, stack.pop());\n                }\n                String str = sb.toString();\n                stack.pop();\n\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    sb.insert(0, stack.pop());\n                }\n                int count = Integer.parseInt(sb.toString());\n\n                while(count > 0){\n                    for (char ch : str.toCharArray()){\n                        stack.push(ch);\n                    }\n                    count--;\n                }\n            }\n        }\n        StringBuilder ans = new StringBuilder();\n        while(!stack.isEmpty()){\n            ans.insert(0, stack.pop());\n        }\n        return ans.toString();\n    }\n}\n\n```\n\n**复杂度分析**\n\n* 时间复杂度 : *O(n)*\n\n* 空间复杂度 : *O(n)* \n\n---\n### 思路2 [DFS]\n使用递归（DFS）后续复习递归补上\n\n### Solution\n```\n//Todo\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919226617","body":"[TOC]\n## LC232 用栈实现队列 [Easy]\n**Implement Queue using Stacks**\n\n- Stack\n- [link](https://leetcode.com/problems/implement-queue-using-stacks/)\n---\n### 思路\n使用双栈实现，s1和s2。push操作只需要往s1中push，pop的时候，若s2为空，需要将s1里面的数据pop然后再依次塞入s2中，实现逆序\n如果s2不为空，直接从s2中pop结果。s1和s2都为空才代表队列为空\n\n相似题还有[LC225](https://leetcode.com/problems/implement-stack-using-queues/),使用队列实现栈\n\n### Solution\n\n```\nclass MyQueue {\n    Stack<Integer> s1;\n    Stack<Integer> s2;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        s1 = new Stack<Integer>();\n        s2 = new Stack<Integer>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (s2.isEmpty() && !s1.isEmpty()){\n            while(!s1.isEmpty()){\n                int temp = s1.pop();\n                s2.push(temp);\n            }\n        }\n        return s2.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (s2.isEmpty() && !s1.isEmpty()){\n            while(!s1.isEmpty()){\n                int temp = s1.pop();\n                s2.push(temp);\n            }\n        }\n        return s2.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        if (s1.isEmpty() && s2.isEmpty()){\n            return true;\n        }\n        return false;\n    }\n}\n\n```\n\n**复杂度分析**\n\n* 时间复杂度 : \n1. Push(): *O(1)* \n2. Pop()/Peek(): *O(n)* \n3. Empty(): *O(1)*\n\n* 空间复杂度 : *O(n)* \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920143937","body":"[TOC]\r\n## LC768 最多能完成排序的块 II [Hard]\r\n**Max Chunks To Make Sorted II**\r\n\r\n- Monotone Stack / Hashmap\r\n- [link](https://leetcode.com/problems/max-chunks-to-make-sorted-ii/)\r\n---\r\n### 思路1 [Stack]\r\n来源于官方题解，使用单调栈计数，通过查找下一个元素是否比当前这个小来判断是否分块，查找到需要分为一块的数字后，融合将最大的押回，继续判断\r\n\r\n### Solution\r\n\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        if (arr.length == 0) return 0;\r\n\r\n        Stack<Integer> stack = new Stack<>();\r\n        for (int i=0; i<arr.length; i++){\r\n            if (!stack.isEmpty() && arr[i] < stack.peek()){\r\n                int curr = stack.pop();\r\n                while(!stack.isEmpty() && arr[i] < stack.peek()){\r\n                    stack.pop();\r\n                }\r\n                stack.push(curr);\r\n            }else{\r\n                stack.push(arr[i]);\r\n            }\r\n        }\r\n        return stack.size();\r\n        \r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n* 时间复杂度 : *O(n)*\r\n\r\n* 空间复杂度 : *O(n)* \r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920969300","body":"[TOC]\n## LC61 旋转链表 [Medium]\n**Rotate List**\n\n- LinkedList\n- [link](https://leetcode.com/problems/rotate-list/description/)\n---\n### 思路\n使用快慢指针找到第k个点\n右移k和k%length是一致，找到了第k个殿后，将每个原有的node移动到length-k%length的位置\nStep：\n1. 找到链表长度\n2. 移动到length-k%length的位置\n3. 进行旋转\n\n### Solution\n\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null){\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow = dummy;\n\n        int length = 0;\n        // Get the length of the linkelist\n        while(fast.next != null){\n            fast = fast.next;\n            length++;\n        }\n\n        // Find the length - length % length node\n        for(int j = length - (k % length); j>0; j--){\n            slow = slow.next;\n        }\n\n        // Rotate the list\n        fast.next = dummy.next;\n        dummy.next = slow.next;\n        slow.next = null;\n\n        return dummy.next;\n    }\n}\n\n```\n\n**复杂度分析**\n\n* 时间复杂度 : *O(n)* \n\n* 空间复杂度 : *O(1)* \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921858982","body":"[TOC]\n## LC24 两两交换链表中的节点 [Medium]\n**Swap Nodes in Pairs**\n\n- LinkedList\n- [link](https://leetcode.com/problems/swap-nodes-in-pairs/description/)\n---\n### 思路1 Recursive\n遍历和递归两种都可以，递归更加直观\n递归只需要考虑最小结构，也就是两个点是如何交换的，末尾的next指向下一次递归的结果\n\npreA -> A -> B -> nextB\n1. preA -> A -> nextB\n           B -> nextB\n2. preA -> A -> nextB\n      B -> A\n3. preA -> B -> A -> nextB\n```\nA.next = nextB;\nB.next = A;\npreA.next = B;\n```\n\n### Solution1\n\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next== null){\n            return head;\n        }\n        ListNode temp = head.next;\n        head.next = swapPairs(head.next.next);\n        temp.next = head;\n        return temp;\n\n    }\n}\n\n```\n**复杂度分析**\n\n* 时间复杂度 : *O(n)* \n\n* 空间复杂度 : *O(1)* \n\n---\n### 思路2 Iterative\nplaceholder\n\n### Solution2\nplaceholder\n\n**复杂度分析**\n\n* 时间复杂度 : *O(n)* \n\n* 空间复杂度 : *O(1)* \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922270582","body":"[TOC]\n## LC61 有序链表转换二叉搜索树 [Medium]\n**Convert Sorted List to Binary Search Tree**\n\n- LinkedList\n- [link](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/)\n---\n### 思路\n链表有序，可以找到中点，左边小的作为左子树，右边大的作为右子树\n进行递归不断寻找\n\n找中点可以使用快慢指针，快指针每次走两各，慢指针每次走一格，当快指针到末尾时，慢指针刚好到中点\n\n### Solution\n\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return head;\n        return constructBST(head, null);\n    }\n\n    private TreeNode constructBST (ListNode head, ListNode tail){\n        ListNode slow = head;\n        ListNode fast = head;\n        if (tail == null){\n            return null;\n        }\n\n        while (fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            tail = slow.next;\n        }\n\n        TreeNode t = new TreeNode(slow.val);\n        t.left = constructBST(head, slow);\n        t.right = constructBST(slow.next, tail);\n        return t;\n    }\n}\n\n```\n\n**复杂度分析**\n\n* 时间复杂度 : *O(nlogn)* \n\n* 空间复杂度 : *O(nlogn)* \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922452532","body":"[TOC]\n## LC160 相交链表 [Easy]\n**RIntersection of Two Linked Lists**\n\n- LinkedList\n- [link](https://leetcode.com/problems/intersection-of-two-linked-lists/description/)\n---\n### 思路\n只需要关注两个指针是否同时到达相交点\n使用两次循环来实现，第一次循环时候，当某一list到达尾部后，重新设置到另一个list的头部，这是为了抵消掉差异点\n第二次循环同时移动，知道找到相同点\n如果没有相交点，那么结束循环后，都是list尾部，都为tail\n\n1 -> 2 -> 3 -> 4 -> 5\n\n8 -> 3 -> 4 -> 5\n\n### Solution\n\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null){\n            return null;\n        }\n\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while (a != b){\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n\n        return a;\n    }\n}\n\n```\n\n**复杂度分析**\n\n* 时间复杂度 : *O(n)* \n\n* 空间复杂度 : *O(1)* \n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carreylife":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916945203","body":"### 思路\n加法运算，用 `carry` 来表示进位，反向遍历数组即可。\n\n遍历结束条件：\n\n1. 数组所有元素都遍历过了\n2. 当 K 为 0 的时候\n\n需要注意的点：\n\n如果遍历结束后 `carry` 大于 0，还需要在数组前面补一位。\n\n### JS代码\n```javascript\nvar addToArrayForm = function(A, K) {\n  const res = []\n  let i = A.length - 1, carry = 0\n  while (i >=0 || K != 0) {\n      const x = i >= 0 ? A[i] : 0\n      const y = K != 0 ? K % 10 : 0\n\n      const sum = x + y + carry\n      res.push(sum % 10)\n      carry = Math.floor(sum / 10)\n\n      i--\n      K = Math.floor(K / 10)\n  }\n  if (carry) res.push(carry)\n  return res.reverse()\n};\n```\n\n**复杂度分析**\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917415190","body":"### 思路\n正反两边同时遍历找到距离目标值最小的距离\n\n### 代码\n```js\n/**\n * @param {string} s = \"loveleetcode\"\n * @param {character} c = \"e\"\n * @return {number[]} [3,2,1,0,1,0,0,1,2,2,1,0]\n */\nvar shortestToChar = function (s, c) {\n  let res = Array(s.length).fill(0);\n\n  for (let i = 0; i < s.length; i++) {\n    // 如果当前位置是目标字符就跳出\n    if (s[i] === c) continue;\n    // 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let left = i,\n      right = i,\n      shortest = Infinity;\n\n    while (left >= 0) {\n      if (s[left] === c) {\n        shortest = Math.min(shortest, i - left);\n        break;\n      }\n      left--;\n    }\n\n    while (right < s.length) {\n      if (s[right] === c) {\n        shortest = Math.min(shortest, right - i);\n        break;\n      }\n      right++;\n    }\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n***复杂度***\n\n- 时间复杂度: O(N^2)\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917627794","body":"### 思路\n使用数组来模拟栈\n### 代码 js\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.list = [];\n  this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.list.length < this.maxSize) {\n    this.list.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  const item = this.list.pop();\n  return item === void 0 ? -1 : item;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k && i < this.list.length; i++) {\n      this.list[i] += val;\n  }\n};\n```\n***复杂度分析***\n- 时间复杂度  `push` 和 `pop` 是 $O(1)$，`increment ` 是 $O(k)$。\n- 空间复杂度  空间复杂度：$O(maxSize)$。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918274198","body":"### 思路\n按照官方题解思路\n\n### 代码 Python\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n                # pop 掉 \"[\"\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```\n***复杂度***\n- 时间复杂度 O(N)\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919098568","body":"思路\r\n---\r\n- 在 push 的时候利用辅助栈（双栈）\r\n\r\n代码\r\nJavaScript Code:\r\n---\r\n\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function () {\r\n  this.stack = [];\r\n  this.helpStack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue.\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n  let cur = null;\r\n  while (cur === this.stack.pop()) {\r\n    this.helpStack.push(cur);\r\n  }\r\n  this.helpStack.push(x);\r\n\r\n  while (cur === this.helpStack.pop()) {\r\n    this.stack.push(cur);\r\n  }\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n  return this.stack.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n  return this.stack[this.stack.length - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n  return this.stack.length === 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n***复杂度***\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919955849","body":"思路\n---\n- 按照官方题解思路\n\n代码 javascript\n---\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n  const stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    a = arr[i];\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\n      const cur = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > a) stack.pop();\n      stack.push(cur);\n    } else {\n      stack.push(a);\n    }\n  }\n  return stack.length;\n};\n```\n***复杂度***\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920751390","body":"思路\n---\n- 参考官方题解思路\n\n代码\n---\n- 语言支持：JavaScript\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head || !head.next) return head;\n  let count = 0,\n    now = head;\n\n  while (now) {\n    now = now.next;\n    count++;\n  }\n\n  k = k % count;\n  let slow = (fast = head);\n  while (fast.next) {\n    if (k-- <= 0) {\n      slow = slow.next;\n    }\n    fast = fast.next;\n  }\n  fast.next = head;\n  let res = slow.next;\n  slow.next = null;\n  return res;\n};\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921738728","body":"思路\n---\n参考官方题解思路\n\n代码\n---\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  if (!head || !head.next) return head;\n  let res = head.next;\n  let now = head;\n  let preNode = new ListNode();\n  preNode.next = head;\n  while (now && now.next) {\n    let nextNode = now.next;\n    let nnNode = nextNode.next;\n    now.next = nnNode;\n    nextNode.next = now;\n    preNode.next = nextNode;\n    preNode = now;\n    now = nnNode;\n  }\n  return res;\n};\n\n```\n***复杂度***\n- 时间复杂度: O(N)\n- 空间负责度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922279481","body":"思路\n---\n官方题解\n\n代码\n---\nJavascript Code\n```js\nvar sortedListToBST = function (head) {\n  if (!head) return null;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast != tail && fast.next != tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head, slow);\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n```\n***复杂度***\n- 时间复杂度: 递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn)\n- 空间复杂度: 空间复杂度为O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922473581","body":"思路\n---\n参考官方题解\n\n代码\n---\nJavascript Code\n```js\nlet data = new Set();\nwhile (A !== null) {\n  data.add(A);\n  A = A.next;\n}\nwhile (B !== null) {\n  if (data.has(B)) return B;\n  B = B.next;\n}\nreturn null;\n```\n***复杂度***\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fzzfgbw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916945692","body":"### 思路\r\n\r\n从后往前加、再反转\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\tvar res []int\r\n\tfor i:= len(num)-1;i>=0||k>0;i-- {\r\n\t\tif i >= 0 {\r\n\t\t\tk+=num[i]\r\n\t\t}\r\n\t\tres = append(res,k%10)\r\n\t\tk/=10\r\n\t}\r\n\tfor i,n:=0,len(res);i<n/2 ;i++{\r\n\t\tres[i],res[n-i-1] = res[n-i-1],res[i]\r\n\t}\r\n\treturn res\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(n,log(k)))。\r\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917041009","body":"### 思路\n\n从左遍历，找到左边最近距离；\n从右边遍历，找到右边最近的距离并与之前左边最近距离相比较。\n\n### 代码\n\n\n```go\nfunc shortestToChar(s string, c byte) []int {\n\tvar ans []int\n\tcurr := -len(s)\n\tfor i := range s {\n\t\tif s[i] == c {\n\t\t\tcurr = i\n\t\t\tans = append(ans, 0)\n\t\t} else {\n\t\t\tans = append(ans, i-curr)\n\t\t}\n\t}\n\tcurr = 2*len(s)\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\tif s[i] != c {\n\t\t\tif curr-i < ans[i] {\n\t\t\t\tans[i] = curr - i\n\t\t\t}\n\t\t} else {\n\t\t\tcurr = i\n\t\t}\n\t}\n\treturn ans\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917442498","body":"### 思路\n\n\n\n### 代码\n\n\n```go\ntype CustomStack struct {\n\tstack []int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{make([]int, 0,maxSize)}\n}\n\nfunc (this *CustomStack) Push(x int) {\n\tif len(this.stack) < cap(this.stack) {\n\t\tthis.stack = append(this.stack, x)\n\t}\n}\n\nfunc (this *CustomStack) Pop() int {\n\tif len(this.stack) > 0 {\n\t\tres := this.stack[len(this.stack)-1]\n\t\tthis.stack = this.stack[:len(this.stack)-1]\n\t\treturn res\n\t} else {\n\t\treturn -1\n\t}\n}\n\nfunc (this *CustomStack) Increment(k int, val int) {\n\tif k > len(this.stack) {\n\t\tk = len(this.stack)\n\t}\n\tfor i := 0; i < k; i++ {\n\t\tthis.stack[i] += val\n\t}\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度： push 、pop O(1)    increment：（O(min(k,len(stack)))）\n- 空间复杂度：O(1)。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918043208","body":"### 思路\n\n\n\n### 代码\n\n\n```go\nfunc decodeString(s string) string {\n\tvar stack []uint8\n\tfor i := range s {\n\t\tif s[i] != ']' {\n\t\t\tstack = append(stack, s[i])\n\t\t} else {\n\t\t\tvar left int\n\t\t\tvar dup []uint8\n\t\t\tvar times int\n\t\t\tvar mul = 1\n\t\t\tfor j := len(stack) - 1; j >= 0; j-- {\n\t\t\t\tif stack[j] == '[' {\n\t\t\t\t\tleft = j + 1\n\t\t\t\t\tfor i2 := range stack[left:] {\n\t\t\t\t\t\tdup = append(dup,stack[left:][i2])\n\t\t\t\t\t}\n\t\t\t\t\tj--\n\t\t\t\t\tfor  j >= 0 && '0' <= stack[j] && stack[j] <= '9' {\n\t\t\t\t\t\ttimes += int(stack[j]-48) * mul\n\t\t\t\t\t\tmul *= 10\n\t\t\t\t\t\tj--\n\t\t\t\t\t}\n\n\t\t\t\t\tstack = stack[:j+1]\n\t\t\t\t\tfor times>0 {\n\t\t\t\t\t\tstack  = append(stack,dup...)\n\t\t\t\t\t\ttimes--\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t}\n\tvar res string\n\tfor i := range stack {\n\t\tres+=string(stack[i])\n\t}\n\treturn res\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(N)。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918361617","body":"### 思路\n\n\n\n### 代码\n\n\n```go\n\ntype MyQueue struct {\n\tstack []int\n}\n\n\n/** Initialize your data structure here. */\nfunc Constructor() MyQueue {\n\treturn MyQueue{}\n}\n\n\n/** Push element x to the back of queue. */\nfunc (this *MyQueue) Push(x int)  {\n\tthis.stack = append(this.stack,x)\n}\n\n\n/** Removes the element from in front of queue and returns that element. */\nfunc (this *MyQueue) Pop() int {\n\tpop:=this.stack[0]\n\tthis.stack = this.stack[1:]\n\treturn pop\n}\n\n\n/** Get the front element. */\nfunc (this *MyQueue) Peek() int {\n\treturn this.stack[0]\n}\n\n\n/** Returns whether the queue is empty. */\nfunc (this *MyQueue) Empty() bool {\n\treturn len(this.stack) == 0\n}\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)。\n- 空间复杂度：O(1)。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920115127","body":"### 思路\n\n单调递增栈，栈中每个元素为改组的最大值\n\n### 代码\n\n\n```go\nfunc maxChunksToSorted(arr []int) int {\n\tvar memo []int\n\tn := len(arr)\n\tfor i := 0; i < n; i++ {\n\t\tif len(memo) == 0 || arr[i] >= memo[len(memo)-1] {\n\t\t\tmemo = append(memo, arr[i])\n\t\t} else {\n\t\t\ttop := memo[len(memo)-1]\n\t\t\tmemo = memo[:len(memo)-1]\n\t\t\tfor len(memo) != 0 && memo[len(memo)-1] > arr[i] {\n\t\t\t\tmemo = memo[:len(memo)-1]\n\t\t\t}\n\t\t\tmemo = append(memo, top)\n\t\t}\n\t}\n\treturn len(memo)\n\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(N)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920837073","body":"### 思路\n\n快慢指针\n### 代码\n\n\n```go\nfunc rotateRight(head *ListNode, k int) *ListNode {\n\tif head == nil {\n\t\treturn head\n\t}\n\tl := 0\n\tfast := head\n\tslow := head\n\tdummy := head\n\tfor head != nil {\n\t\tl++\n\t\thead = head.Next\n\t}\n\tk %= l\n\n\tfor k > 0 {\n\t\tk--\n\t\tfast = fast.Next\n\t}\n\tfor fast.Next != nil {\n\t\tfast = fast.Next\n\t\tslow = slow.Next\n\t}\n\tnewHead := slow.Next\n\tslow.Next = nil\n\tfast.Next = dummy\n\treturn newHead\n\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921429385","body":"### 思路\n\n递归\n\n### 代码\n\n\n```go\n\nfunc swapPairs(head *ListNode) *ListNode {\n    if head == nil ||head.Next == nil{\n        return head\n    }\n    res:=head.Next\n    next:=swapPairs(head.Next.Next)\n    res.Next = head\n    head.Next = next\n    return res\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921967267","body":"### 思路\n\n遍历节点值，再递归\n\n### 代码\n\n\n```go\nfunc sortedListToBST(head *ListNode) *TreeNode {\n\tif head == nil {\n\t\treturn nil\n\t}\n\tvar s []int\n\tfor head != nil {\n\t\ts = append(s, head.Val)\n\t\thead = head.Next\n\t}\n\treturn dfs(s)\n}\nfunc dfs(s []int) *TreeNode {\n\tif len(s) > 0 {\n\t\treturn &TreeNode{s[len(s)/2], dfs(s[:len(s)/2]), dfs(s[len(s)/2+1:])}\n\t} else {\n\t\treturn nil\n\t}\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(N)。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922412942","body":"### 思路\n\nn1+n2 - s = n2+n1 - s  (n1,n2分别为链表长度，s为交叉点之后的路径长度)\n\n### 代码\n\n\n```go\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n\tif headA == nil || headB == nil {\n\t\treturn nil\n\t}\n\tdummyA := headA\n\tdummyB := headB\n\tfor  headA != headB {\n        if headA.Next == nil && headB.Next == nil  {\n\t\t\treturn nil\n\t\t}\n\t\tif headA.Next == nil {\n\t\t\theadA = dummyB\n\t\t} else {\n\t\t\theadA = headA.Next\n\t\t}\n\t\tif headB.Next == nil {\n\t\t\theadB = dummyA\n\t\t} else {\n\t\t\theadB = headB.Next\n\t\t}\n\t\t\n\t}\n\treturn headA\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n1+n2)。\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922512709","body":"### 思路\n\n\n\n### 代码\n\n\n```go\nfunc detectCycle(head *ListNode) *ListNode {\n\tif head == nil {\n\t\treturn nil\n\t}\n\tfast := head\n\tslow := head\n\tfor fast.Next != nil && fast.Next.Next != nil {\n\t\tfast = fast.Next.Next\n\t\tslow = slow.Next\n\t\tif fast == slow {\n\t\t\tfor head != slow {\n\t\t\t\thead = head.Next\n\t\t\t\tslow = slow.Next\n\t\t\t}\n\t\t\treturn head\n\t\t}\n\t}\n\treturn nil\n\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Zzh-Zh3nDu1":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916946095","body":"## 思路\r\n先在对应位置一一相加，再进行进位操作\r\n\r\n## 代码\r\nJavascript code:\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let temp = 0;\r\n    const kLen = k.toString().length;\r\n    for (let i = 0;i < kLen;i++) {\r\n        if (num.length < kLen) num.unshift(0);\r\n        temp = k % 10;\r\n        k = Math.floor(k / 10);\r\n        num[num.length - 1 - i] += temp;\r\n    }\r\n    const nLen = num.length;\r\n    for (let i = nLen - 1;i > 0;i--) {\r\n        if (num[i] >= 10) {\r\n            num[i - 1] += 1\r\n            num[i] = num[i] % 10;\r\n        }\r\n    }\r\n    if (num[0] >= 10) {\r\n        num[0] = num[0] % 10;\r\n        num.unshift(1);\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度O(max(N,logk))\r\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917405319","body":"## 思路\n先取到所有 c 的 index,存到数组里\n从头 循环字符串,与靠近右边的 c 比较,把结果存到一个数组 res 中\n从尾 循环字符串,与靠左边的 c 比较, 再把这个值与 res 中的结果比较\n\n## 代码 js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n```\nvar shortestToChar = function (s, c) {\n  let cs = []\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == c) {\n      cs.push(i)\n    }\n  }\n  let j = 0,\n    res = []\n  for (let i = 0; i < s.length; i++) {\n    res.push(Math.abs(i - cs[j]))\n\n    if (i == cs[j] && j < cs.length - 1) {\n      j++\n    }\n  }\n\n  for (let i = s.length - 1; i > 0; i--) {\n    if (Math.abs(i - cs[j]) < res[i]) {\n      res[i] = Math.abs(i - cs[j])\n    }\n\n    if (i == cs[j] && j > 0) {\n      j--\n    }\n  }\n\n  return res\n}\n```\n\n## 复杂度分析\n时间复杂度：O(3n)\n空间复杂度：O(3)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918205155","body":"## 思路\n类似括号匹配，遍历字符串，\n如果是数字，就计算当前数字；\n如果是字符，入栈；\n如果是左括号，先把当前计算好的数字入栈，再把左括号入栈；\n如果是右括号，先把栈顶字符串依次出栈并拼接起来，直到碰到左括号。左括号出栈后，栈顶是重复次数，根据次数展开当前字符串后入栈。\n遍历结束后把栈内所有已解码完成的字符串拼接起来。\n\n## 代码\n/**\n * @param {string} s\n * @return {string}\n */\n```\nvar decodeString = function(s) {\n  let stack = [];\n\n  let num = 0;\n  for (let i=0; i<s.length; i++) {\n    if (s[i] >= '0' && s[i] <= '9') {\n      num = num * 10 + (s[i] - '0');\n    } else if (s[i] === '[') {\n      stack.push(num);\n      num = 0;\n      stack.push(s[i]);\n    } else if (s[i] === ']') {\n      let str = '';\n      while (stack[stack.length - 1] !== '[') {\n        str = stack.pop() + str;\n      }\n      stack.pop(); // '['\n\n      let temp = '';\n      let repeat = stack.pop();\n      while (repeat > 0) {\n        temp += str;\n        repeat--;\n      }\n      stack.push(temp);\n    } else {\n      // chars\n      stack.push(s[i]);\n    }\n  }\n\n  let ans = '';\n  while (stack.length !== 0) {\n    ans = stack.pop() + ans;\n  }\n\n  return ans;\n};\n```\n\nTC: O(ans.length)\nSC: O(ans.length)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919044714","body":"## 思路\n用两个栈完成 一个inStack用于输入 一个outStack用于输出\n\n## 代码\n```javascript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(!this.outStack.length){\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.outStack.length){\n        this.in2out();\n    }\n    return this.outStack[this.outStack.length-1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.inStack.length == 0 && this.outStack.length == 0\n};\n\nMyQueue.prototype.in2out = function() {\n    while(this.inStack.length){\n        this.outStack.push(this.inStack.pop());\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n## 复杂度\n时间：O(1)\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919903331","body":"## 思路\n数组进行分块后 每一个分块内的数字与排序后数组对应分块中数字是一样的 只是排序不同\n用滑动窗口扫描排序前后的数组 当窗口中数字的和相同时就分块\n\n## 代码\n```javascript\nvar maxChunksToSorted = function(arr) {\n    let sorted = [...arr].sort((a, b) => a - b);\n    let count = 0, sum1 = 0, sum2 = 0; \n    for(let i = 0; i < arr.length; i++){\n        sum1 += arr[i];\n        sum2 += sorted[i];\n\n        if(sum1 == sum2){\n            count++\n        }\n    }\n    return count;\n};\n```\n\n## 复杂度\n时间复杂度：O(NlogN)O(NlogN)，N 为数组长度，数组排序时间认为是 NlogN，滑动窗口遍历数组时间为 N。\n空间复杂度：O(N)O(N)，N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920541033","body":"## 思路\n循环链表\n当向右移动的次数 k ≥n 时，我们仅需要向右移动 kmodn 次即可。\n我们可以先将给定的链表连接成环，然后将指定位置断开。\n\n## 代码\n```javascript\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n```\n\n## 复杂度\n时间复杂度：O(n)，最坏情况下，我们需要遍历该链表两次。\n空间复杂度：O(1)，我们只需要常数的空间存储若干变量。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921596042","body":"## 思路\n递归\n\n## 代码\n```javascript\nvar swapPairs = function (head) {\n    if (!head || !head.next) return head\n    var one = head\n    var two = one.next\n    var three = two.next\n\n    two.next = one\n    one.next = swapPairs(three)\n\n    return two\n};\n```\n## 复杂度\n1. 时间复杂度：O(n)\n2. 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Weisday":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916946830","body":"#### 思路\n\n​\t将数组倒序遍历，分别使用school method addition，逐位相加。\n\n​\t自己一开始在遍历中没有考虑 `i >= 0 || k > 0` 中的k在数组遍历后不为零的情况。后来在参考别人的解析后意识到了这一点。\n\n#### 代码\n\n~~~c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        res.reserve(num.size() + 1);\n        for (int i = num.size() - 1; i >= 0 || k > 0; --i)\n        {\n            k += (i >= 0 ? num[i] : 0);\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(begin(res), end(res));\n        return res;\n    }\n};\n\n\n~~~\n\n#### 复杂度分析\n\n时间复杂度： O(max(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917415329","body":"#### 思路\n\n正反两次遍历，取更小的一个值\n\n#### 代码\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n);\n\n        int pre = INT_MAX / 2;\n        for(int i = 0; i < n; i++)\n        {\n            if(s[i] == c)\n                pre = i;\n            res[i] = abs(pre - i);\n        }\n        \n        for(int i = n - 1; i >= 0; i--)\n        {\n            if(s[i] == c)\n                pre = i;\n            res[i] = min(res[i], abs(pre - i));\n        }\n        return res;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917645818","body":"#### 代码\n\n```C++\nclass CustomStack {\nprivate:\n    vector<int> vec;\n    int maxsize;\n    \npublic:\n    CustomStack(int maxSize) {\n        maxsize = maxSize;\n        vec.clear();\n        vec.reserve(maxsize);\n    }\n    \n    void push(int x) {\n        if(vec.size() == maxsize)\n            return ;\n        vec.push_back(x);\n    }\n    \n    int pop() {\n        if (vec.empty()) \n            return -1;\n        int res = vec.back();\n        vec.pop_back();\n        return res;\n    }\n    \n    void increment(int k, int val) {\n        k = std::min(static_cast<size_t>(k),vec.size());\n        for (int i = 0; i < k; ++i)\n            vec[i] += val;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918248315","body":"#### 代码\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        if(s.empty())\n            return \"\";\n        \n        string ans;\n        int i = 0;\n        int len = s.length();\n        int c = 0;\n        while (isdigit(s[i]) && i < len)\n            c = c * 10 + (s[i++] - '0');\n        \n        int j = i;\n        if (i < len && s[i] == '[')\n        {\n            int open = 1;\n            while (++j < len && open)\n            {\n                if (s[j] == '[') ++open;\n                if (s[j] == ']') --open;\n            }\n        }\n        else\n        {\n            while (j < len && isalpha(s[j])) \n                ++j;\n        }\n        \n        if (i == 0)\n            return s.substr(0, j) + decodeString(s.substr(j));\n        \n        string ss = decodeString(s.substr(i + 1, j - i - 2));\n        while (c--)\n            ans += ss;\n        ans += decodeString(s.substr(j));\n        return ans;\n    }\n};\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919224591","body":"#### 代码\n\n``` C++\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        s1_.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if (s2_.empty()) move();\n        int top = s2_.top();\n        s2_.pop();\n        return top;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if (s2_.empty()) move();\n        return s2_.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return s1_.empty() && s2_.empty();\n    }\n    \n    private:\n    stack<int> s1_;\n    stack<int> s2_;\n  \n    void move() {\n        while (!s1_.empty()) {\n            s2_.push(s1_.top());\n            s1_.pop();\n        }\n    }   \n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n\n\n```\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920956341","body":"### 代码\n\n\n\n~~~c++\nclass Solution {\npublic:\n  ListNode* rotateRight(ListNode* head, int k) {\n    if (!head) \n        return head;    \n    int l = 1;\n    ListNode* tail = head;\n    while (tail->next) { tail = tail->next; ++l; }\n    k %= l;\n    if (k == 0) \n        return head;\n    \n    ListNode* prev = head;\n    while (--l > k) prev = prev->next;\n    ListNode* new_head = prev->next;\n    tail->next = head;\n    prev->next = nullptr;\n    return new_head;\n  }\n};\n~~~\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922329340","body":"### 代码\n\n~~~c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* build(ListNode* head){\n        if(head == NULL)    \n            return nullptr;\n        else if(head->next == NULL) \n            return (new TreeNode(head->val));\n        ListNode* slow,*temp,*quick;\n        slow = head;\n        quick = head;\n        while(quick && quick->next){        \n            quick = quick->next->next;\n            temp = slow;\n            slow = slow->next;\n        }\n        TreeNode* root = new TreeNode(slow->val);\n        temp->next = NULL;\n        ListNode* headN = slow->next;\n        slow->next = NULL;\n        root->left = build(head);\n        root->right = build(headN);\n        return root;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        return build(head);\n    }\n};\n~~~\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922480814","body":"### 代码\n\n~~~C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n\n        if(headA == NULL || headB == NULL) \n            return NULL;\n        ListNode *pA = headA, *pB = headB;\n\n        while(pA != pB) {\n            pA = pA == NULL ? headB : pA->next;\n            pB = pB == NULL ? headA : pB->next;\n        }\n        return pA;\n    }\n};\n~~~\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsyxiaoba":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916948342","body":"## 思路\n\n从最低位开始相加，k = 123， X = [4,5,6]，\n[4,5,6+123] --> [4,5,129] --> 129 % 10 --> 9 --> [4,5,9] --> 129 - 9 --> 120 --> Matn.floor(120 / 10) --> 12 --> [4,5+12,9]\n......\n\n## js代码\n\n```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n``` \n\n## 复杂度\n\n* 时间复杂度：O(max(n,logk))，其中 n 为数组的长度\n* 空间复杂度：O(1)。除了返回值以外，使用的空间为常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428632","body":"## 思路\n把 C 看成分界线，将 S 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值 <br/>\n如：s = 'woshicaiji' ,   c = 'i' <br>\n第一个窗口：woshi   <br>\n第二个窗口：icai   <br>\n第三个窗口：iji\n\n## js代码\n```ls\nvar shortestToChar = function (S, C) {\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\n  let l = S[0] === C ? 0 : Infinity,\n    // 窗口右边界\n    r = S.indexOf(C, 1);\n\n  const res = Array(S.length);\n\n  for (let i = 0; i < S.length; i++) {\n    // 计算字符到当前窗口左右边界的最小距离\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n\n    // 遍历完了当前窗口的字符后，将整个窗口右移\n    if (i === r) {\n      l = r;\n      r = S.indexOf(C, l + 1);\n    }\n  }\n\n  return res;\n};\n```\n\n## 复杂度\n* 时间复杂度：O(N) N是字符串S的长度\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917627439","body":"## js代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n\r\n    if(this.stack.length < this.maxSize){\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n\r\n    return this.stack.length > 0 ? this.stack.pop() : -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const len = Math.min(this.stack.length, k);\r\n    for(let i = 0;i < len; i++){\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度： push:O(1)、pop：O(1)、increment：O(N) ，N为min(K， 栈中元素的个数)\r\n- 空间复杂度：O(N)，N为maxSize","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918323893","body":"### 思路\n\n 两个栈解法\n 一个栈放倍数，一个栈放字母\n\n### js代码\n\n```js\nvar decodeString = function(s) {\n    let numStack = []; // 存倍数的栈\n    let strStack = []; // 存 待拼接的str 的栈\n    let num = 0; // 倍数中转站\n    let result = ''; // 字符串中转站\n    for(const char of s){\n        if(!isNaN(char)){ // 遇到数字\n            num = num * 10 + (+char); // 计算倍数\n        }else if(char === '['){ // 遇到 [\n            strStack.push(result); // result字符串入栈\n            result = '';           // 入栈后清零\n            numStack.push(num); // 倍数num入栈\n            num = 0; // 倍数入栈后清零\n        }else if(char === ']'){ // 遇到 ]，两个栈顶出栈\n            let repeatTimes = numStack.pop(); // 获取倍数\n            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\n        }else{\n            result += char; // 遇到字母，拼接给result串\n        }\n    }\n    return result;\n};\n```\n\n\n### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919258583","body":"## 思路\r\njs用两个数组来回倒腾，只使用 pop、push 两个API 以及 length 属性来实现，将数组当成栈即可，遵循先进后出原则\r\n\r\n\r\n## js代码\r\n```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.queue1 = [];\r\n    this.queue2 = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.queue1.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(!this.queue2.length){\r\n         while(this.queue1.length){\r\n            this.queue2.push(this.queue1.pop());\r\n        }\r\n    }\r\n    return this.queue2.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(!this.queue2.length){\r\n         while(this.queue1.length){\r\n            this.queue2.push(this.queue1.pop());\r\n        }\r\n    }\r\n    return this.queue2[this.queue2.length - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.queue1.length && !this.queue2.length;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：push: O(1)，pop和peek两个都是 O(N) N 是元素总个数，empty:O(1)\r\n- 空间复杂度：O(N) N 是元素总个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920118717","body":"### 思路\n\n滑动窗口：\n\n原数组进行分块后，每一个分块和排序后的数组中对应的分块数字是一样的，只是排序不同。\n\n既然每个分块中数字是一样的，那它们的和也是一样的了。我们可以用一个滑动窗口同时扫描原数组和排序数组，当窗口中数字的和一样时，就将数组进行分块\n\n\n### js代码\n\n```js\nvar maxChunksToSorted = function(arr) {\n    const sorted = [...arr];\n    sorted.sort((a,b) => a - b);\n\n    let count = 0;\n    let sum1 = 0;\n    let sum2 = 0;\n\n    for(let i = 0; i < arr.length; i++){\n        sum1 += arr[i];\n        sum2 += sorted[i];\n        \n        if(sum1 === sum2){\n            count++;\n            sum1 = sum2 = 0;\n        }\n    }\n\n    return count;\n};\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(NlogN)，N 为数组长度，数组排序时间认为是 NlogN，滑动窗口遍历数组时间为 N。\n- 空间复杂度：O(N)，N 为数组长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921012286","body":"### 思路\r\n\r\n    环型链表法\r\n\r\n    记录链表长度\r\n    如果移动长度是链表长度的整数倍，则位置不变\r\n    如果不是整数倍，移动的长度是 k % len，将链表变成一个头尾相连的环形链表\r\n    然后再将此时的尾移动 k % len 个位置，此时尾的 next 是指向头的，\r\n    最后头尾断开，返回头即可\r\n \r\n\r\n### js代码\r\n\r\n```js\r\nvar rotateRight = function(head, k) {\r\n    if(!head || !head.next || k === 0){\r\n         return head;\r\n    }\r\n\r\n    // 缓存链表长度\r\n    let len = 1;\r\n    let tail = head;\r\n    while(tail.next){\r\n        tail = tail.next;\r\n        len++;\r\n    }\r\n\r\n    // 如果移动长度是链表长度的整数倍，则位置不变\r\n    // 如果不是整数倍，移动的长度是 k % len\r\n    // 获取末尾节点位置\r\n    let mov = len - k % len;\r\n    if(len === mov){\r\n        return head;\r\n    }\r\n\r\n    // 将尾部指针指向头部，闭合链表\r\n    tail.next = head; \r\n    // 尾移动 mov 个位置\r\n    while(mov){\r\n        tail = tail.next;\r\n        mov--;\r\n    }\r\n\r\n    // 断开环\r\n    const res = tail.next;\r\n    tail.next = null;\r\n\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921858802","body":"### 思路\r\n\r\n- 生成一个节点N，保存并指向头部\r\n- 开始遍历，保存第一个 第二个节点\r\n- 改变指向\r\n\r\n\r\n### js代码\r\n\r\n```js\r\nvar swapPairs = function (head) {\r\n    // 如果不存在或只有一个节点，直接返回\r\n    if (!head || !head.next) return head;\r\n    // 在 head 之前生成一个节点 yNode 指向 head\r\n    const yNode = new ListNode(0);\r\n    yNode.next = head;\r\n    // 保存 yNode，从 yNode 开始遍历\r\n    let y = yNode;\r\n    while (y.next && y.next.next) { // 如果至少有两个节点才继续\r\n        // 缓存第一个和第二个节点\r\n        const n1 = y.next;\r\n        const n2 = y.next.next;\r\n        // 改变节点指向\r\n        y.next = n2;\r\n        n1.next = n2.next;\r\n        n2.next = n1;\r\n        // 完成一次交换后，将 n1 赋值给 y，继续下一次遍历\r\n        y = n1;\r\n    }\r\n    // 返回头结点\r\n    return yNode.next;\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。\r\n- 空间复杂度：O(1)。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922326642","body":"### 思路\r\n\r\n- 将链表转为数组\r\n- 将中间元素作为根节点\r\n- 递归构建左右子树\r\n\r\n### js代码\r\n\r\n```js\r\nvar sortedListToBST = function(head) {\r\n\r\n    // 将链表转为数组\r\n    const nums = [];\r\n    while(head){\r\n        nums.push(head.val);\r\n        head = head.next;\r\n    }\r\n\r\n    // 根据索引start到end的子数组构建子树\r\n    let makeTree = (start, end) => {\r\n        // 指针交错，形成不了子序列，返回null节点\r\n        if (start > end) return null;\r\n        // 求中间索引 中间元素是根节点的值\r\n        let mid = Math.floor((start + end) / 2);\r\n        // 创建根节点\r\n        let currentTree = new TreeNode(nums[mid]);\r\n        // 递归构建左子树\r\n        currentTree.left = makeTree(start, mid - 1);\r\n        // 递归构建右子树\r\n        currentTree.right = makeTree(mid + 1, end);\r\n        // 返回当前子树\r\n        return currentTree\r\n    }\r\n    // 根据整个数组构建\r\n    return makeTree(0, nums.length - 1);\r\n\r\n};\r\n```\r\n\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度：O(n)，n 为链表节点个数。\r\n- 空间复杂度：O(n)，n 为链表节点个数。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922493351","body":"### 思路\r\n\r\n\r\n**双指针法**\r\n     pA  pB  分别指向两个链表\r\n\r\n 判断两个链表是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回null。\r\n遍历两个链表，如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针pB 为空，则将指针 pB 移到链表 headA 的头节点。\r\n当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者null。\r\n\r\n\r\n情况一：两个链表相交\r\n\r\n链表 A 走完接着走 B\r\n链表 B 走完接着走 A\r\n这样不管两个链表分别有多长，当两个指针相遇时，他们走过的路程一定是一样的\r\n\r\n\r\n情况二：两个链表不相交\r\n\r\n链表 A 走完接着走 B\r\n链表 B 走完接着走 A\r\n这样不管两个链表分别有多长，当两个指针都分别走完自己和对方的路程时，他们走过的路程也一定是一样的（即：自己的和对方的），最终都走到尾部时，都指向了 null，退出\r\n\r\n\r\n### js代码\r\n\r\n\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    if(!headA || !headB) return null;\r\n    let a = headA, b = headB;\r\n    while(a !== b){\r\n        a = !a ? headB : a.next;\r\n        b = !b ? headA : b.next;\r\n    }\r\n    return a\r\n};\r\n\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度O(m+n)，其中 m 和 n 是分别是链表headA 和headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。\r\n- 空间复杂度：O(1)。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carterrr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916951028","body":"class 989_数组形式的加法{\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        for(int i = num.length - 1; i >= 0 || k > 0 ; i--) {\n            if(i >=0) {\n             k +=  num[i];\n            }\n            res.add(k % 10);\n            k /= 10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917393635","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        // 双轮遍历  填充最大值用于回头的时候取到最小值 如果不填充在头部的时候最小值全是0\n        Arrays.fill(res, s.length());\n        int cur = -1;\n        for(int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == c) {\n                cur = i;\n                res[i] = 0;\n                continue;\n            }\n\n            if(cur != -1) {\n                res[i] = i - cur;\n            }\n        }\n\n        cur = -1;\n        for(int i = s.length() - 1; i >= 0; i--) {\n            if(s.charAt(i) == c) {\n                cur = i;\n                continue;\n            }\n\n            if(cur != -1) {\n                res[i] = Math.min(res[i], cur - i);\n            }\n        }\n\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917596410","body":"  private int[] stack ;\n    private int[] inc;\n    private int top = -1;// 初始栈空  top指向当前栈顶元素的位置\n    public CustomStack_TrieSum(int maxSize) {\n        stack = new int[maxSize];\n        inc = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if(top < stack.length - 1) {\n            stack[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if(top == -1) return -1;\n        int res = stack[top] + inc[top];\n        if(top > 0) {\n            inc[top - 1] += inc[top];\n        }\n        inc[top] = 0;// 避免increment方法再次自增的时候又加上了\n        top --;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int incMax = Math.min(top, k - 1);\n        // 要给对应位置赋值  incMax应该指向最大位置\n        if(incMax >= 0) {\n            // 注意是叠加  不能直接赋值 =\n            inc[incMax] += val;\n        }\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918217379","body":"class 字符串解码_394{\n    public String decodeString(String s) {\n        // 遇到[开始把前面一个入栈  以及后面的\n        Deque<String> cStack = new LinkedList<>();\n        Deque<Integer> iStack = new LinkedList<>();\n\n        String res = \"\"; // 存储本次[] 中的字符串  \n        int num = 0;     //  存储本次[ 前面的倍数\n        for(char c : s.toCharArray()) {\n            if(c >= '0' && c <= '9') { // 是数字\n                num = num * 10 +  (c - '0'); // 23[ab] 这种  数字是23倍\n            } else if( c == '[') {  // [ 将之前的字符串和倍数入栈保存 \n                cStack.push(res);\n                iStack.push(num);\n                res = \"\";\n                num = 0;\n            } else if( c == ']' ) { // ] 用数字栈顶数字来倍化 [] 中的元素\n                String tmpRes = res;\n                final int repeat = iStack.pop() - 1;\n                for(int i = 0; i < repeat; i++ ) {\n                    tmpRes = tmpRes + res;\n                }\n                res = cStack.pop() + tmpRes; //加上 数字前面的字符串 没有就是 \"\"\n            } else {\n                res = res + c;\n            }\n        }\n        return  res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918800540","body":"class MyQueue {\r\n\r\n    private Deque<Integer> pushStack = new LinkedList<>();\r\n    private Deque<Integer> popStack = new LinkedList<>();\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        pushStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(popStack.isEmpty() && !pushStack.isEmpty()) {\r\n            while(!pushStack.isEmpty()) {\r\n                popStack.push(pushStack.pop());\r\n            }\r\n        }\r\n        return popStack.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(popStack.isEmpty() && !pushStack.isEmpty()) {\r\n            while(!pushStack.isEmpty()) {\r\n                popStack.push(pushStack.pop());\r\n            }\r\n        }\r\n        return popStack.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return popStack.isEmpty() && pushStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919764242","body":"class Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        // 每个块\r\n        // 最小的 比前面大\r\n        // 最大的 比后面小\r\n        // 每个块只保留最大元素   最终数下栈中元素个数即可\r\n\r\n        Deque<Integer> stack = new LinkedList<>();\r\n        for (int num : arr) {\r\n            final Integer head = stack.peek();\r\n            if (!stack.isEmpty() && num < head) {\r\n                // 合并num  和 比num 大的块 为一个\r\n                while (!stack.isEmpty() && num < stack.peek()) {\r\n                    stack.pop();\r\n                } \r\n                // 最终只剩下head代表一个独立块\r\n                stack.push(head);\r\n            } else {\r\n                // 栈为空或者 num 比head大 可以成为一个单独的块\r\n                // 直接添加num成一个独立块\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920575191","body":"/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || k == 0) return head;\r\n        ListNode fast = head, slow = head;\r\n        for(int i = 0; i < k; i++) {\r\n            fast = fast.next;\r\n            if(fast == null) {\r\n                fast = head;  // 快指针 fast 对 k 取模\r\n            }\r\n        }\r\n        while(fast.next != null) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        fast.next = head;\r\n        head = slow.next;\r\n        slow.next = null;\r\n        return head;\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921707376","body":"/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass 两两交换链表中的节点_21 {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null) return head;\r\n        // 要保存每组节点的前驱指针  需要一个伪节点  并后移伪节点\r\n        ListNode dummyHead =new ListNode(0, head), cur = dummyHead;\r\n        while(cur.next != null && cur.next.next != null) {\r\n            // 这里有三个几点在操作中  cur.next  node1 node2\r\n            ListNode node1 = cur.next.next;\r\n            ListNode node2 = cur.next.next.next;\r\n            node1.next = cur.next;   // 第二个节点指向第一个节点\r\n            cur.next.next = node2;   // 第一个节点指向后面的节点\r\n            cur.next = node1;        // 当前指针指向第一个节点\r\n            cur = node1.next;        // 指针后移到后一组节点的前驱节点\r\n        }\r\n        return dummyHead.next;\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922251990","body":"/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass 有序链表转换二叉搜索树_109 {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        if(head.next == null) return new TreeNode(head.val);\r\n        ListNode  fast = head,  slow = head, preSlow = null;\r\n        // 快慢指针找中点\r\n        while(fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            preSlow = slow;\r\n            slow = slow.next;\r\n            \r\n        }\r\n        preSlow.next = null; // 不断开 下次还会找到这次的root  无限循环\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(slow.next);\r\n        return root;\r\n\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922401152","body":"/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode curA = headA, curB = headB;\r\n        while(curA !=curB ){\r\n            if(curA == null) {\r\n                curA = headB;\r\n            } else {\r\n            curA = curA.next;\r\n\r\n            }          \r\n            if(curB == null) {\r\n                curB = headA;\r\n            } else {\r\n            curB = curB.next;\r\n\r\n            }\r\n        }\r\n        return curA;\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ff1234-debug":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916953423","body":"> #### 思路\r\n> ​将k视为整体直接与最低位相加，进行取余，进位，最后再对k进行取余，进位\r\n> \r\n> ​ 数组逆置是为了便于最后单独对k的处理\r\n> \r\n> #### 代码\r\n> c++\r\n>\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) \r\n    {\r\n        if(k==0) return num;\r\n        int res=0,c=0,n=num.size();\r\n        reverse(num.begin(),num.end());\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            k=k+num[i];\r\n            num[i]=k%10;\r\n            k/=10;\r\n        }\r\n        while(k!=0)\r\n        {\r\n            num.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(num.begin(),num.end());\r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n> #### 复杂度分析\r\n> 时间复杂度： O(max(n,log(k))\r\n>空间复杂度： O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917374548","body":"> ### 思路\r\n> 从头到尾和从尾到头分别遍历两次数组，分别找到字符左边和右边的目标字符最小距离，再取两者之间的最小值。 \r\n> ### 代码\r\n>   c++\r\n ```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) \r\n    {\r\n        int n=s.length();\r\n        vector<int> ans(n);\r\n        int before=n+5;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n           if(s[i]==c) before=i;\r\n           ans[i]=abs(i-before);\r\n        }\r\n        int after=2*n+5;\r\n        for(int i=n-1;i>=0;i--)\r\n        {\r\n            if(s[i]==c) after=i;\r\n            ans[i]=min(abs(after-i),ans[i]);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n> ### 复杂度\r\n> 时间复杂度：O(n)\r\n> 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917598929","body":"> ## 思路\r\n> vecor模拟栈的操作，优化时新增一个vector用于存放增量，在出栈时才进行相加\r\n> \r\n> ### c++ vector实现 \r\n``` \r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) \r\n    {\r\n        q.resize(maxSize);\r\n        inc.resize(maxSize);\r\n        top=-1;\r\n    }\r\n    \r\n    void push(int x) \r\n    {\r\n        if(top!=q.size()-1) \r\n        {\r\n          top++;\r\n          q[top]=x;\r\n        }\r\n    }\r\n    \r\n    int pop() \r\n    {\r\n       if(top==-1) return -1;\r\n       int x=q[top]+inc[top];\r\n       if(top!=0) inc[top-1]+=inc[top];\r\n       inc[top]=0;\r\n       top--;\r\n       return x;\r\n    }\r\n    \r\n    void increment(int k, int val) \r\n    {\r\n        int n=top<k-1?top:k-1;\r\n        if(n>=0) inc[n]+=val;\r\n    }\r\nprivate:\r\n    vector<int> q;\r\n    vector<int> inc;\r\n    int top;\r\n};\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n> ## 复杂度分析\r\n> * **时间复杂度**:  O(1)\r\n> * **空间复杂度**  O(maxSize)的栈空间\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918112034","body":"> ### 思路\r\n> 利用string ，栈完成，栈用于括号匹配和保存运算完成后的结果\r\n> \r\n> ### 代码   C++ \r\n ```  C++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) \r\n    {\r\n       stack<string> q;\r\n       int n=s.size();\r\n       string num=\"\",str=\"\",ans=\"\";\r\n       for(int i=0;i<n;i++)\r\n       {\r\n          if(s[i]>='0'&&s[i]<='9') num+=s[i];\r\n          else\r\n          {\r\n              if(num!=\"\")\r\n              {\r\n                q.push(num);\r\n                num=\"\";\r\n              }\r\n              if(s[i]=='['||(s[i]>='a'&&s[i]<='z')) \r\n              {\r\n                str+=s[i];\r\n                q.push(str);\r\n                str=\"\";\r\n              }\r\n              else if(s[i]==']')\r\n              {\r\n                 string t=\"\";\r\n                 string cmp=\"[\";\r\n                 while(q.top()!=cmp)\r\n                 {\r\n                    t=q.top()+t;\r\n                    q.pop();\r\n                 }\r\n                 q.pop();\r\n                 int m=stoi(q.top());\r\n                 string k=t;\r\n                 for(int j=0;j<m-1;j++)\r\n                    t+=k;\r\n                q.pop();\r\n                q.push(t);\r\n              }\r\n          }\r\n       }\r\n       string t2=\"\";\r\n       while(!q.empty())\r\n       {\r\n          t2=q.top()+t2;\r\n          q.pop();\r\n       }\r\n       ans+=t2;\r\n       return ans;\r\n    }\r\n};\r\n ```\r\n> \r\n> **复杂度分析**\r\n> \r\n> * 时间复杂度：O(N)\r\n> * 空间复杂度：O(N)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918909021","body":"> ## 思路\r\n> 使用两个栈s1, s2，s1用于输入数据，s2用于输出数据。当s2不为空直接输出，s2为空的时候将栈s1的元素出栈压入s2。\r\n> ## 代码\r\n> ### 实现语言: C++\r\n ```c++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() \r\n    {\r\n       \r\n    }\r\n    void s1_to_s2()\r\n    {\r\n        while(!s1.empty())\r\n        {\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n    }\r\n    /** Push element x to the back of queue. */\r\n    void push(int x) \r\n    {\r\n      s1.push(x);     \r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() \r\n    {\r\n        int x;\r\n        if(s2.empty()) s1_to_s2();\r\n        x=s2.top();\r\n        s2.pop();\r\n        return x;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() \r\n    {\r\n       if(s2.empty()) s1_to_s2();\r\n       return s2.top();  \r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() \r\n    {\r\n       return s1.empty()&&s2.empty();\r\n    }\r\nprivate:\r\n    stack<int> s1;\r\n    stack<int> s2;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n ```\r\n> \r\n> \r\n> ## 复杂度分析\r\n> * 时间复杂度： O(n) ，每个操作均摊为O(1)\r\n> * 空间复杂度： O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920100492","body":"> ### 思路\r\n> （1）依据题目可知，数组分块排序后再连接在一起可以构成所有元素的升序排列，可以得到后一个分片数组的数据元素应该大于前一个分配数组的所有元素，即大于前一个数组的最大元素。\r\n>（2）遍历数组，采用单调栈升序存储每个分片数组的最大值，若遇到数组元素小于单调栈栈顶元素，需要进行分片数组的合并，具体为进行出栈直到数组元素大于单调栈栈顶元素或单调栈为空，最后再将最大值压入单调栈作为新的分配数组的最大值。\r\n> （3）遍历完成后，单调栈中的元素个数即为最终的分片数组个数。\r\n> ### c++代码\r\n ```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) \r\n    {\r\n        vector<int> q;\r\n        q.push_back(0);\r\n        int n=arr.size(),max=0;\r\n        for(int i=1;i<n;i++)\r\n        {\r\n            if(arr[i]>=arr[max])\r\n            {\r\n               q.push_back(i);\r\n               max=i;\r\n            }\r\n            else\r\n            {\r\n              while(!q.empty()&&arr[i]<arr[q[q.size()-1]])\r\n              {\r\n                  q.pop_back();\r\n              } \r\n                q.push_back(max);\r\n            }\r\n        }\r\n        return q.size();\r\n    }\r\n};\r\n ```\r\n> ### 复杂度\r\n> 时间复杂度：O(n) ，遍历一篇数组\r\n> 空间复杂度：O(n)， 单调栈最多存N个元素\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920699895","body":"> ## 思路\r\n> * 观察至链表长度为n,移动k次,实际只需移动k%n次\r\n> * 遍历得出链表长度和链表尾指针，再次从头遍历n-k-1次链表，得到移动后链表的尾指针p，p->next为头指针,处理链表使head=p->next,p->next=nullptr\r\n> * 最后返回head\r\n> ## 代码\r\n> * 语言支持：C++\r\n> \r\n> C++ Code:\r\n> \r\n ```c++\r\n/*\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) \r\n    {\r\n       if(head==nullptr||head->next==nullptr||k==0) return head;\r\n       ListNode* p=head;\r\n       int n=1;\r\n       while(p->next!=nullptr)\r\n       {\r\n           p=p->next;\r\n           n++;\r\n       }   \r\n       k=k%n;\r\n       ListNode *q=head;\r\n       for(int i=0;i<n-k-1;i++)\r\n       {\r\n           q=q->next;\r\n       }\r\n       p->next=head;\r\n       head=q->next;\r\n       q->next=nullptr;\r\n       return head;\r\n    }\r\n};\r\n```\r\n> \r\n> ## 复杂度分析\r\n> 令 n 为链表长度。\r\n> \r\n> * 时间复杂度：$O(n)$\r\n> * 空间复杂度：$O(1)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921630245","body":"> ### 思路\r\n> 迭代，新建虚拟头节点指向head进行统一操作，然后进行两两交换\r\n> ### C++代码\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head)\r\n    {\r\n        if(head==nullptr||head->next==nullptr) return head;\r\n        ListNode *dummyHead=new ListNode(0,head);\r\n        ListNode *p=dummyHead;\r\n        while(p->next!=nullptr&&p->next->next!=nullptr)\r\n        {\r\n            ListNode *a=p->next,*b=p->next->next;\r\n            a->next=b->next;\r\n            b->next=a;\r\n            p->next=b;\r\n            p=a;\r\n        }\r\n        return dummyHead->next;\r\n    }\r\n};\r\n\r\n```\r\n\r\n> 时间复杂度：O(N)\r\n> 空间复杂度：O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922253647","body":"> ## 思路\r\n>分治法，首先利用快慢指针找到每个分块的中间节点，再以此建立树节点，并递归返回，最终构造出所需的平衡二叉数并返回根节点\r\n> ## 代码 C++\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* getmid(ListNode* left,ListNode* right)\r\n    {\r\n        ListNode* slow=left;\r\n        ListNode* fast=left;\r\n        while(fast!=right && fast->next!=right)\r\n        {\r\n            fast=fast->next;\r\n            fast=fast->next;\r\n            slow=slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n    TreeNode* buidTree(ListNode* left,ListNode* right)\r\n    {\r\n        if(left==right) return nullptr;\r\n        ListNode* mid = getmid(left,right);\r\n        TreeNode* root=new TreeNode(mid->val);\r\n        root->left=buidTree(left,mid);\r\n        root->right=buidTree(mid->next,right);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) \r\n    {\r\n        return buidTree(head,nullptr);\r\n    }\r\n};\r\n```\r\n> ## 复杂度分析\r\n> ### 时间复杂度  O(nlogn)\r\n> ### 空间复杂度  O(logn)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922435157","body":"> # 思路\r\n>首先判断headA或headB是否为空，若为空相交节点为空。再依次同时headA和headB进行遍历，headA遍历完或headB遍历完成后仍未找到相交节点，则headA转到headB，headB转到headA再进行遍历。最终遍历到的相同节点为相交节点，无相交节点也包含在相交节点中，同时为空。\r\n> # 代码 C++\r\n>```\r\n>/**\r\n> * Definition for singly-linked list.\r\n> * struct ListNode {\r\n> *     int val;\r\n> *     ListNode *next;\r\n> *     ListNode(int x) : val(x), next(NULL) {}\r\n >* };\r\n> */\r\n>class Solution {\r\n>public:\r\n>   ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\r\n>   {\r\n>        if(headA==nullptr||headB==nullptr) return nullptr;\r\n>         ListNode* a=headA,*b=headB;\r\n>         for(;;)\r\n>         {\r\n>            if(a!=nullptr&&a!=b) a=a->next;\r\n>           else if(a==nullptr&&a!=b) a=headB;\r\n>            if(b!=nullptr&&b!=a) b=b->next;\r\n>            else if(b==nullptr&&b!=a) b=headA;\r\n>            if(a==b) break;\r\n>         }   \r\n>        return a;\r\n>    }\r\n>};\r\n>```\r\n> # 复杂度\r\n> 时间复杂度 ：Om+n),m和n分别代表两个链表的长度\r\n> 空间复杂度：O(1)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzhsaga":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916953516","body":"Code:\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n\nTc：O(max(n,logk)) \n\nSc：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917254115","body":"### Code\r\n```\r\npublic class test {\r\n    public static int[] shortestToChar(String s, char c) {\r\n        int l = s.length();\r\n        int[] ans = new int[l];\r\n        int prev = -10000;\r\n        for (int i = 0; i < l; i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            ans[i] = i-prev;\r\n        }\r\n        prev = 10000;\r\n        for (int i = l - 1; i >=0; i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            ans[i] = Math.min(prev - i, ans[i]);\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n### Complexity Analysis\r\n- TC: O(n)\r\n- SC: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heyqz":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916955471","body":"## 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry = 0\r\n        for i in range(len(num)-1, -1, -1):\r\n            remain = k % 10\r\n            k = k // 10\r\n            total = num[i] + remain + carry\r\n            carry = total // 10\r\n            res.append(total % 10)\r\n        \r\n        k = k + carry\r\n        while k:\r\n            res.append(k % 10)\r\n            k //= 10\r\n        \r\n        res.reverse()\r\n        return res\r\n```\r\n## 复杂度\r\n* time complexity: O(max(n, logk))\r\n* space complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420910","body":"## 思路\r\n分别从左和从右两次遍历\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        left, right, res = [None] * n, [None] * n, [None] * n\r\n        \r\n        tmp = float('inf')\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                tmp = 0\r\n            left[i] = tmp\r\n            tmp += 1\r\n                \r\n        tmp = float('inf')\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                tmp = 0\r\n            right[i] = tmp\r\n            tmp += 1\r\n            \r\n        for i in range(n):\r\n            res[i] = min(left[i], right[i])\r\n            \r\n        return res\r\n```\r\n## 复杂度\r\n* time complexity: O(n)\r\n* space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917654431","body":"## code\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.cur_size = 0\r\n        self.size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size < self.size:\r\n            self.stack.append(x)\r\n            self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cur_size == 0:\r\n            return -1\r\n        self.cur_size -= 1\r\n        return self.stack.pop()\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.cur_size)):\r\n            self.stack[i] += val\r\n```\r\n## complexity\r\n* time complexity: push, pop: O(1), inc: O(k)\r\n* space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917721498","body":"## 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        \r\n        for c in s:\r\n            if c != \"]\":\r\n                stack.append(c)\r\n            else:\r\n                substr = \"\"\r\n                while stack[-1] != \"[\":\r\n                    substr = stack.pop() + substr\r\n                stack.pop() # pop out the \"[\"\r\n                \r\n                k = \"\"\r\n                while stack and stack[-1].isdigit(): \r\n                    k = stack.pop() + k\r\n                stack.append(int(k) * substr)\r\n        \r\n        return \"\".join(stack)\r\n```\r\n## 复杂度\r\n* time complexity: O(n)\r\n* space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918469877","body":"## Code\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.stack1) == 0 and len(self.stack2) == 0\r\n```\r\n## Complexity\r\n* time complexity: O(1)\r\n* space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919562272","body":"### 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        sortArr = sorted(arr)\r\n        cnt = 0\r\n        sum1, sum2 = 0, 0\r\n        \r\n        for i in range(len(arr)):\r\n            sum1 += arr[i]\r\n            sum2 += sortArr[i]\r\n            \r\n            if sum1 == sum2:\r\n                cnt += 1\r\n                \r\n        return cnt\r\n```\r\n### 复杂度\r\ntime complexity: O(nlogn)\r\nspace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920305356","body":"### Code\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        \r\n        length = 1\r\n        tail = head\r\n        while tail.next:\r\n            tail = tail.next\r\n            length += 1\r\n                   \r\n        k = k % length\r\n        if  k == 0:\r\n            return head  \r\n        \r\n        cur = head\r\n        for i in range(length-k-1): \r\n            cur = cur.next\r\n        ans = cur.next\r\n        cur.next = None\r\n        tail.next = head\r\n        \r\n        return ans\r\n```\r\n### Complexity\r\ntime: O(n)\r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921176599","body":"### 代码\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        dummy = ListNode(0, head)\r\n        pre, cur = dummy, head\r\n        \r\n        while cur and cur.next:\r\n            nextPair = cur.next.next\r\n            second = cur.next\r\n            \r\n            # reverse this pair\r\n            second.next = cur\r\n            cur.next = nextPair\r\n            pre.next = second\r\n\r\n            pre = cur\r\n            cur = nextPair\r\n            \r\n        return dummy.next\r\n```\r\n### 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922123514","body":"先找到中点作为root，再递归构建树\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return None         \r\n        pre, slow, fast = None, head, head\r\n        \r\n        while fast and fast.next:\r\n            pre, slow, fast = slow, slow.next, fast.next.next\r\n                \r\n        if pre:\r\n            pre.next = None\r\n        else:\r\n            return TreeNode(head.val)\r\n        \r\n        root = TreeNode(slow.val)\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        \r\n        return root \r\n```\r\n### 复杂度\r\ntime complexity: O(nlogn)\r\nspace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922479593","body":"### 代码\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        curA, curB = headA, headB\r\n        a, b = 0, 0\r\n        while curA:\r\n            a += 1\r\n            curA = curA.next\r\n        while curB:\r\n            b += 1\r\n            curB = curB.next\r\n    \r\n        if a > b:\r\n            curL = headA\r\n            diff = a - b\r\n            curS = headB\r\n        else:\r\n            curL = headB\r\n            diff = b - a\r\n            curS = headA\r\n        \r\n        for i in range(diff):\r\n            curL = curL.next\r\n        \r\n        while curL != curS:\r\n            curL = curL.next\r\n            curS = curS.next\r\n        \r\n        return curL\r\n```\r\n### 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922528051","body":"### 代码\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if fast == slow:\r\n                break\r\n        \r\n        if fast is None or fast.next is None:\r\n            return None\r\n        \r\n        fast = head\r\n        while fast != slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        \r\n        return fast\r\n```\r\n### complexity\r\ntime complexity: O(n)\r\nspace complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lovemyse1f":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916956842","body":"思路：题解\n\n代码（python）\nclass Solution(object):\n    def addToArrayForm(self, num, K):\n        i = len(num) - 1\n        while K:\n            num[i] += K#\n            K, num[i] = num[i] // 10, num[i] % 10#\n            i -= 1\n\n            if i < 0 and K:\n                num.insert(0,0)\n                i = 0\n        return num\n复杂度：\n时间O（N）\n空间O(|K-N|)\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921790071","body":"思路：迭代，来自题解\n代码：\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        newHead = ListNode(0) \n        newHead.next = head #新的头节点指向链表\n        temp = newHead \n        while temp.next and temp.next.next: #当链表中存在两个元素时继续；\n            node1 = temp.next#交换相邻元素\n            node2 = temp.next.next\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n        return newHead.next  #返回具有新头节点的链表\n时间复杂度：O(N) 因为是顺序遍历\n空间复杂度：O（1）\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Clarence5":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916962545","body":"```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\naddToArrayForm([1,2,6,3,0,7,1,7,1,9,7,5,6,6,4,4,0,0,6,3],516);\n```","onTime":true},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922472248","body":"```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA, pB = headB;\n        while(pA != pB){\n            pA = pA == null? headB : pA.next;\n            pB = pB == null? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MissNanLan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916962803","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n \n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n \n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 前置知识\n\n- 求第一个非负整数的个位与第一位分别是求余、除以10\n\n## 公司\n\n- 暂无\n\n## 思路\n\n逐位相加法\n\n## 关键点\n\n-  两数相加超过10怎么用代码表示\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (n, k) {\n  var res = [];\n  for (var i = n.length - 1; i >= 0; --i) {\n    var sum = n[i] + (k % 10);\n    k = Math.floor(k / 10);\n    if (sum >= 10) {\n      k++;\n      sum = sum - 10;\n    }\n    res.push(sum);\n  }\n  for (; k > 0; k = Math.floor(k / 10)) {\n    res.push(k % 10);\n  }\n  return res.reverse();\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917594442","body":"\n## 思路\n-  找出 c的下标的位置，放入到一个数组tempArr里面\n-  用tempArr与i相减得到绝对值，与tempArr下一个元素作比较，前一个元素比较大，则tempArr向后移动一个位置\n-  前一个元素小，则不需要动\n- 以上思路是参照别人的解法，感觉用两个循环不是很优雅，希望以后还是有自己的想法\n\n## 关键点\n-  如何求出两个下标之间的距离（两个下标相减的绝对值）\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(str, c) {\n  var answer = [];\n  var tempArr = [];\n  var k = 0;\n// 找出 c的下标的位置，放入到一个数组tempArr里面\n  for (var i = 0; i < str.length; i++) {\n    var s = str.charAt(i);\n    if (s === c) tempArr.push(i);\n  }\n//  用tempArr与i相减得到绝对值，与tempArr下一个元素作比较，前一个元素比较大，则tempArr向后移动一个位置\n// 前一个元素小，则不需要动\n  for (var i = 0; i < str.length; i++) {\n    if (\n      k < tempArr.length - 1 &&\n      Math.abs(tempArr[k] - i) > Math.abs(tempArr[k + 1] - i)\n    )\n      k++;\n    answer.push(Math.abs(tempArr[k] - i));\n  }\n  return answer;\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917645843","body":"## 前置知识\n\n- 栈先进后出\n- js原型知识\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n-  时间复杂度的优化。从O(k)->O(1)\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.arr = new Array(max);\n  this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.arr.length < this.maxSize) {\n    return this.arr.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  if (this.arr.length > 0) {\n    return this.arr.pop();\n  }\n  return -1;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  for (var i = 0; i < k && i < this.arr.length; i++) {\n    this.arr[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(k)\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918247390","body":"\n\n## 思路\n\n1、 遍历 s 字符串，假设当前字符为 c\n2、 如果是字母的话，拼接字符 curStr = curStr + c\n3、 如果是数字的话，放入到一个临时变量 curNum\n4、 如果碰到\"[\"，则将 curStr、curNum 入栈 stack，入栈之后 curStr、curNum 设为初始值\n5、 如果碰到\"]\", 则依次出栈，分别记作 prevStr、prevNum\n6、出栈的时候，拼接字符串 curStr = prevStr + curStr.repeat(prevNum);\n\n思考： stack 里面相邻的一定是字母数字隔开的吗，有没有可能出现连续的字母或数字\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n\n  var curStr = \"\",\n    curNum = 0,\n    stack = [];\n  for (var i = 0; i < s.length; i++) {\n    var c = s.charAt(i);\n    if (c >= \"0\" && c <= \"9\") {\n      curNum = curNum * 10 + Number(c);\n    } else if (c === \"[\") {\n      stack.push(curNum);\n      stack.push(curStr);\n      curStr = \"\";\n      curNum = 0;\n    } else if (c === \"]\") {\n      let prevStr = stack.pop();\n      let prevNum = stack.pop();\n      curStr = prevStr + curStr.repeat(prevNum);\n    } else {\n      curStr += c;\n    }\n  }\n  return curStr\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n),  一层循环，n是s字符串的长度\n- 空间复杂度： 这里不会分析\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919189564","body":"\n\n## 思路\n\n1、 双栈，一个入栈，一个出栈\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\nvar MyQueue = function () {\n  this.outStack = [];\n  this.inStack = [];\n};\n\n/**\n * Push element x to the back of queue.\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.inStack.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  if (this.outStack.length === 0) {\n    this.in2out();\n  }\n  return this.outStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  if (this.outStack.length === 0) {\n    this.in2out();\n  }\n  return this.outStack[this.outStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return this.inStack.length === 0 && this.outStack.length === 0;\n};\n\nMyQueue.prototype.in2out = function () {\n  while (this.inStack.length > 0) {\n    this.outStack.push(this.inStack.pop());\n  }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：push、peek、pop、empty 均是 O(1)\n- 空间复杂度：O(n)，n 是队列 push 的次数，\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920071807","body":"\n\n## 前置知识\n\n- 栈\n- 单调栈\n\n## 公司\n\n- 暂无\n\n## 思路\n\n\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n  let stack = [];\n  for (var i = 0; i < arr.length; i++) {\n    let head;\n    // 合并\n    if (stack.length > 0 && stack[stack.length - 1] > arr[i]) {\n      head = stack.pop();\n      while (stack.length > 0 && stack[stack.length - 1] > arr[i]) {\n        stack.pop();\n      }\n      stack.push(head);\n    } else {\n      // 新的块\n      stack.push(arr[i]);\n    }\n  }\n  return stack.length;\n};\n\n\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JinhMa":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916963481","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int len = A.length;\n        int lastNum =K;\n        LinkedList<Integer> ret= new LinkedList<>();\n\n        int i = len-1;\n        while(i >=0 || lastNum > 0){\n            if(i >= 0){\n                lastNum+=A[i];\n            }\n            ret.addFirst(lastNum%10);\n            lastNum/=10;\n            i--;\n        }\n        return ret;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917362135","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int l = s.length();\n        int[] ans = new int[l];\n        int start = 0;\n        List<Integer> record = new ArrayList<>();\n        while(start<l){\n            int end = start;\n            if(s.charAt(end)==c){\n                record.add(end);\n                start = end+1;\n            }\n            else{\n                while(end<l && s.charAt(end)!=c){\n                    end++;\n                }\n                if(end<l){\n                    record.add(end);\n                    for(int i=start;i<end;i++){\n                        if(record.size()==1){\n                            ans[i] = Math.abs(end-i);\n                        }\n                        else{\n                            int num1 = Math.abs(record.get(record.size()-1)-i);\n                            int num2 = Math.abs(record.get(record.size()-2)-i);\n                            ans[i] = Math.min(num1, num2);\n                        }\n                    }\n                }\n                if(end==l){\n                    for(int i=start;i<end;i++){\n                         ans[i] = Math.abs(record.get(record.size()-1)-i); \n                    }\n                }\n                start = end;\n            }\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917546538","body":"class CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top<stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top==-1){\n            return -1;\n        }\n        else{\n            top--;\n            return stack[top+1];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917814555","body":"\nclass Solution {\n    public String decodeString(String s) {\n        char[] c = s.toCharArray();\n        int l = c.length;\n        Stack<Integer> num = new Stack<>();\n        Stack<String> record = new Stack<>();\n        int start = 0;\n        while (start<l){\n            if (Character.isDigit(c[start])){\n                int shu = 0;\n                while (Character.isDigit(c[start])){\n                    shu = shu * 10 + c[start]-'0';\n                    start++;\n                }\n                start--;\n                num.add(shu);\n            }\n            else if (c[start]==']'){\n                int tmp = num.peek();\n                num.pop();\n                String str = \"\";\n                StringBuilder sb = new StringBuilder();\n                while(!record.peek().equals(\"[\")){\n                    sb = sb.append(record.peek());\n                    record.pop();\n                }\n                if (record.peek().equals(\"[\")){\n                    record.pop();\n                }\n                for (int i=0;i<tmp;i++){\n                    str = str + sb;\n                }\n                record.add(str);\n            }\n            else {\n                record.add(String.valueOf(c[start]));\n            }\n            start++;\n        }\n        StringBuilder ans = new StringBuilder();\n        while (!record.isEmpty()){\n            ans = ans.append(record.peek());\n            record.pop();\n        }\n        return ans.reverse().toString();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919087148","body":"class MyQueue {\n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        inStack = new Stack<Integer>();\n        outStack = new Stack<Integer>();\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(outStack.isEmpty()){\n        while(!inStack.isEmpty()){\n            outStack.push(inStack.pop());\n        }\n        }\n        return outStack.pop();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        if(outStack.isEmpty()){\n        while(!inStack.isEmpty()){\n            outStack.push(inStack.pop());\n        }\n        }\n        return outStack.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n\n}\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919751423","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920938060","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921864808","body":"class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922275552","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922406026","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        HashSet<ListNode> record = new HashSet<>();\n        while(headA!=null){\n            record.add(headA);\n            headA=headA.next;\n        }\n        while(headB!=null){\n            if(!record.add(headB)){\n                return headB;\n            }\n            headB = headB.next;\n        }\n        return null;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aatoe":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916965868","body":"先把卡打上，后面在优化。\n      var addToArrayForm = function(num, k) {\n        // 第一步先将k 加进num里，\n        let kArr = ('' + k).split('').reverse()\n        let len = kArr.length\n        for (let i = 0; i < len; i++) {\n          if (num[num.length - 1 - i] !== undefined) num[num.length - 1 - i] += +kArr[i]\n          else num.unshift(kArr[i])\n        }\n        console.log(num, 'num')\n        // 第二步将num里把每一项进行进位\n        let i = num.length - 1\n        while (i >= 0) {\n          // 大于9 进一\n          if (num[i] > 9) {\n            debugger\n            console.log(i, 'i')\n            if (i > 0) num[i - 1] = +num[i - 1] + parseInt((num[i] % 100) / 10)\n            else {\n              console.log(num[i], 'um[i]')\n              if (num[i] > 9) {\n                num.unshift()\n                let first = parseInt(num[i] % 10)\n                let second = parseInt((num[i] % 100) / 10)\n                num[i] = first\n                num.unshift(second)\n              } else {\n                num.unshift(num[i])\n              }\n            }\n            num[i] = parseInt(num[i] % 10)\n          }\n          i--\n        }\n        return num\n      }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917392659","body":"设置双循环，第一次循环将值存在数组中，\n第二次循环将获取到的值和第一次的做比较。得出最终的数组。 \n var shortestToChar = function(s, c) {\n        let result = []\n        let sArr = s.split('')\n        // 这是左循环\n        for (let i = 0; i < sArr.length; i++) {\n          let distance = 0\n          while (true) {\n            if (sArr[i + distance] === c) break\n            distance++\n            if (distance > s.length) {\n              distance = Infinity\n              break\n            }\n          }\n          result.push(distance)\n        }\n        // 这是右循环\n        for (let i = sArr.length - 1; i >= 0; i--) {\n          let distance = 0\n          while (true) {\n            if (sArr[i - distance] === c) break\n            distance++\n            if (distance > s.length) break\n          }\n          // 如果小于则替换\n          if (distance < result[i]) result.splice(i, 1, distance)\n        }\n        return result\n      }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917511353","body":"js code\n```js\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.arr = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.arr.length >=this.maxSize) return\n    this.arr.push(x)  \n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    // console.log(this,\"this\")\n    if(this.arr.length === 0) return -1\n    return this.arr.pop()\n    \n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    k = this.arr.length >k?k:this.arr.length\n    for(let i =0 ; i<k;i++){\n        this.arr[i] += val\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917904295","body":"```js\n      function decodeString(S) {\n        // if(S.length===0) return \"\"\n        let stack = []\n        let num = ''\n        for (const s of S) {\n          // 数字可能会多个,注意一下这里的技巧\n          if (!isNaN(s)) {\n            num += s\n            continue\n          }\n          if (num) {\n            stack.push(num)\n            num = ''\n          }\n\n          // 进栈\n          if (s !== ']') {\n            stack.push(s)\n            continue\n          } else if (s === ']') {\n            // 出栈\n            let str = ''\n            // 遇见 [ 出栈结束\n            while (stack.length && stack.slice(-1)[0] !== '[') {\n              let lastEle = stack.pop()\n              console.log(lastEle)\n              str = lastEle + str\n            }\n            stack.pop() // 删除 [\n            let num = +stack.pop()\n            stack.push(str.repeat(num))\n          }\n        }\n        console.log(stack, 'stack')\n        return stack.join('')\n      }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918717032","body":"```js\nvar MyQueue = function() {\n    this.arr = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.arr.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n   return this.arr.shift()\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.arr[0]\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.arr.length === 0\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919882076","body":"```js\n var maxChunksToSorted = function(arr) {\n   // 单调递增栈\n   let stack = []\n   for (const val of arr) {\n     if (stack.length === 0 || stack[stack.length - 1] <= val) {\n       stack.push(val)\n     } else {\n       let curMax = stack.pop()\n\t\t// 这种情况就是为了解决 arr = [1, 1, 0, 0, 1] ，有两个 1 都进去stack了，然后后面的 0，0 就会在 arr[1] 哪一块\n   \t// 他只能在 [1,1,0,0] 这一块。\n       while (stack.length > 0 && stack[stack.length - 1] > val) {\n         stack.pop()\n       }\n       stack.push(curMax)\n     }\n   }\n   console.log(stack, 'stack')\n   return stack.length\n }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920775673","body":"```js\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n  if (!head || !head.next) return head\n  // 使用快慢指针\n  let fast = head,\n    slow = head,\n    countLink = head,\n    count = 0\n  while (countLink) {\n    countLink = countLink.next\n    count += 1\n  }\n  // 当出现大于链表的长度的时候应该从0开始\n  k = k % count\n  while (fast.next) {\n    if (k-- <= 0) {\n      slow = slow.next\n    }\n    fast = fast.next\n  }\n  fast.next = head // 头尾相连\n  let res = slow.next // 链表头部\n  slow.next = null // 最后的元素进行断开\n  return res\n}\n\n执行用时：84 ms, 在所有 JavaScript 提交中击败了63.28%的用户\n内存消耗：39.6 MB, 在所有 JavaScript 提交中击败了29.85%的用户\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921545478","body":"使用curent记录当前遍历的位置，\n\n新建一个假的节点去记录上一个位置，先放在链表首。\n\n然后在while中进行替换，替换完之后，需要更新current中的值，这样就可以跳过2个了\n```js\nvar swapPairs = function(head) {\n  if (!head || !head.next) return head\n  let current = head\n  let res = head.next\n  \n  // 记录上一个节点，为了更加方便后续的交换操作，为了不想重新创建链表，将head赋值过去\n  // let preNode = head\n  \n  // 构造一个节点出来，为了更加方便后续的交换操作\n  let preNode = new Node()\n  preNode.next = head\n\n  while (current && current.next) {\n    let nextNode = current.next\n    let nnNode = nextNode.next\n\n    // 将 current 和 下一个的向进行交换位置\n    current.next = nnNode // 将 current下一项的指针指向下下项\n    nextNode.next = current // 将 nextNode 的下一项指针指向 current\n\n  \t// preNode总是记录上一项的的位置，让这个链表产生联系\n    preNode.next = nextNode \n    // 需要将最新的current赋值给preNode\n    preNode = current \n\n    // 需要将循环进行跳过2个\n    current = nnNode\n  }\n  return res\n}\n\n时间复杂度：所有节点只遍历一遍，时间复杂度为O(N)\n空间复杂度：未使用额外的空间，空间复杂度O(1)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BadCoderChou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916966133","body":"从低位往高位顺着加\r\n\r\n代码 ： java\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        int carry = 0;\r\n        List<Integer> res = new ArrayList<>();\r\n        int i = num.length - 1;\r\n        while (i >= 0 || k > 0) {\r\n            int cur = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry;\r\n            k = k > 0 ? k / 10 : 0;\r\n            i = i >= 0 ? i - 1 : -1;\r\n            carry = cur / 10;\r\n            cur = cur % 10;\r\n            res.add(cur);\r\n        }\r\n        if (carry == 1) res.add(carry);\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```\r\n复杂度分析\r\n时间复杂度：O(n)，其中 n 为数组的长度\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917419173","body":"思路\r\n左右循环遍历取最小距离值；\r\n\r\n代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] result = new int[len];\r\n        Arrays.fill(result, len);\r\n\r\n        //找左边的最近距离\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                result[i] = 0;\r\n            }\r\n            else if(i > 0){\r\n                result[i] = result[i-1] + 1;\r\n            }\r\n        }\r\n\r\n        for(int i = len - 1; i >= 0; i--){\r\n            if(s.charAt(i) == c){\r\n                result[i] = 0;\r\n            }\r\n            else if(i < len - 1){\r\n                result[i] = Math.min(result[i+1] + 1, result[i]);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```\r\n时间复杂度\r\nO（n）\r\n\r\n空间复杂度\r\nO（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917646199","body":"代码(Java)\r\n```java\r\nclass CustomStack {\r\n    List<Integer> stack; // stack_pre\r\n    int maxCap;\r\n    int currSize;\r\n    \r\n    List<Integer> incNum;\r\n    List<Integer> incVal;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new ArrayList<Integer>(maxSize);\r\n        maxCap = maxSize;\r\n        currSize = 0;\r\n        \r\n        incNum = new ArrayList<Integer>();\r\n        incVal = new ArrayList<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (currSize>=maxCap) return;\r\n        else {\r\n            if (currSize>=1) {                \r\n                stack.add(stack.get(currSize-1)+x);\r\n            }else {\r\n                stack.add(x);\r\n            }            \r\n            currSize++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (currSize<=0) return -1;\r\n        else {\r\n            int ele;\r\n            if (currSize>=2) ele = stack.get(currSize-1)-stack.get(currSize-2);\r\n            else ele = stack.get(currSize-1);\r\n            // compute ele with inc\r\n            for (int i =0; i<incNum.size(); ++i){\r\n                // System.out.println(ele);\r\n                if (currSize <= incNum.get(i)) {\r\n                   ele+= incVal.get(i);\r\n                   incNum.set(i, incNum.get(i)-1);\r\n                }\r\n            }\r\n            stack.remove(--currSize);\r\n            return ele;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        incNum.add(Math.min(k, currSize));\r\n        incVal.add(val);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918307353","body":"代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n```\n复杂度分析\n时间复杂度 O(n)\n\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919259108","body":"代码\n```java\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack1 = new Stack<Integer>();\n        stack2 = new Stack<Integer>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        while (!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n        stack1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n         if (!stack1.isEmpty() && stack2.isEmpty()){\n            while (!stack1.isEmpty()){\n                 stack2.push(stack1.pop());\n            }\n        } \n        return stack2.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        while (!stack1.isEmpty()){\n            stack2.push(stack1.pop());\n        }\n        return stack2.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n复杂度分析\n时间复杂度：push/pop/peek操作为O(N)，N为栈的长度。其他操作O(1)。\n空间复杂度：O(N)，使用了两个栈。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920077416","body":"```java\npublic int maxChunksToSorted(int[] arr) {\n\nint count=0;\nint sum1=0,sum2=0;\n\nint[] sortArr = Arrays.copyOf(arr, arr.length);\nArrays.sort(sortArr);\n\nfor (int i = 0; i < arr.length; i++) {\n\n    sum1+=arr[i];\n    sum2+=sortArr[i];\n\n    if (sum1 ==sum2) {\n        count ++;\n        //sum1 = sum2 = 0; \n    }\n}\nreturn count;\n```\n复杂度分析\n\n时间复杂度：O(NlogN)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921029009","body":"```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n\n        // Find length of list, and get the min k\n        int count = 0;\n        ListNode cur = head;\n        while (cur != null) {\n            cur = cur.next;\n            count++;\n        }\n        k = k % count;\n        if (k == 0) {\n            return head;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head;\n        count = 0;\n        while (count < k) {\n            fast = fast.next;\n            count++;\n        }\n        // Find the new head\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        // slow.next is the new head\n        ListNode newHead = slow.next;\n        fast.next = head;\n        slow.next = null;\n        return newHead;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921849509","body":"```java\n  public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        return swapKPairs(head,2);\n    }\n\n    public ListNode swapKPairs(ListNode head, int k) {\n        ListNode newHead = null;\n        ListNode preNode = null;\n        Deque<ListNode> stack = new LinkedList<>();\n        while (head != null) {\n            while (head != null && stack.size() != k) {\n                ListNode next = head.next;\n                head.next = null;\n                stack.push(head);\n                head = next;\n            }\n            \n            while (!stack.isEmpty()) {\n                if (newHead == null) {\n                    newHead = stack.peek();\n                }\n                if (preNode == null) {\n                    preNode = stack.pop();\n                } else {\n                    ListNode node = stack.pop();\n                    preNode.next = node;\n                    preNode = node;\n                }\n            }\n        }\n        return newHead;\n    }\n```\n时间&空间\n时间 o(n)\n空间 o(k) k = 2","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922314491","body":"```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        else if(head.next == null) return new TreeNode(head.val);\n        ListNode pre = head;\n        ListNode p = pre.next;\n        ListNode q = p.next;\n        //找到链表的中点p\n        while(q!=null && q.next!=null){\n            pre = pre.next;\n            p = pre.next;\n            q = q.next.next;\n        }\n        //将中点左边的链表分开\n        pre.next = null;\n        TreeNode root = new TreeNode(p.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(p.next);\n        return root;\n    }\n}\n```\n复杂度分析\n\n令 n 为数组长度。\n\n时间复杂度：$O(n)$\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922485939","body":"```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    if (headA == null || headB == null) {\n        return null;\n    }\n    ListNode curA = headA;\n    ListNode curB = headB;\n    while (curA != curB) {\n        curA = curA == null ? headB : curA.next;\n        curB = curB == null ? headA : curB.next;\n    }\n    return curA;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HWFrankFung":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916966146","body":"代码\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n复杂度\n时间复杂度：O(max(n,logk))\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420400","body":"Ideas\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nUse res[] to store every elemets distance to the specific c, by traversing the array s to seek whether there's any shorter distance.\n\nCode\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```javascript\nvar shortestToChar = function (s, c) {\n    let arr = []\n    let res = []\n    for (var i = 0; i < s.length; i++) {\n        if (s[i] === c) arr.push(i)\n    }\n\n    var dis = 0\n    for (var i = 0; i < s.length; i++) {\n        dis = Math.abs(i - arr[0])\n        for (var j = 1; j < arr.length; j++) {\n            dis = Math.min(dis, Math.abs(i - arr[j]))\n        }\n        res.push(dis)\n    }\n    return res\n};\n```\nComplexity\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nTime: O(n)  \nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917635651","body":"Ideas\n----------------------------------\nPush and pop can be directly called by arary.push() and array.pop(). Increment is also not that difficult. Compare k and the length of the array to determine which element should be increased. \n \nCode\n----------------------------------\n```javascript\n        var CustomStack = function (maxSize) {\n             this.arr = [];\n             this.maxSize = maxSize;\n        };\n\n        CustomStack.prototype.push = function (x) {\n            if (this.arr.length < this.maxSize){\n                this.arr.push(x);\n            }\n        };\n\n        CustomStack.prototype.pop = function () {\n            if (this.arr.length){\n                return this.arr.pop();\n            }\n            return -1;\n        };\n\n        CustomStack.prototype.increment = function (k, val) {\n            if(this.arr.length <= k) {\n                for(let i = 0; i < this.arr.length; i++){\n                    this.arr[i] += val;\n                }\n            }else{\n                for(let i = 0; i < k; i++){\n                    this.arr[i] += val;\n                }\n            }\n        };\n```\nComplexity\n-----------------------------------------------\npop() and push: O(1)  \nIncrement: O(k)\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918227624","body":"Ideas\n-------\nI use two stacks to store the multiples in front of the [ while the other does the same job on the letters called numStack and strStack. When it gets the [, numbers in front of it should be push into the first stack while the letters are pushed into the other. When it meets ], it's time to construct the result with the former elements stored.   \n\nCode\n---- \n```javascript\nvar decodeString = function(s) {\n    let numStack = [];        \n    let strStack = [];        \n    let num = 0;              \n    let res = '';        \n    for (const char of s) {   \n        if (!isNaN(char)) {   \n            num = num * 10 + Number(char); \n        } else if (char == '[') {  \n            strStack.push(res); \n            res = '';           \n            numStack.push(num);   \n            num = 0;              \n        } else if (char == ']') {  \n            let Times = numStack.pop(); \n            res = strStack.pop() + res.repeat(Times); \n        } else {                   \n            res += char;        \n        }\n    }\n    return res;\n};\n```\n\nComplexity\n-\nTime: O(n)  \nSpace:O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919206068","body":"Ideas\r\n-\r\n\r\nDesign two stacks. The first one is from FIFO while the other is LIFO.\r\n\r\nCode\r\n-\r\n\r\n```javascript\r\n        var MyQueue = function () {\r\n            this.inStack = [];\r\n            this.outStack = [];\r\n        };\r\n\r\n        MyQueue.prototype.push = function (x) {\r\n            this.inStack.push(x);\r\n        };\r\n\r\n        MyQueue.prototype.pop = function () {\r\n            const size = this.outStack.length;\r\n            if (size) {\r\n                return this.outStack.pop();\r\n            }\r\n            while (this.inStack.length) {\r\n                this.outStack.push(this.inStack.pop());\r\n            }\r\n            return this.outStack.pop();\r\n        };\r\n\r\n        MyQueue.prototype.peek = function () {\r\n            const p = this.pop();\r\n            this.outStack.push(p);\r\n            return p;\r\n        };\r\n\r\n        MyQueue.prototype.empty = function () {\r\n            return this.outStack.length === 0 && this.inStack.length === 0;\r\n        };\r\n```\r\n\r\nComplexity:\r\n-\r\nTime: O(1)\r\n\r\nSpace: O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920096813","body":"Ideas\n-\nToday is too busy to do the execise. I just simply code these code refers to others' ideas and I will figure it out on my own tomorrow.\n\nCode\n-\n\n```javascript\nvar maxChunksToSorted = function(arr) {\n    const stack = []\n    let max = -1\n    for(let i = 0; i < arr.length; i++){\n        if (arr[i] >= max) {\n            stack.push(arr[i])\n            max = arr[i]\n        } else {\n            while(arr[i] < stack[stack.length - 1] && stack.length) {\n                stack.pop()\n            }\n            stack.push(max)\n        }\n    }\n    return stack.length\n};\n```\n\nComplexity\n-\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920988683","body":"Ideas\n-\nThe length of the linkedlist is n. We can treat it as a loop with k % n times and stop at the top point.\n\nCode\n-\n```javascript\nvar rotateRight = function (head, k) {\n    if (! head || ! head.next) {\n        return head;\n    }\n    let curr = head;\n    let len = 0;\n    while (++ len && curr.next) {\n        curr = curr.next;\n    }\n    curr.next = head;\n    k % = len;\n    while (++ k < len) {\n        head = head.next;\n    }\n    let tmp = head;\n    head = head.next;\n    tmp.next = null;\n    return head;\n}\n```\n\nComplexity\n-\n\nTime:O(n)  \nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921846464","body":"Ideas\n-\n\nCode\n-\n\n```javascript\nvar swapPairs = function(head) {\n    let thead = new ListNode(0);\n    thead.next = head;\n    let tmp = thead;\n    while(tmp.next != null && tmp.next.next != null){\n        let start = tmp.next;\n        let end = start.next;\n        tmp.next = end;\n        start.next = end.next;\n        end.next = start;\n        tmp = start;\n    }\n    return thead.next;\n};\n```\n\nComplexity\n-\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922279580","body":"Ideas\n-\nTwo pointes to find the middle node.\n\nCodes\n-\n\n```javascript\n var sortedListToBST = function(head) {\n    const recursion = (head) => {\n        if(!head) {\n           return null \n        }\n        let emptyNode = prev = new ListNode()\n        prev.next = head\n        let slow = fast = head\n        while(fast && fast.next) {\n            slow = slow.next\n            fast = fast.next.next\n            prev = prev.next\n        }\n        prev.next = null\n        const node = new TreeNode(slow.val)\n        node.left = recursion(emptyNode.next)\n        node.right = recursion(slow.next)\n        return node\n    }\n    return recursion(head)\n};\n```\n\nComplexity\n-\nTime: O(n)  \nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922486831","body":"Ideas\n-\n\nTime limited, I applied a brutal method to do so. Time complexity might not good enough. The main idea is traversing all nodes in listA and find if there's a same one in the listB.\n\nCodes\n-\n\n```javascript\nvar getIntersectionNode = function (headA, headB) {\n    if (!headA || !headB) return null;\n\n    let pA = headA;\n    while (pA) {\n        let pB = headB;\n\n        while (pB) {\n            if (pA === pB) return pA;\n            pB = pB.next;\n        }\n\n        pA = pA.next;\n    }\n};\n```\n\nComplexity\n-\nTime: O(m*n)\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangyifan2018":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916969010","body":"## 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int sum = 0, len = num.length;\n        List<Integer> res = new ArrayList<Integer>();\n\n        for(int i = len - 1; i >= 0; i--){\n            sum = num[i] + k % 10;\n            k /= 10;\n            if(sum >= 10){\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for(; k > 0; k/= 10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917409958","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[s.length()];\n        Arrays.fill(ans, n - 1);\n        int right = n - 1;\n\n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) ==c){\n                ans[i] = 0;\n                right = i;\n            } else{\n                ans[i] = Math.min(ans[i], Math.abs(right - i));\n            }\n        }\n\n        for(int i = n - 1; i>=0; --i){\n            if(s.charAt(i) == c){\n                right = i;\n                ans[i] = 0;\n            }\n            else{\n                ans[i] = Math.min(ans[i], Math.abs(right - i));\n            }\n        }\n\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917515042","body":"## 添加一个add数组做累积\n\n```java\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top != stack.length - 1){\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top == -1){\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if(top != 0){\n            add[top - 1] += add[top];\n        }\n        add[top] = 0;\n        --top;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k-1, top);\n        if(limit >= 0){\n            add[limit] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917777270","body":"```golang\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n\nfunc decodeString(s string) string {\n    stk := []string{}\n    ptr := 0\n    for ptr < len(s) {\n        cur := s[ptr]\n        if cur >= '0' && cur <= '9'{\n            digits := getDigis(s, &ptr)\n            stk = append(stk, digits)\n        } else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <='Z' || cur =='['){\n            stk = append(stk, string(cur))\n            ptr++\n        } else {\n            ptr ++\n            sub := []string{}\n            for stk[len(stk) - 1] != \"[\" {\n                sub = append(sub, stk[len(stk) - 1])\n                stk = stk[:len(stk)-1]\n            }\n            for i := 0; i < len(sub)/2; i++{\n                sub[i], sub[len(sub) -i - 1] = sub[len(sub) -i -1], sub[i]\n            }\n            stk = stk[:len(stk) - 1]\n            repTime, _ := strconv.Atoi(stk[len(stk) -1])\n            stk = stk[: len(stk) - 1]\n            t := strings.Repeat(getString(sub), repTime)\n            stk = append(stk, t)\n        }\n    }\n    return getString(stk)\n}\n\nfunc getDigis(s string, ptr *int) string {\n    ret := \"\"\n    for ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++{\n        ret += string(s[*ptr])\n    }\n    return ret\n}\n\nfunc getString(v []string) string {\n    ret := \"\"\n    for _, s := range v {\n        ret += s\n    }\n    return ret\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918727077","body":"```golang\ntype MyQueue struct {\n    inStack, outStack []int\n}\n\n\n/** Initialize your data structure here. */\nfunc Constructor() MyQueue {\n    return MyQueue{}\n}\n\n\n/** Push element x to the back of queue. */\nfunc (this *MyQueue) Push(x int)  {\n    this.inStack = append(this.inStack, x)\n}\n\nfunc (this *MyQueue) in2out() {\n    for len(this.inStack) > 0 {\n        this.outStack = append(this.outStack, this.inStack[len(this.inStack) - 1])\n        this.inStack = this.inStack[:len(this.inStack) - 1]\n    }\n}\n\n/** Removes the element from in front of queue and returns that element. */\nfunc (this *MyQueue) Pop() int {\n    if len(this.outStack) == 0 {\n        this.in2out()\n    }\n    x := this.outStack[len(this.outStack) - 1]\n    this.outStack = this.outStack[:len(this.outStack) - 1]\n    return x\n}\n\n\n/** Get the front element. */\nfunc (this *MyQueue) Peek() int {\n    if len(this.outStack) == 0{\n        this.in2out()\n    }\n    y := this.outStack[len(this.outStack) - 1]\n    return y\n    \n}\n\n\n/** Returns whether the queue is empty. */\nfunc (this *MyQueue) Empty() bool {\n    return len(this.inStack) == 0 && len(this.outStack) == 0\n}\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Peek();\n * param_4 := obj.Empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919666303","body":"```golang\nfunc maxChunksToSorted(arr []int) int {\n    res := 0\n    minRight := make([]int ,len(arr))\n    maxLeft:=arr[0]\n    minRight[len(arr)-1] = arr[len(arr)-1]\n   //维护一个数组，保存其右边最小的值\n    for i:=len(arr)-2;i>=0;i--{\n        minRight[i] = min(minRight[i+1],arr[i])\n    }\n    //遍历数组，将左边的最大值和左边的最小值比较\n    for i:=0;i<len(arr)-1;i++{\n        maxLeft = max(maxLeft,arr[i])\n        if (maxLeft<=minRight[i+1]){\n            res ++\n        }\n    }\n    return res+1 \n}\n//返回两数较小的\nfunc min(a int, b int) int{\n    if a < b{\n        return a\n    }\n    return b\n}\n//返回两数较大的\nfunc max(a int, b int) int{\n    if a > b{\n        return a\n    }\n    return b\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920511873","body":"```golang\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc rotateRight(head *ListNode, k int) *ListNode {\n    if head == nil || head.Next == nil || k==0 {\n        return head\n    }\n    fast := &ListNode{Val: 0, Next: head}\n    slow := &ListNode{Val: 0, Next: head}\n\n    for i := 0; i < k ; i++ {\n        fast = fast.Next\n        if fast == nil {\n            fast = head\n        }\n    }\n    for fast.Next != nil {\n        fast = fast.Next\n        slow = slow.Next\n    }\n    if slow.Next == head {\n        return head\n    }\n    fast.Next = head\n    head = slow.Next\n    slow.Next = nil\n    return head\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921377305","body":"```golang\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n    dummyHead := &ListNode{0, head}\n    temp := dummyHead\n    for temp.Next != nil && temp.Next.Next != nil {\n        node1 := temp.Next\n        node2 := temp.Next.Next\n        temp.Next = node2\n        node1.Next = node2.Next\n        node2.Next = node1\n        temp = node1\n    }\n    return dummyHead.Next\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922159920","body":"```golang\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sortedListToBST(head *ListNode) *TreeNode {\n    return buildTree(head, nil)\n}\n\nfunc buildTree(left, right *ListNode) *TreeNode {\n    if (left == right){\n        return nil\n    }\n    fast, slow := left, left\n    for fast != right && fast.Next != right {\n        fast = fast.Next.Next\n        slow = slow.Next\n    }\n    mid := slow\n    root := &TreeNode{mid.Val, nil, nil}\n    root.Left = buildTree(left, mid)\n    root.Right = buildTree(mid.Next, right)\n    return root\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922401719","body":"```golang\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    if headA == nil || headB ==nil {\n        return nil\n    }\n    pa, pb := headA, headB\n    count := 0\n    for pa != pb {\n        if pa == nil {\n            pa = headB\n            count++\n        } else {\n            pa = pa.Next\n        }\n        if pb == nil {\n            pb = headA\n            count++\n        } else {\n            pb = pb.Next\n        }\n        if count > 2 {\n            return nil\n        }      \n    }\n    return pa\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eemsyw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916969273","body":"## 思路\n数字逐位相加，满十进一。\n## 代码\n```\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n```\n\n## 复杂度\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linearindep":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916969683","body":"【思路】这题肯定要用reverse,因为add（0，x)更可怕。如果先把array转为int的话，在大数字面前就不准。所以最好还是直接在array上面操作。就是普通的进位。从右到左，依次相加。保留一个进位。每次每位上面的数字就是 k%10 + num[pos] + carry. 如果k还有但是pos没有的话，num[pos] = 0；\r\n【复杂度】O（n) ，遍历一遍，reverse也是O(n)\r\n\r\n```\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> rtn = new ArrayList<>();\r\n\r\n        int[] ans = num;\r\n        int add = k;\r\n        int carry = 0;\r\n        int pos = num.length - 1;\r\n        while(add != 0 || pos >= 0){\r\n            int newDigit = add % 10;\r\n            int oldDigit = (pos>=0)? num[pos] : 0;\r\n            int newSum = newDigit + oldDigit + carry;\r\n            carry = newSum / 10 ;\r\n            rtn. add( newSum % 10);\r\n            pos--;\r\n            add = add /10;\r\n        }\r\n        if(carry!=0) rtn.add(carry);\r\n        \r\n        Collections.reverse(rtn);\r\n        return rtn;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334683","body":"【思路】从左和右各遍历一遍代码，左边起始可以是-10000，右边是10000 【题目说size<10^4】，记录发现c的位置，然后和之前发现的C的位置相减。最后取左右两边算出来最小的值\r\n【复杂度分析】O（n）\r\n\r\n```\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] left = new int[s.length()];\r\n        int[] right = new int[s.length()];\r\n\r\n        int leftPos = -10000;\r\n        int rightPos = 10000;\r\n        for(int i = 0 ; i < s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                leftPos = i;\r\n                left[i] = 0;\r\n            }else{\r\n                left[i] = -leftPos+i;\r\n            }\r\n        }\r\n\r\n        for(int i = s.length()-1 ; i >= 0; i--){\r\n            if(s.charAt(i) == c){\r\n                rightPos = i;\r\n                right[i] = 0;\r\n            }else{\r\n                right[i] = rightPos - i;\r\n            }\r\n             left[i] = Math.min(left[i],right[i]);\r\n        }\r\n\r\n        \r\n        return left;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917553871","body":"【思路】前缀和。 每次increament的时候，把所有从0到k都加val。因为我们并不需要储存每一个加好的值。可以不断累积。在最后pop的时候把累积的值加上再return；\r\n【复杂度】O（1）\r\n\r\n```\r\nArrayList<Integer> stack = new ArrayList<>();\r\n    int size = 0;\r\n    int capacity = 0;\r\n    int[] inc ;\r\n    public CustomStack(int maxSize) {\r\n       \r\n        this.capacity = maxSize;\r\n        this.inc = new int[maxSize];\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(size+1 > capacity){\r\n            return;\r\n        }\r\n\r\n        stack.add(x);\r\n        size++;\r\n\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size==0) return -1;\r\n        int temp = this.stack.remove(size-1);\r\n        size--;\r\n        temp = temp + this.inc[size];\r\n        this.inc[size] = 0;\r\n        return temp;\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i<k; i++){\r\n            if(i>=this.size) return;\r\n            this.inc[i] += val;\r\n        }\r\n\r\n    }\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917854025","body":"【思路】用两个stack记录，一个记录string，一个记录数字。遍历string，碰到左括号[就往前看数字，算出结果，存入另一个stack中，碰到右括号就不停pop，直到发现左括号，这样就算出了substring，再pop出已经通过左括号算好的次数，形成有效的长度，在放回stack中，这样下一个括号迭代也可以把这个弄好的string放入计算。\r\n\r\n但是这样其实弄复杂了。题解好像是在遍历string的时候，碰到数字就可以直接计算，每次往前*10就可以了，碰到左括号就直接加入int stack更方便了。少了一次while pop。[机智\r\n【复杂度】O（n)\r\n\r\n```\r\npublic String decodeString(String s) {\r\n        Stack<Character> num = new Stack<>();\r\n        Stack<Integer> each = new Stack<>();\r\n        Stack<String> decode = new Stack<>();\r\n        String ans = \"\";\r\n        \r\n        for(int i = 0; i< s.length(); i++){\r\n            Character temp = s.charAt(i);\r\n            if(Character.isDigit(temp)){\r\n                num.push(temp);\r\n            }else if(temp == ']'){\r\n                String curr = decode.pop();\r\n                String local = \"\";\r\n                String total = \"\";\r\n                \r\n                while(!curr.equals(\"[\") ){\r\n                    local = curr + local;\r\n                    curr = decode.pop();\r\n                }\r\n                int times = each.pop();\r\n                for(int j = 0; j<times; j++){\r\n                    total = total+local;\r\n                }\r\n                decode.push(total);\r\n            }else if(temp == '['){\r\n                decode.push(temp+\"\");\r\n                Character curr3 = num.pop();\r\n                int pos = 1;\r\n                int sum = curr3-'0';\r\n                while(curr3!='['&& !num.isEmpty()) {\r\n                    pos = pos *10;\r\n                    curr3 = num.pop();\r\n                    int now = curr3-'0';\r\n                    sum += pos * now;\r\n                    \r\n                    \r\n                }\r\n                each.add(sum);\r\n            }else{\r\n                decode.push(temp+\"\");\r\n            } \r\n        }\r\n        \r\n    \r\n        while(!decode.isEmpty()){\r\n            ans =decode.pop() + ans ;\r\n        }\r\n        return ans;\r\n\r\n\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919271830","body":"【思路】其实只用每次pop/peek的时候，如果输出的站没有东西了，就把之前入站的东西拿出来，放进新的。这样的话输出的站的就是需要的顺序了\r\n【复杂度】peek/pop O(n) 其他O(1)\r\n```\r\nStack<Integer> first = new Stack<Integer>();\r\n    Stack<Integer> second = new Stack<Integer>();\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        first.push(x);\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(second.isEmpty()){\r\n            while(!first.isEmpty()){\r\n                int temp = first.pop();\r\n                second.push(temp);\r\n            }\r\n        }\r\n        return second.pop();\r\n\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(second.isEmpty()){\r\n            while(!first.isEmpty()){\r\n                int temp = first.pop();\r\n                second.push(temp);\r\n            }\r\n        }\r\n        return second.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return first.isEmpty() && second.isEmpty();\r\n\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919697015","body":"【思路】遍历array，我们会发现，只要是一个数的左边的从前面一个chunk往后的所有数字都大于它的话，他们就自动成为一个chunk。如果它大于左边所有的数，那它自己就成为新的chunk。所以我们要用stack来保持每个chunk的最大值。遍历数组的时候，不停pop之前的stack，直到找到比自己小的停下。在每次pop的时候，还需要保持整个chunk的最大值，最后停止的时候要把最大值放回。\r\n这样最后stack的size就是有几块了\r\n【复杂度】O(n)\r\n```\r\npublic int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> chunk = new Stack<Integer>();\r\n       for(int i = 0; i< arr.length ; i++){\r\n           int temp = arr[i];\r\n           int max  = temp;\r\n           while(!chunk.isEmpty()){\r\n               int curr = chunk.pop();\r\n               max = Math.max(max,curr);\r\n               if(temp<curr){\r\n                   \r\n               }\r\n               else {\r\n                    chunk.push(curr);\r\n                    break; \r\n               }\r\n               \r\n           }\r\n        chunk.push(max);\r\n           \r\n       }\r\n       return chunk.size();\r\n\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920593907","body":"【思路】先遍历一遍，得到尾巴和数量。在求余数得到旋转的次数。 用size-次数，得到新的尾巴，新的尾巴的下一个是新的头，把旧尾巴和新头连起来就行了。\r\n 这题主要注意的几个base case！！比如head ==null k==0，还有rotation==0的情况，都要做到心中有数\r\n【复杂度】 O（n) 遍历整个list\r\n\r\n```\r\npublic ListNode rotateRight(ListNode head, int k) {\r\n    \r\n       ListNode temp = head;\r\n       ListNode tail = head;\r\n       int size = 0;\r\n       while(temp!=null){\r\n           size++;\r\n           tail = temp;\r\n           temp = temp.next;\r\n       }\r\n       if(size ==0 || k == 0) return head;\r\n       int rotate =  k % size ;\r\n        if(rotate == 0) return head;\r\n\r\n       ListNode curr = head;\r\n       for(int i = 1; i<size - rotate; i++){\r\n           curr = curr.next;\r\n       }\r\n       ListNode newTail = curr;\r\n       ListNode newHead = curr.next;\r\n        newTail.next = null;\r\n        tail.next = head;\r\n\r\n        return newHead;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921489289","body":"【思路】递归 如果只剩自己（没有next）或者自己是null，就return 自己 因为没有旋转的条件了。然后把return的值【已经换好的后面list的头】，放在第一个的后面，第二个.next=第一个， 把第二个return回去就好了\r\n【复杂度】 遍历一遍，所以是O(n)\r\n\r\n\r\n```\r\npublic ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n\r\n        ListNode first = head;\r\n        ListNode second = head.next;\r\n\r\n        ListNode next = second.next;\r\n\r\n        ListNode firstNext = swapPairs(next);\r\n\r\n        second.next = first;\r\n        first.next = firstNext;\r\n        return second;\r\n\r\n    }\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iciue":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916971835","body":"### 代码\n```js\nconst solution = (num, k) => {\n    const result = []\n    let [cleanNum, carry] = [num, k]\n\n    while(cleanNum.length || carry) {\n        const sum = cleanNum.pop() || 0 + carry % 10\n        carry = ~~(sum / 10) + ~~(carry / 10)\n        result.push(sum)\n    }\n\n    if (carry) result.push(carry)\n    \n    return result.reverse()\n}\n```\n\n### 复杂度分析\n时间复杂度: O(Math.max(num.length, k.length) + result.length)\n\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917574447","body":"### 思路\n参考官方题解，分两次遍历数组，查找每个字符的最近目标字符的下标组成数组。 再次遍历下下标数组， 计算最短距离。\n\n### 代码\n```js\nfunction shortestToChar(s: string, c: string): number[] {\n  const len = s.length;\n  const res = new Array(len).fill(Infinity)\n  \n  for (let i = 0; i < len; i++) {\n    if (s[i] === c) res[i] = i;\n    else if (res[i - 1] !==undefined && res[i - 1] !== Infinity) res[i] = res[i - 1]\n  }\n  for (let i = len - 1; i >= 0; i--) {\n    if (s[i] !== c) {\n      res[i] = Math.abs(res[i + 1] - i) <= Math.abs(res[i] - i) ? res[i + 1] : res[i]\n    }\n  }\n  for (let i = 0; i < len; i++) {\n    res[i] = Math.abs(res[i] - i);\n  }\n  \n  \n  return res;\n};\n```\n\n### 复杂度分析\n时间复杂度: O(n)\n\n空间复杂度: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662767","body":"### 思路\n利用数组模拟栈，维护一个额外的 increment数组， pop 时再计算增加的值\n\n### 代码\n```ts\nclass CustomStack {\n    maxSize:number;\n    cnt:number;\n    stack: Array<number>;\n    incrementInfos: Array<number>;\n\n    constructor(maxSize: number) {\n      this.maxSize = maxSize;\n      this.cnt = -1;\n      this.incrementInfos = new Array(maxSize).fill(0);\n      this.stack = [];\n    }\n\n    push(x: number): void {\n      if (this.cnt < this.maxSize -1) {\n        this.cnt++;\n        this.stack.push(x);\n      }\n    }\n\n    pop(): number {\n      if (this.cnt === -1) return -1;\n      const inc = this.incrementInfos[this.cnt];\n      \n      if (inc) {\n        this.incrementInfos[this.cnt] = 0;\n        this.incrementInfos[this.cnt -1] += inc;\n      }\n      this.cnt--;\n      return this.stack.pop() + inc;\n    }\n\n    increment(k: number, val: number): void {\n      let i = k;\n      if (this.cnt < i) i = this.cnt + 1;\n      if (i > 0 ) this.incrementInfos[i - 1] += val;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918225010","body":"### 思路\n利用栈匹配括号，提取需要重复的元素和需要重复的次数\n\n### 代码\n```ts\nfunction decodeString(s: string): string {\n  let result = []\n  for (let i = 0; i < s.length; i++) {\n    const c = s[i]\n    if (c === ']') {\n      let repeatSt = ''\n      let repeatCnt = ''\n      \n      while (result[result.length - 1] !== '[') {\n        repeatSt = result.pop() + repeatSt\n      }\n\n      result.pop()\n\n      while (/\\d/.test(result[result.length - 1])) {\n        repeatCnt = result.pop() + repeatCnt\n      }\n      \n      result.push(...repeatSt.repeat(~~repeatCnt));\n      \n    } else {\n      result.push(c);\n    }\n  }\n  return result.join('');\n};\n```\n\n### 复杂度\n时间 O(n)\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918710988","body":"### 思路\n利用两个栈分别模拟队列的压入和弹出操作\n\n### 代码\n```ts\nclass MyQueue {\n    inStack: Array<any>\n    outStack: Array<any>\n    constructor() {\n      this.inStack = []\n      this.outStack = []\n    }\n\n    push(x: number): void {\n      this.inStack.push(x)\n    }\n\n    pop(): number {\n      if (this.empty()) return -1\n      if (this.outStack.length === 0) this.peek()\n      return this.outStack.pop()\n    }\n\n    peek(): number {\n      if (this.empty()) return -1\n      if (this.outStack.length === 0) {\n        while (this.inStack.length !== 0) {\n          this.outStack.push(this.inStack.pop())\n        }\n      }\n      return this.outStack[this.outStack.length - 1]\n    }\n\n    empty(): boolean {\n      return this.inStack.length === 0 && this.outStack.length === 0\n    }\n}\n\n```\n\n### 复杂度\n时间 O(n)\n空间 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiayinya":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916972497","body":"### 解题思路\r\n##### 1. 暴力解题 （将两数相加 —>转成数组）【自己最开始的想法】（测试耗时76s）\r\n好吧，补充下，提交之后发现这种写法是错误的。\r\n```javascript\r\n  var addToArrayForm = function(num, k) {\r\n    let str = ''\r\n    for (const i of num) {\r\n      str = str + i\r\n    }\r\n    const numStr = Number(str)\r\n    const sum = numStr + k\r\n    const sumStr = sum.toString()\r\n    // 将数字1234变成[1, 2, 3, 4]\r\n    const arr = []\r\n    for (let i = 0; i < sumStr.length; i++) {\r\n      arr.push(Number(sumStr[i]))\r\n    }\r\n    return arr\r\n  };\r\n```\r\n时间复杂度：\r\n空间复杂度：O(1)\r\n\r\n##### 2. 力扣优解（测试耗时80s，迷茫了，怎么比暴力解题的时间还长），这个优解还未彻底理解，待消化\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n  let count = 0\r\n  const len = k.toString().length\r\n  for (let i = 0; i < len; i++) {\r\n    if (num.length < len) {\r\n      num.unshift(0)\r\n    }\r\n    count = k % 10\r\n    k = parseInt(k / 10)\r\n    num[num.length - 1 - i] += count\r\n  }\r\n  for (let i = 0; i < num.length; i++) {\r\n    if (num[0] > 9) {\r\n      num.unshift(0)\r\n    }\r\n    if (num[num.length - 1 - i] > 9) {\r\n      num[num.length - 2 - i]++\r\n      num[num.length - 1 - i] = num[num.length - 1 - i] % 10\r\n    }\r\n  }\r\n  return num\r\n};\r\n```\r\n时间复杂度：\r\n空间复杂度：O(1) ","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919039736","body":"### 思路\r\n将一个栈当作输入栈，用于push传入的数据；另一个栈当作输出栈，用于pop 和 peek 操作。\r\n\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.inStack = [];\r\n    this.outStack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.inStack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\nMyQueue.prototype.in2out = function() {\r\n    while (this.inStack.length) {\r\n        this.outStack.push(this.inStack.pop());\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920016033","body":"### 思路\r\n单调递增栈\r\n### 代码\r\n```javascript\r\n/**\r\n *\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted1 = function (arr) {\r\n    let stack = [];\r\n\r\n    for (let val of arr) {\r\n        // 大于栈顶元素，直接入栈，算一个块\r\n        if (!stack.length || stack[stack.length - 1] <= val) {\r\n            stack.push(val);\r\n        } else {\r\n            let curMax = stack.pop();\r\n            // val和这些弹出的元素算一个块\r\n            while (stack.length && stack[stack.length - 1] > val) {\r\n                stack.pop();\r\n            }\r\n            // 保存块中的最大值\r\n            stack.push(curMax);\r\n        }\r\n    }\r\n    return stack.length;\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度O(nlogn)\r\n空间复杂度O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920945125","body":"### 思路\r\n**思路分析：**\r\n  给定链表的长度为n，往后移动k位，有如下几种情况\r\n  k < n ，那么移动的位数直接就是k\r\n  k >=  n\t\r\n  k 是 n 的整数倍，那么链表的位置不会发生变化\r\n  k 不是 n 的整数倍，实际移动的值是 k / n 的余数的值\r\n\r\n**解题步骤**\r\n（1）计算链表的长度\r\n（2）判断链表长度与 k 的情况，做出相对应的操作\r\n### 代码\r\n```JavaScript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    // 1. 计算链表的长度\r\n    // 【第一步】建立锚节点，记录链表的头结点\r\n    const first = new ListNode(0, head)\r\n    let cur = first\r\n    // 【第二步，循环计算链表的长度】\r\n    var len = 0\r\n    while(cur.next) {\r\n        cur = cur.next\r\n        len++\r\n    }\r\n\r\n    // 取余数判断\r\n    var r = k / len\r\n\r\n    // 2. 链表的长度等于要移动的次数，或者移动次数是链表长度的倍数，直接返回链表\r\n    if (r === 0) {\r\n        return head\r\n    } else {\r\n        // 形成闭环链表\r\n        // 将链表的最后一个位置，指向链表的第一个位置，形成一个环链表\r\n        cur.next = first.next\r\n        while(r) {\r\n            cur = cur.next\r\n            r--\r\n        }\r\n\r\n        const result = cur.next\r\n        cur.next = null     // 断开链表\r\n        return result\r\n    }\r\n    \r\n};\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921780547","body":"### 思路：递归\r\n\r\n### 代码\r\n```JavaScript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    // 1. 如果链表为空或者只有1位，不做交换，直接返回\r\n    if (head === null || head.next === null) {\r\n        return head\r\n    }\r\n\r\n    // 2. 获取第二个节点\r\n    const second = head.next\r\n\r\n    // 3. 递归将下一组的头节点传入（也就是第三个节点）& 将第一组的节点连接第二组的头节点\r\n    head.next = swapPairs(second.next)\r\n\r\n    // 4. 第二个节点连接head\r\n    second.next = head\r\n\r\n    return second\r\n};\r\n```\r\n\r\n### 复杂度\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chaggle":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916974685","body":"# Day-1 ：2021-09-10 \n\n# 989.数组形式的整数加法\n\n### 题目\n\n```cpp\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 题目思路\n\n-   1、建立一个res的动态数组，以位数的形式来存储最后的结果值；\n-   2、从后往前与k相加，然后对相加得到的值对10进行求余数；\n-   3、如果k的位数大于nums数组所给的位数时候，必然导致k在循环内除以10后余留的值大于0，此时需要扩展数组，由于是动态数组，直接改写类似循环中k = sum / 10，此处为k /= 10，直到k为0为止。\n-   4、最后逆序数组即可输出。\n\n## 题目代码\n\n### 代码块\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& nums, int k) {\n        vector<int> res;\n        for(int i = nums.size() - 1; i >= 0; i--)\n        {\n            int sum = nums[i] + k;\n            res.push_back(r % 10);\n            k = sum / 10;\n        }\n\n        while(k > 0)\n        {\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        \n        reverse(res.begin(), res.end());\n        //此处使用reverse函数时间复杂度会更低一些\n        /* for(int i = 0, j = res.size() - 1; i < j; i++, j--)\n        {\n            int temp = res[i];\n            res[i] = res[j];\n            res[j] = temp;\n        }  */\n        \n        return res;\n    }\n};\n```\n\n## 复杂度\n\n-   空间复杂度：申请了一个常数级数组，故空间为O(1)\n-   时间复杂度：$O(max(n, \\log k))$，其中n为数组的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917380909","body":"# Day-2 ：2021-09-11 \n\n# **821. 字符的最短距离**\n\n### 题目\n\n```cpp\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n```\n\n## 题目思路\n\n-   1、建立一个vector存储遍历字符串后等于输入字符c的位置position下标\n-   2、对于每一个位置，将其减去数组中的值，返回其abs（绝对值），并返回其中最小的值。\n-   3、min(abs(i - pos[j]), abs(i - pos[j + 1]))中会出现数组长度为一的特殊的情况，所以此处在今晚会进一步进行优化。\n\n## 题目代码\n\n### 代码块\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> pos;\n        vector<int> ans(n, n); \n        for(int i = 0; i < n; i++)\n        {\n            if(s[i] == c) pos.push_back(i);\n        }\n        \n        for(int i = 0; i < n; i++)\n        {\n            int tmp = 0;\n            if(pos.size() != 1)\n            {\n                for(int j = 0; j < pos.size() - 1; j++)\n                {\n                    tmp = min(abs(i - pos[j]), abs(i - pos[j + 1]));\n                    if(ans[i] > tmp) ans[i] = tmp;\n                }\n            }\n            else \n            {\n                ans[i] = abs(i - pos[0]);\n            }\n            \n        }\n        return ans;\n    }\n};\n```\n\n## 复杂度\n\n-   时间复杂度：O(n*k)，n是s的长度，k是字符c在字符串中出现的次数，k <= n。\n\n-   空间复杂度：O(k)，k为字符c出现的次数，这是记录字符c出现下标的辅助数组消耗的空间。\n\n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917605390","body":"# Day-3 ：2021-09-12 \n\n# **821. 字符的最短距离**\n\n### 题目\n\n```cpp\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n    \nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1); // 栈变为 [1]\ncustomStack.push(2); // 栈变为 [1, 2]\ncustomStack.pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2); // 栈变为 [1, 2]\ncustomStack.push(3); // 栈变为 [1, 2, 3]\ncustomStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100); // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100); // 栈变为 [201, 202, 103]\ncustomStack.pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop(); // 返回 -1 --> 栈为空，返回 -1\n\n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 题目思路\n\n-   1、创建一个动态数组data，可以使用c++中的resize函数重置数组容量；\n-   2、push、pop都是经典的栈写法；\n-   3、increment数通过一个数组遍历即可。\n\n### 代码块\n\n```c++\nclass CustomStack {\nprivate:\n    vector<int> data;\n    int top;\n    \npublic:\n    CustomStack(int maxSize) \n    {\n        data.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) \n    {\n        if (top != data.size() - 1) \n        {\n            data[++top] = x;\n        }\n    }\n    \n    int pop() \n    {\n        if (top == -1) return -1;\n        else return data[top--];\n    }\n    \n    void increment(int k, int val) \n    {\n        int minx = k  < (top + 1) ?  k : top + 1;\n        for (int i = 0; i < minx; i++) \n        {\n            data[i] += val;\n        }\n    }\n};\n```\n\n## 复杂度\n\n-   时间复杂度：push、pop均为O(1)，而increment为O(minx)。\n\n-   空间复杂度：由创建的动态数组data的长度决定，即为O(maxSize)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917995705","body":"# Day-4 ：2021-09-13\n\n# **[394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)**\n\n### 题目\n\n```cpp\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n \n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n示例 3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n示例 4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n```\n\n## 题目思路\n\n- 1、创建一个stack<string> res的辅助栈以及最终的返回值string类型的res初始化为空；\n- 2、'['之前的数字可能不止一位，所以要设置一个sum表示其之前数字的总和。\n- 3、字符串题有大小写的区别，所以要注意大小写\n- 4、看代码注释举例。\n\n### 代码块\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> pos;\n        stack<int> nums;\n        string res = \"\";\n        int sum = 0;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n                sum = sum * 10 + s[i] - '0';\n            else if((s[i] >= 'a' && s[i] <= 'z')||(s[i] >= 'A' && s[i] <= 'Z'))\n                res += s[i]; //注意大小写，之前第一次提交发现大小写也存在区分\n            else if(s[i] == '[')\n            {\n                nums.push(sum);\n                sum = 0;    //重置 0\n                pos.push(res);\n                res = \"\";   //重置为空字符串\n            } \n            else if(s[i] == ']') \t\t//此处举例3[a2[c]];\n            {\t\t\t\t\t\t\t//出现[后将3放入nums中，sum重置，res仍为\"\"\n                sum = nums.top();\t\t//而后再出现[，此时sum=2;res=\"a\",存入pos\n                nums.pop();\t\t\t\t//第一次出现], 此时sum = nums.top() == 2\n                while(sum)\t\t\t\t//pos.top = a, res = 'c',输出为res = \"acc\"\n                {\t\t\t\t\t\t//第二次出现],sum = nums.top() == 3;\n                    pos.top() += res; \t//pos.top = \"\" 第一次存入的res, res =\"acc\",\n                    sum--;\t\t\t\t//画图更好理解，sum经历变化后的值最终始终为0\n                }\n                res = pos.top();\n                pos.pop();\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 复杂度\n\n- 时间复杂度：一次遍历O(s.size), 其中的while循环应该是常数级;\n\n- 空间复杂度：O(s.size);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918914843","body":"# Day-4 ：2021-09-14\r\n\r\n# **[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)**\r\n\r\n### 题目\r\n\r\n```cpp\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n \r\n\r\n说明：\r\n\r\n你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n \r\n进阶：\r\n\r\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n \r\n\r\n提示：\r\n\r\n1 <= x <= 9\r\n最多调用 100 次 push、pop、peek 和 empty\r\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\r\n```\r\n\r\n## 题目思路\r\n\r\n- 1、如题所给，创建两个栈，其中s1为入栈，s2为出栈\r\n- 2、由于栈是动态实现的，不存在上溢问题，所以入栈只需要将x保存至s1中即可\r\n- 3、在pop()、与peek()函数中，是相同的逻辑，只是一个需要删除，一个不需要删除\r\n\r\n### 代码块\r\n\r\n```c++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> s1, s2;\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {}\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        s1.push(x);  \r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() \r\n    {\r\n        if(s2.size() == 0 && s1.size() == 0) return false;\r\n        else if(s2.size() != 0) \r\n        {\r\n            int temp = s2.top();\r\n            s2.pop();\r\n            return temp;\r\n        }\r\n        else\r\n        {\r\n            while(s1.size() != 0)\r\n            {\r\n                s2.push(s1.top());\r\n                s1.pop(); \r\n            }\r\n            int temp = s2.top();\r\n            s2.pop();\r\n            return temp;\r\n        }\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(s2.size() == 0 && s1.size() == 0) return false;\r\n        else if(s2.size() != 0) return s2.top();\r\n        else\r\n        {\r\n            while(s1.size() != 0)\r\n            {\r\n                s2.push(s1.top());\r\n                s1.pop(); \r\n            }\r\n        } \r\n        return s2.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s1.empty() && s2.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(1)，除了调用pop()与peek()初次需要较长的时间之外，其余都只需要O(1)的复杂度。P(击败100%应该是O(1)吧)\r\n\r\n- 空间复杂度：O(n)，两个栈一共存放输入n个数据规模，故应为O(n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919806072","body":"# Day-6 ：2021-09-15\n\n# **[768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)**\n\n### 题目\n\n```cpp\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10^8。\n\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n示例 1:\n\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n示例 2:\n\n输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n注意:\n\narr的长度在[1, 2000]之间。\narr[i]的大小在[0, 10**8]之间。\n```\n\n## 题目思路\n\n- 1、分块排序，组合之后与原数组进行升序排序要相同\n- 2、所以可以采用动态规划的思想，前一个块的最大值要小于下一个块的最小值，这样分块排序合并之后也会与原数组升序排序一致。\n- 3、\n\n### 代码块\n\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        /* 虽然能通过但是时间复杂度太高，两者比较与清空操作要花费较多的时间开销\n           解法并不优秀。\n        int n = arr.size();\n        vector<int> nums(arr);\n        sort(nums.begin(), nums.end());\n        unordered_map<int, int> h1, h2;\n        int ans = 0;\n        for (int i = 0; i < n; i++)\n        {\n            ++h1[arr[i]];\n            ++h2[nums[i]];\n            if(h1 == h2)\n            {\n                ans++;\n                h1.clear();\n                h2.clear();\n            }\n        }\n        return ans;*/\n        //此解法就极大缩短了时间，只需要寻找左边最大值小于右边最小值的区域即可\n        int n = arr.size();\n        vector<int> l(n, 0);\n        vector<int> r(n, 10^8);\n        l[0] = arr[0];\n        r[n - 1] = arr[n - 1];\n        for(int i = 1; i < n; i++) \n        {\n            //动态规划\n            l[i] = max(l[i - 1], arr[i]);\n            r[n - 1 - i] = min(r[n - i], arr[n - 1 - i]);\n        }\n        int res = 1;\n        for(int i = 0; i < n - 1; i++)\n        {\n            int ans = l[i] <= r[i + 1] ? 1 : 0;\n            res += ans;\n        }\n        return res;\n    } \n};\n```\n\n## 复杂度\n\n- 时间复杂度：O(n)\n\n- 空间复杂度：O(2n)，两个数组开辟2n的空间;","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920585022","body":"# Day-7 ：2021-09-16\n\n# **[61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)**\n\n### 题目\n\n```cpp\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n\n示例 1：\n    \n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n    \n示例 2:\n\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n \n提示：\n\n链表中节点的数目在范围 [0, 500] 内\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n```\n\n## 题目思路\n\n- 1、链表右移操作，实际可能为将最后k个插入头部\n\n### 代码块\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(k == 0 || head == NULL || head -> next == nullptr) return head;\n        int len = 1;\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast -> next != nullptr)\n        {\n            fast = fast -> next;\n            ++len;\n        }\n        fast -> next = head;\n        k = len - 1 - k % len; //此处注意移动k步后的末尾节点,鄙人在此卡了接近半小时\n        if(k == len) return head;//最后想明白了 k % len还要走多少步数的\n        while(k)\n        {\n            slow = slow -> next;\n            k--;\n        }\n        fast = slow -> next;\n        slow -> next = nullptr; \n        return fast;\n    }\n};\n```\n\n## 复杂度\n\n- 时间复杂度：O(n),遍历两次链表\n\n- 空间复杂度：O(1)，常数级","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921588156","body":"# Day-8 ：2021-09-17\n\n# **[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)**\n\n### 题目\n\n```cpp\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n示例 1：\n\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n    \n示例 2：\n\n输入：head = []\n输出：[]\n    \n示例 3：\n\n输入：head = [1]\n输出：[1]\n \n提示：\n\n链表中节点的数目在范围 [0, 100] 内\n0 <= Node.val <= 100\n \n\n进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\n```\n\n## 题目思路\n\n- 1、最简单的思路自然是递归的思路\n- 2、而递归调用的也是栈的实现方法，所以自然也能想到栈的相应的做法。\n\n### 代码块\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        /* if (head == nullptr || head->next == nullptr) return head;\n        ListNode* p = head -> next;\n        head -> next = swapPairs(p -> next);\n        p -> next = head;\n        return p; */\n\t\tif(head == nullptr || head -> next == nullptr) return head;\n\t\tstack<ListNode* > stk;\n\t\tListNode* p = new ListNode();\n\t\tListNode* pos = head;\n        head = p;\n\t\twhile(pos != nullptr && pos -> next != nullptr) \n        {\n\t\t\tstk.push(pos);\n\t\t\tstk.push(pos -> next);\n\t\t\tpos = pos -> next -> next;\n\t\t\tp -> next = stk.top();\n            stk.pop();\n\t\t\tp = p -> next;\n\t\t\tp -> next = stk.top();\n            stk.pop();\n\t\t\tp = p -> next;\n\t\t}\n\t\tif(pos != nullptr) p -> next = pos;\n\t    else p -> next = nullptr; \n\t\treturn head -> next;\n    }\n};\n```\n\n## 复杂度\n\n- 时间复杂度：O(n) \n\n- 空间复杂度：O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922239904","body":"# Day-9 ：2021-09-18\n\n# **[109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)**\n\n### 题目\n\n```cpp\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n示例:\n\n给定的有序链表： [-10, -3, 0, 5, 9],\n\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n```\n\n## 题目思路\n\n- 1、本题相当于将链表转化为一个二叉搜索树(Binary Search Tree : BST)\n- 2、基于中序遍历恢复二叉搜索树，即可从任意节点出发，以节点左边的升序序列作为左子树，右边升序序列为右子树，即可得到二叉搜索树，本题要建立一个高度平衡的二叉搜索树，那么左右高度差至多为1，故从链表的中点开始建立二叉搜索树最好。\n- 3、本题也可以用BFS建树，DFS填节点值，但这样空间复杂度较高，时间复杂度跟递归链表差不多的情况下，确实不是特别优秀的解法，不过也可以用来熟悉一下DFS与BFS。\n\n### 代码块。\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head == nullptr) return nullptr;\n        if(head -> next == nullptr)\n        {\n            TreeNode* root = new TreeNode(head -> val);\n            return root;\n        }\n        ListNode* fast = head;\n        int len = 1;\n        while(fast -> next != nullptr)\n        {\n            fast = fast -> next;\n            len++;\n        }\n        len = len >> 1;\n        ListNode* slow = head;\n        ListNode* p = slow;\n        while(len--)\n        {   \n            p = slow;\n            slow = slow -> next;\n        }\n        p -> next = nullptr;\n        TreeNode* root = new TreeNode(slow -> val);\n        root -> left = sortedListToBST(head);\n        root -> right = sortedListToBST(slow -> next);\n        return root;\n    }\n};\n```\n\n## 复杂度\n\n- 时间复杂度：O(n) \n\n- 空间复杂度：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922439860","body":"# Day-10 ：2021-09-19\r\n\r\n# **[160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)**\r\n\r\n### 题目\r\n\r\n```cpp\r\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\r\n\r\n图示两个链表在节点 c1 开始相交：\r\n\r\n题目数据 保证 整个链式结构中不存在环。\r\n\r\n注意，函数返回结果后，链表必须 保持其原始结构 。\r\n\r\n示例 1：\r\n\r\n\r\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\r\n输出：Intersected at '8'\r\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\r\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\r\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\r\n示例 2：\r\n\r\n\r\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\r\n输出：Intersected at '2'\r\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\r\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\r\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\r\n示例 3：\r\n\r\n\r\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\r\n输出：null\r\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\r\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\r\n这两个链表不相交，因此返回 null 。\r\n \r\n\r\n提示：\r\n\r\nlistA 中节点数目为 m\r\nlistB 中节点数目为 n\r\n0 <= m, n <= 3 * 104\r\n1 <= Node.val <= 105\r\n0 <= skipA <= m\r\n0 <= skipB <= n\r\n如果 listA 和 listB 没有交点，intersectVal 为 0\r\n如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]\r\n \r\n\r\n进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\r\n```\r\n\r\n## 题目思路\r\n\r\n- 1、经典双指针问题，如果A、B中有一个为空，则无交点。\r\n- 2、如果相交则不用证明其正确信，不相交则相互遍历到最终的结果都为nullptr，经过 m + n次。\r\n- 3、哈希表好理解一些，当计数count函数出现q时候，即可返回相交节点值，否则返回nullptr\r\n\r\n### 代码块。\r\n\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        /* if(headA == nullptr || headB == nullptr) return nullptr;\r\n        ListNode* p = headA;\r\n        ListNode* q = headB;\r\n        while(p != q)\r\n        {\r\n            p = p == nullptr ? headB : p -> next; \r\n            q = q == nullptr ? headA : q -> next;\r\n        }\r\n        return p; */\r\n        if(headA == nullptr || headB == nullptr) return nullptr;\r\n        unordered_set<ListNode* > vis;\r\n        ListNode* p = headA;\r\n        ListNode* q = headB;\r\n        while(p != nullptr)\r\n        {\r\n            vis.insert(p);\r\n            p = p -> next;\r\n        }\r\n\r\n        while(q != nullptr)\r\n        {\r\n            if(vis.count(q)) return q;\r\n            q = q -> next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(m+n)、哈希表也是O(m+n);\r\n\r\n- 空间复杂度：O(1)、哈希表为O(n + m); ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sqshada":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916979869","body":"### 思路\n逐位相加\n\n### 代码\n```js\n/**\n * @param {number[]} A\n * @param {number} K\n * @return {number[]}\n */\nvar addToArrayForm = function (A, K) {\n    const res = []\n    const len = A.length\n    for (let i = len - 1; i >= 0; i--) {\n        let sum = A[i] + K % 10\n        K = Math.floor(K / 10)\n        if (sum >= 10) {\n            K++\n            sum -= 10\n        }\n        res.push(sum)\n    }\n    for (; K > 0; K = Math.floor(K / 10)) {\n        res.push(K % 10)\n    }\n    res.reverse()\n    return res\n};\n```\n\n### 复杂度分析\n时间复杂度 O(N)，N 为数组的长度。     \n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917420833","body":"### 思路\n左右依次遍历\n\n### 代码\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  const res = [];\n  let prev = -10001;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      prev === i;\n    }\n    res[i] = i - prev;\n  }\n  prev = 10001;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) {\n      prev === i;\n    }\n    res[i] = Math.min(res[i], prev - i);\n  }\n  return res;\n};\n```\n\n\n### 复杂度分析\n时间复杂度 O(N)，N 为数组的长度。\n空间复杂度 O(N)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918316288","body":"### 思路\n外层的解码需要等待内层解码的结果。\n\n### 代码\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  let numStack = []\n  let strStack = []\n  let num = 0\n  let result = ''\n  for (const char of s) {\n    if (!isNaN(char)) {\n      num = num * 10 + Number(char)\n    } else if (char === '[') {\n      strStack.push(result)\n      result = ''\n      numStack.push(num)\n      num = 0\n    } else if (char === ']') {\n      let repeatTime = numStack.pop()\n      result = strStack.pop() + result.repeat(repeatTime)\n    } else {\n      result += char\n    }\n  }\n  return result\n};\n```\n\n### 复杂度分析\n时间复杂度 O(N)，N 是解析后字符串的长度\n空间复杂度 O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920932345","body":"### 思路\n双指针 找到要切断的位置，将后面的部分连接到前面来\n\n### 代码\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n  if (!head) return null\n  let length = 1,\n    last = head,\n    first = head\n  while (first.next) {\n    length += 1\n    first = first.next\n  }\n  k = k % length\n\n  if (k === 0) return head\n\n  for (let i = 1; i < length - k; i++) {\n    last = last.next\n  }\n  first.next = head\n  head = last.next\n  last.next = null\n\n  return head\n};\n```\n\n### 复杂度分析\n时间复杂度 O(N)        \n空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CoreJa":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916980151","body":"# 思路\n思路1：把num数组合并为数字，两个数字相加再转换成数组\n思路2：把k转换成数组，两个数组相加，但要额外处理一下进位的过程\n思路1里的部分可以用python的map映射偷懒完成，先把数组用join+map转成str，再换成int，还原同理\n\n# 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        return list(map(int,str(int(\"\".join(map(str,num)))+k)))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917365668","body":"# 思路\r\n遍历数组的每个字母，向左和向右分别找到离该字母最近的C，取最小值即可。\r\n这个思路相对比较暴力法，最坏的情况下时间复杂度为O(N^2)\r\n\r\n另一个思路有贪心和DP的思想，即使用数组来保存状态。因为题目要求找每个字母离最近的C的距离，显然每个字母都可以向左延伸和向右延伸。从左遍历数组即可得到每个字符距离左边最近的C的距离。(假设上一个C的坐标为`pos_l`，则当前字母的距离为`i-pos_l`)，从右遍历同理。\r\n\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar1(self, S: str, C: str) -> List[int]:\r\n        res = []\r\n        for i in range(len(S)):\r\n            right = S[i:].find(C)\r\n            left = S[:i + 1].rfind(C)\r\n            if left == -1:\r\n                left = float('inf')\r\n            else:\r\n                left = len(S[:i + 1]) - 1 - left\r\n            if right == -1:\r\n                right = float('inf')\r\n\r\n            res.append(min(left, right))\r\n        return res\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        res = []\r\n        l = len(S)\r\n        left = [float('inf')] * l\r\n        right = [float('inf')] * l\r\n        pos_l = -float('inf')\r\n        pos_r = float('inf')\r\n        for i in range(l):\r\n            j = l - 1 - i\r\n            if S[i] == C:\r\n                pos_l = i\r\n            left[i] = i - pos_l\r\n            if S[j] == C:\r\n                pos_r = j\r\n            right[j] = pos_r - j\r\n        for i in range(l):\r\n            res.append(min(left[i], right[i]))\r\n        return res\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917585831","body":"# 思路\n这个题本以为是个简单的栈的实现，看了别人的题解才发现increment里大有玄机\n关键点在于把实时的increment变成lazy load，只在元素pop的时候才真正的加上，这样就实现了O(1)的时间复杂度\n\n具体需要多一个数组来记录每次的increment操作，定义为：列表的下标对应increment操作里的参数k，值为val，其表示需要对0-k个元素进行+val的操作。在每次pop的时候，根据下标找到add数组中该元素需要+val，同时将该值传递给add数组中的前一个元素。这里一定要注意边界情况，谨防越界。\n\n# 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.top = 0\n        self.stack = [0] * maxSize\n        self.add = [0] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.top >= len(self.stack):\n            return\n        self.stack[self.top] = x\n        self.top += 1\n        return\n\n    def pop(self) -> int:\n        if self.top > 0:\n            self.top -= 1\n            self.stack[self.top] += self.add[self.top]\n            if self.top > 0:\n                self.add[self.top - 1] += self.add[self.top]\n            self.add[self.top] = 0\n            return self.stack[self.top]\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        k = min(k, self.top)\n        if k > 0:\n            self.add[k - 1] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918334455","body":"# 思路\n题目和大学学过的利用栈实现计算器比较相似(括号匹配的部分相似)，基本思路就是，如果读到数字了，保留(注意数字可能是多位)，如果读到左括号了，把前面保留的数字记录，并且标记一下(往栈里压一个#)，如果读到字母，那就继续压栈，如果读到反括号，那就一口气出栈到标记位(#)，并且在输出结果里写相应的结果。\n\n# 代码\n```python\nclass Solution:\n\n    def decodeString(self, s: str) -> str:\n        stack = collections.deque()\n        res = []\n        tmp_stack = []\n        for c in s:\n            if 48 <= ord(c) <= 57:\n                tmp_stack.append(c)\n            elif c == '[':\n                stack.append(''.join(tmp_stack))\n                tmp_stack = []\n                res.append('#')\n            elif c == ']':\n                tmp = collections.deque()\n                while res[-1] != '#':\n                    tmp.appendleft(res.pop())\n                res.pop()\n                res.append(''.join(tmp) * int(stack.pop()))\n            else:\n                res.append(c)\n        return \"\".join(res)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919219420","body":"# 思路\n一开始其实思路不明确，后来发现倒一次后顺序就正确了。\n那么就将一个栈定义为输入栈，一个栈定义为输出栈。\npush就往输入栈里压数据，pop的话就从输出栈里拿数据。如果输出栈里没有数据了，那就将输入栈的所有数据全部倒腾到输出栈里。\n\n这就好像是两个栈把底部黏在了一起，一个吃输入，一个吐输出，这就形成了一个队列。唯一要解决问题是两个栈之间的交流，即输入栈如何把数据挪到输出栈来。那要挪的时候没办法，只能一个一个搬，但是因为pop的总次数和搬运的总次数相当，所以\"均摊时间复杂度\"为 O(1)。\n这里解释一下，假设一共要pop n次，那么我一共也只需要挪n次数据(pop+push)，故均摊下来执行O(2n/n)得到O(1)的时间复杂度\n\n# 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.in_stack = []\n        self.out_stack = []\n\n    def in2out(self) -> None:\n        while len(self.in_stack) != 0:\n            self.out_stack.append(self.in_stack.pop())\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.in_stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if len(self.out_stack) == 0:\n            self.in2out()\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if len(self.out_stack) == 0:\n            self.in2out()\n        return self.out_stack[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if len(self.in_stack) == 0 and len(self.out_stack) == 0:\n            return True\n        else:\n            return False\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920605768","body":"# 思路\n题目思路非常清晰，本质上数到第`n-k%n`个节点，把该节点的后部分链表挪到链表的头部去。\n\n为了方便coding，不妨把链表的收尾相连，在找到指定节点后再将其从该出断开。\n\n复杂度分析：\n\n空间：O(1)\n\n时间：O(N+k%n)=O(N)\n\n# 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head is None:\n            return head\n        p = head\n        cnt = 1\n        while p.next is not None:\n            cnt += 1\n            p = p.next\n        p.next = head\n        k = cnt - k % cnt\n        while k != 0:\n            p = p.next\n            k -= 1\n        head = p.next\n        p.next = None\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921092077","body":"# 思路\n## 思路1\n思路最清晰最bug free的方法是加一个头节点，这样对于任意两个需要交换的节点，均存在其前一节点，这样就不需要考虑各种边界情况。标记需要交换的两个节点为`first`和`second`，first的前一个节点为p，second的后一个节点为next_node。循环条件为p->next和p->next->next都存在即可。\n1. first->next=next_node\n2. second->next=first\n3. p->next=second\n4. p=second\n\n## 思路2\n如果不想加头节点，那就麻烦一些，等于是处理p指向first节点，然后second节点的指向需要额外判断一下。\n\n## 时间复杂度分析\n两个思路的时间复杂度都是O(n)，但是思路1不管是人脑的思考和代码的简洁程度以及代码的运行速度都会快一些（少判断了很多情况）\n# 代码\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        my_head=ListNode(0,head)\n        p=my_head\n        while p.next and p.next.next:\n            first=p.next\n            second=first.next\n            next_node=second.next\n            second.next=first\n            first.next=next_node\n            p.next=second\n            p=first\n        return my_head.next\n\n\n    def swapPairs1(self, head: ListNode) -> ListNode:\n        if head is None:\n            return head\n        p=head\n        if head.next:\n            head=head.next\n        while p.next and p.next.next:\n            q=p.next.next\n            p.next.next=p\n            p.next=q.next if q.next else q\n            p=q\n        if p.next is None:\n            return head\n        else:\n            p.next.next=p\n            p.next=None\n        return head\n\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"daidaidashixiong666":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916980667","body":"``` java\nclass Solution {\npublic List addToArrayForm(int[] num, int k) {\nboolean addOne=false;//进位\nLinkedList list = new LinkedList<>();\nfor(int i=num.length-1;i>=0;i--){\nif(addOne){\nif(k%10+num[i]+1>=10){\naddOne=true;\n}else {\naddOne=false;\n}\nlist.add((k%10+num[i]+1)%10);\n}else {\nif(k%10+num[i]>=10){\naddOne=true;\n}else {\naddOne=false;\n}\nlist.add((k%10+num[i])%10);\n}\nk/=10;\n}\nif(addOne&&k==0){\nlist.add(1);\naddOne=false;\n}else if(k!=0){\nwhile (k!=0){\nif(addOne){\nlist.add((k%10+1)%10);\nif((k%10+1)>=10){\naddOne=true;\n}else {\naddOne= false;\n}\n}else {\nlist.add(k%10);\n}\nk/=10;\n}\n}\nif(addOne)\nlist.add(1);\nCollections.reverse(list);\nreturn list;\n}\n}\n复杂度分析\n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917613866","body":"```java\nclass CustomStack {\n            int[] num;\n            int length=0;\n            public CustomStack(int maxSize) {\n                    num=new int[maxSize];\n            }\n\n            public void push(int x) {\n                if(length<num.length){\n                    num[length]=x;\n                    length++;\n                }\n            }\n\n            public int pop() {\n                if(length-1==-1)\n                    return -1;\n                length--;\n                return num[length];\n            }\n\n            public void increment(int k, int val) {\n                    if(k>=length+1){\n                        for(int i=0;i<length;i++){\n                            num[i]+=val;\n                        }\n                    }else{\n                            for (int i=0;i<k;i++){\n                                num[i]+=val;\n                            }\n                        }\n                    }\n            }\n\n**复杂度分析**\n- 时间复杂度 push pop 为O(1),increment为O(n)\n- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922479191","body":"```java\npublic class Solution {\n            public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n                if(headB==null||headA==null)\n                return null;\n                ListNode a=headA;\n                ListNode b=headB;\n                while (a!=b){\n                    if(a==null){\n                        a=headB;\n                    }else a=a.next;\n                    if(b==null){\n                        b=headA;\n                    }else b=b.next;\n                }\n                return a;\n        }\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Maschinist-LZY":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916981887","body":"思路：\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n语言：C\r\n\r\n\r\n\r\nint* addToArrayForm(int* A, int ASize, int K, int* returnSize){\r\n    int sum, len_K, len;\r\n    int * res;\r\n    if(K == 0)\r\n    {\r\n        *returnSize = ASize;\r\n        return A;\r\n    }\r\n    len_K = log10(K) + 1;\r\n    *returnSize = (ASize > len_K) ? ASize + 1: len_K + 1;\r\n    res = (int *) malloc(*returnSize * sizeof(int));\r\n    len = *returnSize;\r\n    while(len - 1 >= 1 || K > 0)\r\n    {\r\n       if(ASize > 0) K += A[--ASize];\r\n       res[--len] = K % 10;\r\n       K /= 10;\r\n    }\r\n    *returnSize -= len;\r\n    return res + len;\r\n} \r\n\r\n复杂度分析：\r\n时间：O(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917709052","body":"# 思路\r\n正序和逆序两次遍历\r\n# 代码(C语言)\r\n```c\r\nint* shortestToChar(char * s, char c, int* returnSize){\r\n    int s_len = strlen(s);\r\n    int *res = (int*)malloc(sizeof(int)*s_len);\r\n    int pos = -s_len;\r\n    for(int i=0;i<s_len;i++){\r\n        if(s[i]==c)pos = i;\r\n        res[i] = i-pos;\r\n    }\r\n    for(int i=pos-1;i>=0;i--){\r\n        if(s[i]==c)pos = i;\r\n        if(res[i]>pos-i)\r\n        res[i] = pos-i;\r\n    }\r\n    *returnSize = s_len;\r\n    return res;\r\n}\r\n```\r\n# 复杂度分析\r\n时间：O(n)\r\n空间：O(1)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917712038","body":"# 思路\n先全部压入栈\n然后识别到数字，遍历直达不是数字为止\n对数字后的【】进行解码\n# 代码(Python)\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack1=list()\n        length=len(s)\n        i=length-1\n        while i>=0:\n            if s[i].isdigit()==False:\n                stack1.append(s[i])\n                i-=1\n            else:\n                num=''\n                while i>=0 and s[i].isdigit():\n                    num=s[i]+num\n                    i-=1\n                sub=''\n                while stack1[-1]!=']':\n                    tmp=stack1.pop()\n                    if tmp!='[':\n                        sub+=tmp\n                stack1.pop()\n                sub=int(num)*sub\n                stack1.append(sub)\n\n        stack1.reverse()\n        return ''.join(stack1)\n```\n# 复杂度分析\n时间：O(n)  \n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918588940","body":"## 思路\n参考了官方题解的双栈思路，一个入栈，一个出栈\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass MyQueue {\nprivate:\n    stack<int> S_a,S_b;\n\n    void move(){\n        while(!S_a.empty()){\n            S_b.push(S_a.top());\n            S_a.pop();\n        }\n    }\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        S_a.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if(S_b.empty())\n        {\n            move();\n        }\n        int x = S_b.top();\n        S_b.pop();\n        return x;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if(S_b.empty())\n        {\n            move();\n        }\n        return S_b.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return S_b.empty() && S_a.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919395393","body":"## 思路\n 用栈辅助寻找局部最大值\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> newS;\n        newS.push(arr[0]);\n        int max=arr[0];\n        int x = 1;\n        while(x<arr.size()){\n            if(arr[x]>=max)\n            {\n                newS.push(arr[x]);\n                max = arr[x];\n            }\n            else{\n\n            while(!newS.empty() && arr[x]<newS.top()){\n                newS.pop();\n            }\n            newS.push(max);\n            }\n         x++;   \n        }\n        return newS.size();\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921009795","body":"## 思路\n1.统计节点个数，链表成环\n2.计算移动的次数，找到新的头节点的位置；\n3.断开环\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(k==0 || head==nullptr || head->next == nullptr){\n            return head;\n        }\n        int n = 1;\n        ListNode *p = head;\n        while(p->next != nullptr){\n            p = p->next;\n            n++;\n        }\n        int change = n - k%n;\n        if(change == n){\n            return head;\n        } \n        p->next = head;\n        while(change--){\n            p = p->next;\n        }\n        head = p->next;\n        p->next = nullptr;\n        return head;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921878342","body":"## 思路\n模拟交换\n## 代码\nC++  \n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode*  dummy = new ListNode(-1);  //虚拟头节点\n        dummy->next = head;\n        for(auto p = dummy; p->next && p->next->next; )\n        {\n            auto a = p->next, b = a->next;\n            p->next = b;\n            a->next = b->next;\n            b->next = a;\n            p = a;\n        }\n        return dummy->next;\n    }\n};\n```\n## 复杂度分析\n时间 O(n)  \n空间 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingkong1994":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916981984","body":"#数组形式的整数加法\n## 考察点\n1、数组为空时的处理情况。  \n2、数值求和进位的问题，需要注意一些特殊情况。  \n3、数组的长度跟数值k的位数长短的比较。  \n<1> 若数组长度更长，则在按位求和完k后，需要进一步考虑进位的问题。 这里需要特别注意在数组索引为0的求和进位问题。  \n<2> 若数值k的位数更长，则根据索引依次求和完num后，也同样需要考虑进位的问题。注意k的最高位进位问题。\n##代码\n```python\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int size = num.size();\n        if (num.empty()) {\n            while(k) {\n                int val = k % 10;\n                num.push_back(val);\n                k /= 10;\n            }\n            reverse(num.begin(), num.end());\n            return num;\n        }\n        int carry = 0;\n        while (size && k) {\n            int sum = num[size - 1] + (k % 10) + carry;\n            if (sum > 9) {\n                sum -= 10;\n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            num[size - 1] = sum;\n            size --;\n            k /= 10;\n        }\n        while(size && carry) { \n            int sum = num[size - 1] + carry;\n            if (sum > 9) {\n                sum -= 10;                   \n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            num[size - 1] = sum;\n            size --; \n        }\n        while (k) {\n            int val = k % 10 + carry;\n            if (val > 9) {\n                val -= 10;\n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            num.insert(num.begin(), val);\n            k /= 10;\n        }\n        if (carry) { num.insert(num.begin(), carry); }\n        return num; \n    }\n};\n```\n##复杂度\n时间复杂度： O（n）  \n空间复杂度： O（1）  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917388008","body":"## 字符的最短距离  \n### 思路\n思路一：  \n1、 先把字符串中等于字符的对应索引用vector存储起来。\n2、遍历整个字符串，当发现不等于该字符时，则去vector中计算最短距离。  \n思路二：\n1、先从左到右扫描一遍，然后从右到左再扫描一遍。   \n### 代码  \n```python\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> idx_vec;\n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] == c)  idx_vec.push_back(i);\n        }\n        if (idx_vec.empty())  return vector<int>{};\n        vector<int> res;\n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] == c)  {\n                res.push_back(0);\n                continue;\n            }\n            int MIN = s.length();\n            for (int j = 0; j < idx_vec.size(); j++) {\n                MIN = min(MIN, abs(idx_vec[j] - i));\n            }\n            res.push_back(MIN);\n        }\n        return res;\n    }\n};\n```\n### 复杂度  \n时间复杂度： O(n*k)，n表示字符串的长度， k表示字符c的个数。  \n空间复杂度：O(n)。  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917598412","body":"## 思路\n1、采用数组的方式进行查询存储，这样的话可以直接通过索引直接进行检索。\n## 代码  \nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        max_size = maxSize;\n    }\n    \n    void push(int x) {\n        if (vals.size() < max_size) {\n            vals.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if (vals.empty())  return -1;\n        int val = vals.back();\n        vals.pop_back();\n        return val;\n    }\n    \n    void increment(int k, int val) {\n        if (vals.empty())  return;\n        k = k > vals.size()? vals.size(): k;\n        for (int i = 0; i < k; i++) {\n            vals[i] += val;\n        }\n    }\n    vector<int> vals;\n    int max_size;\n};\n## 复杂度\n时间复杂度：pop 和 push操作都是O(1)， increment操作是 O(k) 。\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918282561","body":"## 思路\n目前写出的方法有点耗时，明天优化下，\n1、采用递归的方式，每次只解码一个【】内的内容。\n## 代码\n```python\nclass Solution {\npublic:\n    string decodeString(string s) {\n        if (s.empty())  return s;\n        int idx_left_new = -1;\n        int idx_left_old = -1;\n        int idx_right = -1;\n        string num;\n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] == '[')  {\n                idx_left_old = idx_left_new;\n                idx_left_new = i;\n            }\n            if (s[i] == ']') {\n                idx_right = i;\n                break;\n            }\n        }\n        int start;\n        if (idx_left_old == -1) {\n            for (int i = 0; i < idx_left_new; i++) {\n                if (s[i] >= '0' && s[i] <= '9') {\n                    start = i; break;\n                }\n            }\n        } else {\n            for (int i = idx_left_old + 1; i < idx_left_new; i++) {\n                if (s[i] >= '0' && s[i] <= '9') {\n                    start = i; break;\n                }\n            }\n        }\n        num = s.substr(start, idx_right - start);\n        if (idx_left_new <= 0 || idx_right == -1)  return s;\n        if (idx_right - idx_left_new == 1)  return s;\n        string tmp;\n        for (int i = 0; i < atoi(num.c_str()); i++) {\n            tmp += s.substr(idx_left_new + 1, idx_right - idx_left_new - 1);\n        }\n        string tmp_s;\n        if (idx_right != s.length() - 1) {\n            tmp_s = start == 0? tmp + s.substr(idx_right + 1) : \n                s.substr(0, start) + tmp + s.substr(idx_right + 1);\n        } else {\n            tmp_s = start == 0? tmp: s.substr(0, start) + tmp;\n\n        }\n        return decodeString(tmp_s);\n    }\n};\n```\n## 复杂度\n时间复杂度：O(n*k)，n表示字符串的长度， k表示'['的个数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919213436","body":"## 思路\n使用双栈。\n## 代码\n```python\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        s1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if (s1.empty() && s2.empty())  return -1;\n        if (s2.empty()) {\n            while (!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int val = s2.top();\n        s2.pop();\n        return val;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if (s1.empty() && s2.empty())  return -1;\n        if (s2.empty()) {\n            while (!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        return s2.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n    stack<int> s1;\n    stack<int> s2;\n};\n``` \n## 复杂度\n时间复杂度：push O(1) ,  pop和peek最好情况是O(1)，最坏情况时O(n)。\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920049831","body":"## 思路\n创建一个连续数组A，用来存放所有已经排序好的元素。\n然后遍历A和原数组arr，求和。 如果真的在便利过程中，求和相等，则说明此刻可以分块了。\n## 代码\n```python\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> res = arr;\n        sort(res.begin(), res.end());\n        long sum1 = 0;\n        long sum2 = 0;\n        int count = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            sum1 += res[i];\n            sum2 += arr[i];\n            if (sum1 == sum2) {\n                count ++;\n            }\n        }\n        return count;\n    }\n};\n```\n## 复杂度\n时间复杂度： O（nlogn）\n空间复杂度： O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920941631","body":"## 思路\n1、确定到底要旋转几个节点\n2、找到最新的头节点\n3、将新的头节点的前节点的next指向NULL， 将链表中最后一个节点的next指向旧头节点。\n## 代码\n```python\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head || k == 0)  return head;\n        ListNode* node = head;\n        int count = 1;\n        while (node->next) {\n            node = node->next;\n            count++;\n        }\n        k = k % count;\n        if (k == 0)  return head;\n        node->next = head;\n\n        node = head;\n        ListNode* pre = NULL;\n        int idx = count - k;\n        count = 0;\n        while (count < idx) {\n            pre = node;\n            node = node->next;\n            count++;\n        }\n        pre->next = NULL;\n\n        ListNode* new_head = node;\n        \n        return new_head;\n\n    }\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921798740","body":"## 思路\n采用递归的方法进行俩俩交换\n## 代码\n```python\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (!head)  return head;\n        ListNode* node = head;\n        for (int i = 0; i < 2; i++) {\n            if (!node)  return head;\n            node = node->next;\n        }\n        ListNode* res = Reverse(head, node);\n        head->next = swapPairs(node);\n        return res;\n    }\n    ListNode* Reverse(ListNode* left, ListNode* right) {\n        ListNode* pre = NULL;\n        ListNode* p = left;\n        ListNode* q = NULL;\n        while (p != right) {\n            q = p->next;\n            p->next = pre;\n            pre = p;\n            p = q;\n        }\n        return pre;\n    }\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922275078","body":"## 思路\n1、先创建一个数组，遍历链表每个节点，把值放入数组中。\n2、采用递归方法，每次取中间节点作为树的root。root的左边数组是左子树，右边是右子树。\n## 代码 \n```python\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (!head)  return NULL;\n        vector<int> vals;\n        ListNode* node = head;\n        while (node) {\n            vals.push_back(node->val);\n            node = node->next;\n        }\n        int count = vals.size();\n        return func(vals, 0, count - 1);\n    }\n    TreeNode* func(vector<int>& vals, int start, int end) {\n        if (start > end)  return NULL;\n        int mid = (start + end) / 2;\n        TreeNode* root = new TreeNode(vals[mid]);\n        root->left = func(vals, start, mid - 1);\n        root->right = func(vals, mid + 1, end);\n        return root;\n    }\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922471288","body":"## 思路\n两个链表依次遍历，若有相交，则在遍历的过程中会重合。\n## 代码\n```python\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (!headA || !headB)  return NULL;\n        ListNode* nodeA = headA;\n        ListNode* nodeB = headB;\n        int count_a = 0;\n        while (nodeA) {\n            nodeA = nodeA->next;\n            count_a++;\n        }\n        int count_b = 0;\n        while (nodeB) {\n            nodeB = nodeB->next;\n            count_b++;\n        }\n        int sum = count_a + count_b;\n\n        nodeA = headA;\n        nodeB = headB;\n        int i = 0;\n        while (i <= sum) {\n            if (nodeA == nodeB)  return nodeA;\n            nodeA = nodeA? nodeA->next : headB;\n            nodeB = nodeB? nodeB->next : headA;\n            i++;\n        }\n        return NULL;\n    }\n};\n```\n## 复杂度\n时间复杂度： O(n+m)  n和m表示两个链表的长度\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916982551","body":"### Intuition\nSince the input array is passed by reference, we are allowed to modify it in place.\n\nWe start from number k, and add the digits in the array from right to left following the standard addition rule, i.e., if the sum is greater than 10 we reset the current digit and add one to the next digit. \n\nThe modulo and division operations are used to calculate the remainder and update the carry values.\n    \n\n### Implementation\n```c++\nclass Solution\n{\n  public:\n    std::vector<int> addToArrayForm(std::vector<int>& num, int k)\n    {\n        int carry = k;\n        for (int i = num.size() - 1; i >= 0; i--) {\n            int tmp = carry + num[i];\n            carry = tmp / 10;\n            num[i] = tmp % 10;\n        }\n        // Insert to the front at most 3 times\n        while (carry > 0) {\n            num.insert(num.begin(), carry % 10);\n            carry /= 10;\n        }\n        return num;\n    }\n};\n```\n### Complexity\n- Time complexity: O(n)\n- Space complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917338764","body":"### Intuition\nThe observation is that the closest char 'c' for each char in the string is either its first left neigboring 'c' or right neigboring 'c'.\n\nWe can compute the distance on the fly when find the occurances of char 'c' in the string.\n\nIn the first pass going from left to right, whenever we find a char 'c', we record its index in the string, and update its following right neighors untils it hits the next occurance.\n\nIn the second pass going from right to left, whenever we find a char 'c', we record its index in the string, and update its following left neighors untils it hits the next occurance.\n\nNotice that the initial values of result vector is initialized to INT_MAX, but a value of str.length() is enough.\n    \n\n### Implementation\n```c++\nclass Solution\n{\n  public:\n    vector<int> shortestToChar(string s, char c)\n    {\n        // The shortest distance to c is eight from its left neighboring c or right neighboring c\n        int n = s.length();\n        vector<int> res(n, INT_MAX);\n\n        // Sweep from left to right\n        // When one c occurance is found, update its right neighors until the next occurance of c\n        int cIdx = -1;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) {\n                cIdx = i;\n            }\n            if (cIdx != -1) {\n                res[i] = i - cIdx;\n            }\n        }\n\n        // Sweep from right to left\n        // When one c occurance is found, update its left neighors until the next occurance of c\n        cIdx = n;\n        for (int i = n - 1; i >= 0; i--) {\n            if (s[i] == c) {\n                cIdx = i;\n            }\n            if (cIdx != n) {\n                res[i] = std::min(res[i], cIdx - i);\n            }\n        }\n\n        return res;\n    }\n};\n```\n### Complexity\n- Time complexity: O(n)\n- Space complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917543733","body":"### Intuition\nThe array based implementattion is fairly simple:\n\n- Upon contruction, an array of size maxSize is created, maybe a sanity check of positive value of maxSize is needed\n- An internal pointer topIdx is used for two purposes:\n\t- Pointing to the top element of in the stack\n\t- Indicate the actual size of the stack, ie., topIdx+1\n- Keep an eye on what the interviewer means about \"bottom\"\n\n### Implementation\n```c++\nclass CustomStack\n{\n\n  public:\n    CustomStack(int maxSize)\n        : maxSize_{ maxSize }\n        , topIdx_{ -1 }\n        , sbuf_(maxSize)\n    {}\n\n    void push(int x)\n    {\n        if (topIdx_ < maxSize_ - 1) {\n            sbuf_[++topIdx_] = x;\n        }\n    }\n\n    int pop()\n    {\n        if (topIdx_ < 0) {\n            return -1;\n        } else {\n            return sbuf_[topIdx_--];\n        }\n    }\n\n    void increment(int k, int val)\n    {\n        int end = std::min(topIdx_, k - 1);\n        for (int i = 0; i <= end; i++) {\n            sbuf_[i] += val;\n        }\n    }\n\n  private:\n    int topIdx_;\n    int maxSize_;\n    std::vector<int> sbuf_;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n### Complexity\n- Time complexity:\n\t- pop(...): O(1)\n\t- push(...): O(1)\n\t- increment(...): O(k)\n- Space complexity: O(n) for internal array storage","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917772426","body":"### Intuition\nPairing brackets in a string is often associated with stack ADT. We do nothing but pushing each char onto a stack until we encounter the right bracket ']'. When ']' is found, we need to pop elements on the stack until we find its first pairing bracket '['. Then some operations need to be done with the popped elements, in this case, we record the chars in between '[' and ']', and use the knowledge of numeric number right before '[' to repeat the recorded chars. After the operation is done, we can remove the pairing bracket '[' and the numeric number from the stack and push the after-processing chars back to the stack. After iterating through the original string, the stack will be left of pure chars without numeric numbers and brackets.\nThe final results is done backward iterating through the stack.\n\nThe key point in implementing it in c++ is that the stack is of type char not string, because char comparison is cheaper than the string comparison.\n\nOne caveat when we get the numeric number from the stack is that we need an additional stack to store the digits. This is because we store the number from high digit to low digit, for example, if we have 300[a], the stack is ['3', '0', '0', '[', 'a'], we need to have a helper stack to store the digits ['0', '0', '3']. An optimization can be done by observing that all integers are in the range [1, 300]. We can allocate a static array of size 3 and reset it to ['\\*', '\\*', '*'] before we compute the numeric number and fill the digits backwards into the array. \n\nThis is a more natural solution to me and sounds like DFS.\nThe two stacks approach consisting of numeric number stack and string stack is kind of hard to memorize for me.\n\n### Implementation\n```c++\nclass Solution\n{\npublic:\n  string decodeString(string s)\n  {\n    std::stack<char> resStack;\n    std::vector<char> digitVec(3, '*');\n    for (auto const& c : s) {\n      if (c != ']') {\n        resStack.push(c);\n      } else {\n        // Find the chars to be repeated in between '[' and ']'\n        std::vector<char> repeatStrVec;\n        while (resStack.top() != '[') {\n          repeatStrVec.push_back(resStack.top());\n          resStack.pop();\n        }\n        // Remove the '[' from the stack\n        resStack.pop();\n        // Find the repeat count, and remove the numbers from the stack\n        std::fill(digitVec.begin(), digitVec.end(), '*');\n        int idx = digitVec.size();\n        // static_cast is needed as isdigit has undefined behavior for char type\n        while (!resStack.empty() && std::isdigit(static_cast<unsigned char>(resStack.top()))) {\n          digitVec[--idx] = resStack.top();\n          resStack.pop();\n        }\n        int count{digitVec[idx] - '0'}; \n        for (int ii = idx+1; ii < digitVec.size(); ii++) {\n          count = 10 * count + digitVec[ii] - '0';\n        }\n        // Repeat the chars in betwen '[' and ']' count times and push them back to the stack\n        for (int ii = 0; ii < count; ii++) {\n          for (auto it = repeatStrVec.rbegin(); it != repeatStrVec.rend(); it++) {\n            resStack.push(*it);\n          }\n        }\n      }\n    }\n    // Pre-allocate the string so that we don't need string concatenation\n    std::string res(resStack.size(), '*');\n    int idx = resStack.size();\n    while (!resStack.empty()) {\n      res[--idx] = resStack.top();\n      resStack.pop();\n    }\n    return res;\n  }\n};\n```\n### Complexity\n- Time complexity: O(300n) = O(n) regardless of loops inside loop\n- Space complexity: O(300n) = O(n) for storing the expanded chars in stack\n- 300 comes from the factor that the max integer is 300","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919175734","body":"### Intuition\nThe naive solution would be to dump the main stack to the helper stack, get the element, and dump the helper stack back to the main stack in each call of pop(). This requires O(n) time complexity.\n\nAn improvement comes from the fact that once we dump the main stack to the helper stack, we can use it for multiple pop() operations.\n\nA typical way to think about it is to treat the internal stacks as input stack and output stack. Push() operations only know about input stack and keep adding elements into the input stack. Pop() operations only know about output stack, and can only get elements from the output stack. The transfer from input stack to output stack is triggered once for every n pop() operations, and when it happens, all elements in input stack are transferred to the output stack, in a batched manner.\n\nI also tend to think the output stack as a cached process. We only draw elements from the cache, and the elements are guaranteed to be found when the cache is not empty. When it is not empty, we need to go to the main stack and fetch a bunch of elements for the next rounds of pop(). The bunch size is the current size of the main stack.\n\nA side node about the empty() operation: we need to check the sizes of both input stack and output. stack\n\n### Implementation\n```c++\nclass MyQueue\n{\npublic:\n  /** Initialize your data structure here. */\n  MyQueue() {}\n\n  /** Push element x to the back of queue. */\n  void push(int x) { mystack.push(x); }\n\n  /** Removes the element from in front of queue and returns that element. */\n  int pop()\n  {\n    // Always get the item from cache\n    // if we cache is empty, we dump the items from mystack in reverse order\n    if (mystack_cache.empty()) {\n      while (!mystack.empty()) {\n        mystack_cache.push(mystack.top());\n        mystack.pop();\n      }\n    }\n    int res = mystack_cache.top();\n    mystack_cache.pop();\n    return res;\n  }\n\n  /** Get the front element. */\n  int peek()\n  {\n    if (mystack_cache.empty()) {\n      while (!mystack.empty()) {\n        mystack_cache.push(mystack.top());\n        mystack.pop();\n      }\n    }\n    return mystack_cache.top();\n  }\n\n  /** Returns whether the queue is empty. */\n  bool empty() { return mystack.empty() && mystack_cache.empty(); }\n\nprivate:\n  std::stack<int> mystack;\n  std::stack<int> mystack_cache;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n ```\n### Complexity\n- Time complexity: O(1) for push() and empty(), amortized O(1) for pop() and peak()\n- Space complexity: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920120878","body":"### Intuition\nWe can observe the following necessary and sufficient condition for splitting the array into chunks.\n\nIf an array can be splitted into chunks 0 to k, labelled as {c0, c1, ..., ck}, and if we denote the maximum element within a chunk ci ad max{ci}, then we have max{cj} >= max{ci}, for j >= i.\n\nIf we can somehow maintain a data structure to store those max{ci} while we scan through the whole array, we will be able to count the number of chunks that can be splitted by simply looking at the final size of the data structure. Moreover, we can further output the actual splitted chunks by recording additional information in the data structure.\n\nThe aforementioned data structure is monotonic stack. In this case, monotonically ascending stack if we scan array from left to right, monotonically descending stack if we scan array from right to left.\n\n### Implementation\n```c++\nclass Solution\n{\npublic:\n  int maxChunksToSorted(vector<int>& arr)\n  {\n    std::stack<int> s;\n    for (auto const& ele : arr) {\n      if (s.empty() || s.top() <= ele) {\n        s.push(ele);\n      } else {\n        int chunkLeader = s.top();\n        s.pop();\n        while (!s.empty() && s.top() > ele) {\n          s.pop();\n        }\n        // Now the leader of the chunk is back to the stack\n        s.push(chunkLeader);\n      }\n    }\n    return s.size();\n  }\n};\n```\n### Complexity\n- Time complexity: O(n) \n- Space complexity: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920961100","body":"### Intuition\nClassic fast-slow two pointer problem.\n\n\n### Implementation\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution\n{\npublic:\n  ListNode* rotateRight(ListNode* head, int k)\n  {\n    // Walk through the linked list once, to get its size n\n    // We only need to rotate k % n steps\n    // fast/slow two pointer solution\n    if (head == nullptr || head->next == nullptr) return head;\n    int nNodes{ 0 };\n    ListNode* ptr{ head };\n    while (ptr != nullptr) {\n      nNodes++;\n      ptr = ptr->next;\n    }\n    k = k % nNodes;\n    if (k == 0) return head;\n\n    ListNode* pFast{ head };\n    for (int ii = 0; ii < k; ii++) {\n      pFast = pFast->next;\n    }\n\n    ListNode* pSlow{ head };\n    while (pFast->next != nullptr) {\n      pSlow = pSlow->next;\n      pFast = pFast->next;\n    }\n    ListNode* res = pSlow->next;\n    pSlow->next = nullptr;\n    pFast->next = head;\n    return res;\n  }\n};\n```\n### Complexity\n- Time complexity: O(n) \n- Space complexity: O(1) ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922173440","body":"### Intuition\n- fast/slow two pointers to locate the middle of the linked list, if odd size, slow pointer points to the middle, if even size, slow pointer points to the middle right\n- recursion to build the left subtree and right subtree.\n- use \\[head, tail\\) as the range of the sub linked list that is passed to the recursive function\n\n### Implementation\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution\n{\npublic:\n  TreeNode* sortedListToBST(ListNode* head) { return sortedListToBST_(head, nullptr); }\n\nprivate:\n  TreeNode* sortedListToBST_(ListNode* head, ListNode* tail)\n  {\n    // the list contains nodes in the range of [head, tail);\n    // When do we stop? - when the head and tail meet\n    if (head == tail) {\n      // No element in the range: leaf node that has no left/right children\n      return nullptr;\n    }\n    // Find the middle ListNode of the subtree\n    ListNode* pSlow{ head };\n    ListNode* pFast{ head };\n    while (pFast != tail && pFast->next != tail) {\n      pFast = pFast->next->next;\n      pSlow = pSlow->next;\n    }\n\n    TreeNode* subroot = new TreeNode(pSlow->val);\n    subroot->left = sortedListToBST_(head, pSlow);\n    subroot->right = sortedListToBST_(pSlow->next, tail);\n    return subroot;\n  }\n};\n```\n### Complexity\n- Time complexity: O(NlogN) \n- Space complexity: O(logN) for the recursion call stack \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922381285","body":"### Intuition\n- Easy solution with O(n) space is to create a dictionary for one list and check the existance of each node in the other list\n- O(1) space complexity solution is recognizing that the interection problem in linked list is often associated with two pointers meet problem: can be with different walking paces pointers but same walking distances, or different intial walking distance walkers but with same walking paces, like in this case\n- The stop condition for this type of problem is 'WHEN THEY MEET': either meet at interection or the end of their lists (nullptr)\n- The type of problem often comes with resetting the pointer to heads of lists when it first reaches the tail of the list\n\n\n### Implementation\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution\n{\npublic:\n  ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\n  {\n    // O(n) time and O(1) space complexities\n    // fast/slow two-pointer problem, actually same pace but different distance walkers\n    // The first time two pointers will meet is when they walk the same amount of distance\n    // Walker A walked lengthA = skipA + commonLen, after it reaches the end of list A\n    // Walker B walked lengthB = skipB + commonLen, after it reaches the end of list B\n    // If walker A walks additional skipB, and walker B walks additional skipA,\n    // they will have their first meet at the total distance skipA + commonLen + skipB\n    // The the trick is walking both pointers at the same pace, until their first meet if they can meet,\n    // otherwise, they will all end up with nullptr at the end of their lists\n    ListNode *pA{ headA };\n    ListNode *pB{ headB };\n    while (pA != pB) {\n      // walk another skipB for walker A\n      if (pA == nullptr)\n        pA = headB;\n      else\n        pA = pA->next;\n      // walk another skipA for walker B\n      if (pB == nullptr)\n        pB = headA;\n      else\n        pB = pB->next;\n    }\n    return pA;\n  }\n};\n```\n### Complexity\n- Time complexity: O(N) \n- Space complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alwaysbest":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916982643","body":"# 思路\n#### 从低到高处理数组，刚下班，先打卡\n# 代码\npublic class add2ArrayFromInteger {\n\n    public static void main(String[]args) {\n        Scanner scan = new Scanner(System.in);\n        //数组长度\n        int len = scan.nextInt();\n        //数组\n        ArrayList<Integer> list = new ArrayList<>(len);\n        int i = 0;\n        while (scan.hasNext() && i<len) {\n            list.add(scan.nextInt());\n            i++;\n        }\n        //整数k\n        int k = scan.nextInt();\n        System.out.println(\"数组：\" + list);\n        System.out.println(\"整数：\" + k);\n        //调用方法\n        System.out.println(\"结果：\"+getSum(list, k));\n\n    }\n    \n    private static ArrayList<Integer> getSum(ArrayList<Integer> list, int k) {\n        \n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918234820","body":"## 思路\n利用栈处理数字、字母、括号\n## 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<Integer> numStack = new LinkedList<>();\n        Deque<String> wordStack = new LinkedList<>();\n        StringBuilder curr = new StringBuilder();\n        int multi = 0;\n\n        for (char c : s.toCharArray()) {\n            if (c <= '9' && c >= '0') {\n                multi = multi * 10 + c - '0';\n            } else if (c == '[') {\n                wordStack.push(curr.toString());\n                numStack.push(multi);\n                multi = 0;\n                curr = new StringBuilder();\n            } else if (c == ']') {\n                int count = numStack.pop();\n                StringBuilder tmp = new StringBuilder(wordStack.pop());\n                for (int i = 0; i < count; i++) {\n                    tmp.append(curr);\n                }\n                curr = tmp;\n            } else {\n                curr.append(c);\n            }\n        }\n        return curr.toString();\n    }\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922503154","body":" public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head, fast = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n            if (fast == slow) {\n                ListNode ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pzl233":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916985748","body":"# 思路\n\n把k本身当作carry\n从低位到高位进行循环，把carry加到目前处理的最低位，并对carry进行更新\n\n# 代码\n\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new LinkedList<>();\n        for (int i = num.length - 1; i >=0 ; i--) {\n            int carray = (num[i] + k) % 10;\n            k = (num[i] + k) / 10;\n            result.add(0, carray);\n        }\n        while (k > 0) {\n            result.add(0, k % 10);\n            k /= 10;\n        }\n        return result;\n    }\n\n```\n# 复杂度分析\n时间复杂度： O(n), where n is the length of the num array.\n空间复杂度:   O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917418783","body":"# 思路\r\n遍历数组两边：\r\n    先按从左到右的顺序计算当前的i离左边最近的字符C的距离\r\n    再从右到左计算当前i离右边最近的字符C的距离， 然后取两者之中的最小值记录作为结果\r\n\r\n\r\n# 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int curr = -n;\r\n        int result[] = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                curr = i;\r\n            }\r\n            result[i] = i - curr;\r\n        }\r\n        for (int i = curr - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c)  {\r\n                curr = i;\r\n            }\r\n            result[i] = Math.min(result[i], curr - i);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n# 复杂度分析\r\n时间复杂度： O(n), where n is the length of the String s.\r\n空间复杂度:   O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917654968","body":"# 思路\n\n在设计普通stack的同时记录一个额外的数组inc\ninc[i]代表stack[0]到stack[i]之间的元素应该增加的量\n因为我们只需要在pop的时候用到这个多增加的量，所以可以在pop的时候返回stack顶的元素+inc[topIndex[对stack的下一个\ntop对应的inc, which is inc[i - 1]进行 inc[i - 1] += inc[i]的赋值\n# 代码\n\n```java\nclass CustomStack {\n    private int capacity;\n    private int size = 0;\n    private int[] stack;\n    private int[] inc;\n    private int topIndex = -1;\n\n    public CustomStack(int maxSize) {\n        capacity = maxSize;\n        stack = new int[maxSize];\n        inc = new int[maxSize];\n        \n    }\n    \n    public void push(int x) {\n        if (size < capacity) {\n            topIndex = size;\n            stack[size++] = x;\n        }\n    }\n    \n    public int pop() {\n        if (topIndex < 0) {\n            return -1;\n        }\n        if (topIndex > 0) {\n            inc[topIndex - 1] += inc[topIndex];\n        }\n        int result = stack[topIndex] + inc[topIndex];\n        inc[topIndex--] = 0;\n        size--;\n        return result;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, size) - 1;\n        if (i >= 0) {\n            inc[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n# 复杂度分析\n时间复杂度： \n\npush：O(1)\n\npop：O(1)\n\nincrement：O(1)\n\n空间复杂度:   O(maxSize)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918380700","body":"# 思路\n\n用两个stack in and out，在push的时候只push到in上面，而当需要取出来的时候，如果out不含任何元素，那就把in里面的元素全部转移到out里面，这样的话最早push进in里面的就会变成out的top，从而满足queue的要求\n\n# 代码\n\n```java\nclass MyQueue {\n    private Stack<Integer> in;\n    private Stack<Integer> out;\n    \n    /** Initialize your data structure here. */\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        in.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        peek();\n        return out.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (out.isEmpty()) {\n            while (!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n# 复杂度分析\n时间复杂度： O(n)\n空间复杂度:   Amortized O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919635726","body":"# 思路\n对于在i位置的元素来说，如果在数组中i后面存在比它小的数，那么我们就不能在i位置进行分割。\n\n## 思路1： 利用单调栈\n保持一个单调递增的栈，并遍历数组。如果栈顶的元素比当前元素小，那么我门就不能在当前位置进行分割。换句话说就是得把当前元素和之前的元素融合成一个块。并且再融合之后，这个块里面的最大值也要比数组后面所有的数值小。所以我们可以碰到比栈顶小的元素时，先记录下当前栈顶（最大值），然后一直pop直到栈顶<当前值，再放回之前记录的最大值，从而保持这个融合出来的块的最大值。\n\n\n# 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        stack.push(-1);\n        for (int i : arr) {\n            if (i >= stack.peek()) {\n                stack.push(i);\n            } else {\n                int currMax = stack.pop();\n                while (stack.peek() != -1 && stack.peek() > i) {\n                    stack.pop();\n                }\n                stack.push(currMax);\n            }\n        }\n        return stack.size() - 1;\n    }\n}\n\n```\n# 复杂度分析\n时间复杂度： O(n), where n is the length of the num array.\n空间复杂度:   O(n)\n\n## 思路2： 用数组记录从后数的最小值。\n对于在i位置的元素来说，如果在数组中i后面存在比它小的数，那么我们就不能在i位置进行分割。那么我们可以从记录从后面数到当前位置的最小值。假设这个minFromBack数组的第i位元素是x，那么在i到minFromBack.length这个范围里的最小值就是x。利用这个性质，我们对input的数组进行遍历，并且记录从前开始数的最大值。如果在当前位置j，我们记录的最大值大于minFromBack[j],就意味着在j后面存在比到j为止的最大值更大的值，那么就不能进行分割。\n\n\n# 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        int curMax = Integer.MIN_VALUE;\n        int[] minFromBack = Arrays.copyOf(arr, n);\n        int result = 1;\n        for (int i = n - 2; i >= 0; i--) {\n            minFromBack[i] = Math.min(arr[i], minFromBack[i + 1]);\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            curMax = Math.max(curMax, arr[i]);\n            if (curMax <= minFromBack[i + 1]) {\n                result++;\n            }\n        }\n        \n        return result;\n    }\n}\n\n```\n# 复杂度分析\n时间复杂度： O(n), where n is the length of the num array.\n空间复杂度:   O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920546076","body":"# 思路\n先获取链表的长度，再用这个长度%k得到真正需要旋转的次数\n在旋转过后，原来列表中的倒数第k个node会变成新的head,而倒数第k+1个node则变成tail\n利用这个性质，我们可以用双指针，一快一慢，使他们相隔k个node\n这样当快指针指向tail的时候，慢指针就会指向倒数第k+1个node\n然后保存下慢指针的next,也就是倒数第k个node，新的head\n再讲慢指针的next赋值为null,快指针的next赋值为原本的head\n然后返回新head\n\n# 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        int length = 1;\n        ListNode temp = head;\n        while (temp.next != null) {\n            temp = temp.next;\n            length++;\n        }\n        \n        k = k % length;\n        if (k == 0) {\n            return head;\n        }\n        \n        ListNode fast = head;\n        ListNode slow = head;\n        for (int i = 0; i < k; i++) {\n            fast = fast.next;\n        }\n        \n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        fast.next = head;\n        ListNode result = slow.next;\n        slow.next = null;\n        return result;\n    }\n}\n\n```\n# 复杂度分析\n时间复杂度： O(n), where n is the length of the linkedlist.\n空间复杂度:   O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921907501","body":"# 思路\n用三指针进行两两交换\n\n\n# 代码\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode prev = dummy;\n        ListNode first = head;\n        ListNode second = head.next;\n        while (second != null) {\n            first.next = second.next;\n            second.next = first;\n            dummy.next = second;\n            dummy = first;\n            if (first == null || first.next == null) break;\n            first = first.next;\n            second = first.next;\n        }\n        return prev.next;\n    }\n}\n\n```\n# 复杂度分析\n时间复杂度： O(n), where n is the length of the list.\n空间复杂度:   O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangshisong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916987710","body":"# Day-1 ：2021-09-10\r\n# 思路\r\n从右向左\r\n进位操作在下一步执行\r\n下一步根据不同情况执行不同操作\r\n\r\n### 缺点\r\n每次需要判断不同情况用以执行不同操作，主要耗时在这个地方\r\n\r\n\r\n\r\n\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        last = 0\r\n        for i in range(max(len(num), len(str(k)))):\r\n            \r\n            if i  < len(str(k)) and i  < len(num):\r\n            \r\n                num[-1-i] = num[-1-i] + int(str(k)[-1-i]) + last\r\n            elif i  >= len(str(k)) and i  < len(num):\r\n                if last > 0:\r\n                    num[-1-i] = num[-1-i] + last\r\n                    last = 0\r\n                else:\r\n                    break\r\n            elif i  < len(str(k)) and i  >= len(num):\r\n                num = [int(str(k)[-1-i])  + last ] + num\r\n                \r\n            if num[-1-i] >= 10:\r\n                num[-1-i] -= 10\r\n                last = 1\r\n            else:\r\n                last = 0\r\n\r\n        if last == 1:\r\n            return [1] + num\r\n                \r\n        return num\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917380083","body":"# Day-12：2021-09-11\r\n# 思路\r\n从左向右遍历一次\r\n考虑不同情况\r\n\r\n\r\n### 缺点\r\n数组索引次数较多，略耗时\r\n\r\n\r\n\r\n\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        toLeft_list = []\r\n        result_list = []\r\n        previous_max = 0\r\n        for chara_index, chara in enumerate(s):                 \r\n            if chara == c:\r\n                toLeft_list = toLeft_list + [chara_index-previous_max]\r\n                if chara_index == 0:\r\n                    result_list = [0]\r\n                else:\r\n                    toLeft_list_len = len(toLeft_list)\r\n                    if len(result_list) == 0:\r\n                        toLeft_list.reverse()\r\n                        result_list = toLeft_list\r\n                    elif toLeft_list_len > 2:\r\n                        result_list = result_list + toLeft_list[1:int((toLeft_list_len + 0.5)/2)]\r\n                        toLeft_list = toLeft_list[:-int((toLeft_list_len + 0.5)/2) ]\r\n                        toLeft_list.reverse()    \r\n                        result_list = result_list + toLeft_list\r\n                    else:\r\n                        result_list = result_list + [0]\r\n                    previous_max = len(result_list)-1\r\n                    toLeft_list = [0]\r\n            else:\r\n                toLeft_list = toLeft_list + [chara_index-previous_max]\r\n        return result_list + toLeft_list[1:]\r\n```\r\n# 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 应该是O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917558206","body":"# Day-12：2021-09-12\r\n# 思路\r\n不需要思路\r\n用变量记录长度，并不确定是否比调用len()更节约时间\r\n\r\n\r\n### 缺点\r\n没什么直观缺点\r\n\r\n\r\n\r\n\r\n# 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.stack_length = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.stack_length < self.maxSize:\r\n            self.stack.append(x)\r\n            self.stack_length += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.stack_length ==0:\r\n            return -1\r\n        self.stack_length -= 1\r\n        return self.stack.pop(-1)\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for inc_index in range(k):\r\n            if inc_index < self.stack_length:\r\n                self.stack[inc_index] += val\r\n            else:\r\n                break\r\n```\r\n# 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 应该是O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918233537","body":"# Day-4：2021-09-13\r\n# 思路\r\n有思路，写不出，还需要再研究一下\r\n\r\n\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n    \r\n        num_stack = []  \r\n        num_val = 0\r\n        result = \"\"  \r\n        for ele in s:\r\n            if ele.isdigit():\r\n                num_val = num_val * 10 + int(ele)\r\n            elif ele == \"[\":\r\n                num_stack.append([result, num_val])\r\n                result, num_val = \"\", 0\r\n            elif ele == \"]\":\r\n                top = num_stack.pop()\r\n                result = top[0] + result * top[1]\r\n            else:\r\n                result += ele\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919179066","body":"# Day-5：2021-09-14\r\n# 思路\r\n不需要什么思路，唯一需要在意的点是pop第一个元素会是O(n)复杂度，因为后续的重新排序会需要比较长的时间，因此，在这里我们移动指针而不是每次都执行pop，相对节约了时间\r\n\r\n# 缺点\r\n如果遇到特别冗长的操作指令，可能会占用太多内存，因此，可以设定一个阈值用来更新数组，以防内存过载\r\n\r\n# 代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.MyQueue = []\r\n        self.start_pos = 0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.MyQueue += [x]\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        self.start_pos += 1\r\n\r\n        return self.MyQueue[self.start_pos-1]\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n\r\n        return self.MyQueue[self.start_pos]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if len(self.MyQueue) - self.start_pos == 0:\r\n            return True\r\n        return False\r\n\r\n\r\n```\r\n# 复杂度\r\n时间复杂度: O(1)\r\n空间复杂度: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920104106","body":"# 思路\r\n不会，需要再思考，但今天没时间了\r\n\r\n# 代码:\r\n```python\r\ndef maxChunksToSorted(self, arr):\r\n        count = collections.defaultdict(int)\r\n        ans = nonzero = 0\r\n\r\n        for x, y in zip(arr, sorted(arr))\r\n            count[x] += 1\r\n            if count[x] == 0: nonzero -= 1\r\n            if count[x] == 1: nonzero += 1\r\n\r\n            count[y] -= 1\r\n            if count[y] == -1: nonzero += 1\r\n            if count[y] == 0: nonzero -= 1\r\n\r\n            if nonzero == 0: ans += 1\r\n\r\n        return ans\r\n```\r\n# 复杂度分析\r\n时间复杂度: O(NlogN)\r\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920894641","body":"# 思路\r\n先转成数组再转回链表\r\n\r\n# 缺点\r\n应该不需要这么麻烦，对链表的操作不清楚，需要进一步学习\r\n\r\n# 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        val_list = []\r\n    \r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n\r\n        original_head = head\r\n\r\n        while head.next is not None:\r\n            val_list += [head.val]\r\n            head = head.next\r\n        \r\n        val_list +=[head.val]\r\n        k = k%len(val_list)\r\n\r\n        if k is 0:\r\n            return original_head\r\n\r\n\r\n        val_list = val_list[-k:] + val_list[:len(val_list)-k]\r\n        \r\n        inner_node = None\r\n        for num_index in range(len(val_list)):\r\n            inner_node = ListNode(val = val_list[-num_index-1], next = inner_node)\r\n        return inner_node\r\n```\r\n# 复杂度分析\r\n时间: O(n)\r\n空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921819606","body":"# 思路\r\n看了参考答案以后，基本上就是下个和下下个交换， 需要之后在学习学习，代码复制的标准答案\r\n\r\n# 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummyHead = ListNode(0)\r\n        dummyHead.next = head\r\n        temp = dummyHead\r\n        while temp.next and temp.next.next:\r\n            node1 = temp.next\r\n            node2 = temp.next.next\r\n            temp.next = node2\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            temp = node1\r\n        return dummyHead.next\r\n```\r\n# 复杂度分析\r\n时间: O(n)\r\n空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922328672","body":"# 思路\r\n有思路，想先转成数组，再取中点建树，但实现不了。 这里先放上标准答案，之后再好好研究。\r\n\r\n# 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getLength(head: ListNode) -> int:\r\n            ret = 0\r\n            while head:\r\n                ret += 1\r\n                head = head.next\r\n            return ret\r\n        \r\n        def buildTree(left: int, right: int) -> TreeNode:\r\n            if left > right:\r\n                return None\r\n            mid = (left + right + 1) // 2\r\n            root = TreeNode()\r\n            root.left = buildTree(left, mid - 1)\r\n            nonlocal head\r\n            root.val = head.val\r\n            head = head.next\r\n            root.right = buildTree(mid + 1, right)\r\n            return root\r\n        \r\n        length = getLength(head)\r\n        return buildTree(0, length - 1)\r\n\r\n```\r\n# 复杂度分析\r\n时间: O(N)\r\n空间: O(logN)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922482154","body":"# 思路\r\n同时遍历，找交叉点\r\n\r\n# 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a = headA\r\n        b = headB\r\n        while a != b:\r\n            if a is not None:\r\n                a = a.next\r\n            else:\r\n                a = headB\r\n            if b is not None:\r\n                b = b.next\r\n            else:\r\n                b = headA\r\n        return a\r\n```\r\n\r\n# 复杂度分析\r\n时间: O(m+n)\r\n空间: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baoqin87":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916989796","body":"## 989. 数组形式的整数加法\n\n### 思路 逐位加法\n例如计算 123+912，我们从低位到高位依次计算 3+2、2+1 和 1+9。任何时候，若加法的结果大于等于 10，把进位的 1 加入到下一位的计算中，所以最终结果为 1035。\n\n### 代码 JavaScript\n\n```javascript\nvar addToArrayForm = function(num, k) {\n  let n = num.length\n  let sum = 0\n  let res = []\n  for (let i = n - 1; i>=0; i--) {\n      sum = num[i] + k % 10\n      k = Math.floor(k/10)\n      if (sum>=10) {\n          k++\n          sum -= 10\n      }\n      res.push(sum)\n  }\n  for (;k>0;k=Math.floor(k/10)){\n      res.push(k%10)\n  }\n  res.reverse()\n  return res\n}\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(max⁡(n,log⁡k))，其中 n 为数组的长度。\n* 空间复杂度：O(n)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917421521","body":"## 821.字符的最短距离\n\n### 思路\n向左或者向右距离目标字符最近的距离，取最小值\n\n### 代码 JavaScript\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  let len = s.length\n  let res = []\n  let prev = -10000\n  for (let i = 0; i < len; ++i) {\n    if (s.charAt(i) == c) prev = i\n    res[i] = i - prev\n  }\n  prev = 20000\n  for (let i = len - 1; i >= 0; --i) {\n    if (s.charAt(i) == c) prev = i\n    res[i] = Math.min(res[i], prev - i)\n  }\n  return res\n}\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n2)，其中 n 为数组的长度。\n* 空间复杂度：O(n)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917644078","body":"## 1381.设计一个支持增量操作的栈\n\n### 思路\n用数组模拟栈操作\n\n### 代码 JavaScript\n\n```javascript\nvar CustomStack = function(maxSize) {\n  stack = []\n  len = 0\n  size = maxSize\n};\nCustomStack.prototype.push = function(x) {\n  if (len < maxSize) stack[++len] = x\n  return stack\n\n};\nCustomStack.prototype.pop = function() {\n  if (len) return stack[len--]\n  return -1\n};\nCustomStack.prototype.increment = function(k, val) {\n  while (k) stack[k--] += val\n}\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(1)。\n* 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918255932","body":"### 思路\r\n使用入栈出栈操作，将原字符串解码\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\nvar decodeString = function(s) {\r\n  let res = '';\r\n  let multi = 0;\r\n  let stack_multi = [];\r\n  let stack_res = [];\r\n  for (let i = 0, len = s.length; i < len; i++) {\r\n    c = s.charAt(i)\r\n    if(c == '[') {\r\n      // 把数字和拼接的字母分别压入栈\r\n      stack_multi.push(multi)\r\n      stack_res.push(res)\r\n      multi = 0\r\n      res = ''\r\n    } else if(c == ']') {\r\n      let tmp = ''\r\n      // 数字出栈\r\n      let cur_multi = stack_multi.pop()\r\n      // 数字作为循环次数\r\n      for (let i = 0; i < cur_multi; i++) {\r\n        tmp += res\r\n      }\r\n      res = stack_res.pop() + tmp\r\n    } else if (c >= '0' && c <= '9') {\r\n      multi = multi * 10 + parseInt(c)\r\n    } else {\r\n      res += c\r\n    }\r\n  }\r\n  return res;\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(N)。\r\n* 空间复杂度：O(N)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919237552","body":"### 思路\n* 将一个栈当作输入栈，用于压入push传入的数据；\n* 另一个栈当作输出栈，用于pop 和 peek 操作。\n* 每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，\n* 这样输出栈，从栈顶往栈底的顺序，就是队列从队首往队尾的顺序。\n\n### 代码 JavaScript\n\n```javascript\n/**\n * 初始化数据结构.\n */\nvar MyQueue = function() {\n  // 输入栈\n  this.in_stack = []\n  // 输出栈\n  this.out_stack = []\n};\n\n/**\n * 往输入栈里塞值. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.in_stack.push(x)\n};\n\n/**\n * 删除并返回数组的最后一个元素\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  if (this.out_stack.length == 0) {\n    this.in2out()\n  }\n  return this.out_stack.pop()\n};\n\n/**\n * 栈首出栈.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if (this.out_stack.length == 0) {\n    this.in2out()\n  }\n  return this.out_stack[this.out_stack.length - 1]\n};\n\n/**\n * 队列是否为空.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.in_stack.length == 0 && this.out_stack.length == 0\n};\n\n/**\n * 从输入栈弹出元素，塞到输出栈\n */\nMyQueue.prototype.in2out = function() {\n  while (this.in_stack.length > 0) {\n    this.out_stack.push(this.in_stack.pop())\n  }\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n)。\n* 空间复杂度：O(n)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920074080","body":"### 思路\n判断是否是排序块，只需要用到该块的元素最大值 head。可以遍历一遍数组 arr ，动态判断到目前数字 num 为止，最多能分出多少排序块，并保存每个排序块的最大值 head 。每遍历到下个数字 num ，动态判断前面所有的排序块是否成立，并更新所有排序块。\n\n### 代码 JavaScript\n\n```javascript\nvar maxChunksToSorted = function(arr) {\n  let stack = []\n  let num\n  for (let i = 0, len = arr.length; i < len; i++) {\n    num = arr[i]\n    if (stack.length > 0 && num < stack[stack.length - 1]) {\n      let head = stack.pop()\n      while(stack.length > 0 && num < stack[stack.length - 1]) {\n        stack.pop()\n      }\n      stack.push(head)\n    } else {\n      stack.push(num)\n    }\n  }\n  return stack.length\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n)。\n* 空间复杂度：O(n)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920935911","body":"### 思路\n快慢指针\n* 获取单链表的倒数第 k（尾节点）与倒数第 k+1 个节点\n* 将倒数第 k+1个节点的 next 指向 null\n* 将尾节点的 next 指向 head（拼起来）\n* 返回倒数第 k 个节点\n### 代码 JavaScript\n\n```javascript\nvar rotateRight = function(head, k) {\n  if (!head || !head.next) return head\n  let count = 0, now = head\n  while(now) {\n    now = now.next\n    count++\n  }\n  k = k % count\n  let slow = (fast = head)\n  while(fast.next) {\n    if (k-- <= 0) {\n      slow = slow.next\n    }\n    fast = fast.next\n  }\n  fast.next = head\n  let res = slow.next\n  slow.next = null\n  return res\n}\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n)。\n* 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921804203","body":"### 思路\n递归法处理，递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。\n如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。\n\n### 代码 JavaScript\n\n```javascript\nvar swapPairs = function(head) {\n  if (head == null || head.next == null) {\n    return head\n  }\n  let next = head.next\n  head.next = swapPairs(next.next)\n  next.next = head\n  return next\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。\n* 空间复杂度：O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922323841","body":"### 思路\n* 先构建左子树，再构建根节点，再构建右子树。——遵循中序遍历。\n* 其实，BST 的中序遍历，打印的节点值正是这个有序链表的节点值顺序\n \n### 代码 JavaScript\n\n```javascript\nvar sortedListToBST = (head) => {\n  if (head == null) return null\n  let len = 0\n  let h = head\n  while(head) {\n    len++\n    head = head.next\n  }\n  const buildBST = (start, end) => {\n    if (start > end) return null\n    const mid = (start + end) >>> 1\n    const left = buildBST(start, mid - 1)\n    const root = new TreeNode(h.val)\n    h = h.next\n    root.left = left\n    root.right = buildBST(mid + 1, end)\n    return root\n  }\n  return buildBST(0, len - 1)\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n)。\n* 空间复杂度：O(logn)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922470316","body":"### 思路\n* 把a链表的元素遍历出来放一个集合里\n* 遍历b链表，判断是否在之前生成的集合里，存在的话就是要找的相交点，找不到就返回null表示不相交\n \n### 代码 JavaScript\n\n```javascript\nvar getIntersectionNode = function(headA, headB) {\n  let aSet = new Set()\n  pA = headA\n  pB = headB\n  while (pA) {\n    aSet.add(pA)\n    pA = pA.next\n  }\n  while (pB) {\n    if (aSet.has(pB)) {\n      return pB\n    } else {\n      pB = pB.next\n    }\n  }\n  return null\n};\n\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n)。\n* 空间复杂度：O(n)。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"StefanLeeee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916990366","body":"### 思路\r\n把k本身当作carry\r\n从低位到高位进行循环，把carry加到目前处理的最低位，并对carry进行更新\r\n### 代码\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}`\r\n### 复杂度分析\r\n时间复杂度：O(max(n,logk))，其中 nn 为数组的长度。\r\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429247","body":"# 思路\n将字符串转化为数组，chatAt()可以算出ASCII码，然后遍历整个数组，每个元素的charAt(i) - charAt(C)，即可算出每个字符到字符C的最短距离\n# 代码\n```\n public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n\n```\n# 复杂度分析\n时间复杂度：O(N)\n空间复杂读：O(N) ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918251807","body":"# 思路\n* 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\n* 如果当前的字符为字母或者左括号，直接进栈\n* 如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串\n\n# 代码\n``` java\npackage com.leetcode;\n\nimport java.util.Collections;\nimport java.util.LinkedList;\n\n/**\n * @author Enbing\n * @create 2021-09-13 8:30 PM\n * @Description\n */\npublic class T394 {\n    int ptr;\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<>();\n        ptr = 0;\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                //获取一个字母并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                //获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++)));\n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                //左括号出栈\n                stk.removeLast();\n                //此时栈顶为当前sub对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                //构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                stk.addLast(t.toString());\n            }\n        }\n        return getString(stk);\n    }\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n\n\n```\n# 复杂度\n时间复杂度：O(S+∣s∣)，即 O(S)O(S)\n空间复杂度：O(S)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919175569","body":"# 思路\n一个输入栈，一个输出栈。四个方法：push，pop，peek，empty。\n* push时，需判断输入栈是否满，未满，直接将值push进即可\n* pop时，需先判断输出栈是否为空，若为空，则先将输入栈中的值push进输出栈，pop结束，移除栈顶元素\n* peek时，同样需判断输出栈是否为空，若为空，也需将输入栈中的值push进输出栈，peek不移除栈顶元素\n* empty，如果输入栈和输出栈同时为空，则return true，有一个不为空，则return false\n# 代码\n``` java\nclass MyQueue {\n\n        Deque<Integer> instack;\n        Deque<Integer> outstack;\n\n        /**\n         * Initialize your data structure h    ere.\n         */\n        public MyQueue() {\n            instack = new LinkedList<Integer>();\n            outstack = new LinkedList<Integer>();\n\n        }\n\n        /**\n         * Push element x to the back of queue.\n         */\n        public void push(int x) {\n            instack.push(x);\n        }\n\n        /**\n         * Removes the element from in front of queue and returns that element.\n         */\n        public int pop() {\n            if (outstack.isEmpty()) {\n                outStack1ToStack2();\n            }\n            return outstack.pop();\n        }\n\n        /**\n         * Get the front element.\n         */\n        public int peek() {\n            if (outstack.isEmpty()) {\n                outStack1ToStack2();\n            }\n            return outstack.peek();\n        }\n\n        /**\n         * Returns whether the queue is empty.\n         */\n        public boolean empty() {\n            return instack.isEmpty() && outstack.isEmpty();\n        }\n\n        public void outStack1ToStack2() {\n            while (!instack.isEmpty()) {\n                outstack.push(instack.pop());\n            }\n        }\n    }\n···\n# 复杂度\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920926331","body":"# 思路\n寻找head，移动k，k与n取模运算。找到头结点，然后再去做处理\n# 代码\n``` java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n```\n# 复杂度\n时间复杂度： O(N)，最坏的情况下，需要遍历链表两次\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921792562","body":"# 思路\n递归实现\n# 代码\n``` java\npublic ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n                \n    }\n```\n# 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922331503","body":"# 思路 \n参考LeetCode\n# 代码\n``` java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n\n```\n# 复杂度\n* 时间复杂度：O(n log n)，其中 nn 是链表的长度\n* 空间复杂度：O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Venchyluo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916993064","body":"###### \r\n简易版，把K也变成list, 然后翻转两个list， 每个位置相加。 主要注意carry， 进位的问题就好。 这样的做法就有点像linked list 相加的那道题了.\r\n\r\nO (N) 做法其实只需要从num 尾巴开始加起，也是注意carry， 是否有进位的情况。\r\n######\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry,i = 0,len(num)-1\r\n      \r\n        while carry or k or i > -1:\r\n            carry += (num[i] if i > -1 else 0) + (k % 10 if k else 0)\r\n            res.append(carry % 10)\r\n            k //= 10\r\n            carry //= 10\r\n            i -= 1\r\n            \r\n        return res[::-1]\r\n```\r\n\r\n###### \r\n时间复杂度： O(N)\r\n\r\n空间复杂度：O(1)（ 不算res的情况下）\r\n###### ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917418667","body":"###### \r\n第一个char之前都是以第一个char为标准， 同理最后一个char之后都是以这个char为标准。中间的 [char， x, x, x, char] 就需要左右两边扫一次看看是哪个char 离得近。 \r\n\r\n######\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \r\n        prev = float('-inf')\r\n        res = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                prev = i # update new_prev             \r\n            res.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i] == c:\r\n                prev = i\r\n            res[i] = min(res[i], prev - i)\r\n            \r\n        return res\r\n```\r\n\r\n###### \r\n时间复杂度： O(N) 左右各循环一次\r\n\r\n空间复杂度：O(N) for res || O(1)\r\n###### \r\n\r\n\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        # 贴一个用stack的写法，就不用走两遍，重点就是记住前一个s[i] == c的位置\r\n        stack = []\r\n        res = [0]*len(s) #这样下面当s[i] == c  就不要考虑 0 的问题了\r\n        prev = -1\r\n        \r\n        for i in range(len(s)):\r\n            if not stack and s[i] == c:\r\n                prev = i\r\n                continue \r\n                \r\n            if stack and s[i] == c:\r\n                while stack:\r\n                    tmp = stack.pop()\r\n                    if prev != -1: # indicate it's not the first 'c'\r\n                        res[tmp] = min(abs(i-tmp),abs(prev-tmp))                      \r\n                    else:\r\n                        res[tmp] = abs(i-tmp)\r\n                        \r\n                prev = i\r\n                continue\r\n            \r\n            stack.append(i)\r\n                       \r\n        while stack:\r\n            temp = stack.pop()\r\n            res[temp] = temp-prev\r\n                \r\n        return res\r\n            \r\n\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917660387","body":"###### \r\n用array 模拟stack， 注意控制一个maxSize的量就好量\r\n######\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.size = 0\r\n        self.stack = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.max_size:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            self.size -= 1\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k,len(self.stack))):\r\n            self.stack[i] += val\r\n            \r\n\r\n        \r\n```\r\n\r\n###### \r\ntime complexity:  push O(1) 放在尾巴,  pop O(1), increment O(min(k,len(stack)))\r\n\r\nspace complexity: O(N) for self.stack\r\n###### \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918297176","body":"###### \r\n注意分析遇到数字， 字母，'[', ']' 不同情况时如何处理。因为题目规定好，不会出现3[4],3a 这种情况，可以假定int*[alphabet*] 这样的顺序。  \r\n注意两个字符串， 一个是之前已经处理完毕，需要和现在的正在处理的字符串相加\r\n######\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        cur_string,times = '',0\r\n        stack = []\r\n        for char in s:\r\n            if char.isdigit():\r\n                times = times*10+int(char) \r\n                # 因为可能是多位数           \r\n            elif char == '[':\r\n                stack.append(cur_string)\r\n                stack.append(times)   \r\n                times,cur_string = 0,''\r\n            elif char == ']':\r\n                pre_times = stack.pop()\r\n                pre_string = stack.pop()\r\n                cur_string = pre_string + pre_times * cur_string         \r\n            else:\r\n                cur_string += char\r\n                \r\n        return cur_string\r\n            \r\n\r\n        \r\n```\r\n\r\n###### \r\ntime complexity:  O(N)\r\nspace complexity: O(N) \r\n###### ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920061795","body":"###### \r\n条件： min(chunk) <= max(chunk)    \r\n 可以用两个list分别记录到index 时左边（包括这个index） 的max_value, 右边chunk.min_value, 只要保证 左边 max_value <= 右边min_value, 那么就可以把这个大chunk 分成两个。 这也是为什么chunks的初始值为1.\r\n######\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        \r\n        min_array, max_array = [0]*len(arr),[0]*len(arr)\r\n        min_array[-1],max_array[0] = arr[-1],arr[0]\r\n        for i in range(1,len(arr)):\r\n            max_array[i] = max(max_array[i-1],arr[i])\r\n            \r\n        for i in range(len(arr)-2,-1,-1):\r\n            min_array[i] = min(min_array[i+1],arr[i])\r\n           \r\n        chunks = 1\r\n        for i in range(1,len(arr)):\r\n            if max_array[i-1] <= min_array[i]:\r\n                chunks += 1\r\n                   \r\n        return chunks\r\n        \r\n```\r\n###### \r\n条件： min(chunk) <= max(chunk)  \r\n单调栈做法， stack中只记录到目前位置出现的max_chunk_value。如果遇见比栈顶元素小的，就要不停出栈，直到找到一个new peek 比 该元素大，满足条件。\r\n######\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for i in range(len(arr)):\r\n            if not stack or arr[i] >= stack[-1]:\r\n                stack.append(arr[i])\r\n            else:\r\n                temp_max = stack[-1]\r\n                while stack and stack[-1] > arr[i]:\r\n                    stack.pop()\r\n                stack.append(temp_max)\r\n    \r\n        \r\n        return len(stack)\r\n        \r\n        \r\n        \r\n```\r\n\r\n\r\n###### \r\n\r\ntime complexity: overall O(N) \r\nspace complexity: O(N) \r\n###### \r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921847430","body":"###### \r\n语句匮乏。 就是交换node, 如果用recursion, 就是指向下一个，下一个并没有到break point,就继续recursion  \r\n######\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next: return head\r\n        \r\n        node1, node2 = head,head.next\r\n        node1.next = self.swapPairs(node2.next)\r\n        node2.next = node1\r\n        \r\n        return node2\r\n        \r\n```\r\n###### \r\ntime complexity: O(N)   \r\nspace complexity: O(N) call stack \r\n###### \r\n\r\n###### \r\niteration \r\n######\r\n\r\n###### \r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        dummy = ListNode(-1)\r\n        dummy.next = head\r\n        cur = dummy\r\n        \r\n        while head and head.next:\r\n            node1,node2 =head,head.next\r\n            cur.next = node2\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            \r\n            cur, head = node1, node1.next\r\n            \r\n        return dummy.next\r\n\r\n```\r\n\r\n\r\n###### \r\ntime complexity: O(N)   \r\nspace complexity: O(1) \r\n###### \r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922329598","body":"###### \r\n这道题如果把linked list 先变成array code比较好写。 如果直接recursion 就快慢指针找到中间值，它作为root，再往左，右 不停取 截断 的linked list 的中间值mid一直往下recursion。 \r\n######\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head: return None\r\n        if not head.next: return TreeNode(head.val)\r\n        \r\n        fast, slow = head.next.next, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            \r\n        mid = slow.next\r\n        slow.next = None \r\n        root = TreeNode(mid.val)\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(mid.next)\r\n        \r\n        return root\r\n        \r\n```\r\n\r\n\r\n###### \r\ntime complexity: O(N log N)   \r\nspace complexity: O(log N) 因为题目规定height balanced BST, 不会有最差到N 这种可能性。 \r\n###### \r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lydia61":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916993282","body":"**思路**：取整，大于10进1，否则0，然后去掉多余0.\r\n**代码：python**\r\n`class Solution():\r\n    def plusK(self, digits, k):\r\n        res = [k] #把k当作初始值去做加法，66题的启示\r\n        for digit in digits[::-1]: #遍历\r\n            current_digit = res[-1] + digit #进位后\r\n            res[-1] = current_digit % 10 #整除\r\n            res.append(current_digit // 10) #＞10进位1；否则0\r\n        if res[-1] == 0: #去0\r\n            res.pop()\r\n        return res[::-1]\r\ndemo = Solution()\r\ndemo.plusK([9, 9], 11)`\r\n**时间复杂度n\r\n空间复杂度n**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429802","body":"**思路**\n左右遍历，取最小值\n\n**代码 python**\n `class Solution():\n   def shortChar(self, S, C):\n        ans = []\n        first = -10**4\n        for i, x in enumerate(S):\n            if x == C: \n                first = i \n            ans.append(i - first)\n\n        first = 10**4\n        for i in range(len(S)-1, -1, -1):\n            if S[i] == C: \n                first = i\n            ans[i] = min(ans[i], first - i)\n        return ans\ndemo = Solution()\ndemo. shortChar(\"loveleetcode\", \"e\")` \n\n**复杂度分析**\n\n空间复杂度 O(N)\n时间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917659353","body":"# 设计一个支持增量操作的栈\r\n\r\n## 思路\r\n\r\n- **存储数据：** 用list存储栈的内容\r\n- **push()操作：** 入栈前对内容长度进行判断，如果内容长度小于`maxSize`，则进行入栈操作\r\n- **pop()操作：** 出栈前对内容长度进行判断，如果长度大于`0`则删除并返回栈顶元素，否则直接返回`-1`\r\n- **increment(k, val)操作：** 将栈底的前 `min(k, length)`个元素的值加`k`，其中`length`为内容长度\r\n\r\n## 代码\r\n\r\n``` python \r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.stack = []\r\n        self.max_size = maxSize\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        return self.stack.pop() if self.stack else -1\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val\r\n```\r\n## 复杂度分析\r\n\r\n### 时间复杂度\r\n\r\n- push: O(1) \r\n- pop: O(1) \r\n- increment: O(k)\r\n\r\n### 空间复杂度\r\n\r\nO(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918325157","body":"# 字符串解码\n\n## 思路\n\n遍历原字符串，将所有除`']'`以外的元素放入栈中，当遇到`']'`的时候对前面对应`'['`内的内容进行解码\n\n## 代码\n\n``` python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        res = []\n        for c in s:\n            if c != ']':\n                res.append(c)\n            else:\n                encoded_string = ''\n                k = ''\n                while res[-1] != '[':\n                    encoded_string = res.pop() + encoded_string\n                res.pop()\n                while res and res[-1].isdigit():\n                    k = res.pop() + k\n                res += encoded_string * int(k)\n        return ''.join(res)\n```\n\n## 性能分析\n\n- **时间复杂度：** O(n)\n- **空间复杂度：** O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921001074","body":"# 旋转链表\r\n\r\n## 思路\r\n\r\n将倒数后 `k % length` 位移至链表开头\r\n\r\n## 代码\r\n\r\n``` python\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head:\r\n            return None\r\n        length = 1\r\n\r\n        p_node = head\r\n        while p_node.next:\r\n            length += 1\r\n            p_node = p_node.next\r\n        \r\n        p_node.next = head\r\n        k %= length\r\n        for _ in range(length - k):\r\n            p_node = p_node.next\r\n        res = p_node.next\r\n        p_node.next = None\r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- **时间复杂度：** O(n)\r\n- **空间复杂度：** O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921795937","body":"# 两两交换链表中的节点\n\n## 思路\n\n递归：每次交换两个节点，并将后续节点做同样操作\n\n## 代码\n\n``` python \nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        new_head = head.next\n        head.next = self.swapPairs(new_head.next)\n        new_head.next = head\n        return new_head\n```\n\n## 复杂度分析\n\n- **时间复杂度：** O(n)\n- **空间复杂度：** O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922495952","body":"# 相交链表\n\n## 思路\n\n当链表遍历到末尾的时候，遍历到空节点；然后遍历到另一个链表。会有两种情况：\n\n1. 有交点，切巩固部分长度为`c`，则在遍历到第`a + b + 1 - c`的时候会结束\n2. 没有交点，在遍历到第`a + b + 2`的时候会结束，两指针同时为空\n\n## 代码 \n\n``` python \nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```\n\n## 复杂度分析\n\n- **时间复杂度：** O(m+n) \n- **空间复杂度：** O(m+n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Auto-SK":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916993544","body":"## 思路\n\n不断取 `num` 和 `k` 的最后一位相加，和为 `acc`，进位为 `carry`。使用队列来保存结果，保证先入先出。\n\n## 代码\n\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = collections.deque()\n        acc, carry = 0, 0\n        while num or k:\n            x = num.pop() if len(num) > 0 else 0\n            y = k % 10\n            k //= 10\n            acc = x + y + carry\n            carry = acc // 10\n            res.appendleft(acc % 10)\n        if carry > 0:\n            res.appendleft(1)\n        return list(res)\n```\n\n## 复杂度分析\n\n时间复杂度：O(max(n, log(k)))\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917374529","body":"## 思路\n\n两次遍历，第一次遍历从头到尾，`pre` 记录前面出现 `c` 的位置，第二次遍历从尾到头，`pre` 记录后面出现 `c` 的位置，取两次最小的距离。\n\n## 代码\n\n``` python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        pre = -float('inf')\n        for i in range(len(s)):\n            if s[i] == c:\n                pre = i\n            ans.append(i - pre)\n        pre = float('inf')\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                pre = i\n            ans[i] = min(ans[i], pre - i)\n        return ans\n```\n\n## 复杂度分析\n\n* 时间复杂度：O(n)\n\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917610899","body":"## 思路：增量数组\n\n用数组模拟栈，`stack` 用来存储栈的元素，`diff` 用来存储增量。当调用 `pop` 和 `increment` 方法时，改变 `diff` 数组的元素。\n\n* 当 `pop` 时，若操作后，栈不为空，`diff[-1]` 加上上一个 `diff[-1]`；\n* 当 `increment` 时，如果栈为空，不操作；若 k > 栈长，`diff[-1] += val`；若 k < 栈长，`diff[k - 1] += val`。\n\n## 代码\n\n``` python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.stack = []\n        self.diff = []\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n            self.diff.append(0)\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        s = self.stack.pop()\n        d = self.diff.pop()\n        if self.diff:\n            self.diff[-1] += d\n        return s + d\n    def increment(self, k: int, val: int) -> None:\n        if not self.diff:\n            return\n        if len(self.diff) < k:\n            self.diff[-1] += val\n        else:\n            self.diff[k - 1] += val\n```\n\n## 复杂度分析\n\n* 时间复杂度：O(1)\n* 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918330323","body":"## 思路：辅助栈法\n\n利用栈先入后出的特性，根据情况出入栈。\n\n## 代码\n\n``` python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], '', 0\n        for c in s:\n            if c == '[':\n                stack.append([res, multi])\n                res, multi = '', 0\n            elif c == ']':\n                last_res, cur_multi = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = 10 * multi + int(c)\n            else:\n                res += c\n        return res\n```\n\n## 复杂度分析\n\n* 时间复杂度：O(n)\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919145079","body":"## 思路\n\n两个栈，一个入栈，一个出栈，入栈负责读入，出栈出去的时候倒入入栈。\n\n## 代码\n\n``` python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack_in = []\n        self.stack_out = []\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack_in.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.stack_out:\n            return self.stack_out.pop()\n        while self.stack_in:\n            self.stack_out.append(self.stack_in.pop())\n        if self.stack_out:\n            return self.stack_out.pop()\n        return -1\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.stack_out:\n            return self.stack_out[-1]\n        while self.stack_in:\n            self.stack_out.append(self.stack_in.pop())\n        if self.stack_out:\n            return self.stack_out[-1]\n        return -1\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if self.stack_in or self.stack_out:\n            return False\n        return True\n```\n\n## 复杂度分析\n\n* 时间复杂度：O(1)\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920144249","body":"## 思路：辅助栈法\n\n单调栈递增，如果后面的元素小于前面的元素，则压到前面比它大的元素中。\n\n## 代码\n\n``` python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n```\n\n## 复杂度\n\n* 时间复杂度：O(n)\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920899606","body":"## 思路\n闭合为环，计算出链表的长度 `n`，并且找到最后一个节点 `cur`，闭合链表为环，在遍历 `n - k` 次找到断开点，断开点 `res = cur.next`，特殊地，`k == 0 or n == 0 or n == 1` 时，直接返回 `head`。\n\n## 代码\n``` python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head or not head.next:\n            return head\n        cur = head\n        n = 1\n        while cur.next:\n            n += 1\n            cur = cur.next\n        k = k % n\n        if k == 0:\n            return head\n        cur.next = head\n        for _ in range(n - k):\n            cur = cur.next\n        res = cur.next\n        cur.next = None\n        return res\n```\n\n## 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921904620","body":"## 思路\n递归，`head_next = head.next`，`head.next = swap(head_next.next)`，`head_next.next = head`，新的头节点为 `head_next`。\n\n## 代码\n``` python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        head_next = head.next\n        head.next = self.swapPairs(head_next.next)\n        head_next.next = head\n        return head_next\n```\n\n## 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922237829","body":"## 思路一：双指针\n通过快慢指针算出中点，中点左边为左子树，右边为右子树。\n\n## 代码\n``` python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        elif not head.next:\n            return TreeNode(head.val)\n        pre, slow, fast = None, head, head\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        root = TreeNode(slow.val)\n        pre.next = None\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n```\n\n## 复杂度\n* 时间复杂度：O(nlogn)\n* 空间复杂度：O(logn)，递归栈深度\n\n## 思路二：中序遍历\n构造出的二叉搜索树的中序遍历结果就是链表本身。\n\n## 代码\n``` python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getLength(head):\n            count = 0\n            while head:\n                count += 1\n                head = head.next\n            return count\n        def buildTree(left, right):\n            if left > right:\n                return\n            mid = ((right - left) >> 1) + left\n            root = TreeNode()\n            root.left = buildTree(left, mid - 1)\n            nonlocal head\n            root.val = head.val\n            head = head.next\n            root.right = buildTree(mid + 1, right)\n            return root\n        length = getLength(head)\n        return buildTree(0, length - 1)\n```\n\n## 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(logn)，递归栈深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922492431","body":"## 思路\n设链表 `A` 的长度为 `a + c`，链表 `B` 的长度为 `b + c`，`a` 为链表 `A` 不公共部分，`b` 为链表 `B` 不公共部分，`c` 为链表 `A`、`B` 的公共部分，将两个链表连起来，`A -> B` 和 `B -> A`，长度：`a + c + b + c = b + c + a + c`，若链表 `A`、`B` 相交，则 `a + c + b` 与 `b + c + a` 就会抵消，它们就会在 `c` 处相遇；若不相交，则 `c` 为 `None` ，则 `a + b = b + a`，它们各自移动到尾部循环结束，即返回 `None`。\n\n## 代码\n``` python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        ha, hb = headA, headB\n        while (ha or hb) and ha != hb:\n            ha = ha.next if ha else headB\n            hb = hb.next if hb else headA\n        return ha\n```\n\n## 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LOVEwitch":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916993689","body":"//javascript按位相加\nvar addToArrayForm = function(num, k) {\n  //split后每一项为字符串，相加时要注意转换为数字\n  let newNum = String(k).split('');\n  //进位的值\n  let jw = 0;\n  //保证num为长数组\n  if(num.length < newNum.length){\n      let temp = num;\n      num = newNum;\n      newNum = temp;\n  }\n  //长数组从尾到头遍历一遍\n  for(let i = num.length - 1, j = newNum.length - 1; i >= 0; i--){\n      //sum为相应位置上长短数组和进位的和\n      let sum = 0;\n      //短数组存在时，长短数组和进位相加，否则长数组和进位\n      if(j >= 0){\n          sum = Number(num[i]) + Number(newNum[j]) + jw; \n          j--;\n      } else {\n          sum = Number(num[i]) + jw; \n      }\n      //保留非进位的数字\n      num[i] = sum % 10;\n      //判断是否进位，并存储此次循环的进位\n      if( sum >= 10){\n          jw = Math.floor(sum / 10);\n      } else {\n          jw = 0;\n      } \n      \n  }\n  //循环完后还有进位，存储到数组头部\n  if(jw){\n    num.unshift(jw)\n  }\n  return num;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917369964","body":"//两次遍历法，第一次从左向右，当前元素距离左边特定字符的位置，第二次，从右向左，当前元素距离右侧元素的距离，二者取最小\n var shortestToChar = function(s, c) {\n  const N = s.length;\n  let res = new Array(N), lastIndex = -N;\n\n  for(let i = 0; i < N; i++) {\n      if(s[i] === c) {\n          lastIndex = i;\n          res[i] = 0;\n      }\n      res[i] = i - lastIndex;\n  }\n  for(let i = N-1; i >= 0; i--){\n    if(s[i] === c) {\n      lastIndex = i;\n      res[i] = 0;\n    }\n    res[i] = Math.min(Math.abs(lastIndex - i), res[i])\n  }\n  return res;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917788258","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.length ? this.stack.pop() : -1;\n};\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  let len = Math.min(k, this.stack.length)\n  for(let i = 0; i < len; i++){\n    this.stack[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917928795","body":"//递归\nvar decodeString = function(s) {\n  return recursion(s, 0);\n};\nvar recursion = function(s, i){\n  let res = '', num = '';\n  while(i < s.length) {\n    if(/[0-9]/.test(s[i])) {\n      num += s[i];\n      i++;\n    } else if(/[a-z]/i.test(s[i])) {\n      res += s[i];\n      i++;\n    } else if(s[i] === '[') {\n      const [pattern, nextIndex] = recursion(s, i+1)\n      res += pattern.repeat(Number(num));\n      num = '';\n      i = nextIndex;\n      continue;\n    } else if(s[i] === ']') {\n      return [res, i+1]\n    }\n  }\n  return res;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918747278","body":"/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n  this.stack = [];\n  this.backStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.stack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  \n  if(!this.backStack.length){\n    this.in2out()\n  }\n  return this.backStack.pop()\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if(!this.backStack.length){\n    this.in2out()\n  }\n  return this.backStack[this.backStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.stack.length === 0 && this.backStack.length == 0;\n};\n\nMyQueue.prototype.in2out = function() {\n  while(this.stack.length){\n    this.backStack.push(this.stack.pop());\n  }\n};\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920102901","body":"var maxChunksToSorted = function(arr) {\n    let stack = [];\n    for (let i of arr) {\n        if(stack.length === 0 ||stack[stack.length -1] <= i){\n            stack.push(i);\n        } else {\n            const temp = stack.pop()\n            while (stack[stack.length -1] >i){\n                stack.pop()\n            }\n            stack.push(temp)\n        }\n    }\n    return stack.length\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920996961","body":"var rotateRight = function(head, k) {\n    if( k == 0 || !head || !head.next) {\n        return head;\n    }\n    let fast = head, len = 1;\n    while(fast.next){\n        fast = fast.next;\n        len++;\n    }\n    if(len === k){\n        return head;\n    }\n    fast.next = head;\n    let step = len - k % len;\n    while(step){\n        fast = fast.next;\n        step--;\n    }\n    const newHead = fast.next;\n    fast.next = null;\n    return newHead;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921865073","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    const newHead = new ListNode(0);\n    newHead.next = head;\n    let temp = newHead;\n    while (temp.next !== null && temp.next.next !== null) {\n        const slowTemp = temp.next;\n        const fastTemp = temp.next.next;\n        temp.next = fastTemp;\n        slowTemp.next = fastTemp.next;\n        fastTemp.next = slowTemp;\n        temp = slowTemp;\n        \n    }\n    return newHead.next;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922329780","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if(head == null) return null;\n    let fast = head, slow = head, pre;\n    while(fast && fast.next) {\n        pre = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    const root = new TreeNode(slow.val);\n    if(pre != null) {\n        pre.next = null;\n        root.left = sortedListToBST(head);\n    }\n    root.right = sortedListToBST(slow.next);\n    return root;\n};\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922493610","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    if(headA == null || headB == null) return null;\n    const newHeadA = headA, newHeadB = headB;\n    while(headA!== headB){\n        if(headA === null){\n            headA = newHeadB;\n            \n        } else {\n            headA = headA.next\n        }\n        if(headB === null){\n            headB = newHeadA;\n        } else {\n            headB = headB.next\n        }\n    }\n    return headA;\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MusicOfWind":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916994086","body":"思路:逐位相加\r\n让我们逐位将数字加在一起。例如计算 123+912123+912，我们从低位到高位依次计算 3+23+2、2+12+1 和 1+91+9。任何时候，若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中，所以最终结果为 10351035。\r\n\r\n代码:\r\nclass Solution {\r\npublic List addToArrayForm(int[] num, int k) {\r\nLinkedList ans = new LinkedList<>();\r\nint temp=0;\r\nfor (int i = num.length-1; i >=0 ; i--) {\r\ntemp = k%10;\r\nk/=10;\r\nif (temp+num[i]>=10){\r\nk++;\r\nans.addFirst((temp+num[i])%10);\r\n}else {\r\nans.addFirst(temp+num[i]);\r\n}\r\n//处理特殊情况\r\nif (i==0){\r\nwhile (k>0){\r\ntemp = k%10;\r\nk/=10;\r\nans.addFirst(temp);\r\n}\r\n}\r\n}\r\nreturn ans;\r\n}\r\n}\r\n\r\n复杂度:\r\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\r\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917401544","body":"思路:\r\n对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值\r\n\r\n代码:\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        ArrayList<Integer> arr = new ArrayList<>();\r\n        int[] ret = new int[s.length()];\r\n        int p = 0;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) arr.add(i);\r\n        }\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\r\n            ret[i] = Math.abs(arr.get(p) - i);\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\n复杂分析度:\r\n时间复杂度：O(N)，其中 N 是 S 的长度，我们需要遍历字符串两次。\r\n空间复杂度：O(N)，ans 数组的大小。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingcai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916996704","body":"##  思路\n\nnum数组从后往前遍历， k值从个位开始遍历。 使用add来记录是否有进位\n\n## 代码\n```cpp\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        std::vector<int> result;\n        //int devide = 10;\n        int num_index = num.size() - 1;\n        int add = 0; // 进位标志\n        int value = 0;\n        while (num_index >= 0 or k > 0) {\n            // 三种情况下 都记着+add\n            if(num_index >= 0 && k > 0) { // num和k都有值可用\n                value = num[num_index] + k % 10 + add;\n            } else if (num_index >= 0) { // k已经用完，num还没有遍历完\n                value = num[num_index] + add;\n            } else {\n                value = k % 10 +add; // num已经遍历完， k还没有用完\n            }\n\n            int real_value = value % 10;  // %10 取个位置 放入到result\n            add = value / 10; // 是否有进位\n            result.push_back(real_value);\n            k = k / 10; // 将k去掉个位，十位变成个位\n            num_index--; // num_index往前移动\n        }\n        if (add > 0) {\n            result.push_back(add); //压入最后可能存在的进位\n        }\n        reverse(result.begin(), result.end()); // 翻转result\n        return result;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度  O(n) , 必须遍历数组且会将结果数组翻转\n空间复杂度 O(n) 用来保存结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917415390","body":"## 思路\n\n最先开始肯定是考虑 固定一个元素，然后去遍历整个数组，找到最小位置。对于每个元素找一个 时间复杂度是O(n) ，所有找下来就是O(n*n) 。需要找到更快速的方法。\n在解题中想到的方法是：\n1）先遍历一遍数组，找到所有存在c的位置，将位置记录在一个数组c_positions中。 时间复杂度O(n), 空间复杂度O(n);\n2）然后再遍历这个数组，初始化两个变量left,right来记录数组c_positions，而它们保存的值则代表在c_positon[left] 或者 c_positon[right]位置上保存有字符c。 在循环中，有一个if, else; 如果有遍历的位置==c_positon[right] ，则我们本身就在c的位置；那么会2.1）将位置放入到results中；2.2）right赋值给left; 2.3)如果right+1没有超过c_positon大小上界，则++； else中，则是直接和c_position[left] 、c_postion[right]做比较，找到相对较小的那个。  这一步时间复杂度为O(n), 空间复杂度O(n) 用来保存结果。\n\n## 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        std::vector<int> c_positions; // 记录了char c出现的位置\n        for (int i = 0; i < s.length(); ++i) {\n            if (s[i] == c) { //如果为c, 则记录c出现的位置\n                c_positions.push_back(i);\n            }\n        }\n        vector<int> results(0, s.length()); //开辟空间 用来保存结果\n        // 定义left 和 right， 代表当前位置最靠近左侧和最靠近右侧为c的位置（位置指的是在c_position的下标）\n        int left_c_index = 0;\n        int right_c_index = 0;\n        for (int i = 0; i < s.length(); ++i) { // 开始遍历\n            if (i == c_positions[right_c_index]) {// 如果i和c_positions[xx]相等，则代表这个位置本身保存的就是c\n                results.push_back(0);\n                left_c_index = right_c_index; // 将right下标赋值给left\n                if (right_c_index + 1 < c_positions.size()) {//如果还存在right，则将ringth+1\n                    right_c_index += 1;\n                    } \n                } else { //否则 就直接将该下标和c_positions保存的位置相比较\n                    int dis = min(abs(i - c_positions[right_c_index]), abs(i - c_positions[left_c_index]));\n                    results.push_back(dis);\n            }\n        }\n        return results;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度 O(n)\n空间复杂度 O(n)\n\n## 思考\n\n看了题解后，比较理想而且好理解的是左右遍历；1） 先从左到右遍历一遍数组，记录每个元素左侧出现c的最靠近的位置；2） 再从右到左遍历一遍数组，记录每个元素右侧出现c的最靠近的位置；3）然后左右取最小，则是该元素距离c最小的距离。\n\n碰到这种找距离，需要瞻左顾右的题目，需要想到从左到右，从右到左两次遍历，分别记录，再根据题目所给计算想要的结果。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917564334","body":"### 解题思路\n这道题主要需要思考的是在increment时是否可以优化，使得inc不用是O(n), 以此来降低复杂度\n\n1） 比较直观的思路时， 遇到Inc操作时，按照参数逐一遍历栈中元素然后加上val, 此时操作是O(MaxK) 复杂度，同时由于需要遍历栈， 栈需要使用vector来保存，而不能使用原始的std:stack;\n\n2）还有一个思路时，由于pop操作是只针对栈顶元素的，那么我们记录inc时，也只需要记录该位置上累计的加操作，当这个位置的元素弹出时，将这个位置的inc累计值赋值给前一个元素的inc , 以此来达到各个操作都是O(1) 时间复杂度。 不过需要有一个数组来记录各个位置的累加inc值， 空间复杂度则是O(n)\n\n\n### 代码\n\n```cpp\nclass CustomStack {\n\nprivate:\n    vector<int> _stack;\n    vector<int> _add;\n    int _maxsize;\n    int _now_size;\npublic:\n    CustomStack(int maxSize) {\n        _stack.resize(maxSize, 0);\n        _add.resize(maxSize); // 用于记录在每个位置上inc的值（如果inc多次，会累加）\n        _maxsize = maxSize;\n        _now_size = 0;\n    }\n    \n    void push(int x) {\n        //std::cout << \" enter push \" << std::endl;\n        if (_now_size < _maxsize) {\n            std::cout << \"push now size : \" << _now_size << std::endl;\n            _stack[_now_size] = x;\n            _now_size++;\n        }\n\n    }\n    \n\n    int pop() {\n        //std::cout << \" enter pop\" << std::endl;\n\n        if (_now_size > 0) {\n            int pop_value = _stack[_now_size - 1] + _add[_now_size - 1];\n            if (_now_size > 1) {\n                _add[_now_size-2] += _add[_now_size-1]; // 将后一个inc的值叠加到这个位置上\n            }\n            _add[_now_size - 1] = 0; // 归零操作，防止push的之后inc计算有原有数据\n            _now_size--;\n            return pop_value;\n        }\n        return -1;\n    }\n\n    void increment(int k, int val) {\n        //std::cout << \" enter inc\" << std::endl;\n        int inc_num = (k > _now_size) ? _now_size : k;\n        if (inc_num > 0) {\n            _add[inc_num - 1] += val;\n        }\n       \n    }\n\n    int pop_old() {\n        std::cout << \" enter pop\" << std::endl;\n        if (_now_size > 0) {\n            std::cout << \"pop now size : \" << _now_size << std::endl;\n            int pop_value = _stack[_now_size-1];\n            _now_size--;\n            return pop_value;\n        } \n        return -1;\n    }\n    \n    void increment_old(int k, int val) {\n        std::cout << \" enter inc\" << std::endl;\n\n        int inc_num = (k > _now_size) ? _now_size : k;\n        std::cout << \"inc_num : \" << inc_num << \" k : \" << k << \" _now_size: \" << _now_size <<  std::endl;\n        for (int i = 0; i < inc_num; ++i) {\n            _stack[i] += val;\n            std::cout << \" _stack : \" << _stack[i] << std::endl;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n### 复杂度\npop push increment 三个操作时间复杂度都为O(1) 空间复杂度为 O(n) , 需要记录累加值\n\n### 思考\n对于栈的操作，我们都是在栈顶进行操作，不会像数组下标直接取很多。 因此在记录元素状态时，可以使用一个数组来记录，弹出时改变这个数组状态（累加 累减），而不需要每次操作都遍历一次全部的栈元素。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918273760","body":"## 思路\n\n使用栈思想 保存number \n\n## 代码\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        // 存放[之前的内容字符串内容\n        stack<string> chars;\n        //存放[之前的数字内容\n        stack<int> numbers;\n        string res = \"\";\n        int num = 0;\n        for (char one : s) {\n            if (isdigit(one)) {\n                num = num * 10 + one - '0';\n            } else if (isalpha(one)) {\n                res.push_back(one);\n            } else if (one == '['){\n                numbers.push(num);\n                num = 0;\n                chars.push(res);\n                res = \"\";\n            } else if (one == ']') {\n                string tmp = res;\n                for (int i = 0; i < numbers.top() - 1; ++i) {\n                    res += tmp;\n                }\n                // 这里需要注意顺序\n                res = chars.top() + res;\n                chars.pop();numbers.pop();\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度 O(n) 只需要遍历一遍\n空间复杂度 O(n) 保存numbers 或者字符串","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919216226","body":"## 思路\n\n使用两个栈模拟队列， 不管是push pop 还是 peek， 如果某个栈中存在元素，那么就需要倒到另外一个，具体条件参考代码\n\n## 代码\n\n```cpp\nclass MyQueue {\n// 类中定义master和slave, push总是放入到master, pop总是从slave中pop\n// 所有元素要么是在master中，那么在slave, 不会存在一部分到master，一部分在slave\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        while (!slave_stack.empty()) { // 如果slave队列不为空，将slave全部移入master中，然后再push\n            master_stack.push(slave_stack.top());\n            slave_stack.pop();\n        }\n        master_stack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        while (!master_stack.empty()) { //cy:如果master不为空 导入到slave中 取top\n            slave_stack.push(master_stack.top());\n            master_stack.pop();\n        }\n        int peak_value = slave_stack.top();\n        slave_stack.pop();\n        return peak_value;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        while (!master_stack.empty()) { //如果master有元素 都导入到slave 取top\n            slave_stack.push(master_stack.top());\n            master_stack.pop();\n        }\n        return slave_stack.top();\n\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return master_stack.empty() && slave_stack.empty();\n    }\n   \n    private:\n        std::stack<int> master_stack;\n        std::stack<int> slave_stack; \n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n## 复杂度\n\n时间复杂度 O(n)\n空间复杂度 O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921007716","body":"## 思路\n\n1）  遍历一遍链表，获取长度，以及最后一个node的指针 last；\n\n2）  计算移动k步之后，最后一个node应该是在哪个位置。不断移动，移动到这个位置pos。将pos->next作为新开头(返回的result), nullptr赋值给pos->next.， 传进来的start赋值给last->next\n\n## 代码\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* node = head;\n        ListNode* now_node = node; // 记录遍历位置\n        int list_length = 0;\n        if (node == nullptr or node->next == nullptr or k == 0) {\n            return node;\n        }\n\n        // 计算链表长度并找到最后一个node的位置\n        while (node != nullptr and node->next != nullptr) {\n            list_length++;\n            node = node->next;\n        }\n        ListNode* last_node = node;\n        list_length += 1; // 加上最后一个元素\n        if (k % list_length == 0) {\n            return head; // 无需旋转\n        }\n\n        int step = list_length - (k % list_length) - 1; // 从头开始走几步应该停止\n        while (step > 0) {\n            now_node = now_node->next;\n            step--;\n        }\n        ListNode* result = now_node->next;\n        now_node->next = nullptr; // 当前节点为链表尾巴\n        last_node->next = head; // 原链表的尾巴指向开头\n        return result;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度， 相当于最多遍历两边 O(n)\n空间复杂度 O(1)\n\n## other\n\n上面的代码是直接算了应该往前移动几步，判断时比较复杂。 在提供的参考答案中，是提供了slow和fast指针， fast先走k步，然后slow再走，之后进行赋值。 因为按照题目的意思，其实只要我们找到的倒数第k个节点，就可以快速赋值翻转了","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921869485","body":"## 思路\n采用了遍历的思路，为了交换方便以及记录位置，有四个节点需要记录\nfirst: 两个交换节点中的第一个；\nsecond: 两个交换节点中的第二个；\nbefore: 第一个节点的前一个节点\nafter: 第二个节点的后一个节点；\n\n为了循环不需要考虑开头，在开头位置创造虚拟节点dummy. \n然后从开始两两交换，需要注意的是结束的条件，在代码中已经说明\n\n## 代码\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr or head->next == nullptr) return head;\n        ListNode* dummy = new ListNode(); // 添加一个dummy头结点，方便程序编写\n        dummy->next = head;\n\n        ListNode* result = head->next;\n        ListNode* first = head;\n        ListNode* second = head->next;\n        ListNode* before =dummy; // first的前一个节点\n        ListNode* after = second->next; // second的后一个节点\n\n        while (second != nullptr) {\n            // 交换\n            first->next = after;\n            second->next = first;\n            before->next = second;\n\n           // 当前两个交换完成后，如果after为空（代表当前交换的为最后两个） 或者after->next为空（代表为个数，最后还剩一个），则break 退出循环\n            if (after == nullptr or after->next == nullptr) break;\n             // 向后移动\n            before = first; // 交换完一次后，first在second后边，first所在位置为下一次交换before的位置\n            first = first->next;\n            second = first->next; //second为first后边的元素\n            after = second->next; // after为second后边的元素\n        }\n        return result;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度 O(n)\n空间复杂度O(1)   只需要声明一些变量","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922489793","body":"## 思路\n\n求出来 两个链表的差值，然后让长的链表先走n步， 再找到相交的结点\n\n## 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (headA == nullptr or headB == nullptr) return nullptr;\n        ListNode* first = headA;\n        ListNode* second = headB;\n \n\n        // 找到两个链表的差值\n        int len_a = 0;\n        int len_b = 0;\n        while (first->next != nullptr) {\n            len_a++;\n            first = first->next;\n        }\n        len_a++; // 最后一个节点\n\n        while (second->next != nullptr) {\n            len_b++;\n            second = second->next;\n        }\n        len_b++;\n\n        if (first != second) {\n            return nullptr; // 最后一个节点都不相同，肯定不相等；\n        }\n\n        int diff = len_a -len_b; // 找到差值后，让长的链表先走diff步\n        if (diff <= 0) {\n            diff = abs(diff);\n            while (diff > 0) {\n                headB = headB->next;\n                diff --;\n            }\n        } else {\n            while (diff > 0) {\n                headA = headA->next;\n                diff --;\n            }\n        }\n        while (headA != nullptr and headB != nullptr) { // 找出来相同的节点\n            if (headA == headB) {\n                return headA;\n            }\n            headA = headA->next;\n            headB = headB->next;\n        }\n        return nullptr;\n    }\n};\n```\n\n## 复杂度\n\n空间复杂度O(1)\n时间复杂度O(n)\n\nps...  没想到大家代码这么少。。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JunQu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916996830","body":"## 思路分析\r\n首先考虑最常见的情况，第二种输入示例2里面的情况，对位相加。\r\n然后考虑到进位，增加一个参数`n`表示进位，则`n`的值只能是`0`或者`1`。\r\n最后一个边缘情况是数字的长度大于数组的长度，这样首位前面补`0`。\r\n\r\n## 代码实现\r\n```js\r\nconst addToArrayForm = function(num, k) {\r\n  let n = 0;\r\n  let len = k.toString().length;\r\n  while (len > num.length) {\r\n    num.unshift(0);\r\n  }\r\n  for (let i = num.length - 1; i >= 0; i--) {\r\n    const digit = k % 10;\r\n    const sum = num[i] + digit + n;\r\n    n = sum > 9 ? 1 : 0;\r\n    num[i] = sum % 10;\r\n    k = ~~(k / 10);\r\n  }\r\n  if (n) {\r\n    num.unshift(n);\r\n  }\r\n  return num;\r\n};\r\n```` \r\n失误点：没有一次提交过，是因为我没有考虑数字长度大于数组长度。\r\n\r\n## 复杂度分析\r\nfor 循环的时间复杂度为 O(n)，理论上 unshift 操作的复杂度也是 O(n),但是考虑到 k 的长度是5以内，所以整体的时间复杂度还是 O(n)。\r\n\r\n空间复杂度取决于 K 的长度，根据条件 K 的长度小于5，那么最大空间复杂度就是 5.\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917934297","body":"## 思路\r\n主要是用栈的思维，先进后出。遇到`[`则入栈，遇到`]`则出栈，再注意数字部分就可以。\r\n## 代码\r\n```js\r\nconst decodeString = (str) => {\r\n  const strStack = []; // 非最小重复部分则入栈\r\n  const numStack = []; // 保存数字部分\r\n  let resultStr = ''; // 保存每一次的重复部分\r\n  let num = 0; // 保存数字\r\n  for (const letter of str) {\r\n    switch (letter) {\r\n      case '[':\r\n        // 全部入栈\r\n        strStack.push(resultStr);\r\n        numStack.push(num);\r\n        resultStr = '';\r\n        num = 0;\r\n        break;\r\n      case ']':\r\n        // 出栈时需要注意拼接\r\n        resultStr = strStack.pop() + resultStr.repeat(numStack.pop());\r\n        break;\r\n      default:\r\n        // 需要特殊处理一下数字部分\r\n        if (parseInt(letter, 10) >= 0) {\r\n          num = num * 10 + parseInt(letter, 10);\r\n        } else {\r\n          resultStr += letter;\r\n        }\r\n    }\r\n  }\r\n  return resultStr;\r\n};\r\n```\r\n\r\n## 复杂度\r\n令 k 为字符串的最大嵌套深度的数字至它外层所有数字部分之积， 则 k 最小位1。\r\n时间复杂度: 最小时间复杂度是O(n)，最大时间复杂度是O(n\\*K)，最复杂情形是：`100[2[3[4[5[b]]]]]`\r\n空间复杂度:  字符串必须是新字符，所以最小空间是O(n)，同样取决于K，最大空间是O(n\\*k)\r\nps: 我不懂复杂度计算，以上是我瞎猜的，总觉得repeat会消耗空间和时间。\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919288812","body":"## js 通过双栈实现队列\r\n## 思路\r\n一开始使用一个栈，发现非常不便。思考了二十分钟后，尝试失败了几次，参考了别人的双栈，于是突然开朗了，这样的复杂度也能得到保障。\r\n## 代码实现\r\n```js\r\nclass MyQueue {\r\n  inStack = [];\r\n  outStack = [];\r\n\r\n  push(...elements) {\r\n    this.inStack.push(...elements);\r\n  }\r\n\r\n  pop() {\r\n    if (!this.outStack.length) {\r\n      this.inToOut();\r\n    }\r\n    return this.outStack.pop();\r\n  }\r\n\r\n  peek() {\r\n    if (!this.outStack.length) {\r\n      this.inToOut();\r\n    }\r\n    return this.outStack[this.outStack.length - 1];\r\n  }\r\n\r\n  inToOut() {\r\n    while (this.inStack.length) {\r\n      this.outStack.push(this.inStack.pop());\r\n    }\r\n  }\r\n\r\n  empty() {\r\n    return !this.outStack.length && !this.inStack.length;\r\n  }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度 ：  入队列是 O(1),主要是`peek` 和 `pop`方法复杂度会有O(n)\r\n空间复杂度: O(n)，因为需要两个栈互相转化，一个栈的整体移动到另一栈。\r\n\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922492915","body":"## 思路 \r\n不同的长度的绳子找相同的点，那就把两段绳子全部走一遍，也就是跑完A再跑B，这样相同的路程必然相交在相同的点。题目由于之前不久做过，所以就直接过了。\r\n这是剑指offer上的原题，解法很多，我一开始就是树上说的先把他们对齐，让长的先走几步。不过我后来看到优秀的跑两次的解法后，我感觉到我不适合解题。\r\n\r\n## 代码\r\n\r\n```js\r\nconst getIntersectionNode = (headA, headB) => {\r\n    let firstA = headA;\r\n    let firstB = headB;\r\n    while(firstA !== firstB) {\r\n        firstA = firstA ? firstA.next:headB;\r\n        firstB = firstB ? firstB.next:headA;\r\n    }\r\n    return firstA;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)，这里复杂度应当是 `m+n` （m和n分别是两条链表的长度）因为最多跑两次，在两条链表长度相同的情况下只跑一次就是 n。\r\n空间复杂度: O(1)，仅仅开辟两个常量的空间。\r\n\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuetong3yu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916997256","body":"### JS解法\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n    const ret = [];\r\n    let i = num.length - 1, carry = 0;\r\n    while (i >= 0 || k != 0) {\r\n        let x = i >= 0 ? num[i] : 0;\r\n        let y = k !== 0 ? k % 10 : 0;\r\n\r\n        const sum = x + y + carry;\r\n\r\n        ret.push(sum % 10);\r\n        carry = Math.floor(sum / 10);\r\n\r\n        i--;\r\n        k = Math.floor(k / 10);\r\n    }\r\n    if (carry) {\r\n        ret.push(carry);\r\n    }\r\n    return ret.reverse();\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657176","body":"思路\r\n用数组模拟\r\n\r\n代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.stack.length >= this.maxSize) {\r\n        return;\r\n    }\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    return this.stack.length > 0 ? this.stack.pop() : -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    let length = Math.min(k, this.stack.length);\r\n    for (let i = 0; i < length; i++) {\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n```\r\n\r\n时间复杂度：O(1)push pop, O(n)inc\r\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kbfx1234":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916998377","body":"#### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n``` cpp\n// 9-10 cpp \nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int i = num.size() - 1;\n        int up = 0;\n        vector<int> ans;\n        while (i >= 0 || k != 0) {\n            int x = i >= 0 ? num[i] : 0;\n            int y = k != 0 ? k%10 : 0;\n\n            int sum = x + y + up;\n            ans.push_back(sum % 10);\n            up = sum / 10;\n\n            i--;\n            k = k / 10;\n        }\n        if (up) ans.push_back(up);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917380020","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n``` cpp\n// 9-11 cpp \nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> record;\n        vector<int> ans(len);\n        for (int i = 0; i < len; i++) {\n            if (s[i] == c) record.push_back(i);\n        }\n        \n        for (int i = 0; i < len; i++) {\n            int temp = INT_MAX;\n            for (int k = 0; k < record.size(); k++) {\n                temp = min(temp, abs(i - record[k]));\n            }\n            ans[i] = temp;\n        }\n        return ans;\n    }\n};\n```\n\n **时间复杂度：** O( n^2 )\n\n **空间复杂度：** O( k )","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918116870","body":"#### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n``` cpp\n// 9-13 cpp 栈\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> nums;\n        stack<string> let;\n        int num = 0;\n        string res = \"\";\n        for (auto i : s) {\n            if (i >= '0' && i <= '9') {\n              // 注意多位数\n                num = num * 10 + i - '0';\n            }\n            else if (i == '[') {\n                nums.push(num);\n                num = 0;\n                let.push(res);\n                res = \"\";\n            }\n            else if (i == ']') {\n                int k = nums.top();\n                nums.pop();\n                string temp = let.top();\n                for (int i = 0; i < k; i++) {\n                    temp += res;\n                }\n                res = temp;\n                let.pop();\n            }\n            else {\n                res += i;\n            }\n        }\n        return res;\n    }\n};\n```\n\n**时间复杂度：**  O(n)\n\n**空间复杂度：** O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922459892","body":"#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n``` cpp\n// cpp 9-19\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* curA = headA;\n        ListNode* curB = headB;\n\n        int lenA = 0;\n        int lenB = 0;\n\n        while (curA != NULL) {\n            lenA++;\n            curA = curA->next;\n        }\n        while (curB != NULL) {\n            lenB++;\n            curB = curB->next;\n        }\n\n        curA = headA;\n        curB = headB;\n        if (lenB > lenA) {\n            swap(curB, curA);\n            swap(lenB, lenA);\n        }\n        int gap = lenA - lenB;\n        while (gap--) {\n            curA = curA->next;\n        }\n        while (curA != NULL) {\n            if (curA == curB) {\n                return curA;\n            }\n            curA = curA->next;\n            curB = curB->next;\n        }\n        return NULL;\n    }\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crypteee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916998496","body":"## 思路\r\n\r\n- 原地修改数组，无需开辟额外的空间\r\n- 由于加法从右到左逐位计算，自然地倒序遍历数组\r\n- 模运算 `%` 可拿到每次计算结果的末位数，然后把该末位数原地更新到原数组\r\n- 取整的除运算 `/` 可拿到去掉末位数的剩余数字，这些数字即下一轮要继续计算的数字，直到剩余的数字归零\r\n- 如果数组已经完全计算完毕，但是还有剩余的数字要计算，则对原数组的头部补 0，然后继续运算剩余的数字，直到归零\r\n\r\n## 实现\r\n\r\n语言：TypeScript\r\n\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  let restK = k;\r\n  let i = num.length - 1;\r\n\r\n  while (i >= 0) {\r\n    const curSum = num[i] + restK;\r\n    num[i] = curSum % 10;\r\n    restK = ~~(curSum / 10);\r\n\r\n    if (i === 0 && restK !== 0) {\r\n      // 原数组用完了，但还存留未计算的数，那么就在数组首部补零\r\n      num.unshift(0);\r\n    } else {\r\n      // 原数组没用完，那就继续向左移动\r\n      i = i - 1;\r\n    }\r\n  }\r\n\r\n  return num;\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：每个元素只遍历一次，所以是 O(N)\r\n- 空间复杂度：由于是原地操作数组，所以是 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917445030","body":"## 思路\r\n\r\n- 因为要最小值，所以用一个大数来初始化结果数组 D，由于距离最大值为首部到尾部的距离即 `(N - 1) - 0 < N`，所以可直接用 `N` 作为大数\r\n- 先顺序扫一遍，计算出 `C` 右侧的字符 `S[i]` 距离 R = `iS - iC`，期间找到 `C` 才更新结果数组 `D[i] = min(D[i], R)`\r\n- 再逆序扫一遍，计算出 `C` 左侧的字符 `S[i]` 距离 L = `iC - iS` = `| iS - iC |`，期间找到 `C` 才更新结果数组  `D[i] = min(D[i], L)`\r\n\r\n## 实现\r\n\r\n开发语言：TypeScript\r\n\r\n```ts\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n  const maxLen = s.length;\r\n  const dist = new Array(s.length).fill(maxLen);\r\n\r\n  let iC = null;\r\n  for (let i = 0; i < s.length; i++) {\r\n    // 顺序扫一遍，计算出 `C` 右侧的字符 `S[i]` 距离 R\r\n    minDistance(i);\r\n  }\r\n\r\n  iC = null;\r\n  for (let j = s.length - 1; j >= 0; j--) {\r\n    // 逆序扫一遍，计算出 `C` 左侧的字符 `S[i]` 距离 L\r\n    minDistance(j);\r\n  }\r\n  \r\n  function minDistance(iS: number) {\r\n    if (s[iS] === c) {\r\n      iC = iS;\r\n    }\r\n\r\n    dist[iS] = Math.min(\r\n      dist[iS],\r\n      // 没有找到 C 之前，都用一个大数补位\r\n      iC === null ? maxLen : Math.abs(iS - iC)\r\n    );\r\n  }\r\n\r\n  return dist;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：遍历两次数组，每次遍历，一个元素只被访问一次，所以是 O(N)\r\n- 空间复杂度：需要创建一个与字符串 `S` 长度相同的数组空间来存储结果，所以是 O(N)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662016","body":"## 思路\r\n\r\n- 栈的进出可以通过数组的 push 和 pop 实现\r\n- inc 操作要求可以通过遍历更新栈的值，但时间复杂度为 O(N)\r\n- 通过使用 Map 对象记录 inc 操作（第 K 个元素及其 inc 值），在 pop 时才对数值进行计算，把时间复杂度降低到 O(1)\r\n- 通过 Map 对象，每次 pop 时，需要把第 K 个元素的记录删除，同时将 inc 值累加到下一个元素即第 k - 1 个元素的 inc 记录去，这样才能满足题目要求「栈底的 K 个元素都增加 val」而不是「第 K 个元素增加 val」\r\n\r\n## 实现\r\n\r\n开发语言：TypeScript\r\n\r\n```ts\r\nclass CustomStack {\r\n    /**\r\n     * 记录栈的长度\r\n     */\r\n    private length = 0;\r\n    /**\r\n     * 记录栈的数值\r\n     */\r\n    private stack = [];\r\n    /**\r\n     * 记录栈底的第 k 个元素的值要增加的 val 值\r\n     * 该记录可以使 inc 操作的时间复杂度降低到 O(1)\r\n     */\r\n    private incMap = new Map();\r\n\r\n    constructor(private maxSize: number) {\r\n    }\r\n\r\n    push(x: number): void {\r\n      // 栈在增长到 maxSize 之后则不支持 push 操作\r\n      if (this.length === this.maxSize) {\r\n        return;\r\n      }\r\n      this.length += 1;\r\n      this.stack.push(x);\r\n    }\r\n\r\n    pop(): number {\r\n      if (this.length === 0) {\r\n        return -1;\r\n      }\r\n\r\n      // 当前第 k 个元素在 pop 之前被要求增加的值\r\n      const incVal = this.incMap.get(this.length) ?? 0;\r\n      // 由于元素被 pop 出去，所以增加之后无需保留，可以进行清除已节省空间\r\n      this.incMap.delete(this.length);\r\n      // 更新栈的长度\r\n      this.length -= 1;\r\n      if (this.length >= 0) {\r\n        // 此时要更新下一个元素即 k - 1 被要求增加的值\r\n        // 同时需要累加第 k 个元素被要求增加的值\r\n        // 因为题意要求增加的值是对栈底 0 到 k - 1 个元素进行累加\r\n        this.incMap.set(\r\n          this.length,\r\n          (this.incMap.get(this.length) ?? 0) + incVal\r\n        );\r\n      }\r\n\r\n      return this.stack.pop() + incVal;\r\n    }\r\n\r\n    increment(k: number, val: number): void {\r\n      // 如果栈中元素总数小于 k ，则栈中的所有元素都增加 val\r\n      const incK = Math.min(k, this.length);\r\n      this.incMap.set(incK, (this.incMap.get(incK) ?? 0) + val);\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：每个操作都是 O(1) 操作，所以复杂度为 O(1)\r\n- 空间复杂度：开辟了两个存储空间，一个存储栈值的数组，空间为 O(maxSize)，另一个是存储 inc 操作的 Map 对象，空间为 O(k 不等的 inc 调用的次数)，合并之后，空间复杂度为 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918335964","body":"## 实现\r\n\r\n语言：TypeScript\r\n\r\n```ts\r\nconst REGEX_TOKEN_NUMBER = /\\d/;\r\nconst REGEX_TOKEN_STRING = /[a-zA-Z]/;\r\nconst REGEX_TOKEN_PUSH = /\\[/;\r\nconst REGEX_TOKEN_POP = /\\]/;\r\n\r\nfunction decodeString(s: string): string {\r\n  const tokenStack = [];\r\n\r\n  for (const c of s) {\r\n    if (REGEX_TOKEN_NUMBER.test(c)) {\r\n      tokenStack.push(Number(c));\r\n    } else if (REGEX_TOKEN_STRING.test(c) || REGEX_TOKEN_PUSH.test(c)) {\r\n      tokenStack.push(c);\r\n    } else if (REGEX_TOKEN_POP.test(c)) {\r\n      let ch = tokenStack.pop();\r\n      const chars = [];\r\n      while (!REGEX_TOKEN_PUSH.test(ch)) {\r\n        chars.push(ch);\r\n        ch = tokenStack.pop();\r\n      }\r\n      \r\n      let times = tokenStack.pop();\r\n      const str = chars.reverse().join('');\r\n      let decoded = [];\r\n      while (times > 0) {\r\n        decoded.push(str);\r\n        times--;\r\n      }\r\n      tokenStack.push(decoded.join(''));\r\n    }\r\n  }\r\n\r\n  return tokenStack.reverse().join('');\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzcyes":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917000501","body":"方法一：末尾相加\r\n\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n const sum:number[] = [];\r\n    let i = num.length - 1;\r\n    while(i >= 0 || k > 0){\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        sum.push(k % 10);   //  把k的末位push进数组\r\n        i--;\r\n        k = Math.floor(k / 10); // 把k的末位去掉\r\n    }\r\n    return sum.reverse();\r\n};\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922491993","body":"## 题解\r\n\r\n### 解法一:  双指针&&两路程\r\n\r\n```typescript\r\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\r\n    let pa: ListNode | null = headA;\r\n    let pb: ListNode | null = headB;\r\n    while (pa !== pb) {\r\n        if (pa === null) {\r\n            pa = headB;\r\n        } else {\r\n            pa = pa.next;\r\n        }\r\n        if (pb === null) {\r\n            pb = headA;\r\n        } else {\r\n            pb = pb.next;\r\n        }\r\n    }\r\n    return pa;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yliboom":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917000554","body":"# 思路\n根据 arr 的长度 在遍历过程中做幂等运算，得出 arr 转换后的数组\n# 代码\n```javascript\n\nconst addToArrayForm = function (arr, k) {\n\n    let number = 0;\n    // 根据 arr 的长度 在遍历过程中 做运算，得出 arr 转换后的数组\n    // 0 + 1 * 1000 + 2 * 100 + 3 * 10 + 4\n\n    for (let i = 0; i < arr.length; i++) {\n        let len = arr.length - i - 1;\n        number +=  arr[i] * Math.pow(10, len);\n    }\n    return number + k\n\n}\n\n\n\n````\n# 复杂度分析\nfor 循环的时间复杂度为 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917368512","body":"# 思路\n\n- 将 string 转为数组, 根据字符串所在位置组成目标字符串数组，在原数组中找到每个字符串具体目标字符串索引最近的位置\n- 关键词：绝对值以及 索引位置\n\n\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nlet shortestToChar = function(s, c) {\n\n    let array = [];\n    let S = s.split('');\n    let placeArray = [];\n\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] == c) placeArray.push(i);\n    }\n\n    for (let i = 0; i < S.length ; i++) {\n\n        let min = 0;\n        let subtract = 0;\n\n        for (let j = 0; j < placeArray.length ; j++) {\n\n            subtract = Math.abs(placeArray[j] - i)\n\n            if (j === 0 || min > subtract) {\n                min = subtract\n            }\n\n        }\n\n        array.push(min)\n    }\n\n    return array;\n\n};\n\nshortestToChar(\"loveleetcode\", 'e')\n\n```\n\n# 复杂度分析\n1. 时间复杂度：log(n) + n\n2. 空间复杂度:  log(n) + n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918332383","body":"# 思路\n确定大致的思路是 从里往外整合数组中的内容，用到的栈的概念不理解，从官方找到了一个自己能够理解的方案\n\n# 代码\n```javascript\n\nconst decodeString = (s) => {\n    let numStack = [];        // 存倍数的栈\n    let strStack = [];        // 存 待拼接的str 的栈\n    let num = 0;              // 倍数的“搬运工”\n    let result = '';          // 字符串的“搬运工”\n    for (const char of s) {   // 逐字符扫描\n        if (!isNaN(char)) {   // 遇到数字\n            num = num * 10 + Number(char); // 算出倍数\n        } else if (char == '[') {  // 遇到 [\n            strStack.push(result); // result串入栈\n            result = '';           // 入栈后清零\n            numStack.push(num);    // 倍数num进入栈等待\n            num = 0;               // 入栈后清零\n        } else if (char == ']') {  // 遇到 ]，两个栈的栈顶出栈\n            let repeatTimes = numStack.pop(); // 获取拷贝次数\n            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\n        } else {                   \n            result += char;        // 遇到字母，追加给result串\n        }\n    }\n    return result;\n};\n\n````\n# 复杂度分析\n1.时间复杂度 O(n)\n2.空间复杂度\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gjts":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917000754","body":"## 语言 CSharp \n\n* 时间复杂度:O(max⁡(n,log⁡k))\n* 空间复杂度:O(N)\n\n> 考点：两个数相加 超过10进一位 \n\n> 操作：%10 取个位上的数  /10取十位上的数 添加到数组 数组反转\n\n> 思考：先考虑有没有加0的可能性，试着用一个自己习惯的数字来进行 比如[9,9]+5 先处理一个小的数\n```\npublic IList<int> AddToArrayForm(int[] num, int k) {\n        int i = num.Length - 1;\n        int sum = k;\n        List<int> arr = new List<int>();\n        while(i >= 0 || sum != 0){\n            if(i >= 0){\n                sum += num[i];\n            }\n            arr.Add(sum % 10);\n            sum /= 10;\n            i--;\n        }\n        int[] arr1 = arr.ToArray();\n        Array.Reverse(arr1);\n        return arr1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429975","body":"## 语言 CSharp\n* 时间复杂度：O(N)\n* 空间复杂度：O(N)\n\n\n> 思路：找出距离向左或者向右下一个字符 C 的距离\n\n\n> 操作：向左 向右遍历\n\n\n```javascript\npublic int[] ShortestToChar(string s, char c) {\n        int N = s.Length;\n        var isok = s.ToCharArray();\n        int[] ans = new int[N];\n        var prev = int.MinValue >> 1;\n        for (int i = 0; i < s.Length; i++)\n        {\n            if (isok[i] == c) prev = i;\n            ans[i] = i - prev;\n        }\n        prev = int.MaxValue >> 1;\n        for (int i = N - 1; i >= 0; --i)\n        {\n            if (isok[i] == c) prev = i;\n            ans[i] = Math.Min(ans[i], prev - i);\n        }\n        return ans;\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662349","body":"## 语言 CSharp \n* 时间复杂度：Push:O(1)  Pop:O(1)  Increment:O(k)\n* 空间复杂度：O(n)\n\n> 思路：先想一下栈的特性：先入后出的结构、底层存储有两种方式、数组和链表可以选择\n\n> 步骤：对于Push 操作判断是不是数组是不是满了 对于Pop操作看看数组是不是为空了\n\n__Code__\n```javascript\npublic class CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top =-1;\n    }\n    public void Push(int x) {\n        if(top!=stack.Length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    public int Pop() {\n        if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    public void Increment(int k, int val) {\n        int limit = Math.Min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918337705","body":"## 语言 CSharp\n* 时间复杂度：O(n)\n* 空间复杂度：O(n)\n\n\n> 思路：括号内还有括号 匹配问题可以用栈 \n\n> 操作：遇到数字 int当作倍数  遇到字母string 尾部添加  为 [ 时 倍数和 字母入栈 为 ] 时，stack 出栈，拼接字符串\n```javascript\npublic string DecodeString(string s) {\n        StringBuilder res = new StringBuilder();\n        int mult = 0;\n        Stack<int>  repeatCount = new Stack<int>();\n        Stack<string> repeatStr = new Stack<string>();\n        foreach(char c in s)\n        {\n            if(c == '[') {\n                repeatCount.Push(mult);\n                repeatStr.Push(res.ToString());\n                mult = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_mult = repeatCount.Pop();\n                for(int i = 0; i < cur_mult; i++) tmp.Append(res);\n                res = new StringBuilder(repeatStr.Pop() + tmp);\n            }\n            else if(c >= '0' && c <= '9') mult = mult * 10 + int.Parse(c + \"\");\n            else res.Append(c);\n        }\n        return res.ToString();\n    }\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919281858","body":"## 语言 CSharp\n**Ps:CSharp 里面的所有方法都是首字母大写的**\n\n* 时间复杂度：Push:O(1) ; Pop:摊还复杂度 O(1)，最坏情况下的时间复杂度 O(n) ; Peek:O(1)\n* 空间复杂度：Push:O(n) ; Pop:O(1) ; Peek:O(1)\n\n> 思路：先知道队列是个啥，先入先出的线性结构，和栈恰好相反，可以用反转的思路来完成\n\n> 操作：先准备两个栈，一个用来Push操作，一个用来Pop操作，反转一下就可以了，Pop时判断out栈为空时就要反转一下 反转操作就是in栈用Pop,out栈用 Push\n\n**Code**\n\n```javascript\npublic class MyQueue {\n    /** Initialize your data structure here. */\n    Stack<int> inputStack;\n    Stack<int> outputStack;\n    private int front=default;\n    public MyQueue() {\n        inputStack = new Stack<int>();\n        outputStack = new Stack<int>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void Push(int x) {\n        if(inputStack.Count==0)\n        {\n            front = x;\n        }\n        inputStack.Push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int Pop() {\n        if (outputStack.Count==0) {\n            while (inputStack.Count!=0)\n            {\n                outputStack.Push(inputStack.Pop());\n            }\n        }\n         return outputStack.Pop(); \n    }\n    \n    /** Get the front element. */\n    public int Peek() {\n        if (outputStack.Count !=0) \n        {\n            return outputStack.Peek();\n        }\n        return front;\n    }\n    \n    /** Returns whether the queue is empty. */\n    public bool Empty() {\n        return (inputStack.Count == 0)&&(outputStack.Count ==0);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920144737","body":"## 语言 CSharp\n\n* 时间复杂度：O(n)\n* 空间复杂度：O(n)\n\n> 思路：当前值小于栈顶值 排序块改变 大于栈顶值不改变 可以用小的值自己试一下\n\n> 操作：遍历数字，Stack不为空且num值小于栈顶值  把栈顶值给到big值 每 pop() 一个 big 代表合并一个块\n\n__Code__\n```javascript\npublic int MaxChunksToSorted(int[] arr) {\n        Stack<int> stack = new Stack<int>();\n        foreach (int num in arr) {\n            if (stack.Count!=0 && num < stack.Peek()) {\n                int superBig = stack.Pop();\n                while (stack.Count!=0 && num < stack.Peek()) {\n                    stack.Pop();\n                }\n                stack.Push(superBig);\n            } else {\n                stack.Push(num);\n            }\n        }\n        return stack.Count;\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921030089","body":"## 语言 CSharp \n* 时间复杂度：O(n)\n* 空间复杂度：O(1)\n\n> 思路：链表问题 首先一般要知道链表有多少个元素 链表的头节点 链表是否有环循环会产生死锁 可以用当前值来%链表的长度 2%5 和 7%5是一样的都是想找到它的位置\n\n操作：\n 1. 可以先判断链表的长度，以最小的值来判断，假如只有一个值，那就直接返回它自己\n 2. 计数器来记录链表的长度，数组或者字符串都有Length属性或者方法，链表可以用count来记录有多少个 循环到！=null为止\n 3. 然后直接% 找到需要跑到哪\n 4. 双指针定位起始值在头部，循环头部不为空，那就双指针一块走\n 5. 为空了直接连起来 变成一个有环链表 把满指针的只想空\n\n```javascript\npublic ListNode RotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        while(now != null){\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921905231","body":"## 语言 CSharp\n\n* 时间复杂度：O(n)\n* 空间复杂度：O(1)\n\n> 思路：链表考察指针指向问题，可以用一个假的节点来指向头节点，pre------>A------>B----->Next 变成 pre------>B------>A------->Next\n\n> 操作：建立虚拟头节点，两个节点交换\n\n__Code__\n```javascript\nif(head == null || head.next == null) return head;\n        ListNode preNode = new ListNode(-1, head), res;\n        preNode.next = head;\n        res = head.next;\n        ListNode firstNode = head;\n        ListNode secondNode; \n        ListNode nextNode;\n        while(firstNode != null && firstNode.next != null){\n            secondNode = firstNode.next;\n            nextNode = secondNode.next;\n\n            firstNode.next = nextNode;\n            secondNode.next = firstNode;\n            preNode.next = secondNode;\n\n            preNode = firstNode;\n            firstNode = nextNode;\n        }\n        return res;\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922331718","body":"## 语言 CSharp\n\n* 时间复杂度：O(logn)\n* 空间复杂度：O(1)\n\n> 思路：平衡二叉数概念是中点永远大于左子树，并且小于右子树\n\n> 操作：找到最初中节点 快慢指针找中点 \n\n__Code__\n\n```javascript\npublic TreeNode SortedListToBST(ListNode head) {\n        if(head == null) return null;\n        return dfs(head,null);\n    }\n    private TreeNode dfs(ListNode head, ListNode tail){\n        if(head == tail) return null;\n        ListNode fast = head, slow = head;\n        while(fast != tail && fast.next != tail){ //链表循环完 中点就出来了 Slow就是中点 这一步就是核心操作 这题的双指针就是求中点\n          fast = fast.next.next;                        //快指针跑1步  \n          slow = slow.next;                             //慢指针跑2步  \n        }\n        TreeNode root = new TreeNode(slow.val);  \n        root.left = dfs(head, slow);            //递归左子树 头节点到中点\n        root.right = dfs(slow.next, tail);      //递归右子树 中点到链表最后\n        return root;\n  }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922495984","body":"## 语言 CSharp\n\n* 时间复杂度：O(m+n)\n* 空间复杂度：O(1)\n\n\n> 思路：消除两个链表的长度差 \n\n> 操作：双指针 走两个链表 A走完走B B走完走A 只有两种可能为null 相交\n\n__Code__\n```javascript\npublic ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenbihao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917000877","body":"\n## 思路\n硬刚出来的，明天看看别人的解答\n\n## 关键点\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        // 先转int[] 再去加   进位字段\n        String kStr = String.valueOf(k);\n        int[] kArray = getIntArray(kStr);\n\n        List<Integer> result;\n\n        // 计算并取进位\n        if (num.length >= kArray.length) {\n            result = calculate(num, kArray);\n        } else {\n            result = calculate(kArray, num);\n        }\n        return result;\n    }\n\nprivate List<Integer> calculate(int[] longer, int[] shorter) {\n        int carry = 0;\n        for (int i = 0; i < longer.length; i++) {\n            int longerLen = longer.length - i - 1;\n            int shorterLen = shorter.length - i - 1;\n\n            if (shorterLen >= 0) {\n                int i1 = shorter[shorterLen] + longer[longerLen] + carry;\n                longer[longerLen] = i1 % 10;\n                carry = i1 / 10;\n            } else {\n                // 当k比num位数少的时候，还得计算完进位的情况\n                if (carry != 0) {\n                    int i1 = longer[longerLen] + carry;\n                    longer[longerLen] = i1 % 10;\n                    carry = i1 / 10;\n                }\n            }\n        }\n\n        // 判断最后有没有进位，有的话补上\n        List<Integer> result = Arrays.stream(longer).boxed().collect(Collectors.toList());\n        if (carry != 0) {\n            ArrayList<Integer> integers = new ArrayList<>();\n            integers.add(carry);\n            integers.addAll(result);\n            result = integers;\n        }\n        return result;\n    }\n    \n    private int[] getIntArray(String str) {\n        int[] ints = new int[str.length()];\n        for (int i = 0; i < ints.length; i++) {\n            Character ch = str.charAt(i);\n            ints[i] = Integer.parseInt(ch.toString());\n        }\n        return ints;\n    }\n\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917426477","body":"总觉得菜鸡的我为什么每次写的都很长很冗余的感觉，哭了\n\n``` java\n\npublic int[] shortestToChar(String s, char c) {\n        char[] cs = new char[s.length()];\n        int[] result = new int[s.length()];\n        \n        for (int i = 0; i < cs.length; i++) {\n            cs[i] = s.charAt(i);\n        }\n        for (int i = 0; i < cs.length; i++) {\n            Integer forward = null;\n            Integer backward = null;\n            if (cs[i] == c) {\n                result[i] = 0;\n                continue;\n            }\n            // 向前遍历\n            for (int j = 1; i - j >= 0; j++) {\n                if (cs[i - j] == c) {\n                    forward = j;\n                    break;\n                }\n            }\n            // 向后遍历\n            for (int j = 1; i + j < cs.length; j++) {\n                if (cs[i + j] == c) {\n                    backward = j;\n                    break;\n                }\n            }\n            if (forward==null) {\n                result[i] =backward;\n            }else if(backward == null){\n                result[i] =forward;\n            }else{\n                result[i] = forward > backward ? backward : forward;\n            }\n        }\n        return result;\n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917622502","body":"\n## 思路\n最开始写测试的时候以为数组的值也要每一步一致，导致走了点弯路\n\n其实题目只要 pop 和 push，并没有获取整个数组的方法\n\n看题解的时候发现还有优化的做法，可以使inc操作的时间复杂度优化为 O(1):\n\n* 增加一个增量操作的数组\n* 调用 inc 时，只需要简单的赋值，复杂度是 O(1) ，v1版的是for循环，复杂度是 O(k)\n* 调用 pop 时，只需要获取顶部的增量值+原栈值；并且把增量值往下合并即可\n\n因为这里是栈的结构，只需操作栈顶，所以可以不用考虑获取中间值的状况，所以可以使用这种方法来优化 inc 方法的复杂度\n\n## 关键点\n\n栈 、前缀和\n\n## 代码\n\nJava Code:\n\n```java\n\npackage array_stack_queue;\n\n/**\n * @author: chenbihao\n * @create: 2021/9/10\n * @Description:\n * @History:\n */\npublic class LeetCode_1381_CustomStack {\n\n    int top;\n    int[] stack;\n\n    public LeetCode_1381_CustomStack(int maxSize) {\n        top = -1;\n        stack = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top != stack.length - 1) {\n            stack[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        return stack[top--];\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, top + 1);\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\nclass LeetCode_1381_CustomStack_v2 {\n\n    int top;\n    int[] stack, add;\n\n    public LeetCode_1381_CustomStack_v2(int maxSize) {\n        top = -1;\n        stack = new int[maxSize];\n        add = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top != stack.length - 1) {\n            stack[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if (top != 0) {\n            add[top - 1] += add[top];\n        }\n        add[top--] = 0;\n        return ret;\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k - 1, top);\n        if (k >= 0) {\n            add[k] += val;\n        }\n    }\n}\n\n\n```\n\n\n**复杂度分析**\n\nv1版：\n- 时间复杂度：  \n  - push 操作和 pop 操作： O(1) \n  - inc 操作： O(k)\n- 空间复杂度： O(maxSize)\n\nv2版：\n- 时间复杂度： O(1)\n- 空间复杂度： O(maxSize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918244503","body":"## 思路\n\n栈、括号匹配\n\n## 关键点\n\n遇到左括号就进行压栈处理，遇到右括号就弹出栈\n\n性能不太行，晚点优化\n\n## 代码\n\nJava Code:\n\n``` java\n\n    public String decodeString(String s) {\n\n        Stack<Integer> countStack = new Stack();\n        Stack<String> StrStack = new Stack();\n        String count = \"\";\n        String str = \"\";\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c >= '0' && c <= '9') {\n                // 遇到数字就记录   也可以用这个来判断是否数字：  if (Character.isDigit(c)) {\n                count += Integer.parseInt(String.valueOf(c));\n            } else if (c == '[') {\n                // 遇到左括号就入栈\n                countStack.push(Integer.parseInt(count));\n                StrStack.push(str);\n                count = str = \"\";\n            } else if (c == ']') {\n                // 遇到右括号就出栈\n                Integer c1 = countStack.pop();\n                String temp = \"\";\n                for (int j = 0; j < c1; j++) {\n                    temp += str;\n                }\n                str = StrStack.pop() + temp;\n            } else {\n                // 记录字母\n                str += c;\n            }\n        }\n        return str;\n    }\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：O(s)\n- 空间复杂度：O(s)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919237187","body":"\n## 思路\n\n栈、队列\n\n## 关键点\n\n由2个栈：后进先出（last in - first out， LIFO）\n\n来实现队列：先进先出（first in - first out， FIFO）\n\n可以利用反转\n\n几种实现方法：\n- 一个当队列栈（主栈），一个当临时栈\n  - push：先把队列里的一个个取出放入到临时栈，然后把 push 的值放到队列最底部，最后把临时栈里的值取回到队列里，复杂度O(n)\n  - pop、peek、isEmpty：针对队列栈调用即可，复杂度O(1)\n- 一个当输入栈，一个当输出栈\n  - push：直接压入输入栈中，复杂度O(1)\n  - pop、peek：先判断输出栈是否为空，为空的话需要做一下反转操作（从输入栈取出到输出栈），然后直接对输出栈进行调用即可，摊还复杂度O(1)\n  - isEmpty:判断2个栈是否都为空，复杂度O(1)\n\n## 代码\n\nJava Code:\n\n``` java\npublic class LeetCode_232_MyQueue {\n\n    Stack<Integer> stackIn, stackOut;\n\n    public LeetCode_232_MyQueue() {\n        stackIn = new Stack();\n        stackOut = new Stack();\n    }\n\n    public void push(int x) {\n        // 把 x 入栈\n        stackIn.push(x);\n    }\n\n    public int pop() {\n        stackReverse();\n        return stackOut.pop();\n    }\n\n    public int peek() {\n        stackReverse();\n        return stackOut.peek();\n    }\n\n    public boolean empty() {\n        return stackIn.empty() && stackOut.empty();\n    }\n\n    /**\n     * 要取的话，判断reverse是否为空，空的话先反转\n     */\n    private void stackReverse() {\n        if (stackOut.isEmpty()) {\n            while (!stackIn.isEmpty()) {\n                stackOut.push(stackIn.pop());\n            }\n        }\n    }\n\n}\n```\n\n\n\n**复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920071521","body":"\n## 关键点\n\n这题目让我无厘头了一个钟，一直理解不了题的意思，直到看了题解....\n\n原来是我看叉了....  我还一直在纠结到底是`块内排序`还是`块的和`再排序，\n\n结果是块内排序 & 原数组排序：\n\n> 分割成几个“块” `分别进行排序`，使得连接的结果和按`升序排序后的原数组`相同。\n\n\n可以用\n- 滑动窗口\n- 单调栈\n- 计数排序\n- ...\n\n题解：\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-deng-jie-/\nhttps://leetcode-solution.cn/solutionDetail?type=3&id=6&max_id=2\n\n\n## 代码\n\nJava Code:\n\n``` java\n\npublic int maxChunksToSorted(int[] arr) {\n\n// 这里使用滑动窗口的解法：当滑动窗口的和相等的话，则说明可以分块\n\nint count=0;\nint sum1=0,sum2=0;\n\nint[] sortArr = Arrays.copyOf(arr, arr.length);\nArrays.sort(sortArr);\n\nfor (int i = 0; i < arr.length; i++) {\n\n    sum1+=arr[i];\n    sum2+=sortArr[i];\n\n    if (sum1 ==sum2) {\n        count ++;\n        //sum1 = sum2 = 0; \n    }\n}\nreturn count;\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920955994","body":"\n\n## 关键点\n\n判断长度，取余\n然后把尾连到头形成一个循环链表\n根据取余的值，找到新的头和尾，并把新的尾给断开\n\n## 代码\n\nJava Code:\n\n``` java\n public ListNode rotateRight(ListNode head, int k) {\n\n    if (head == null || head.next == null) {\n        return head;\n    }\n\n    int count = 1;\n    ListNode flag = head;\n\n    // 先遍历总长\n    while (flag.next != null) {\n        count++;\n        flag = flag.next;\n    }\n    // 取余\n    int mod = k % count;\n    if (mod == 0) {\n        return head;\n    }\n\n    // 单纯取余的话是向左移动，这里向右移所以减一下\n    int needNext = count - mod;\n    flag.next = head;\n    flag=head;\n\n    // 循环一下找到新尾，设置新尾的next为空\n    for (int i = 1; i < needNext; i++) {\n        flag = flag.next;\n    }\n    ListNode result = flag.next;\n    flag.next = null;\n    return result;\n}\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921667605","body":"\n## 思路\n\n解法：\n- 递归\n- 迭代（本次解法）\n\n\n2个值互换看起来挺简单的\n\n主要要有临时指针来存放，然后改一下单数位和双数位的next就好了\n\n比如：(下标表示next指针指向的位置) \n- 原始链表： **1**<sub>2</sub>  2<sub>3</sub>   3<sub>4</sub>  4<sub>null</sub>\n- 改成：   1<sub>4</sub>  **2**<sub>1</sub>  3<sub>null</sub>  4<sub>3</sub>   \n  按照顺序：  **2**<sub>1</sub>  1<sub>4</sub> 4<sub>3</sub> 3<sub>null</sub>\n\n这里有个容易绕进去的点在于:第一位的next不是指向第三位，而是第四位\n\n因为如果第三四位有值的话，三四位也是需要交换的,最终指向的是第四位\n\n所以代码流程为： \n- 第一位指向第四位（如果第三四位有空则指向第三位）\n- 第二位指向第一位\n- 操作指针指向第三位，继续下一轮操作\n\n\n## 关键点\n\n链表的基础操作\n\n## 代码\n\nJava Code:\n\n``` java\n\npublic ListNode swapPairs(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode flag = head;\n        // 如果第二个有值，把返回的头定在第二个\n        ListNode result = head.next != null ? head.next : head;\n\n        ListNode temp2, temp3;\n        // 判断单数和双数是否为空，不为空则调换顺序\n        while (flag != null && flag.next != null) {\n\n            // 存第2、3位指针\n            temp2 = flag.next;\n            temp3 = temp2.next;\n\n            // 判断3、4是否为空 空的话1链到3（因为无法支撑下一轮操作） 否则链到4（继续下一轮）\n            if (temp3 == null || temp3.next == null) {\n                flag.next = flag.next.next;\n            } else {\n                flag.next = flag.next.next.next;\n            }\n\n            // 第2位的指针指向第1位\n            temp2.next = flag;\n            // 当前遍历的指针指向第3位\n            flag = temp3;\n        }\n        return result;\n    }\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922324355","body":"\n## 思路\n\n递归：\n- 快慢指针\n缓存：\n- \n\n## 关键点\n\n递归\n\n## 代码\n\nJava Code:\n\n``` java\npublic TreeNode sortedListToBST(ListNode head) {\n    return dfs(head, null);\n}\n\nprivate TreeNode dfs(ListNode head, ListNode tail) {\n    if (head == tail) {\n        return null;\n    }\n    // 寻找中点\n    ListNode fast = head, slow = head;\n    while (fast != tail && fast.next != tail) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    // 慢的就是中点\n    TreeNode treeNode = new TreeNode(slow.val);\n    // 分别拿左右边的值递归下去\n    treeNode.left = dfs(head, slow);\n    treeNode.right = dfs(slow.next, tail);\n    return treeNode;\n}\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922469709","body":"\n## 思路\n\n很多种解法：\n- 栈：最开始用的是2个栈，全部入栈，然后再从栈顶去对比\n- 统一起点：统计下2个链表的长度，让长的先走，走到同一起跑线后并排走，如有一致则返回\n- 哈希Set：只需遍历一个链存进Set，然后遍历另一个链表时对比即可\n- 双指针：因为双指针的长度总合是相等的（（链A+B）乘2 == （链B+A）乘2），所以双指针最终会走向同一个终点（null），如果中间遇到相交的提前返回即可\n\n## 关键点\n\n双指针\n\n## 代码\n\nJava Code:\n\n``` java\npublic ListNode getIntersectionNodeV3(ListNode headA, ListNode headB) {\n    ListNode p1 = headA, p2 = headB;\n\n    // 遍历一次\n    while (p1 != p2) {\n        // 如果不等于空，就继续；如果等于空，就换到另一条链上继续遍历\n        p1 = p1 == null ? headA : p1.next;\n        p2 = p2 == null ? headB : p2.next;\n    }\n    return p1;\n}\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917001862","body":"### 思路\n\n待补\n\n### 代码\n\n\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\n\nvar addToArrayForm = function(num, k) {\n  const res = []\n  let i = num.length - 1\n  let carry = 0\n  while (i >= 0 || k > 0 || carry > 0) {\n    let cur = (num[i] || 0) + k % 10 + carry\n    res.push(cur % 10)\n    carry = cur / 10 | 0\n    i--\n    k = k / 10 | 0\n  }\n  return res.reverse()\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917365809","body":"##### 思路\r\n用变量prevC记录c的下标,初始值为无穷大,当s[i]=c时更新preC=i\r\n遍历字符串,将非c的字符串存入临时栈中,当遇到c时,依次计算栈中字符串到当前c以及prevC的最小距离,注意针对C非S最后一个字符串的情况,需要再清空下临时栈\r\n##### 复杂度\r\n时间复杂度：$O(N)$, N 为S数组长度。\r\n空间复杂度：$O(N)$, N 为S数组长度。\r\n##### 代码\r\n```js\r\nvar shortestToChar = function (S, C) {\r\n  let arr = [],\r\n    prevC = -Infinity,\r\n    map = [];\r\n  //清空暂存栈\r\n  function clear(prev, next = Infinity) {\r\n    for (const targetIndex of map) {\r\n      const Index = Math.min(Math.abs(targetIndex - prev), Math.abs(targetIndex - next));\r\n      arr.push(Index);\r\n    }\r\n    map = [];\r\n  }\r\n  for (let index = 0; index < S.length; index++) {\r\n    const ele = S[index];\r\n    if (ele === C) {\r\n      clear(prevC, index);\r\n      arr.push(0);\r\n      prevC = index;\r\n    } else {\r\n      map.push(index);\r\n    }\r\n  }\r\n  if (map.length > 0) {\r\n    clear(prevC);\r\n  }\r\n  return arr;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917534757","body":"### 设计一个支持增量操作的栈\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n链接：https://leetcode-cn.com/problems/design-a-stack-with-increment-operation\r\n\r\n#### 思路\r\n两种做法:\r\n一种常规遍历.\r\n一种运用辅助栈,空间换时间，用一个 O(M)的 hashtable 来记录所有 increment 的操作，\r\n在要 pop 的时候把操作对弹出栈的值进行运算,并且要更新辅助栈.\r\n\r\n#### 复杂度\r\n\r\n1. 复杂度分析\r\n时间复杂度：O(N) \r\n空间复杂度：O(1)\r\n\r\n2. 辅助栈\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n\r\n#### 代码\r\n\r\n```js\r\nvar CustomStack = function (maxSize) {\r\n  this.list = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.list.length < this.maxSize) {\r\n      this.list.push(x)\r\n  }\r\n};\r\n\r\n1.\r\n/**\r\n* @return {number}\r\n*/\r\nCustomStack.prototype.pop = function () {\r\n  return this.list.length ? this.list.pop() : -1\r\n};\r\n\r\n/** \r\n* @param {number} k \r\n* @param {number} val\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.increment = function (k, val) {\r\n  let min = Math.min(k, this.list.length)\r\n  for (let index = 0; index < min; index++) {\r\n      this.list[index] += val\r\n  }\r\n};\r\n\r\n\r\n2.\r\nCustomStack.prototype.pop = function() {\r\n  if(this.stack.length < 1) return -1; //如果长度为0，返回-1\r\n  let curLastIndex = this.stack.length - 1; //现在即将要被pop出去的元素的index\r\n  let last = this.stack.pop(); //last = 被pop的\r\n  if(this.record.has(curLastIndex)){ //如果record有这个index的操作记录\r\n    let temp = this.record.get(curLastIndex) //让temp等于这个index的增加的总值\r\n    last += temp //加到last上去\r\n    //调整相关记录\r\n    this.record.set(curLastIndex - 1, (this.record.get(curLastIndex - 1) || 0 ) + temp )\r\n    //删除已经用过的记录\r\n    this.record.delete(curLastIndex)\r\n  }\r\n\r\n  return last;\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n const index = Math.min(k,this.stack.length) - 1;\r\n  this.record.set(index, (this.record.get(index) || 0) + val)\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919045627","body":"### 用栈实现队列\n#### 思路\n\n**栈1:**\n\n用于入队列存储\n\n**栈2:**\n\n出队列时将栈1的数据依次出栈，并入栈到栈2中\n\n栈2出栈即栈1的底部数据即队列要出的数据。\n\n**注意:**\n\n栈2为空才能补充栈1的数据，否则会打乱当前的顺序。\n#### 复杂度\n时间复杂度：时间复杂度均摊为 O(1) push 和 empty 都是 1， pop 和 peek 均摊是 1，对于每个元素之多入栈和出栈两次\n\n空间复杂度：O(N)\n#### 代码\n```js\nvar MyQueue = function () {\n    this.stack1 = [];\n    this.stack2 = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.stack1.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    if (this.stack2.length === 0) {\n        while (this.stack1.length > 0) {\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    if (this.stack2.length === 0) {\n        while (this.stack1.length > 0) {\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2[this.stack2.length-1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\nreturn this.stack2.length===0 && this.stack1.length===0\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919922887","body":"\n### 最多能完成排序的块 II\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n#### 思路\n\n借助辅助栈,存储每一块的最大值,因而栈是正序排列的.\n遍历数组,当遇到比辅助栈栈顶元素大的元素或栈为空时直接压入栈,\n否则需要找到栈中所有比元素大的块,合为一块,最大值就是栈顶的值.so,递归遍历栈,若块的值比元素大,则出栈,块的值比元素小则停止循环,给栈加上值为栈顶的块\n#### 复杂度\n时间复杂度$O(N)$：一次遍历arr为$O(N)$,修正排序块最多遍历一遍arr为$O(N)$\n空间复杂度$O(N)$：极端情况下，排序块数量等于数组长度，此时stack占用线性大小额外空间。\n\n#### 代码\n```\nvar maxChunksToSorted = function (arr) {\n  let stack = [];\n  for (const ele of arr) {\n      if (stack.length && ele < stack[stack.length - 1]) {\n        let max = stack.pop()\n        while (stack.length && ele < stack[stack.length - 1]) {\n         stack.pop()\n      }\n          stack.push(max);\n      }\n      else {\n          stack.push(ele);\n      }\n  }\n\n  return stack.length\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JianXinyu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917004761","body":"```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917423711","body":"- 找出s中所有的c所在位置，记为数组idxs\n- s中的每一个字符必然落在两个c位置之间，记为l和r\n- 比较两个的距离即可\n- 使用iterator方便迭代idxs\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        const int n = s.length();\n        vector<int> ans(n, 0);\n        vector<int> idxs;\n\n        \n        for(int i = 0; i < n; ++i){\n            if( s[i] == c ){\n                idxs.push_back(i);\n            }\n        }\n        idxs.push_back(10000);\n        vector<int>::iterator itr = idxs.begin();\n        int l = -10000, r = *itr;\n        for(int i = 0; i < n; ++i){\n            ans[i] = min(i - l, r - i);\n            if( r == i){\n                l = r;\n                itr++;\n                if( itr == idxs.end() )\n                    r = 20000;\n                else\n                    r = *itr;\n            }\n        }\n\n        return ans;\n\n    }\n};\n```\nT: O(n)\nS: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917631608","body":"```cpp\nclass CustomStack {\nprivate:\n    int size_;\n    int length_;\n    vector<int> *stack_;\npublic:\n    CustomStack(int maxSize) {\n        size_ = maxSize;\n        length_ = 0;\n        stack_ = new vector<int>(maxSize);\n    }\n    \n    void push(int x) {\n        if( length_ < size_ )\n            stack_->at(length_++) = x;\n    }\n    \n    int pop() {\n        int ans;\n        if(length_ > 0){\n            ans = stack_->at(--length_);\n        }\n        else\n            return -1;\n        return ans;\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < k; i++){\n            if( i < length_ ){\n                stack_->at(i) += val;\n            }\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918299835","body":"```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        if(s.length() < 4)\n            return s;\n        \n        stack<char> stk;\n        for(char ch : s){\n            if(ch != ']')\n                stk.push(ch); // 除']'外，所有都入栈\n            else{\n                // 1. 取出[]内的字符串\n                string str;\n\n                while( !stk.empty() && isalpha(stk.top()) ){\n                    str.insert(0, 1, stk.top());\n                    stk.pop();\n                }\n\n                stk.pop(); // pop '['\n\n                // 2. 得到倍数数字\n                string num;\n                 while( !stk.empty() && isdigit(stk.top()) ){\n                    num.insert(0, 1, stk.top());\n                    stk.pop();\n                }\n                int count = stoi(num);\n\n                // 3. 根据倍数把字母再push回去\n                while( count > 0 ){\n                    for( char chr : str){\n                        stk.push(chr);\n                    }\n                    count--;\n                }\n            }\n        }\n        // 取出栈里的所有char\n        string ans;\n        while( !stk.empty() ){\n            ans.insert(0, 1, stk.top());\n            stk.pop();\n        }\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919236522","body":"```cpp\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() { }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stk1_.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if(stk2_.empty()) move();\n        int top = stk2_.top();\n        stk2_.pop();\n        return top;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if(stk2_.empty()) move();\n        return stk2_.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return (stk1_.empty() && stk2_.empty());\n    }\nprivate:\n    stack<int> stk1_, stk2_;\n    void move(){\n        while(!stk1_.empty()){\n            stk2_.push(stk1_.top());\n            stk1_.pop();\n        }\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920124253","body":"```cpp\nint maxChunksToSorted(vector<int>& arr) {\n    stack<int> stack;\n    for(int i =0;i<arr.size();i++){\n        // 如果arr[i]比栈顶小，说明arr[i]一定要和前面的元素融合，融合到没有栈元素比arr[i]大为止\n        if(!stack.empty()&&stack.top()>arr[i]){\n            int cur = stack.top(); // 当前栈顶一定是前面所有块的最大值\n            while(!stack.empty()&&stack.top()>arr[i]){\n                stack.pop(); \n            }\n            stack.push(cur); // 把原栈顶放回去\n        }\n        else{\n            stack.push(arr[i]);\n        }\n    }\n    return stack.size();\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920973972","body":"# Solution 1 simple traverse\n## 思路\n首先观察规律：rotate就是把old tail and old head连起来，设置new tail, 再返回new head。new head是原链表倒数第k个节点，new tail是原链表倒数第k+1个节点。\n\n题目Constraints中给的k可能远大于链表长度，不妨先遍历一遍链表，找出长度和tail，再取模，避免无意义的遍历列表。\n\n注意链表为0，或者不旋转的corner case。\n## Code\n```cpp\nListNode* rotateRight(ListNode* head, int k) {\n\tif(!head || !k) return head;\n\tint len = 0;\n\tListNode *cur = head, *tail;\n\n\twhile(cur){\n\t\tlen++;\n\t\tif(!cur->next) tail = cur;\n\t\tcur = cur->next;\n\t}\n\n\tint rotate = k % len;\n\tif(!rotate) return head;\n\tcur = head;\n\t// 找到倒数第k个节点\n\tfor(int i = 1; i < len - rotate; ++i){\n\t\tcur = cur->next;\n\t}\n\n\ttail->next = head;\n\tListNode* newhead = cur->next;\n\tcur->next = nullptr;\n\n\treturn newhead;\n}\n```\n\n**复杂度分析**\nN为链表长度\nT: 遍历了两遍链表，O(N)\nS: O(1)\n\n# Solution 2 fast and slow pointers\n## Preparation \n求单链表的倒数第 N+1 个节点（注意，倒数第一个节点就是tail，这里不是从零开始计数了）\n1.  采用快慢指针\n2.  快指针与慢指针都以每步一个节点的速度向后遍历\n3.  快指针比慢指针先走 N 步\n4.  当快指针到达终点时，慢指针正好是倒数第 N+1 个节点\n```text\n快指针 = head;  \n慢指针 = head;  \nwhile (快指针.next) {  \n\t if (N-- <= 0) {  \n\t \t慢指针 = 慢指针.next;  \n\t }  \n\t 快指针 = 快指针.next;  \n}\n```\n## 思路\n1.  获取单链表的倒数第 k + 1 与倒数第 k 个节点\n2.  将倒数第 k + 1 个节点的 next 指向 null\n3.  将链表尾节点的 next 指向 head\n4.  返回倒数第 k 个节点\n\n例如链表 A -> B -> C -> D -> E 右移 2 位，依照上述步骤为：\n1.  获取节点 C 与 D\n2.  A -> B -> C -> null, D -> E\n3.  D -> E -> A -> B -> C -> null\n4.  返回节点 D\n\n```cpp\nListNode* rotateRight(ListNode* head, int k) {\n\t/* fast and slow pointers */\n\t// corner case\n\tif(!head || !head->next || !k) return head;\n\n\t// 计算链表长度\n\tListNode *cur = head;\n\tint len = 0;\n\twhile(cur){\n\t\tlen++;\n\t\tcur = cur->next;\n\t}\n\n\tk = k % len; // 取模\n\tif(!k) return head;\n\n\t// 快慢指针\n\tListNode *fast = head, *slow = head;\n\twhile(fast->next){\n\t\tif(k-- <= 0)\n\t\t\tslow = slow->next;\n\t\tfast = fast->next;\n\t}\n\t// now, fast指向tail, slow指向倒数第k+1个节点\n\n\tfast->next = head; // 把old tail and old head连起来\n\tListNode *newhead = slow->next; // new head是倒数第k个节点\n\tslow->next = nullptr; // 设置new tail\n\n\treturn newhead;\n}\t\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921891664","body":"## 思路\n用两个指针，将它俩逆转后再小心地和剩余节点连起来。\n\n## Code\n```cpp\nListNode* swapPairs(ListNode* head) {\n\tif(!head || !head->next) return head;\n\tListNode dummy(0);\n\tdummy.next = head;\n\tListNode *prev = &dummy;\n\tListNode *cur1 = head;\n\tListNode *ans = cur1->next;\n\t\n\twhile(cur1 && cur1->next){\n\t\tListNode *cur2 = cur1->next;\n\t\tListNode *next = cur2->next;\n\n\t\t// swap\n\t\tcur2->next = cur1;\n\t\tcur1->next = next;\n\t\tprev->next = cur2;\n\n\t\t// update\n\t\tprev = cur1;\n\t\tcur1 = next;  \n\t}\n\treturn ans;\n}\n```\n**Complexity Analysis**:\nT: O(N)\nS: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922330800","body":"## 思路\n1. 既然是height-balanced BST, 那必然要从中间均分，所以找中点\n2. 如何找中点？\n\t1. 遍历一遍，记录长度，取其一半，再遍历到中点\n\t2. 快慢指针，快指针移动两步，慢指针移动一步\n\t3. 由于需要新建TreeNode, 不需要ListNode, 把ListNode.val存到数组，用空间换时间，这样只需要遍历一遍就好了\n3. 将中点设为TreeNode \\*root\n4. 对左右两半递归\n5. 检查边界情况\n\n## Code\n### 快慢指针找中点: \n```cpp\nTreeNode* sortedListToBST(ListNode* head) {\n\tif(!head) return nullptr;\n\treturn build(head, nullptr);\n}\nTreeNode* build(ListNode* head, ListNode* tail){\n\t// 为啥返回nullptr， 见下\n\tif(head == tail) return nullptr;\n\t// find middle ListNode using fast&slow pointers\n\tListNode *fast = head, *slow = head;\n\twhile(fast != tail && fast->next != tail){\n\t\tfast = fast->next->next;\n\t\tslow = slow->next;\n\t}\n\t// now slow pointer points to the middle node, use it as root\n\tTreeNode* root = new TreeNode(slow->val);\n\t// recursion\n\troot->left = build(head, slow);\n\troot->right = build(slow->next, tail);\n\treturn root;\n}\n```\n考虑临界情况head->next == tail时，此时slow=head, root->val=head->val。之后递归，在第一个递归中，head还是原来的head'，head=tail，那就不能再返回一次head'了，所以返回nullptr。考虑这个边界情况的时候，不要尝试放在树中考虑，不然会越想越糊涂；应该只是从递归函数返回值的角度。\n**Complexity Analysis**\nN为链表长度\nT: 由于有遍历+递归，所以是$O(NlogN)$\nS: $O(1)$\n\n#### Cache找中点\n```cpp\nTreeNode* sortedListToBST(ListNode* head) {\n\tif(!head) return nullptr;\n\t// cache\n\tvector<int> nodes;\n\twhile(head){\n\t\tnodes.push_back(head->val);\n\t\thead = head->next;\n\t}\n\tint n = nodes.size();\n\n\tfunction<TreeNode*(int, int)> build = [&](int b, int e)->TreeNode*{\n\t\tif(b == e) return nullptr;\n\t\tint mid = (b+e) / 2;\n\t\tTreeNode *root = new TreeNode(nodes[mid]);\n\t\troot->left = build(b, mid);\n\t\troot->right = build(mid+1, e);\n\t\treturn root;\n\t};\n\t// note: n, rather than n-1\n\treturn build(0, n);\n}\n```\n为什么是n而不是n-1呢？\n直觉上，对比快慢指针法，其中的tail其实是最后一个节点的next。\n另一方面，用了n-1的话，因为mid=(b+e)/2是向下取整，所以mid不会等于n-1，root->val就不会是nodes\\[n-1\\]；尽管mid+1可以等于n-1，但此时直接返回nullptr了，不会再设置root。\n\n**Complexity Analysis**\nT: $O(N)$\nS: $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922494883","body":"## 思路\n1. 先遍历链表A，\n2. 由于题目Constraints有$1 <= Node.val <= 10^5$, 将经过的节点值减去$10^5$，作为经过的标记\n3. 再遍历链表B，第一个节点值$\\leq 0$的，就是相交点\n4. 由于题目要求不能修改输入链表，我们再改回去，即链表A的节点值$+10^5$\n## Code\n```cpp\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n\tif(!headA || !headB) return nullptr;\n\tListNode *cur = headA;\n\twhile(cur){\n\t\tcur->val -= 1e5;\n\t\tcur = cur->next;\n\t}\n\n\tListNode *ans = headB;\n\twhile(ans && ans->val > 0){\n\t\tans = ans->next;\n\t}\n\n\tcur = headA;\n\twhile(cur){\n\t\tcur->val += 1e5;\n\t\tcur = cur->next;\n\t}\n\treturn ans;\n}\n```\n**Complexity Analysis:**\nT: $O(N)$\nS: $O(1)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CruiseYuGH":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917007515","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        tmp = 0\n        for i in range(n-1,-1,-1):\n            num_tmp = num[i] + k%10+ tmp\n            tmp =num_tmp//10\n            num[i] = num_tmp%10\n            k = k//10\n        #print(k,tmp,num)\n        k += tmp\n        while k!=0:\n            num.insert(0,k%10)\n            k = k//10\n        return num\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917421775","body":"## 思路\r\n左遍历一遍，存储距离，右遍历一遍，两者最小值为最近距离\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        left_num, right_num =[],[]\r\n        c_tmp = -99\r\n        for i,s_char in enumerate(s):\r\n            if s_char == c:\r\n                c_tmp = i\r\n            if c_tmp != -99:\r\n                left_num.append(i-c_tmp)\r\n            else:\r\n                left_num.append(10001)\r\n        c_tmp = -99\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i] == c:\r\n                c_tmp = i\r\n            if c_tmp != -99:\r\n                right_num.insert(0,c_tmp-i)\r\n            else:\r\n                right_num.insert(0,10001)\r\n        res = [min(right_num[i],left_num[i]) for i in range(len(s))]\r\n        return res\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917655502","body":"## 思路\n前缀和思想\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = 0\n        self.maxSize = maxSize\n        self.s = []\n        self.s_add = []\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.s.append(x)\n            self.s_add.append(0)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0: return -1\n        self.size -= 1\n        if self.size >= 1:\n            self.s_add[-2] += self.s_add[-1]\n        return self.s.pop() + self.s_add.pop()\n\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.size:\n            self.s_add[min(self.size, k) - 1] += val\n        print(self.s_add)\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918301970","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        cur_num = 0\n        cur_str=\"\"\n        for c in s:\n            if c.isdigit():\n                cur_num = cur_num*10+int(c)\n            elif c is \"[\":\n                stack.append(cur_str)\n                stack.append(cur_num)\n                cur_str = ''\n                cur_num = 0\n            elif c is \"]\":\n                temp_num = stack.pop()\n                temp_str = stack.pop()\n                cur_str = temp_str + temp_num * cur_str\n            else:\n                cur_str+=c \n        return cur_str","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919247914","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.data = []\n        self.helper = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.data.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if len(self.helper) == 0:\n            self.d2h()\n        return self.helper.pop()\n\n    def d2h(self):\n        while self.data:\n            self.helper.append(self.data.pop())\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if len(self.helper) == 0:\n            self.d2h()\n        return self.helper[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.data) == 0 and len(self.helper) == 0\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920124671","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920953040","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head:\n            slow , fast = head ,head\n            tmp = head\n            leng = 0\n            while tmp:\n                tmp = tmp.next\n                leng +=1\n            k = k%leng\n            while k:\n                fast = fast.next\n                k -=1\n            while fast.next:\n                slow = slow.next\n                fast = fast.next\n            if slow.next:\n                tmp = slow.next\n            else:\n                return head\n            slow.next = None\n            fast.next = head\n            return tmp\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921891778","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        dummyHead = ListNode(0)\n        dummyHead.next = head\n        temp = dummyHead\n        while temp.next and temp.next.next:\n            p1 = temp.next\n            p2 = temp.next.next\n            temp.next = p2\n            p1.next = p2.next\n            p2.next = p1\n            temp = p1\n        return dummyHead.next\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922332352","body":"class Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def build(head):\n            if not head: return None\n            if not head.next: return TreeNode(val = head.val)\n            pre, fast, slow = head, head, head\n            while fast and fast.next:\n                fast = fast.next.next\n                pre = slow\n                slow = slow.next\n            pre.next = None #median: slow, right: slow.next\n            return TreeNode(val = slow.val, left = build(head), right = build(slow.next))\n        return build(head)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922496323","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        P_A, P_B = headA,headB\n        while P_A!=P_B:\n            if P_A: P_A=P_A.next\n            else: P_A=headB\n            if P_B: P_B=P_B.next\n            else: P_B=headA\n        return P_A","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kuroky-Chen":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917007922","body":"* 语言：JavaScript\r\n```\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921852868","body":"```\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == NULL || head->next == NULL)\r\n            return head;\r\n\r\n        ListNode* newHead = head->next;\r\n        head->next = swapPairs(newHead->next);  // 后面的交给递归解决\r\n        newHead->next = head;\r\n        \r\n        return newHead;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917008176","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n    \n      LinkedList<Integer> list = new LinkedList<>();\n           \n            for(int i=num.length-1;i>=0;i--){\n                 k = k + num[i];\n                 int a=(k)%10;\n\n                  k=k/10;\n\n                  list.addFirst(a);\n\n            }\n            if(k>0){\n                while(k>0){\n                   \n                    int b = k % 10;\n                     k=k/10;\n                    list.addFirst(b);\n                }\n            }\n            return list;\n\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917329642","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n         char[] chars = s.toCharArray();\n         int[] arr=new int[s.length()];\n        for(int i=0;i<s.length();i++){\n           String s1 = new String(chars,0,i);\n           String s2 = new String(chars,i,s.length()-i);\n           int i1 = s1.lastIndexOf(c);\n           int i2 = s2.indexOf(c);\n           int min=-1;\n           if(i1==-1){\n             min=i2;\n           }\n           if(i2==-1){\n           i1 = s1.length()-i1;\n            min=i1;\n           }\n            if(i1!=-1&&i2!=-1){\n                i1 = s1.length()-i1;\n               min = i1<i2?i1:i2;\n            }\n\n               arr[i]=min;\n        }\n             return arr;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flagyk5":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917009198","body":"```\nclass Solution:\n#list转换为int\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        B = 0\n        for i in range(len(A)):\n            B += A[i]*(10**(len(A) - i - 1))\n#做加法     \n        C = B + K    \n#加判断,程序测试的时候发现[0]和0通不过       \n        if C == 0:\n            D = [0]\n        else:\n            D = []     \n#int转化为list，注意reverse\n#while循环，除了0， 空字符串，空列表，空元组，空字典，空集合等，其它都为True\n        while C:\n            D.append(C%10)\n            C //=10\n        D.reverse()\n        return D\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917411362","body":"```\nfrom typing import List\n\nclass Solution:\n    def shortestToChar(self, S: str, C: str) -> List[int]:\n        ans = []\n\n        for i in range(len(S)):\n            l = r = i\n            while l >= 0:\n                if S[l] == C: break\n                l -= 1\n            while r < len(S):\n                if S[r] == C: break\n                r += 1\n\n            if l == -1: l = -10000\n            if r == len(S): r = 10000\n            ans.append(min(r - i, i - l))\n        return ans\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917650807","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.cs = []\n        self.sz = maxSize\n        \n    def push(self, x: int) -> None:\n        if len(self.cs) < self.sz: \n            self.cs.append(x)\n            \n    def pop(self) -> int:\n        if len(self.cs) == 0:\n            return -1\n        return self.cs.pop()\n        \n    def increment(self, k: int, val: int) -> None:\n        if len(self.cs) <= k:\n            for i in range(len(self.cs)):\n                self.cs[i] += val\n        if len(self.cs) > k:\n            for i in range(k):\n                self.cs[i] += val\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919277091","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.s1.append(x)\n            \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.s1 == []:\n            return []\n        while self.s1:\n            self.s2.append(self.s1.pop())\n        pop = self.s2.pop()\n        if self.s2 == []:\n            pass\n        while self.s2:\n            self.s1.append(self.s2.pop())\n        return pop\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.s1 == []:\n            return []\n        while self.s1:\n            self.s2.append(self.s1.pop())\n        peek = self.s2[-1]\n        self.s1.append(self.s2.pop())\n        return peek\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not bool(self.s1)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920137532","body":"```\nclass Solution:\n    def maxChunksToSorted(self, A: [int]) -> int:\n        s = []\n        for i in A:\n            if s and s[-1] > i:\n                num = s[-1]\n                while s and s[-1] > i:\n                    s.pop()\n                s.append(num)\n            else:\n                s.append(i)\n        return len(s)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920980057","body":"```\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        p1 = p2 = head\n        c = 1\n        i = 0\n        while i < k:\n            if p2.next:\n                c += 1\n                p2 = p2.next\n            else:\n                k = k%c\n                i = -1\n            i +=1\n        while p2.next:\n            p2 = p2.next\n            p1 = p1.next\n        if p1.next: sav = p1.next\n        else: return head\n        p1.next = None\n        p2.next = head\n        return sav\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921824283","body":"```\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n    if not head or not head.next: \n        return head\n    ans = ListNode()\n    ans.next = head.next\n    pre = ans\n    while head and head.next:\n        next = head.next\n        n_next = next.next\n\n        next.next = head\n        pre.next = next\n        head.next = n_next\n\n        pre = head\n        head = n_next\n    return ans.next\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917013134","body":"### 代码实现\n\n```\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(max(n,logk))，其中 nn 为数组的长度\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919250638","body":"### 解题思路\n使用两个辅助栈，一个作为输入栈，一个作为输出栈\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(1)\n- 空间复杂度 $O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moxiaopao278":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917014944","body":"#include <algorithm>\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n        int carry = 0;\n        vector<int> B;\n        while(K > 0){\n            B.push_back(K%10);\n            K /= 10;\n        }\n        if(B.size()==0){\n            B.push_back(0);\n        }\n        reverse(A.begin(), A.end());\n        int i;\n        int maxl = max(A.size(), B.size());\n        vector<int> C(maxl);\n        //对齐A组和B组的数位。\n        while(A.size()<maxl)A.push_back(0);\n        while(B.size()<maxl)B.push_back(0);\n        for(i = 0; i < maxl; i++){\n            C[i] = A[i] + B[i] + carry;\n            carry = C[i] / 10;\n            C[i] %= 10;\n        }\n        if(carry){\n            C.push_back(carry);\n        }\n        reverse(C.begin(), C.end());\n        return C;\n\n    }\n};\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917662357","body":"#思路\n##官方思路 不太会，学习别人的\n###JAVA\n###class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.size = 0\n        self.stack = []\n        \n\n    def push(self, x: int) -> None:\n        if self.size < self.max_size:\n            self.stack.append(x)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size > 0:\n            self.size -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.stack))):\n            self.stack[i] += val\n            \n\n        \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918334277","body":"#思路：自己未做出来，参考了别人的。\n##class Solution {\n  public String decodeString(String s) {\n    Stack<Integer> intStack = new Stack();\n    Stack<StringBuilder> strStack = new Stack();\n    StringBuilder pattern = new StringBuilder();\n    int number = 0;\n\n    for (char ch : s.toCharArray()) {\n      if (Character.isDigit(ch)) {\n        number = number * 10 + ch - '0';\n      } else if (ch == '[') {\n        intStack.push(number);\n        strStack.push(pattern);\n        number = 0;\n        pattern = new StringBuilder();\n      } else if (ch == ']') {\n        StringBuilder temp = pattern;\n        pattern = strStack.pop();\n        for (int i = intStack.pop(); i > 0; i--) pattern.append(temp);\n      } else pattern.append(ch);\n    }\n    return pattern.toString();\n  }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919285108","body":"class MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n    \n    public MyQueue() {\n        stack1 = new Stack<Integer>();\n        stack2 = new Stack<Integer>();\n    }\n    \n    \n    public void push(int x) {\n        while (!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n        stack1.push(x);\n    }\n    \n    \n    public int pop() {\n         if (!stack1.isEmpty() && stack2.isEmpty()){\n            while (!stack1.isEmpty()){\n                 stack2.push(stack1.pop());\n            }\n        } \n        return stack2.pop();\n    }\n    \n  \n    public int peek() {\n        while (!stack1.isEmpty()){\n            stack2.push(stack1.pop());\n        }\n        return stack2.peek();\n    }\n    \n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919739010","body":"#思路\r\n不太会，参考别人代码\r\n‘’‘ java\r\n public int maxChunksToSorted(int[] arr) {\r\n        int[] max = new int[arr.length];\r\n        max[0] = arr[0];\r\n        for(int i=1; i<arr.length; i++)\r\n            max[i] = Math.max(arr[i], \r\n\r\n> max[i-1]);\r\n\r\n        int cmin = Integer.MAX_VALUE, re=0;\r\n        for (int i = arr.length-1; i >=0; i--) {\r\n            // 确切地说，cmin记录的是arr[i+1]到最后一个数之间的最小值\r\n            // 如果cmin >= max[i], 则i这里就是一个分割点\r\n            if(cmin >= max[i])\r\n                re++;\r\n            cmin = Math.min(cmin,arr[i]);\r\n        }\r\n        return re;\r\n    }\r\n‘’‘","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921730390","body":"#思路：\n不太会参考别人的。\n```class Solution {\n    public ListNode swapPairs(ListNode head) {\n          if(head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode temp = dummy;\n        while(temp.next != null && temp.next.next !=null) {\n            ListNode next = temp.next;\n            ListNode nextNext = temp.next.next;\n            next.next = nextNext.next;\n            nextNext.next = next;\n            temp.next = nextNext;\n            temp = next;\n        }\n        return dummy.next;\n\n    }\n}```\n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922331544","body":"#思路：参考别人代码\n\n''' \nclass Solution {\n\n    public TreeNode sortedListToBST(ListNode head) {\n        List<Integer> nodes = new ArrayList<>();\n        while(head != null){\n            nodes.add(head.val);\n            head = head.next;\n        }\n\n        return sortedListToBST(nodes, 0, nodes.size());\n    }\n\n    private TreeNode sortedListToBST(List<Integer> nodes, int start, int end){\n        if(start >= end) return null;\n        int mid = start + (end - start) /2;\n        TreeNode root = new TreeNode(nodes.get(mid));\n        root.left = sortedListToBST(nodes, start, mid);\n        root.right = sortedListToBST(nodes, mid+1, end);\n        return root;\n    }\n}'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922496023","body":"\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        int CA = 0, CB = 0;\n        ListNode* ptrA = headA, *ptrB = headB;\n        while(ptrA)\n        {\n            ptrA = ptrA->next;\n            ++CA;\n        }\n        while(ptrB)\n        {\n            ptrB = ptrB->next;\n            ++CB;\n        }\n        ptrA = headA;\n        ptrB = headB;\n        if(CA > CB)\n        {\n            int x = CA - CB;\n            while(ptrA && x--)\n                ptrA = ptrA->next;\n            while(ptrA)\n            {\n                if(ptrA == ptrB)\n                    return ptrA;\n                ptrA = ptrA->next;\n                ptrB = ptrB->next;\n            }\n        }\n        else\n        {\n            int x = CB-CA;\n            while(ptrB && x--)\n                ptrB = ptrB->next;\n            while(ptrB)\n            {\n                if(ptrA == ptrB)\n                    return ptrA;\n                ptrA = ptrA->next;\n                ptrB = ptrB->next;\n            }\n        }\n        return NULL;\n    }\n}\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917015435","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n      List returnList= new ArrayList<Integer>();\n\n      //1. 转换成int  \n      int sum = num[0];\n\n      for(int i = 0; i< num.length - 1; i++){\n          sum *=10;\n          sum += num[i+1];\n      }\n\n      //2. 相加\n      sum = sum + k;\n\n      //2. 转成Integer[]\n      String str = Integer.toString(sum);\n      char[] chars = str.toCharArray();\n\n      for(int i = 0; i < chars.length; i++){\n          Integer integer = Integer.valueOf(String.valueOf(chars[i]));\n          returnList.add(integer);\n      }\n\n      return returnList;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917427815","body":"```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        // 1. 获取c的位置\n        List<Integer> cPos = new ArrayList<>();\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == c){\n                cPos.add(i);\n            }\n        }\n\n        // 2. 计算距离\n        int min;\n        int[] res = new int[s.length()];\n        for(int i = 0; i < s.length(); i++){\n            min = Integer.MAX_VALUE;\n            for(int j = 0; j < cPos.size(); j++){\n                int abs = Math.abs(i - cPos.get(j));\n                min = Math.min(abs, min);\n            }\n            res[i] = min;\n        }\n\n        // 3. 返回res\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917542514","body":"class CustomStack {\n    int[] stack;\n    int size;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        size = 0;\n    }\n    \n    public void push(int x) {\n       if(size < stack.length) {\n           stack[size] = x;\n           size++;\n       }\n    }\n    \n    public int pop() {\n        if(size == 0){\n            return -1;\n        }\n        return stack[--size];\n    }\n    \n    public void increment(int k, int val) {\n        int len = size > k ? k : size;\n\n        for(int i = 0; i< len; i++){\n            stack[i] += val;\n        }\n\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918183065","body":"class Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int times = 0;\n        LinkedList<Integer> multi = new LinkedList<>();\n        LinkedList<String> stack = new LinkedList<>();\n\n        for(Character c : s.toCharArray()){\n           if(c == '[') {\n               multi.addLast(times);\n               stack.addLast(res.toString());\n               times = 0;\n               res = new StringBuilder();\n           }\n           else if(c == ']'){\n              StringBuilder tmp = new StringBuilder();\n              int cur_multi = multi.removeLast();\n              for(int i =0 ;i<cur_multi; i++){tmp.append(res);};\n              res = new StringBuilder(stack.removeLast() + tmp);\n           }\n           else if(c >= '0' && c <= '9'){times = times * 10 + Integer.parseInt(c + \"\");}\n           else res.append(c);\n        }\n        return res.toString();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918702916","body":"class MyQueue {\n    // 输入栈\n    Deque<Integer> stIn;\n    // 输出栈\n    Deque<Integer> stOut;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stIn = new ArrayDeque<>();\n        stOut = new ArrayDeque<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        stIn.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(stOut.isEmpty()){\n            while(!stIn.isEmpty()){\n                stOut.push(stIn.pop());\n            }\n        }\n        return stOut.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        int res = this.pop();\n        stOut.push(res);\n        return res;\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stIn.isEmpty() && stOut.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920087294","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n\n        int count = 0;\n        int sum1 = 0, sum2 = 0;\n\n        int[] sortArr = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(sortArr);\n\n        for (int i = 0; i < arr.length; i++) {\n\n            sum1 += arr[i];\n            sum2 += sortArr[i];\n\n            if (sum1 == sum2) {\n                count++;\n                //sum1 = sum2 = 0; \n            }\n        }\n        return count;\n\n    }\n}\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920800078","body":"```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        // 记录头尾指针的位置 和链表的长度\r\n       ListNode first = head;\r\n       int length = 1;\r\n       int cur = 0;\r\n\r\n        if(head == null){\r\n            return head;\r\n        }\r\n\r\n\r\n        while(head.next != null){\r\n            head = head.next;\r\n            length ++;\r\n        }\r\n\r\n        // 形成环状\r\n        head.next = first;\r\n\r\n        // 对k取余\r\n        k = k % length;\r\n        while(cur < (length - k)){\r\n            head = head.next;\r\n            cur++;\r\n        }\r\n        first = head.next;\r\n        head.next = null;\r\n\r\n        // 把倒数第k个元素做头结点, 即倒数第k+1个元素的next = null\r\n        return first;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921833011","body":"class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922328743","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n\n        // 快慢指针找中心节点\n        ListNode p = head, q = head, pre = null;\n        while (q != null && q.next != null) {\n            pre = p;\n            p = p.next;\n            q = q.next.next;\n        }\n        pre.next = null;\n       \n        // 以升序链表的中间元素作为根节点 root，递归的构建 root 的左子树与右子树。\n        TreeNode root = new TreeNode(p.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(p.next);\n        return root;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922485716","body":"public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n\n        if(headA == null || headB == null) return null;\n        ListNode pA = headA, pB = headB;\n\n        while(pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zyMacro":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917015464","body":"    let arr2_ = [];\n    while(k>=0) {\n        arr2_.push(k%10);\n        k = Math.floor(k/10);\n        if(k === 0) {\n            break;\n        }\n    }\n    let arr1_ = num.reverse();\n    let len1 = num.length;\n    let len2 = arr2_.length;\n    if(len1 > len2) {\n        while(len1 - len2 > 0) {\n            arr2_.push(0);\n            len1 = len1 - 1;\n        }\n    } else if (len1 < len2){\n        while(len2 - len1 > 0) {\n            arr1_.push(0);\n            len2 = len2 - 1;\n        }\n    }\n    let res = [];\n    let bit = 0;\n    let supplement = 0;\n    arr1_.forEach((val,i) => {\n        let sum = val + arr2_[i];\n        if(sum + bit > 9) {\n            supplement = sum - 10;\n            res.push(supplement + bit);\n            bit = 1;\n        } else {\n            supplement = sum ;\n            res.push(supplement + bit);\n            bit = 0;\n        }\n    })\n    if(bit === 1) {\n        res.push(1);\n    }\n    return res.reverse();","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917381031","body":"```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let arr = s.split('');\n    let indexArr = [];\n    let res = [];\n    arr.forEach((val, i) => {\n        if(val === c) {\n            indexArr.push(i);\n        }\n    })\n    for(let i = 0; i < arr.length; i++) {\n        if(indexArr[0] >= i) {\n            res.push(indexArr[0] - i);\n        } else if (indexArr[indexArr.length - 1] <= i) {\n            res.push(i - indexArr[indexArr.length - 1]);\n        } else {\n            let distance = i - indexArr[0];\n            indexArr.forEach((val) => {\n                distance = distance > Math.abs(i - val) ? Math.abs(i - val) : distance;\n            })\n            res.push(distance);\n        }\n\n    }\n    return res;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917656961","body":"```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length === 0) {\n        return -1;\n    }\n    let pop = this.stack.pop();\n    return pop;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    this.stack.forEach((item, index) => {\n        if(index + 1 <= k) {\n            this.stack[index] += val;\n        }\n    })\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919262271","body":"```javascript\nvar MyQueue = function() {\nthis.inStack = [];\nthis.outStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(!this.outStack.length) {\n        while(this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return this.outStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.outStack.length) {\n        while(this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return this.outStack[this.outStack.length - 1];\n\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.inStack.length && !this.outStack.length;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920146952","body":"```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n   let res = 0;\n   let sum1 = 0;\n   let sum2 = 0;\n   let arr_ = [...arr];\n   let arrSorted = arr.sort(compare);\n   arr_.forEach((val, i) => {\n       sum1 += val;\n       sum2 += arrSorted[i];\n       if(sum1 === sum2) {\n           res += 1;\n       }\n   })\n    return res;\n};\n\nconst compare = (a, b) => a - b;\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921006777","body":"```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if(k === 0 || !head || !head.next) {\r\n        return head;\r\n    }\r\n    let n = 1;\r\n    let cur = head;\r\n    while(cur.next) {\r\n        cur = cur.next;\r\n        n++;\r\n    }\r\n    k = n - k % n;\r\n    if(k === 0) {\r\n        return head;\r\n    }\r\n    cur.next = head;\r\n    console.log(head.val);\r\n    while(k > 1) {\r\n        head = head.next;\r\n        k--;\r\n    }\r\n    const res = head.next;\r\n    head.next = null;\r\n    return res;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921903006","body":"```javascript\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    let curNode = head;\n    let flag = true;\n    let res;\n    while(curNode && curNode.next && curNode.next.next) {\n        let nextNode = curNode.next;\n        let temp = nextNode.next;\n        nextNode.next = curNode;\n        curNode.next = temp;\n        curNode = curNode.next;\n        if(flag) {\n            res = nextNode;\n            flag = false;\n        }\n    }\n    return res;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winterdogdog":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917015491","body":"```js\r\n**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    for(let i = num.length - 1; i >= 0; i--) {\r\n        let sum = k % 10 + num[i]\r\n        k = Math.floor(k / 10)\r\n        if (sum >= 10) {\r\n            k++\r\n            res.push( sum % 10 );\r\n        } else {\r\n            res.push(sum)\r\n        }\r\n    }  \r\n    while(k > 0) {\r\n        res.push(k % 10)\r\n        k = Math.floor( k / 10)\r\n    }\r\n    return res.reverse()\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917415842","body":"```js\r\n左右循环两次\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let res = [], str = s.split(''), pre = Infinity;\r\n    str.forEach((item, index) => {\r\n        if (item === c) {\r\n            pre = index\r\n        }\r\n        res.push(Math.abs(index - pre))\r\n    })\r\n    pre = Infinity;\r\n    for(let i = str.length - 1; i>=0; i--) {\r\n        if (str[i] === c) {\r\n            pre = i\r\n        }\r\n        if (res[i] > Math.abs(pre - i)) {\r\n            res[i] = Math.abs(pre - i)\r\n        }\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917934009","body":"```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.list = [];\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.list.length < this.maxSize) {\r\n        this.list.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    let res = this.list.pop()\r\n    return res === undefined ? -1 : res\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    this.list.forEach((item, index) => {\r\n        if (index < k) {\r\n            this.list[index] += val\r\n        }\r\n    })\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918311915","body":"```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let stack = [];const reg = /[a-zA-Z]+|[0-9]+|\\[|\\]/g;;\r\n    while(reg.lastIndex < s.length) {\r\n        let count = reg.exec(s)[0]\r\n        if (count !== ']') {\r\n            stack.push(count)\r\n        } else {\r\n            let cha = stack.pop(), str = '';\r\n            while(cha !== '[') {\r\n                str = cha + str\r\n                cha = stack.pop()\r\n            }\r\n            stack.push(str.repeat(+stack.pop()))\r\n            console.log(stack)\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919169831","body":"```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.instack = [];\r\n    this.outstack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.instack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(!this.outstack.length) {\r\n        while(this.instack.length) {\r\n        this.outstack.push(this.instack.pop())\r\n    }\r\n    }\r\n    \r\n    return this.outstack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if (!this.outstack.length){\r\n        while(this.instack.length) {\r\n        this.outstack.push(this.instack.pop())\r\n    }\r\n    }\r\n     \r\n    return this.outstack[this.outstack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.instack.length && !this.outstack.length\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919756382","body":"```js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    let stack = [];\r\n    arr.forEach(item => {\r\n        if(!stack.length || stack[stack.length - 1] <= item) {\r\n            stack.push(item)\r\n        } else {\r\n            let temp = stack.pop();\r\n            while(stack[stack.length - 1] > item) {\r\n                stack.pop()\r\n            }\r\n            stack.push(temp)\r\n        }\r\n    })\r\n    return stack.length\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920701459","body":"```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if(!head || !head.next || !k) return head;\r\n    let len = 1, cur  = head;\r\n    while(cur.next) {\r\n        len++;\r\n        cur = cur.next;\r\n    }\r\n    let add =len - k % len;\r\n    if (!add) return head;\r\n    cur.next = head;\r\n    console.log(add)\r\n    while(add) {\r\n        cur = cur.next;\r\n        add--\r\n    }\r\n    let res = cur.next;\r\n    cur.next = null;\r\n    return res\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921604870","body":"```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    if(head === null || head.next === null) return head;\r\n    let temp = head.next;\r\n    head.next = swapPairs(temp.next)\r\n    temp.next = head;\r\n    return temp\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922242788","body":"**递归**\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    const arr = [];\r\n    while(head) {\r\n        arr.push(head.val);\r\n        head = head.next;\r\n    }\r\n    let buildTree = (start, end) => {\r\n        if(start > end) return null;\r\n        let mid = (start + end) >>> 1\r\n        let root = new TreeNode(arr[mid]);\r\n        root.left = buildTree(start, mid - 1);\r\n        root.right = buildTree(mid+1, end);\r\n        return root\r\n    }\r\n    return buildTree(0, arr.length - 1)\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922494443","body":"```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    if(headA === null || headB === null) return null;\r\n    let a = headA, b = headB;\r\n    while(a !== b) {\r\n        a = a === null ? headB : a.next;\r\n        b = b === null ? headA : b.next\r\n    }\r\n    return a\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yankang233":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917015563","body":"#python\r\n\r\n    class Solution:\r\n        def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n            i = len(A) - 1\r\n            while K:\r\n                A[i] += K\r\n                K, A[i] = A[i] // 10, A[i] % 10\r\n                i -= 1\r\n\r\n              if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n           return A\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351715","body":"## Code\n### python3\n      class Solution:\n          def shortestToChar(self, s: str, c: str) -> List[int]:\n              cc = [ i  for i in range(len(s))   if s[i]==c]\n              return([min([abs(x-y)  for y in cc]) for x in range(len(s))])\n\n## 复杂度\n\n时间：O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917639352","body":"    class CustomStack:\n\n        def __init__(self, maxSize: int):\n            self.stk = [0] * maxSize\n            self.top = -1\n\n        def push(self, x: int) -> None:\n            if self.top != len(self.stk) - 1:\n                self.top += 1\n                self.stk[self.top] = x\n\n        def pop(self) -> int:\n            if self.top == -1:\n                return -1\n            self.top -= 1\n            return self.stk[self.top + 1]\n\n        def increment(self, k: int, val: int) -> None:\n            lim = min(k, self.top + 1)\n            for i in range(lim):\n                self.stk[i] += val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918335062","body":"# code  \n    class Solution:\n      def decodeString(self, s: str) -> str:\n          stack = []  # (str, int) 记录左括号之前的字符串和左括号外的上一个数字\n          num = 0\n          res = \"\"  # 实时记录当前可以提取出来的字符串\n          for c in s:\n              if c.isdigit():\n                  num = num * 10 + int(c)\n              elif c == \"[\":\n                  stack.append((res, num))\n                  res, num = \"\", 0\n              elif c == \"]\":\n                  top = stack.pop()\n                  res = top[0] + res * top[1]\n              else:\n                  res += c\n          return res\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917017117","body":"### 思路\n\n------\n\n先在对应位置一一相加，有进位就进位，再进行进位操作，获取每位的数出来\n\n### 语言\n\n------\n\nJava\n\n        class Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n      List<Integer> res = new ArrayList<Integer>();\n       int n = num.length;\n       for (int i = n - 1; i >= 0; --i) {\n         int sum = num[i] + k % 10;\n       k /= 10;\n      if (sum >= 10) {\n       k++;\n     sum -= 10;\n     }\n       res.add(sum);\n      }\n      for (; k > 0; k /= 10) {\n       res.add(k % 10);\n        }\n      Collections.reverse(res);\n      return res;\n          }\n         }\n复杂度分析\n\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zulliu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917017139","body":"**思路**\n\n倒序遍历，将数字拆分为位数相加\n\n**代码**\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        holder = 0\n        counter = 0\n        num=num[::-1]\n        while k > 0 or counter < len(num):\n            if counter >= len(num):\n                digit = k % 10 + holder\n                num.append(digit % 10)\n            else:\n                digit = num[counter] + k % 10 + holder\n                num[counter] = digit % 10\n            holder = digit // 10\n            k = k //10\n            counter += 1\n        if holder == 1:\n            num.append(1)\n        num = num[::-1]\n        return num\n```\n**复杂度分析**\n\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921028697","body":"### 思路\r\n快慢指针寻找倒数第k个节点\r\n### 代码\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        \r\n        if not head:\r\n            return head\r\n        length = 0\r\n\r\n        current = fast = slow = head\r\n\r\n        while current:\r\n            current = current.next\r\n            length += 1\r\n        if length <= 1:\r\n            return head\r\n        \r\n        for i in range(k % length):\r\n            fast = fast.next\r\n        \r\n        while fast.next and slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        fast.next = head\r\n        current = slow.next\r\n        slow.next = None\r\n        return current\r\n```\r\n### 复杂度\r\n时间: O(n)\r\n空间: O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"supermeohh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917017461","body":"\n\n## 思路\n\n遍历进位\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> r = new ArrayList<Integer>();\n        int n = num.length;\n        for(int i = n-1;i >=0;--i){\n            int sum = num[i] + k%10;\n            k /=10;\n            if(sum >= 10){\n                k++;\n                sum -=10;\n            }\n            r.add(sum);\n        }\n        for(; k>0; k /=10){\n            r.add(k%10);\n        }\n        Collections.reverse(r);\n        return r;\n    }\n}\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n空间复杂度 O(1)\n时间复杂度 O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917424146","body":"\n\n## 思路\n\n左右遍历，取最小值\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n\n\n```\n\n\n**复杂度分析**\n\n\n空间复杂度 O(2N)\n时间复杂度 O(N)\n\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920010833","body":"插眼\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(N)$\n- 空间复杂度：$O(N)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Baiqr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917022001","body":"```javascript\nfunction calculateTwoNumberSum(arr, num) {\n    const arrNumberStr = arr.join(',')\n    const res = (Number(arrNumberStr.replace(/,/g, \"\")) + num)\n    return String(res).split(\"\")\n}\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"V-Enzo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917027391","body":"## 思路\r\n判断末尾相加的和是否大于10，如果大于10则需要，给k/=10后的k加1，然后进行下一轮操作。使用push_back更易操作\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> result;\r\n        int num_size = num.size();\r\n        for(int i=num_size -1; i>=0; i--){\r\n            int value = num[i] + k%10;\r\n            k/=10;\r\n            if (value>=10){\r\n                k += 1;\r\n                value -= 10;\r\n            }\r\n            result.push_back(value);\r\n        }\r\n        for( ; k>0; k/=10){            \r\n            result.push_back(k%10);\r\n        }\r\n        reverse(result.begin(), result.end());\r\n        return result;\r\n    }\r\n};\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917344037","body":"## 思路\r\n找到指定字符，计算出所有的距离，取最小值即可。这里其实变为指针移动去判断更好，能降到时间复杂度为O(N)\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int s_len = s.length();\r\n        vector<int> pos;\r\n        for(int i=0; i<s_len;i++){\r\n            if (s[i] ==c)\r\n                pos.push_back(i);\r\n        }\r\n        vector<int> ans;\r\n        for(int i=0; i<s_len; i++){\r\n            vector<int> min_dist;\r\n            for(int j=0; j<pos.size(); j++){\r\n                min_dist.push_back(abs(i-pos[j]));            \r\n                }\r\n            int min_v = *min_element(min_dist.begin(), min_dist.end());\r\n            ans.push_back(min_v);\r\n            }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n## 复杂度\r\n空间复杂度为O(N)\r\n时间复杂度为O(N^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917592064","body":"## 思路\r\n构建类中的vector，以及top（来标记栈目前的位置），随后通过改变top的值，来压入和弹出值。\r\n```C++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int top;\r\n\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        // cout<<top;\r\n        if(top != stack.size() - 1){\r\n            top += 1;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if(top==-1){\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int num = min(k, top+1);\r\n        for(int i=0; i<num; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n};\r\n```\r\n## 复杂度分析\r\n时间复杂度O(N)\r\n空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918092967","body":"## 思路\r\n维护两个栈去存储字符和数字。\r\n比较困难的是在碰到']'的时候，去字符串顶获取当前已经保存的字符，重复k遍后加到栈顶。\r\n然后把栈顶的元素赋给cur_str，弹出字符串的栈顶元素。\r\n最终的结果就是保留在cur_str中。\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n          int s_len = s.size();\r\n        stack<int> numstack;\r\n        stack<string> strstack;\r\n        int num = 0;\r\n        string cur_str=\"\";\r\n        string res = \"\";\r\n        for(int i = 0; i < s_len; i++) {\r\n            if(s[i]>='0' && s[i]<='9') {\r\n                num = 10*num + s[i]-'0';\r\n            }\r\n            else if((s[i]>='a' && s[i]<='z') || (s[i]>='A' && s[i]<'Z')) {\r\n                cur_str += s[i];\r\n                // cout<< cur_str;\r\n            }\r\n            else if(s[i]=='['){\r\n                strstack.push(cur_str);\r\n                numstack.push(num);\r\n                num = 0;\r\n                cur_str=\"\";\r\n            }\r\n            else if(s[i]==']'){\r\n                int k = numstack.top();\r\n                numstack.pop();\r\n                for(int j = 0; j <k; j++){\r\n                    strstack.top() += cur_str;\r\n                }\r\n                cur_str = strstack.top();\r\n                strstack.pop();\r\n                \r\n            }\r\n    }\r\n    return cur_str;\r\n    }\r\n};\r\n```\r\n## 复杂度分析\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919072676","body":"## 思路\r\n栈只能先进后出，队列择为先进先出。所以需要两个栈来维护，一个栈用来压入输入的元素，另一个栈则在pop的时候使用，将压入元素的栈弹出元素，压入新的栈，则可以做到模拟队列，做到先入先出。 \r\n1. 注意这里在pop的时候要先判断输出的栈是否有元素，如果没有则再去输入元素的栈去取。\r\n2. C++中元素的定义要放在构造函数外面申明，构造函数只能用来初始化。\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int> in_stk;\r\n    stack<int> out_stk;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        in_stk.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n    if (out_stk.empty()){\r\n        int in_size = in_stk.size();\r\n       for(int i=0; i<in_size; i++){\r\n           out_stk.push(in_stk.top());\r\n           in_stk.pop();\r\n        }\r\n       } \r\n       int res = out_stk.top();\r\n       out_stk.pop();\r\n       return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(out_stk.size()!=0){\r\n            return out_stk.top();\r\n        }else{\r\n            int in_size = in_stk.size();\r\n            for(int i=0; i<in_size;i++){\r\n                out_stk.push(in_stk.top());\r\n                in_stk.pop();\r\n            }\r\n            return out_stk.top();\r\n        }\r\n        \r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        if(out_stk.empty() && in_stk.empty()){\r\n            return true;\r\n        }\r\n        return  false;\r\n\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n时间复杂度:O(1)\r\n空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920015460","body":"## 思路\r\n单调递增栈的思想，融合数组，来满足分割的边界为前一部分的最大值要小于后一部分的最小值，最后的结果就是单调栈的长度。\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> stk;\r\n        for(int i=0; i<arr.size(); i++){\r\n            if(!stk.empty()&&stk.top()>arr[i]){\r\n                int cur = stk.top();\r\n                while(!stk.empty()&&stk.top()>arr[i]){\r\n                    stk.pop();\r\n                }\r\n                stk.push(cur);\r\n            }else{\r\n                stk.push(arr[i]);\r\n            }\r\n        }\r\n        return stk.size();\r\n    }\r\n};\r\n```\r\n## 复杂度分析：\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920985157","body":"## 思路\r\n1. 先统计链表长度。\r\n2. 发现要移动的个数为k%链表长度\r\n3. 移动（长度-取模的结果）位，进行指针操作\r\n4. 最后还要保证最后的节点是nullptr，以及开始的时候判断head是不是nullptr；\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n    if(head==nullptr)\r\n        return head;\r\n    ListNode* cur = head;\r\n    int cnt = 0;\r\n    while(cur!=nullptr){\r\n        cnt++;\r\n        cur = cur->next;\r\n    }\r\n    int times = k%cnt;\r\n    if(times==0){\r\n        return head;\r\n    }\r\n    int left = cnt - times;\r\n    ListNode* tmp;\r\n    cur = head;\r\n    // cout<< left;\r\n    while(cur!=nullptr && left--){\r\n        cur = cur->next;\r\n    }\r\n    tmp = cur;\r\n    while(cur->next!=nullptr){\r\n        cur = cur->next;\r\n    }\r\n    cur->next = head;\r\n    head = tmp;\r\n    // while(head!=nullptr){\r\n    //     cout<<head->val;\r\n    //     head = head->next;\r\n    // }\r\n    cur = head;\r\n    while(cur->next != head){\r\n        cur = cur->next;\r\n    }\r\n    cur->next = nullptr; \r\n    return head;\r\n\r\n    }\r\n};\r\n```\r\n## 复杂度分析：\r\n时间复杂度为:O(N)\r\n空间复杂度为:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921915929","body":"## 思路\r\n主要是要设定dummy，以及用tmp来标识当前的位置，并且在后两个位置之间进行交换。\r\n写的时候脑子里要有图，会容易很多，而且设定dummy元会便于处理，否则会很混乱。\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if(head==nullptr || head->next==nullptr)\r\n            return head;\r\n        ListNode* dummy = new ListNode(0);\r\n        dummy->next = head;\r\n        ListNode* tmp = dummy;\r\n        while(tmp->next!=nullptr && tmp->next->next!=nullptr){\r\n            ListNode* node1 = tmp->next;\r\n            ListNode* node2 = tmp->next->next;\r\n            tmp->next = node2;\r\n            node1->next = node2->next;\r\n            node2->next =node1;\r\n            tmp = node1;\r\n        }\r\n        return dummy->next;\r\n    }\r\n};\r\n```\r\n## 复杂度分析\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922287313","body":"## 思路\r\n还没有非常理解，主要是递归的思想还不太会写，先插个眼。\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* getMedian(ListNode* left, ListNode* right) {\r\n        ListNode* fast = left;\r\n        ListNode* slow = left;\r\n        while (fast != right && fast->next != right) {\r\n            fast = fast->next;\r\n            fast = fast->next;\r\n            slow = slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n\r\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\r\n        if (left == right) {\r\n            return nullptr;\r\n        }\r\n        ListNode* mid = getMedian(left, right);\r\n        TreeNode* root = new TreeNode(mid->val);\r\n        root->left = buildTree(left, mid);\r\n        root->right = buildTree(mid->next, right);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        return buildTree(head, nullptr);\r\n    }\r\n};\r\n```\r\n## 复杂度分析\r\n时间复杂度:O(nlogn)\r\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922418574","body":"## 思路\r\n先上个暴力解法，直接两个for循环\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode* curA = headA;\r\n        ListNode* curB = headB;\r\n        for(auto ita=headA; ita!=nullptr; ita=ita->next){\r\n            for(auto itb=headB; itb!=nullptr; itb=itb->next){\r\n                if(ita == itb)\r\n                    return ita;\r\n            }\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```\r\n## 复杂度分析:\r\n时间复杂度:O(N^2)\r\n空间复杂度:O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ThreeGold-yxh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917027518","body":"## 思路一\n\n把 num[ ] 和k都转化为list，然后用0补齐较短的那个list，再遍历相加，加法策略为两数相加再加上进位，遍历完了之后最后检查一下进位是否为0，不为0还要插进结果list中，最后把结果list反转即可\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //首先把k变为数组模式kList\n        int temp = k;\n        List<Integer> kList = new ArrayList<>();\n        while(temp > 0){\n            int kBit = temp % 10;\n            kList.add(kBit);\n            temp = temp / 10;\n        }\n        //KList这时候是反的，个位在第一个\n        //把数组int[] num 变为 numList，注意也是个位数在最前面\n        List<Integer> numList = new ArrayList<>();\n        for(int i = num.length - 1; i >=0; i--){\n            numList.add(num[i]);\n        }\n        //比较一下这两个list哪个长，短的在后面补0\n        if(numList.size() > kList.size()){\n            int length= numList.size() - kList.size();\n            while(length-- > 0){\n                kList.add(0);\n            }\n        }\n        else{\n            int length= kList.size() - numList.size();\n             while(length-- > 0){\n                numList.add(0);\n            }\n        }\n        // //两个list反转\n        // Collections.reverse(numList);\n        // Collections.reverse(kList);\n        List<Integer> resultList = new ArrayList<>();\n        //按位做加法\n        //进位\n        int carryBit = 0;\n        for(int i = 0; i < numList.size(); i++){\n            int currentBit = numList.get(i) + kList.get(i) + carryBit;\n            int remainBit = currentBit % 10;\n            carryBit = currentBit / 10;\n            resultList.add(remainBit);\n        }\n        //最后看一下进位\n        if(carryBit != 0){\n            resultList.add(carryBit);\n        }\n        //反转resultList\n        Collections.reverse(resultList);\n        return resultList;\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(n)$\n\n因为用到了一个辅助List去保存结果","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334828","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n\n\n\n## 思路一\n\n双指针做法，一个firstIndex快指针，优先找到c的位置，然后慢指针secondIndex再来移动，补全结果数组\n\n\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        //双指针来做\n        int firstIndex = 0;\n        int secondIndex = -1;\n        int[] resultArr = new int[s.length()];\n        while(firstIndex <= s.length() - 1){\n            if(!(c==(s.charAt(firstIndex)))){\n                //如果慢指针还没有动过，那么这时候连一个c都没找到，全部赋值10001\n                if(secondIndex == -1){\n                    resultArr[firstIndex] = 10001;\n                }\n                //反之此时慢指针应该指向上一个c的位置，取位置的差值赋进去\n                else{\n                    resultArr[firstIndex] = firstIndex - secondIndex;\n                }\n                //快指针继续向后\n                firstIndex++;\n            }\n            //此时快指针到了下一个c的所在地，\n            else{\n                resultArr[firstIndex] = 0;\n                int mid = 0;\n                //修改位置差值,如果secondIndex == -1，那么全部都要修改\n                if(secondIndex == -1){\n                    mid = 0;\n                }\n                //修改位置差值,从mid到firstIndex的元素都需要修改值\n                else{\n                    mid = secondIndex + ((firstIndex - secondIndex) + 1) / 2 ;\n                }\n                while(mid < firstIndex){\n                    resultArr[mid] = firstIndex - mid;\n                    mid ++;\n                }\n                //最后把慢指针直接移动到快指针位置\n                secondIndex = firstIndex;\n                //然后快指针继续移动\n                firstIndex ++;\n            }\n        }\n        return resultArr;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(n^2)$\n\n空间复杂度：$O(n)$\n\n\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921897610","body":"#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n示例 1：\n\n\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n示例 2：\n\n输入：head = []\n输出：[]\n示例 3：\n\n输入：head = [1]\n输出：[1]\n\n\n\n## 思路一\n\n两个指针p、q遍历整个链表，注意交换结点后要整理好整张链表的顺序，不要断链了\n\n\n\n### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null){\n            return null;\n        }\n        ListNode p = head;\n        ListNode q = head.next;\n        //调整头指针head位置\n        if(q!=null){\n            head = q;\n        }\n        while(p!=null && q!=null){\n            //交换\n            p.next = q.next;\n            q.next = p;\n            //移动\n            //临时保存一下上一个p的位置\n            ListNode tempP = p;\n            p = p.next;\n            if(p!=null){\n                q = p.next;\n                if(q!=null){\n                tempP.next = q;\n            }\n            }\n        }\n        return head;\n\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922496112","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        //假设第一个链表长为a，第二个链表长为b，重合部分长为c，则\n        //两个指针indexA和indexB分别指向两个链表的表头，同时进行遍历\n        //indexA走完a链表后，再去从头遍历b链表，indexB走完b链表后，再去从头遍历a链表\n        //对indexA来说，它先走了a长度，再次走到两链表相交点时又走了b-c的长度(结点)\n        //对indexB来说，它先走了b长度，再次走到两链表相交点时又走了a-c的长度(结点)\n        //我们发现a+b-c = b+a-c,所以这两个指针恰好会在相交点处相遇，而如果两个链表没有相交点\n        //则c=0，此时两个指针刚好都为null，即同时遍历完了链表\n        ListNode indexA = headA;\n        ListNode indexB = headB;\n        while(indexA!=indexB){\n            if(indexA!=null){\n                indexA = indexA.next;\n            }\n            else{\n                indexA = headB;\n            }\n            if(indexB!=null){\n                indexB = indexB.next;\n            }\n            else{\n                indexB = headA;\n            }\n        }\n        return indexA;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"for123s":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917027734","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int len = num.size() - 1;\r\n        while(len>=0)\r\n        {\r\n            int sum = k % 10 + num[len];\r\n            k /= 10;\r\n            if(sum>=10)\r\n            {\r\n                ++k;\r\n                sum -= 10;\r\n            }\r\n            --len;\r\n            res.push_back(sum);\r\n        }\r\n        while(k>0)\r\n        {\r\n            res.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917328223","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n\r\n## 思路\r\n用数组index存放c在s中的位置，之后对s进行遍历，比较当前位置与index[i]，index[i+1]的距离，取最近距离值。\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size(),0);\r\n        vector<int> index;\r\n        for(int i=0;i<s.size();++i)\r\n        {\r\n            if(s[i]==c)\r\n                index.push_back(i);\r\n        }\r\n        for(int i=0;i<index[0];++i)\r\n            res[i] = index[0] - i;\r\n        int idx1 = 0, idx2 = idx1+1<index.size()?idx1+1:idx1;\r\n        for(int i=index[0]+1;i<s.size();++i)\r\n        {\r\n            if(idx2==idx1)\r\n                res[i] = i - index[idx1];\r\n            else\r\n                res[i] = (i-index[idx1])<(index[idx2]-i)?(i-index[idx1]):(index[idx2]-i);\r\n            if(res[i]==0)\r\n            {\r\n                idx1++;\r\n                idx2 = idx1+1<index.size()?idx1+1:idx1;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917655795","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass CustomStack {\r\n    int len;\r\n    vector<int> res;\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        len = 0;\r\n        res.resize(maxSize,0);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(len==res.size())\r\n            return;\r\n        res[len] = x;\r\n        ++len;\r\n    }\r\n    \r\n    int pop() {\r\n        if(len==0)\r\n            return -1;\r\n        --len;\r\n        return res[len];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if(len<k)\r\n            for(int i=0;i<len;++i)\r\n                res[i] += val;\r\n        else\r\n            for(int i=0;i<k;++i)\r\n                res[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918337819","body":"\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<char> st_c;\r\n        stack<int> st_num;\r\n        for(int i=0;i<s.size();++i)\r\n        {\r\n            if(s[i]>='0'&&s[i]<='9')\r\n            {\r\n                int temp = s[i]-'0';\r\n                while(s[i+1]>='0'&&s[i+1]<='9')\r\n                {\r\n                    ++i;\r\n                    temp = temp * 10 + s[i]-'0';\r\n                }\r\n                st_num.push(temp);\r\n            }\r\n            else if(s[i]==']')\r\n            {\r\n                string temp = \"\";\r\n                while(st_c.top()!='[')\r\n                {\r\n                    temp = st_c.top() + temp;\r\n                    st_c.pop(); \r\n                }\r\n                st_c.pop();\r\n                for(int j=0;j<st_num.top();++j)\r\n                {\r\n                    for(int k=0;k<temp.size();++k)\r\n                    {\r\n                        st_c.push(temp[k]);\r\n                    }\r\n                }\r\n                st_num.pop();\r\n            }\r\n            else\r\n            {\r\n                st_c.push(s[i]);\r\n            }\r\n        }\r\n        string res=\"\";\r\n        while(!st_c.empty())\r\n        {    \r\n            res = st_c.top() + res;\r\n            st_c.pop();\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919285183","body":"\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    Deque<Integer> out, in;\r\n    public MyQueue() {\r\n        in = new ArrayDeque<>();\r\n        out = new ArrayDeque<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        in.addLast(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (out.isEmpty()) {\r\n            while (!in.isEmpty()) out.addLast(in.pollLast());\r\n        }\r\n        return out.pollLast();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (out.isEmpty()) {\r\n            while (!in.isEmpty()) out.addLast(in.pollLast());\r\n        }\r\n        return out.peekLast();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return out.isEmpty() && in.isEmpty();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920145500","body":"\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int>maxStk;\r\n        maxStk.push(arr[0]);\r\n        for(int i=1;i<arr.size();i++){\r\n            if(arr[i]<maxStk.top()){\r\n                int maxNum=maxStk.top();\r\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\r\n                maxStk.push(maxNum);\r\n            }\r\n            else maxStk.push(arr[i]);\r\n        }\r\n        return maxStk.size();\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921021492","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        ListNode* first = head;\r\n        ListNode* second = new ListNode(0,head);\r\n        head = second;\r\n        int len = 0;\r\n        for(int i=0;i<k;++i)\r\n            if(first)\r\n                first = first->next;\r\n            else\r\n            {\r\n                len = i;\r\n                break;\r\n            }\r\n        if(len!=0)\r\n        {\r\n            int move = k % len;\r\n            first = head->next;\r\n            for(int i=0;i<move;++i)\r\n                first = first->next;\r\n        }\r\n        if(first)\r\n        {\r\n            second = head->next;\r\n            while(first->next)\r\n            {\r\n                first = first->next;\r\n                second = second->next;\r\n            }\r\n            first->next = head->next;\r\n            head->next = second->next;\r\n            second->next = nullptr;\r\n        }\r\n        return head->next;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921895740","body":"\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if((!head)||(!head->next))\r\n            return head;\r\n        ListNode *first = head;\r\n        ListNode *second = new ListNode(0,head);\r\n        ListNode *pre = second;\r\n        head = second;\r\n        second = first->next;\r\n        while(1)\r\n        {\r\n            pre->next = second;\r\n            first->next = second->next;\r\n            second->next = first;\r\n            if(first->next&&first->next->next)\r\n            {\r\n                pre = first;\r\n                first = first->next;\r\n                second = first->next;\r\n            }\r\n            else\r\n                break;\r\n        }\r\n        return head->next;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922328016","body":"\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    int getLength(ListNode* head) {\r\n        int ret = 0;\r\n        for (; head != nullptr; ++ret, head = head->next);\r\n        return ret;\r\n    }\r\n\r\n    TreeNode* buildTree(ListNode*& head, int left, int right) {\r\n        if (left > right) {\r\n            return nullptr;\r\n        }\r\n        int mid = (left + right + 1) / 2;\r\n        TreeNode* root = new TreeNode();\r\n        root->left = buildTree(head, left, mid - 1);\r\n        root->val = head->val;\r\n        head = head->next;\r\n        root->right = buildTree(head, mid + 1, right);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        int length = getLength(head);\r\n        return buildTree(head, 0, length - 1);\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922494987","body":"\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(!headA||!headB)\r\n            return nullptr;\r\n        ListNode *a = headA;\r\n        ListNode *b = headB;\r\n        while(a!=b)\r\n        {\r\n            if(!a)\r\n                a = headB;\r\n            else\r\n                a = a->next;\r\n            if(!b)\r\n                b = headA;\r\n            else\r\n                b = b->next;\r\n        }\r\n        return a;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Yufanzh":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917128012","body":"## Intuition\r\nTraverse the array from left to right, and then right to left. Both sides will iterative using the following logic:\r\ninitialize the location of c `lastc` as max_value, iterative through rray, if find char == c, then update `lastc = i`; else, update `distance = lastc - i`\r\ndo the same from end to begin\r\nthen the ans will be the minimum value comparing those two at each location.\r\n\r\n## Algorithm\r\ncode in python3\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = [0]*len(s)\r\n        lastc = float('inf')\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                lastc=i\r\n            else:\r\n                res[i] = abs(lastc-i)\r\n        for i in range(len(s))[::-1]:\r\n            ch = s[i]\r\n            if ch == c:\r\n                lastc = i\r\n            else:\r\n                res[i] = min(res[i], abs(lastc-i))\r\n        return res\r\n```\r\n## Complexity analysis\r\ntime complexity: O(len(s)\r\nextra space complexity: O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657653","body":"## Intuition\nThe hard part and tricky part is the increment function.\nSimple way is to use for loop and add incremental to each element in the last k positions, which will take O(N) time complexity to finish\nA tricky way to do it in O(1) time complexity is to create another array to record incremental value which we call `incr` array. We modify `incr` with `stack` array. Thus, when push, we also append 0 to `incr` array to keep it the same size as stack. When pop, since we only care about the element's value when it was popped, so we can modify it at the time of popping. So we can just modify `incr[k]` with val added to it. And the returned element from pop will be the element in the `stack` + popped element in the 'incr' array. At the same time, we will update the incr[-2] element with the incr[-1] to update the current last element in `incr` after popping.\n\n## Algorithm in python3\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        #track size, current element count,\n        self.max_size = maxSize\n        self.stack = []\n        self.incr = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n            self.incr.append(0)\n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        val = self.stack.pop()\n        if len(self.stack) >=1:\n            self.incr[-2] += self.incr[-1]\n        return val + self.incr.pop()\n    \n    def increment(self, k: int, val: int) -> None:\n        if self.stack:\n            self.incr[min(k, len(self.stack)) -1] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## Complexity Analysis\n- time complexity: O(1) for all functions\n- space complexity: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917714542","body":"## Intuition\n(only figure out how to do it in iterative way)\nUse stack structure to help figuring out this problem. Use two variables to store: `repeatStr` to record letters to be repeated, `repeatCnt`: the repeated numbers, respectively.\nbefore we met with \"]\", we push every character encountered into stack individually. \nWhen we met with \"]\", we start to pop and record. At the step, we will need to check the types of element at the top of stack.\nif \"[\", pop out and not record; if letter, add to `repeatStr`, if numbers, add to `repeatCnt` as strings.\nThen the answer would be \"repeatStr * int(repeatCnt)\"\n## Algorithm in python 3\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        #method-1:iterative way\n        #check the char types: number?letter?left or right parenthese\n        #left: push in stack; right: pop out of stack\n        stack = []\n        for c in s:\n            if c == \"]\":\n                #right parenthese start to triggle pop\n                repeatStr = \"\"\n                repeatCnt = \"\"\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n                # pop out [\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCnt = stack.pop() + repeatCnt\n                stack.append(repeatStr * int(repeatCnt))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```                            \n## Complexity analysis\n- Time complexity: O(N)\n- Space complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918726971","body":"## Intuition\nUse two stacks to record. One for push and another for pop\n## Algorithm in python\n```\nclass MyQueue:\n    ##use two stacks to accomplish this\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        ## initialize two stacks\n        self.stack = []\n        self.help_stack=[]\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        ## append always add element to the end\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        self.peek()\n        return self.help_stack.pop()\n        \n        \n        \n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if not self.help_stack:\n            while self.stack:\n                self.help_stack.append(self.stack.pop())\n        return self.help_stack[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not self.stack and not self.help_stack\n```\n## Complexity Analysis\n- Time complexity: O(1)  for push, pop amortized O(1)\n- Space complexity: O(N) because we use an extra stack to work with","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919709381","body":"## Intuition 1\nTricky solution. Use the idea that a valid chunk should satisfy the following pattern: the sum of all element in each chunk should equal to the sum of the same locations of element in sorted array \n## Algorithm 1 in python3\n```\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr2 = sorted(arr)\n        ans = 0\n        sum1 = sum2 = 0\n        for i in range(len(arr)):\n            sum1 += arr[i]\n            sum2 += arr2[i]\n            if sum1 == sum2:\n                ans += 1\n        return ans\n```\n## Complexity analysis 1\n- Time complexity: O(nlogn) with sort used in the solution\n- Space complexity: O(1)\n\n## Intuition 2\nUse the idea that a valid chunk should satisfy the following: the minimum element in the next chunk should larger than the maximum element in the previous chunk\nWe can use a curMax value to record the current max value, and a `backward` array where `backward[i]` indicate the minimum element in the range of [i, n-1]\n## Algorithm 2 in python3\n```\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        ans = 1\n        curMax = arr[0]\n        backward = [arr[-1]]*len(arr)\n        for i in range(len(arr)-2, -1, -1):\n            backward[i] = min(arr[i], backward[i+1])\n        for i in range(1, len(arr), 1):\n            if curMax <= backward[i]:\n                ans += 1\n            curMax = max(curMax, arr[i])\n        return ans\n```\n## Complexity analysis 2\n- Time complexity became O(N)\n- Space complexity became O(N) with a backward array needed\n## Intuition 3\nUse monotonous stack. If `arr[i] >= arr[i-1]`, push element into stack, if `arr[i] < arr[i-1]`, cannot push `arr[i]` to stack as this stack is monotonous. We will pop out the last element, record it as curMax. And then continue compare top of stack element with arr[i]; keep popping until top of stack element is no longer larger than `arr[i]`, then we can put the curMax back to stack.\nIn the end, the number of element in the stacks is equal to the number of chunks valid. (the elements in stack indicate the initial element for each valid chunk)\n##Algorithm 3 in python3\n```\ndef maxChunksToSorted(self, arr: List[int]) -> int:\n        ans = 1\n        stack =[]\n        for i in range(len(arr)):\n            if len(stack)==0 or stack[-1]<= arr[i]:\n                stack.append(arr[i])\n            else:\n                curMax = stack[-1]\n                stack.pop()\n                while len(stack) != 0 and stack[-1]>arr[i]:\n                    stack.pop()\n                stack.append(curMax)\n        return len(stack)\n```\n## Complexity analysis 3\n- Time complexity became O(2N)\n- Space complexity became O(N) with a monotonous stack needed","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920559991","body":"## Intuition\nfast slow two-pointer \n## Algorithm in pyhton3\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # boundary condition\n        if not head or not head.next or k == 0:\n            return head\n        #calculate length of linkedlist\n        length = 1\n        p0 = head\n        while p0.next:\n            p0 = p0.next\n            length += 1   \n        k = k % length\n        #fast slow two-pointer problem\n        p1 = head\n        p2 = head\n        while k>0:\n            p2 = p2.next\n            k -= 1\n        while p2.next:\n            p2 = p2.next\n            p1 = p1.next\n        p2.next = head\n        ans = p1.next\n        p1.next = None\n        return ans\n```\n## Complexity Analysis\n- Time complexity: O(N)\n- Space complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921488125","body":"## Intuition\nThree pointers, need to have a dummy point that can point to the new header in order to return the new header\nInteresting thing about three pointers in linked list is that, different with three pointers in array, those three pointers can have relations so that when you move, you can only define the first pointer, the 2nd and 3rd pointers would just be first.next and first.next.next\n## Algorithm in Java\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n       //boundary\n        if (head == null || head.next == null){\n            return head;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        head = dummy;\n        while (head != null && head.next != null && head.next.next != null){\n            ListNode p1 = head.next;\n            ListNode p2 = head.next.next;\n            \n            //swap\n            p1.next = p2.next;\n            p2.next = p1;\n            head.next = p2;\n            head = p1;   \n        }\n        return dummy.next;\n    }\n}\n```\n\n## Complexity Analysis\n - Time complexity: O(N)\n - Space complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922176414","body":"## Intuition\nLeetcode 108 is to convert arraylist to BST. We know that array[mid] should be root, and then we check left part and right part recursively to build BST. \nHere I choose to convert linked list to arraylist and perform the same flow. The reason is that arraylist is better at indexing at any location than linked list, time complexity will be O(1) for indexing in arraylist instead of O(N) in linked list\n\nAnother way is to use two pointers which is common for linked list related problem\n## Algorithm in python3\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        #help function, convert Array to BST\n        def sortedArrayToBST(array:List[int]) -> Optional[TreeNode]:\n            if not array: return\n            n = len(array)\n            mid = n//2\n            root = TreeNode(array[mid])\n            root.left = sortedArrayToBST(array[0:mid])\n            root.right = sortedArrayToBST(array[mid+1:n+1])\n            return root\n        # convert to array and then use help function\n        nums = []\n        p = head\n        while p:\n            nums.append(p.val)\n            p = p.next\n        return sortedArrayToBST(nums)\n```\n## Complexity Analysis\n - Time complexity: O(N)\n - Space complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922377782","body":"## Intuition\nFor linked list, double pointers are always a common trick\nThe critical part is headA and headB doesn't necessarily meet at intersection after same steps\nOne way to do it is to tranverse headA to headB, and then tranverse headB to headA, then their intersection will both appear in the end (or as nullptr)\n## Algorithm in Python3\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p1 = headA\n        p2 = headB\n        while p1 != p2:\n            if p1 == None:\n                p1 = headB\n            else:\n                p1 = p1.next\n            if p2 == None:\n                p2 = headA\n            else:\n                p2 = p2.next\n        return p1\n```\n## Complexity Analysis:\n- Time complexity: O(N) where n is the sum length of headA and headB\n- Space complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922520920","body":"## Intuition \nA typical two pointers (slow and fast pointers) problem.\nfirst of all, fast pointer goes twice the speed of the slower pointer. If they can eventually meet, then there is circle in the list; if fast pointer reaches to null, there is no circle.\nThen to find the starting point of the circle. We can re-direct either pointer back to head and then move in the same speed. Then they will meet at the starting point of the circle\n## Algorithm in python3\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        #slow and fast pointers\n        slow = head\n        fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if slow == fast:\n                break\n        if not fast or not fast.next:\n            return None\n        slow = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        return slow\n```\n## Complexity Analysis\n- Time complexity: O(N) since we need to traverse through the linked list\n- Space complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HuijunXu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917123316","body":"### 思路\r\n\r\n1. k求余\r\n2. 倒序相加\r\n3. 判断是否进1\r\n4. k除10，加上进一位\r\n\r\n### 代码\r\n\r\n```javascript\r\n var addToArrayForm = function(num, k) {\r\n    var p1 = 0;\r\n    var i=1;\r\n    while(k>0){\r\n        if((num.length-i)<0) num = [0].concat(num)\r\n        var rest = k%10\r\n        k = (k-rest)/10\r\n        var r = num[num.length-i]+rest+p1\r\n        if(r>9) k+=1\r\n        num[num.length-i] = r%10;\r\n        i++\r\n    }\r\n    return num\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(1)\r\n\r\n### 晒个结果\r\n\r\nAccepted\r\n156/156 cases passed (108 ms)\r\nYour runtime beats 85.28 % of javascript submissions\r\nYour memory usage beats 92.89 % of javascript submissions (42.1 MB)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917139121","body":"### 思路\r\n\r\n* 双指针\r\n\r\n### 代码\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n    var l = -1;\r\n    var n = -1;\r\n    var i =0;\r\n    var arr = [];\r\n    while(i<s.length){\r\n        if(n<=i){\r\n            n++;\r\n            while(s[n]!=c&&n<s.length){\r\n                n++\r\n            };\r\n        }\r\n        if(s[i]===c){\r\n            l = i;\r\n            arr[i]=0\r\n        }else{\r\n            if(l<0){\r\n                arr[i] = Math.abs(i-n)\r\n            }else if(n===s.length){\r\n                arr[i] = Math.abs(i-l)\r\n            } else{\r\n                arr[i]=Math.min(Math.abs(i-l),Math.abs(i-n))\r\n            }\r\n        }\r\n        i++\r\n    }\r\n    return arr\r\n};\r\n```\r\n### 复杂度分析\r\n时间：O(n)\r\n空间：O(n)\r\n\r\n### 结果\r\n\r\nAccepted\r\n76/76 cases passed (80 ms)\r\nYour runtime beats 79.89 % of javascript submissions\r\nYour memory usage beats 50.28 % of javascript submissions (40 MB)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918336609","body":"### 思路\r\n出栈\r\n### 代码\r\n\r\n```javascript \r\nvar decodeString = function(s) {\r\n    var i = 0;\r\n    var char;\r\n    var lastChar;\r\n    var nStack=[];\r\n    var sStack=[\"\"];\r\n    // var needSplit = false\r\n    while(i<s.length){\r\n        // console.log(sStack)\r\n        // console.log(nStack)\r\n        var char = s[i]\r\n        // console.log(char,\"123\")\r\n        if(char===\"[\"){\r\n            sStack.push(\"\")\r\n        }else if(char===\"]\"){\r\n            // needSplit = true\r\n            var n = nStack.pop();\r\n            var str = sStack.pop();\r\n            var r= \"\"\r\n            while(n>0){\r\n                r+=str;\r\n                n--\r\n            }\r\n            var l = sStack.length\r\n            sStack[l-1]+=r\r\n        }else if(char<=\"9\"){\r\n            if(lastChar<\"9\"){\r\n                const l = nStack.length;\r\n                nStack[l-1] = nStack[l-1]*10+parseInt(char)\r\n            }else{\r\n                nStack.push(parseInt(char));\r\n            }\r\n            \r\n        }else {\r\n                sStack[sStack.length-1]+=char\r\n        }\r\n        lastChar = char;\r\n        i++\r\n    }\r\n    // console.log(i,s.length)\r\n    return sStack.join(\"\")\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间 O(n)\r\n空间O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920142176","body":"## 思路\r\n分块最大<右侧最小\r\n##代码\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\n var maxChunksToSorted = function(arr) {\r\n    var leftMax = [];\r\n    var rightMin = [];\r\n    for(let i=0;i<arr.length;i++){\r\n        leftMax[i] = Math.max(arr[i],leftMax[i-1]||0);\r\n        rightMin[arr.length-i-1] = \r\n        Math.min(rightMin[arr.length-i]==undefined\r\n            ?Infinity\r\n            :rightMin[arr.length-i],\r\n            arr[arr.length-i-1])\r\n        // console.log(arr[arr.length-i])\r\n    }\r\n    // console.log(leftMax,rightMin)\r\n    var chunk = 0\r\n    for(let i=0;i<arr.length;i++){\r\n        if( \r\n            (i<(arr.length-1)&&\r\n            leftMax[i]<=rightMin[i+1])\r\n            || i===(arr.length-1)\r\n            ){\r\n            chunk++\r\n        }\r\n    }\r\n    return chunk\r\n\r\n};\r\n\r\n## 复杂度\r\n* 时间复杂度 O(n)\r\n* 空间复杂度 O(n )","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920940611","body":"```javascript\r\nvar rotateRight = function(head, k) {\r\n    if(!head||!k) return head;\r\n   var l= 1;\r\n   var node  = head;\r\n   while(node.next){\r\n       node = node.next;\r\n       l++\r\n   }\r\n   node.next = head;\r\n   k = k%l\r\n   if(k===0) {\r\n       node.next = null;\r\n       return head\r\n   }\r\n   k=l-k\r\n   while(k>0){\r\n       node = node.next;\r\n       k--\r\n   }\r\n   head = node.next;\r\n   node.next = null\r\n   return head\r\n};\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922337008","body":"\r\n```javascript\r\n\r\nvar getIntersectionNode = function(headA, headB) {\r\n    if(!headA||!headB) return null;\r\n    var pa = headA;\r\n    var pb = headB;\r\n    while(pa!==pb){\r\n        pa = pa==null?headB:pa.next;\r\n        pb = pb===null?headA:pb.next\r\n    }\r\n    return pa\r\n};\r\n```\r\n### 时间: O(n)\r\n### 空间: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917225566","body":"# java, 菜鸡解法\n```import java.util.Collections;\nimport java.util.ArrayList;\nimport java.util.*;\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n       char []arr=s.toCharArray();\n        int[]ans=new int[arr.length];\n      ArrayList<Integer> a=new ArrayList<Integer>();\n\n        for(int i=0; i<arr.length; i++)\n        {\n            if(arr[i]==c)\n                a.add(i);\n        }\n        for(int i=0; i<arr.length;i++)\n        {\n        ArrayList<Integer> list = new ArrayList<Integer>(); \n            for(int j=0;j<a.size();j++)\n            {\n               list.add(Math.abs(i-a.get(j)));\n            }\n             ans[i]=Collections.min(list);\n        }\n              return ans;\n    }\n}```\n时间复杂度o(n^2)\n空间复杂度0（n）\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917548006","body":"#设计增量栈\r\n-java\r\n-官方题解，用数组\r\n-主要学习如何设计函数\r\n\r\n```java\r\nimport java.util.Stack;\r\nclass CustomStack {\r\n int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n-时间复杂度O(N)\r\n-空间复杂度O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917815687","body":"#JAVA 栈\r\n```java\r\nimport java.util.*;\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n         String res = \"\";\r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resStack = new Stack<>();\r\n        int idx = 0;\r\n        while (idx < s.length()) {\r\n            if (Character.isDigit(s.charAt(idx))) {\r\n                int count = 0;\r\n                while (Character.isDigit(s.charAt(idx))) {\r\n                    count = 10 * count + (s.charAt(idx) - '0');\r\n                    idx++;\r\n                }\r\n                countStack.push(count);\r\n            }\r\n            else if (s.charAt(idx) == '[') {\r\n                resStack.push(res);\r\n                res = \"\";\r\n                idx++;\r\n            }\r\n            else if (s.charAt(idx) == ']') {\r\n                StringBuilder temp = new StringBuilder (resStack.pop());\r\n                int repeatTimes = countStack.pop();\r\n                for (int i = 0; i < repeatTimes; i++) {\r\n                    temp.append(res);\r\n                }\r\n                res = temp.toString();\r\n                idx++;\r\n            }\r\n            else {\r\n                res += s.charAt(idx++);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n时间复杂度O(N)\r\n空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918771803","body":"#JAVA\r\n```java\r\nimport java.util.*;\r\nclass MyQueue {\r\n        Stack<Integer> st1 = new Stack<Integer>();\r\n        Stack<Integer> st2 = new Stack<Integer>();\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n       while (!st2.isEmpty()) {\r\n            st1.push(st2.pop());\r\n        }\r\n\r\n        st1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n       while (!st1.isEmpty()) {\r\n       st2.push(st1.pop());\r\n       }\r\n       return st2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n       while (!st1.isEmpty()) {\r\n       st2.push(st1.pop());\r\n       }\r\n       return st2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n      return st1.isEmpty() && st2.isEmpty();\r\n    }\r\n}\r\n```\r\n时间复杂度O(1)\r\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919506126","body":"#java\n复制别人题解\n\n``` java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920954962","body":"```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n    if (head == null) {\r\n        return head;\r\n    }\r\n\r\n    int len = calculateLen(head);\r\n    k = k%len;\r\n\r\n    ListNode slow = head;\r\n    ListNode fast = head;\r\n\r\n    for(int i = 0; i < k; i++) {\r\n        fast= fast.next;\r\n    }\r\n    while (fast.next != null) {\r\n        fast = fast.next;\r\n        slow = slow.next;\r\n    }\r\n    fast.next = head;\r\n\r\n    head = slow.next;\r\n\r\n    slow.next = null;\r\n    return head;\r\n}\r\n\r\nprivate int calculateLen(ListNode head){\r\n    int len = 0;\r\n    while (head!=null) {\r\n        head = head.next;\r\n        len++;\r\n    }\r\n    return len;\r\n}\r\n\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921408463","body":"#JAVA 采用官方题解\r\n``` java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n       if(head == null || head.next == null) return head;\r\n        ListNode preNode = new ListNode(-1, head), res;\r\n        preNode.next = head;\r\n        res = head.next;\r\n         ListNode firstNode = head, secondNode, nextNode;\r\n           while(firstNode != null && firstNode.next != null)\r\n           {\r\n               secondNode = firstNode.next;\r\n               nextNode = secondNode.next;\r\n               firstNode.next=nextNode;\r\n               secondNode.next=firstNode;\r\n               preNode.next=secondNode;\r\n               preNode=firstNode;\r\n                firstNode = nextNode;\r\n           }\r\n           return res;\r\n    }\r\n}\r\n```\r\n时间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922328111","body":"#JAVA\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head != null) {\r\n            ListNode fast = head, slow = head, preSlow = null;\r\n\r\n            // 快慢指针移动\r\n            while(fast != null) {\r\n                fast = fast.next;\r\n                if(fast != null){\r\n                    fast = fast.next;\r\n                    preSlow = slow;\r\n                    slow = slow.next;\r\n                }\r\n            }\r\n\r\n            TreeNode treeNode = new TreeNode(slow.val);\r\n            treeNode.right = sortedListToBST(slow.next);\r\n            if(preSlow != null) {\r\n                preSlow.next = null;\r\n                treeNode.left = sortedListToBST(head);\r\n            }\r\n            return treeNode;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n时间复杂度O(N)\r\n空间复杂度o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922414394","body":"```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode a=headA;\r\n        ListNode b=headB;\r\n        while(a!=b)\r\n        {\r\n        if(a==null)\r\n         a=headB;\r\n         else\r\n         a=a.next;\r\n         if(b==null)\r\n         b=headA;\r\n         else\r\n         b=b.next;\r\n        }\r\n        return a;\r\n\r\n    }\r\n}\r\n```\r\n时间复杂度O(N)\r\n空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"simonsayshi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917895986","body":"补打卡\r\n从后前逐位相加\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n       \r\n        vector<int> res;\r\n        for(int i  = num.size() - 1;i >=0 ;i--) {\r\n            int cur = num[i] + k % 10;\r\n            k /= 10;\r\n            if(cur >= 10) {\r\n                k+=1;\r\n                cur-=10;\r\n            }\r\n            res.push_back(cur);\r\n        }\r\n        while(k>0) {\r\n            res.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;      \r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917243682","body":"```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        \n        vector<int>arr;int Last_Occ=-1;\n        int l;\n        for(int j = 0 ; j < s.length() ; j++)\n        {\n            size_t k = s.find(c,j);  \n            if(j==k)//found c at index j\n            {\n                arr.push_back(0);\n                Last_Occ=k;//store the latest index of occurence of char c\n            }\n            else{\n                if(Last_Occ==-1)//not reached index 'j' yet where s[j] == c\n\t\t\t\t\tarr.push_back(k-j);\n                else\n                {\n\t\t\t\t/* use  l = min(k - j , j - Last_Occ) */\n                    if( k - j <= j - Last_Occ)\n                        l = k - j;\n                    else\n                        l = j - Last_Occ;\n                    arr.push_back(l);\n                }\n            }\n            \n        }\n        return arr;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917927720","body":"string input分以下几种，数字，char，和左括号，右括号\n    数字之后必然是左括号，右括号可看作返回字符串的标记\n    遇到是数字的字符串，把字符串变成数字；\n    数字之后一定是左括号\n    左括号之后一定是字符\n    所以逻辑就变成，遇到数字字符，变成数字N，再把后面括号中的内容读取完（以右括号为终结），返回字符串，重复累加字符串N遍，返回\n```\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res;\n        int i = 0;\n        return helper(s, i);\n        \n    }\n    \n    string helper(string s, int& indx) {\n        string res = \"\";\n        \n        for(;indx<s.size();indx++) {\n            if(s[indx] == ']') {\n                break;\n            }else if(s[indx] < '0' || s[indx] > '9') {\n                res+= s[indx];\n            } else {\n                int count = 0;\n                while(s[indx] >= '0' && s[indx] <='9') {\n                    count = count * 10 + s[indx] - '0';\n                    indx++;\n                }\n                indx++;\n                string temp = helper(s, indx);\n                while(count != 0) {\n                    res+=temp;\n                    count--;\n                }\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918824253","body":"//双stack,需要pop和peek的时候在另一个stack中转换存放顺序\n\n```\nclass MyQueue {\n    stack<int> st1;\n    stack<int> st2;\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        st1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if(st2.empty()) {\n            transfer();\n        }\n        int cur = st2.top();\n        st2.pop();\n        return cur;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if(st2.empty()) {\n            transfer();\n        }\n        int cur = st2.top();\n        return cur;\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return st1.empty() && st2.empty();\n    }\n    \n    void transfer() {\n        while(!st1.empty()) {\n            int temp = st1.top();\n            st2.push(temp);\n            st1.pop();\n        }\n    }\n   ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919695605","body":"\r\n\r\n//单调栈，栈中元素单调递增， 当当前值比stack top小的时候（元素顺序有起伏）需要合并，栈中存放的是当前chunk的最大值\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> st;\r\n        int res = 0;\r\n        int curMax = INT_MIN;\r\n        for(int i = 0; i < arr.size();i++) {\r\n            if(!st.empty() && st.top() > arr[i]) {\r\n                int curMax = st.top();\r\n                st.pop();\r\n                while(!st.empty() && st.top() > arr[i]) {\r\n                    st.pop();\r\n                }\r\n                st.push(curMax);\r\n            }else {\r\n                st.push(arr[i]);\r\n            }\r\n        }\r\n        return st.size();\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920542722","body":"```\n//快慢指针找，找出链表长度，再对k%n取模以免重复rotate. 再用俩指针切断并重组链表\n\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* temp = head;\n        if(!head)\n            return NULL;\n        if(!head->next || k == 0)\n            return head;\n\n        int len = 1;\n        while(temp->next != NULL) {\n            temp = temp->next;\n            len++;\n        }\n        \n        k %= len;\n        if(k == 0)\n            return head;\n        \n        ListNode* tail = temp;\n        temp = head;\n        \n        for(int i = 0; i < len - k -1; i++) {\n            temp = temp->next;\n        }\n        ListNode* newNode = temp->next;\n        tail->next = head;\n        temp->next = NULL;\n        \n        \n        return newNode;\n    }\n};```\n\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922167993","body":"```\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        ListNode* temp = head;\n        vector<int> res;\n        while(temp != NULL) {\n            res.push_back(temp->val);\n            temp = temp->next;\n        }\n        \n        return helper(res, 0, res.size() - 1);    \n    }\n    \n    TreeNode* helper(vector<int>&res, int start, int end) {\n        \n        if(start > end) {\n            return NULL;\n        }\n        \n        int mid = (end + start) / 2;\n        TreeNode* root = new TreeNode(res[mid]);\n        TreeNode* left = helper(res, start, mid - 1);\n        TreeNode* right = helper(res, mid + 1, end);\n        root->left = left;\n        root->right = right;\n        return root;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"FlorenceLLL":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917256344","body":"先写一个自己想出来的暴力解决方法\r\n#### 思路\r\n1.首先找到c的所有位置，存在indexList数组中\r\n2.遍历s每个index - indexList的值，取最小，存到answer中\r\n\r\n#### 代码\r\n``` python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        ##找出所有c的位置\r\n        index = s.find(c)\r\n        indexList = []\r\n        indexList.append(index)\r\n\r\n        while (index != -1):\r\n            index = s.find(c,index + 1)\r\n            if(index != -1):\r\n                indexList.append(index)\r\n\r\n        ##计算s每个位置 - c所有的位置，取最小，存到list中\r\n        answer = []\r\n        for i in range(len(s)):\r\n            min = abs(i - indexList[0])\r\n            for j in range(len(indexList)):\r\n               if(abs(i-indexList[j]) < min):\r\n                   min = abs(i-indexList[j])\r\n            answer.append(min)\r\n        \r\n        return answer\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度 $$O(n^2)$$ 因为循环两次\r\n空间复杂度 $$O(n)$$ 因为新建了一个数组存answer","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661136","body":"### 思路\n用python list的基本操作+判断完成\n\n### 代码\n``` python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        self.stack = []\n        self.maxSize = maxSize\n        self.currentSize = 0\n        \n    def push(self, x):\n        if self.currentSize < self.maxSize:\n            self.stack.append(x)\n            self.currentSize += 1\n\n\n    def pop(self):\n        if self.currentSize > 0:\n            self.currentSize -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k, val):\n        for i in range(min(k,self.currentSize)):\n            self.stack[i] += val\n```\n\n### 复杂度分析\n#### 时间复杂度：\npush & pop：O(1)\nincrement：O(min(k, self.currentSize))\n\n#### 空间复杂度：\nO(maxSize) 主要是push在使用空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918337488","body":"``` python\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_num = 0\n        current_string = ''\n        for n in s:\n            if n == '[':\n                stack.append(current_string)\n                stack.append(current_num)\n                current_string = ''\n                current_num = 0\n            elif n == ']':\n                num = stack.pop()\n                previous_string = stack.pop()\n                current_string = previous_string + num*current_string\n            elif n.isdigit():\n                current_num = current_num*10 + int(n)\n            else:\n                current_string += n\n        return current_string\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919243641","body":"### 思路\r\n用两个栈来操作：\r\n1. 输入时全都输入到stack1\r\n2. 输出时：\r\n- stack2为空，将stack1 pop、push到stack2中，刚好reverse\r\n- stack2不空，直接从stack2 pop\r\n\r\nPS helper这个命名就很灵性，学到了\r\n\r\n### 代码\r\n``` python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        self.stack1 = [] ##入栈\r\n        self.stack2 = [] ##出栈\r\n\r\n\r\n    def push(self, x):\r\n        self.stack1.append(x)\r\n\r\n    def pop(self):\r\n        if len(self.stack2)==0:\r\n            while len(self.stack1)>0:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n    def peek(self):\r\n        if len(self.stack2)==0:\r\n            while len(self.stack1)>0:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n    def empty(self):\r\n        return len(self.stack1)==0 and len(self.stack2)==0\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921009240","body":"### 思路\n边挪边比较k和链表的长度\n\n### 代码\n``` python\nclass Solution:\n    def rotateRight(self, head, k) :\n         if not head or k == 0:\n            return head\n        right = head\n        temp = k\n        while right.next and k:\n            right = right.next\n            k -= 1\n        if k:\n            k -= 1\n            k %= temp - k\n            return self.rotateRight(head, k)\n\n        left = head\n        while right.next:\n            left = left.next\n            right = right.next\n\n        right.next = head\n        head = left.next\n        left.next = None\n\n        return head\n```\n\n之前背的答案\n\n### 复杂度分析\n时间复杂度： O(n)\n空间复杂度： O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"devosend":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917302280","body":"## 思路\n遍历两次字符串，找到当前字符距离左边和右边第一个目标字符的距离，存储较小的值\n\n## 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        index = -len(s)\n\n        for i in range(len(s)):\n            if s[i] == c:\n                index = i\n            \n            ans.append(i - index)\n\n        # index = len(s)\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                index = i\n            \n            ans[i] = min(ans[i], abs(index - i))\n        \n        return ans\n\n```\n\n## 复杂度分析\n- 时间复杂度: O(n)\n- 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"comst007":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917314532","body":"[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n----\r\n\r\n### 思路\r\n\r\nmin_dist[i] = min(dist_to_left[i], dist_to_right[i])\r\n\r\n\r\n----\r\n### 代码\r\n\r\n```cpp\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> ans(s.size());\r\n        int pos_c = -10009;\r\n        for(int ii = 0; ii < s.size(); ++ ii){\r\n            if(s[ii] == c){\r\n                pos_c = ii;\r\n                ans[ii] = 0;\r\n                continue;\r\n            }\r\n            ans[ii] = ii - pos_c;\r\n        }\r\n        pos_c = 20009;\r\n        for(int jj = s.size() - 1; jj >= 0;  -- jj){\r\n            if(s[jj] == c){\r\n                pos_c = jj;\r\n                ans[jj] = 0;\r\n                continue;\r\n            }\r\n            ans[jj] = min(ans[jj], pos_c - jj);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n};\r\n\r\n``` \r\n\r\n----\r\n\r\n**复杂度分析**\r\n-   分别从左右两边遍历一边 `O(n)`\r\n-   `O(1)`\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917486247","body":"[1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n----\n\n### 思路\n内部通过变量记录当前元素个数和最大元素个数\n内部通过 `vector<int>`类型的数组存储栈中的数据\n\n\n----\n### 代码\n\n- C++\n\n```cpp\nclass CustomStack {\nprivate:\n    int _maxSize;\n    vector<int> _nums;\n    int _curSize;\npublic:\n    CustomStack(int maxSize) {\n        _maxSize = maxSize;\n        _curSize = 0;\n    }\n    \n    void push(int x) {\n        if(_curSize >= _maxSize) return;\n        ++_curSize;\n        _nums.push_back(x);\n    }\n    \n    int pop() {\n        if(_curSize <= 0) return -1;\n        int tmp = _nums[--_curSize];\n        _nums.pop_back();\n        return tmp;\n    }\n    \n    void increment(int k, int val) {\n        int jj = k > _curSize? _curSize : k;\n        for(int ii = 0; ii < jj; ++ ii){\n            _nums[ii] += val;\n        }\n    }\n};\n\n\n``` \n\n----\n\n**复杂度分析**\n-   incement 为$O(k)$, 其余为$O(1)$\n-   空间复杂度  $O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917695691","body":"[394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n----\n\n### 思路\n借助数据结构 中的 栈。一个栈用来存储中间计算结果st1，一个栈用来存储出现次数 st2。\n从头开始扫描：\n - 遇到连续是数字的字符把它转化成最终的整数存入到st2中。\n - 遇到的字符是大小写字母或者`[`就把它存储到st1 中。\n- 遇到的字符是`]`， 则逐渐弹出st1中的字符，直到`[`。弹出的字符形成的字符串记为s_tmp，然后从st2中弹出一个整数s_feq，最后将s_tmp重复s_feq次，然后把结果存入st1中。\n\n最后返回st1中的字符构成的字符串。\n\n\n----\n### 代码\n\n* C++\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        vector<int> num_st;\n        vector<char> ch_st;\n        for(int ii = 0, cur_cnt = 0; ii < s.size(); ++ ii){\n            if(s[ii] <= '9' && s[ii] >= '0'){\n                cur_cnt = cur_cnt * 10 + s[ii] - '0';\n                continue;\n            }\n            if(cur_cnt > 0){\n                 num_st.push_back(cur_cnt);\n                 cur_cnt = 0;\n            }\n            \n            if( (s[ii] <= 'z' && s[ii] >= 'a') || (s[ii] <= 'Z' && s[ii] >= 'A') || (s[ii] == '[')){\n                ch_st.push_back(s[ii]);\n                continue;\n            }\n            if(s[ii] == ']'){\n                vector<char> tmp_ch;\n                while(ch_st.back() != '['){\n                    tmp_ch.push_back(ch_st.back());\n                    ch_st.pop_back();\n                }\n                ch_st.pop_back();\n                int feq = num_st.back();\n                num_st.pop_back();\n                while(feq --){\n                    for(int jj = tmp_ch.size() - 1; jj >= 0; -- jj){\n                        ch_st.push_back(tmp_ch[jj]);\n                    }\n                }\n            }\n        }\n\n        return string(ch_st.begin(), ch_st.end());\n    }\n\n\n};\n\n``` \n\n----\n\n**复杂度分析**\n假设最终的解码后的字符串长度为m\n-   时间复杂度  遍历一遍字符串的字符 `O(m)`\n-   空间复杂度 需要借助栈来辅助计算 `O(m)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918456729","body":"[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n----\n\n### 思路\n- 内部使用两个栈`st_in`， `st_out`， 和一个记录`st_in`栈底的`in_base`。\n- 执行`push(x)`的时候， 将`x`放入`st_in`这个栈，如果在入栈之前`st_in` 为空，则`in_base = x`。\n- 执行`pop()`的时候， 如果`st_out`为空，则先将`st_in`中的数据出栈然后压入`st_out`栈中。将`st_out`栈顶弹出。\n- 执行`peek()`的时候， 如果`st_out`为空，则队列的第一个元素是`in_st`的栈底元素， 返回`in_base`， 如果`st_out`不为空， 则返回'st_out'的栈顶元素.。\n- 执行`empty()`的时候， 如果`st_in` 和 `st_out`都为空则返回`true`, 否则返回`false`。\n\n\n----\n### 代码\n\n* C++\n\n```cpp\nclass MyQueue {\nprivate:\n    stack<int> st_in;\n    stack<int> st_out;\n    int in_base;\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        if(st_in.empty()){\n            in_base = x;\n        }\n        st_in.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if(st_out.empty()){\n            while(!st_in.empty()){\n                st_out.push(st_in.top());\n                st_in.pop();\n            }\n        }\n        int tp = st_out.top();\n        st_out.pop();\n        return tp;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if(st_out.empty()){\n            return in_base;\n        }\n\n        return st_out.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return st_in.empty() && st_out.empty();\n    }\n};\n``` \n\n----\n\n**复杂度分析**\n\n栈中元素规模为n\n-   时间复杂度： `push`操作为`O(1)`, `empty`操作为`O(1)`， `peek`操作为`O(1)`， `pop`操作因为在'st_out'为空的时候会发生数据从'st_in'转移到'st_out'的操作，`st_in`中的数据都会经历一次出栈入栈操作。所以`pop`操作并不是每次操作都是`O(1)`。\n-   空间复杂度 ：`O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919451962","body":"[768. 最多能完成排序的块II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\n----\n\n### 思路\n\n使用贪心算法。\n假设原数组为`arr`， 排序后的数组为`brr`。如果`arr`中下标区间`[l  r]`中的数据为一个块的话，那么，该块中的数据也一定位于排序后的`brr`的相同的区间内。\n现在的问题就转化成了 如何判断两个数组在区间`[l r]`内的数据完全相同，但顺序可能不同。\n这里需要借助哈希表。\n\n\n----\n### 代码\n\n* C++\n\n```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        auto brr = arr;\n        sort(brr.begin(), brr.end());\n        int ans = 0;\n        unordered_map<int, int> freq;\n        for(int ii = 0, z = 0; ii < arr.size(); ++ ii){\n            if(freq[arr[ii]] == 1){\n                z -- ;\n            }else if(freq[arr[ii]] == 0){\n                z ++;\n            }\n            freq[arr[ii]] -- ;\n\n            if(freq[brr[ii]] == -1){\n                z --;\n            }else if(freq[brr[ii]] == 0){\n                z ++ ;\n            }\n            freq[brr[ii]] ++ ;\n\n            if(z == 0) ++ ans;\n        }\n        return ans;\n    }\n};\n\n``` \n\n----\n\n**复杂度分析**\n-   时间复杂度  需要对原数组排序需要`O(nlogn)`，然后遍历一遍数组`O(n)`\n-   空间复杂度   需要额外空间存储 排序的数组 。在判断区间元素是否相同的时候需要借助哈希表。`O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920346650","body":"[61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n----\n\n### 思路\n\n先遍历一遍链表，求得链表长度 `ln`， 如果  `k > ln`， 则`k = k % ln`将`k`的范围转换到`0 ~ ln - 1`。原链表的尾节点为`taill`。\n\n求得新链表的尾节点`ptail` （原链表第`ln - k` 个节点），  头节点`phead`(`ptail`在原链表的下一个节点)。\n\n然后`ptail -> next = NULL; taill -> next = head`。\n\n\n----\n### 代码\n\n* C++\n\n```cpp\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr || k == 0) return head;\n        int ln = 0;\n        ListNode *ptmp, *pt;\n        ptmp = head;\n        while(ptmp){\n            ++ ln;\n            pt = ptmp;\n            ptmp = ptmp -> next;\n        }\n        k = k % ln;\n\n        if(k == 0) return head;\n        \n        ListNode *ph;\n\n        ptmp = head;\n        for(int ii = 0; ii < ln - k - 1; ++ ii){\n            ptmp = ptmp -> next;\n        }\n        \n        pt -> next = head;\n        head = ptmp -> next;\n        ptmp -> next = nullptr;\n\n        return head;\n    }\n};\n\n``` \n\n----\n\n**复杂度分析**\n-   时间复杂度  `O(n)`\n-   空间复杂度  `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921515226","body":"# [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n----\n\n## 思路\n\n`pfast`, `pslow`, `ppre`分别指向要交换的两个节点以及其前一个结点.\n\n交换过程  \n\n\n> ptmp = pfast -> next;  \n> pfast -> next = pslow;  \n> pslow -> next = ptmp;  \n> pre -> next = pfast;  \n> ppre = pslow;  \n\n\n----\n\n## 代码\n\n* C++\n  \n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head || !head ->next) return head;\n\n        ListNode *pfast, *pslow, *ptmp, *ppre;\n        ListNode *dummy = new ListNode();\n        dummy -> next = head;\n\n        ppre = dummy;\n        pslow = head;\n        pfast = pslow -> next;\n        \n        while(true){\n\n            ptmp = pfast -> next;\n            pfast -> next = pslow;\n            pslow -> next = ptmp;\n            ppre ->next = pfast;\n            ppre = pslow;\n\n            if(!ptmp){\n                //ppre -> next = NULL;\n                break;\n            }\n\n            pslow = ptmp;\n            if(!pslow -> next) break;\n            pfast = pslow -> next;\n            \n\n            \n        }\n        return dummy -> next;\n    }\n};\n\n\n```\n\n----\n\n## **复杂度分析**\n\n* 时间复杂度 $O(n)$\n* 空间复杂度 $O(1)$\n  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922169323","body":"# [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n----\n\n## 思路\n\n* 分治思想\n\n    1. 将链表的中间节点转化成二叉搜索树的根节点。\n    2. 将链表左半部分递归转化成二叉搜素树的左子树。\n    3. 将链表右半部分递归转化成二叉搜索树的右子树。 \n\n## 代码\n\n* C++\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(!head) return NULL;\n        if(!head -> next) return new TreeNode(head -> val);\n\n        int n = 0;\n        ListNode *p = head;\n        while(p){\n            ++ n;\n            p = p -> next;\n        }\n        int mid = (n + 1) >> 1;\n        p = head;\n        for(int ii = 0; ii < mid - 2; ++ ii){\n            p = p -> next;\n        }\n        TreeNode *root = new TreeNode(p -> next -> val);\n        root -> right = sortedListToBST(p -> next -> next);\n        p -> next = NULL;\n        root -> left = sortedListToBST(head);\n\n        return root;\n        \n\n    }\n};\n```\n\n----\n\n## **复杂度分析**\n\n* 时间复杂度 $O(nlogn)$\n* 空间复杂度 $O(1)$\n  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922413475","body":"# [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n----\n\n## 思路\n\n* 双指针。`heada`, `headb` 分别为两个链表`lista`, `listb`的头指针。\n\n    1. 初始 `pa = heada`, `pb = headb`。\n    2. 如果 `pa` 不空， 则`pa = pa -> next`, 否则 `pa = headb`。同理`pb`。\n    3. 直到 `pa == pb`推出循环。则 `pa`就是所指向的公共链表的头节点。\n\n## 代码\n\n* C++\n\n```cpp\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* pa = headA;\n        ListNode* pb = headB;\n        while(pa != pb){\n            if(pa){\n                pa = pa ->next;\n            }else{\n                pa = headB;\n            }\n            if(pb){\n                pb = pb -> next;\n            }else{\n                pb = headA;\n            }\n        }\n        return pa;\n\n        \n    }\n};\n```\n\n----\n\n## **复杂度分析**\n\n* 时间复杂度 $O(m + n)$, m, n分表为链表的长度。\n* 空间复杂度 $O(1)$\n  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922520804","body":"# [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n----\n\n## 思路\n\n 快慢指针。`fast`, `slow` 初始都是指向链表头。每次  `fast`走两步, `slow`每次走一步。  \n如果存在环，因为`fast`速度是`slow`的两倍, `fast`会追赶上`slow`。如果不存在环，则`fast`会先走到链表结尾。  \n\n 如果存在环，`slow`从链表起点重新走,`fast`则继续从相遇的结点走，只是每次走一步。当两个指针再次相遇的时候就是环的起始节点。\n\n## 代码\n\n* C++\n\n```cpp\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(!head) return head;\n        ListNode *fast, *slow;\n        fast = head;\n        slow = head;\n        int start = 1;\n        while(fast && (start || fast != slow)){\n            if(start == 1) start = 0;\n            if(!fast -> next) return NULL;\n            fast = fast -> next;\n            if(!fast -> next) return NULL;\n            fast = fast -> next;\n\n            slow = slow -> next;\n        }\n        if(!fast) return NULL;\n\n        slow = head;\n        while(slow != fast){\n            slow = slow -> next;\n            fast = fast -> next;\n        }\n        return slow;\n    }\n};\n```\n\n----\n\n## **复杂度分析**\n\n* 时间复杂度 $O(n)$, n 为链表节点数。\n* 空间复杂度 $O(1)$\n  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917145787","body":"**思路:**\r\n从array最末端和k的个位开始加, 有进位就记下来,下一轮循环加上. \r\n每一轮循环把算出来的当前值个位push到栈里面.\r\n最后把栈里的东西依次拿出来放进一个要return的vector中.\r\n\r\n**代码**\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int shouldAdd = 0;\r\n        stack<int> sum;\r\n        int i = num.size() -1;\r\n        while(k > 0 || i >= 0){\r\n\r\n            int curr;\r\n            if(k <= 0){\r\n                curr = 0;\r\n            }\r\n            else{\r\n                curr = k % 10;\r\n            }\r\n            if(i >= 0){\r\n                curr = curr +num[i] + shouldAdd;\r\n            }\r\n            else{\r\n                curr += shouldAdd;\r\n            }\r\n            \r\n            \r\n            if(curr > 9){\r\n                shouldAdd = 1;\r\n                curr -= 10;\r\n            }\r\n            else{\r\n                shouldAdd = 0;\r\n            }\r\n            sum.push(curr);\r\n            k /= 10;\r\n            --i;\r\n        }\r\n        if(shouldAdd){\r\n            sum.push(shouldAdd);\r\n        }\r\n        vector<int>ret;\r\n        while(!sum.empty()){\r\n            ret.push_back(sum.top());\r\n            sum.pop();\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n\r\n**复杂度分析**\r\n时间: O(n)\r\n空间: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917330206","body":"### 思路\r\n官方题解里的贪心算法，\r\n### 代码\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n       int n = S.length();\r\n       vector<int> ret(n,n);\r\n       for(int i = 0; i < n; ++i){\r\n           if(S[i] == C){\r\n               ret[i] = 0;\r\n           }\r\n           else if(i > 0){\r\n               ret[i] = ret[i - 1] + 1;\r\n           }\r\n       }\r\n\r\n       for(int i = n -1; i >= 0; --i){\r\n           if(ret[i] == n || (i < n-1 && ret[i+ 1] + 1 < ret[i]) ){\r\n               ret[i] = ret[i + 1] + 1;\r\n           }\r\n       }\r\n       return ret;\r\n       \r\n    }\r\n};\r\n### 复杂度\r\n时间O（n）\r\n空间O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917332543","body":"# Python 思路\n先遍历s，将位置记录下\n再遍历一遍s，计算s中的元素到每一个位置的距离，取最小值（双重循环）\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        position = []\n        distance = []\n        for i,item in enumerate(s):\n            if item == c:\n                position.append(i)\n                continue\n        print(position)\n\n        for i in range(len(s)):\n            dist = []\n            for p in range(len(position)):\n                if len(position)==1:\n                    d = abs(i-position[p])\n                else:\n                    dist.append(abs(i-position[p]))\n                    d = min(dist)\n            distance.append(d)\n\n\n        return distance\n```\n时间复杂度：O（N*K）\n空间复杂度：O（K）\nK为c在s中出现的次数\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917552614","body":"# 思路：维护一个数组\n```\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.data = []\n        self.maxSize = maxSize\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.data) < self.maxSize:\n            self.data.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.data)==0:\n            return -1\n        else:\n            value = self.data.pop(-1)\n            return value\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if len(self.data)<k:\n            for i in range(len(self.data)):\n                (self.data)[i] += val\n        else:\n            for i in range(0,k):\n                (self.data)[i] += val\n```\n时间复杂度：O（1）\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918254503","body":"# 思路\n迭代法，遇到 ] 前不断入栈，然后出栈直到遇到数字。遇到数字就重复，再压入栈中。重复出栈操作直到碰到[\n```\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for c in s:\n            if c== ']':\n                repstr=''\n                repcount=''\n\n                #遇到 [ 前不断出栈\n                while stack and stack[-1] != '[':\n                    repstr = stack.pop() + repstr\n                #pop出'['\n                stack.pop()\n                #遇到数字就相加(字符串格式)\n                while stack and stack[-1].isnumeric():\n                    repcount = stack.pop() + repcount\n                stack.append(repstr * int(repcount))\n                #不是]直接入栈\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```\n时间复杂度：O(n)\n空间复杂度：O(n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919056219","body":"# 思路：\n入队时先将栈中的所有元素依次出栈，再入栈到辅助栈中，再将新元素放到辅助栈的栈顶，接着讲辅助栈元素依次入栈即可\n```\nclass MyQueue(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []\n        self.aux_stack= []\n\n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: None\n        \"\"\"\n        while self.stack:\n            self.aux_stack.append(self.stack.pop())\n        self.aux_stack.append(x)\n        while self.aux_stack:\n            self.stack.append(self.aux_stack.pop())\n\n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        return self.stack.pop()\n\n\n    def peek(self):\n        \"\"\"\n        Get the front element.\n        :rtype: int\n        \"\"\"\n        return self.stack[-1]\n\n\n    def empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        if self.stack:\n            return False\n        else:\n            return True\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n时间复杂度:O(N)\n空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920032934","body":"# 解题思路\n维护两个字典，分别表示原始数列与已排序数列中各个数字出现的次数，如果二者相同，则课分桶。\n```\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        count_1 = {}\n        count_2 = {}\n        # 初始化字典\n        for i in arr:\n            count_1['{}'.format(i)] = 0\n            count_2['{}'.format(i)] = 0\n        num = 0\n\n        for a,b in zip(arr, sorted(arr)):\n            #统计每个元素出现的次数\n\n            count_1['{}'.format(a)] += 1\n            count_2['{}'.format(b)] += 1\n            #相等则可分桶\n            if count_1 == count_2:\n                num +=1\n        return num\n```\n时间复杂度:O(N)\n空间复杂度O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921862283","body":"# 思路\n关注待交换节点的前驱和后继\n```\nclass ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next: \n            return head\n        ans = ListNode(next=head)\n        ans.next = head.next\n        pre = ans\n        while head and head.next:\n            next = head.next\n            n_next = next.next\n\n            next.next = head\n            pre.next = next\n            head.next = n_next\n            # 更新指针\n            pre = head\n            head = n_next\n        return ans.next\n```\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x-joey":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917335984","body":"## 思路\n暴力法：\n首先记录c在字符串中出现的下标，并保存在list中\n然后遍历字符串，字符串中每一位下标和list中的下标相减取绝对值，并保存最小的一个\n## 关键点\n\n-  值得注意的是，看了题解，我的代码可以在两个地方优化\n1. 在两层循环时候，一旦遇到字符c，就不需要进入内循环\n2. 在内循环中，一旦遇到距离大于之前的距离，就可以直接退出内循环，因为是顺序的，后面的距离肯定更大。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        List<Integer> list = new ArrayList();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i) == c){\n                list.add(i);\n            }\n        }\n        int res[] = new int[s.length()];\n        \n        for(int i=0;i<s.length();i++){\n            int min=Integer.MAX_VALUE;\n            for(int j=0;j<list.size();j++){\n                int abs = Math.abs(i-list.get(j));\n                min = Math.min(abs,min);\n            }\n            res[i] = min;\n        }\n        return res;\n\n    }\n}\n\n```\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n*m)$n是数组长度，m是字符串中出现c的个数\n- 空间复杂度：$O(n)$\n\n```java\n//从左往右和从右往左遍历\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int ans[] = new int[n];\n        int prev = Integer.MIN_VALUE/2;//注意越界，所以除以2\n\n        for(int i=0;i<n;i++){\n            if(s.charAt(i)==c){\n                prev = i;\n            }\n            ans[i] = i-prev;\n        }\n       prev = Integer.MAX_VALUE/2;\n        for(int i=n-1;i>=0;i--){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i],prev-i);\n        }\n        return ans;\n    }\n}\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$n是数组长度\n- 空间复杂度：$O(n)$\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922227702","body":"## 思路\n将链表所有节点存放到list中，然后二分找到子树的根节点，递归构建二叉树\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head ==null) return null;\n        if(head.next == null) return new TreeNode(head.val);\n\n        List<Integer> list = new ArrayList();\n        //先存到list里面，然后再创建树\n        while(head !=null){\n            list.add(head.val);\n            head = head.next;\n        }\n        return buildTree(0,list.size()-1,list);\n    }\n    public TreeNode buildTree(int left,int right, List<Integer> list){\n        if(left>right) return null;\n        int mid = left + (right-left+1)/2;\n\n        TreeNode root = new TreeNode(list.get(mid));\n        root.left = buildTree(left,mid-1,list);\n        root.right = buildTree(mid+1,right,list);\n        return root;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biancaone":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917338278","body":"### 思路\n先转成string, 然后是int, 与k做计算，然后再把结果转成array\n\n### 代码\n```python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        result = ''\n        for i in range(len(num)):\n            result += str(num[i])\n\n        result = int(result)\n\n        result += k\n\n        return [int(i) for i in str(result)]\n```\n### 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917337981","body":"### 思路\n对于string 中的每个charater, 比较离它最近的左右两边target charater的距离，返回最小值\n\n### 代码\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        if not s:\n            return []\n\n        result = [0 for i in range(len(s))]\n\n        prev = -sys.maxsize\n\n        for i in range(len(s)):\n            if s[i] == c:\n                prev = i\n            result[i] = i - prev\n\n        prev = sys.maxsize\n\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                prev = i\n            result[i] = min(result[i], prev - i)\n\n        return result\n```\n### 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917494514","body":"### 思路\n重点，难点其实是inc功能的实现。\n\n****\n### 代码\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.n = maxSize\n        \n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.n:\n            self.stack.append(x)\n        \n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n\n```\n****\n### 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)\n****","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917685635","body":"### 思路\n用栈来记录number和之前的字符串。遇到左括号，就压栈，遇到右括号，弹栈，并更新当前的字符串。\n\n****\n### 代码\n```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        if not s:\n            return ''\n        \n        stack = []\n        \n        cur_string = ''\n        cur_num = 0\n        \n        for char in s:\n            if char == '[':\n                stack.append(cur_string)\n                stack.append(cur_num)\n                cur_string = ''\n                cur_num = 0\n            elif char == ']':\n                prev_num = stack.pop()\n                prev_string = stack.pop()\n                cur_string = prev_string + cur_string * prev_num\n            elif char.isdigit():\n                cur_num = cur_num * 10 + int(char)\n            else:\n                cur_string += char\n                \n        \n        return cur_string\n```\n****\n### 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)\n****","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918768730","body":"### 思路\n一个栈用来存数据，一个栈用来存弹出来的数据，利用栈的特性，先进后出，所以需要第二个栈来保存弹出来的数据，那么最后一个也就是第一个。\n\n****\n### 代码\n```python3\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n        \n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n        \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        self.peek()\n        return self.stack2.pop()\n        \n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        while not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n                \n        return self.stack2[-1]\n        \n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not self.stack1 and not self.stack2\n```\n****\n### 复杂度\n- 时间复杂度 均摊复杂度都是O(1)\n- 空间复杂度 O(n)\n****","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919673850","body":"### 思路\n这道题我自己想的不好实现，队友用脑经急转弯的思路给我讲了这道题，非常好理解。就是复杂度上要到了Nlogn.\n先排序arr,做到一个目标arr,然后开始把目标arr一项项加和，与之前的arr一项项的和做对比。如果和一样，那么可以切一刀，如果和不一样，那么就不能切。\n\n****\n### 代码\n```python3\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n        \n        sorted_arr = sorted(arr)\n        result = 0\n        \n        arr_sum = 0\n        sorted_sum = 0\n        \n        for i in range(len(arr)):\n            arr_sum += arr[i]\n            sorted_sum += sorted_arr[i]\n            \n            if arr_sum == sorted_sum:\n                result += 1\n                \n                \n        return result\n```\n****\n### 复杂度\n- 时间复杂度 O(nlogn)\n- 空间复杂度 O(n)\n****\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920549023","body":"### 思路 🏷️\n找到新的头和新的尾巴是关键。k取余，是因为当k的长度超过了链表的长度，k-length与k效果是一致的。\n\n****\n### 代码 📜\n\n```python3\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        # find the length of the linkedlist\n        length = 1\n        tail = head\n        while tail.next:\n            tail = tail.next\n            length += 1\n            \n        k %= length\n        if k == 0:\n            return head\n        \n        # find the prev node\n        prev = head\n        # 这个地方举个例子\n        for i in range(length - k - 1):\n            prev = prev.next\n        \n        new_head = prev.next\n        prev.next = None\n        tail.next = head\n        \n        return new_head\n```\n****\n### 复杂度 :package:\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)\n****","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921430850","body":"### 思路 🏷️\n多画图，找到断开和链接的位置。\n\n****\n### 代码 📜\n\n```python3\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = ListNode(-1)\n        dummy.next = head\n        prev = dummy\n        \n        while prev.next and prev.next.next:\n            self.swap(prev)\n            prev = prev.next.next\n            \n        return dummy.next\n    \n    def swap(self, prev):\n        dummy1 = prev.next\n        prev.next = dummy1.next\n        dummy1.next = dummy1.next.next\n        prev.next.next = dummy1\n```\n****\n### 复杂度 📦\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)\n****","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922177391","body":"### 思路 🏷️\r\n递归的题，思路就是多练习，多想几遍。想明白第一层就可以。\r\n\r\n****\r\n### 代码 📜\r\n\r\n```python3\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        \r\n        nums = []\r\n        \r\n        while head:\r\n            nums.append(head.val)\r\n            head = head.next\r\n            \r\n        return self.helper(nums, 0, len(nums) - 1)\r\n    \r\n    \r\n    def helper(self, nums, left, right):\r\n        if left > right:\r\n            return None\r\n        \r\n        mid = (left + right) // 2\r\n        root = TreeNode(nums[mid])\r\n        \r\n        root.left = self.helper(nums, left, mid - 1)\r\n        root.right = self.helper(nums, mid + 1, right)\r\n        \r\n        return root\r\n```\r\n****\r\n### 复杂度 📦\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)\r\n****\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922355759","body":"### 思路 🏷️\n追及问题，如果有相交，那么遇到的那一刻，走过的路程应该是一样的。\n\n****\n### 代码 📜\n\n```python3\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return None\n        \n        p1 = headA\n        p2 = headB\n        \n        while p1 != p2:\n            if p1:\n                p1 = p1.next\n            else:\n                p1 = headB\n                \n            if p2:\n                p2 = p2.next\n            else:\n                p2 = headA\n                \n        return p1\n```\n****\n### 复杂度 📦\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)\n****","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917339015","body":"Two pass\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int c_position = -n;\n        int[] ans = new int[n];\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                c_position = i;\n            }\n            ans[i] = i - c_position;\n        }\n        \n        for (int j = n - 1; j >= 0; j--) {\n            if (s.charAt(j) == c) {\n                c_position = j;\n            }\n            ans[j] = Math.min(ans[j], Math.abs(j - c_position));\n        }\n        return ans;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917644802","body":"Imple w/ ArrayList\nclass CustomStack {\n    \n    int n;\n    List<Integer> myStack = new ArrayList<>();\n    \n    public CustomStack(int maxSize) {\n        n = maxSize;\n    }\n    \n    public void push(int x) {\n        if (myStack.size() < n) {\n            myStack.add(x);\n        }\n    }\n    \n    public int pop() {\n        if (!myStack.isEmpty()) {\n            return myStack.remove(myStack.size() - 1);\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < myStack.size(); i++) {\n            myStack.set(i, myStack.get(i) + val);\n        }\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918383878","body":"\nclass MyQueue {\n    Stack<Integer> s1 = new Stack<>();\n    Stack<Integer> s2 = new Stack<>();\n    int front;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        this.front = front;\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        if (s1.isEmpty()) {\n            front = x;\n        }\n        while (!s1.isEmpty()) {\n            s2.push(s1.pop());\n        }\n        s2.push(x);\n        while (!s2.isEmpty()) {\n            s1.push(s2.pop());\n        }  \n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (!s1.isEmpty()) {\n            int pop = s1.pop();\n            if (!s1.isEmpty()){\n                front = s1.peek();\n            }\n            return pop;\n        }\n        return -1;\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        return front;\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return s1.isEmpty();\n    }\n}\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922167435","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        return dfs(head, null);\n    }\n    \n    private TreeNode dfs(ListNode head, ListNode tail) {\n        if (head == tail) return null;\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != tail && fast.next != tail) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        TreeNode root = new TreeNode(slow.val);\n        root.left = dfs(head, slow);\n        root.right = dfs(slow.next, tail);\n        return root;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922404743","body":"public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = length(headA);\n        int lenB = length(headB);\n        while (lenA > lenB) {\n            headA = headA.next;\n            lenA--;\n        }\n        while (lenB > lenA) {\n            headB = headB.next;\n            lenB--;\n        }\n        while (headA != headB) {\n            headA = headA.next;\n            headB = headB.next;\n        }\n        return headA;\n    }\n    \n    private int length(ListNode head) {\n        int len = 0;\n        while (head != null) {\n            head = head.next;\n            len++;\n        }\n        return len;\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cassiechris":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917341652","body":"### 思路\n\n先遍历一遍字符串s，把c每次出现的index记录下来存为一个list\n然后再次遍历s，每个元素计算与每个c的距离（遍历list），如果计算得到更小的距离就更新最小距离直到遍历完c的list，将得到的最小距离存到距离的list中，最后输出最终的list\n\n### 代码\n\n```python\ndef shortestToChar(s: str, c: str):\n    ls_c = []\n    for i,e in enumerate(s):\n        if e == c:\n            ls_c.append(i)\n    ls_d = []\n    for i in range(len(s)):\n        distance = abs(i-ls_c[0])\n        for c in ls_c:\n            if abs(c-i) < distance:\n                distance = abs(c-i)\n        ls_d.append(distance)\n    return ls_d\n```\n\n**复杂度分析**\n\n- 时间复杂度: $O(N)$，N为字符串s的长度\n- 空间复杂度: $O(N)$，N为字符串s的长度","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921818612","body":"### 思路\n\n官方题解1：迭代\n\n- 创建空节点在涉及到链表指针修改的时候头节点可能发生变化的时候非常常用\n- 修改两个一组的链表节点：由 preA -> A -> B -> nextB 改为 preA -> B -> A -> nextB， nextB 以及 nextB 的下一个元素同理\n\n官方题解2：递归\n\n- 将逆转后的尾节点.next 指向下一次递归的返回值，返回逆转后的链表头节点（逆转前的第二个节点）\n\n### 代码\n\n```python\n# Method 1: Iteration\ndef swapPairs(head):\n\tif not head or not head.next: \n\t\treturn head\n\tans = ListNode()\n\tans.next = head.next\n\tpre = ans\n\twhile head and head.next:\n\t\tnext = head.next\n\t\tn_next = next.next\n\t\tnext.next = head\n\t\tpre.next = next\n\t\thead.next = n_next\n\t\tpre = head\n\t\thead = n_next\n\treturn ans.next\n\n# Method 2: Recursion\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n\t\t    if not head or not head.next: return head\n\t\t\t\tnext = head.next\n        head.next = self.swapPairs(next.next)\n        next.next = head\n        return next\n```\n\n**复杂度分析**\n\n- 时间复杂度: $O(N)$，N为节点数\n- 空间复杂度: $O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XinnXuu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917351268","body":"### 思路\n从低位到高位逐位相加k的余数，每高一位k/10，每一位的和大于10则记到k中\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        for (int i = num.length - 1; i >= 0; i--){\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10){\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        while (k > 0){\n            res.add(k % 10);\n            k /= 10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n\n```\n### 复杂度分析\n- 时间复杂度：$O(N)$, N为数组长度\n- 空间复杂度：$O(N)$, 保存结果的ArrayList","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917344179","body":"### 思路\n向左向右各遍历一次，比较取距离最小值。\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n        int pos = -10001;\n        for(int i = 0; i <= n - 1; i++){\n            if(s.charAt(i) == c){\n                pos = i;\n            }\n            res[i] = i - pos;\n        }\n        pos = 10001;\n        for(int i = n - 1; i >= 0; i--){\n            if(s.charAt(i) == c){\n                pos = i;\n            }\n            res[i] = Math.min(res[i], pos - i);\n        }\n        return res;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：$O(N)$, N为数组长度\n- 空间复杂度：$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917567573","body":"### 思路\n通过增加一个辅助数组，来优化increment操作到O(1)。辅助数组专门负责记录increment操作增加的val值和位置。重点在于pop操作，这时再将栈顶值加上辅助数组记录的val值，并传递该val值给辅助数组的前一位。\n另外要注意一些top=-1以及0时的边界。\n### 代码\n```java\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1){\n            return -1;\n        }\n        int sum = stack[top] + add[top];\n        if (top != 0){\n            add[top - 1] += add[top]; \n        }\n        add[top] = 0;\n        top--;\n        return sum;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k - 1, top);\n        if (limit >= 0){\n        add[limit] += val; \n        }\n    }\n}\n\n```\n### 复杂度分析\n- 时间复杂度：均为O(1)\n- 空间复杂度：用到了两个数组，O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917718484","body":"\n### 思路\n遇到右括号前不断压栈，遇到右括号后开始出栈，先出栈所有字母直至非字母为止得到repeatStr，再继续出栈所有数字到非数字为止得到重复次数，根据重复次数拼接repeatStr并压入栈。循环结束后全部出栈即得到所求结果。\n### 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n\n        Stack<Character> stack = new Stack<Character>();\n        \n        for (char c : s.toCharArray()){\n            //把遇到]前的所有字符压入栈\n            if(c != ']'){ \n                stack.push(c);\n            } else{\n                //遇到]后开始出栈\n                //1.先取[]内字母\n                StringBuilder letters = new StringBuilder();\n                //弹出[]内字母\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())){\n                    letters.insert(0, stack.pop());\n                }\n\n                String repeatStr = letters.toString();\n                stack.pop(); //pop一次去除左括号[\n\n                //2.开始取倍数数字\n                StringBuilder num = new StringBuilder();\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    num.insert(0, stack.pop());\n                }\n                int repearCount = Integer.valueOf(num.toString());\n\n                //3.根据倍数，拼接字符并压入栈中\n                for ( ; repearCount > 0; repearCount--){\n                    for (char ch : repeatStr.toCharArray()){\n                        stack.push(ch);\n                    }\n                }\n            }\n        }\n        StringBuilder res = new StringBuilder();\n        while (!stack.isEmpty()){\n            res.insert(0, stack.pop());\n        }\n        return res.toString();\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(N),N为s长度\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918556526","body":"### 思路\n用两个栈来模拟队列，栈1负责push，栈2负责pop，每次队列出列入列时先检查负责另一个功能的栈中是否有元素，有则全部出栈到本栈，再进行push或者pop（也就是每次队列push或pop时总要先把另一个栈排空）。如此操作使得队列尾在栈1顶，队列首在栈2顶。\n### 代码\n```java\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack1 = new Stack<Integer>();\n        stack2 = new Stack<Integer>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        while (!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n        stack1.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n         if (!stack1.isEmpty() && stack2.isEmpty()){\n            while (!stack1.isEmpty()){\n                 stack2.push(stack1.pop());\n            }\n        } \n        return stack2.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        while (!stack1.isEmpty()){\n            stack2.push(stack1.pop());\n        }\n        return stack2.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n\n```\n### 复杂度分析\n- 时间复杂度：push/pop/peek操作为O(N)，N为栈的长度。其他操作O(1)。\n- 空间复杂度：O(N)，使用了两个栈。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919726276","body":"### 思路\n栈内保存每个块的最大值。遍历一遍数组，对于每个num,如果不小于当前栈顶则入栈，否则融合进当前块。\n### 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for (int num : arr){\n            if (!stack.isEmpty() && num < stack.getLast()){\n                int cur =  stack.removeLast();\n                while (!stack.isEmpty() && num < stack.getLast()){\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920360789","body":"\n### 思路\n让链表首位连接成环，再在相应位置断开即得所求。\n### 代码\n```java\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0){\n            return head;\n        }\n        int n = 1;\n        ListNode newHead = head;\n        while (newHead.next != null){\n            n++;\n            newHead = newHead.next;\n        }\n        int add = n - (k % n);\n        if (add % n == 0) {\n            return head;\n        }\n        \n        newHead.next = head; \n        while (add-- > 0){\n            newHead = newHead.next;\n        }\n        ListNode tmp = newHead.next;\n        newHead.next = null;\n        return tmp;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921254091","body":"\n### 思路\n迭代，遍历链表，每次交换cur节点后的两个节点，当cur节点后少于两个节点则循环结束。使用虚拟头节点dummy来避免因头节点特殊性产生的问题。\n### 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        ListNode cur = new ListNode(0);\n        dummy.next = head;\n        cur = dummy;\n         while (cur.next != null && cur.next.next != null){\n             ListNode node1 = cur.next;\n             ListNode node2 = cur.next.next;\n             cur.next = node2;\n             node1.next = node2.next; \n             node2.next = node1;\n             cur = node1;\n         }\n         return dummy.next;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(N)，N为链表节点数量，需要遍历一遍链表对每个节点进行更新。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922117049","body":"### 思路\n通过快慢指针找出链表的中位数，作为当前树的根节点。左右继续递归建立左右子树。\n### 代码\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        if (head.next == null){\n            TreeNode root = new TreeNode(head.val);\n            return root;\n        }\n        return dfs(head,null);\n    }\n\n    private TreeNode dfs(ListNode head, ListNode tail){\n        if (head == tail){\n            return null;\n        }\n        ListNode fast = head, slow = head;\n        while (fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode median = new TreeNode(slow.val);\n        median.left = dfs(head, slow);\n        median.right = dfs(slow.next, tail);\n        return median;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(NlogN),递归树深度logN,每层基本操作数N\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922419109","body":"### 思路\n双指针，指针AB分别遍历两台链表，若到链表尾则重定向到另一条链表的表头。若有相交点则两指针必然相遇。\n### 代码\n```java\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null){\n            return null;\n        }\n        ListNode ptrA = headA;\n        ListNode ptrB = headB;\n        while (ptrA != ptrB){\n            if (ptrA == null){\n                ptrA = headB;\n            } else {\n                ptrA = ptrA.next;\n            }\n            if (ptrB == null){\n                ptrB = headA;\n            } else {\n                ptrB = ptrB.next;\n            }\n            if (ptrA == null && ptrB == null){\n                return null;\n            }\n        }\n        return ptrA;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AgathaWang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917840434","body":"# 补卡\n```\n# python奇技淫巧\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result = int(\"\".join([str(i) for i in num])) + k\n        return [int(i) for i in str(result)]\n```\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917344743","body":"# 思路\n采用标答第二种思路，空间换时间\n\n# 代码\n```\n# python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        c_lst = [i for i in range(len(s)) if s[i]==c]\n\n        output = []\n        for w in range(len(s)):\n            min_dist = min([abs(i-w) for i in c_lst])\n            output.append(min_dist)\n        return output\n```\n# 复杂度\n- 时间复杂度： O(N*K)\n- 空间复杂度： O(K)\n\nK = length of c_lst, the number of c in s\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917551856","body":"# 答案\n```\n# python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.st = []\n        # self.cnt = 0\n        self.maxSize = maxSize\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.st) < self.maxSize:\n            self.st.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.st == []:\n            return -1\n        else:\n            return self.st.pop()\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if k > len(self.st):\n            k = len(self.st)\n       \n        self.st[:k] = [i+val for i in self.st[:k]]\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917817362","body":"# 迭代法\n```\n# python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for w in s:\n            repeat_ct = \"\"\n            repeat_char = \"\"\n            if w == \"]\":\n                while stack[-1] != '[':\n                    repeat_char = stack.pop() + repeat_char\n                stack.pop() # delete [\n                while stack and stack[-1].isnumeric():\n                    repeat_ct = stack.pop() + repeat_ct\n                temp = int(repeat_ct)*repeat_char\n                stack.append(temp)\n            else:\n                stack.append(w)\n        return \"\".join(stack)\n```\n时间复杂度： O(s)\n空间复杂度： O(s)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918788953","body":"# 思路\n使用help.stack来取出第一个元素，python list模拟stack,不可以使用除了-1以外的索引，因为模拟stack。\n\n# 代码\n```\n# python\nclass MyQueue(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stk = []\n        self.help_stk = []\n\n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: None\n        \"\"\"\n        return self.stk.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        while self.stk:\n            self.help_stk.append(self.stk.pop())\n        output = self.help_stk.pop()\n        while self.help_stk:\n            self.stk.append(self.help_stk.pop())\n        return output\n    \n\n    def peek(self):\n        \"\"\"\n        Get the front element.\n        :rtype: int\n        \"\"\"\n        while self.stk:\n            self.help_stk.append(self.stk.pop())\n        output = self.help_stk[-1]\n        while self.help_stk:\n            self.stk.append(self.help_stk.pop())\n        return output\n\n    def empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        return self.stk==[]\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919709205","body":"```\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: \n                ans += 1\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920574250","body":"# 倒数k个node变体\n快慢指针法\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head:\n            p1=head\n            p2=head\n            count=1  #记链表长度\n            i=0 #计步\n            # this while block: p2先行k步\n            while i<k:  \n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:  #k大于链表长度, if部分p2已行至tail node，else从head开始\n                    k = k%count\n                    i = -1\n                    p2 = head\n                i += 1\n            ## this while let p2 move to tail node and p1 move forward where k steps after p2\n            while p2.next:  \n                p2 = p2.next\n                p1 = p1.next\n            if p1.next:\n                temp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return temp\n```\n时间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921467990","body":"# 两两交换节点\n迭代法\n```\n# 迭代\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n\n        virtualhead = ListNode()\n        virtualhead.next = head\n        pre = virtualhead\n        while head and head.next:\n            next = head.next\n            nnext = next.next\n            #修改指针\n            pre.next = next\n            next.next = head\n            head.next = nnext\n            \n            #更新节点\n            pre = head\n            head = nnext\n        return virtualhead.next\n```\n时间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922228043","body":"# 迭代\r\n```\r\n# python 3\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return head\r\n        pre, slow, fast = None, head, head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast:  #只有一个node\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n```\r\n时间复杂度：O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922409547","body":"# 哈希表和双指针\n```\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        # 双指针\n        # a = headA\n        # b = headB\n        # while a != b:\n        #     # 注意if a not a.next, because a could handle no intersect\n        #     a = a.next if a else headB  \n        #     b = b.next if b else headA\n        # return a\n\n        # 哈希表，set()形式,list会超时\n        s = set()\n        # s = []\n        a = headA\n        b = headB\n        while a:\n            s.add(a)\n            # s.append(a)\n            a = a.next\n        while b:\n            if b in s:\n                return b \n            b = b.next\n        return None\n```\n哈希表 - 时间复杂度：O(N), 空间复杂度O(N)\n双指针 - 时间复杂度：O(N), 空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sumukeio":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917350684","body":"class Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        result = [float('inf') for i in s]\r\n        last_c = -float('inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                last_c = i\r\n                result[i] = i-last_c\r\n            else:\r\n                result[i] = i-last_c\r\n        last_c = float('inf')\r\n        for i in range(len(s)-1, -1,-1):\r\n            if s[i] == c:\r\n                last_c = i\r\n            result[i] = min(result[i], last_c - i)\r\n        return result ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917652275","body":"class CustomStack {\r\nprivate:\r\n    int ans[1000];\r\n    int size;\r\n    int top;\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        size = maxSize;\r\n        top = 0;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top < size) \r\n            ans[top ++] = x;\r\n    }\r\n    \r\n    int pop() {\r\n        if (top > 0) return ans[-- top];\r\n        else return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0, num = min(k, top); i < num; i ++)\r\n            ans[i] += val;\r\n    }\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918336926","body":"class Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':  # 处理>10的数字\r\n                multi = multi * 10 + int(c)\r\n            else:\r\n                res += c\r\n        return res","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919679354","body":"var maxChunksToSorted = function(arr) {\r\n    let sortArr = [...arr];\r\n    sortArr.sort((a,b)=>a-b);\r\n    let count = 0,num1 = 0,num2 = 0;\r\n    for(let i = 0; i < arr.length; i++){\r\n        num1 += arr[i];\r\n        num2 += sortArr[i];\r\n        if(num1==num2){\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920971325","body":"ListNode* rotateRight(ListNode* head, int k)\r\n    {\r\n        if (k == 0)\r\n            return head;\r\n        ListNode *p = head;\r\n        int len = 0;\r\n        while(p->next)\r\n        {\r\n            len++;\r\n            p = p->next;\r\n        }\r\n        len++;\r\n        k = k % len;\r\n        p->next = head;\r\n        p = head;\r\n        int flag = 0;\r\n        // 找到尾节点\r\n        while(flag != (len - k - 1))\r\n        {\r\n            p = p->next;\r\n            flag++;\r\n        }\r\n        // 赋值头节点\r\n        ListNode *q = p->next;\r\n        //赋值尾节点\r\n        p->next = nullptr;\r\n        return q;\r\n    }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922327110","body":"class Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        l = 0 \r\n        cur = head\r\n        while cur:\r\n            cur = cur.next\r\n            l += 1\r\n            \r\n        def toTree(left, right):\r\n            nonlocal head\r\n\r\n            if left > right: \r\n                return None\r\n            \r\n            mid = (left+ right) // 2\r\n            \r\n            left = toTree(left, mid - 1)\r\n            \r\n            t = TreeNode(head.val)\r\n            \r\n            head = head.next\r\n            right = toTree(mid + 1, right)\r\n            \r\n            t.left = left\r\n            \r\n            t.right = right\r\n            \r\n            return t\r\n        \r\n        tree = toTree(0, l - 1)\r\n        return tree","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"watermelonDrip":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351060","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        indx_c = list()\r\n        \r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                indx_c.append(i)\r\n        \r\n        # find shortest distance\r\n        \r\n        res = [10000]* len(s)\r\n\r\n        for j in range(len(s)):\r\n            if j in indx_c:\r\n                res[j] = 0\r\n            else:\r\n                tmp = [abs(x - j) for x in indx_c]\r\n                res[j] = min(tmp)\r\n\r\n\r\n        return res\r\n\r\n                \r\n\r\n            \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917516610","body":"\r\n栈允许尾部操作，可以用数组进行模拟。\r\n1.\r\npush O(1)\r\npop O(1)\r\nincre O(K): 因为有一层循环\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = list() \r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stk) < self.maxSize:\r\n            self.stk.append(x)\r\n        \r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stk) == 0:\r\n            return -1\r\n        tmp = self.stk.pop(-1)\r\n        return tmp\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        k_len = min(k,len(self.stk))\r\n        for i in range(k_len):\r\n            self.stk[i] += val\r\n        \r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n2.\r\n法1中, incre操作的时间复杂度是O(K)。考虑空间换时间。因为只在pop操作的时候，才返回。\r\n用一个数组add来保存每次需要增加的值。\r\n刚写的时候，多次不通过的原因是，很多边界没考虑\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.add = [0] * maxSize \r\n \r\n        self.top = -1  \r\n        self.maxSize = maxSize \r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top == self.maxSize -1:\r\n            return \r\n        self.top += 1\r\n        self.stk[self.top] = x\r\n        \r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.add[self.top] + self.stk[self.top]\r\n        if self.top > 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        \r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return ret\r\n        \r\n \r\n    def increment(self, k: int, val: int) -> None:\r\n        k_len = min(k-1,self.top)\r\n        if k_len<0:\r\n            return \r\n\r\n        self.add[k_len] += val\r\n        \r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917803837","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack =[]\r\n        res = ''\r\n        k = 0\r\n        for elem in s:\r\n            if '0' <=  elem  <= '9':\r\n                k  = k*10+ int(elem)\r\n            elif elem == '[':\r\n                stack.append([res, k])\r\n                res = ''\r\n                k =0\r\n \r\n            elif elem == ']':\r\n                tmp_str, tmp_k = stack.pop()\r\n                \r\n                res = tmp_str + res * tmp_k \r\n            \r\n                \r\n            else:\r\n                res =  res + elem \r\n              \r\n        return res\r\n     time:O(N)        \r\nspace(O(N))\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918723140","body":"```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stk1 = list()\r\n        self.stk2 = list()  # create new queue\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stk1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.stk2:\r\n            return self.stk2.pop()\r\n        else:\r\n            while self.stk1:\r\n                self.stk2.append(self.stk1.pop())\r\n            return self.stk2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.stk2:\r\n            return self.stk2[-1]\r\n        while self.stk1:\r\n            self.stk2.append(self.stk1.pop())\r\n        return self.stk2[-1] \r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return (len(self.stk2) == 0 and  len(self.stk1)== 0)\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919702925","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]:\r\n                head = stack.pop()\r\n                while stack and num < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            else:\r\n                stack.append(num)\r\n        return len(stack)\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921508695","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy_node = ListNode(0,head)\r\n      \r\n        tmp = dummy_node\r\n        while tmp.next and tmp.next.next:\r\n            node1 = tmp.next\r\n            node2 = tmp.next.next\r\n\r\n            tmp.next = node2  \r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            tmp  = node1\r\n        return dummy_node.next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922166360","body":"可以转会成有序数组转成二叉搜索树。\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        new_list  = []\r\n        while head:\r\n            new_list.append(head.val)\r\n            head = head.next\r\n        def sortAarrayToBst(nums):\r\n            if not nums:\r\n                return None\r\n            mid = len(nums)//2\r\n            root = TreeNode(nums[mid])\r\n            root.left = sortAarrayToBst(nums[:mid])\r\n            root.right = sortAarrayToBst(nums[mid+1:])\r\n            return root\r\n        return sortAarrayToBst(new_list)\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922435883","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        cur_A = headA\r\n        cur_B = headB\r\n        while cur_A != cur_B:\r\n            if cur_A == None:\r\n                cur_A = headB\r\n            else:\r\n                cur_A = cur_A.next\r\n\r\n            if cur_B == None:\r\n                cur_B = headA\r\n            else:\r\n                cur_B = cur_B.next\r\n\r\n      \r\n        return cur_A\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xvm03":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351757","body":"### 思路\r\n找s里所有c的位置，遍历s逐一和c的数组进行差值计算，找到最小值，新建数组存放最小值\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n            List<Integer> list = new ArrayList();\r\n            int length = s.length();\r\n            for(int i=0;i<length;i++){\r\n                char b = s.charAt(i);\r\n                if(b == c){\r\n                    list.add(i);\r\n                }\r\n            }\r\n            int[] result = new int[length];\r\n            for(int i=0;i<length;i++){\r\n                char b = s.charAt(i);\r\n                int diffNum=0;\r\n\r\n                for(int y=0;y<list.size();y++){\r\n                    Integer d = list.get(y);\r\n                    int innerDiffNum=0;\r\n                    if(i>d){\r\n                        innerDiffNum=i-d;\r\n                    }else{\r\n                        innerDiffNum=d-i;\r\n                    }\r\n\r\n                    if(y==0){\r\n                        diffNum=innerDiffNum;\r\n                    }\r\n                    if(innerDiffNum<diffNum){\r\n                        diffNum=innerDiffNum;\r\n                    }\r\n                }\r\n                result[i]=diffNum;\r\n            \r\n            }\r\n            return result;\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n需要先遍历一遍s，复杂度：n，然后再遍历一遍s，和重复c的数组进行逐一比对，n*c.length()，n+n*c.length()\r\n\r\n时间复杂度：o(n)\r\n空间复杂度：o(n)\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920851290","body":"### \r\n\r\n###  思路(看的官方解析）\r\n* * *\r\n\r\n头尾相连，移动次数就是找head的位置，如果次数超过链表大小size，n-k%size的结果就是链表需要循环的次数，找到就是tail节点，把tail节点的next作为head，tail.next=null，就完成了题目的要求\r\n\r\n``` java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n            //n=size,k%n\r\n            if(head == null){\r\n                return head;\r\n            }\r\n           \r\n            if(head.next == null){\r\n                return head;\r\n            }\r\n            if(k==0){\r\n                return head;\r\n            }\r\n\r\n            int n=1;\r\n            ListNode node = head;\r\n            while(node.next!= null){\r\n                n++;\r\n                node = node.next;\r\n            }\r\n            \r\n            int movNum = k%n;\r\n            if(movNum==0){\r\n                return head;\r\n            }\r\n\r\n            node.next = head;\r\n            \r\n           int aaa = n-movNum;\r\n        \r\n            while(aaa-->0){\r\n                node=node.next;\r\n            }\r\n            ListNode result = node.next;\r\n            node.next = null;\r\n            return result;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengistchan":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917353463","body":"# 代码\n```javascript\nconst shortestToChar = (s, c) => {\n  const res = Array(s.length).fill(-1)\n  let close = -1, i = 0\n  while(i < s.length) {\n    if(s[i] === c) {\n      res[i] = 0\n      close = i\n    } else {\n      res[i] = close === -1 ? -1 : i - close\n    }\n    i++\n  }\n  i = s.length - 1\n  while(i >= 0) {\n    if(s[i] === c) {\n      close = i\n    } else {\n      res[i] = res[i] === -1 ? Math.abs(i - close) : Math.min(res[i], Math.abs(i - close))\n    }\n    i--\n  }\n  return res\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917631390","body":"# 代码\n```javascript\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize\n  this.stack = []\n};\n\nCustomStack.prototype.push = function(x) {\n  if(this.stack.length < this.maxSize) {\n    this.stack.push(x)\n  }\n};\n\nCustomStack.prototype.pop = function() {\n  if(this.stack.length === 0) return -1\n  return this.stack.pop()\n};\n\nCustomStack.prototype.increment = function(k, val) {\n  let t = 0\n  while(t < k && t < this.stack.length) {\n    this.stack[t] += val\n    t++\n  }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917826985","body":"# 代码\n```javascript\nfunction decodeString(s: string): string {\n  let stack: string[] = [], i = 0, length = s.length, res = ''\n  while(i < length) {\n    if(s[i] === ']') {\n      let str = '', time: string | number = '', t = ''\n      while(stack[stack.length - 1] !== '[') {\n        str = stack.pop() + str\n      }\n      stack.pop()\n      while(stack.length && stack[stack.length - 1].charCodeAt(0) >= '0'.charCodeAt(0) && stack[stack.length - 1].charCodeAt(0) <= '9'.charCodeAt(0)) {\n        time = stack.pop() + time\n      }\n      stack.push(str.repeat(+time))\n    } else {\n      stack.push(s[i])\n    }\n    i++\n  }\n  return stack.join('')\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918750263","body":"# 代码\n```javascript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.stack_1 = [];\n    this.stack_2 = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    if(this.stack_1.length === 0) {\n        while(this.stack_2.length !== 0) {\n            this.stack_1.push(this.stack_2.pop());\n        }\n    }\n    this.stack_1.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.stack_2.length === 0) {\n        while(this.stack_1.length !== 0) {\n            this.stack_2.push(this.stack_1.pop());\n        }\n    }\n    let x = this.stack_2.pop();\n    return x;\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.stack_2.length === 0) {\n        while(this.stack_1.length !== 0) {\n            this.stack_2.push(this.stack_1.pop());\n        }\n    }\n    let x = this.stack_2[this.stack_2.length - 1];\n    return x;\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stack_1.length === 0 && this.stack_2.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919905105","body":"# 代码\n```javascript\nvar maxChunksToSorted = function (arr) {\n  const stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    a = arr[i];\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\n      const cur = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > a) stack.pop();\n      stack.push(cur);\n    } else {\n      stack.push(a);\n    }\n  }\n  return stack.length;\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922421834","body":"# 代码\n```javascript\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n  let a = headA, b = headB\n  while(a != b) {\n    a = a ? a.next : null\n    b = b ? b.next : null\n    if(a == null && b == null) return null\n    if(a == null) {\n      a = headB\n    } \n    if(b == null) {\n      b = headA\n    }\n  }\n  return a\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"QiZhongdd":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917359579","body":"**思路**\n- 定义变量prev代表前一次目标字符出现的小标，然后进行前向遍历，记录与目标字符的距离的绝对值。如同与目标字符相同，则更新变量prev.\n-  进行后序遍历，记录与目标字符的距离的绝对值，与第一次遍历的值比较取最小值。如果与目标字符相同，更新变量prev.\n\n**复杂度**\n- 时间复杂度2n\n- 空间复杂度n\n\n```\nvar shortestToChar = function(s, c) {\n   let prev=-Infinity,result=[];\n   for(let i=0;i<s.length;i++){\n       if(s.charAt(i)===c){\n           prev=i\n       }\n       result[i]=Math.abs(i-prev)\n   }\n   prev=Infinity\n   for(let j=s.length-1;j>=0;--j){\n        if(s.charAt(j)===c){\n           prev=j\n       }\n       result[j]=Math.min(result[j],Math.abs(prev-j))\n   }\n   return result\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917598202","body":"```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize=maxSize\n    this.val=[];\n    this.cnt=0;\n    this.incrementals=new Array(maxSize).fill(0)\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.cnt<this.maxSize){\n        this.val.push(x)\n        this.cnt += 1\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.cnt==0)return -1;\n    if(this.cnt>=2){\n        this.incrementals[this.cnt-2]+=this.incrementals[this.cnt-1];\n    }\n    let val=this.incrementals[this.cnt-1]+this.val.pop();\n    this.incrementals[this.cnt-1]=0;\n    this.cnt-=1;\n    return val;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  if (this.cnt){\n      this.incrementals[Math.min(this.cnt, k) - 1] += val\n  }\n};\n```\n**复杂度**\n时间复杂度都为O(1),空间复杂度为O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917850482","body":"**思路**\n- 除了‘]’都入栈\n- 遇到’]‘出栈，品鉴字符串，直到‘[’\n- 抛出‘[’\n- 抛出栈顶然后获取到数字repeat后加入栈\n```\nvar decodeString = function(s) {\n    let stack=[];\n    for(let i=0;i<s.length;i++){\n        if(s[i]==']'){\n            let str=''\n            while(stack[stack.length-1]!='['){\n                let char=stack.pop()\n                str=char+str\n            }\n            stack.pop();\n            let num;\n            while(!isNaN(Number(stack[stack.length-1]))){\n                num=stack.pop()\n                stack.push(str.repeat(Number(num)))\n            }\n        }else{\n            stack.push(s[i])\n        }\n    }\n\n    return stack.join('')\n};\n```\n\n**复杂度**\n时间O(N),空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918816251","body":"```\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.stackOne=[];\n    this.stackTwo=[]\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stackOne.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(!this.stackTwo.length){\n        while (this.stackOne.length) {\n            this.stackTwo.push(this.stackOne.pop());\n        }\n    }\n    return this.stackTwo.pop()\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.stackTwo.length){\n        while (this.stackOne.length) {\n            this.stackTwo.push(this.stackOne.pop());\n        }\n    }\n    return this.stackTwo[this.stackTwo.length-1]\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stackOne.length===0&&this.stackTwo.length==0;\n};\n```\n\n复杂度\n时间：均摊时间复杂度 O(1)\n空间：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919966640","body":"```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n   let stack=[];\n   for(let i=0;i<arr.length;i++){\n       if(stack.length&&arr[stack[stack.length-1]]>arr[i]){\n            let cur=stack[stack.length-1]\n            while(stack.length&&arr[stack[stack.length-1]]>arr[i]){\n                stack.pop();\n            }\n            stack.push(cur)\n       }else{\n            stack.push(i)\n       }\n   }\n    return stack.length;\n};\n\n```\n复杂度分析\n时间复杂度: O(N) 其中 N 为数组长度\n空间复杂度: O(N) 其中 N 为数组长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920583877","body":"**思路**\n- 建立快慢指针，先让快指针走k步，然后同时移动走到结尾\n- 走到结尾后让fast的next节点指向head，形成一个环\n- slow的next节点进行断开，返回结果\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n  if (!head || !head.next) return head;\n    let n = 0,\n    node = head;\n    while(node){\n        node=node.next;\n        n++;\n    }\n    k = k % n;\n    let slow = (fast = head);\n    while (fast.next) {\n        if(k-- <=0){\n            slow=slow.next;\n        }\n        fast=fast.next;\n    }\n    fast.next = head;\n    let res = slow.next;\n    slow.next = null;\n    return res\n};\n**复杂度**\n- 时间复杂度为O(n)\n- 空间复杂度为O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921455349","body":"```\nvar swapPairs = function(head) {\n    if(!head||!head.next)return head;\n    let temp=head.next;\n    head.next=swapPairs(temp.next);\n    temp.next=head;\n    return temp;\n};\n```\n\n时间复杂度：O(n),空间复杂度O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922195669","body":"**思路**\n- 利用快慢指针，快指针比慢指针每次操作多走一步，当快指针走到结尾的时候，慢指针刚好在中间，即树的root节点\n- 进行二分操作，采用递归，分别求出树的左节点和右节点\n\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if (!head) return null;\n   function dfs(head,tail){\n       if(head===tail)return null;\n       let fast=head;\n        let slow=head;\n        while(fast!==tail&&fast.next!==tail){\n            slow=slow.next;\n            fast=fast.next.next;\n        }\n        let root=new TreeNode(slow.val);\n        root.left=dfs(head,slow);\n        root.right=dfs(slow.next,tail);\n        return root;\n   }\n  return dfs(head,null)\n};\n\n```\n\n**复杂度**\n\n时间复杂度：递归的时间复杂度为log(n)，每一层的操作的时间复杂度为n,所以总的时间复杂度n(logn);\n空间复杂度：递归树的深度是log(n),空间复杂度为log(n)，每层的空间复杂度为1,所以总的空间复杂度为log(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922417321","body":"```\nvar getIntersectionNode = function(headA, headB) {\n    let nodeA=headA;\n    let nodeB=headB;\n    while(nodeA&&nodeB){\n        if(nodeA===nodeB){\n           return nodeA\n        } \n        nodeA=nodeA.next;\n        nodeB=nodeB.next;\n        if(nodeA===null&&nodeB){\n            nodeA=headB\n        }\n        if(nodeB===null&&nodeA){\n            nodeB=headA\n        }\n    }\n    return null\n};\n```\n时间复杂度：o(n+m),空间o(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youyiqin":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917361047","body":"## 思路\n- 从左到右遍历，结果数组保存距离\n- 从右到左遍历，修正相对较小的距离值\n\n## 代码\n```js\nvar shortestToChar = function(S, C) {\n    let res = [];\n    // tip: max length is 10^4\n    let prev = -10001;\n    \n    for (let i = 0; i < S.length; i++) {\n        if (S.charAt(i) == C) {\n            prev = i;\n        }\n        res[i] = i - prev;\n    }\n\n    prev = 10001;\n    for (let i = S.length - 1; i >= 0; i--) {\n        if (S.charAt(i) == C) {\n            prev = i;\n        }\n        // 取向左和向右中的最小值\n        res[i] = Math.min(res[i], prev - i);\n    }\n    return res;\n};\n```\n\n## 复杂度\n- Time: O(n)\n- Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917661881","body":"# 思路\n使用对象和递增的下标模拟数组的下标，实现访问元素的复杂度为 O(1)\n\n# 代码\n```js\nclass CustomStack {\n  constructor(maxSize) {\n    this._maxSize = maxSize\n    this._size = 0\n    this._content = {}\n  }\n  push(x) {\n    if(this._size < this._maxSize) {\n      this._content[++this._size] = x\n    }\n  }\n  pop() {\n    if(this._size === 0) {\n      return -1\n    } else {\n      const topStackValue = this._content[this._size]\n      delete this._content[this._size--]\n      return topStackValue\n    }\n  }\n  increment(k, val) {\n    if(this._size === 0) {\n      return\n    }\n    for (let index = 1; index <= this._size && index <= k; index++) {\n      this._content[index] += val\n    }\n  }\n}\n```\n# 复杂度\n时间: O(1)\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918301423","body":"# 思路\n用栈接入字符串，遍历字符串，当匹配到字母和'['的时候就入栈保存，当匹配到']'的时候则保存当前的结果，最后得出结果\n# 代码\n```typescript\nconst isNumber = (str: string) => /\\d/.test(str);\nconst isLetter = (str: string) => /[a-z]/.test(str);\n\nfunction decodeString(str: string): string {\n  if (str.length === 0) return \"\";\n  const stack = [];\n  const len = str.length;\n  let index = 0;\n  let repeatStr = \"\";\n  while (index < len) {\n    if (isLetter(str[index]) || str[index] === \"[\") {\n      stack.push(str[index]);\n    } else if (isNumber(str[index])) {\n      if (isNumber(stack[stack.length - 1])) {\n        stack[stack.length - 1] += str[index];\n      } else {\n        stack.push(str[index]);\n      }\n    } else if (str[index] === \"]\") {\n      let prevValue = stack.pop();\n      while (prevValue !== \"[\") {\n        repeatStr = prevValue + repeatStr;\n        prevValue = stack.pop();\n      }\n      if (isNumber(stack[stack.length - 1])) {\n        stack[stack.length - 1] = repeatStr.repeat(stack[stack.length - 1]);\n      } else {\n        stack.push(repeatStr);\n      }\n      repeatStr = \"\";\n    }\n    index++;\n  }\n  return stack.join(\"\");\n}\n```\n# 复杂度\n时间复杂度: O(n)\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"juleijs":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917347689","body":"### 思路\n先将数组转成string，再转成number与K做运算，然后把结果转成array\n\n### 代码\n``` javascript\nfunction addToArrayFrom(arr, k) {\n  let arrNum = parseInt(arr.join(''))\n  arrNum += k\n  return arrNum.toString().split('')\n}\n```\n\n### 复杂度\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917363682","body":"### 思路\r\n* 从当前下标出发，分别向左、向右寻找目标字符C\r\n* 只从一个方向找到的话，直接计算目标距离\r\n* 两个方向都有的话，计算最短的那一个距离\r\n### 代码\r\n``` javascript\r\nfunction shortestToChar(s, c) {\r\n  let res = Array(s.length).fill(0)\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) continue;\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n    while(l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l)\r\n        break;\r\n      }\r\n      l--\r\n    }\r\n    while(r < s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i)\r\n        break;\r\n      }\r\n      r++\r\n    }\r\n    res[i] = shortest\r\n  }\r\n  return res\r\n}\r\n```\r\n### 复杂度\r\n* 时间复杂度：O(N²)\r\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917588556","body":"### 思路\r\n用数组模拟栈实现，pop、push用数组的原生方法实现，increment时为数组中的每个元素都加上增量的值\r\n### 代码\r\n``` javascript\r\nconst CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n};\r\n\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length >= this.maxSize) return;\r\n  this.stack.push(x);\r\n};\r\n\r\nCustomStack.prototype.pop = function() {\r\n  return this.stack.length > 0 ? this.stack.pop() : -1;\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n  const length = Math.min(k, this.stack.length);\r\n  for (let i = 0; i < length; i++) {\r\n    this.stack[i] += val;\r\n  };\r\n};\r\n```\r\n### 复杂度\r\n* 时间复杂度：pop、push O(1); increment O(N)\r\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918235891","body":"### 思路\r\n利用字符串栈、数字栈和拼接的字符串来接，遍历每一个字符\r\n* 当为数字时，算出数字倍数\r\n* 当为字符时，拼接字符串\r\n* 当为“[\"时，拼接的字符串入字符串栈，入栈后清空，倍数数字入数字栈，入栈后清零\r\n* 当为”]“时，两个栈顶出栈，用倍数乘字符串并拼接原字符串\r\n### 代码\r\n``` javascript\r\nfunction decodeString(s) {\r\n  let strStack = [];\r\n  let numStack = [];\r\n  let num = 0;\r\n  let result = '';\r\n  for (const char of s) {\r\n    if (!Number.isNaN(char)) {\r\n      num = Number(char);\r\n    } else if (char === '[') {\r\n      strStack.push(result);\r\n      result = '';\r\n      numStack.push(num);\r\n      num = 0;\r\n    } else if (char === ']') {\r\n      result = strStack.pop() + result.repeat(numStack.pop());\r\n    } else {\r\n      result += char;\r\n    }\r\n  }\r\n  return result;\r\n} ;\r\n```\r\n### 复杂度\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919206937","body":"### 思路\r\n双栈，一个入栈、一个出栈模拟队列\r\n### 代码\r\n``` javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n  this.inStack = [];\r\n  this.outStack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.checkOutStack = function() {\r\n  if (!this.outStack.length){\r\n     while(this.inStack.length) {\r\n        this.outStack.push(this.inStack.pop());\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  this.checkOutStack();\r\n  return this.outStack.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  this.checkOutStack();\r\n  return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return !this.inStack.length && !this.outStack.length;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n### 复杂度\r\n* 时间复杂度：O(1)\r\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919805804","body":"### 思路\r\n单调栈递增\r\n### 代码\r\n``` javascript\r\nclass Stack {\r\n  constructor() {\r\n    this.items = [];\r\n  };\r\n\r\n  push(val) {\r\n    this.items.push(val);\r\n  };\r\n  \r\n  pop() {\r\n    return this.items.pop();\r\n  };\r\n  \r\n  peek() {\r\n    return this.items[this.items.length - 1];\r\n  };\r\n  \r\n  empty() {\r\n    return !this.items.length;\r\n  };\r\n  \r\n  size() {\r\n    return this.items.length;\r\n  };\r\n};\r\n\r\nconst maxChunksToSorted = arr => {\r\n  let stack = new Stack();\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (stack.empty() || stack.peek() <= arr[i]) {\r\n      stack.push(arr[i]);\r\n    } else {\r\n      const temp = stack.pop();\r\n      while(stack.peek() > arr[i]) {\r\n        stack.pop();\r\n      };\r\n      stack.push(temp);\r\n    };\r\n  };\r\n  return stack.size();\r\n};\r\n```\r\n### 复杂度\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920539716","body":"### 思路\r\n旋转链表\r\n### 代码\r\n``` javascript\r\nconst rotateRight = (head, k) => {\r\n  if (!head || !head.next || !k) return head;\r\n  let cur = head,\r\n    len = 1;\r\n  while(cur.next) {\r\n    cur = cur.next;\r\n    len++;\r\n  };\r\n  let move = len - k % len;\r\n  cur.next = head;\r\n  while(move) {\r\n    cur = cur.next;\r\n    move--;\r\n  };\r\n  let ans = cur.next;\r\n  cur.next = null;\r\n  return ans;\r\n}\r\n``` \r\n### 复杂度\r\n* 时间复杂度：O(N)\r\n* 空间发咋读：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921410579","body":"### 思路\r\n自递归\r\n### 代码\r\n``` javascript\r\nconst swapPairs = head => {\r\n  if (!head || !head.next) return head;\r\n  let next = head.next;\r\n  head.next = swapPairs(next.next);\r\n  next.next = head;\r\n  return next;\r\n}\r\n```\r\n### 复杂度\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922184743","body":"### 思路\r\n这题不太会，借鉴他人思路，用快慢指针思想解题\r\n### 代码\r\n``` javascript\r\nconst sortedListToBST = head => {\r\n  if (head === null) return null;\r\n  let slow = head,\r\n    fast = head,\r\n    preSlow\r\n  while( fast && fast.next) {\r\n    preSlow = slow;\r\n    slow = slow.next;\r\n    fast = fast.next.next;\r\n  }\r\n  const root = new TreeNode(slow.val)\r\n  if (preSlow !== null) {\r\n    preSolw.next = null;\r\n    root.left = sortedListToBST(head);\r\n  }\r\n  root.right = sortedListToBST(slow.next)\r\n  return root;\r\n}\r\n```\r\n### 复杂度\r\n* 时间复杂度：O(logN)\r\n* 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922490985","body":"### 思路\r\n利用哈希集合\r\n### 代码\r\n``` javascript\r\nconst getIntersectionNode = (headA, headB) => {\r\n  let visited = new Set();\r\n  let temp = headA;\r\n  while(temp !== null) {\r\n    visited .add(temp);\r\n    temp = temp.next;\r\n  }\r\n  \r\n  temp = headB;\r\n  white(temp !== null){\r\n     if (visited.has(temp)){\r\n       return temp;\r\n     }\r\n     temp = temp.next\r\n  }\r\n  return null;\r\n}\r\n```\r\n### 复杂度\r\n* 时间复杂度： O(M+N)\r\n* 空间复杂度:：O(M)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rebel-ly":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917351654","body":"### 思路：（编程基础很差，在坚持中）\r\n拿到题，首先想到的是之前的python 可以直接将数字变成数组，但直接加一个整数是给数组中的每一个元素都进行加处理；没有进行下去，看了题解，认真看懂了题解，自己敲了一边。\r\n题解使用的是错位相加，前面的一个if循环很好理解，但需要注意条件边界（都是带=），后面的一个if循环，自己用一个例子试了试才看懂，需要考虑K的位数比Array的位数要大很多的情况，可能第一个IF执行完，K还有几位数没有进行相加，这时候就可以直接每次取个位加入数组。\r\n官方题解使用list  应该是因为add操作方便。\r\n（纯个人感悟，希望大家多多指正）\r\n### 代码：\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n     List sum= new ArrayList();\r\n    for(int i = num.length-1; i>=0; i--){\r\n        int adding=num[i]+(k%10);\r\n        k=k/10;\r\n        if(adding>=10){\r\n            k++;\r\n            adding=adding-10;\r\n        }\r\n        sum.add(adding);\r\n    }\r\n    for( ;k>0;){\r\n        sum.add(k%10);\r\n        k=k/10;\r\n    }\r\n    Collections.reverse(sum);\r\n    return(sum);\r\n    }\r\n}\r\n```\r\n### 时间复杂度：\r\n时间复杂度一般取决于局部代码（讲义）\r\n在此主要看for循环，取决于数组长度 为O(N)\r\n### 空间复杂度：\r\n本质是对于一个List的操作，大小为N\r\n空间复杂度也为O(N)``","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917368065","body":"### **思路**\r\n刚开始没啥思路，编程水平低还做的题少。。妈哦，看了官方题解，就解释一下官方题解的思路把！\r\n计算字符串之间的最短距离，对于一个字符串元素来说，就有两个距离，一个靠左边标记点的，一个靠右边标记点的，结合西法老师备注的数组正向，反向遍历，可以想到这里要用两次遍历来找到对于每个字符串元素而言的两个距离，再留下其中的最小值。\r\nanswer直接创建一个整型数组即可。int[ ]\r\n记标记点为pre, 都用charAt(i)来找到，找到赋值为pre=i\r\n首先，从左向右遍历，标记点在元素的左侧，所以answer值为i-pre;\r\n(为了让左侧没有标记点的元素也有一个值，事先对pre赋值为MIN_VALUE/2，除2 是为了防止溢出，因为MIN_VALUE的绝对值比MAX_VALUE还要大1，所以直接减去最小值的话会溢出，感觉这里/3，/4均可以)\r\n其次，从右向左遍历，标记点在元素的右侧，所以answer的值为 pre-i;\r\n（这里官方题解给pre的初始赋值为MAX_VALUE/2，感觉是可以不除以2的，因为pre-int，最大也不会溢出）\r\n最后再对每个字符元素的距离左边右边标记点的距离作比较（Math.min(a,b)），赋值给answer即可。\r\n### **代码**\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n=s.length();\r\n        int[] answer= new int[n];\r\n        int pre=Integer.MIN_VALUE/2;\r\n        for(int i=0; i<n; i++){\r\n            if(s.charAt(i)==c){\r\n                pre=i;\r\n            }\r\n            answer[i]=i-pre;\r\n        }\r\n        pre=Integer.MAX_VALUE;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i)==c){\r\n                pre=i;\r\n            }\r\n            answer[i]=Math.min(answer[i],pre-i);\r\n        }\r\n        return answer;\r\n\r\n    }\r\n}\r\n```\r\n### **复杂度**\r\n这里的复杂度也主要取决于for循环，都是循环数组长度N \r\n时间复杂度 O(N)\r\n空间上也是占用一个数组长度的空间，因此\r\n空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917581675","body":"### 思路：\r\n 今天的题之前接触过相关的知识，用数组模拟一个队列，所以还是有些头绪的，但是太久没看，还是在检测队列是否为空还是为满的条件上犯了错，看了题解，都是使用Top指标来检测的，在队列初始化的时候，TOP=-1，加一个元素进去，Top++，抛出一个元素，也是在Top处做文章，Top--，抛出Top+1.\r\n至于判断为空为满的条件错误原因：使用nums.length 这始终是我们用来模拟队列的数组长度，是一个固定的值，而Top代表的才是真正的队列长度，所以Top=-1说明没有元素push 队列为空；Top=nums.length-1 说明用来构建队列满了。\r\n对于增值函数比较简单，就是看队列元素也就是Top+1和K的大小关系，取最小值，加就可以了。\r\n反思：晚上空余学习一下用链表模拟队列，希望顺利，今天还学习了滑动窗口的经典题209，加油拉。\r\n### 代码\r\n```\r\nclass CustomStack {\r\n//先进先出 top处进去 top处出去\r\n    int top;\r\n    int[] cust;\r\n\r\n    public CustomStack(int maxSize) {\r\n      cust=new int[maxSize];\r\n      top=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n       if (!isFull()){\r\n         top++;\r\n         cust[top]=x;\r\n         }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(isEmpty())\r\n           return -1;\r\n        top--;\r\n        return cust[top+1];\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit=Math.min(k,top+1);\r\n        for(int i=0;i<limit;i++){\r\n            cust[i]+=val;\r\n        }\r\n\r\n    }\r\n    public boolean isEmpty(){\r\n        //return cust.length==0;\r\n        return top==-1;\r\n    }\r\n    public boolean isFull(){\r\n        return top==cust.length-1;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n对于一个队列的操作push或者pop都是O(1)\r\n但是在increment这里涉及到了循环，所以是O（n）\r\n时间复杂度：O(n)\r\n空间上最大也是一个数组\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918051130","body":"### 思路\r\n自己虽然想到了用两个栈，一个存放数据，一个存放字符串，但是没做下去，看了一篇优秀题解，就主要讲一下他的做法吧。\r\n同样，主要是使用两个栈，一个用于存放数据，一个用于存放字符串；\r\n但是需要注意，只有确定数据是完整的乘积后才存入栈中，字符串也同理，只有是完整的字符串才存入。因此，设置了一个整形num用来代表当前不够完整的数字，以及一个字符串item存放不完整的字符。\r\n开始读取：\r\n1）最简单的：\r\n当读取的字节是’0‘到’9‘的时候（注意读出来的是String型），就把他放到num这个数字临时存储地，需要注意前面进去的需要乘以10再加上当前的数字；（将字符型转化为十进制数字）\r\n当读取的字节是普通字符型（即非数字，非[ 非]）的时候，直接放到item这个字符串临时存储地中。\r\n2）处理读取到【】的情况：\r\n当读取的字节为[ 的时候，意味着前面临时存入的num已经是完整的了，可以存入栈中；\r\n同时已经完成的item也可以存入栈中；然后再将两个临时存储地初始化；\r\n当读取字节为]的时候，意味着一个字符串读完了，那么就可以进行乘法处理了（从num_stack中取出刚刚放进去的完整num,作为当前item的倍数进行处理），最后将当前完成的item（之前已经存到item栈中）加到之前已经完成的item后面（字符串可以直接相加而相连）\r\n### 代码\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n     LinkedList<String> stack_item=new LinkedList<String>();\r\n     LinkedList<Integer> stack_num=new LinkedList<Integer>();\r\n     int num=0;\r\n     StringBuilder item= new StringBuilder();\r\n     for(int i =0;i<s.length();i++){\r\n         Character c=s.charAt(i);\r\n         if(c=='['){\r\n             stack_item.addFirst(item.toString());\r\n             stack_num.addFirst(num);\r\n             num=0;\r\n             item=new StringBuilder();\r\n         }\r\n         else if(c==']'){\r\n             StringBuilder temp=new StringBuilder();\r\n             int cur_num=stack_num.pop();\r\n             for(int j =0; j<cur_num; j++){\r\n                 temp.append(item);\r\n             }\r\n             item =new StringBuilder(stack_item.pop()+temp);\r\n         }\r\n         else if(c>='0'&&c<='9'){\r\n             num=num*10+Integer.parseInt(c+\"\");\r\n         }\r\n         else{\r\n             item.append(c);\r\n         }\r\n     }\r\n     return item.toString();\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度o(n)\r\n空间复杂度o(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918754746","body":"### 思路：\r\n今天的这个题比较容易，主要的思想就是当out的栈为空的时候，就把in栈的元素一个一个取出来放到out栈中，可以理解成一个平移，所以元素的顺序不会发生改变\r\n其他操作就直接来就可以！\r\n### 代码：\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> stack_in ;\r\n    Stack<Integer> stack_out; \r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack_in = new Stack<Integer>();\r\n        stack_out = new Stack<Integer>();\r\n    }\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stack_in.push(x);\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(stack_out.isEmpty()){\r\n            while(!stack_in.isEmpty()){\r\n                stack_out.push(stack_in.pop());\r\n            }\r\n        }\r\n        return stack_out.pop();\r\n\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(stack_out.isEmpty()){\r\n            while(!stack_in.isEmpty()){\r\n                stack_out.push(stack_in.pop());\r\n            }\r\n            return  stack_out.peek();\r\n        }\r\n        else{\r\n             return stack_out.peek();\r\n        }\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stack_in.isEmpty() && stack_out.isEmpty();\r\n    }\r\n}\r\n```\r\n### 复杂度：\r\n时间复杂度：O (1)\r\n空间复杂度：O (n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920006884","body":"### 思路：\r\n参考了一个优秀解答，说说他的思路。初始化一个栈后，遍历数组：\r\n对于第一个数，栈中是空的，加入站，假设为head;\r\n对于后面取出来的数，和栈中现在的顶端做比较，如果比他大说明是一个新的head，入栈即可；\r\n如果后面的数比现在的栈顶小，就把当前栈顶拿出来，预设为head, 在取出一个数进行比较，还是小，就删除掉那个数，把比它小的已经当成栈顶的都删掉，最后再把head加进去；\r\n相等的情况也直接入栈，当作一个新的head;\r\n最后栈中元素的数量就是head的数量就是可以划分的最大块。\r\n### 代码\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> stack=new LinkedList<Integer>();\r\n        for(int i=0;i<arr.length;i++){\r\n            if(!stack.isEmpty() && arr[i]<stack.getLast()){\r\n                int head=stack.removeLast();\r\n                while(!stack.isEmpty()&&arr[i]<stack.getLast()){\r\n                    stack.removeLast();\r\n                }\r\n                 stack.addLast(head);\r\n            }\r\n            else{\r\n                stack.addLast(arr[i]);\r\n            }\r\n        }\r\n        return stack.size();\r\n\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度（遍历一个数组）O(n)\r\n空间复杂度  （一个栈的空间）O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Winperrr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917354062","body":"### 思路\r\n**逐位相加，把进位加到k上参与下次的运算，注意k位数多余num位数的情况**\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n       vector<int> rev;\r\n       int len=num.size();\r\n       for(int i=len-1;i>=0;i--){\r\n           int sum=num[i]+k%10;\r\n           k/=10;\r\n           if(sum>9){\r\n               k++;    // 把进位加到k上，这样下次运算自然而然加到了下次的sum中\r\n               sum-=10;\r\n           }\r\n           rev.push_back(sum);\r\n       }\r\n       //应对k的位数超过num位数的情况\r\n       for(;k>0;k/=10){\r\n           rev.push_back(k%10);\r\n       }\r\n     reverse(rev.begin(),rev.end());\r\n     return rev;\r\n}\r\n```\r\n};\r\n### 时间复杂度\r\n**O(n)**\r\n### 空间复杂度\r\n**O(n）**","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917370146","body":" c++\r\n---\r\n### 思路\r\n\r\n\r\n1. 先遍历字符串，把与字符相同的元素下标存储在数组key中\r\n2. 双重循环，计算answer每个元素的下标与key中各个元素的距离绝对值，得到最小值存储到answer中，便得到结果\r\n\r\n---\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int len =s.length();\r\n        vector<int> key;\r\n        vector<int> answer;\r\n        for(int i=0;i<len;i++){\r\n            if(s[i]==c) key.push_back(i);\r\n        }\r\n        int n=key.size();\r\n        for(int k=0;k<len;k++){\r\n            int ans=abs(k-key[0]);\r\n            for(int j=1;j<n;j++){\r\n                if (ans>abs(k-key[j]) )ans=abs(k-key[j]);\r\n            }\r\n            answer.push_back(ans);\r\n        }\r\n        return answer;\r\n    }\r\n};\r\n```\r\n---\r\n### 时间复杂度\r\n**O(n*n) 双重循环**\r\n### 空间复杂度\r\n**O(n)**","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangcn111":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917364192","body":"``` javascript\r\nfunction addToArrayForm(num, k) {\r\n    //从低位按位相加，大于10进1\r\n    let len = num.length;\r\n    let res = [];\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        let sum = num[i] + (k % 10);\r\n        k = Math.floor(k / 10);\r\n        //sum大于10\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k%10);\r\n    }\r\n    return res.reverse();\r\n}\r\n```\r\n\r\n\r\n## 时间复杂度是 o(n) 跟数组的长度有关\r\n## 时间复杂度也是o(n) 跟生成的数组有关","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917371448","body":"``` javascript \n function shortestToChar(S, C) {\n    //先把c的所有下标找到\n    let indexs = [];\n    let res = [];\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === C) {\n            indexs.push(i);\n        }\n    }\n    //每一个元素跟 c的下标差的绝对值最小的那个\n    for (let i = 0; i < S.length; i++) {\n        let min = Infinity;\n        indexs.reduce((minx, cur) => {\n            min = minx < Math.abs(i - cur) ? minx : Math.abs(i - cur);\n            return min;\n        }, Infinity);\n        res.push(min);\n    }\n    return res;\n}\n\n``` \n\n复杂度分析\n\n时间复杂度：O(N*K)O(N∗K)，N 是 S 的长度，K 是字符 C 在字符串中出现的次数，K <= NK<=N。\n\n空间复杂度：O(K)O(K)，K 为字符 C 出现的次数，这是记录字符 C 出现下标的辅助数组消耗的空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917931350","body":"``` javascript\nclass CustomStack {\n    constructor(maxSize) {\n        if (maxSize < 1 || maxSize > 1000) {\n            throw new Error(\"maxSize在1到1000之间\");\n        }\n        // this.maxPushTime = 1000;\n        // this.maxPopTime = 1000;\n        // this.maxIncTime = 1000;\n        this.maxSize = maxSize;\n        this.stack = new Array();\n    }\n    /**\n     *如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\n     * @param {} x\n     */\n    push(x) {\n        // if (this.maxPushTime == 0) {\n        //     throw Error(\"已经达到最大pop次数\");\n        // }\n        // this.maxPushTime--;\n        if (this.stack.length >= this.maxSize) {\n            return;\n        }\n        this.stack.push(x);\n    }\n\n    /**\n     * 弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n     */\n    pop() {\n        // if (this.maxPopTime == 0) {\n        //     throw Error(\"已经达到最大pop次数\");\n        // }\n        // this.maxPopTime--;\n        if (this.stack.length === 0) {\n            return -1;\n        } else {\n            return this.stack.pop();\n        }\n    }\n\n    /**\n     *\n     * 栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n     * @param {*} k\n     * @param {*} val\n     */\n    increment(k, val) {\n        // if (this.maxIncTime == 0) {\n        //     throw Error(\"已经达到最大pop次数\");\n        // }\n        // this.maxIncTime--;\n        let end = Math.min(k, this.stack.length);\n        console.log(k, val, end);\n        for (let i = 0; i < end; i++) {\n            this.stack[i] = this.stack[i] + val;\n        }\n    }\n}\n\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917932028","body":"``` javascript \n function decode(str) {\n    let arr = str.split(\"\");\n    let res = [];\n    let temp = \"\";\n    let flag = 0;\n    let encode = false;\n    while (arr.length > 0) {\n        let s = arr.pop();\n        if (encode === true) {\n            //数字的情况\n            temp = temp.repeat(Number(s));\n            encode = false;\n            flag === 0 ? (res.push(temp), (temp = \"\")) : null;\n        } else if (s === \"]\") {\n            //右括号\n            flag++;\n        } else if (s === \"[\") {\n            //左括号\n            flag--;\n            encode = true;\n        } else if (flag == 0) {\n            //没有括号\n            res.push(s);\n        } else {\n            temp = `${s}${temp}`;\n        }\n    }\n    return res.reverse().join(\"\");\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freesan44":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917391713","body":"## 思路\n通过字符串与int之间的转换形成\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        #字符串与int的转换\n        resStr = \"\"\n        for i in num:\n            resStr +=str(i)\n        res = str(int(resStr)+k)\n        reslist = []\n        for i in res:\n            reslist.append(int(i))\n        return reslist\n\nif __name__ == '__main__':\n    A = [1,2,0,0]\n    K = 34\n    ret = Solution().addToArrayForm(A, K)\n    print(ret)\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917385468","body":"### 思路\r\n通过指针检索当前index与下一个，跟当前字符距离哪个大，然后进位\r\n\r\n### 代码\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        indexList = []\r\n        for index,val in enumerate(s):\r\n            if val == c:\r\n                indexList.append(index)\r\n        resList = []\r\n        p = 0#通过指针检索当前index与下一个，跟当前字符距离哪个大，然后进位\r\n        # print(indexList)\r\n        for index,val in enumerate(s):\r\n            # print(index)\r\n            if p < len(indexList)-1 and (abs(index-indexList[p]) > abs(index-indexList[p+1])):\r\n                p += 1\r\n            resList.append(abs(index-indexList[p]))\r\n        return resList\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间：O(N) \r\n- 空间：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917546707","body":"## 思路\r\n通过数组的append和pop实现增删\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n    maxSize = 0\r\n    stack = []\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = list()\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack) >= k:\r\n            for i in range(0,k):\r\n                self.stack[i] += val\r\n        else:\r\n            for i in range(len(self.stack)):\r\n                self.stack[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917742130","body":"## 思路\r\n通过一个临时栈，从]符号开始倒数栈内的字符串然后进行拼接处理\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        sList = list(s)\r\n        stack = list()\r\n        res = \"\"\r\n        while len(sList) != 0:\r\n            i = sList.pop(0)\r\n            # print(i)\r\n            if i == \"]\":#出栈\r\n                tempStr = \"\"#找出栈内最后一个[]内的字符串\r\n                while True:\r\n                    j = str(stack.pop())\r\n                    if j.isalpha() == True:\r\n                        tempStr = j + tempStr\r\n                    elif j == \"[\":\r\n                        break\r\n                tempInt = \"\"#找出栈内最后一个连续数字\r\n                # print(stack, tempStr, tempInt,\"-\")\r\n                while True:\r\n                    try:\r\n                        k = stack.pop()\r\n                        if k.isnumeric() == True:\r\n                            tempInt = k + tempInt\r\n                        else:\r\n                            stack.append(k)#如果是非数字，再次入栈\r\n                            break\r\n                    except:#用于边界条件【其实不稳固】\r\n                        break\r\n                # print(stack,tempStr,tempInt)\r\n                stack.append(tempStr*int(tempInt))\r\n                # print(stack)\r\n            else:\r\n                stack.append(i)\r\n                # print(stack)\r\n        return \"\".join(stack)\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    # s = \"3[a]2[bc]\"\r\n    # s = \"3[a2[c]]\"\r\n    # s = \"2[abc]3[cd]ef\"\r\n    # s = \"abc3[cd]xyz\"\r\n    s = \"100[leetcode]\"\r\n    result = Solution().decodeString(s)\r\n    print(result)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918676232","body":"## 思路\r\npeekIndex作为指针记录最后一位，Alist和Blist实现push和pop，在pop里面等BList空了才把A倒过去\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.Alist = []\r\n        self.Blist = []\r\n        self.peekIndex = None\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.Alist.append(x)\r\n        if len(self.Alist)== 1:\r\n            self.peekIndex = x\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        #如果B为空，就从A倒到B再处理\r\n        if len(self.Blist) == 0 and len(self.Alist) == 0:\r\n            return None\r\n        if len(self.Blist) != 0:\r\n            return self.Blist.pop()\r\n        else:\r\n            while len(self.Alist)!=0:\r\n                self.Blist.append(self.Alist.pop())\r\n            self.peekIndex = None\r\n            return self.Blist.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.Blist.__len__() == 0:\r\n            return self.peekIndex\r\n        else:\r\n            return self.Blist[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if self.peekIndex == None and len(self.Blist) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919678484","body":"## 思路\r\n通过单调栈实现逻辑\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for i in arr:\r\n            if stack and stack[-1]>i:\r\n                cur = stack[-1]\r\n                while stack and stack[-1]>i:\r\n                    stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(i)\r\n        return len(stack)\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    arr = [5,4,3,2,1]\r\n    result = Solution().maxChunksToSorted(arr)\r\n    print(result)\r\n\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920474904","body":"## 思路\r\n通过双指针，先把整个链表形成一个循环，然后计算移动到k步之后的链头，断开循环，形成新的链表\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if head  == None:\r\n            return head\r\n        headPoint = head\r\n        length = 1\r\n        while head.next != None:\r\n            head = head.next\r\n            length += 1\r\n        endPoint = head\r\n        endPoint.next = headPoint #形成一个循环\r\n        moveLength = length - (k % length) - 1 #得出移动步数\r\n        print(moveLength)\r\n        while moveLength != 0:\r\n            headPoint = headPoint.next\r\n            moveLength -= 1\r\n        endPoint = headPoint\r\n        headPoint = headPoint.next\r\n        endPoint.next = None\r\n        return headPoint\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921361232","body":"## 思路\r\n先获取一个Pre节点，然后再进行替换遍历\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        startHead = ListNode(-1)\r\n        startHead.next = head\r\n        tempHead = startHead\r\n        while tempHead.next and tempHead.next.next:\r\n            #先获得Node1、Node2\r\n            node1 = tempHead.next\r\n            node2 = tempHead.next.next\r\n            #进行替换\r\n            tempHead.next = node2\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            #移动指针\r\n            tempHead = node1\r\n\r\n        return startHead.next\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922235000","body":"## 思路\r\n通过快慢指针获取到链路中点，然后抽取出来创建二叉树，再通过递归把链路一分为二逐层递归\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if head == None:\r\n            return head\r\n        #快慢指针\r\n        pre, slow, fast = None, head, head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow#pre作为slow【中点】左边的指针存在\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None#把链路从中间断开\r\n        rootTreeNode = TreeNode(slow.val)\r\n        if fast == slow:\r\n            return rootTreeNode\r\n        rootTreeNode.left = self.sortedListToBST(head)\r\n        rootTreeNode.right = self.sortedListToBST(slow.next)\r\n        return rootTreeNode\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XiangyDeng":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917386558","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> answer;\n        answer.resize(s.length());\n\n        for(int i = 0;i < s.length();i++)\n        {\n            int j = i,k = i;\n\n            while(j >= 0 || k <= s.length()-1)\n            {\n                if(j >= 0)\n                {\n                    if(s[j] == c)\n                    {\n                        answer[i] = abs(i-j);\n                        break; \n                    }\n                    j--;\n                }\n                if(k <= s.length())\n                {\n                    if(s[k] == c)\n                    {\n                        answer[i] = abs(i - k);\n                        break;\n                    }\n                    k++;\n                }\n            }\n        }\n        return answer;\n    }\n};\n时间复杂度：O(n^2)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanjyumoso":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917390477","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [len(s)] * len(s)\n\n        j = 0\n        for i in range(len(s)):\n            if s[i] != c:\n                continue\n            ans[i] = 0\n            while j <= i:\n                ans[j] = min(abs(1 + ans[j-1]), abs(i-j)) if j > 0 else abs(i-j)\n                j += 1\n        while j < len(s):\n            ans[j] = 1 + ans[j-1]\n            j += 1\n        return ans\n```\n\n* Time: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917995666","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        # 遇到 】 之前不断进行压栈\n        # 遇到 】 之后开始出栈直到非数字为止，再压栈\n\n        stack = []\n        for c in s:\n            if c == ']':\n                pattern = ''\n                count = ''\n                while stack and stack[-1] != '[':\n                    pattern  = stack.pop() + pattern\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    count = stack.pop() + count\n                stack.append(int(count) * pattern)\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920657221","body":"```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # none node. return itself\n        if not head:\n            return head\n        def getLength(head):\n            if not head:\n                return 0\n            n = 0\n            while head:\n                head = head.next\n                n += 1\n            return n\n\n        n = getLength(head)\n        k %= n\n        # if only has one node or k == 0, return itself\n        if k == 0 or n < 2:\n            return head\n        \n        node = head\n        for i in range(0, n - k - 1):\n            node = node.next\n        next = node.next\n        node.next = None\n        dummy = ListNode(-101)\n        dummy.next = next\n        for i in range(k - 1):\n            next = next.next\n        \n        next.next = head\n        return dummy.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921340565","body":"```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        \n        # if null node or only one node in list, return head\n        if not head or not head.next:\n            return head\n        \n        newHead = ListNode(0)\n        newHead.next = head\n        temp = newHead\n        \n        while temp.next and temp.next.next:\n            # swap node 1 and node 2\n            node1 = temp.next\n            node2 = node1.next\n            temp.next = node2\n            # change the next nodes for node1 and node 2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n        \n        return newHead.next \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922237778","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n\n        if not head:\n            return None\n            \n        elif not head.next:\n            return TreeNode(head.val)\n        fast, slow = head.next.next, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n        cur = slow.next\n        slow.next = None\n        ans = TreeNode(cur.val)\n        ans.left = self.sortedListToBST(head)\n        ans.right = self.sortedListToBST(cur.next)\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922412396","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\n        if not headA or not headB:\n            return None\n\n        pa, pb = headA, headB\n\n        while pa != pb:\n            pa = headB if not pa else pa.next\n            pb = headA if not pb else pb.next\n        return pa\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leige635539766":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917394084","body":"class Solution:\n    def __init__(self, S, C):\n        self.S = S\n        self.C = C\n\n    def Distance(self):\n        C_loc = []\n        min_dis = []\n        for i in range(len(self.S)):\n            if self.S[i] == self.C:\n                C_loc.append(i)\n        for i in range(len(self.S)):\n            distance = []\n            for j in C_loc:\n                distance.append(abs(j-i))\n            min_dis.append(sorted(distance)[0])\n\n        return min_dis\n\n\n\n\n\n\n\n思路： \n  先把字符所在的位置标记出来；\n  再遍历字符串中每个字符距离指定字符最近的距离。\n \n \n \n时间复杂度分析：\n  O(N*K) N位字符串长度 K位指定字符出现的次数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917571670","body":"## 思路\r\n\r\n\r\n满了的条件判断；\r\n空了的条件判断。\r\n\r\n\r\n## 代码\r\n```\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, size):\r\n        self.size = size\r\n        self.st = []\r\n        self.cnt = 0\r\n\r\n\r\n    def push(self, x):\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n\r\n    def pop(self):\r\n        if self.cnt == 0: return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n\r\n\r\n    def increment(self, k, val):\r\n        for i in range(0, min(self.cnt, k)):\r\n            self.st[i] += val\r\n```\r\n## 时间复杂度\r\n\r\nO(min(cnt, k))\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918120939","body":"\r\n## 思路:\r\n根据栈的特点  先进后出   还有括号的判断   在讲义中有提到\r\n\r\n\r\n\r\n\r\n## 代码\r\n```\r\nclass Solution:\r\n\r\n    def __init__(self, S):\r\n        self.S = S\r\n\r\n\r\n\r\n    def RecodeString(self):\r\n        stack = []\r\n        result = \"\"\r\n        for c in self.S:\r\n            if c == ']':\r\n                reStr = ''\r\n                reCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    reStr = stack.pop() + reStr\r\n\r\n                stack.pop()   \r\n                while stack and stack[-1].isnumeric():\r\n                    reCount = stack.pop() + reCount\r\n                stack.append(reStr * int(reCount))\r\n            else:\r\n                stack.append(c)\r\n\r\n        return result.join(stack)\r\n\r\n```\r\n\r\n\r\n\r\n\r\n## 时间复杂度分析:\r\nO(N)  N为输入的数组长度\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918911463","body":"\r\n\r\n## 思路：\r\n分为两个栈  一个用来操作  一个用来存储   “先进后出”\r\n\r\n\r\n\r\n\r\n```\r\nclass Myqueue:\r\n\r\n    def __init__(self, x):\r\n\r\n        self.x = x\r\n        self.stack = []\r\n        self.othstack = []\r\n\r\n\r\n    def push(self):\r\n\r\n        while self.stack:\r\n            self.othstack.append(self.stack.pop())\r\n        self.othstack.append(self.x)\r\n        while self.othstack:\r\n            self.stack.append(self.othstack.pop())\r\n\r\n\r\n    def pop(self):\r\n\r\n        return self.stack.pop()\r\n\r\n\r\n\r\n    def peek(self):\r\n\r\n        return  self.stack[-1]\r\n\r\n\r\n    def empty(self):\r\n\r\n        return not bool(self.stack)\r\n\r\n\r\n```\r\n\r\n\r\n## 时间复杂度：\r\nO(N) N为栈中元素的个数\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919982832","body":"## 思路：\r\n参考官方\r\n先排序 ，排序后为  sorted_arr\r\n\r\n从左到右遍历 arr，比如遍历到了索引为 i 的元素，其中 0 <= i < len(arr)\r\n\r\n如果 arr[:i+1] 的计数信息和 sorted_arr[:i+1] 的计数信息一致，那么说明可以分桶，否则不可以。\r\n\r\n\r\n\r\n## 时间复杂度：\r\nO（N^2）\r\n\r\n\r\n\r\n\r\n## 代码\r\n\r\n```\r\n\r\nimport collections\r\n\r\nclass Solution:\r\n    def __init__(self, x):\r\n        self.x = x\r\n\r\n        self.counta = collections.defaultdict(int)\r\n        self.countb = collections.defaultdict(int)\r\n\r\n\r\n    def max(self):\r\n        maxt = 0\r\n        for a, b in zip(self.x, sorted(self.x)):\r\n            self.counta[a] += 1\r\n            self.countb[b] += 1\r\n            if self.counta == self.countb:\r\n                maxt += 1\r\n        return maxt\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920725432","body":"'''\r\n## 思路\r\n首先我们看下如何返回链表倒数第 k 个节点。\r\n\r\n采用快慢指针\r\n\r\n快指针与慢指针都以每步一个节点的速度向后遍历\r\n\r\n快指针比慢指针先走 k 步\r\n\r\n当快指针到达终点时，慢指针正好是倒数第 k 个节点\r\n\r\n\r\n\r\n## 算法时间的复杂度\r\n\r\nO(N) \r\n\r\n\r\n## 代码\r\n\r\n```\r\nclass Solution:\r\n\r\n    def rotateRight(self, head, k):\r\n        if head:\r\n            p1 = head\r\n            p2 = head\r\n            count = 1\r\n            i = 0\r\n            while i < k:\r\n                if p2.next:\r\n                    count += 1\r\n                    p2 = p2.next\r\n                else:\r\n                    k = k % count\r\n                    i = -1\r\n                    p2 = head\r\n                i += 1\r\n\r\n            while p2.next:\r\n                p1 = p1.next\r\n                p2 = p2.next\r\n\r\n            if p1.next:\r\n                tmp = p1.next\r\n            else:\r\n                return head\r\n            p1.next = None\r\n            p2.next = head\r\n            return tmp\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921725891","body":"\r\n## 思路 \r\n关注最小子结构，即将两个节点进行逆转。\r\n\r\n将逆转后的尾节点.next 指向下一次递归的返回值\r\n\r\n返回逆转后的链表头节点（ps:逆转前的第二个节点）\r\n\r\n\r\n\r\n## 时间复杂度\r\nO(N)\r\n\r\n\r\n## 代码\r\n```\r\nclass Solution:\r\n    def __init__(self, head):\r\n        self.head = head\r\n\r\n    def swapPairs(self):\r\n        if not self.head or not self.head.next:\r\n            return self.head\r\n\r\n        next = self.head.next\r\n        self.head.next = self.swapPairs(next.next)\r\n        next.next = self.head\r\n\r\n        return next\r\n```\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922268462","body":"参考官方\r\n\r\n## 思路\r\n\r\n定义一个快指针每步前进两个节点，一个慢指针每步前进一个节点\r\n\r\n当快指针到达尾部的时候，正好慢指针所到的点为中点\r\n\r\n\r\n\r\n\r\n## 代码\r\n\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head) :\r\n        if not head:\r\n            return head\r\n        pre, slow, fast = None, head, head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n\r\n        return node\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n````\r\n\r\n\r\n\r\n\r\n## 时间复杂度为\r\nO(nlogn)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922392624","body":"\r\n## 思路\r\n看两个链条相交的节点\r\n\r\n\r\n\r\n## 时间复杂度\r\nO(N)\r\n\r\n\r\n\r\n\r\n## 代码\r\n```\r\nclass Solution:\r\n    def getNode(self, A, B):\r\n        Ha, Hb =A,B\r\n        while Ha != Hb:\r\n            Ha = Ha.next if Ha else B\r\n            Hb = Hb.next if Hb else A\r\n        return Ha\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Master-guang":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917405597","body":"Leetcode 821 字符的最短距离\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n题目思路：\n把输入字符 C 看成分界线，将 S 划分成一个个窗口。\n然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\n\n代码：\nvar shortestToChar = function (S, C) {\n  let left = S[0] === C ? 0 : Infinity\n  let right = S.indexOf(C, 1);\n\n  let res = Array(S.length);\n\n  for (let i = 0; i < S.length; i++) {\n    res[i] = Math.min(Math.abs(i - left), Math.abs(right - i));\n\n    if (i === right) {\n      left = right;\n      right = S.indexOf(C, left + 1);\n    }\n  }\n\n  return res;\n};\n\n复杂度分析\n时间复杂度：O(N)，N 是 S 的长度。\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917654622","body":"> # 1381. 设计一个支持增量操作的栈\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n> \r\n> ## 前置知识\r\n> * 栈\r\n> * 前缀和\r\n> \r\n\r\n语言：Pyhton\r\n\r\n1. 解题思路1：简单数组操作\r\n使用数组的栈结构，进出栈分别通过简单的数组赋值与读取进行操作，increment函数通过一个循环进行赋值操作\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top < len(self.stack)-1:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top is -1:\r\n            return self.top\r\n        else:\r\n            self.top -= 1\r\n            return self.stack[self.top+1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k,self.top+1)):\r\n            self.stack[i] += val\r\n\r\n时间复杂度：O（k），由复杂度最高的函数increment决定，因为有一个for循环，其他函数都是常量复杂度。\r\n空间复杂度：O（maxSize）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919276207","body":"语言：Python\n思路：双栈：将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于pop和peek操作\n\n代码： def __init__(self):\n    \"\"\"\n    Initialize your data structure here.\n    \"\"\"\n    self.queue1 = list()\n    self.queue2 = list()\n\ndef push(self, x: int) -> None:\n    \"\"\"\n    Push element x to the back of queue.\n    \"\"\"\n    self.queue1.append(x)\n\ndef pop(self) -> int:\n    \"\"\"\n    Removes the element from in front of queue and returns that element.\n    \"\"\"\n    if not self.queue2:\n        while self.queue1:\n            self.queue2.append(self.queue1.pop())\n    \n    return self.queue2.pop()\n\ndef peek(self) -> int:\n    \"\"\"\n    Get the front element.\n    \"\"\"\n    if self.queue1:\n        return self.queue1[0]\n    else:\n        return self.queue2[-1]\n\ndef empty(self) -> bool:\n    \"\"\"\n    Returns whether the queue is empty.\n    \"\"\"\n    if not self.queue1 and not self.queue2:\n        return True\n    else:\n        return False\n\n时间复杂度：O（1）\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920039099","body":"困难题果然难很多，题目读半天\r\n思路\r\n单调递增栈，从左往右遍历数组arr，如果当前值arr[i] >= 单调栈的栈顶元素的值，arr[i]直接入栈，如果当前值arr[i] < 单调栈的栈顶元素时，栈顶元素出栈后，先把它临时保存为此时栈的最大值max，循环继续比较arr[i]和下一个栈顶元素的大小\r\n代码\r\njavascript\r\n\r\n/*\r\n *\r\n * [768] 最多能完成排序的块 II\r\n */\r\n\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted1 = function (arr) {\r\n    let stack = [];\r\n\r\n    for (let val of arr) {\r\n        if (!stack.length || stack[stack.length - 1] <= val) {\r\n            stack.push(val);\r\n        } else {\r\n            let curMax = stack.pop();\r\n            while (stack.length && stack[stack.length - 1] > val) {\r\n                stack.pop();\r\n            }\r\n            stack.push(curMax);\r\n        }\r\n    }\r\n    return stack.length;\r\n}\r\n\r\n复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920533579","body":"语言：JavaScript\n\n思路\n\n- 快慢指针\n- 与链表长度成整数倍的「旋转」都是没有意义的（旋转前后链表不变），使用「快慢指针」找到倒数第 k 个节点，然后完成基本的链接与断开与断开操作\n\n代码\n\n    var rotateRight = function(head, k) {\n        if(head === null || k === 0)return head;   \n        var tot = 0;\n        var tmp = head;\n        while (tmp !== null && ++tot > 0) tmp = tmp.next;\n        k %= tot;\n        if (k == 0) return head;\n        \n        var slow = head, fast = head;\n        while (k-- > 0) fast = fast.next;\n        while (fast.next !== null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n    \n        var nHead = slow.next;\n        slow.next = null;\n        \n        fast.next = head;\n        return nHead;\n    };\n\n复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922273614","body":"语言：JavaScript\n\n思路\n\n- 递归分治思想\n- 找到链表中点即为树的根，同时将链表拆为两段，分出左右两部分，再提起各自的中点作为根节点……分治下去，依次递归下去\n\n代码\n\n    const sortedListToBST = (head) => {\n      const arr = [];\n      while (head) { \n        arr.push(head.val);\n        head = head.next;\n      }\n      const buildBST = (start, end) => {\n        if (start > end) return null;       \n        const mid = (start + end) >>> 1;    \n        const root = new TreeNode(arr[mid]); \n        root.left = buildBST(start, mid - 1); \n        root.right = buildBST(mid + 1, end); \n        return root;     \n      };\n    \n      return buildBST(0, arr.length - 1); \n    };\n    \n\n复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"summer506hai":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917418464","body":"#-*- coding : utf-8 -*-\n'''\n遍历字符串，找到目标字母，用cIndices数组记下位置. 遍历字符串，将当前位置与cIndices数组的位置进行相减，取最小值\n'''\ndef shortestToChar(S, C):\n    cIndices = []\n    res = []\n    for i,x in enumerate(S):\n        if x == C:\n            cIndices.append(i)\n    for i,x in enumerate(S):\n        r = float('inf')\n        for j,y in enumerate(cIndices):\n            r = min(r,abs(i - y))\n        res.append(r)\n    return res\n\nprint(shortestToChar(\"loveleetcode\",\"e\"))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917610041","body":"## 解题思路\n- 创建inc数组用来记录增量操作\n## 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.cnt = 0\n        self.maxSize = maxSize\n        self.inc = []\n        self.st = []\n\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.maxSize:\n            self.st.append(x)\n            self.cnt = self.cnt + 1\n            self.inc.append(0)\n\n\n    def pop(self) -> int:\n        if self.cnt == 0:\n            return -1\n        self.cnt -= 1\n        if self.cnt >= 1:\n            self.inc[-2] += self.inc[-1]\n        return self.st.pop() + self.inc.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.cnt:\n            self.inc[min(k,self.cnt)-1] += val\n            #print(self.inc)\n\n\nif __name__ == '__main__':\n    obj = CustomStack(3)\n    obj.push(1)\n    obj.push(2)\n    obj.pop()\n    obj.push(2)\n    obj.push(3)\n    obj.push(4)\n\n    obj.increment(5, 100)\n    obj.increment(2, 100)\n    print(obj.pop())\n    print(obj.pop())\n    print(obj.pop())\n    print(obj.pop())\n```\n## 算法复杂度\n时间负责度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918177087","body":"## 解题思路\r\n- 用栈\r\n- 非 ']' 入栈操作\r\n- 若遇到数字，则将 reStr * 数字（次数）\r\n- '[' 出栈\r\n## 代码\r\n```python\r\n#-*- coding : utf-8 -*-\r\n'''\r\n字符串解码\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n'''\r\ndef decodeString(s):\r\n    stack = []\r\n    for i in s:\r\n        if i == ']':\r\n            reStr = ''\r\n            reCount = ''\r\n            while stack and stack[-1] != '[':\r\n                reStr = stack.pop() + reStr\r\n\r\n            stack.pop()\r\n\r\n            while stack and stack[-1].isnumeric():\r\n                reCount = stack.pop() + reCount\r\n\r\n            stack.append(reStr*int(reCount))\r\n\r\n\r\n        else:\r\n            stack.append(i)\r\n\r\n    return \"\".join(stack)\r\n\r\nif __name__ == '__main__':\r\n    print(decodeString(\"3[a2[c]]\"))\r\n\r\n```\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922470588","body":"import java.util.HashSet;\nimport java.util.Set;\n\npublic class leetcode_160 {\n\n    static class ListNode {\n        int val;\n        ListNode next;\n        ListNode(int val){\n            this.val=val;\n        }\n    }\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode temp = headA;\n        Set<ListNode> l = new HashSet<ListNode>();\n        while (temp != null){\n            l.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while (temp != null){\n            if (l.contains(temp)){\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ChenJingjing85":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917419109","body":"## 思路\n遍历字符串直到找到一个匹配位置，记录上一个匹配的位置， 这两个位置之间的字符的最短距离必然由这两个位置产生。注意匹配字符在两端和在中间的不同情况。\n## 代码\n``` java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        char[] ss = s.toCharArray();\n        int lastHitIndex = -99;\n        for(int i = 0; i < s.length(); i ++){\n            if(ss[i] == c){\n                if(lastHitIndex >=0 ){\n                    int mid = (lastHitIndex + i)/2; \n                    int dis = 0;\n                    for(int j = lastHitIndex; j <= mid; j ++){\n                        res[j] = dis++;\n                    }\n                    dis = 0;\n                    for(int j = i; j > mid; j --){\n                        res[j] = dis++;\n                    }\n                }else{\n                    int dis = i;\n                    for (int j = 0; j <= i; j ++){\n                        res[j] = dis--;\n                    }\n                }\n\n                lastHitIndex = i;\n            }\n        }\n        int dis = 0;\n        for(int j = lastHitIndex; j <= s.length()-1; j ++){\n            res[j] = dis++;\n        }\n        return res;\n    }\n}\n```\n## 复杂度分析\n时间复杂度：O(N)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917543324","body":"### 思路\n利用数组实现栈，用一个指针记录栈顶位置\n### 代码\n``` java\nclass CustomStack {\n    private int[] stack;\n    private int top = -1;;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(stack.length-1 > top){\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top>=0){\n            return stack[top--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int incre = Math.min(k, top+1);\n        for(int i = 0; i < incre; i ++){\n            stack[i] = stack[i]+val;\n        }\n\n    }\n}\n```\n### 复杂度分析\n* 增加元素：时间O(1), 空间O（1）\n* 删除元素：时间O(1), 空间O（1）\n* 增量操作：时间O(N), 空间O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918314808","body":"### 思路：\r\n对字符串，数字， 左括号分别建立各自的栈， 遍历字符如各自的栈，字符为右括号时，每个栈分别弹出，计算重复字符串，若左括号栈不为空，得到的字符串继续入字符串栈，否则append到结果中。注意入栈时字符和字母的连续性，需要保留前一个字符做判断，判断是新入栈还是拼接到栈顶元素。同时建立辅助栈，记录数字前面一个字符，在字符串重复计算完后，判断是新入栈还是拼接到字符串栈的栈顶元素。\r\n### 代码：\r\n``` java\r\nclass Solution {\r\n    public String decodeString(String s) {        StringBuilder sb = new StringBuilder();\r\n        char[] chs = s.toCharArray();\r\n        Stack<Character> bucks = new Stack();\r\n        Stack<Integer> nums = new Stack();\r\n        Stack<Character> numPres = new Stack();\r\n        Stack<String> letters = new Stack();\r\n        boolean isDigitBreak = false;\r\n        boolean isLetterBreak = false;\r\n        Character preChar = null;\r\n        for(int i = 0; i < chs.length; i ++){\r\n            char c = chs[i];\r\n            if(bucks.isEmpty() && Character.isLetter(c)){\r\n                sb.append(String.valueOf(c));\r\n                isDigitBreak = false;\r\n                isLetterBreak = true;\r\n                preChar = c;\r\n            }else if(Character.isDigit(c)){\r\n            \t int num = Integer.valueOf(String.valueOf(c));\r\n                 if(preChar != null && Character.isDigit(preChar)){\r\n                     int pre = nums.pop();\r\n                     nums.push(pre*10+num);\r\n                 }else{\r\n                    nums.push(num);\r\n                    numPres.push(preChar);\r\n                 }\r\n                 \r\n                 preChar = c;\r\n            }else if(Character.isLetter(c)){\r\n                String sc = String.valueOf(c);\r\n                 if(preChar != null && Character.isLetter(preChar)){\r\n                     String pre = letters.pop();\r\n                     letters.push(pre+sc);\r\n                 }else{\r\n                    letters.push(sc);\r\n                 }           \r\n                 preChar = c;\r\n            }else if(c == '['){\r\n                bucks.push(c);\r\n                preChar = c;\r\n            }else if(c == ']'){\r\n                bucks.pop();\r\n                int num = nums.pop();\r\n                Character numPre = numPres.pop();\r\n                String letter = letters.pop();\r\n                StringBuilder sbTemp = new StringBuilder();\r\n                while(num>0){\r\n                    sbTemp.append(letter);\r\n                    num--;\r\n                }\r\n                String temp = sbTemp.toString();\r\n                if(bucks.isEmpty()){\r\n                \tsb.append(temp);\r\n                }else{\r\n                \tif(numPre != null && (Character.isLetter(numPre))){\r\n                        String pre = letters.pop();\r\n                        letters.push(pre+temp);\r\n                    }else{\r\n                        letters.push(temp);\r\n                    }\r\n                }\r\n            }\r\n            \r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919185381","body":"### 思路\n使用两个栈，push时始终往栈1push， pop或peek时，栈1元素全部倒过来到栈2中，栈2不为空时，不能push， 要先把栈2的全部倒入栈1中，才能push元素。两个栈全空时判断为空。\n### 代码\n``` java\nclass MyQueue {\n    private Stack<Integer> stack = new Stack();\n    private Stack<Integer> stack2 = new Stack();\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        while(!stack2.isEmpty()){\n            stack.push(stack2.pop());\n        }\n        stack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        while(!stack.isEmpty()){\n            stack2.push(stack.pop());\n        }\n        return stack2.pop();\n\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        while(!stack.isEmpty()){\n            stack2.push(stack.pop());\n        }\n        return stack2.peek();\n\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack.isEmpty() && stack2.isEmpty();\n\n    }\n}\n```\n### 复杂度分析\n* 时间复杂度：push, pop, peek 操作最好情况O(1), 最坏情况O(N),   push和peek/pop操作交换进行最耗时。\n* 空间复杂度； O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920136062","body":"### 思路\r\n归并，先扫一遍按递增分块，存放每块最大最小值，再扫一遍归并块，以保证前一个块中的最大值小于等于后一块中最小值\r\n\r\n### 代码\r\n``` java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> mins = new Stack();\r\n        Stack<Integer> maxs = new Stack();\r\n        mins.push(arr[0]);\r\n        maxs.push(arr[0]);\r\n        int count = 1;\r\n        for(int i = 1; i< arr.length; i ++){        \t\r\n            int preMax = maxs.peek();\r\n            int preMin = mins.peek();\r\n            if(arr[i] < preMin){\r\n                mins.pop();\r\n                mins.push(arr[i]);\r\n            }else if(arr[i] >= preMax){\r\n                maxs.push(arr[i]);\r\n                mins.push(arr[i]);\r\n            }\r\n        }\r\n        while (!maxs.isEmpty()){\r\n            int min = mins.pop();\r\n            int max = maxs.pop();\r\n            if(maxs.isEmpty()){\r\n            \tbreak;\r\n            }\r\n            int preMax = maxs.peek();\r\n            int preMin = mins.peek();\r\n            if(min>= preMax){\r\n                count++;\r\n            }else if(min < preMin){\r\n                if(min < preMin){\r\n                    mins.pop();\r\n                    mins.push(min);\r\n                }\r\n               \r\n            } \r\n        }\r\n\r\n        return count;\r\n\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n* 时间复杂度 O(N^2)\r\n* 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920952855","body":"### 思路\n走一遍链表得到链表长度和最后一个节点tail指针，移动步数对链表长度取余得到就是链表倒数第几个结点会断开， 断开处前一个节点的next指null， 断开处后一个结点是需返回的新的head, \n将原来的tail的next指向原来的head即可。\n### 代码\n``` java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null){\n            return null;\n        }\n        int length = 1;\n        ListNode last = head;\n        while(last.next != null){\n            last = last.next;\n            length++;\n        }\n        int count = length - k % length;\n        if(count == length){\n            return head;\n        }\n        \n        ListNode newHead = head.next;\n        ListNode newLast = head;\n        while(count > 1){\n            newLast = newLast.next;\n            newHead = newHead.next;\n            count--;\n        }\n        newLast.next = null;\n        last.next = head;\n        return newHead;\n    }\n}\n```\n### 复杂度分析\n* 时间复杂度 O(N)\n* 空间复杂度 O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921900645","body":"### 思路\n遍历链表，奇数位置记录节点，偶数位置交换结点\n### 代码\n``` java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null){\n            return null;\n        }\n        ListNode n = head;\n        ListNode newHead = head;\n        ListNode pre = null;\n        ListNode next = null;\n        int i = 1;\n        while(n != null){\n            if(i <= 2){\n                newHead = n;\n            }\n            next = n.next;\n            if(i%2 == 1){\n                if(pre != null){\n                    pre.next = n;\n                }\n                pre = n;\n            }else{\n                pre.next = null;\n                n.next = pre;\n            }\n            n = next;\n            i++;\n        }\n        return newHead;\n    }\n}\n```\n### 复杂度分析\n* 时间复杂度 O(N)\n* 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922331346","body":"### 思路\n找到链表中点作为树根节点，不断在左边子链表中递归找中点建立左子树，右边子链表中递归找中点建立右子树，直到子链表大小为1。找中点可利用快慢指针。\n### 代码\n``` java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head.next == null){\n            return new TreeNode(head.val);\n        }\n        ListNode tail = head;\n        while(tail.next != null){\n            tail = tail.next;\n        }\n        return buildTree(head, tail);\n    }\n\n    public TreeNode buildTree(ListNode head, ListNode tail){\n         if(head == tail){\n            return new TreeNode(head.val);\n        }\n        ListNode mid = getMid(head, tail);         \n        TreeNode leftTree = buildTree(head, mid);\n        TreeNode rightTree = buildTree(mid.next, tail);\n        return new TreeNode(mid.val, leftTree, rightTree);\n    }\n\n    public ListNode getMid(ListNode head, ListNode tail){\n        if(head == null || tail == null){\n            return null;\n        }\n        if(head == tail){\n            return null;\n        }        \n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast.next != null && fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n### 复杂度分析\n* 时间复杂度 O(NlogN)\n* 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922456717","body":"### 思路\n先分别遍历链表得到两者长度和最后一个节点， 若两者最后一个节点不相同说明两者无相交，返回空，否则， 计算长度差diff， 长者先走diff步，然后两者同步走，每步判断节点是否相同，相同则返回。\n### 代码\n``` java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = 0;\n        int lenB = 0;\n        ListNode  tailA = headA;\n        while(tailA != null){\n            lenA++;\n            tailA = tailA.next;\n        }\n        ListNode  tailB = headB;\n        while(tailB != null){\n            lenB++;\n            tailB = tailB.next;\n        }\n        if(tailA != tailB){\n            return null;\n        }\n        int diff = lenB-lenA;\n        ListNode a=headA;\n        ListNode b=headB;\n        if(diff > 0){\n            while(diff>0){\n                b = b.next;\n                diff--;\n            }\n        }else if(diff < 0 ){\n            while(diff<0){\n                a = a.next;\n                diff++;\n            }\n        }\n        while(a != null){\n            if(a == b){\n                return a;\n            }\n            a = a.next;\n            b = b.next;\n        }\n        return null;\n    }\n}\n```\n### 复杂度分析\n* 时间复杂度：O(N)\n* 空间复杂度： O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917422144","body":"思路\n---------\n模拟竖式加法运算过程，逐位相加，需要记录进位数值。在循环结束后，判断进位值是否为0，若不为零，则加入list中。\n\n代码\n---------\n语言:Java \n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n\tif(num==null||num.length==0) {\n\t\treturn new ArrayList<Integer>();\n\t}\n\tint carry = 0;\n\tint i = num.length-1,flag=k%10;\n\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile(i>=0||k!=0) {\n\t\tint temp = i<0?flag+carry:num[i]+flag+carry;\n\t\tlist.add(0, temp%10);\n\t\tcarry = temp/10;\n\t\ti--;\n\t\tif(k!=0) {\n\t\t\tk=k/10;\n\t\t\tflag=k%10;\n\t\t}\n\t}\n\tif(carry!=0) {\n\t\tlist.add(0, carry);\n\t}\n\treturn list;\n}\n```\n\n复杂度\n--------\n时间复杂度：O（n）\n空间复杂度：O（n）","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917427308","body":"思路\n-------\n学习官方解法，左右各遍历一遍\n\n代码\n-------\n语言：java\n```java\npublic int[] shortestToChar(String s, char c) {\n\tint len=s.length();\n\tint[] ans =new int[len];\n\tint pre = Integer.MIN_VALUE/2;\n\tfor(int i=0;i<len;i++) {\n\t\tif(s.charAt(i)==c) {\n\t\t\tpre = i;\n\t\t}\n\t\tans[i] = i-pre;\n\t}\n\tpre = Integer.MAX_VALUE;\n\tfor(int i=len-1;i>=0;i--) {\n\t\tif(s.charAt(i)==c) {\n\t\t\tpre = i;\n\t\t}\n\t\tans[i] = Math.min(ans[i], pre-i);\n\t}\n\treturn ans;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917596611","body":"思路\n-------\n用数组模拟栈，这次依旧参考了官方的代码，一开始想用数组模拟队列的代码修改一下，结果反而想复杂了。\n\n代码\n-------\n```java\nclass CustomStack {\n    int[] stack;\n    int head=-1;\n    int maxSize=0;\n    public CustomStack(int maxSize) {\n        this.stack=new int[maxSize];\n        this.maxSize=maxSize;\n    }\n    public void push(int x) {\n        if(head>=maxSize-1) {\n            return;\n        }\n        head++;\n        stack[head]=x;\n    }\n    public int pop() {\n        if(head==-1) {\n            return -1;\n        }\n        head--;\n        int res=stack[head+1];\n        stack[head+1]=0;\n        return res;\n    }\n    public void increment(int k, int val) {\n        if(k>=maxSize) {\n            k=maxSize;\n        }\n        for(int i=0;i<=k-1;i++) {\n            stack[i]+=val;\n        }\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921029401","body":"思路\n----------\n首先找出链表的尾部和长度，通过计算得到旋转后链表的新尾部。将链表旧尾部的next=head，新尾部的next为空即可。\n\n代码\n------\n语言：Java\n```Java\npublic ListNode rotateRight(ListNode head, int k) {\n    if(head==null){\n        return null;\n    }\n    if(k==0){\n        return head;\n    }\n    ListNode tail = head;\n    ListNode flag=head;\n    int size=1;\n    while(tail.next!=null){\n        tail=tail.next;\n        size++;\n    }\n    int index = size-(k%size);\n    for(int i=1;i<index;i++){\n        flag=flag.next;\n    }\n    tail.next=head;\n    ListNode res = flag.next;\n    flag.next=null;\n    return res;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921907730","body":"思路\n--------\n参考了官方解法\n\n代码\n--------\n```Java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head==null){\n            return null;\n        }\n        if(head.next==null){\n            return head;\n        }\n        ListNode dummyHead = new ListNode();\n        dummyHead.next=head;\n        ListNode cur = dummyHead,node1 = head,node2 = head;\n        while(cur.next!=null&&cur.next.next!=null){\n            node1=cur.next;\n            node2=cur.next.next;\n            cur.next=node2;\n            node1.next=node2.next;\n            node2.next=node1;\n            cur=cur.next.next;\n        }\n        return dummyHead.next;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihuiwen":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917428923","body":"## 思路\n正序遍历和反序遍历\n## 代码\n```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  let dis = Infinity\n  const ret = []\n  for (let i = 0; i < s.length; i++) {\n    const cur = s[i]\n    if (cur === c) {\n      dis = 0\n    } else {\n      dis++\n    }\n    ret.push(dis)\n  }\n\n  for (let i = s.length - 1; i >= 0; i--) {\n    const cur = s[i]\n    if (cur === c) {\n      dis = 0\n    } else {\n      dis++\n    }\n    ret[i] = Math.min(dis, ret[i])\n  }\n\n  return ret\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917659625","body":"## 思路\n用数组模拟栈\n## 代码\n```\nvar CustomStack = function (maxSize) {\n  this.maxSize = maxSize\n  this.stack = []\n}\n\nCustomStack.prototype.push = function (x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x)\n}\n\nCustomStack.prototype.pop = function () {\n  return this.stack.length > 0 ? this.stack.pop() : -1\n}\n\nCustomStack.prototype.increment = function (k, valu) {\n  let len = Math.min(k, this.stack.length)\n  for (let i = 0; i < len; i++) {\n    this.stack[i] += val\n  }\n}\n```\n## 复杂度\n时间复杂度：O(1)push、O(1)pop 、O(n)inc\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918330799","body":"## 思路\n用栈接入字符串，匹配到字母和'['的时候就入栈，匹配到']'的时候保存当前结果，最后得出结果\n\n## 代码\n```\nvar decodeString = function (s) {\n    let numStack = [];\n    let strStack = [];\n    let num = 0;\n    let result = \"\";\n    for (let char of s) {\n        if (!isNaN(char)) {\n            num = num * 10 + Number(char);\n        } else if (char === \"[\") {\n            numStack.push(num);\n            num = 0;\n            strStack.push(result);\n            result = \"\";\n        }else if(char ===\"]\"){\n            let repeatNum = numStack.pop();\n            result = strStack.pop() + result.repeat(repeatNum);\n        }else{\n            result += char;\n        }\n    }\n    return result;\n};\n```\n\n## 复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919273019","body":"## 思路\n双栈，一个输入一个输出\n## 代码\n```\nclass MyQueue {\n\nconstructor() {\n    this.inStack = [];\n    this.outStack = [];\n}\npush(x) {\n    this.inStack.push(x)\n}\n\npop() {\n    this.in2out()\n    return this.outStack.pop()\n}\n\npeek() {\n    this.in2out()\n    return this.outStack[this.outStack.length - 1]\n}\n\nempty() {\n    return !this.inStack.length && !this.outStack.length\n}\nin2out() {\n    if (!this.outStack.length) {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n}\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920142713","body":"## 思路\n单调栈递增，如果后面的元素小于前面的元素，则压缩到前面比它大的元素中。\n\n## 代码\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n    let stack = [];\n    for (let i = 0; i < arr.length; i++) {\n        let a = arr[i];\n        if (stack.length > 0 && stack[stack.length - 1] > a) {\n            let cur = stack[stack.length - 1];\n            while (stack.length > 0 && stack[stack.length - 1] > a) stack.pop();\n            stack.push(cur);\n        } else {\n            stack.push(a)\n        }\n    }\n    return stack.length;\n};\n```\n## 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921027393","body":"## 思路\n先把链表拼成环，然后算出要移动几次，最后断开链表\n\n## 代码\n```\n\nvar rotateRight = function (head, k) {\n  if (k === 0 || !head.next) {\n    return head\n  }\n  let count = 0\n  let cur = head\n  while (cur.next) {\n    cur = cur.next\n    count++\n  }\n  let n = count - k % count\n  if (n === count) {\n    return head\n  }\n  cur.next = head\n  while (n > 1) {\n    cur = cur.next\n  }\n  let temp = cur.next\n  cur.next = null\n  return temp\n}\n```\n\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921903714","body":"## 思路\n两两迭代\n\n## 代码\n```\nvar swapPairs = function(head) {\n    let dummy = new ListNode(-1, head)\n    let pre = dummy\n\n    while(pre.next && pre.next.next) {\n        //定义两相邻节点的指针\n        let l1 = pre.next, l2 = pre.next.next\n        //交换操作 4步\n        next = l2.next\n        l1.next = next\n        l2.next = l1\n        pre.next = l2\n        //pre跳到后面第二个节点(交换后的)\n        pre = l1\n    }\n    return dummy.next\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922266052","body":"## 思路\n二叉树搜索\n\n## 代码\n```\nvar sortedListToBST = function (head) {\n  if (!head) return null;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast != tail && fast.next != tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head, slow);\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922494706","body":"## 思路\n双指针\n\n## 代码\n```\nvar getIntersectionNode = function(headA, headB) {\n    //要求链表必须 保持原始结构\n    //用指针指向\n    // a + c + b === b + c + a\n    var a = headA, b = headB\n    while(a !== b) {\n        a = (a === null)? headB : a.next;\n        b = (b === null)? headA : b.next;\n    }\n    return a\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhy3213":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429931","body":"# 思路\n\n保存位置，计算差值，找最小\n\n```\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos=[]\n        res=[]\n        for i, cha in enumerate(s):\n            if cha==c:\n                pos.append(i)\n        for i in range(len(s)):\n            res.append(min([abs(j-i) for j in pos]))\n        return res\n```\n\n写起来很方便但理论时间复杂度O(N^2)，空间O(N)\n\n而实际执行中根据所选字符的频率，再加入合理的剪枝，执行速度并不会较左右遍历有很大差距。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917549491","body":"# 思路\nlazy increment: 维护一个增量数组，由于是底部k个值同时增加，可以在需要增加的最顶元素上标记仅标记一次，在pop时再进行加操作，即可实现O(1)的increment\n\n# 代码\n```python\ndef __init__(self, maxSize: int):\n        self.stk=[]\n        self.inc=[]\n        self.maxSize=maxSize\n        self.top=0\n\n    def push(self, x: int) -> None:\n        if self.top == self.maxSize:\n            return\n        self.stk.append(x)\n        self.inc.append(0)\n        self.top+=1\n\n    def pop(self) -> int:\n        if self.top==0:\n            return -1\n        ret=self.stk.pop()\n        ret+=self.inc[self.top-1]\n        if self.top>1:\n            self.inc[self.top-2]+=self.inc.pop()\n        else:\n            self.inc.pop()\n        self.top-=1\n        return ret\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stk)==0:\n            return\n        self.inc[min(k,len(self.inc))-1]+=val\n```\n# 复杂度\n空间O(N)\n时间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918334361","body":"# 那一天人们终于想起了 被编译原理支配的恐惧","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918751386","body":"# 思路\n两个栈互相倒，用头就反过来，用尾就翻过去。\n```python\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stk=[]\n        self.rstk=[]\n        self.r=False\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self.r:\n            self.stk.append(x)\n        else:\n            while(len(self.rstk)>0):\n                self.stk.append(self.rstk.pop())\n            self.stk.append(x)\n            self.r=False\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.r:\n            return self.rstk.pop()\n        else:\n            while(len(self.stk)>0):\n                self.rstk.append(self.stk.pop())\n            self.r=True\n            return self.rstk.pop()\n                \n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.r:\n            return self.rstk[-1]\n        else:\n            while(len(self.stk)>0):\n                self.rstk.append(self.stk.pop())\n            self.r=True\n            return self.rstk[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.stk)==0 and len(self.rstk)==0\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920538437","body":"# 思路\n建立索引，修改指针\n# 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        if not head.next:\n            return head\n        if k==0:\n            return head\n        temp=head\n        index=[head]\n        while temp.next:\n            temp=temp.next\n            index.append(temp)\n        l=len(index)\n        k=k%l\n        if k==0:\n            return head\n        index[-1].next=head\n        index[l-k-1].next=None\n        return index[l-k]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921889428","body":"# 思路\n三指针，循环使用\n# 代码\n```python\ndef swapPairs(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        if not head.next:\n            return head\n        fakehead=ListNode(0,head)\n        ptr=[fakehead,head,head.next]\n        count=0\n        while ptr[(count+1)%3].next:\n            ptr[(count)%3].next=ptr[(count+2)%3]\n            ptr[(count)%3]=ptr[(count+2)%3].next\n            ptr[(count+2)%3].next=ptr[(count+1)%3]\n            if not ptr[(count)%3]:\n                ptr[(count+1)%3].next=None\n                break\n            ptr[(count+1)%3].next=ptr[(count)%3]\n            ptr[(count+2)%3]=ptr[(count+1)%3]\n            ptr[(count+1)%3]=ptr[(count)%3].next\n            count+=2\n        return fakehead.next\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917429949","body":"```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        ArrayList<Integer> arr = new ArrayList<>();\r\n        int[] ret = new int[s.length()];\r\n        int p = 0;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) arr.add(i);\r\n        }\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\r\n            ret[i] = Math.abs(arr.get(p) - i);\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917644778","body":"## 思路\r\n用数组来模拟栈操作\r\n1. pop时候需要栈考虑是否已空,且返回的是删除的值\r\n2. push时候需要栈考虑是否已满\r\n## 代码\r\nJava实现\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != stack.length - 1){\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top != -1){\r\n            top--;\r\n            return stack[top+1];\r\n        }else{\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int min = Math.min(k, top+1);\r\n        for(int i=0;i<min;i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hibriansun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917450963","body":"## Main idea\r\n自己的思路要么没考虑到Edge Cases要不错误\r\n干脆上官方解法\r\n\r\n笨思路是把数组数字还原出来再加和再还原，但这样有数字溢出问题\r\n官解思路是：例如计算129+79112，两个数组，在原数组上执行[1,2,9+79112] --> [1,2+7912,1] --> [1+791,4,1] --> [79,2,4,1] --> [7,9,2,4,1]\r\n本质是模拟进位\r\n\r\n## Code\r\n```cpp\r\n// C++\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        // 新数组\r\n        vector<int> rtn;\r\n\r\n        for (int i = num.size()-1; i >= 0 || k > 0; i--, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];        // Key Algorithm\r\n            }\r\n            // 可处理多位溢出问题\r\n            rtn.push_back(k % 10);\r\n        }\r\n        \r\n        reverse(rtn.begin(), rtn.end());\r\n        return rtn;\r\n    }\r\n};\r\n```\r\n\r\n## Complexity\r\nTime: O(N)\r\nSpace: O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917439455","body":"## Main idea\r\n一个辅助数组，用于记录在s中出现ch的下标\r\n再来两个辅助指针，适时遍历下标辅助数组\r\n比较当前index距两侧指针距离填入值\r\n注意辅助数组前后填入极值防止数组下标非法访问\r\n\r\n## Code \r\n```cpp\r\n// C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> index;\r\n        vector<int> rtn(s.size());\r\n        index.push_back(INT32_MAX);\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s[i] == c) {\r\n                index.push_back(i); \r\n            }\r\n        }\r\n        index.push_back(INT32_MAX);         // for indeices overflow\r\n\r\n\r\n        for (int i = 0, j = 1, l = index[0], r = index[j]; i < rtn.size(); i++) {\r\n            if (i == index[j]) {\r\n                j++;\r\n                l = r;\r\n                r = index[j];\r\n            }\r\n\r\n            abs(i - l) > abs(i - r) ? rtn[i] = abs(i - r) : rtn[i] = abs(i - l);\r\n        }\r\n\r\n        return rtn;\r\n    }\r\n};\r\n```\r\n\r\n## Complexity\r\nTime: O(N)\r\nSpace: O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917444038","body":"## Main idea\n模拟\n\n## Code\n```cpp\n// C++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (top + 1 < stack.size()) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int rtn = stack[top];\n        top--;\n        return rtn;\n    }\n    \n    void increment(int k, int val) {\n        k > stack.size() ? k = stack.size() : k;\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\nprivate:\n    vector<int> stack;\n    int top = -1;\n};\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n## Complexity\nTime: O(N)\nSpace: O(N)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921905769","body":"// Two pointers point to two nodes\n// Exit when one of pointer point to nullptr\n// Step forward two nodes per step. \n\n// odd\n// 1 -> 2 -> 3\n\n// even\n// 1 -> 2 -> 3 -> 4\n\nstruct ListNode {\n     int val;\n     ListNode *next;\n     ListNode() : val(0), next(nullptr) {}\n     ListNode(int x) : val(x), next(nullptr) {}\n     ListNode(int x, ListNode *next) : val(x), next(next) {}\n };\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n\n        // init\n        ListNode* f = head->next, *b = head, *tmp, *f_backup = f, *b_backup = b, *rtn = head->next;\n\n        // ** Exit condition **\n        while (f) {\n            // Record \n            // Step forward 2 nodes\n            b_backup = f->next;\n            if(b_backup != nullptr) {\n                f_backup = f->next->next;\n            }\n\n            // Swap\n            tmp = f->next;\n            f->next = b;\n            b->next = tmp;\n\n            // Avoid nullptr visit\n            if (b_backup == nullptr) {\n                break;\n            }\n\n            // move \n            f = f_backup;\n            b = b_backup;\n        }\n\n        return rtn;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922154070","body":"## 朴素二分递归\n```cc\n\nclass Solution {\npublic:\n    // Find midle\n    // [a, b)\n    ListNode* findMid(ListNode* head, ListNode* end) {\n        ListNode *fast = head, *slow = head;\n        while (fast != end && fast->next != end) {\n            fast = fast->next;\n            fast = fast->next;\n            slow = slow->next;\n        }\n\n        return slow;\n    }\n\n    TreeNode* buildTree(ListNode* head, ListNode* end) {\n        // Recursive ending\n        // Last recursion (when head->next == end), we donot do with findMid\n        if (head == end) {\n            return nullptr;\n        }\n\n        // 这种情况findMid处理了\n        // if (head->next == end) {\n        //     return new TreeNode(head->val);\n        // }\n\n        ListNode* mid = findMid(head, end);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left  = buildTree(head, mid);\n        root->right = buildTree(mid->next, end);\n\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        // For \"[]\"\n        if (head == nullptr){\n            return nullptr;\n        }\n        \n        return buildTree(head, nullptr);\n    }\n};\n```\n\nO(nlogn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922434736","body":"## 暴力法 -- 停留遍历 O(M*N)\r\n```cc\r\n// Basic solution: O(M*N)\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode* p1 = headA, *p2 = headB;\r\n        while (p1) {\r\n            p2 = headB;\r\n            while (p2) {\r\n                if (p2 == p1) {\r\n                    return p2;\r\n                }\r\n                p2 = p2->next;\r\n            }\r\n            p1 = p1->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```\r\n\r\n## 计算两链表差距以同步 -- 付出较少的前期成本减少后期的损耗 O(N)\r\n```cc\r\n// Avoid more waste\r\n// O(N)\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        int lenA = 0, lenB = 0;\r\n        ListNode* p1 = headA, *p2 = headB;\r\n\r\n        // 先付出一点成本利用数学计算(算法)节省更多花费\r\n        while (p1) {\r\n            lenA++;\r\n            p1 = p1->next;\r\n        }\r\n\r\n        while (p2) {\r\n            lenB++;\r\n            p2 = p2->next;\r\n        }\r\n\r\n        int len = lenA - lenB;\r\n\r\n        p1 = headA; \r\n        p2 = headB;\r\n\r\n        while (p1) {\r\n            if (len > 0) {\r\n                p1 = p1->next;\r\n                len--;\r\n            } else if (len < 0) {\r\n                p2 = p2->next;\r\n                len++;\r\n            } else {\r\n                if (p1 == p2) {\r\n                    return p1;\r\n                }\r\n                p1 = p1->next;\r\n                p2 = p2->next;\r\n            }\r\n        }\r\n\r\n        return nullptr;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jz1433":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917730702","body":"补卡\r\n#### 思路\r\n从低位到高位\r\n\r\n#### 代码\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        for i in range(len(num)-1, -1, -1):\r\n            num[i], carry = (num[i] + carry + k % 10) % 10, (num[i] + carry + k % 10) // 10\r\n            k //= 10\r\n        extra = []\r\n        # 如果全部加完还有进位，需要特殊处理。 比如 A = [2], K = 998\r\n        carry += k\r\n        while carry:\r\n            extra = [carry % 10] + extra\r\n            carry = carry // 10\r\n        return extra + num\r\n``` \r\n\r\n#### 复杂度\r\nTime: O(n + max(0, k-n)^2)\r\nSpace: O(max(1, k-n))","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917771284","body":"补卡\r\n### 思路\r\ngreedy\r\n\r\n### 代码\r\n``` python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        res = [float('inf') for i in range(n)]\r\n        if s[0] == c:\r\n            res[0] = 0\r\n        for i in range(1, n):\r\n            if s[i] == c:\r\n                res[i] = 0\r\n            else:\r\n                res[i] = res[i-1] + 1\r\n        if s[n-1] == c:\r\n            res[n-1] = 0\r\n        for j in range(n-2, -1, -1):\r\n            if s[j] == c:\r\n                res[j] = 0\r\n            else:\r\n                res[j] = min(res[j+1] + 1, res[j])\r\n        return res\r\n```\r\n\r\n### 复杂度\r\nTime: O(n)\r\nSpace: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917486769","body":"\n``` python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920527637","body":"### 思路\r\n先走一遍count有多少node, 然后链表首位相连，再根据需要rotate的步数判断从哪里断开\r\n\r\n### 代码\r\n``` python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        count = 1\r\n        node =  head\r\n        while node and node.next:\r\n            node = node.next\r\n            count += 1\r\n        # 如果转的次数为node个数的倍数，那就不用转啦，直接返回\r\n        turn = k % count\r\n        if turn == 0: return head\r\n        # 把尾巴连到head\r\n        node.next = head\r\n        # 开始转\r\n        step = count - turn\r\n        while step:\r\n            node = node.next\r\n            step -= 1\r\n        newHead = node.next\r\n        node.next = None\r\n        return newHead\r\n```\r\n\r\n### 复杂度\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921412526","body":"### 思路\r\n玩转指针 + dummy head\r\n\r\n### 代码\r\n``` python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        dummy = ListNode()\r\n        dummy.next = head\r\n        pre, node = dummy, head\r\n        \r\n        while node and node.next:\r\n            pre.next = node.next\r\n            next_ = node.next.next\r\n            node.next.next = node\r\n            node.next = next_\r\n            pre = node\r\n            node = node.next\r\n        \r\n        return dummy.next\r\n```\r\n\r\n### 复杂度\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922168599","body":"### 思路\r\nrecursion\r\n### 代码\r\n``` python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        # recursion\r\n        # base case\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        # recusive call\r\n        # get the middle node, which is the slow\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            prev = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        prev.next = None\r\n        root = TreeNode(slow.val)\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n```\r\n### 复杂度\r\nTime: O(nlogn)\r\nSpace: O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aduispace":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917498723","body":"### IDEA\nUse an int array as stack, and a pointer to record the top of stack\n\n### Code\n\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top < stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top > -1) {\n            int prevTopValue = stack[top];\n            top--;\n            return prevTopValue;\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        if (top == -1) return;\n        for (int i = 0; i < Math.min(k, top + 1); i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n\n```\n\n### Time and Space Complexity\n\nTime: O(1) for push and pop, O(Math.min(k, top + 1)) for increment\nSpace: O(MaxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917924072","body":"```java\nclass Solution {\n    public String decodeString(String s) {\n        return dfs(s, 0)[0];\n    }\n    private String[] dfs(String s, int i) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        while(i < s.length()) {\n            if(s.charAt(i) >= '0' && s.charAt(i) <= '9') \n                multi = multi * 10 + Integer.parseInt(String.valueOf(s.charAt(i))); \n            else if(s.charAt(i) == '[') {\n                String[] tmp = dfs(s, i + 1);\n                i = Integer.parseInt(tmp[0]);\n                while(multi > 0) {\n                    res.append(tmp[1]);\n                    multi--;\n                }\n            }\n            else if(s.charAt(i) == ']') \n                return new String[] { String.valueOf(i), res.toString() };\n            else \n                res.append(String.valueOf(s.charAt(i)));\n            i++;\n        }\n        return new String[] { res.toString() };\n    } \n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenlong201807":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917538106","body":"### 解题思路\r\n```\r\njs中数组的操作，支持push pop 即为后进先出，符合栈的特点\r\nthis指针在原型中可以指向构造函数，因此，在构造函数中，初始化需要的基本数据内容。比如这里需要一个数组作为栈中数据的存储内容\r\n栈中的最大长度作为数组的长度，即可符合需求\r\n具体的细节要求按照执行就行了。\r\n\r\n```\r\n\r\n### 代码块\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n  this.arr = []\r\n  this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.arr.length < this.maxSize) {\r\n    this.arr.push(x)\r\n  }\r\n\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if (this.arr.length) {\r\n    return this.arr.pop()\r\n  }\r\n\r\n  return -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  const addValNum = Math.min(this.arr.length, k)\r\n  for (let i = 0; i < addValNum; i++) {\r\n    this.arr[i] = this.arr[i] + val\r\n  }\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度\r\n    + push O(1)\r\n    + pop O(1)\r\n    + incr O(k)\r\n- 空间复杂度\r\n   + push O(1)\r\n   +  pop O(1)\r\n   + incr O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918165358","body":"### 解题思路\r\n```\r\n使用栈结构，\r\n滑动窗口模型判断一个完整的数字\r\n字符串乘法\r\n倒叙叠加字符串\r\n\r\n```\r\n\r\n### 代码块\r\n```javascript\r\n\r\nfunction checkRate(input) {\r\n  var re = /^[0-9]+.?[0-9]*/;\r\n  //判断字符串是否为数字//判断正整数/[1−9]+[0−9]∗]∗/;//判断字符串是否为数字//判断正整数/[1−9]+[0−9]∗]∗/\r\n  return re.test(input);\r\n}\r\nvar decodeString = function (s) {\r\n  const stack = [];\r\n  let numStr = '';\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (checkRate(s[i])) {\r\n      numStr += s[i];\r\n      continue;\r\n    } else {\r\n      if (numStr) stack.push(numStr);\r\n      numStr = '';\r\n\r\n      if (s[i] !== ']') {\r\n        stack.push(s[i]);\r\n      } else {\r\n        let tempStr = '';\r\n        while (stack.length) {\r\n          const curStr = stack.pop();\r\n          if (curStr !== '[') {\r\n            tempStr = curStr + tempStr;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n        let curNum = stack.pop();\r\n        stack.push(tempStr.repeat(curNum));\r\n      }\r\n    }\r\n  }\r\n  return stack.join('');\r\n}\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919092457","body":"### 解题思路\r\n```\r\n1.题目要求，之外就自由操作\r\n2.js数据特点。只要达到目的，额外的因素先不考虑\r\n3.实现了。在看看优化\r\n4.js 中，数组的操作很灵活。别限制的想象\r\n\r\n```\r\n\r\n### 代码块\r\n```javascript\r\n\r\n/**\r\n * 题目 https://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n * Initialize your data structure here.\r\n */\r\n var MyQueue = function() {\r\n  this.stack1 = [];\r\n  this.stack2 = [];\r\n};\r\n\r\n/**\r\n* Push element x to the back of queue. \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nMyQueue.prototype.push = function(x) {\r\n  this.stack1.push(x);\r\n};\r\n\r\n/**\r\n* Removes the element from in front of queue and returns that element.\r\n* @return {number}\r\n*/\r\nMyQueue.prototype.pop = function() {\r\n  const size = this.stack2.length;\r\n  if(size) {\r\n      return this.stack2.pop();\r\n  }\r\n  while(this.stack1.length) {\r\n      this.stack2.push(this.stack1.pop());\r\n  }\r\n  return this.stack2.pop();\r\n};\r\n\r\n/**\r\n* Get the front element.\r\n* @return {number}\r\n*/\r\nMyQueue.prototype.peek = function() {\r\n  const x = this.pop();\r\n  this.stack2.push(x);\r\n  return x;\r\n};\r\n\r\n/**\r\n* Returns whether the queue is empty.\r\n* @return {boolean}\r\n*/\r\nMyQueue.prototype.empty = function() {\r\n  return !this.stack1.length && !this.stack2.length\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919979929","body":"### 解题思路\r\n```\r\n参考学习 https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/\r\n\r\n```\r\n\r\n### 代码块\r\n```javascript\r\n\r\nvar maxChunksToSorted = function (arr) {\r\n  const sorted = [...arr];\r\n  sorted.sort((a, b) => a - b);\r\n\r\n  let count = 0,\r\n      sum1 = 0,\r\n      sum2 = 0;\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n      sum1 += arr[i];\r\n      sum2 += sorted[i];\r\n\r\n      if (sum1 === sum2) {\r\n          count++;\r\n          sum1 = sum2 = 0; // 这行不要也可以啦\r\n      }\r\n  }\r\n\r\n  return count;\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920879572","body":"### 解题思路\r\n```\r\n参考学习，继续理解\r\n\r\n```\r\n\r\n### 代码块\r\n```javascript\r\n\r\nvar rotateRight = function (head, k) {\r\n  if (k === 0 || !head || !head.next) return head;\r\n  var dummy = new ListNode(0, head), cur = dummy;\r\n\r\n  let count = 0;\r\n  while (cur.next) {\r\n      cur = cur.next;\r\n      count++;\r\n  }\r\n  if (k === count) {\r\n      return head;\r\n  } else if (k > count) {\r\n      k %= count;\r\n  }\r\n\r\n  cur.next = dummy.next;\r\n  cur = cur.next;\r\n\r\n  for (let i = 0; i < count - k - 1; i++) {\r\n      cur = cur.next;\r\n  }\r\n\r\n  dummy.next = cur.next;\r\n  cur.next = null;\r\n  return dummy.next\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921866112","body":"### 解题思路\r\n```\r\n1.固定的几个指针，相互交换\r\n2.注意头指针，保留下来\r\n\r\n```\r\n\r\n### 代码块\r\n```javascript\r\n\r\nvar swapPairs = function (head) {\r\n  const dummy = new ListNode(); // 结果要求返回头节点，保留指针\r\n  dummy.next = head; \r\n  let current = dummy;\r\n\r\n  // 快慢两个指针都不能为空\r\n  while (current.next !== null && current.next.next !== null) {\r\n    let n1 = current.next;\r\n    let n2 = current.next.next;\r\n    current.next = n2;\r\n    n1.next = n2.next;\r\n    n2.next = n1;\r\n    current = n1;\r\n  }\r\n\r\n  return dummy.next;\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922276409","body":"### 解题思路\r\n```\r\n参考学习，需继续消化\r\n\r\n```\r\n\r\n### 代码块\r\n```javascript\r\n\r\nconst sortedListToBST = (head) => {\r\n  if (head == null) return null;\r\n  let len = 0;\r\n  let h = head;  // h初始指向头结点\r\n  while (head) { // 计算链表节点个数\r\n    len++;\r\n    head = head.next;\r\n  }\r\n\r\n  const buildBST = (start, end) => {\r\n    if (start > end) return null;     // 递归出口，返回null节点\r\n    const mid = (start + end) >>> 1;  // 求mid，只是为了分治，不是用它断开链表\r\n    const left = buildBST(start, mid - 1); // 先递归构建左子树\r\n\r\n    const root = new TreeNode(h.val);      // 根据 h.val 构建节点\r\n    h = h.next;          // h指针步进              \r\n    root.left = left;    // root接上构建好的左子树        \r\n\r\n    root.right = buildBST(mid + 1, end); // 构建当前root的右子树，接上\r\n    return root;\r\n  };\r\n\r\n  return buildBST(0, len - 1);\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(log)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922480315","body":"### 解题思路\r\n```\r\n如果有交点，那么a,b 交点之后是相同的个数，\r\n因此，使用两个指针，各自都遍历一遍，\r\n如果有相同的，则为交点，\r\n前提是，ab最多只有一个交点，或者没有交点\r\n\r\n```\r\n\r\n### 代码块\r\n```javascript\r\n\r\nvar getIntersectionNode = function (headA, headB) {\r\n  if (!headA || !headB) return null;\r\n\r\n  let pA = headA,\r\n      pB = headB;\r\n  while (pA !== pB) {\r\n      pA = pA === null ? headB : pA.next;\r\n      pB = pB === null ? headA : pB.next;\r\n  }\r\n  return pA;\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LareinaWei":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917580204","body":"### 思路\n使用一个list来进行stack的模拟，push使用append进行模拟，pop使用list的pop函数进行模拟\nincrement先比较k与current stack size的大小，再进行increment\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = 0\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        self.size -= 1\n        return self.stack.pop()\n        \n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i < self.size:\n                self.stack[i] += val\n```\n\n### 复杂度分析\n时间复杂度: Push O(1), pop O(1), increment O(n)  \n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917946903","body":"### Thinking\nUsing a list as a stack, push every character in the string into the stack if it is not a closing bracket.  \nIf we encounter a closing bracket, we need to start pop characters out of the stack to get the repeated string and how many times the string is repeated.  \nWe first pop out the characters and store them into a temp string until we meet a starting bracket. The temp string is what is need to be repeated. We then pop the opening bracket.  \nThen we pop out the number characters one by one until the last element of the stack is not a numeric character. We then get the number of times to repeat. Use the number and temp string to get the repeated string, then push it back to the stack, since it might still be part of another longer repeating string.  \nWe repeat the steps above go through every character in the provided string. Then the answer is combining all elements in the stack together.\n### Code\n```Python  \nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        \n        for char in s:\n            if char == \"]\":\n                tempStr = \"\"\n                count = \"\"\n                \n                while stack and stack[-1] != \"[\":\n                    tempStr = stack.pop() + tempStr\n                    \n                #pop the \"[\" character\n                stack.pop() \n                \n                #pop all the numbers from the stack and get the count number\n                while stack and stack[-1].isnumeric():\n                    count = stack.pop() + count\n                    \n                #get the repeated temp string\n                repeat = int(count) * tempStr\n                \n                #push the repeated string to the stack\n                stack.append(repeat)\n            else:\n                stack.append(char)\n                \n                \n        #get the final answer\n        res = \"\"\n        \n        for i in range(len(stack)):\n            res += stack[i]\n            \n        return res\n```\n### Complexity\nTime Complexity: O(n). Since it needs to go through the string once.  \nSpace Complexity: O(n).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918850583","body":"### Thinking\nUse two stack to achieve the action of push in queue. Whenever an element is to pushed into the queue, pop every element in stack1 and push the popped elements into stack2.  \nAfter that, push the new element into stack1, then pop every element in stack2 and push them one by one into stack1. Then the stack1 would be the new queue after pushing the new element.\n\n### Code\n```Python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n        \n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        for i in range(len(self.stack1)):\n            self.stack2.append(self.stack1.pop())\n            \n        self.stack1.append(x)\n        \n        for j in range(len(self.stack2)):\n            self.stack1.append(self.stack2.pop())\n        \n        \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        return self.stack1.pop()\n        \n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack1[-1]\n        \n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if self.stack1:\n            return False\n        else:\n            return True\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### Complexity\nTime complexity: O(n). \nSpace complexity: O(n).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919721610","body":"### Thinking\nReferring to the solution of the problem.  \n\n### Code\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            #if the last element of the stack (which is the largest element of the last chunk) is greater than the current number, we need to pop the element on top of the stack until the element on top is smaller than current number\n            if stack and stack[-1] > num:\n                curr_largest = stack[-1]\n                \n                while stack and stack[-1] > num:\n                    stack.pop()\n                #now we need to insert the element back to the top of the stack\n                stack.append(curr_largest)\n                \n            else:\n                #if there is no larger number in the stack, then we coould just append the currenet number to the top of the stack and it would become a new chunk\n                stack.append(num)\n                \n        return len(stack)\n```\n\n### Complexity\nTime Complexity: O(n) Since we only need to go through the array one time.  \nSpace Complexity: O(n). The worst case is every element in arr can be a chunk.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920682335","body":"### Thinking\r\nFirst thought about the two pointers, but found out k might be greater than the size of the linkedlist.  \r\nTo avoid non necessary looping through the linkedlist, we need to first find out he length of the linkedlist, and get the result of k mod length, which would be the steps that the linkedlist needed to be rotated.  \r\nWe can connect the tail of the linked list to the head to form a circle. Then move the pointer length - step - 1 times from head to get to the new tail of the linked list. The next node of the new tail would be the new head.\r\n### Code\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if head == None or k == 0:\r\n            return head\r\n        \r\n        node = head\r\n        length = 1\r\n        # find out the length of the linkedlist\r\n        while node.next != None:\r\n            length += 1\r\n            node = node.next\r\n        \r\n        # connect the tail of the linkedlist back to the head of the linkedlist,\r\n        # to make it a circle\r\n        node.next = head\r\n\r\n        # find out the number of times needed to rotate the linkedlist\r\n        rotate = k % length\r\n        \r\n        pos = length - rotate - 1\r\n        \r\n        tail = head\r\n        for i in range(pos):\r\n            tail = tail.next\r\n        new_head = tail.next\r\n        # break the circle\r\n        tail.next = None\r\n\r\n        return new_head\r\n```\r\n### Complexity\r\nTime Complexity: O(n). \r\nSpace Complexity: O(1).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921630425","body":"### Thinking \nRather straight forward approach but easy to make mistake when changing the pointers...  \nStart by creating a dummy head for the linked list, and go on a while loop when cure.next and curr.next.next are both not None, since there would be no need to swap nodes if there is only one node left at the tail in the linked list.  \nWe store the next node of the two nodes to be swapped as nex, and the current.next as temp. Let curr.next to be the second node in the pair, curr.next.next, which is the second node's next to be the first node(temp), and the first node's next to be nex. Then we let curr to step forward two steps and come to the position before the next pair of nodes.  \nAt last we return the next of dummy head.\n### Code\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dum_head = ListNode()\n        dum_head.next = head\n        \n        curr = dum_head\n        while curr.next and curr.next.next:\n            temp = curr.next\n            nex = curr.next.next.next\n            curr.next = curr.next.next\n            curr.next.next = temp\n            curr.next.next.next = nex\n            curr = curr.next.next\n            \n        return dum_head.next\n```\n\n### Complexity\nTime complexity: O(n). We only need to loop through the linked list once.  \nSpace complexity: O(1). We are not using extra space.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922233300","body":"### Thinking \nSolve the problem using in order traversal (sort of reversed version, to build the tree).  \nDefine a helper function to construct the tree, take the head of the linked list (or sub-list) and the tail of it as arguments, find the middle of the linked list using two pointers then reversely call the helper function with the sublist preceding the middle node and the sublist after that.  \nAt last, return the root of the tree, which is the middle node.\n### Code\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        \n        return self.dfs(head, None)\n        \n        \n    def dfs(self, head, tail):\n        if head == tail:\n            return\n        \n        fast = head\n        slow = head\n        \n        while fast != tail and fast.next != tail:\n            slow = slow.next\n            fast = fast.next.next\n            \n        root = ListNode(slow.val)\n        root.left = self.dfs(head, slow)\n        root.right = self.dfs(slow.next, tail)\n        \n        return root\n```\n\n### Complexity\nTime complexity: O(nlogn). Since every time we split the list in to two parts, we will need to call the helper function logn times. And each time we need to traverse the linked list, which takes O(n) time.\nSpace complexity: O(height) = O(logn).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922441890","body":"### Thinking\nUsing a set to store the element of one set, then traverse the other linked list, check if the node is in the set. If it is, then return it.\n\n### Coding\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        s = set()\n        node = headA\n        while node:\n            if node not in s:\n                s.add(node)\n            node = node.next\n            \n        node = headB\n        while node:\n            if node in s:\n                return node\n            node = node.next\n            \n        return None\n```\n### Complexity\nTime Complexity: O(n).  \nSpace Complexity: O(n).","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qibao1112":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917586304","body":"### 思路\r\n\r\n从低位到高位相加，加和的余数存入到linkedList,并将加和的进位存储到K中，其中linkedList可以将将加和向右移位，构成正确的输出\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList<Integer>();\r\n        for(int i = num.length-1;i>=0;i--){\r\n            list.add(0,(num[i]+k)%10);\r\n            k = (num[i] +k) /10;\r\n        }\r\n        while(k>0){\r\n            list.add(0,k%10);\r\n            k=k/10;\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：Max(O(n),O(logK))\r\n\r\n空间复杂度:0（1）\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917597934","body":"### 思路\r\n\r\n从左往右遍历，记录离右边最近的c的长度，然后再从右边往左边遍历，记录当下离左边最近的c与之前记录的距离比较，取最小值。\r\n\r\n\r\n### 代码\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int position = -s.length();\r\n\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) {\r\n                position = i;\r\n            }\r\n            res[i] = i - pos;\r\n        }\r\n\r\n        for (int i = s.length() - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                position = i;\r\n            }\r\n            res[i] = Math.min(res[i], Math.abs(i - position));\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917600091","body":"### 思路\r\n\r\n使用数组构建栈的push和pop操作，同时需要记录当前数组的大小。\r\n\r\n### 代码\r\n\r\n```\r\nclass CustomStack {\r\n\r\n     private int[] stack;\r\n    private int maxSize;\r\n    private int currentSize = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        stack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (currentSize < maxSize) {\r\n            stack[currentSize] = x;\r\n            currentSize++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (currentSize == 0) return -1;\r\n        currentSize--; \r\n        return stack[currentSize];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int n = k < currentSize ? k : currentSize;\r\n        for (int i = 0; i < n; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922469768","body":"### 思路\r\n\r\n思路一：遍历headA使用HashMap存储节点,遍历headB,判断hashMap中是否存在相同节点，出现相同节点则返回。\r\n\r\n思路二：\r\n\r\n1、循环遍历两个节点，如果节点有相同则返回\r\n\r\n2、如果两个节点存在遍历到末尾情况依然未出现相同节点，则从对方的头节点开始遍历\r\n\r\n### 代码\r\n\r\n```java\r\n思路一实现代码\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode current1 = headA;\r\n        ListNode current2 = headB;\r\n        \r\n        HashMap<ListNode,Integer> hashMap = new HashMap<ListNode,Integer>();\r\n        while(current1!=null){\r\n            hashMap.put(current1,null);\r\n            current1 = current1.next;\r\n        }\r\n        while(current2!=null){\r\n            if(hashMap.containsKey(current2))\r\n                return current2;\r\n            current2 = current2.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n思路二实现代码\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode current1 = headA;\r\n        ListNode current2 = headB;\r\n        \r\n        while(current1 != current2){\r\n        \tcurrent1 = current1==null?headB:current1.next;\r\n        \tcurrent2 = current2==null?headA:current2.next;\r\n        }\r\n        return current1;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n思路一：\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(N)\r\n\r\n思路二：\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ziyue08":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917600668","body":" \r\n## 解题思路：\r\n初始化函数中，定义栈的最大容量maxSize，设置栈指针为-1。push函数中判断当前栈是否已满，未满，则指针加1，对应位置赋值为x，pop函数内，判断栈是否为空，为空返回-1，不为空指针减1，并返回栈顶元素。increment函数内，先找到k与栈长度的最小值。然后将最小值范围内的元素加上val。代码如下：\r\n\r\n## 代码如下\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n};\r\n\r\n/** \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length < this.maxSize) {\r\n      this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n* @return {number}\r\n*/\r\nCustomStack.prototype.pop = function() {\r\n  if (this.stack.length > 0) {\r\n      return this.stack.pop();\r\n  } else {\r\n      return -1;\r\n  }\r\n};\r\n\r\n/** \r\n* @param {number} k \r\n* @param {number} val\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let len = this.stack.length;\r\n  if (len < k) {\r\n      for (let i = 0; i < len; i++ ) {\r\n          this.stack[i] += val;\r\n      }\r\n  } else {\r\n      for (let i = 0; i < k; i++) {\r\n          this.stack[i] += val;\r\n      }\r\n  }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Alanwgy":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917603196","body":"# 解法： 模拟\n时间复杂度：初始化、push 操作和 pop 操作的渐进时间复杂度为 O(1)，increment 操作的渐进时间复杂度为 O(k)。\n空间复杂度：用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)\n\n~~~python\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = [0] * maxSize\n        self.top = -1\n\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stack) - 1:\n            self.top += 1\n            self.stack[self.top] = x\n\n\n\n    def pop(self) -> int:\n        if self.top == -1: return -1\n        self.top -= 1\n        return self.stack[self.top+1]\n\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k,self.top+1)\n        for i in range(lim):\n            self.stack[i] += val\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918280908","body":"'''\r\n1.所有可能的输入有 -,'[',']',数字，字母\r\n2.做一个s的for循环，当发现是数字时，如果超过一位数，那么就会被乘以10\r\n3.如果是一个字符，就会被添加金curString\r\n4.如果遇到了'[',这是一个新的子串的开始，前面的子串都已经被处理了，所以将当前的curString和curNum附加到栈中，\r\n并且将curString设为空，curNum设为0\r\n5.当遇到']'，到达了子串完整的地方，就是开始计算了\r\n'''\r\n\r\n~~~python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack,curNum,curString = [],0,''\r\n        for i in s:\r\n            if i == '[':\r\n                stack.append(curString)\r\n                stack.append(curNum)\r\n                curString = ''\r\n                curNum = 0\r\n            elif i == ']':\r\n                num = stack.pop()\r\n                prevString = stack.pop()\r\n                curString = prevString + num*curString\r\n            elif i.isdigit():\r\n                curNum = curNum*10 + int(i)\r\n            else:\r\n                curString += i\r\n        return curString\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922145115","body":"# 创建两个快慢指针，找中间节点\r\n\r\n~~~python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        \r\n        if not head:\r\n            return \r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        slow, fast = head, head.next.next\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        \r\n        tmp = slow.next\r\n        \r\n        slow.next = None\r\n        root = TreeNode(tmp.val)\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(tmp.next)\r\n        return root","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuezhongyuan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917600632","body":"### 思路：\r\n进位法\r\n\r\n### 代码：\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; i--, k /= 10){\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917602833","body":"### 思路：\r\n左右两次遍历\r\n\r\n### 代码：\r\n```\r\nclass Solution {\r\n        public static int[] shortestToChar(String S,char c){\r\n\r\n        int length = S.length();\r\n        int[] ans = new int[length];\r\n\r\n        int prev = -100000;\r\n        for(int i = 0; i < length; i++){\r\n            if (S.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            ans[i] = i-prev;\r\n        }\r\n\r\n\r\n         prev = 100000;\r\n        for (int j = length - 1; j >= 0; j-- ){\r\n            if (S.charAt(j) == c){\r\n                prev = j;\r\n            }\r\n            ans[j] = Math.min(ans[j],prev - j);\r\n        }\r\n\r\n        return ans;\r\n\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917604786","body":"### 思路：\r\n双数组实现\r\n\r\n### 代码：\r\n```\r\nclass CustomStack {\r\n    private int size;\r\n    private int[] arrayStack;\r\n    private int[] increArray;\r\n\r\n    public CustomStack(int maxSize){\r\n        arrayStack = new int[maxSize];\r\n        increArray = new int[maxSize];\r\n        size = -1;\r\n    }\r\n\r\n    public void push(int x){\r\n        if (size <arrayStack.length - 1)\r\n            arrayStack[++size] = x;\r\n    }\r\n\r\n    public int pop(){\r\n        if (size == -1)\r\n            return -1;\r\n\r\n        int ans = arrayStack[size] + increArray[size];\r\n\r\n        if (size != 0)\r\n            increArray[size - 1] += increArray[size];\r\n\r\n        increArray[size] = 0;\r\n        size--;\r\n\r\n        return ans;\r\n    }\r\n\r\n    public void increment(int k ,int val){\r\n            int min = Math.min(size,k-1);\r\n            if (min >= 0 ){\r\n                increArray[min] += val;\r\n            }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(k)\r\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919992120","body":"### 思路：\r\n两次遍历法\r\n\r\n### 代码：\r\n```\r\n\r\nclass Solution {\r\n        public int maxChunksToSorted(int[] arr) {\r\n        int[] max = new int[arr.length];\r\n        max[0] = arr[0];\r\n        for(int i=1; i<arr.length; i++)\r\n            max[i] = Math.max(arr[i], max[i-1]);\r\n        int cmin = Integer.MAX_VALUE, re=0;\r\n        for (int i = arr.length-1; i >=0; i--) {\r\n            // 确切地说，cmin记录的是arr[i+1]到最后一个数之间的最小值\r\n            // 如果cmin >= max[i], 则i这里就是一个分割点\r\n            if(cmin >= max[i])\r\n                re++;\r\n            cmin = Math.min(cmin,arr[i]);\r\n        }\r\n        return re;\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"watchpoints":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917607639","body":"~~~c++\r\n// @lc code=start\r\n//time  increment 0（k）\r\n//space:o(n)\r\nclass CustomStack\r\n{\r\nprivate:\r\n    vector<int> m_data; //随机读写\r\n    int m_maxlen;\r\n    int m_top; //下一个元素位置 m_data没有元素\r\npublic:\r\n    CustomStack(int maxSize)\r\n    {\r\n        m_maxlen = maxSize;\r\n        m_data.resize(maxSize); //无扩容操作\r\n        m_top = 0;              //空栈\r\n    }\r\n\r\n    void push(int x)\r\n    {\r\n        //满： m_top == m_maxlen\r\n        if (m_top >= m_maxlen)\r\n        {\r\n            return;\r\n        }\r\n\r\n        m_data[m_top++] = x;\r\n    }\r\n\r\n    int pop()\r\n    {\r\n        //空栈 m_top == 0\r\n        if (m_top <= 0)\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        return m_data[--m_top];\r\n    }\r\n\r\n    void increment(int k, int val)\r\n    {\r\n\r\n        int size = min(k, m_top);\r\n        for (int i = 0; i < size; i++)\r\n        {\r\n            m_data[i] += val;\r\n        }\r\n    }\r\n};\r\n~~~","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919096551","body":"## 思路\r\n- 双栈模拟\r\n-  如何保证 在出队列后，还能正确的入队列。--复原 \r\n\r\n## 代码\r\n\r\n```c++\r\nclass MyQueue\r\n{\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue()\r\n    {\r\n        m_total = 0;\r\n    }\r\n    /** Push element x to the back of queue. */\r\n    //每次插入一个元素，需要判断是否读取过。然后还原到读取状态\r\n    void push(int x)\r\n    {\r\n\r\n        m_total++;\r\n        //\r\n        if (!m_output.empty())\r\n        {\r\n            while (!m_output.empty())\r\n            {\r\n                m_input.push(m_output.top());\r\n                m_output.pop();\r\n            }\r\n        }\r\n\r\n        m_input.push(x);\r\n\r\n        while (!m_input.empty())\r\n        {\r\n            m_output.push(m_input.top());\r\n            m_input.pop();\r\n        }\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop()\r\n    {\r\n        m_total--;\r\n        int val = peek();\r\n        m_output.pop();\r\n        return val;\r\n    }\r\n\r\n    /** Get the front element. */\r\n    int peek()\r\n    {\r\n        //序列：第一个入队列的，需要第一个出队列\r\n\r\n        return m_output.top();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    bool empty()\r\n    {\r\n\r\n        return m_total == 0;\r\n    }\r\n\r\nprivate:\r\n    stack<int> m_input;  //入队列操作\r\n    stack<int> m_output; //出队列操作\r\n    int m_total;         //记录大小\r\n};\r\nï\r\n\r\n```\r\n\r\n## 复杂度：\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wanghuaikuan":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917620989","body":"1. 思路\r\n较简单的栈的基本实现\r\n\r\n2. 代码\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    vector<int> s;\r\n    int size;\r\n    CustomStack(int maxSize) {\r\n        s.resize(maxSize);\r\n        size=0;\r\n    }\r\n    void push(int x) {\r\n        if(size<s.size())s[size++]=x;\r\n    }\r\n    int pop() {\r\n        if(size>0) return s[--size];\r\n        return -1;\r\n    }\r\n    void increment(int k, int val) {\r\n        for(int i=0;i<min(k,size);i++)  s[i]+=val;\r\n    }\r\n};\r\n\r\n```\r\n\r\n3.复杂度\r\n时间复杂度：increment方法为O(k),其他的都为O(1)；\r\n空间复杂度：O(maxSize);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918140781","body":"## 1.思路\r\n### 本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应。\r\n#### ①构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\r\n#### ②当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\r\n#### ③当 c 为字母时，在 res 尾部添加 c；\r\n#### ④当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\r\n记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\r\n记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\r\n进入到新 [ 后，res 和 multi 重新记录。\r\n#### ⑤当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\r\nlast_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\r\ncur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]的2.\r\n##  2.代码\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        int n=s.size();\r\n        vector<int> numS;\r\n        vector<string> charS;\r\n        int a=0;\r\n        string ret;\r\n        for(int i=0;i<n;i++){\r\n            if(isdigit(s[i])){\r\n               a=a*10+s[i]-'0';\r\n            }else if( s[i]=='['){\r\n                numS.push_back(a);\r\n                string tmp;\r\n                charS.push_back(tmp);\r\n                a=0;\r\n            }else if( s[i]==']'){\r\n                int num=numS.back();\r\n                string s1=charS.back();\r\n                charS.pop_back();\r\n                if(charS.size())\r\n                {\r\n                    for(int i=0; i< num; i++){\r\n                        charS.back() +=s1;\r\n                    }   \r\n                }else {\r\n                    for(int i=0; i< num; i++){\r\n                        ret +=s1;\r\n                    }              \r\n                }\r\n                numS.pop_back();\r\n            }else{\r\n                if(charS.size()){\r\n                    charS[charS.size()-1].push_back(s[i]);\r\n                }else{\r\n                    ret.push_back(s[i]);   \r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```\r\n## 3.复杂度\r\n遍历一遍s需要的时间为O(s.size());","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ShuchenWuu":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917634185","body":"#include <iostream> \r\n#include <stack> \r\nusing namespace std;\r\n\r\nclass CustomStack {\r\npublic:\r\n        vector<int> stack;\r\n        int size;\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        size = 0;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (size < stack.size()){\r\n            stack[size] = x;\r\n            size++;            \r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        int res = -1;\r\n        if (size > 0){\r\n            size--;\r\n            res = stack[size];\r\n        }\r\n\r\n        return res;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < min(k, size); i++)\r\n            stack[i] += val;\r\n    }\r\n};\r\n\r\n时间复杂度push：O(1)，pop：O(1)，increment：O(N) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luoanyang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917043545","body":"## 思路\n先把k也拆成数组，然后由后的到近的下标两个数组相加起来\n\n## 代码\n```js\nvar addToArrayForm = function (num, k) {\n  let nLength = num.length;\n  let kArr = k.toString().split('');\n  let kLength = kArr.length;\n  let result = nLength > kLength ? [...num] : [...kArr];\n  let isExceed = false;\n  for (let i = 1; i <= result.length; i++) {\n    let cK = parseInt(kArr[kLength - i]);\n    let cN = num[nLength - i];\n    let cV = 0;\n    console.log(cK, cN)\n\n    if (cK && cN) {\n      cV = cK + cN;\n    } else if (cK) {\n      cV = cK;\n    } else if (cN) {\n      cV = cN;\n    }\n\n    if (isExceed) {\n      cV++;\n      isExceed = false;\n    }\n\n    if (cV >= 10) {\n      cV -= 10;\n      isExceed = true;\n    }\n\n    result[result.length - i] = cV;\n    if (i == result.length && isExceed) {\n      result.unshift(1)\n    }\n  }\n\n  return result;\n};\n```\n\n## 复杂度分析\n时间复杂度：O(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917642515","body":"### 思路\n用js中的数组来模拟栈\n\n### 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.stack = [];\n  this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if(this.stack.length == this.maxSize) return;\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n   if(this.stack.length==0) return -1;\n   let cur = this.stack[this.stack.length-1];\n   this.stack.length = this.stack.length-1\n   console.log(cur)\n   console.log(this.stack)\n   return cur;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  if(this.stack.length == 0)return;\n  console.log(this.stack)\n  for(let i=0;i<this.stack.length;i++){\n    if(i>=k) break;\n    this.stack[i] += val;\n  }\n};\n\n```\n\n### 复杂度\n- 时间复杂度\npush：O(1)\npop：O(1)\nincrement：O(min(k,stack.length))\n\n- 空间复杂度 O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ymwang-2020":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917641088","body":"## 思路\n思考是从低位还是高位开始计算\n## 关键点\n进位的处理\n\n## 代码\n\n - 语言支持\n\npython3\n\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n=len(num)\n        add=0\n        for i in range(n-1,-1,-1):    \n            num[i],add=(k%10+num[i]+add)%10,(k%10+num[i]+add)//10\n            k=k//10\n        B=[]\n        add=add+k\n\n        # 当原数组处理完后还有进位（只有进位1 or K还未处理完）\n        while add:\n            B =[(add)%10]+B\n        return B+num\n```\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n - 时间复杂度：$O(n+max(0,k-n)**2)$\n - 空间复杂度：$O(0,k-n)$","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917647694","body":"## 思路\n判断栈空、栈满\n## 关键点\nk的处理\n## 代码\n\n - 语言支持\n\npython3\n\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n```\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n - 时间复杂度：$O(k)$\n - 空间复杂度：$O(maxSize)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918259196","body":"## 思路\n数据压栈和出栈\n## 关键点\n括号套括号的处理\n## 代码\n\n - 语言支持\n\npython3\n\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        num_str = ''\n        k = 0\n        for item in s:\n            if item.isdigit():\n                # 如果是数字就记录数字\n                k = k * 10 + int(item)\n            elif item == '[':\n                #如果遇到左括号就压入 括号前数字 和 已处理好的字符\n                stack.append((num_str,k))\n                num_str=''#记录下一次的 括号内字符 或 普通字符\n                k=0\n            elif item==']':\n                #遇到右括号则弹出，加上当前处理的方括号内字符*存储的K\n                inner=stack.pop()\n                num_str = num_str*inner[1]+inner[0]\n            else:\n                num_str += item\n\n        return num_str\n```\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n - 时间复杂度：$O(n)$\n - 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919155616","body":"## 思路\n啊偶。。我只想到了如何用一个数组去做，脑袋空空，继续加油，去学习官方题解啦\n## 关键点\n\n## 代码\n\n - 语言支持\n\npython3\n\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack=[0]*1000\n        self.front=0\n        self.rear=0\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack[self.rear]=x\n        self.rear+=1\n         \n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        # if empty():\n        #     return -1\n        x=self.stack[self.front]\n        self.front+=1\n        return x\n\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack[self.front]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if self.rear==self.front:\n            return True\n        else:\n            return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919998131","body":"## 思路\n\n## 关键点\n\n## 代码\n\n - 语言支持\n\npython3\n\n\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.Counter()\n        counted = []\n        for x in arr:\n            count[x] += 1\n            counted.append((x, count[x]))\n\n        ans, cur = 0, None\n        for X, Y in zip(counted, sorted(counted)):\n            cur = max(cur, X)\n            if cur == Y:\n                ans += 1\n        return ans\n\n\n\n```\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n - 时间复杂度：$O(NlogN)$\n - 空间复杂度：$O(N)$\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921862214","body":"## 思路\n两两互换实质上设计到了四个节点，定义 需交换的节点对中的 第一个节点的pre节点是关键\n## 关键点\n采用虚拟首节点代替原来的head,由于原来的首节点是不断变化的，无法最后作为返回结果\n注意指向节点和等于节点的不同\n## 代码\n\n - 语言支持\n\npython3\n\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n\n        if not head or not head.next:\n            # 空表或只有一个节点 \n            return head\n\n        ans = ListNode()#采用虚拟首节点\n        ans.next = head.next#虚拟首节点与head真节点指向相同\n        A_pre = ans\n        while head and head.next:\n            B=head.next# B节点等于head(即A)的next节点\n            # B_next=B.next# # B后节点等于B的next节点\n            head.next=B.next\n            B.next=head #B的next节点指向head\n            A_pre.next=B\n            A_pre=head\n            head=head.next\n        return ans.next\n\n\n```\n\n## 复杂度分析\n\n令 n 为数组长度。\n\n - 时间复杂度：$O(N)$\n - 空间复杂度：$O(N)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chanceyliu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917603527","body":"### 思路\n\n按照官方题解\n\n### 代码\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nfunction addToArrayForm(num, k) {\n  const res = [];\n  for (let i = num.length - 1; i >= 0; i--) {\n    // 从数组末尾开始加k的最后一位\n    let sum = num[i] + (k % 10);\n    // 加完后剔除k的最后一位\n    k = Math.floor(k / 10);\n    // 如果sum大于10说明需要进一位，于是将操作后的k+1，并让sum保留一位\n    if (sum >= 10) {\n      k++;\n      sum -= 10;\n    }\n    res.push(sum);\n  }\n  // 如果k大于0的话，会进这个循环，说明还有进位没加，将进位push进数组\n  for (; k > 0; k = Math.floor(k / 10)) {\n    res.push(k % 10);\n  }\n  res.reverse();\n  return res;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(max(n,log k))$ 其中 N 为数组长度\n- 空间复杂度：$O(1)$","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917651915","body":"### 思路\n\n按照官方题解\n\n### 代码\n\n```javascript\nvar CustomStack = function (maxSize) {\n  s = [];\n  t = 0;\n  n = maxSize;\n};\nCustomStack.prototype.push = function (x) {\n  if (t < n) s[++t] = x;\n  return s;\n};\nCustomStack.prototype.pop = function () {\n  if (t) return s[t--];\n  return -1;\n};\nCustomStack.prototype.increment = function (k, val) {\n  while (k) s[k--] += val;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：push,pop 为$O(1)$,increment 为$O(k)$\n- 空间复杂度：$O(1)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918279777","body":"### 思路\n\n从前往后遍历字符串，依次推入栈中，直到遇到 `]` ，就开始解析栈内的字符，直到遇到 `[` ，就代表字符解析完成了，前方可能有数字或字母，直到遇到非数字，将之前得到数字\\*字符，得到解析后的字符，推入栈中，继续如此循环\n\n### 代码\n\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nfunction decodeString(s) {\n  let stack = [];\n  for (const i of s) {\n    // 只要值不等于 \"]\" ，就只做入栈操作\n    if (i !== \"]\") {\n      stack.push(i);\n      continue;\n    }\n    // 出现 \"]\" 了，那么他上一个元素必然为字母，那么在遇到 \"[\" 之前都只做拼接字符串的操作\n    let str = \"\";\n    // 从栈中拿出一个\n    let value = stack.pop();\n    while (value !== \"[\") {\n      str = value + str;\n      // 拼接完后在拉一个出来\n      value = stack.pop();\n    }\n    // 匹配到 \"[\" ，所以跳出了上一个循环，我们在拉一个覆盖掉 \"[\"\n    value = stack.pop();\n    //出现 \"[\" 了，那么他前面的元素肯定是数字或者字母，是数字的话我们就要再次拼接\n    let num = \"\";\n    while (!isNaN(value)) {\n      num = value + num;\n      // 继续出栈\n      value = stack.pop();\n    }\n    // 出现新的字母了，上面把它出栈了，现在重新把它装回去，等待再次拼装\n    stack.push(value);\n    // 将处理拼接后的字符推入栈中，继续循环\n    stack.push(str.repeat(num));\n  }\n  return stack.join(\"\");\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：*O(n)*，n 为转换后的字符串长度\n- 空间复杂度：*O(n)*，\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919234035","body":"### 思路\n\n官方题解，双栈\n\n### 代码\n\n```javascript\nclass MyQueue {\n  constructor() {\n    this.intStack = [];\n    this.outStack = [];\n  }\n\n  push(x) {\n    this.intStack.push(x);\n  }\n\n  pop() {\n    if (!this.outStack.length) {\n      this.inToOut();\n    }\n    return this.outStack.pop();\n  }\n\n  peek() {\n    if (!this.outStack.length) {\n      this.inToOut();\n    }\n    return this.outStack[this.outStack.length - 1];\n  }\n\n  empty() {\n    return this.intStack.length === 0 && this.outStack.length === 0;\n  }\n\n  inToOut() {\n    while (this.intStack.length) {\n      this.outStack.push(this.intStack.pop());\n    }\n  }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：push 和 empty 为 O(1)，pop 和 peek 为均摊 O(1)。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 O(1)\n- 空间复杂度：O(n)，n 为操作总数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Craig-Cheng":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917654553","body":"### 用Javascript解题\nincrement 的时间复杂度 O(k)\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.stack = [];\n    this.size = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.stack.length < this.size) this.stack.push(x);\n    return this.stack;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    if (this.stack.length === 0) return -1;\n    return this.stack.pop();\n};\n\n/**\n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    if (!this.stack.length) return;\n    const min = Math.min(k, this.stack.length);\n    for (let i = 0; i < min; i++) {\n        this.stack[i] += val;\n    }\n    return this.stack;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GZ712D":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917657922","body":"零基础以及一点点编程（python）基础  \r\n呃，我题目没看懂，后面尽力加班加点，抓紧跟上课程  \r\n唉，低估了算法入门的难度  ","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921000806","body":"### 反思：  \n缺乏前置知识——求单链表的倒数第N个节点  \n不懂，做不出来唉  \n要把算法学习的优先度提高高","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weichuliao":[null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917658127","body":"### Main Idea ###\r\nImplement stack with list\r\n\r\n### Code with Python ###\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n        return self\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            res = self.stack[len(self.stack)-1]\r\n            self.stack.pop()\r\n            return res\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        length = min(len(self.stack), k)\r\n        for i in range(length):\r\n            self.stack[i] += val\r\n        return self\r\n```\r\n\r\n### Complexity Analysis ###\r\n- Time Complexity: \r\n  - Push: O(1)\r\n  - Pop: O(1)\r\n  - Increment: O( min(len(stack), K )\r\n- Space Complexity: O(maxSize)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920650994","body":"### Main Idea\n\n\n### Code with Python\n```python\ndef rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head == None or k == 0:\n            return head\n        \n        length = 1\n        node = head\n        while node.next != None:\n            length += 1\n            node = node.next\n        \n        if length == 1:\n            return head\n        \n        target_pos = length - (k % length)\n        target_node = None\n        node = head\n        while node.next != None:\n            target_pos -= 1\n            if (target_pos == 0):\n                target_node = node\n            node = node.next\n            \n        if target_node != None:\n            node.next = head\n            head = target_node.next\n            target_node.next = None\n        \n        return head\n```\n\n### Complexity Analysis\n- Time Complexity: O(n)\n- Space Complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Davont":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917666102","body":"## 思路\n利用栈,以前做过，还是对中括号的匹配，很经典一题\n## 代码\n```js\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    const numStack = [];\n    const strStack = [];\n    let repeatTimes = '';\n    for (let i = 0; i< s.length; i++) {\n      const char = s[i];\n      if(!Number.isNaN(+char)){\n          repeatTimes += char;\n          continue;\n      }\n      if(repeatTimes){\n        numStack.push(+repeatTimes);\n        repeatTimes = '';\n      }\n      if(char === ']'){\n          let repeatStr = '';\n          while(strStack.length && strStack.slice(-1)[0]!=='['){\n            let a = strStack.slice(-1);\n            repeatStr = strStack.pop() + repeatStr;\n          }\n          strStack.pop();\n          strStack.push(repeatStr.repeat(numStack.slice(-1)));\n          numStack.pop();\n      }else{\n          strStack.push(char);\n      }\n    }\n    return strStack.join('');\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"absent1353":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917731516","body":"### 思路：\n辅助栈的思路\n### 代码：\n```\ndef decodeString(self, s: str) -> str:\n        stack=[]\n        length = len(s)\n        i = length - 1\n        while i>=0:\n            if not s[i].isdigit():\n                stack.append(s[i])\n                i -= 1\n            else:\n                num = ''\n                while s[i].isdigit() and i>=0:\n                    num = s[i]+num\n                    i -= 1\n                sub = ''\n                while stack[-1]!=']':\n                    tmp = stack.pop()\n                    if tmp != '[':\n                        sub += tmp\n                stack.pop()\n                sub = int(num)*sub\n                stack.append(sub)\n        stack.reverse()\n        return ''.join(stack)\n```\n### 复杂度：\n时间复杂度 $O(N)$\n空间复杂度 $O(N)$","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922503000","body":"### 思路\n快慢指针\n### 代码\n```\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow: break\n        if fast is None or fast.next is None: return None\n        fast = head\n        while slow != fast:\n            fast = fast.next\n            slow = slow.next\n        return slow\n```\n### 复杂度\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"banjingking":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917733641","body":"### 思路\n***\nnumStack: 要repeated多少遍的数字  \nstrStack: 存a，当[a2[c]], a是不用repeat的  \ntail: 当前的string是什么  \n先loop每个char，判断char是digit，open bracket, close bracket, 遇到open bracket, 要将之前记录的string清空，push进去strStack, 遇到close bracket，就把numstack pop出来，乘上 tail\n\n***\n### 代码  \n\npublic String decodeString(String s) {\n\n        Deque<Integer> numStack = new ArrayDeque<>();\n        Deque<String> strStack = new ArrayDeque<>();\n        \n        StringBuilder tail = new StringBuilder();\n        int n = s.length();\n        for(int i = 0; i < n; i++){\n            char c = s.charAt(i);\n            // if is number\n            if(Character.isDigit(c)){\n                // maybe not only one digit\n                int num = c - '0';\n                // see if next is digit\n                while(i +1 <n && Character.isDigit(s.charAt(i+1))){\n                    num = num *10 + s.charAt(i+1) - '0';\n                    i++;\n                }\n                // put number into numStack\n                numStack.push(num);\n            }else if(c == '['){\n                //put string which before the open bracket to the stack\n                strStack.push(tail.toString());\n                tail = new StringBuilder();\n            }else if(c == ']'){\n                StringBuilder tmp = new StringBuilder(strStack.pop());\n                int repeatedTime = numStack.pop();\n                for(int j =0; j < repeatedTime; j++){\n                    tmp.append(tail);\n                }\n                \n                tail = tmp;\n            }else{\n                tail.append(c);\n            }\n        }\n        return tail.toString();\n        \n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918883642","body":"### 思路\n利用两个stack，要push的时候把是s1的东西放到s2, 然后把要加的element放到s2上，再把s2的东西放回s1，所以新加的element就会在最下面\n\n### 代码\n\n class MyQueue {\n    \n    Stack<Integer> s1 = new Stack();\n    Stack<Integer> s2 = new Stack();\n    \n    // Push element x to the back of queue.\n    public void push(int x) {\n      while (!s2.isEmpty())\n        s1.push(s2.pop());\n      \n      s1.push(x);\n    }\n\n    // Removes the element from in front of queue.\n    public void pop() {\n      while (!s1.isEmpty())\n        s2.push(s1.pop());\n      \n      s2.pop();\n    }\n\n    // Get the front element.\n    public int peek() {\n      while (!s1.isEmpty())\n        s2.push(s1.pop());\n      \n      return s2.peek();\n    }\n\n    // Return whether the queue is empty.\n    public boolean empty() {\n      return s1.isEmpty() && s2.isEmpty();\n    }\n\n  }\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922502815","body":"```\r\npublic class Solution {\r\n            public ListNode detectCycle(ListNode head) {\r\n                ListNode slow = head;\r\n                ListNode fast = head;\r\n        \r\n                while (fast!=null && fast.next!=null){\r\n                    fast = fast.next.next;\r\n                    slow = slow.next;\r\n                    \r\n                    if (fast == slow){\r\n                        ListNode slow2 = head; \r\n                        while (slow2 != slow){\r\n                            slow = slow.next;\r\n                            slow2 = slow2.next;\r\n                        }\r\n                        return slow;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n        }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"now915":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917750281","body":"``` javaScript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    let multi = 0\n    let res = ''\n\n    for (const c of s) {\n        if (c == '[') {\n            stack.push([multi, res])\n            multi = 0\n            res = ''\n        } else if (c == ']') {\n            const last = stack.pop()\n            let tmp = ''\n            for (let i = 0; i < last[0]; i++) {\n                tmp += res\n            }\n            res = last[1] + tmp\n        } else if ('0' <= c && c <= '9') {\n            multi = multi * 10 + (c - 0)\n        } else {\n            res += c\n        }\n    }\n    return res\n}; \n```\n- 时间复杂度 O(n) \n- 空间复杂度 O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920847878","body":"## 思路\n遍历让单链表变成一个闭环，得到尾节点和节点个数n，t.next = head， 旋转k次，相当于单链表中第 n - （k % n）个节点变成了头节点 ，然后移动头节点尾节点，最后解开闭环变成单链表就ok了 \n``` javascript\n  /**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (head == null || head.next == null || k == 0) return head\n    let num = 0\n    let t = new ListNode()\n    t = head\n    while(t.next) {\n        num++\n        t = t.next\n    }\n    t.next = head\n    num = (num + 1) - ( k % (num + 1))\n    while (num > 0) {\n        head = head.next\n        t = t.next\n        num--\n    }\n    t.next = null\n    return head\n};\n```\n### 时间复杂度 O(n)\n### 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921739801","body":"## 递归\n``` javaScript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (head == null || head.next == null) {\n        return head\n    }\n    let next = head.next\n    head.next = swapPairs(next.next)\n    next.next = head\n    return next\n};\n```\n### 时间复杂度 O(n)\n### 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"akxuan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-918104547","body":"## 思路\n本来想用位溢出， 发现99+1 这种情况不太好做， 还是没办法做到 1pass， 后来想说其实可以reverse list， 从大往小做。\n不过最后感觉还是把list 转 int 然后加起来比较方便。。。\n时间复杂度就是n , n = num+k 的位数\n\n``` python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = len(num)-1\n        num_int = 0\n        \n        for i in num:\n            num_int += i * 10**n\n            n-= 1\n        num_int += k\n        if num_int ==0:\n            return [0]\n        res = []\n        while num_int>0:\n            res.append(num_int%10)\n            num_int /=10\n        \n        res.reverse()\n        \n        return res\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917782563","body":"这题看着容易， 但是实现好不容易。 \r\n### 思路\r\n首先弄两个 stack, 其中一个存数字， 另一个存string。 \r\n然后每次遇到 ']' 的时候就把string 中最后一个替换成 数字stack[-1]* str_stack[-1]. \r\n\r\n### 坑\r\n1. 首先就是需不需要用一个string 来存output。 如果用一个res 存output， 那就还要再判断一次 num_stack  是不是空的， 这个就蛋疼了。 \r\n2. 最后用 ''.join(stack) 返回非常好。 因为就算有空 string 也不影响\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s):\r\n        stack_num, stack_string =  [],[\"\"]\r\n        num = 0\r\n        res = ''\r\n        for c in s:\r\n            if  c.isdigit():\r\n                num = num*10 + int(c)\r\n            elif c =='[':\r\n                stack_string.append(\"\")\r\n                stack_num.append(num)\r\n                num = 0 \r\n            elif c == ']':\r\n                temp_str = stack_string.pop()\r\n                temp_rep = stack_num.pop()\r\n                last_str = stack_string.pop()\r\n                stack_string.append(last_str+ temp_rep*temp_str)\r\n            else:\r\n                stack_string[-1] += c\r\n        return \"\".join(stack_string)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919119506","body":"## 确实不难这题\r\n就是用两个list ，这个list 只能用pop 和append，用一个 temp list 来做反转。。。\r\n现在写了 pop 是O(n) , peak 是o（1）的\r\n还可以写一个 pop 是 o（1）， peak 是 o(n)， 差不多，就是每次peak 的时候倒一变。 \r\n\r\n···python\r\nclass MyQueue(object):\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack_temp , self.stack_peek = [],[]\r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        while self.stack_peek:\r\n            self.stack_temp.append(self.stack_peek.pop())\r\n        self.stack_temp.append(x)\r\n        while self.stack_temp:\r\n            self.stack_peek.append(self.stack_temp.pop())\r\n            \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.stack_peek:\r\n            return self.stack_peek.pop()\r\n        \r\n        else:\r\n            return None\r\n        \r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.stack_peek:\r\n            return self.stack_peek[-1]\r\n        \r\n        else:\r\n            return None\r\n   \r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        return len(self.stack_peek) == 0\r\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919619036","body":"## 思路1\n1. prefixed sum, 如果相同那么sum 肯定一样. prefixed sum 可以用来解决sorted 这些问题. \n2. 抄同学的,  -方法2，维护一个单调递增栈的办法，[0 1 3 4 2] 则 [ 0 1 3 4] 当2来后，**要注意先记住最大4**。pop 出3 4 ，**再把最大4放入**形成[ 0 1 4] 该单调栈记录为每个chunk 里面最大数。并维持递增栈。最后返回栈的大小，就是chunk的大小。时间复杂度O(n) 空间复杂度 O(n)\n这个方法考试中很难implement出来, **再把最大4放入** 这个很难想到\n\n\n```python \n        res,prfx_s1, prfx_s2 = 0,0,0\n        \n        copy_arr = [i for i in arr]\n        copy_arr.sort()\n        \n        for i in range(len(arr)):\n            prfx_s1 += arr[i]\n            prfx_s2 += copy_arr[i]\n            \n            if prfx_s1 == prfx_s2: res+=1\n                \n        return res\n```\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920527822","body":"## 思路\n找到需要反转的node， 然后把头尾换一下就好了\n\n坑1 先判断head 是不是空\n坑2 list length 算对\n坑3 算 那个 turn node 需要 length - k - 1\n``` python\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"       \n        tail = head\n        length = 1  # 计算lenth 要从1 开始, 因为 tail 本来就算一个了\n        while tail and tail.next:\n            tail = tail.next\n            length += 1\n            \n        k %= length  \n        if k ==0 :\n            return head\n        \n        turn = length - k -1  # 坑 2. 这里turn 的数目要注意\n        \n        dummy = head\n        while turn >0:\n            dummy = dummy.next\n            turn -=1\n        new_head = dummy.next  \n        dummy.next = None\n        tail.next= head\n        \n        return new_head","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921770999","body":"##\r\n时空间复杂度均为 N\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        # 只用一个dummy node\r\n    '''\r\n    def swapPairs1(self, head):\r\n        dummy = p = ListNode(0)\r\n        dummy.next = head\r\n        while head and head.next:\r\n            tmp = head.next\r\n            head.next = tmp.next\r\n            tmp.next = head\r\n            p.next = tmp\r\n            head = head.next\r\n            p = tmp.next\r\n        return dummy.next\r\n    '''    \r\n    # Recursively    \r\n    def swapPairs(self, head):\r\n        if head and head.next:\r\n            tmp = head.next\r\n            head.next = self.swapPairs(tmp.next)\r\n            tmp.next = head\r\n            return tmp\r\n        return head\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922408057","body":"## 从长度相同的部分开始找\no(n)\n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy_a,dummy_b = ListNode(0),ListNode(0)\n        dummy_a.next,dummy_b.next = headA, headB\n        \n        lenA,lenB = 0,0\n        while headA :\n            lenA+=1\n            headA = headA.next\n        while headB:\n            lenB+=1\n            headB = headB.next\n        \n        \n        headA , headB = dummy_a.next, dummy_b.next\n        \n        \n        while headA and headB:\n            if lenA == 0 or lenB == 0:\n                break\n            \n            if lenA > lenB :\n                headA = headA.next\n                lenA-=1\n            elif lenA < lenB:\n                headB = headB.next\n                lenB-=1\n            else:\n                if headB == headA:\n                    return headB\n                else:\n                    headA = headA.next\n                    \n                    headB = headB.next\n                    lenA-=1\n                    lenB -=1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doMoreCode":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917816032","body":"# 思路\n想法是使用栈来进行字符串的复制工作，但是我参考了leetcode的官方的思路，使用了两个栈，一个栈是用来存储数字，另一个用来存储字符串。\n* 如果是数字保存下来， 当然后一位也可能是数字， 因此不用压栈\n* 如果是字符的话，同样保存下来，不用压栈\n* 如果是' [ '，那么把上述两个变量清零，然后压栈\n* 如果是 ' ] ',这时候比较关键，因为这时候的字符串变量是有值的，这个值是括号里面的值。因此我们需要复制这个字符串变量的值k次，然后依次出栈。\n# C++代码\n``` c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> nums;\n        stack<string> strs;\n\n        string res = \"\";\n        int n = 0;\n        for (int i = 0; i < s.size(); i ++) {\n            if (s[i] >= '0' && s[i] <= '9') {\n                n = n * 10 + (s[i] - '0');\n            } else if (s[i] == '[') {\n                nums.push(n);\n                n = 0;\n                strs.push(res);\n                res = \"\";\n            } else if (s[i] >= 'a' && s[i] <= 'z' || s[i] >= 'A' && s[i] <= 'Z') {\n                res += s[i];\n            } else {\n                int time = nums.top();\n                nums.pop();\n                for (int j = 0; j < time; j ++) {\n                    strs.top() += res;\n                }\n\n                res = strs.top();\n                strs.pop();\n            }\n        }\n\n        return res;\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922468588","body":"# 思路\n这个也是参考的大众的解法，主要的思想是双指针的思想，一个指向链表A，一个指向链表B，如果两个链表相交的话，那么他们一定会相遇，但是这里需要注意由于两个链表大小不一，因此需要遍历的最长长度是链表A的长度加上链表B的长度，如果没有相交，那么最后的结果就是为空。\n# 代码\n``` C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (!headA || !headB) return nullptr;\n        ListNode *l1 = headA, *l2 = headB;\n        while (l1 != l2) {\n            if (l1) l1 = l1 -> next;\n            else l1 = headB;\n\n            if (l2) l2 = l2 -> next;\n            else l2 = headA;\n        }\n\n        return l1;\n    }\n};\n```\n# 复杂度\n时间$ O(n + m) $\n空间$ O(1) $","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ChiaJune":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917428961","body":"## 思路\r\n数组从末位向前逐位相加，每次遍历的时候需要计算下一次需要加上的进位值。循环结束后，判断进位值是否大于0，如果大于0则将该值插入到结果数组的前面。\r\n## 代码\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n  var result = [];\r\n  var i = num.length - 1;\r\n  var carry = 0;\r\n  while (i >= 0 || k !== 0) {\r\n    var v = i >= 0 ? num[i] : 0;\r\n    var t = k !== 0 ? k % 10 : 0;\r\n    k = parseInt(k/10);\r\n    var val = carry + t + v;\r\n    carry = val >= 10 ? 1 : 0;\r\n    result.unshift(val % 10);\r\n    i--;\r\n  }\r\n  if (carry) result.unshift(carry);\r\n  return result;\r\n};\r\n```\r\n## 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917866693","body":"## 思路\r\n从左至右遍历：\r\n1. 如果是数字，则累加到count上（字符串操作）；\r\n2. 如果是字母啥的，则累加到result上（字符串操作）;\r\n3. 如果是[，则将当前的count和result组成数组的一项（[count, result]）push到stack中，同时清空result和count，此操作主要用于记录当前信息，以方便遇到]的时候\b计算。\r\n4. 如果是]，stack进行pop()操作得到[count, res]，然后进行数据组装，注意组装顺序。\r\n## 代码\r\n``` javascript\r\nvar decodeString = function(s) {\r\n  let i = 0, size = s.length;\r\n  var result = '';\r\n  var count = '';\r\n  var stack = [];\r\n  while (i < size) {\r\n    var c = s[i];\r\n    if (c === '[') {\r\n      stack.push([count, result]);\r\n      result = '';\r\n      count = '';\r\n    } else if (c === ']') {\r\n      var res = stack.pop();\r\n      result = res[1] + result.repeat(Number(res[0]));\r\n    } else if (/\\d/.test(c)) {\r\n      // 数字\r\n      count += c;\r\n    } else {\r\n      // 字母\r\n      result += c;\r\n    }\r\n    i++;\r\n  }\r\n  return result;\r\n};\r\n```\r\n\r\n## 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918768332","body":"## 代码\r\n``` javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\n var MyQueue = function() {\r\n  this.in = [];\r\n  this.out = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.in.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  if (this.out.length <= 0) {\r\n    while (this.in.length > 0) {\r\n      this.out.push(this.in.pop());\r\n    }\r\n  }\r\n  return this.out.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  if (this.out.length <= 0) {\r\n    while (this.in.length > 0) {\r\n      this.out.push(this.in.pop());\r\n    }\r\n  }\r\n  return this.out[this.out.length - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.in.length <= 0 && this.out.length <= 0;\r\n};\r\n```\r\n## 复杂度\r\n时间：O(1)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919845440","body":"## 思路\r\n参考滑动窗口题解\r\n## 代码\r\n```javascript\r\nvar maxChunksToSorted = function(arr) {\r\n  var sorted = arr.slice().sort((a, b) => a - b);\r\n  var count = 0, sortedSum = 0, sum = 0;\r\n  for (var i = 0; i < arr.length; i++) {\r\n    sortedSum += sorted[i];\r\n    sum += arr[i];\r\n    if (sortedSum === sum) {\r\n      count++;\r\n      sortedSum = sum = 0;\r\n    }\r\n  }\r\n  return count;\r\n};\r\n```\r\n## 复杂度\r\n时间：O(nlogn)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920599279","body":"## 思路\r\n1. 将链表转成一个数组类型的结构\r\n2. 找到开始移动的位置，然后对数组中元素的位置进行交换\r\n3. 生成一个新的节点_head，遍历交换位置后的数组生成新的链表，return _head.next\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n  if (k === 0) return head;\r\n  var cur = head;\r\n  // 辅助栈\r\n  var stack = [];\r\n  // 计算长度\r\n  while (cur) {\r\n    stack.push(new ListNode(cur.val));\r\n    cur = cur.next;\r\n  }\r\n  // 实际要移动的步数\r\n  var start = stack.length - (k % stack.length);\r\n  stack = [...stack.slice(start), ...stack.slice(0, start)];\r\n  var _head = new ListNode(null);\r\n  var _cur = _head;\r\n  for (var i = 0; i < stack.length; i++) {\r\n    _cur.next = stack[i];\r\n    _cur = _cur.next;\r\n  }\r\n  return _head.next;\r\n};\r\n```\r\n## 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921633941","body":"## 思路\r\n## 代码\r\n``` javascript\r\nvar swapPairs = function(head) {\r\n  if (!head || !head.next) return head;\r\n  var one = head;\r\n  var two = one.next;\r\n  var three = two.next;\r\n  two.next = one;\r\n  one.next = swapPairs(three);\r\n  return two;\r\n};\r\n```\r\n## 复杂度\r\n时间：O(n)\r\n空间：O(n) 递归调用栈","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922405327","body":"## 思路\r\n讲义（基础篇） -> 链表\r\n## 代码\r\n```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n  var a = headA, b = headB;\r\n  while (a != b) {\r\n    a = a ? a.next : null;\r\n    b = b ? b.next : null;\r\n    if (a == null && b == null) return null;\r\n    if (a == null) a = headB;\r\n    if (b == null) b = headA;\r\n  }\r\n  return a;\r\n};\r\n```\r\n## 复杂度\r\n时间：O(n)\r\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Changanyue":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917880013","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        bracket_stack = []\r\n        number_stack = []\r\n        c = ''\r\n        n = ''\r\n        for e in s:\r\n            \r\n            if e.isdigit():\r\n                n+=e\r\n            elif e == '[':\r\n                bracket_stack.append(c)\r\n                number_stack.append(n)\r\n                n = ''\r\n                c = ''\r\n            elif e == ']':\r\n                \r\n                c = (bracket_stack.pop() + c*int(number_stack.pop()))\r\n            else:\r\n                c += e\r\n        return c\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cdd111":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917902882","body":"### 解题思路\r\n通过栈来解决本题\r\n1、通过循环原来的字符串依次将除了']'以外的字符进栈a，\r\n2、如果遇到中括号‘]’就从栈顶依次出栈，用一个临时栈b来保存，直到遇到‘[’，此时栈顶是这段字符串的重复次数，\r\n取出数字并重复之前的临时栈，计算出结果再倒序插入原来的栈a，清空用来保存临时数组的临时栈b\r\n3、然后继续循环，直到S字符串被遍历完\r\n### `javascript\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n var decodeString = function(s) {\r\n  let newZhan = [];\r\n  let temp=[]\r\n  for(let i=0;i<s.length;i++){\r\n      if(s[i]!=']'){\r\n        newZhan.push(s[i])\r\n      }else{\r\n        let time = new Array()\r\n        while(newZhan[newZhan.length-1]!='['){\r\n          temp.push(newZhan.pop())\r\n        }\r\n        newZhan.pop()\r\n        while(!isNaN(newZhan[newZhan.length-1])){\r\n          let tmp = newZhan.pop()\r\n          time.push(tmp)\r\n        }\r\n        time= Number(time.reverse().join(''))\r\n        newZhan.push(temp.reverse().join('').repeat(time));\r\n        temp.splice(0,temp.length)\r\n      }\r\n  }\r\n  return newZhan.join('');\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920138279","body":"###javascript解法\n### 代码\n\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    let stack = [];\n    for(let i=0;i<arr.length;i++){\n        let now = arr[i];\n        if(stack.length>0 && now<stack[stack.length-1]){\n           let cur = stack[stack.length-1];\n           while(stack.length>0 && now<stack[stack.length-1]){\n               stack.pop();\n           }\n           stack.push(cur)\n        }else{\n            stack.push(now)\n        }\n    }\n    return stack.length;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuwan":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917922691","body":"### 思路\n* 当遇到数字，压入栈，遇到[压入栈，并保存Sting数组，遇到]压出栈并弹出一个数字，直到不是数字，循环数字把字符在压入栈中\n### 代码\n* java\n```java\n        char[] chars = s.toCharArray();\n        // 当遇到数字，压入栈，遇到[压入栈，并保存Sting数组，遇到]压出栈并弹出一个数字重复\n        Stack<Character> stack = new Stack<>();\n        int length = chars.length;\n        int tmp = 0;\n        StringBuffer res = new StringBuffer();\n        while (tmp < length) {\n            if (chars[tmp] <= '9' && chars[tmp] >= '0') {\n                stack.push(chars[tmp]);\n            } else if (chars[tmp] == '[') {\n                stack.push(chars[tmp]);\n            } else if (chars[tmp] == ']') {\n                // 弹出字符直到遇到[符号\n                StringBuffer sb = new StringBuffer();\n                StringBuffer sb2 = new StringBuffer();\n                char popChar;\n                while ((popChar = stack.pop()) != '[') {\n                    sb.append(popChar);\n                }\n                while (!stack.isEmpty()) {\n                    popChar = stack.peek();\n                    if (popChar >= '0' && popChar <= '9') {\n                        popChar = stack.pop();\n                        sb2.append(popChar);\n                    } else {\n                        break;\n                    }\n                }\n                int cycle = Integer.parseInt(sb2.reverse().toString());\n                sb = sb.reverse();\n                String appendStr = sb.toString();\n                for (int i = 1 ; i < cycle ; i++) {\n                    sb.append(appendStr);\n                }\n                char[] myChars = sb.toString().toCharArray();\n                for (int i = 0 ; i < myChars.length ; i++) {\n                    stack.push(myChars[i]);\n                }\n            } else {\n                stack.push(chars[tmp]);\n            }\n\n            tmp++;\n        }\n        while (!stack.isEmpty()) {\n            res.append(stack.pop());\n        }\n        System.out.println(res.reverse());\n```\n用字符存储需要反复翻转字符，所以我改用了字符串的栈来存储\n```java\n    public String decodeString(String s) {\n        LinkedList<String> stack = new LinkedList<>();\n        int index = 0;\n        while (index < s.length()) {\n            char tmp = s.charAt(index);\n            if (tmp >= '0' && tmp <= '9') {\n                // 是数字，当做整体放入栈中\n                StringBuffer sb = new StringBuffer();\n                while(tmp >= '0' && tmp <= '9') {\n                    sb.append(tmp);\n                    tmp = s.charAt(++index);\n                }\n                stack.addLast(sb.toString());\n            } else if (tmp == '[') {\n                stack.addLast(String.valueOf(tmp));\n                index++;\n            } else if (tmp == ']') {\n                LinkedList<String> sub = new LinkedList<>();\n                while (!\"[\".equals(stack.peekLast())) {\n                    sub.addLast(stack.pollLast());\n                }\n                Collections.reverse(sub);\n                stack.pollLast();\n                int repTime = Integer.parseInt(stack.pollLast());\n                StringBuffer t = new StringBuffer();\n                StringBuffer sb2 = new StringBuffer();\n                for (String tmpStr : sub) {\n                    sb2.append(tmpStr);\n                }\n                String o = sb2.toString();\n                for (int i = 0 ; i < repTime ; i++) {\n                    t.append(o);\n                }\n                stack.addLast(t.toString());\n                index++;\n            } else {\n                // 是字母，当做整体放入栈中\n                StringBuffer sb = new StringBuffer();\n                while ((tmp >= 'a' && tmp <= 'z') || (tmp >= 'A' && tmp <= 'Z')) {\n                    sb.append(tmp);\n                    if (++index >= s.length()) {\n                        break;\n                    }\n                    tmp = s.charAt(index);\n                }\n                stack.addLast(sb.toString());\n            }\n        }\n        StringBuffer res = new StringBuffer();\n        while(!stack.isEmpty()) {\n            res.append(stack.pollFirst());\n        }\n        return res.toString();\n    }\n```\n\n### 复杂度\n时间复杂度O(n)\n空间复杂度O(n)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918750993","body":"### 思路\n每次需要出队列的时候，把数据从入栈导入到出栈，出栈完成后再次导回来\n### 代码\n* java\n``` java\nclass MyQueue {\n\n    private Stack<Integer> inStack;\n    private Stack<Integer> outStack;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n        int res = outStack.pop();\n        while (!outStack.isEmpty()) {\n            inStack.push(outStack.pop());\n        }\n        return res;\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n        int res = outStack.peek();\n        while (!outStack.isEmpty()) {\n            inStack.push(outStack.pop());\n        }\n        return res;\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return inStack.isEmpty();\n    }\n}\n```\n\n后来发现，只需要出栈倒腾一次就行了，不用反复倒腾\n\n``` java\nclass MyQueue {\n\n    private Stack<Integer> inStack;\n    private Stack<Integer> outStack;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        // 只有当出栈为空时，再把入栈队列倒腾出来\n        if (outStack.isEmpty()) {\n            while(!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.pop();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        if (outStack.isEmpty()) {\n            while(!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n```\n### 复杂度\n* 时间复杂度O(1)\n* 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919995745","body":"### 思路\n使用栈结构存储最大值，每次大于栈顶元素则入栈，小于栈顶元素则保留最大元素，一直出栈到当前元素小于等于栈顶元素，在入栈最大值\n### 代码\n* java\n``` java\n    public static int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        int max;\n        for (int i = 0 ;i < arr.length ; ++i ) {\n            if (stack.isEmpty() || arr[i] >= stack.peek()) {\n                stack.push(arr[i]);\n            } else {\n                max = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\n                    stack.pop();\n                }\n                stack.push(max);\n            }\n        }\n        return stack.size();\n    }\n```\n### 复杂度\n时间复杂度： O(n)\n空间复杂度： O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917327281","body":"class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num[-1] += k\r\n        for i in range(len(num)-1, -1, -1):\r\n            carry, num[i] = divmod(num[i], 10)\r\n            if i:\r\n                num[i-1] += carry\r\n        if carry:\r\n            num = [int(i) for i in str(carry)] + num\r\n        return num\r\n\r\ntime complexity: max(len(num), logk)\r\nspace complexity: max(len(num), logk)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917569078","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float(\"-inf\")\r\n        ans = []\r\n        for i in range(0, len(s), 1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n        \r\n        prev = float(\"inf\")\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```\r\ntime complexity: `O(n)`\r\nspace complexity: `O(n)`","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917748523","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.add = []\r\n        self.size = 0\r\n        self.max_size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n            self.add.append(0)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            v = self.stack.pop()\r\n            i = self.add.pop()\r\n            self.size -= 1\r\n            if self.size > 0:\r\n                self.add[-1] += i\r\n            return v+i\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        n = min(k, len(self.stack))\r\n        if n >= 1:\r\n            self.add[n-1] += val\r\n```\r\n\r\ntime complexity: pop and push `O(1)`, inc: `O(1)`\r\nspace complexity: `O(n)`","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-917924069","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c is not ']':\r\n                stack.append(c)\r\n            else:\r\n                rep = ''\r\n                while True:\r\n                    s = stack.pop()\r\n                    if s == '[':\r\n                        break\r\n                    else:\r\n                        rep += s\r\n                k = ''\r\n                while True:\r\n                    k += stack.pop()\r\n                    if not stack or not(stack[-1] in '0123456789'):\r\n                        break\r\n                for i in range(int(k[::-1])):\r\n                    for j in range(len(rep)-1, -1, -1):\r\n                        stack.append(rep[j])\r\n        return ''.join(stack)\r\n```\r\n\r\ntime complexity: maxK^(count_k)*n\r\nspace complexity:  maxK^(count_k)*n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921286846","body":"```\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        if not head.next:\r\n            return head\r\n        \r\n        old_head = head\r\n        acc = 1\r\n        while old_head.next:\r\n            if acc % 2 != 0:\r\n                # need swap\r\n                if acc == 1:\r\n                    next_node = old_head.next\r\n                    old_head.next = next_node.next\r\n                    next_node.next = old_head\r\n                    result = next_node\r\n                    pre_node = next_node\r\n                else:\r\n                    next_node = old_head.next\r\n                    old_head.next = next_node.next\r\n                    next_node.next = old_head\r\n                    pre_node.next = next_node\r\n                    pre_node = next_node\r\n            else:\r\n                pre_node = old_head\r\n                old_head = old_head.next\r\n            acc += 1\r\n        return result\r\n```\r\nTime complexity: `O(n)`\r\nSpace comlexity: `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922226920","body":"```\r\nclass Solution:\r\n    \r\n    def convert_list(self, head):\r\n            result = []\r\n            while head:\r\n                result.append(head.val)\r\n                head = head.next\r\n            return result\r\n        \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        \r\n        vals = self.convert_list(head)\r\n        length = len(vals) - 1\r\n        \r\n        def gen_tree(start, end):\r\n            \r\n            if start > end:\r\n                return None\r\n            \r\n            \r\n            mid = (start + end) // 2\r\n            node = TreeNode(vals[mid])\r\n            if start == end:\r\n                return node\r\n            \r\n            node.left = gen_tree(start, mid-1)\r\n            node.right = gen_tree(mid+1, end)\r\n            return node\r\n            \r\n        return gen_tree(0, length)\r\n```\r\nspace complexity `O(n)`\r\ntime compleity `O(n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922378831","body":"```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        pa = headA\r\n        pb = headB\r\n        while pa != pb:\r\n            pa = headB if pa is None else pa.next\r\n            pb = headA if pb is None else pb.next\r\n        return pa\r\n```\r\ntime complexity `O(m+n)`\r\nspace comoplexity 'O(1)'","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922512726","body":"```\r\nclass Solution:\r\n    \r\n    def getIntersect(self, head):\r\n        fast, slow = head, head\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return None\r\n        \r\n        while fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if not slow or not fast:\r\n                return None\r\n            if slow == fast:\r\n                return slow\r\n        return None\r\n        \r\n        \r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        \r\n        slow = self.getIntersect(head)\r\n        fast = head\r\n        if slow == None:\r\n            return None\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return fast\r\n ```\r\n\r\ntime complexity `O(n)`\r\nspace complexity `O(1)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Bruce-Young233":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918112207","body":"**思路**\n\n建立一个空字符串来储存遍历过的字母，遇到左括号，就将之前的字符串和数字存到一个临时的栈中，遇到右括号时取出，之后按照规则进行连接\n\n**代码**\n\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        str_new = ''\n        num = 0\n        for i in s:\n            if i.isdigit():\n                num = num * 10 + int(i)  # 处理连续数字\n            elif i.isalpha():\n                str_new += i  # 将不在括号内的字母存为一个新的字符串\n            elif i == '[':\n                stack.append((str_new, num))  # 遇到左括号，将之前的字符串和数字存起来\n                str_new, num = '', 0  # 重新初始化\n            else:\n                str_old, num_cur = stack.pop()  # 遇到右括号，取出之前的字符串和数字\n                str_new = str_old + num_cur * str_new  # 重复新的字符串，并与之前的字符串相连\n        return str_new\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n) 最大为s.length","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919106891","body":"**思路**\n\n利用两个空数组实现对队列的操作，一个表示入队，一个表示出队\n\n**Python代码**\n\n```python\nclass MyQueue:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.queue = []  # 建立两个空数组\n        self.tail = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.queue.append(x)  # push直接在队尾添加元素\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        for i in range(len(self.queue) - 1):\n            self.tail.append(self.queue.pop())  # 将queue中的元素从队尾依次删除，并存入tail数组中\n        head_popped = self.queue.pop()  # 此时queue中只剩下需要删除的队首元素head\n        for j in range(len(self.tail)):\n            self.queue.append(\n                self.tail.pop())  # 再将tail数组中的元素重新按照从后到前的顺序存回queue中\n        return head_popped\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.queue[0]  # 返回队首元素\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if len(self.queue) == 0:\n            return True  # 通过判断数组长度来确定队列是否为空\n        else:\n            return False\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whitewhatpin":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917128319","body":"# 思路\n遍历求和，preappend 结果\n# 代码\n```golang\nfunc addToArrayForm(num []int, k int) []int {\n    carry := 0\n    ans := make([]int, 0)\n    for i := len(num) - 1; i >= 0; i-- {\n        tmpSum := k % 10 + num[i] \n        if carry == 1 {\n            tmpSum++\n            carry = 0\n        }\n        \n        if tmpSum >= 10 {\n            carry = 1\n            tmpSum %= 10\n        }\n        \n        ans = append([]int{tmpSum}, ans...)\n        k /= 10\n    }\n    \n    for k != 0 {\n        tmpSum := k % 10\n        if carry == 1 {\n            tmpSum++\n            carry = 0\n        }\n        \n        if tmpSum >= 10 {\n            carry = 1\n            tmpSum %= 10\n        }\n        \n        ans = append([]int{tmpSum}, ans...)\n        \n        k /= 10\n    }\n    \n    if carry == 1 {\n        ans = append([]int{1}, ans...)\n    }\n    \n    return ans\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917456654","body":"# 思路\n从前向后和从后向前遍历go得出左侧离C最近的距离和右侧离C最近的距离\n# 代码\n\n```go\nfunc shortestToChar(s string, c byte) []int {\n    ans := make([]int, len(s))\n\n    \n    sBytes := []byte(s)\n    \n    indexOfC := -len(s)\n    \n    // calculate distance to left\n    for i := 0; i < len(sBytes); i++ {\n        if sBytes[i] == c {\n            indexOfC = i\n            ans[i] = 0\n        } else {\n            ans[i] = i - indexOfC\n        }\n    }\n    \n    indexOfC = len(s) * 2\n    \n    // calculate distance to right and min(right, left)\n    for j := len(sBytes) - 1; j >= 0; j-- {\n        if sBytes[j] == c {\n            indexOfC = j\n            ans[j] = 0\n        } else {\n            ans[j] = min(indexOfC - j, ans[j])\n        }\n    }\n    \n    return ans\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    \n    return b\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/11#issuecomment-917676697","body":"# 思路\nRecord the max size of the stack & using slice to achieve the stack\n# 代码\n```go\ntype CustomStack struct {\n    MaxSize int\n    Stack []int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{maxSize, []int{}}\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if len(this.Stack) < this.MaxSize {\n        this.Stack = append(this.Stack, x)\n    }\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if len(this.Stack) == 0 {\n        return -1\n    }\n    \n    val := this.Stack[len(this.Stack)-1]\n    this.Stack = this.Stack[:len(this.Stack)-1]\n    return val\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    for i := 0; i < k && i < len(this.Stack); i++ {\n        this.Stack[i] += val\n    }\n}\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liudi9047":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917810005","body":"补卡：\r\nJAVA：使用加法模板 数值= 当前位A + 当前位B + 进位\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length;\r\n        //声明一个动态数组 用来装计算结果\r\n         List<Integer> res = new ArrayList<>();\r\n         int i = n - 1;\r\n         int carry = 0;\r\n         int sum = 0;\r\n         //加法模板\r\n         while(i >= 0 || k != 0) {\r\n             int x = i >= 0 ? num[i]:0;\r\n             int y = k != 0 ? k % 10:0;\r\n             //数据等于当前位+进位\r\n             sum = x + y + carry;\r\n             carry = sum/10;//获取进位\r\n             k = k/10;\r\n             i--;\r\n             sum = sum%10;\r\n             res.add(0,sum);\r\n         }\r\n         if (carry != 0) res.add(0,carry);\r\n         return res;\r\n\r\n    }\r\n}\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-918001124","body":"class Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(N)\r\n    空间复杂度：O(N)\r\n\r\n","onTime":false},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921845581","body":"class Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head: return None\r\n        dh = ListNode(next=head)\r\n        p0 = dh\r\n        p1 = head\r\n        p2 = head.next\r\n        while p1 and p2:\r\n            tmp = p2.next\r\n            p0.next = p2\r\n            p2.next = p1\r\n            p1.next = tmp\r\n            p0 = p1\r\n            p1 = tmp\r\n            p2 = tmp.next if tmp else None\r\n        return dh.next\r\n时间复杂度O(n)\r\n空间复杂度O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922487582","body":"public class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null){\r\n            return null;\r\n        }\r\n        ListNode a = headA, b = headB;\r\n        while(a != b){\r\n            a = a == null? headB: a.next;\r\n            b = b == null? headA: b.next;\r\n        }\r\n        return a;\r\n    }\r\n}\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AnkiDord":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917327359","body":"思路：将列表A转化成字符串在转化成整数，与K相加。将结果转化字符串在转化成列表。\r\n代码：\r\n`\r\n\r\nclass Solution:\r\n    \r\n     def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_str = ''\r\n        for i in num:\r\n            num_str += str(i)\r\n        num_int = eval(num_str) + k\r\n\r\n        out = []\r\n        for i in str(num_int):\r\n            out.append(eval(i))\r\n        return out\r\n`\r\n复杂度分析\r\n时间复杂度：两个for循环 O(N) + O(N) =O(N)\r\n空间复杂度：一个字符串和一个空列表O(N)+O(N)=O(N)\r\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918263879","body":"# 思路\n相出了存在子问题，但是不会写代码\n去看了答案，第一种理解了，递归子问题代码还是不怎么理解\n\n设置一个栈stack，字符串res和一个整数变量multi,遍历s，当字符是数字时变成整数(单个字符数字大小在0~9，可能连续出现多个)，是‘['时将res和multi进栈\n，是‘]’时将之前的res和multi弹出，与当前res相加\n\n# 代码\n'''\nclass Solution:\n    def decodeString(self, s: str) -> str:\n\n        stack, res, multi = [], '', 0\n        for c in s:\n            if c == '[':\n                stack.append([res, multi])\n                res, multi = '', 0\n            elif c == ']':\n                last_res, multi = stack.pop()\n                res = last_res + multi*res\n                multi = 0\n            elif '0' <= c <= '9':\n                multi = multi*10 + int(c)\n            else:\n                res += c\n        return res\n'''\n时间复杂度：遍历字符串O(N)\n空间复杂度：栈+字符串长度=O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guohuijiedesu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917425874","body":"##思路\n两数相加的思路，\n如1456+239。\n运算：从个位数开始一位一位加。超过十，就给移位carry赋值。9+6=15，移位为1。那么十位数的算法：和=十位数A+十位数B+移位carry。十位数的和=5+3+1。\n判断条件：while i >= 0 or K != 0。当往前到第一位时，跳出循环不运算了。如果两个第一位相加大于十，那么carry还有值，就再加给carry在第一位。\n##代码\n```\ndef addToArrayForm(self, A: List[int], K: int) -> List[int]:\n    res = []\n    i, carry = len(A) - 1, 0\n    while i >= 0 or K != 0:\n        x = A[i] if i >= 0 else 0\n        y = K % 10 if K != 0 else 0\n\n        sum = x + y + carry\n        res.append(sum % 10)\n        carry = sum // 10\n\n        i -= 1\n        K //= 10\n    if carry != 0: res.append(carry)\n    return res[::-1]\n```\n##时间复杂度\n我猜O(N)\n##空间复杂度\n我猜O(N)","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919234611","body":"### 思路\r\n栈：FIFO，队列：LILO。\r\npython参考：https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/232-yong-zhan-shi-xian-dui-lie-zhan-pyth-gww5/\r\nJavascript等参考：https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/tu-jie-guan-fang-tui-jian-ti-jie-yong-zh-4hru/\r\n声明两个栈，分别为 in_stack 和 out_stack；\r\n对于push 操作：\r\n将元素压入 in_stack 中；\r\n对于pop 操作，分情况：\r\n当 out_stack 为空时，先将 in_stack 中的元素移动到 out_stack 中，然后将 out_stack 栈顶元素弹出并返回；\r\n当 out_stack 不为空时，将 out_stack 栈顶元素弹出并返回；\r\n对于peek 操作，分情况（与 {\\rm pop}pop 操作不同于不需要弹出栈顶元素）：\r\n当 out_stack 为空时，先将 in_stack 中的元素移动到 out_stack 中，然后将 out_stack 栈顶元素返回；\r\n当 out_stack 不为空时，将 out_stack 栈顶元素返回；\r\n对于 empty 操作：\r\n判断两个栈是否都为空，都为空返回 True，否则返回 False。\r\n### 代码\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.in_stack = []\r\n        self.out_stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        # 添加元素\r\n        self.in_stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        # out_stack 不为空，弹出并返回栈顶元素\r\n        # 否则先将 in_stack 中的元素移动到 out_stack 中再弹出并返回栈顶元素\r\n        if not self.out_stack:\r\n            self.in_to_out()\r\n        return self.out_stack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        # 与 pop 方法类似，但是不弹出栈顶元素\r\n        if not self.out_stack:\r\n            self.in_to_out()\r\n        return self.out_stack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        # 两个栈均为空，才表示队列为空\r\n        return not self.in_stack and not self.out_stack\r\n    \r\n    def in_to_out(self):\r\n        \"\"\"\r\n        Moves the element of the in_stack to the out_stack\r\n        \"\"\"\r\n        # 将 in_stack 中的元素移动到 out_stack 中\r\n        while self.in_stack:\r\n            self.out_stack.append(self.in_stack.pop())\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n作者：yiluolion\r\n链接：https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/232-yong-zhan-shi-xian-dui-lie-zhan-pyth-gww5/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n```\r\n### 复杂度\r\n时间复杂度：其中push 和empty 操作时间复杂度为 O(1)，而pop 和peek 操作的均摊时间复杂度为 O(1)。\r\n\r\npop 和peek 操作，最坏的情况下时间复杂度为 O(n)，n 表示队列的大小。即是 out_stack为空时，需要移动元素，进行出栈入栈的操作，时间复杂度为 O(n)，但后续的操作，时间复杂度为 O(1)，摊还后均摊时间复杂度为 O(1)。\r\n\r\n空间复杂度：O(n)。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921015655","body":"### 思路\r\n参考b站up:五分钟力扣YK。<br />\r\n第一步：链表的长度。tail.next一步步，tail.next==none时为最后一个。<br />\r\n第二步：旋转链表。<br />\r\n题目要求我们旋转从右往左数第K个这个值。它等价于 从左往右数第length-k+1个。<br />\r\n从head开始移动的话，移动到这个位置需要移动(length-k)次，我们把这个位置的元素称为new_head。把它当成我们返回的链表新的头部。从k开始断，断掉之后那个值。<br />\r\n断掉前的那个数我们称为pivot。需要移动(length-k-1)次<br />\r\nnew_head=pivot.next。<br />\r\n把原链表的尾巴接上原链表的头部。tail.next-head。把pivot.next接上none就可以了。pivot.next=none。<br />\r\n### 代码\r\n```\r\nclass Solution:\r\n    def rotateRight(selr,head: ListNode,k: int)->ListNode:\r\n        if head==None or head.next==None or k==0:\r\n            return head\r\n        length,tail=1,head\r\n        while tail.next:\r\n            length,tail = length+1,tail.next\r\n\r\n        k%=length\r\n        if k==0:\r\n            return head\r\n        pivot=head\r\n        for _ in range(length-k-1):\r\n            pivot=pivot.next\r\n\r\n        new_head=pivot.next\r\n        tail.next-head\r\n        pivot.next=None\r\n        return new_head\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921856982","body":"### 思路\ndumb做一个假的指针头。try\\except和try\\catch一样。减少了写if语句来判断。如果出了任何错都走except。也就是哪个.next没有了都走except。\n### 代码\n```\nclass Solution:\n    def swapPairs(self,head: ListNode)->ListNode:\n        dumb=ListNode(10086)\n        dumb.next=head\n        move=dumb\n        def swap(pre,x1,x2):\n            temp = x2.next\n            pre.next=x2\n            x1.next=temp\n            x2.next=x1\n        while True:\n            try:\n                swap(move,move.next,move.next.next)\n                move=move.next.next\n            except:\n                break\n        return dumb.next   \n```\n### 复杂度\n空间复杂度：O(n)\n时间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922495523","body":"### 思路\n如果两个链表无重合节点，重合节点是空，则指向空。有重合节点则指向重合节点。\n遍历链表，从链表a的头开始到重合节点到b链表的头作为链表尾。参考https://maxming0.github.io/2021/03/04/Intersection-of-Two-Linked-Lists/\n### 代码\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return None\n        pa, pb = headA, headB\n        while pa is not pb:\n            pa = headB if pa is None else pa.next\n            pb = headA if pb is None else pb.next\n        return pa\n```\n\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzyhang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917860738","body":"补打卡。\r\n\r\n思路\r\n---\r\n\r\n低位逐位相加，溢出进位。\r\n\r\n代码\r\n---\r\n```\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        for(int i=num.length-1;i>=0;i--){\r\n            int sum = num[i]+k%10;\r\n            k=k/10;\r\n            if(sum>=10){\r\n                sum=sum-10;\r\n                k=k+1;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for(;k>0;k=k/10){\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```\r\n\r\n复杂度\r\n---\r\n·空间复杂度：O(1)\r\n·时间复杂度：O(max(n,logk))","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919120311","body":"思路\r\n---\r\n进入栈用作存储进入数据；\r\n退出栈用作模拟队列先进先出的容器；\r\n\r\n代码\r\n---\r\n```\r\nclass MyQueue {\r\n    private Stack<Integer> in;\r\n    private Stack<Integer> out;\r\n    private int peek;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n         in = new Stack<>();\r\n         out = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        if(in.isEmpty())\r\n            peek = x;\r\n        in.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(out.isEmpty()){\r\n            while(!in.isEmpty()){\r\n                out.push(in.pop());\r\n            }\r\n        }\r\n        return out.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(!out.isEmpty()){\r\n            return out.peek();\r\n        }\r\n            return peek;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return in.isEmpty()&&out.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n·时间复杂度：O(1)；\r\n·空间复杂度：O(N);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Forschers":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-918131873","body":"\r\n补打卡\r\n## 思路\r\n逐位相加\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //初始化参数\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        //1.从后往前逐位相加\r\n        for(int i = n-1;i>=0;i--){\r\n            //1.1 逐位相加\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            //1.2 考虑相加进位的情况\r\n            if(sum >= 10){\r\n                sum %= 10;\r\n                k++;\r\n            }\r\n            //1.3 添加到结果集中\r\n            res.add(sum);\r\n        } \r\n        \r\n\r\n        //2.K的长度大于数组长度\r\n        for(;k>0;k /= 10){\r\n            res.add(k % 10);\r\n        }\r\n\r\n        //3.将结果集反转\r\n        Collections.reverse(res);       \r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(n,logk)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918337775","body":"public String decodeString(String s) {\r\n    int ptr = 0;\r\n    int len = s.length();\r\n    LinkedList<String> stack = new LinkedList<>();\r\n\r\n    while (ptr < len) {\r\n        char ch = s.charAt(ptr++);\r\n\r\n        if (Character.isDigit(ch)) {\r\n            int from = ptr - 1;\r\n            while (Character.isDigit(s.charAt(ptr))) {\r\n                ++ptr;\r\n            }\r\n            stack.addLast(s.substring(from, ptr));\r\n        } else if (Character.isLetter(ch) || ch == '[') {\r\n            stack.addLast(String.valueOf(ch));\r\n        } else {\r\n            LinkedList<String> sub = new LinkedList<>();\r\n            while (!\"[\".equals(stack.peekLast())) {\r\n                sub.addFirst(stack.removeLast());\r\n            }\r\n            String str = String.join(\"\", sub);\r\n            \r\n            // 左括号出栈\r\n            stack.removeLast();\r\n            \r\n            int repeatTimes = Integer.valueOf(stack.removeLast());\r\n            StringBuilder builder = new StringBuilder(str.length() * repeatTimes);\r\n            while (repeatTimes-- > 0) {\r\n                builder.append(str);\r\n            }\r\n\r\n            stack.addLast(builder.toString());\r\n        }\r\n    }\r\n\r\n    return String.join(\"\", stack);\r\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919629764","body":"继续抄答案\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> stack = new LinkedList<Integer>();\r\n        for(int num : arr){\r\n            //getLast() 获取最后一个元素\r\n            if(!stack.isEmpty() && num < stack.getLast()){\r\n                int head = stack.removeLast();\r\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\r\n                stack.addLast(head);\r\n            }else{\r\n                stack.addLast(num);\r\n            }\r\n            \r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921021094","body":"\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        //如果是空和只有一个元素链表就直接返回\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        int len = 1, index;\r\n        ListNode temp = head,newHead;\r\n        //计算链表长度\r\n        while(temp.next != null){\r\n            len++;\r\n            temp = temp.next;\r\n        }\r\n    \r\n        //将列表设为循环链表\r\n        temp.next = head;\r\n        k %= len;\r\n        index = len - k;\r\n        //找到要断开循环链表的结点 记录链表新的头节点\r\n        while (index-- > 0) {\r\n            temp = temp.next;\r\n        }\r\n        newHead = temp.next;\r\n        temp.next = null;\r\n        return newHead;\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921891647","body":"\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        ListNode next = head.next;\r\n        head.next = swapPairs(next.next);\r\n        next.next = head;\r\n        return next;\r\n    }\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yourspeace":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918236394","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatcount = ''\n                repeatstr = ''\n                while stack[-1] != '[':\n                    repeatstr = stack.pop() + repeatstr\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatcount =  stack.pop() + repeatcount\n                stack.append(int(repeatcount) * repeatstr)\n            else:\n                stack.append(c)\n        return ''.join(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918929643","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []\n        self.help_stack = []\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        while self.stack:\n            self.help_stack.append(self.stack.pop())\n        self.help_stack.append(x)\n        while self.help_stack:\n            self.stack.append(self.help_stack.pop())\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        return self.stack.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not bool(self.stack)\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920704230","body":"最多遍历两遍链表 o（n）\n没有使用额外空间o（1）\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k<1 or not head or not head.next :\n            return head\n        \n        # initialization\n        fast = slow = head\n        i = 1\n        count = 1\n        \n        # move the fast probe\n        while i <= k:\n            if fast.next:\n                count = count + 1\n                fast = fast.next\n            else:\n                k = k % count\n                if k == 0:\n                    return head\n                i = 0\n                fast = head\n            i = i + 1\n        \n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n\n        new_head = slow.next\n        slow.next = None\n        fast.next = head\n\n        return new_head      \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Draculabo":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918255812","body":"思路：\n因为方括号可能内嵌，需从最内层decode，可使用一个辅助栈：\n1. 将字符依次入栈，遇到第一个']'时出栈，至第一个'['前的数字截止.\n2. 根据数字解码得到相应的字符串。\n3. 将完成解码后的字符串重新入栈。\n4. 重复1-3中操作。\n代码部分：\n\nclass Solution {\n    public String decodeString(String str) {\n\n        if (str == null || str.length() == 0) {\n            return \"\";\n        }\n\n        Stack<Character> stack = new Stack<>();\n\n        for (char c : str.toCharArray()) {\n            if (c != ']') {\n                stack.push(c);\n                // 遇到']'\n            } else {\n                StringBuilder sb = new StringBuilder();\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) sb.insert(0, stack.pop());\n\n                String str = sb.toString();\n                stack.pop();\n                sb = new StringBuilder();\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) sb.insert(0, stack.pop());\n\n                int i= Integer.valueOf(sb.toString());\n                while (i> 0) {\n                    for (char cc : str.toCharArray()) stack.push(cc);\n                    i--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while (!stack.isEmpty()) res.insert(0, stack.pop());\n\n        return res.toString();\n    }\n}\n\n复杂度：\nTime: O(n^2)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919062012","body":"```\n/**\n * 思路；\n * 使用双重栈实现队列\n * 1. 当入队时将元素压入输入栈\n * 2. 当出队或查看第一个元素时    将输入栈压入输出栈\n * 3. 当查看队列是否为空时，返回输入栈与输出栈是否为空\n */\n\n/**\n * 自定义队列 双重栈实现\n * 空间复杂度： o(n)\n * @param <E> 队列元素类型\n */\npublic class CustomQueue<E> {\n    Stack<E> inputStack = new Stack<>();\n    Stack<E> outputStack = new Stack<>();\n\n    /**\n     * 入队\n     * @param e  入队元素\n     * 时间复杂度： o(1)\n     * 空间复杂度： 0(1)\n     */\n    public  void push(E e) {\n        inputStack.push(e);\n    }\n\n    /**\n     * 重排栈 将输入栈中元素压入输出栈中\n     * 时间复杂度： o(n)\n     * 空间复杂度： 0(1)\n     */\n    public  void reStack() {\n        if(outputStack.isEmpty())\n        {\n            while(!inputStack.isEmpty())\n            {\n                outputStack.push(inputStack.pop());\n            }\n        }\n    }\n\n    /**\n     * 出队\n     * @return 出对元素\n     * 时间复杂度： o(1)\n     * 空间复杂度： 0(n)\n     */\n    public  E pop() {\n        reStack();\n     return outputStack.pop();\n    }\n\n    /**\n     * 不出对，返回第一个元素\n     * @return 第一个元素\n     * 时间复杂度： o(1)\n     * 空间复杂度： 0(n)\n     */\n    public E peek() {\n        reStack();\n        return outputStack.peek();\n    }\n\n    /**\n     * 检查队列是否为空\n     * @return 队列是否为空\n     * 时间复杂度： o(1)\n     * 空间复杂度： 0(1)\n     */\n    public boolean isEmpty() {\n        return inputStack.isEmpty() && outputStack.isEmpty();\n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thisjustsoso":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918259910","body":"class Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack=new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c !=']'){\n               //遍历到‘]’之前一直压栈\n                stack.push(c);\n            }else{\n             //取最里面[]内的字符\n                StringBuilder sub=new StringBuilder();\n                while(!stack.isEmpty() && Character.isLetter(stack.peek())){\n                    sub.insert(0,stack.pop());\n                }\n              //去掉‘]’\n                stack.pop();\n              //取重复次数\n                StringBuilder digitSb=new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    digitSb.insert(0,stack.pop());\n                }\n                int count=Integer.valueOf(digitSb.toString());\n\n                while(count > 0){\n                    for(char ch : sub.toString().toCharArray() ){\n                    stack.push(ch);\n                    \n                    }\n                    count--;\n                }\n            }\n        }\n        StringBuilder sb=new StringBuilder();\n        while(!stack.isEmpty()){\n            sb.insert(0,stack.pop());\n        }\n    return sb.toString();\n    }\n\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918877013","body":"class MyQueue {\n    /**初始化MyQueue时同时初始化stack1和stack2*/\n        private Stack<Integer> stack1;\n        private Stack<Integer> stack2;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack1 = new Stack();\n        stack2 = new Stack();\n    }\n    \n\n    /** Push element x to the back of queue. */\n    \n    /**push时用stack1接收 stack2再全部接收stack1吐出的数据*/\n    public void push(int x) {\n        while(!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n        stack1.push(x);\n        while(!stack1.isEmpty()){\n            stack2.push(stack1.pop());\n        }\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        return stack2.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        return stack2.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return stack2.isEmpty();\n    }\n\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Potato121":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918329852","body":"### 思路\r\n正则表达式匹配\r\n\r\n### 代码：\r\n**Javascript Code**\r\n\r\n\r\n```\r\nfunction decodeString(str) {\r\n    var tmpStr = str;\r\n    var regExpAll = /[0-9]+\\[[a-zA-z]+]/g;\r\n    var array = tmpStr.match(regExpAll);\r\n    while(array != null && array.length > 0) { \r\n        var curr_item = array[0];\r\n        var tmpItem = curr_item.replace(/]/g,\"\");;\r\n        var tmpArr = tmpItem.split('[');\r\n        var num = Number(tmpArr[0]);\r\n        var result = tmpArr[1].padStart(num * tmpArr[1].length, tmpArr[1]);\r\n        var tmpReg =  num + '[' + tmpArr[1] + ']';\r\n        tmpStr = tmpStr.replace(tmpReg,result);\r\n        array = tmpStr.match(regExpAll);\r\n    }\r\n    return tmpStr;\r\n}\r\nconsole.log(decodeString(\"2[abc]3[cd]ef\"));\r\n```\r\n\r\n### 算法复杂度\r\n* 时间复杂度: 暂无\r\n* 空间复杂度: 暂无","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922456132","body":"### 题目地址\r\n- https://leetcode-cn.com/problems/intersection-of-two-linked-lists/submissions/\r\n\r\n### 思路1 \r\n* 比较直接，遍历a全部放进哈希表，遍历b如果见到已经在哈希表中的则就是要找的节点，否则没有交点\r\n\r\n### 代码\r\n**JavaScript Code**\r\n\r\n```\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let tmpA = headA;\r\n    let tmpB = headB;\r\n    let data = new Set();\r\n    while(tmpA != null) {\r\n        data.add(tmpA);\r\n        tmpA = tmpA.next;\r\n    }\r\n    while(tmpB != null) {\r\n        if(data.has(tmpB)) {\r\n            return tmpB;\r\n        }\r\n        tmpB = tmpB.next;\r\n    }\r\n    return null;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ozhfo":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/13#issuecomment-918352472","body":"## 代码\n```java\n public String decodeString(String s) {\n        StringBuffer result = new StringBuffer();\n        Stack<Integer> numStack = new Stack<>();\n        Stack<StringBuffer> strStack = new Stack<>();\n        int multi = 0;\n        for (char c : s.toCharArray()) {\n            // abc3[ab2[fg]]def\n            if (Character.isDigit(c)) {\n                // 数字取出来\n                multi = multi * 10 + c - '0';\n            } else if (c == '[') {\n                // 遇到\"[\"将当前环境入栈\n                strStack.add(result);\n                numStack.add(multi);\n                result = new StringBuffer();\n                multi = 0;\n            } else if (Character.isAlphabetic(c)) {\n                // 字符直接记录\n                result.append(c);\n            } else {\n                // 遇到】取出栈字符串\n                // (popStr(ab))2[subStr(fg)] = popStr + num * subStr\n                StringBuffer ansTmp = strStack.pop();\n                int num = numStack.pop();\n                for (int i = 0; i < num; i++) {\n                    ansTmp.append(result);\n                }\n                result = ansTmp;\n            }\n        }\n        return result.toString();\n    }\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919280988","body":"\n```java\nclass MyQueue {\n\n        private Stack<Integer> in, out;\n\n        public MyQueue() {\n            in = new Stack<>();\n            out = new Stack<>();\n        }\n\n   \n        public void push(int x) {\n            while (!out.isEmpty()) {\n                in.push(out.pop());\n            }\n            in.push(x);\n        }\n\n    \n        public int pop() {\n            while (!in.isEmpty()) {\n                out.push(in.pop());\n            }\n            return out.pop();\n        }\n\n        public int peek() {\n            while (!in.isEmpty()) {\n                out.push(in.pop());\n            }\n            return out.peek();\n        }\n\n        public boolean empty() {\n            return out.isEmpty() && in.isEmpty();\n        }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Jding0":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918481053","body":"### 思路\r\n双栈，解决队列\r\n\r\n\r\n### 代码 (Python)\r\n\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n\r\n        return self.outstack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n\r\n        return self.outstack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.instack) == len(self.outstack) == 0\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间：O(N)\r\n- 空间:  O(N)\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921021834","body":"## 思路\r\n\r\n## 代码 (Python)\r\n\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        # 链表为空或只有一个节点时直接返回\r\n        if not head or not head.next: return head\r\n        # 得到链表长度\r\n        ln = 0\r\n        cur = head\r\n        while cur:\r\n            ln += 1\r\n            cur = cur.next\r\n        # 需要右移的个数\r\n        k %= ln\r\n\r\n        # 找到倒数第k+1个节点，使用双指针的方法\r\n        slow, fast = head, head\r\n        # 让快指针在慢指针前面k个位置\r\n        for _ in range(k):\r\n            fast = fast.next\r\n        # 两指针同时移动，当快指针在最后一个时，慢指针则在倒数第k+1的位置\r\n        while fast.next:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        # 将尾部连接，设置新的头节点，即倒数第k个节点，并将原来的断开\r\n        fast.next = head\r\n        head = slow.next\r\n        slow.next = None\r\n        return head    \r\n\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921914130","body":"##思路\r\n\r\n## 代码 Python\r\n\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummyHead = ListNode(0)\r\n        dummyHead.next = head\r\n        temp = dummyHead\r\n        while temp.next and temp.next.next:\r\n            node1 = temp.next\r\n            node2 = temp.next.next\r\n            temp.next = node2\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            temp = node1\r\n        return dummyHead.next\r\n\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921956803","body":"## 思路\r\ncreate dumpy head and exchange two neighors node\r\n\r\n## 代码 \r\n```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummyHead = ListNode(0)\r\n        dummyHead.next = head\r\n        temp = dummyHead\r\n        while temp.next and temp.next.next:\r\n            node1 = temp.next\r\n            node2 = temp.next.next\r\n            temp.next = node2\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            temp = node1\r\n        return dummyHead.next\r\n\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)，其中 nn 是链表的节点数量。需要对每个节点进行更新指针的操作。\r\n空间复杂度：O(1)。\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yyangeee":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918635670","body":"# 232\r\n\r\n## 思路\r\n两个栈，一个负责pop,一个负责push\r\n\r\n## 代码\r\n```py\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.popstack = []\r\n        self.pushstack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.pushstack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.popstack:\r\n            while self.pushstack:\r\n                self.popstack.append(self.pushstack.pop())\r\n        return self.popstack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.popstack:\r\n            while self.pushstack:\r\n                self.popstack.append(self.pushstack.pop())\r\n        return self.popstack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.pushstack)==0 and len(self.popstack)==0\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：$O(N)$, N 为数组长度。\r\n- 空间复杂度：$O(N)$。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pan-qin":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918709390","body":"Idea:\nuse a stack temp to temporarily hold the original queue in reverse order, push the new element into queue and put back the temp stack.\nSpace Complexity: O(n)\nTime Complexity: \npush:O(n)\npeek, pop, empty:O(1) \nJAVA:\nclass MyQueue {\n    Stack<Integer> queue;\n    \n    /** Initialize your data structure here. */\n    public MyQueue() {\n        queue=new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        Stack<Integer> temp = new Stack<>();\n        while(!queue.isEmpty())\n            temp.push(queue.pop());\n        queue.push(x);\n        while(!temp.isEmpty())\n            queue.push(temp.pop());\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() { \n        return queue.pop();\n        \n    }\n    \n    /** Get the front element. */\n    public int peek() {\n     \n        return queue.peek();\n        \n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return queue.isEmpty();\n        \n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Crazy-xjm":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918790538","body":"#### 思路\r\n\r\n使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈**「一个输入栈，一个输出栈」**，这里要注意输入栈和输出栈的关系。\r\n\r\n## Java代码\r\n\r\n```java\r\nclass MyQueue {\r\n    // java中的 Stack 有设计上的缺陷，官方推荐使用 Deque(双端队列) 代替 Stack  \r\n    Deque<Integer> stIn;\r\n    Deque<Integer> stOut;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stIn = new ArrayDeque<>();\r\n        stOut = new ArrayDeque<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stIn.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        // 只要 stOut 为空，那么就应该将 stIn 中所有的元素倒腾到 stOut 中\r\n        if (stOut.isEmpty()) {\r\n            while (!stIn.isEmpty()) {\r\n                stOut.push(stIn.pop());\r\n            }\r\n        }\r\n        // 再返回 stOut 中的元素\r\n        return stOut.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        // 直接使用已有的pop函数\r\n        int res = this.pop();\r\n        // 因为pop函数弹出了元素res，所以再添加回去\r\n        stOut.push(res);\r\n        return res;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        // 当 stIn 栈为空时，说明没有元素可以倒腾到 stOut 栈了\r\n        // 并且 stOut 栈也为空时，说明没有以前从 stIn 中倒腾到的元素了 \r\n        return stIn.isEmpty() && stOut.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间复杂度：O(1)\r\n\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Yachen-Guo":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918795370","body":"### Basic Idea:\nUse two stacks, stack A for in and stack B for out.  The last element for stack A is the first element for stack B, which implements the sequential flip from Stack to Queue.\n\n----\n\n### Code in Java:\n``` java\nclass MyQueue {\n    private Stack<Integer> a;\n    private Stack<Integer> b;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        a.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return a.isEmpty() && b.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n---\n\n### Complexity\nTime:  enqueue: O(N); dequeue: O(1);\n\nSpace:  enqueue: O(N); dequeue: O(1); \n\n---\n\n### Tips\nUse condition if(b.isEmpty()) to ensure the de and enqueue processes have been ended","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921899044","body":"### Basic Idea:\nIdentify the smallest unit of recursion, the basic unit of operation is the head node, the next node of the head node, and the remainder\n\n----\n\n### Code in Java:\n``` java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode remSwap = swapPairs(head.next.next);\n        ListNode headNext = head.next;\n        head.next = remSwap;\n        headNext.next = head;\n        return headNext;\n    }\n}\n```\n\n---\n\n### Complexity\nTime:  O(N)\nSpace: O(1)\n\n---\n\n### Tips\nUse recursion to simplify the whole process","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922331108","body":"### Basic Idea:\nFind the mid-point of the linked list using fast and slow pointer. Divide and conquer.\n\n----\n\n### Code in Java:\n``` java\npublic TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        else if(head.next == null) return new TreeNode(head.val);\n        ListNode pre = head;\n        ListNode p = pre.next;\n        ListNode q = p.next;\n        while(q!=null && q.next!=null){\n            pre = pre.next;\n            p = pre.next;\n            q = q.next.next;\n        }\n        pre.next = null;\n        TreeNode root = new TreeNode(p.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(p.next);\n        return root;\n    }\n```\n\n---\n\n### Complexity\nTime:  O(nlogn);\n\nSpace:  O(logn); \n\n---\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922495625","body":"### Code in Java:\n``` java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode pA = headA, pB = headB;\n        while(pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n\n---\n\n### Complexity\nTime:  O(m+n);\n\nSpace:  O(1); ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"grapefruit-hellomonday":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-918986079","body":"两个栈实现队列原理就是来回倒腾，不过只要阶段性倒腾一次，后面出队就可以直接从out栈里出栈就可以了，这样完成整个流程最多把所有in栈内容倒到out栈一次，就是均摊复杂度O(1)\r\n```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stackIn = []\r\n    this.stackOut = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stackIn.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(!this.stackOut.length){\r\n        this.in2out()\r\n    }\r\n    return this.stackOut.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(!this.stackOut.length){\r\n        return this.stackIn[0]\r\n    }\r\n    return this.stackOut[this.stackOut.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    if(!this.stackIn.length && !this.stackOut.length){\r\n        return true\r\n    }\r\n    return false\r\n};\r\n\r\nMyQueue.prototype.in2out = function() {\r\n    while(this.stackIn.length){\r\n        this.stackOut.push(this.stackIn.pop())\r\n    }\r\n}\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920958110","body":"先算链表长度n，k对n取模，那么链表尾结点连到头结点，倒数第k+1个（正数第n-k个）的next断开，返回倒数第k（整数第n-k+1）个。\n```js\nvar rotateRight = function(head, k) {\n    if(head === null || k === 0){\n        return head\n    }\n    let len = 0\n    let p = head\n    while(p){\n        len++\n        p = p.next\n    }\n    k = k % len\n    if(k === 0){\n        return head\n    }\n    p = head\n    let p2 = head\n    while(k){\n        p2 = p2.next\n        k--\n    }\n    while(p2.next){\n        p = p.next\n        p2 = p2.next\n    }\n    let cur = p.next\n    p2.next = head\n    p.next = null\n    return cur\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921622394","body":"最后一步要额外考虑（null），所以直接把最后一步拆出来，不用在while里额外兼容\n```js\nvar swapPairs = function(head) {\n    if(!head || !head.next){\n        return head\n    }\n    let dummy = new ListNode()\n    dummy.next = head\n    let cur = head\n    let pre = dummy\n    let tail = head.next\n    while( pre.next && cur.next && tail.next){\n        cur.next = tail.next\n        tail.next = cur\n        pre.next = tail\n        pre = cur\n        cur = cur.next\n        tail = cur.next\n    }\n    if(cur && tail){\n        cur.next = null\n        tail.next = cur\n        pre.next = tail\n    }\n    return dummy.next\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pandaCure":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919123230","body":"## 思路\n队列是先进先出，栈是先进后出，所以用双栈来实现先进先出\n## 代码\n```typescript\nclass MyQueue {\n    #inStack\n    #outStack\n    #firstValue\n    constructor() {\n        this.#inStack = []\n        this.#outStack = []\n    }\n\n    push(x: number): void {\n        if (this.#inStack.length === 0) this.#firstValue = x\n        this.#inStack.push(x);\n    }\n\n    pop(): number {\n        if (this.#outStack.length === 0) {\n            while(this.#inStack.length > 0) {\n                this.#outStack.push(this.#inStack.pop())\n            }  \n        }\n        return this.#outStack.pop()\n        \n    }\n\n    peek(): number {\n        if (this.#outStack.length !== 0) {\n            return this.#outStack[this.#outStack.length - 1]\n        } else {\n            return this.#firstValue\n        }\n    }\n\n    empty(): boolean {\n        return !this.#inStack.length && !this.#outStack.length\n    }\n}\n```\n## 时间复杂度\n时间复杂度：O(1)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919134581","body":"### 思路\n栈先进先出\n### 代码\n```js\nvar MyQueue = function() {\n    this.data = []\n    this.temp = []\n};\n\nMyQueue.prototype.push = function(x) {\n    this.data.push(x)\n};\n\nMyQueue.prototype.pop = function() {\n    if(!this.temp.length){\n        while(this.data.length){\n             this.temp.push(this.data.pop())\n        }\n       \n    } \n    return this.temp.pop()\n};\n\nMyQueue.prototype.peek = function() {\n   if(!this.temp.length){\n        while(this.data.length){\n             this.temp.push(this.data.pop())\n        }\n    } \n    return this.temp[this.temp.length-1]\n};\n\nMyQueue.prototype.empty = function() {\n   return !this.data.length && !this.temp.length\n};\n```\n### 复杂度\n时间复杂度：O(1)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920059587","body":"#### 思路\n滑动窗口\n#### 代码\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  let sorted = [...arr]\n  sorted.sort((a, b) => a - b)\n  let count = 0,\n  sum1 = 0,\n  sum2 = 0\n  for(let i = 0; i < arr.length; i++) {\n      sum1 += arr[i]\n      sum2 += sorted[i]\n      if(sum1 === sum2) {\n          count++\n      }\n  }\n  return count\n};\n```\n#### 复杂度分析\n时间复杂度：O(NlogN)O(NlogN)，N 为数组长度，数组排序时间认为是 NlogNNlogN，滑动窗口遍历数组时间为 NN。\n空间复杂度：O(N)O(N)，N 为数组长度。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"panda-qin":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919147323","body":"Idea:\r\nuse a stack temp to temporarily hold the original queue in reverse order, push the new element into queue and put back the temp stack.\r\nSpace Complexity: O(n)\r\nTime Complexity:\r\npush:O(n)\r\npeek, pop, empty:O(1)\r\nJAVA:\r\nclass MyQueue {\r\nStack queue;\r\n\r\n/** Initialize your data structure here. */\r\npublic MyQueue() {\r\n    queue=new Stack<>();\r\n}\r\n\r\n/** Push element x to the back of queue. */\r\npublic void push(int x) {\r\n    Stack<Integer> temp = new Stack<>();\r\n    while(!queue.isEmpty())\r\n        temp.push(queue.pop());\r\n    queue.push(x);\r\n    while(!temp.isEmpty())\r\n        queue.push(temp.pop());\r\n}\r\n\r\n/** Removes the element from in front of queue and returns that element. */\r\npublic int pop() { \r\n    return queue.pop();\r\n    \r\n}\r\n\r\n/** Get the front element. */\r\npublic int peek() {\r\n \r\n    return queue.peek();\r\n    \r\n}\r\n\r\n/** Returns whether the queue is empty. */\r\npublic boolean empty() {\r\n    return queue.isEmpty();\r\n    \r\n}\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919668194","body":"idea: a chunk of the arr after sorting should have the same order with the same section in the completed sorted arr. scan arr from arr[0] to find such chunk, after such a chunk is found, continue to check the next possible range after the chunk\ntime complexity: O(n^2logn)\nspace complexiting: O(n^2)\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        //copy arr\n        int[] sort =new int[arr.length];\n        for(int i=0;i<arr.length;i++) {\n            sort[i]=arr[i];\n        }\n        Arrays.sort(sort);\n        int count=0, start=0, end=0;\n        while(end<arr.length) {\n            if(count_compare(arr,sort,start,end)){\n                count++;\n                start=end+1;\n            }\n            end++;\n        }\n        return count;\n    }\n    private boolean count_compare(int[] arr, int[] sort, int start, int end) {\n        int[] copyarr= new int[end-start+1];\n        int j=start;\n        for(int i=0;i<copyarr.length;i++) {\n            copyarr[i]=arr[j++];\n        }\n        Arrays.sort(copyarr);\n        for(int i=0;i<copyarr.length;i++) {\n            if(copyarr[i]!=sort[start++])\n                return false;\n        }\n        return true;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920373105","body":"idea: recursion. rotate the linkedlist by k-1 times plus one more time.\nTime: O(n^2)\nSpace: O(n)\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    int size=0;\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head==null)\n            return head;\n        if(size==0) {\n            ListNode curr=head;\n            while(curr!=null) {\n                curr=curr.next;\n                size++;}\n        }      \n        k=k%size;\n        if(k==0)\n            return head;\n        if(k==1) {\n            ListNode fast=head;\n            ListNode slow=head;\n            while(fast.next!=null) {\n                slow=fast;\n                fast=fast.next;\n            }\n            slow.next=null;\n            fast.next=head;\n            return fast;\n        }\n        ListNode temp=rotateRight(head,k-1);\n        return rotateRight(temp,1);\n            \n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921377756","body":"idea: recursion. swap the first two nodes. after swaping, link them to the next two swapped nodes by recursion.\nTime: O(n)\nSpace:O(1)\n\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head==null || head.next == null)\n            return head;\n        ListNode curr=head;     \n        ListNode temp=curr;\n        curr=curr.next;\n        ListNode next=curr.next;\n        curr.next=temp;\n        temp.next=swapPairs(next);\n        \n        return curr;\n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922078272","body":"idea: divide and conquer implemented by recursion. find the mid point of the list, which is the root of the tree. recursion on the right side. use a prev pointer to point to the node before mid point, make prev.next=null to make a new list of left side, then recursion on the left side. \nTime: O(nlogn)\nSpace: O(n)\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head==null)\n            return null;\n        if(head.next==null) {\n            TreeNode root = new TreeNode(head.val);\n            return root;\n        }\n       //find the mid of list\n        ListNode fast=head, slow=head,prev=head;\n        while(fast!= null && fast.next!=null) {\n            fast=fast.next.next;\n            prev=slow;\n            slow=slow.next;\n        }\n        prev.next=null;\n        TreeNode root = new TreeNode(slow.val);\n        root.left=sortedListToBST(head);\n        root.right=sortedListToBST(slow.next);\n        return root;\n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922395194","body":"idea: use a hashtable to store listnode in A. iterate through B to find the one that exist in A.\r\nTime: O(m+n)\r\nSpace: O(n)\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null)\r\n            return null;\r\n        HashSet<ListNode> listA = new HashSet<>();\r\n        ListNode curr=headA;\r\n        while(curr!=null) {\r\n            listA.add(curr);\r\n            curr=curr.next;\r\n        }\r\n        curr=headB;\r\n        while(curr!= null) {\r\n            if(listA.contains(curr)) {\r\n                return curr;\r\n            }\r\n            curr=curr.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"WxqKb":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919191926","body":"## 思路\r\n栈遵循先进后出，队列遵循先进先出；利用栈实现队列，需要反转其中一个栈【原栈】，赋值给另外一个栈【反转栈】，从而实现先进先出。因此pop和peek方法需要循环进行反转，同时要注意当反转栈不为空时，原栈的值需要插在反转栈的栈底。（即反转栈不为空时，无需插入原栈）\r\n\r\n## 关键点\r\n反转栈不为空时，不再插入原栈\r\n## 实现(python)\r\n\r\n```JavaScript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.list = []\r\n    this.resList = [] \r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    console.log(x)\r\n    this.list.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(this.resList.length==0){\r\n        while (this.list.length) {\r\n            this.resList.push(this.list.pop());\r\n        }\r\n    }\r\n    console.log(this.resList)\r\n    return this.resList.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(this.resList.length==0){\r\n        while (this.list.length) {\r\n            this.resList.push(this.list.pop());\r\n        }\r\n    }\r\n    return this.resList[this.resList.length -1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.list.length === 0 && this.resList.length === 0;\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920941598","body":">>思路\r\n本质上是对末尾的k位数在前面插入\r\n\r\n>>复杂度分析\r\n时间复杂度 O(n)，空间复杂度 O(1)\r\n\r\n```javaScript\r\nvar rotateRight = function(head, k) {\r\n    if (k === 0 || !head || !head.next) {\r\n        return head;\r\n    }\r\n    let len = 1\r\n    let h = head\r\n    while(h.next){\r\n        len++\r\n        h = h.next\r\n    }\r\n    // 闭环\r\n    h.next = head \r\n\r\n    let count = len - k%len\r\n    while(count){\r\n        h = h.next\r\n        count--\r\n    }\r\n\r\n    var res = h.next\r\n    h.next = null // 断开闭环\r\n    return res\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihanchenyuhua":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919212347","body":"class MyQueue {\nprivate:\n    stack<int> inStack, outStack;\n\n    void in2out() {\n        while (!inStack.empty()) {\n            outStack.push(inStack.top());\n            inStack.pop();\n        }\n    }\n\npublic:\n    MyQueue() {}\n\n    void push(int x) {\n        inStack.push(x);\n    }\n\n    int pop() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        int x = outStack.top();\n        outStack.pop();\n        return x;\n    }\n\n    int peek() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        return outStack.top();\n    }\n\n    bool empty() {\n        return inStack.empty() && outStack.empty();\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919713345","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>maxStk;\n        maxStk.push(arr[0]);\n        for(int i=1;i<arr.size();i++){\n            if(arr[i]<maxStk.top()){\n                int maxNum=maxStk.top();\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\n                maxStk.push(maxNum);\n            }\n            else maxStk.push(arr[i]);\n        }\n        return maxStk.size();\n    }\n};\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921903336","body":"class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922489193","body":"思路：链表篇有说：\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (headA == nullptr || headB == nullptr) {\n            return nullptr;\n        }\n        ListNode *pA = headA, *pB = headB;\n        while (pA != pB) {\n            pA = pA == nullptr ? headB : pA->next;\n            pB = pB == nullptr ? headA : pB->next;\n        }\n        return pA;\n    }\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919232161","body":"思路\n\n- 使用两个栈s1和s2\n- s1实现push功能\n- s2实现pop功能\n\n代码\n\n实现语言：python3\n\n    class MyQueue:\n        def __init__(self):\n            \"\"\"\n            Initialize your data structure here.\n    \n            \"\"\"\n            self.stack1 = []\n            self.stack2 = []\n            \n    \n        def push(self, x: int) -> None:\n            \"\"\"\n            Push element x to the back of queue.\n            \"\"\"\n            if x: self.stack1.append(x)        \n    \n        def pop(self) -> int:\n            \"\"\"\n            Removes the element from in front of queue and returns that element.\n            \"\"\"\n            if not self.stack2:\n                while self.stack1:\n                    self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n            \n    \n        def peek(self) -> int:\n            \"\"\"\n            Get the front element.\n            \"\"\"\n            if not self.stack2:\n                while self.stack1:\n                    self.stack2.append(self.stack1.pop())\n            return self.stack2[-1]        \n    \n        def empty(self) -> bool:\n            \"\"\"\n            Returns whether the queue is empty.\n            \"\"\"\n            return not self.stack1 and not self.stack2        \n    \n\n复杂度分析\n\n- 时间复杂度O(1)\n\n- 空间复杂度O(N)\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922313098","body":"# 思路\n\n用双指针寻找中位节点。后续构造树的部分还没有全明白\n\n# python\n\n​def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Serena9":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919246807","body":"### 代码\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []\n        self.help_stack = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        while self.stack:\n            self.help_stack.append(self.stack.pop())\n        self.help_stack.append(x)\n        while self.help_stack:\n            self.stack.append(self.help_stack.pop())\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        return self.stack.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not bool(self.stack)\n\n### 复杂度\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920084262","body":"### 代码\nclass Solution:\n\n    def maxChunksToSorted(self, A: [int]) -> int:\n        stack = []\n        for a in A:\n            # 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\n            # 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\n            if stack and stack[-1] > a:\n                # 我们需要将融合后的区块的最大值重新放回栈\n                # 而 stack 是递增的，因此 stack[-1] 是最大的\n                cur = stack[-1]\n                # 维持栈的单调递增\n                while stack and stack[-1] > a: stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        # 栈存的是块信息，因此栈的大小就是块的数量\n        return len(stack)\n\n### 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920948615","body":"### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # 双指针\n        if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n```\n### 复杂度\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921864503","body":"### 代码\n```python\nif not head or not head.next: return head\n    ans = ListNode()\n    ans.next = head.next\n    pre = ans\n    while head and head.next:\n        next = head.next\n        n_next = next.next\n\n        next.next = head\n        pre.next = next\n        head.next = n_next\n        # 更新指针\n        pre = head\n        head = n_next\n    return ans.next\n```\n### 复杂度\n时间复杂度：O（N）\n\n空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922328518","body":"### 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n### 复杂度\n时间复杂度：O(nlogn)\n\n空间复杂度：O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"WeiWri-CC":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919255769","body":"#思路\r\n#Python代码\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.instk=[]\r\n        self.outstk=[]\r\n        \r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.instk.append(x)\r\n        \r\n       \r\n  \r\n    \r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if len(self.outstk)==0:\r\n            while len(self.instk)>0:\r\n                self.outstk.append(self.instk.pop())\r\n        \r\n        return self.outstk.pop()\r\n        \r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if len(self.outstk)==0:\r\n            while len(self.instk)>0:\r\n                self.outstk.append(self.instk.pop())\r\n        \r\n        return self.outstk[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.instk)==0 and len(self.outstk)==0\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921019686","body":"# 思路\r\n# Python\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        if (add := n - k % n) == n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        while add:\r\n            cur = cur.next\r\n            add -= 1\r\n        \r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921885358","body":"## 思路\r\n## python\r\n```python3\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if head==None or head.next==None:\r\n            return head\r\n        a=head\r\n        b=head.next\r\n        c=self.swapPairs(head.next.next)\r\n        b.next=a\r\n        a.next=c\r\n        return b\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangxiaohan05":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919262230","body":"### 解题思路\r\n一个负责入，一个负责出。双栈。\r\n### 代码实现\r\n\r\n> \r\n\r\n> class MyQueue {\r\n\r\n    constructor() {\r\n        this.inStack = [];\r\n        this.outStack = [];\r\n    }\r\n    push(x) {\r\n        this.inStack.push(x)\r\n    }\r\n\r\n    pop() {\r\n        this.in2out()\r\n        return this.outStack.pop()\r\n    }\r\n\r\n    peek() {\r\n        this.in2out()\r\n        return this.outStack[this.outStack.length - 1]\r\n    }\r\n\r\n    empty() {\r\n        return !this.inStack.length && !this.outStack.length\r\n    }\r\n    in2out() {\r\n        if (!this.outStack.length) {\r\n            while (this.inStack.length) {\r\n                this.outStack.push(this.inStack.pop())\r\n            }\r\n        }\r\n    }\r\n}\r\n### 复杂度分析\r\npush: O(1)\r\npeek: O(n)\r\npop: O(n)\r\nsize: O(1)\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921861613","body":"/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    if(head === 0 || head.next === null) return\r\n    var nextHead = head.next.next;\r\n    var newHead = head.next;\r\n    head.next = swapPairs(nextHead)\r\n    var preHead = head;\r\n    head = newHead;\r\n    head.next = preHead;\r\n    return head\r\n\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ru8dgj0001":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919264597","body":"class MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.data = []\n        self.helper = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.data.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if len(self.helper) == 0:\n            self.d2h()\n        return self.helper.pop()\n\n    def d2h(self):\n        while self.data:\n            self.helper.append(self.data.pop())\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if len(self.helper) == 0:\n            self.d2h()\n        return self.helper[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.data) == 0 and len(self.helper) == 0","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taoyr722":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919278843","body":"## 232. 用栈实现队列\r\n### 思路\r\n两个栈，「输入栈」会把输入顺序颠倒；如果把「输入栈」的元素逐个弹出放到「输出栈」，再从「输出栈」弹出元素的时候，则可以实现先进先出。\r\n\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1=[]\r\n        self.stack2=[]\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.stack1  and not self.stack2\r\n```\r\n### 复杂度分析\r\n时间复杂度O（1）\r\n空间复杂度O（n）\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920129423","body":"## 768. 最多能完成排序的块 II\n### 思路\n维护一个单调递增的栈，前一个块的最大值，小于后一个块的最小值\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            # 递增栈\n            if not stack or stack[-1] <= num:\n                stack.append(num)\n            else:\n                cur_max = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(cur_max)\n        return len(stack)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"C2tr":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/16#issuecomment-919288067","body":"#思路\n使用两个栈实现先进先出\n#代码\nclass MyQueue:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = list()\n        self.stack2 = list()\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        # self.stack1用于接受元素\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        # self.stack2用于弹出元素，如果self.stack2为[],则将self.stack1中元素全部弹出给self.stack2\n        if self.stack2 == []:\n            while self.stack1:\n                tmp = self.stack1.pop()\n                self.stack2.append(tmp)\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.stack2 == []:\n            while self.stack1:\n                tmp = self.stack1.pop()\n                self.stack2.append(tmp)\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return self.stack1 == [] and self.stack2 == []\n(参考大佬carlsun-2答案)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920033951","body":"看的官方题解,核心是将一个减序列压缩合并成最该序列的最大的值\n\nclass Solution:\n    def maxChunksToSorted(self, A: [int]) -> int:\n        stack = []\n        for a in A:\n            # 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\n            # 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\n            if stack and stack[-1] > a:\n                # 我们需要将融合后的区块的最大值重新放回栈\n                # 而 stack 是递增的，因此 stack[-1] 是最大的\n                cur = stack[-1]\n                # 维持栈的单调递增\n                while stack and stack[-1] > a: stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        # 栈存的是块信息，因此栈的大小就是块的数量\n        return len(stack)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920987312","body":"思路:\n利用快慢指针,偏移K位\n\n代码:\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # 双指针\n        if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n\n(根据官方题解学习)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921900125","body":"思路：\n关注最小子结构，转换后的尾结点，头节点的处理\n\npython3代码：\n\nif not head or not head.next: return head\n    ans = ListNode()\n    ans.next = head.next\n    pre = ans\n    while head and head.next:\n        next = head.next\n        n_next = next.next\n\n        next.next = head\n        pre.next = next\n        head.next = n_next\n        \n        pre = head\n        head = n_next\n    return ans.next","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922472705","body":"思路:\n双指针,ab两指针分别对应AB两链表头结点,以同样的速度后移动,若能相遇说明存在重合\n代码:\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raoshuang":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919414436","body":"思路：\n对于一个块来说，其排序后是有序数组，意味着每一个块都要满足规则：\n块的最小元素应该要>=前一块的最大元素；\n块的最大元素应该要<=后一块的最小元素；\n分析规则，只需要创建两个数组premax,sumin分别记录当前位置往前所有值的最大值和当前位置往后所有值的最小值。\n对于每个位置i，只要当前位置的premax[i]小于等于sumin[i+1]，就证明当前位置往前所有值都小于等于往后的所有值，可以划分出一块。\n\n代码：\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> premax(n),sumin(n);\n        //前缀最大值\n        for(int i=0;i<n;++i){\n            if(i==0){\n                premax[i]=arr[i];\n            }\n            else{\n                premax[i]=max(premax[i-1],arr[i]);\n            }\n        }\n        //后缀最小值 \n        for(int i = n-1;i>=0;--i){\n            if(i==n-1){\n                sumin[i] = arr[i];\n            }\n            else{\n                sumin[i] = min(sumin[i+1],arr[i]);\n            }\n        }\n        int ans = 1;\n        //如果当前位置的前缀最大值小于等于下一个位置的后缀最小，说明当前位置小于后面所有位置，可分一块\n        for(int i=0;i<n-1;i++){\n            if(premax[i] <= sumin[i+1]){\n                ans++;\n            }\n        }\n        return ans;\n\n    }\n};\n\n复杂度\n时间复杂度O(n)；\n空间复杂度O(n)；\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922496010","body":"思路：\n双指针\n\n代码：\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (headA == nullptr || headB == nullptr) {\n            return nullptr;\n        }\n        ListNode *pA = headA, *pB = headB;\n        while (pA != pB) {\n            pA = pA == nullptr ? headB : pA->next;\n            pB = pB == nullptr ? headA : pB->next;\n        }\n        return pA;\n    }\n};\n\n复杂度：\n时间复杂度O(m+n)\n空间复杂度O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/26#issuecomment-922510503","body":"思路：\n快慢指针+数学公式推导\n代码：\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(head == nullptr || head->next == nullptr){\n            return nullptr;\n        }\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while(fast != nullptr && fast->next != nullptr){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow == fast){\n                ListNode *index1 = head;\n                ListNode *index2 = slow;\n                while(index1 != index2){\n                    index1 = index1->next;\n                    index2 = index2->next;\n                }\n                return index2;\n            }\n        }\n    return nullptr;    \n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ninghuangaa":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919441152","body":"```java\r\n public static int maxChunksToSorted(int[] arr) {\r\n            int n = arr.length, res = 0;\r\n            int[] sortArr = Arrays.copyOf(arr, n);\r\n            Arrays.sort(sortArr);\r\n            int netSum = 0;\r\n            for (int i = 0; i < n; ++i) {\r\n                netSum += (arr[i] - sortArr[i]);\r\n                if (netSum == 0)\r\n                    res++;\r\n            }\r\n            return res;\r\n        }\r\n```\r\nTime (N* LogN)\r\nSpace O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"blanktime":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919652000","body":"贪心\n=============================\n思路：对于某个位置，左边最大值不大于右边最小值，则可以分段\n--------------------------------------------------\nC++\n--------------------------------------------------\n```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int N = arr.size();\n        vector<int> lmax(N, INT_MIN);\n        vector<int> rmin(N, INT_MAX);\n        lmax[0] = arr[0];\n        rmin[N - 1] = arr[N - 1];\n        for (int i = 1; i < N; ++i) {\n            lmax[i] = max(lmax[i - 1], arr[i]);\n            rmin[N - 1 - i] = min(rmin[N - i], arr[N - 1 - i]);\n        }\n        int res = 1;\n        for (int i = 0; i < N - 1; ++i) {\n            res += lmax[i] <= rmin[i + 1];\n        }\n        return res;\n    }\n};\n```\n> 复杂度\n> 1. 时间复杂度：O(n) \n> 2. 空间复杂度：O(n) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iceburgs":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919725450","body":"思路\n此题不会做，参考的答案。。。\n\n代码\nclass Solution:\n    def maxChunksToSorted(self, arr) -> int:\n        tempStack = []\n        for currentNumber in arr:\n            if tempStack == []:\n                tempStack.append(currentNumber)\n            else:\n                tempStackTail = tempStack[-1]\n                if currentNumber >= tempStackTail:\n                    tempStack.append(currentNumber)\n                else:\n                    while tempStack and tempStack[-1] > currentNumber:\n                        tempStack.pop()\n                    tempStack.append(tempStackTail)\n        return len(tempStack)\n复杂度\n时间复杂度： O(n)\n空间复杂度： O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SunnyYuJF":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919737745","body":"### 思路 \n维持单调递增栈， 栈内元素是每个chunk的最大值, 返回栈的长度\n#### 代码 Python\n\n```Python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack=[]\n        for i in range(len(arr)):\n            if stack and arr[i]<stack[-1]:\n                peek = stack[-1]\n                while stack and arr[i]<stack[-1]:\n                    stack.pop()\n                stack.append(peek)\n            else:\n                stack.append(arr[i])\n        return len(stack)\n\n```\n\n#### 复杂度分析\n时间复杂度： O(N) </br>\n空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920312061","body":"### 思路 \n1. 求出链表长度， 旋转步数是k%n </br>\n2. 快慢指针指向head, 快指针先行k步，再同时移动快慢指针直到快指针到链表尾部，此时快慢指针间相差k步 </br>\n3. 慢指针所在为新的链表头部， 快指针连接head形成环，慢指针为尾结点\n#### 代码 Python\n\n```Python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head or not head.next or k==0:\n            return head\n\n        #find the length\n        length=0\n        cur = head\n        while cur:\n            length+=1\n            cur=cur.next\n        k=k%length\n        \n        if k==0:\n            return head\n        #fast and slow pointers\n        fast=head\n        slow=head\n        while k>0:\n            fast=fast.next\n            k-=1\n        \n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n        newHead = slow.next \n        fast.next=head  \n        slow.next=None  \n        \n        return newHead\n\n```\n\n#### 复杂度分析\n时间复杂度： O(N)  </br>\n空间复杂度： O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921316395","body":"### 思路 \n遍历链表， 每次交换两个node\n#### 代码 Python\n\n```Python\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        dummy=ListNode(-1)\n        dummy.next = head\n        pre = dummy\n        cur = head\n        while cur and cur.next:\n            next_node = cur.next \n            cur.next = next_node.next  \n            next_node.next = cur\n            pre.next = next_node\n            pre = cur\n            cur =cur.next\n            \n        return dummy.next\n\n```\n\n#### 复杂度分析\n时间复杂度： O(N) </br>\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922166353","body":"### 思路\n快慢指针求中点，递归构建子树\n#### 代码 Python\n\n```Python\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n        root =self.buildTree(head,None)\n        return root\n\n    def getMid(self, left, right):\n        fast, slow =left,left\n        while fast!=right and fast.next!=right:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n    def buildTree(self, left, right):\n        if left==right:\n            return None\n        mid = self.getMid(left, right)\n        node = TreeNode(mid.val)\n        node.left = self.buildTree(left, mid)\n        node.right = self.buildTree(mid.next, right)\n        return node\n\n```\n\n#### 复杂度分析\n时间复杂度： O(NlogN) 递归logN次 </br>\n空间复杂度： O（logN）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922412613","body":"### 思路 \na1->a2->*c1->c2->b1->b2->b3->*c1->c2  </br>\nb1->b2->b3->*c1->c2->a1->a2->*c1->c2\n#### 代码 Python\n\n```Python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not headA or not headB:\n            return None\n        cur1=headA\n        cur2=headB\n        while cur1!=cur2:\n            if cur1:\n                cur1=cur1.next\n            else:\n                cur1 = headB\n              \n            if cur2:\n                cur2=cur2.next\n            else:\n                cur2 = headA\n           \n        return cur1   \n\n```\n\n#### 复杂度分析\n时间复杂度： O(M+N) </br>\n空间复杂度： O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YuanWenLai":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919910728","body":"### 思路 \n \n1、利用求栈stack的最大值的思想，储存可分块的最大值\n2、当出现小于栈顶head的值时，保留当前栈顶head，抛出stack中大于arr[i]的值\n3、最终得出stack的长度的就可分块的最大值\n\n思想和 769. 最多能完成排序的块 的题目一致\n \n \n### 代码 \n \n \n``` js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted2 = function(arr) {\n    let stack = []\n    for(let i=0;i<arr.length;i++) {\n        let len = stack.length\n        // 栈为空 or 栈顶小于当前值\n        if(len == 0 || stack[len-1] <= arr[i]) {\n            stack.push(arr[i])\n        }else {\n            // 保存栈顶的最大值为头，抛出大于当前值的栈内元素\n            const head = stack.pop()\n            while(stack[stack.length-1] > arr[i]) {\n                stack.pop()\n            }\n            stack.push(head)\n        }\n    }\n    return stack.length\n};\n \n``` \n \n**复杂度分析** \n- 时间复杂度：O(N) \n- 空间复杂度：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920852197","body":"### 思路\n\n模仿快慢指针\n\n### 代码\n\n```js\nvar rotateRight = function (head, k) {\n  if (!head || !head.next || k === 0) return head;\n\n  let length = 1,\n    cur = head;\n\n  //找出长度\n  while (cur.next) {\n    cur = cur.next;\n    length++;\n  }\n\n  //找出真实的k的次数\n  k = k % length;\n  //如果次数是0，那么就等于没干，并且如果k = 0 后面会报错\n  if (k === 0) return head;\n\n  //快慢指针，让快的先走 k - 1步，这样慢的就刚好是newHead，快的刚好是现在的尾巴\n  let fast = head,\n    slow = head,\n    count = k - 1;\n\n  while (count > 0) {\n    fast = fast.next;\n    count--;\n  }\n\n  let pre = null;\n  while (fast.next) {\n    pre = slow;\n    fast = fast.next;\n    slow = slow.next;\n  }\n\n  pre.next = null;\n  fast.next = head;\n  return slow;\n};\n```\n\n**复杂度分析** - 时间复杂度：O(N) 。 - 空间复杂度：O（1）\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AutumnDeSea":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-919941873","body":"```js\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.Counter()\n        counted = []\n        for x in arr:\n            count[x] += 1\n            counted.append((x, count[x]))\n\n        ans, cur = 0, None\n        for X, Y in zip(counted, sorted(counted)):\n            cur = max(cur, X)\n            if cur == Y:\n                ans += 1\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"NaiveCoder1999":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920103341","body":"### 思路\n\n引用思路:\n\nhttps://leetcode.com/problems/max-chunks-to-make-sorted-ii/discuss/113465/JavaPython-Easy-and-Straight-Froward\n\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/\n\n方法为滑动窗口，等价于排序前的数减去排序后的数据累加，计算等于0的次数\n\n### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        int res = 0, sum1 = 0, sum2 = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum1 = sum1 + arr[i];\n            sum2 = sum2 + sorted[i];\n            if (sum1 == sum2)\n                res = res +1;\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(NlogN)，数组排序时间认为是 NlogN，滑动窗口遍历数组时间为 N\n- 空间复杂度: O(N)，N为数组长度\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920940695","body":"### 思路\n\n链表节点长度为 n， 右移 K 位与右移动 k % n 的效果一样, 先将链表连接成环，然后找到倒数k+1个节点进行断开，完成旋转\n\n\n\n### 代码\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    \n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0)\n            return head;   \n        int count = 1; // 链表总节点数\n        ListNode curr = head;\n        while (curr.next != null) {\n            curr = curr.next;\n            count++;\n        }\n        k = k % count;\n        if (k == 0) //当k为0时，不需要旋转， \n            return head;\n        // 不满足上述条件，进行旋转，先将首尾相连\n        curr.next = head;\n        // 找到倒数第k+1个节点\n        for (int i = 0; i < count - k; i++) {\n            curr = curr.next;\n        }\n        ListNode res = curr.next;\n        curr.next = null;\n        return res; \n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：节点最多只遍历两遍，时间复杂度为O(N)\n- 空间复杂度：未使用额外的空间，空间复杂度O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922390223","body":"### 思路\n\n设置双指针pA和pB，pA走过的路径为A链+B链\n\npB走过的路径为B链+A链\n\npA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，**如果相交，则会提前在相交点相遇**，如果没有相交点，则会在最后相遇。\n\npA, pB指针相遇的点为相交的起始节点，否则没有相交点\n\n## 代码\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null)\n            return null;\n        ListNode pA = headA, pB = headB;\n        while (pA != pB){\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：时间复杂度为O(m+n)，分别为headA和headB的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。\n- 空间复杂度：未使用额外的空间，空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xlzy520":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920109720","body":"不会做，看题解好好理解一下\n```js\n\n单调栈。\n\nvar maxChunksToSorted = function (arr) {\n    let stack = []\n    for (let i = 0; i < arr.length; i++) {\n        if (stack.length === 0 || stack[stack.length-1] <= arr[i]) {\n            stack.push(arr[i]);\n        } else {\n            const tmp = stack.pop();\n            while (stack[stack.length-1] > arr[i]) {\n                stack.pop();\n            }\n            stack.push(tmp);\n        }\n    }\n    return stack.length;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vaqua":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920144719","body":"### 思路\r\n单调递增栈存储\r\n遇到一个数a小于栈的最大值，只保留最大值，否则就相当于增加一个块\r\n[所有比a大的栈集合b]都要弹出,max值压入,即a--[栈集合b]--max变成一个新块\r\n\r\n\r\n```js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    var stack = []\r\n    for(let i=0;i<arr.length;i++) {\r\n        const a = arr[i]\r\n        if(stack.length > 0 && stack[stack.length-1] > a){\r\n            //遇到一个比[之前分好的块max]小的数a,那[比a大的块集合]都要合并成一个新块\r\n            const max = stack[stack.length-1]\r\n            while(stack && stack[stack.length-1] > a) {\r\n                stack.pop()\r\n            }   \r\n            stack.push(max)\r\n        } else {\r\n            stack.push(a)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度: O(N)\r\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921006129","body":"### 思路\n原链表的首尾相连,设置新头部和尾部,新头部是原链表倒数第k个节点,新尾部是原链表倒数第k+1个节点\n\nk 对链表长度 取模\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if(!head || !k) return head\n    let length = 0\n    let cur = head\n    let tail\n    while(cur) {\n        length++\n        if(!cur.next) tail = cur\n        cur = cur.next\n    }\n\n    const rotate = k % length\n    if(!rotate) return head\n    cur = head\n    //找倒数第k+1个节点\n    for(var i=1;i<length-rotate;i++) {\n        cur = cur.next\n    }\n    //首尾相连\n    tail.next = head\n    //新头部,倒数第k个节点--即倒数第k+1的next(cur.next)\n    const newHead = cur.next\n    //倒数第k+1个节点为尾,所以后面是null\n    cur.next = null\n    return newHead\n};\n```\n\n### 复杂度分析\n时间复杂度: O(N)\n\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921901302","body":"### 思路\n\n两两迭代  \n第一次迭代: dummy ［l1 l2 ］l3 l4  \n第一次迭代: dummy　 l1 l2 ［l1 l2］新  \n...n次\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    let dummy = new ListNode(-1, head)\n    let pre = dummy\n\n    while(pre.next && pre.next.next) {\n        //定义两相邻节点的指针\n        let l1 = pre.next, l2 = pre.next.next\n        //交换操作 4步\n        next = l2.next\n        l1.next = next\n        l2.next = l1\n        pre.next = l2\n        //pre跳到后面第二个节点(交换后的)\n        pre = l1\n    }\n    return dummy.next\n};\n```\n\n### 复杂度分析\n时间复杂度:O(N)  \n空间复杂度:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922493975","body":"### 思路 双指针\n注意点:\n1. 赋值符号右边是取值,左边是容器(不知道的js上卷)\n2. a 与 b比较 是否相等,是比较是否同一个节点,不是比较.value的值,区分数据结构-值的类型为-对象\"节点\",不是值\"num\"\n3. 一轮结束后取对面链表头部-需要headX 这个绝对定位,a/b在迭代中会变动\n\n```js\n\n\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    //要求链表必须 保持原始结构\n    //用指针指向\n    // a + c + b === b + c + a\n    var a = headA, b = headB\n    while(a !== b) {\n        a = (a === null)? headB : a.next;\n        b = (b === null)? headA : b.next;\n    }\n    return a\n};\n```\n\n### 复杂度分析\n时间复杂度：O(M+N) M N 分别是 LinkedList A 和 B 的长度  \n空间复杂度: 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sJingZ":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/21#issuecomment-920153420","body":"# 思路\r\n---\r\n单调栈\r\n\r\n# 代码\r\n---\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        stack = []\r\n        stack.append(-1)\r\n        ma = -1\r\n        for i in range(len(arr)):\r\n            if arr[i] >= stack[-1]:\r\n                stack.append(arr[i])\r\n            else:\r\n                while(arr[i] < stack[-1]):\r\n                    temp = stack.pop()\r\n                    if temp > ma: ma = temp\r\n                stack.append(ma)\r\n                ma = -1\r\n        return len(stack)-1\r\n```\r\n\r\n# 复杂度\r\n---\r\n时间：O(n)\r\n空间：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920241595","body":"# 思路\r\n---\r\n无论是什么方法，都得先判断链表的长度，减少不必要的链表旋转。确定好实际需要旋转次数后，有两种思路进行实际的旋转\r\n1. 暴力法\r\n每次都遍历到链表结尾，把结尾接到头\r\n2. 快慢指针\r\n快慢指针找到倒数第 k 个节点，然后进行操作\r\n\r\n# 代码\r\n---\r\n1. 暴力法\r\n```python\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        if head == None or head.next == None:\r\n            return head\r\n        \r\n        l = 1\r\n        current = head\r\n        while current.next:\r\n            current = current.next\r\n            l += 1\r\n        k = k%l\r\n\r\n        def rotate(h):\r\n            prev = h\r\n            cur = h.next\r\n            while cur.next:\r\n                prev = prev.next\r\n                cur = cur.next\r\n            cur.next = h\r\n            prev.next = None\r\n            return cur\r\n\r\n        while k > 0:\r\n            head = rotate(head)            \r\n            k -= 1\r\n        \r\n        return head\r\n```\r\n2. 快慢指针\r\n```python\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        if head == None or head.next == None:\r\n            return head\r\n        \r\n        l = 1\r\n        current = head\r\n        while current.next:\r\n            current = current.next\r\n            l += 1\r\n        k = k%l\r\n        if k == 0: return head\r\n\r\n        slow, fast = head, head\r\n        while k > 0:\r\n            fast = fast.next\r\n            k -= 1\r\n        \r\n        while fast.next:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        \r\n        fast.next = head\r\n        head = slow.next\r\n        slow.next = None\r\n        \r\n        return head\r\n```\r\n\r\n# 复杂度分析\r\n---\r\n1. 暴力法：\r\n时间：O(k·N)\r\n空间：O(1)\r\n2. 快慢指针\r\n时间：O(N)\r\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dahuang257":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920187269","body":"时间复杂度：O（n）\n语言：c++；\n代码实现:\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) \n    {\n        //先找链表末尾，闭合成环，并计算长度\n        if(!head)return head;\n        ListNode*cur=head;\n        int count=1;\n        while(cur->next)\n        {\n            count++;\n            cur=cur->next;\n        }\n        cur->next=head;\n        k=k%count;\n        //找倒数第k个结点，让其成为头结点，并断开原本顺序倒数k+1到倒数k结点的连接\n        cur=head;\n        int j=1;\n        while(j<count-k)\n        {\n            cur=cur->next;\n            j++;\n        }\n        ListNode*newhead=cur->next;\n        cur->next=NULL;\n        return newhead;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921896617","body":"语言：c++\n代码实现：\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) \n    {\n        //首先交换两个节点，肯定是要断开连接，所以最起码要用两个变量来保存交换的两个节点的前一个节点和后面的节点\n        //直接从第三个节点开始想象交换的过程，因为第一个节点前没有节点，所以没有普适性\n        //如果有前两个节点，先交换\n        if(!head||!head->next)return head;\n        ListNode*q=head->next->next;\n        //保存交换后的头结点\n        ListNode*newHead=head->next;\n        head->next->next=head;\n        head->next=q;\n        //两个变量\n        ListNode*pre=head,*cur;\n        //不想写注释了\n        while(pre->next!=NULL&&pre->next->next!=NULL)\n        {\n        cur=pre->next;\n        ListNode*p=cur->next->next;\n        pre->next=cur->next;\n        pre->next->next=cur;\n        cur->next=p;\n        pre=pre->next->next;\n        }\n        return newHead;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922307068","body":"语言：c++\n代码实现：\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) \n    {\n        ListNode*cur=head;\n        vector<int>res;\n        while(cur)\n        {\n            res.push_back(cur->val);\n            cur=cur->next;\n        }\n        return function(res);       \n    }\n    TreeNode*function(vector<int>v)\n    {\n        if(v.size()==0)return NULL;\n        // if(v.size()==1)\n        // {\n        //     TreeNode*root=new TreeNode(v[0]);\n        //     root->left=NULL,root->right=NULL;\n        //     return root;\n        // }\n        TreeNode*root=new TreeNode(v[v.size()/2]);\n        root->left=function(vector<int>(v.begin(),v.begin()+v.size()/2));//左闭右开\n        root->right=function(vector<int>(v.begin()+v.size()/2+1,v.end()));//左闭右开\n        return root;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922481863","body":"时间复杂度：O(n+m) 两个链表的长度和\n空间复杂度：O(n) 链表 A 的长度\n语言：c++\n代码实现：\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \n    {\n        unordered_set<ListNode*>hash;\n        ListNode*cur=headA;\n        while(cur)\n        {\n            hash.insert(cur);\n            cur=cur->next;\n        }\n        cur=headB;\n        while(cur)\n        {\n            if(hash.count(cur))return cur;\n            cur=cur->next;\n        }\n        return NULL;    \n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JLin-data":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920459995","body":"```Python   \r\n \r\ndef rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head:\r\n            return\r\n\r\n        nxt = head\r\n        lenth = 1\r\n\r\n        while head.next:\r\n            head = head.next\r\n            lenth += 1\r\n\r\n        head.next = nxt\r\n        k = k % lenth\r\n        cut = lenth - k - 1\r\n\r\n        for _ in range(cut):\r\n            nxt = nxt.next\r\n\r\n        ans, nxt.next = nxt.next, None\r\n\r\n        return ans\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuichen17":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920486058","body":"```\nvar rotateRight = function(head, k) {\n    var p = head;\n    var count = 0;\n    while (p !== null) {\n        count++;\n        p = p.next;\n    }\n    k = k % count;\n    var fast = head;\n    var slow = head;\n    for (var i = 0; i < k; i++) {\n        fast = fast.next;\n    }\n    if (fast === null) return head;\n    while (fast.next !== null) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    fast.next = head;\n    fast = slow.next;\n    slow.next = null;\n    return fast;\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922340929","body":"```javascript\nvar getIntersectionNode = function(headA, headB) {\n    let a = headA;\n    let b = headB;\n    while (a !== b) {\n        if (a === null) {\n            a = headB;\n        } else {\n            a = a.next;\n        }\n        if (b === null) {\n            b = headA;\n        } else {\n            b = b.next;\n        }    \n    }\n    return a;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Zz10044":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920490412","body":"### 思路\n------\n\n1. 计算链表长度\n2. 先成环，再拆环\n\n\n### 代码\n------\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        ListNode iter = head;\n        int len = 1;\n        \n        while(iter.next != null){\n            iter = iter.next;\n            len++;\n        }\n       \n        int add = len - k % len;\n        iter.next = head;\n        \n        if (add == len) {\n            return head;\n        }\n\n        while(add-- > 0){\n            iter = iter.next;\n        }\n        ListNode resHead = iter.next;\n        iter.next = null;\n        return resHead;\n\n    }\n    private int getLength(ListNode head){\n        int n = 1;\n        \n        while(head.next != null){\n            head = head.next;\n            n++;\n        }\n        return n;\n    }\n}\n\n```\n\n**复杂度分析**\n------\n— 时间复杂度：O(n) \n\n— 空间复杂度：O(1)\n \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921247354","body":"两两交换链表中的节点\n---\n\n### 思路\n\n1. 结果返回第二个节点\n2. 移动Prehead 到下一组\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode preHead = new ListNode(-1, head),res;\n        preHead.next = head;\n        res = head.next;\n        ListNode firstNode = head, secondNode, nextNode;\n        while(firstNode != null && firstNode.next != null){\n            secondNode = firstNode.next;\n            nextNode = secondNode.next;\n            firstNode.next = nextNode;\n            secondNode.next = firstNode;\n            preHead.next = secondNode;\n            preHead = firstNode;\n            firstNode = nextNode;\n        }\n        return res;\n        \n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922427421","body":"### 8. 160. Intersection of Two Linked Lists\n\n### 思路1\n---\n判断两个链表是否相交，可以使用哈希集合存储链表节点。\n\n首先遍历链表 \\textit{headA}headA，并将链表 \\textit{headA}headA 中的每个节点加入哈希集合中。然后遍历链表 \\textit{headB}headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：\n\n如果当前节点不在哈希集合中，则继续遍历下一个节点；\n\n如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 \\textit{headB}headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。\n\n如果链表 \\textit{headB}headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 \\text{null}null。\n\n\n### 代码\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<ListNode>();\n        ListNode temp = headA;\n        while (temp != null) {\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while (temp != null) {\n            if (visited.contains(temp)) {\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n + m)，\n- 空间复杂度：O(n)，\n\n### 思路2\n---\n\n为什么 a, b 指针相遇的点一定是相交的起始节点? 我们证明一下：\n\n将两条链表按相交的起始节点继续截断，链表 1 为: A + C，链表 2 为: B + C；\n\n当 a 指针将链表 1 遍历完后，重定位到链表 2 的头节点，然后继续遍历直至相交点，此时 a 指针遍历的距离为 A + C + B；\n\n同理 b 指针遍历的距离为 B + C + A；\n\n### 代码\n\n```java\npublic class Solution {\n   public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n       while(headA != headB){\n           if(headA != null){\n               headA = headA.next;\n           }else{\n               headA =headB;\n           }\n           \n           if(headB != null){\n               headB = headB.next;\n           }else{\n               headB =headA;\n           }\n       }\n        return headA;\n    }\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n + m)，\n- 空间复杂度：O(1)，\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsgouwan":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920522049","body":"``` javascript \r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if(!head || !head.next || !k) return head;\r\n    let len = 1, cur = head;\r\n    while(cur.next){\r\n        cur = cur.next;\r\n        len++;\r\n    }\r\n    let move = len - k % len;\r\n    cur.next = head;\r\n    while(move){\r\n        cur = cur.next;\r\n        move--;\r\n    }\r\n    let ans = cur.next;\r\n    cur.next = null;\r\n    return ans;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kkwu314":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920544715","body":"**思路**\r\n1. 计算链表总长，简化k，最终新head为第(n-n%k) 个节点\r\n2. 链表成环，从原链最后开始数new_k个，该节点的后一节点应为新链的head，从该节点断开\r\n\r\n**java代码**\r\n\r\n    class Solution {\r\n        public ListNode rotateRight(ListNode head, int k) {\r\n            if (k==0 || head==null || head.next==null){\r\n                return head;\r\n            }\r\n    \r\n            int n=1;\r\n            ListNode cur=head;\r\n            while(cur.next!=null){\r\n                cur=cur.next;\r\n                n++;\r\n            }\r\n    \r\n            int new_k=n-k%n;\r\n            if (new_k==n){\r\n                return head;\r\n            }\r\n            cur.next = head;\r\n            while(new_k-->0){\r\n                cur = cur.next;\r\n            }\r\n            ListNode new_head = cur.next;\r\n            cur.next = null;\r\n    \r\n            return new_head;\r\n   \r\n        }\r\n    }\r\n\r\n**复杂度**\r\n- Time Complexity: O(N)\r\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921772628","body":"## 思路\n节点两两交换，并记下之前在前面的节点 记为prev。当交换下一对节点时，将prev.next指向下一对中的后面的节点\n## 代码\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    class Solution:\n        def swapPairs(self, head: ListNode) -> ListNode:\n            if not (head and head.next):\n                return head\n            cur = head\n            new_head = cur.next\n            prev = None\n            while(cur and cur.next):\n                if (prev):\n                    prev.next = cur.next\n                tmp = cur.next\n                cur.next = cur.next.next\n                tmp.next = cur\n                prev = cur\n                cur = cur.next\n                \n            return new_head\n\n\n\n\t\t\t\n\n## 复杂度\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922281588","body":"## 思路\n1. 用快慢指针找到中位节点，每次fast向后走2个 同时slow向后走1个\n2. 中位节点为书的根节点，递归构造左右子树\n\n## 代码\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def sortedListToBST(self, head: ListNode) -> TreeNode:\n            def findMedian(left,right):\n                fast = slow = left\n                while fast != right and fast.next != right:\n                    fast = fast.next.next\n                    slow = slow.next\n                return slow\n    \n            def buildTree(left,right):\n                if left == right:\n                    return None\n                median = findMedian(left,right)\n                root = TreeNode(median.val)\n                root.left = buildTree(left,median)\n                root.right = buildTree(median.next,right)\n                return root\n    \n            return buildTree(head,None)\n\t\t\t\n## 复杂度分析\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922437196","body":"## 思路\r\n1. 确保headA和headB都不为null\r\n2. headA指针 pA, headB指针 pB。 当pA≠pB时，pA&pB都向后移一位\r\n3. 当pA或pB到达尾部(null)时，指向对方的head (pA指向headB, pB指向headA)。\r\n4. 如果headA和headB有重叠的话，pA pB肯定会同时指向同一个非空节点。 \r\n5. 如果headA和headB没有重合的话，pA pB会同时指向一个空节点null (m=n时 到达两链表的尾部，m≠n时 两指针都走了一遍m+n到达尾部)\r\n\r\n## 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA==null || headB==null) return null;\r\n        ListNode pA = headA;\r\n        ListNode pB = headB;\r\n        while (pA != pB){\r\n            pA = pA==null? headB:pA.next;\r\n            pB = pB==null? headA:pB.next;\r\n        }\r\n        return pA;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(M+N)，M,N为headA, headB链表长度\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carsonlin9996":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920572313","body":"1. 先统计链表的长度\n2. fast、slow pointer， 先让fast走出k步， 然后再fast 和 slow一步步走， fast走到最后， slow走到倒数第k + 1；\n3. 赋予slow.next/ fast.next 新指针\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        \n\n        ListNode fast = head;\n        int sum = 1;\n        \n        ListNode count = head;\n        \n        while (count.next != null) {\n            count = count.next;\n            sum++;\n        }\n        k = k % sum;\n        \n        while (fast.next != null && k > 0) {\n            fast = fast.next;\n            k--;\n        }\n        \n        ListNode slow = head;\n        \n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        \n        \n        fast.next = head;\n        ListNode newHead = slow.next;\n        slow.next = null;\n\n        return newHead;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921535185","body":"1. 建立dummy方便指向链表头\r\n2. 建立三个ptr互相把对应的next指向新的node\r\n--------------------------------------------------------\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        \r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        \r\n        ListNode dummy = new ListNode(-1, head);\r\n        \r\n        ListNode temp = dummy;\r\n        ListNode ptr1 = head;\r\n        ListNode ptr2 = head.next;\r\n        \r\n        while (ptr1 != null && ptr1.next != null) {\r\n            ptr1.next = ptr2.next;\r\n            ptr2.next = ptr1;\r\n            temp.next = ptr2;\r\n            \r\n            temp = ptr1;\r\n            \r\n            ptr1 = ptr1.next;\r\n            if (ptr1 != null) {\r\n                ptr2 = ptr1.next;\r\n            }\r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922143670","body":"1. 寻找中点， 将其建立一个node\r\n2. 把中点的前一个点断开， 递归第一步\r\n\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        \r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        \r\n        if (head.next == null) {\r\n            return new TreeNode(head.val);\r\n        }\r\n        \r\n        ListNode dis = null;\r\n        \r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        //finds mid point\r\n        while (fast != null && fast.next != null) {\r\n            dis = slow;\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        \r\n        dis.next = null;\r\n        \r\n        TreeNode root = new TreeNode(slow.val);\r\n        \r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(slow.next);\r\n        \r\n        return root;\r\n        \r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922390382","body":"1. 判断两个链表的长度， 先让长的链表走长度的区别\r\n2. 然后指针同时一步步遍历， 直到找到相同的点\r\n\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n       \r\n        int lenA = getLength(headA);\r\n        int lenB = getLength(headB);\r\n        \r\n        ListNode ptrA = headA;\r\n        ListNode ptrB = headB;\r\n        \r\n        int diffStep = Math.abs(lenA - lenB);\r\n        \r\n        if (lenA > lenB) {\r\n            while (diffStep > 0) {\r\n                ptrA = ptrA.next;\r\n                diffStep--;\r\n            }\r\n        } else {\r\n            while (diffStep > 0) {\r\n                ptrB = ptrB.next;\r\n                diffStep--;\r\n            }\r\n        }\r\n        \r\n        while (ptrA != ptrB) {\r\n            ptrA = ptrA.next;\r\n            ptrB = ptrB.next;\r\n        }\r\n        return ptrA;\r\n        \r\n        \r\n    }\r\n    \r\n    public int getLength(ListNode node) {\r\n        \r\n        if (node == null) {\r\n            return 0;\r\n        }\r\n        \r\n        int length = 1;\r\n        \r\n        while (node.next != null) {\r\n            node = node.next;\r\n            length++;\r\n        }\r\n        \r\n        return length;\r\n    } \r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Victoria011":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920593541","body":"思路\n\n计算长度找到 rotate 过后的第一个 node, 同时要有一个指针指向最后一个 node 方便连接 head。将 rotate 后第一个 node 与其前一个 node 的关联断开。\n\n代码\n```java\npublic class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        // get length\n        int len = 0;\n        ListNode curr = head;\n        if (head == null || k == 0) {\n        \treturn head;\n        }\n        while(curr.next != null) {\n            curr = curr.next;\n            len++;\n        }\n        if(curr != null){\n            len++;\n        }\n        if ( len == 1){\n            return head;\n        }\n        \n        ListNode tail = curr;\n        // keep tail\n        int idx = k % len;\n        if (idx == 0) return head;\n        // find idxth element\n        int i=0;\n        curr = head;\n        while(i< len-idx-1){\n            curr = curr.next;\n            i++;\n        }\n        ListNode tmp = curr.next;\n        curr.next = null;\n        tail.next = head;\n        return tmp;\n    } \n}\n```\n复杂度分析：\n- 时间复杂度: O(N), N为链表长度\n- 空间复杂度: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"niuyibo0619":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920674833","body":"```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        # 如果链表无节点或只有一个节点，返回head\n        if not head or not head.next:\n            return head\n        \n        n = 1   # 记录链表长度\n        p = head\n        while p.next:\n            p = p.next\n            n += 1\n\n        # k超过链表长度时相当于重置链表\n        rot = n - k % n   \n        if rot == n:\n            return head\n        \n        p.next = head  # 把链表尾部连上头\n        while rot:     # 找断开的点\n            p = p.next\n            rot -= 1\n        \n        res = p.next   # 新的起点\n        p.next = None  # 断开环\n        return res\n```\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chakochako":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920792897","body":"```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        \r\n        if not head:\r\n            return \r\n        p = head\r\n        i = 1 #记录链表长度\r\n        while p.next:\r\n            p = p.next\r\n            i += 1\r\n        k = k % i \r\n        p.next = head\r\n        for _ in range(i - k): \r\n            p = p.next\r\n        res = p.next \r\n        p.next = None \r\n        return res\r\n\r\n\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922262143","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922398332","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        d = dict()\n        while headA:\n            d[headA] = 1\n            headA = headA.next\n        while headB:\n            if d.get(headB):\n                return headB\n            else:\n                headB = headB.next\n        return None\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Jinjin680":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920874718","body":"### 思路\n\n- 边界条件：k%n == 0||head == null，返回head\n- 先遍历链表，得到链表长度l和尾指针tail；旋转链表k%n个位置后，新的头结点new_head是原来链表的第l-k+1个节点，新的尾结点为new_head的前一个节点prev；将tail指向原来的头节点head，将prev指向null\n\n### 代码\n\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head) return head;\n        int l = 1;\n        ListNode* tail = head;\n        //求链表长度\n        while(tail -> next != nullptr){\n            tail = tail->next;\n            l++;\n        }\n        k = k % l;\n        if(!k) return head;\n        ListNode* prev = head;\n        //相当于将结点从头指针移动l-k-1次到prev指针，prev后还剩下k个指针\n        while(--l > k) prev = prev -> next;\n        ListNode* new_head = prev -> next;\n        tail -> next = head;\n        prev -> next = nullptr;\n        return new_head;\n    }\n};\n```\n\n### 时间复杂度：O(n)\n\n### 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921469242","body":"### 思路\n\n- 三个指针，分别指向前后和当前节点，移动节点步长为2\n\n### 代码\n\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head||!head -> next) return head;\n        ListNode* std = new ListNode(0); //增加一个哨兵节点\n        std -> next = head;\n        ListNode* first = head;\n        ListNode* second = nullptr;\n        ListNode* new_head = first -> next;\n        while(first&&first -> next){\n            second = first -> next;\n            first -> next = second -> next;\n            second -> next = first;\n            std -> next = second;\n            std = first;\n            first = first -> next;\n        }\n        return new_head;\n    }\n};\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922450910","body":"### 思路\n\n- 先求两链表长度，比较大小，先遍历长度较长的链表，知道剩下未遍历节点数目与较短链表节点数目一致时，同步遍历两链表，比较当前两节点是否相等。\n\n### 代码\n\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if(!headA||!headB) return nullptr;\n        int s1 = 1, s2 = 1;\n        ListNode *node1 = headA;\n        ListNode *node2 = headB;\n        while(node1 -> next){\n            node1 = node1 -> next;\n            s1++;\n        }\n        while(node2 -> next){\n            node2 = node2 -> next;\n            s2++;\n        }\n        if(node1 != node2) return nullptr; //若两链表尾结点不等，说明两链表不相交\n        node1 = headA;//让两个指针从头开始遍历,把长一点的走到和短的一样长\n        node2 = headB;\n        if(s1 > s2){\n            while(s1 != s2){\n                node1 = node1 -> next;\n                s1--;\n            }\n        }else if(s1 < s2){\n            while(s1 != s2){\n                node2 = node2 -> next;\n                s2--;\n            }\n        }\n        while(node1 != node2){\n            node1 = node1 -> next;\n            node2 = node2 -> next;\n        }\n        return node1;\n    }\n};\n```\n\n### 复杂度分析\n\n- 时间复杂度O(max(m, n))\n- 空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920881394","body":"### **思路**\r\n求链表长度\r\n找断开节点，设为头节点\r\n旋转\r\n\r\n### **代码**\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null || k == 0) {\r\n        return head;\r\n    }\r\n\r\n    int len = 1;\r\n    ListNode tail = head;\r\n    for (tail.next != null; len++) {\r\n        tail = tail.next;\r\n    }\r\n\t\t\r\n    int i = len - (k % len);\r\n    if (i == len) {\r\n        return head;\r\n    }\r\n\r\n    ListNode iNode = head;\r\n    for (int j = 1; j < i; j++) {\r\n        iNode = iNode.next;\r\n    }\r\n\r\n    ListNode newHead = iNode.next;\r\n    iNode.next = null;\r\n    tail.next = head;\r\n    return newHead;\r\n\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n时间复杂度：O（N）\r\n空间复杂度：O（1）\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921808584","body":"### 思路\r\n\r\n递归\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\npublic ListNode swapPairs(ListNode head) {\r\nif(head == null || head.next == null){\r\nreturn head;\r\n}\r\nListNode next = head.next;\r\nhead.next = swapPairs(next.next);\r\nnext.next = head;\r\nreturn next;\r\n}\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922276490","body":"# 思路\n分治\n\n# 代码\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n## 复杂度\n时间复杂度：O(nlogn)\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922479014","body":"# 思路\n\n双指针\n\n# 代码\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n# 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ASUKAREISJ":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920920513","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sogatechnology":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920938514","body":"## 思路\n\n\n<p>因为是单向的移动的N个位置，所以移动一圈跟N圈本质上是一样的，根据移动的次数可以找到固定的规律，定义拆分点，将链表分成两部分，然后交换位置即为N次移动后的位置</p>\n\n\n## 复杂度分析\n\n\n<p>时间复杂度 O(n)，空间复杂度 O(1)</p>\n\n\n### **Java**\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return null;\n        if (head.next == null) return head;\n        // 链表长度\n        int count = 1;\n        ListNode node = head;\n        while (node.next != null) {\n            node = node.next;\n            count++;\n        }\n        // 相同方向，找到需要切开的index位置\n        int index = count - k % count;\n        ListNode pre = head;\n        while (index > 0) {\n            if (--index == 0) {\n                node.next = head;\n                ListNode tmp = pre.next;\n                pre.next = null;\n                return tmp;\n            }\n            pre = pre.next;\n        }\n        return null;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ariel-mu3":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920940423","body":"```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        tail = head\r\n        length = 1\r\n        while tail.next:\r\n            length += 1\r\n            tail = tail.next\r\n        tail.next = head\r\n\r\n        k = k % length\r\n        for _ in range(length - k):\r\n            tail = tail.next\r\n\r\n        head = tail.next\r\n        tail.next = None\r\n        return head\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921847856","body":"```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = ListNode(-1,head)\n        prev = dummy\n        while head and head.next:\n            first = head\n            second = head.next\n            third = second.next\n            prev.next = second\n            second.next = first\n            first.next = third\n            prev = first \n            head = third \n        return dummy.next\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sugar666":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920953341","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null) {\n            return head;\n        }\n\n        ListNode current = head;\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n        ListNode prev = dummyHead;\n\n        int count = 0;\n        while(current != null) {\n            count++;\n            current = current.next;\n            prev = prev.next;\n        }\n        prev.next = head;\n        \n        k = k % count;\n        count = count - k;\n        \n        current = head;\n        while(count > 1) {\n            current = current.next;\n            count--;\n        }\n        ListNode res = current.next;\n\n        current.next = null;\n        return res;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921836611","body":"```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n\n        ListNode prev = dummyHead;\n        ListNode current = head;\n\n        while(current != null && current.next != null) {\n            ListNode next = current.next;\n            ListNode temp = next.next;\n\n            prev.next = next;\n            next.next = current;\n            current.next = temp;\n\n            prev = current;\n            current = temp;\n\n        }\n        return dummyHead.next;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liwangping":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-920995136","body":"var rotateRight = function(head, k) {\n    var len = 0  \n    var l = head  \n    var prev = null  \n    var last = null \n    while(l){\n        len++\n        l=l.next\n    }\n    if(len==0 || len==1 || k%len==0) return head  \n    l = head\n    if(k>len){\n        k = k%len\n    }\n    var Nums = len - k\n    while(Nums>0){\n        if(Nums==1){\n            prev = l\n        }\n        l = l.next\n        Nums--\n    }\n    prev.next = null  \n    last = l  \n    while(l!==null){  \n        if(l.next==null){ \n            l.next = head \n            break\n        }\n        l = l.next\n    }\n    return last\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SmallCodeBo":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921006704","body":"## 代码\n\n```javascript\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let now = head;\n    while (now.next) {\n        now = now.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n    \n    now.next = head;\n    while (add) {\n        now = now.next;\n        add--;\n    }\n    \n    const ret = now.next;\n    now.next = null;\n    return ret;\n\n};\n\n\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cecilialmw":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921008936","body":"### 思路\n\n将链表首尾相连并计算得出新链表head的位置，断开\n\n### 代码\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        // edge cases\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n\n        // count the length of the list\n        int n = 0;\n        ListNode counter = head;\n        n += 1;\n        while (counter.next != null) {\n            counter = counter.next;\n            n++;\n        }\n        \n\n        // calculate the number of nodes left after rotation\n        int rotation = n - k % n;\n\n        // the situation where the list remains the same\n        if (rotation == n) {\n            return head;\n        }\n\n        // connect the tail of the list to the head\n        counter.next = head;\n\n        // start to rotate\n        while (rotation > 0) {\n            counter = counter.next;\n            rotation--;\n        }\n\n        // reset the head\n        ListNode newHead = counter.next;\n\n        // disconnect the list\n        counter.next = null;\n\n        return newHead;\n\n    }\n}\n```\n### 复杂度分析\n\nTime complexity: O(2n) --> O(n)  [worst case: going through the whole list twice]\n\nSpace complexity: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"KrabbeJing":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/22#issuecomment-921029555","body":"### 代码\n```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret\n```\n**复杂度分析\n- 时间复杂度: O(n)\n- 空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ph2200":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921110780","body":"思路\n\n增加了一个最大值计数数组。这样，只有当原数组在对应位置有指定数量的最大值时，才能分块（虽然过了，但是有点不知道怎么证明，有点类似贪心？）\n\nPython3代码\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        c=0\n        #排序数列\n        x=arr[:]\n        x.sort()\n        #排序数列计数\n        count=[0]*len(arr)\n        count[0]=1\n        #原数列最大值\n        mx=[0]*len(arr)\n        mx[0]=arr[0]\n        #原数列最大值计数\n        mc=[0]*len(arr)\n        mc[0]=1\n  \n        \n        for i in range(1,len(arr)):\n            mx[i]=max(mx[i-1],arr[i])\n            if arr[i]==mx[i-1]:\n                mc[i]=mc[i-1]+1\n            else:\n                if arr[i]>mx[i-1]:\n                    mc[i]=1\n                else:\n                    mc[i]=mc[i-1]\n            if x[i]==x[i-1]:\n                count[i]=count[i-1]+1\n            else:\n                count[i]=1\n       \n      \n        for i in range(len(arr)):\n            \n            if mx[i]==x[i] and mc[i]==count[i] :\n                c+=1\n        return c\n复杂度\n\n时间复杂度：O(nlogn) ，排序数列复杂度\n\n空间复杂度：O(n)，新建的数组\n\nn为arr长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yunomin":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921225113","body":"#### Topic\n\n- linked list\n\n\n#### Idea\n\n- Using 3 pointers to indicate previous node and nodes need to be swapped\n\n\n##### Recursion\n```python\nclass Solution:\n    def rec(self, node1, node2, prev):\n        if not node2: return \n\n        # swap\n        prev.next = node2\n        node1.next = node2.next\n        node2.next = node1\n\n        if node1.next: self.rec(node2.next.next, node1.next.next, prev.next.next)\n        return\n\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next: return head\n        node1 = head\n        head = head.next\n        self.rec(node1, head, ListNode())\n        return head\n``` \n\n##### Iteration\n```python\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head: return head\n        if not head.next: return head\n\n        node1 = head\n        node2 = head.next\n        prev = ListNode()\n        head = node2\n\n        while node2:\n            prev.next = node2\n            node1.next = node2.next\n            node2.next = node1\n\n            if not node1.next: break\n            node1 = node1.next.next\n            node2 = node2.next.next\n            prev = prev.next.next\n\n            temp = node1\n            node1 = node2\n            node2 = temp\n\n        return head\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hinancy":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921420450","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n\n        Head = ListNode()\n        Head.next = head\n        curNode = Head\n        while curNode and curNode.next and curNode.next.next:\n            f = curNode\n            s = curNode.next\n            t = curNode.next.next\n            f.next = t\n            s.next = t.next\n            t.next = s\n            curNode = curNode.next.next\n            \n        return Head.next\n\nTime complexity: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HarleysZhang":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921487141","body":"## 解题思路\n// leetcode 24. 两两交换链表中的节点\n// 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n// 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n1，**迭代法：关键是高清如何交换两个相邻节点，然后迭代交换即可**。\n\n```cpp\n# include <stdio.h>\n# include <iostream>\n# include <vector>\n# include <stack>\nusing namespace std;\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr) return nullptr;\n        else if(head->next == nullptr) return head;\n        ListNode* temp = new ListNode(-1);\n        temp ->next = head;\n        ListNode* pre = temp;\n        while(pre->next != nullptr && pre->next->next != nullptr) {\n\n            ListNode* cur = pre->next;\n            ListNode* next = pre->next->next;\n\n            pre->next = cur->next;\n            cur->next = next->next;\n            next->next = cur;\n            pre = cur;\n        }\n        return temp->next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922262462","body":"### 解题思路\n将单调递增的链表转化为数组，然后分治递归\n\n```cpp\nclass Solution {\npublic:\n    // 分治递归\n    TreeNode* sortedListToBST(ListNode* head) {\n        vector<int> vec;\n        for(auto it = head; it!=nullptr ; it=it->next ){\n            vec.push_back( it->val );\n        }\n        return recur(vec, 0, vec.size()-1);\n    }\n\n    TreeNode* recur(vector<int> &arr, int left, int right){\n        if(left > right) return nullptr;\n        int mid = right + (left-right)/2;  // 数组中间位置的索引\n        TreeNode* node = new TreeNode(arr[mid]);\n        node -> left = recur(arr, left, mid - 1);\n        node -> right = recur(arr, mid + 1, right);\n\n        return node;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922426627","body":"### 解题思路\n\n**双指针**：\n设 节点指针 A 指向头节点 headA, 节点指针 B 指向头节点 headB\n1. A 先遍历完链表 headA，然后遍历 headB;\n2. B 先遍历完链表 headB，然后遍历 headA;\n\n只要有公共节点，总路程数，或者说 A 经过的节点数和 B 经过的节点数是一样的，如果没有公共节点，只有当 A 和 B都变成了 nullptr的时候，两者最终走的路程才是一样的。 \n然后只需比较 A和 B是否相等，相等的那个位置即为公共节点，因为此使，两者走的步数开始相等了。\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* A =  headA;\n        ListNode* B = headB;\n        while(A != B){\n            if(A != nullptr) A = A->next;\n            else A = headB;\n            if (B != nullptr) B = B->next;\n            else B = headA;\n        }\n        return A;\n    }\n};\n```\n### 复杂度分析：\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guochiscoding":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921549509","body":"##### 题解\n\n```javascript\nvar swapPairs = function (head) {\n        if (!head || !head.next) return head\n        let one = head;\n        let two = head.next;\n        let three = two.next;\n\n        two.next = one;\n        one.next = swapPairs(three);\n        return two\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shibingchao123":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921625179","body":"var swapPairs = function(head) {\r\n  if (!head || !head.next) return head\r\n  let current = head\r\n  let res = head.next\r\n  \r\n  // 记录上一个节点，为了更加方便后续的交换操作，为了不想重新创建链表，将head赋值过去\r\n  // let preNode = head\r\n  \r\n  // 构造一个节点出来，为了更加方便后续的交换操作\r\n  let preNode = new Node()\r\n  preNode.next = head\r\n\r\n  while (current && current.next) {\r\n    let nextNode = current.next\r\n    let nnNode = nextNode.next\r\n\r\n    // 将 current 和 下一个的向进行交换位置\r\n    current.next = nnNode // 将 current下一项的指针指向下下项\r\n    nextNode.next = current // 将 nextNode 的下一项指针指向 current\r\n\r\n  \t// preNode总是记录上一项的的位置，让这个链表产生联系\r\n    preNode.next = nextNode \r\n    // 需要将最新的current赋值给preNode\r\n    preNode = current \r\n\r\n    // 需要将循环进行跳过2个\r\n    current = nnNode\r\n  }\r\n  return res\r\n}\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922431945","body":"思路\r\n首先遍历链表 \\textit{headA}headA，并将链表 \\textit{headA}headA 中的每个节点加入哈希集合中。然后遍历链表 \\textit{headB}headB，对于遍历到的每个节点，判断该节点是否在哈希集合中\r\n代码\r\nvar getIntersectionNode = function(headA, headB) {\r\n    const visited = new Set();\r\n    let temp = headA;\r\n    while (temp !== null) {\r\n        visited.add(temp);\r\n        temp = temp.next;\r\n    }\r\n    temp = headB;\r\n    while (temp !== null) {\r\n        if (visited.has(temp)) {\r\n            return temp;\r\n        }\r\n        temp = temp.next;\r\n    }\r\n    return null;\r\n};\r\n时间复杂度：O(m+n)\r\n空间复杂度：O(m)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Corki418":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921706515","body":"var swapPairs = function (head) {\n    if (head === null || head.next === null) {\n        return head;\n    }\n    const newHead = head.next;\n\n    head.next = swapPairs(newHead.next);\n\n    newHead.next = head;\n\n    return newHead;\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yukicoding":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921837672","body":"## 代码\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null) return head;\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        ListNode pre = dummy;\r\n        ListNode left = head;\r\n        ListNode right = head.next;\r\n        \r\n        \r\n        while(left != null && right != null){\r\n            left.next = right.next;\r\n            right.next = left;\r\n            pre.next = right;\r\n            pre = left;\r\n            left = left.next;\r\n            if(left != null){\r\n                right = left.next;\r\n            }    \r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922277277","body":"### 语言：JavaScript\n\n## 思路\n分治\n## 代码\n\nconst sortedListToBST = (head) => {\n  const arr = [];\n  while (head) { \n    arr.push(head.val);\n    head = head.next;\n  }\n  const buildBST = (start, end) => {\n    if (start > end) return null;       \n    const mid = (start + end) >>> 1;    \n    const root = new TreeNode(arr[mid]); \n    root.left = buildBST(start, mid - 1); \n    root.right = buildBST(mid + 1, end); \n    return root;     \n  };\n\n  return buildBST(0, arr.length - 1); \n};\n## 复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lhjzuibang":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921839712","body":"class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* start=new ListNode(0);\n        start->next=head;\n        // 用于记录链表的开头\n        ListNode* s=start;\n    \n        while(start->next!=nullptr && start->next->next!=nullptr){\n            swapTwo(start);\n            //不能忘了更新 start\n            start=start->next->next;\n        }\n        return s->next;\n    }\n   \n    void swapTwo(ListNode* start){\n        ListNode* a=start->next;\n        ListNode* b=start->next->next;\n        start->next=b;\n        a->next=b->next;\n        b->next=a;\n    }\n};\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nadostars":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921877928","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode pre = new ListNode();\n        pre.next = head;\n        \n        ListNode temp = pre;\n        \n        \n\n        while(temp.next != null && temp.next.next != null){\n            ListNode left = temp;\n            ListNode middle = temp.next;\n            ListNode right = middle.next;\n\n            left.next = right;\n            middle.next = right.next;\n            right.next = middle;\n\n            temp = temp.next.next;\n        }\n        return pre.next;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Liuxy94":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/23#issuecomment-921881846","body":"## 思路\nRecursive \n\n## Code\n\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def swap(node = head):\n            if not (node and node.next):\n                return node\n            L, R = node, node.next\n            L.next = swap(L.next.next)\n            R.next = L\n            return R\n        return swap()\n```\n## 复杂度分析\nSpace O(1)\nTime O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922331789","body":"## 思路\n参考ForLittleBeauty。利用分治，先将链表转化为数组，选取中间结点作为根节点不断分治，直到区间内不再存在元素\n\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        \n        arr = list()\n        while head:\n            arr.append(head.val)\n            head = head.next\n        #找到中间结点\n        def bfs(left,right):\n            if left>right:\n                return None\n            mid = left+(right-left)//2\n            root = TreeNode(arr[mid])\n            root.left = bfs(left,mid-1)\n            root.right = bfs(mid+1,right)\n            return root\n\n        return bfs(0,len(arr)-1)\n```\n\n## 复杂度\n时间： O(n)\n空间： O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922492175","body":"## 思路\n拼接两个链表：短链表走到尽头后继续走长链表，就相当于短链表+长链表。长链表走到尽头后又走短链表，相当于长链表+短链表。所以重新走两次其实本质上还是相当于走两次新的拼接的互补链表，一定会找到交点。\n\n## 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```\n\n## 复杂度\n空间：O(1)\n时间：O(m+n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xitice":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-921971282","body":"### JavaScript\n```JavaScript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n\n  if (!head) return null;\n  const nums = [];\n\n  while(head) {\n    nums.push(head.val);\n    head = head.next;\n  }\n  return dfs(nums, 0, nums.length - 1);\n\n  function TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n  }\n\n  function dfs(arr, low, high) {\n    if (low > high) return null;\n    let mid = Math.floor((low + high) / 2);\n    let node = new TreeNode(arr[mid]);\n\n    node.left = dfs(arr, low, mid - 1);\n    node.right = dfs(arr, mid + 1, high);\n\n    return node;\n  }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyk1337":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922171992","body":"``` python\ndef sortedListToBST(self, head: ListNode) -> TreeNode:\n        def get_len(head):\n            n = 0\n            while head:\n                head = head.next\n                n += 1\n            return n\n\n        def convert(left, right):\n            nonlocal head\n            if left > right:\n                return None\n\n            mid = (left + right + 1) // 2\n            left = convert(left, mid - 1)\n            node = TreeNode(head.val)\n\n            node.left = left\n\n            head = head.next\n            node.right = convert(mid + 1, right)\n            return node\n\n        n = get_len(head)\n        return convert(0, n - 1)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ywang525":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922230105","body":"#指针+递归\r\nclass Solution:\r\ndef sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        def getlenth(head):\r\n            ret = 0\r\n            while head:\r\n                ret += 1\r\n                head = head.next\r\n            return ret\r\n        \r\n        def buildtree(left,right):\r\n            nonlocal head\r\n            if left > right:\r\n                return None\r\n            mid = (left+right+1)//2\r\n            root = TreeNode()\r\n            root.left = buildtree(left,mid-1)\r\n            root.val = head.val\r\n            head = head.next\r\n            root.right = buildtree(mid+1, right)\r\n            return root\r\n        \r\n        lenth = getlenth(head)\r\n        return buildtree(0, lenth-1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangzhengNeu":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922231976","body":"\n109. 有序链表转换二叉搜索树\n---\n\n### 思路\n\n1. 先找中点\n2. 在遍历左右\n\n### 代码\n\n```java\npublic class Solution {\npublic TreeNode sortedListToBST(ListNode head) {\n    if(head==null) return null;\n    return toBST(head,null);\n}\npublic TreeNode toBST(ListNode head, ListNode tail){\n    ListNode slow = head;\n    ListNode fast = head;\n    if(head==tail) return null;\n    \n    while(fast!=tail&&fast.next!=tail){\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    TreeNode thead = new TreeNode(slow.val);\n    thead.left = toBST(head,slow);\n    thead.right = toBST(slow.next,tail);\n    return thead;\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922426982","body":"### 8. 160. Intersection of Two Linked Lists\n\n### 思路1\n---\n判断两个链表是否相交，可以使用哈希集合存储链表节点。\n\n首先遍历链表 \\textit{headA}headA，并将链表 \\textit{headA}headA 中的每个节点加入哈希集合中。然后遍历链表 \\textit{headB}headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：\n\n如果当前节点不在哈希集合中，则继续遍历下一个节点；\n\n如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 \\textit{headB}headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。\n\n如果链表 \\textit{headB}headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 \\text{null}null。\n\n\n### 代码\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<ListNode>();\n        ListNode temp = headA;\n        while (temp != null) {\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while (temp != null) {\n            if (visited.contains(temp)) {\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n + m)，\n- 空间复杂度：O(n)，\n\n### 思路2\n---\n\n为什么 a, b 指针相遇的点一定是相交的起始节点? 我们证明一下：\n\n将两条链表按相交的起始节点继续截断，链表 1 为: A + C，链表 2 为: B + C；\n\n当 a 指针将链表 1 遍历完后，重定位到链表 2 的头节点，然后继续遍历直至相交点，此时 a 指针遍历的距离为 A + C + B；\n\n同理 b 指针遍历的距离为 B + C + A；\n\n### 代码\n\n```java\npublic class Solution {\n   public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n       while(headA != headB){\n           if(headA != null){\n               headA = headA.next;\n           }else{\n               headA =headB;\n           }\n           \n           if(headB != null){\n               headB = headB.next;\n           }else{\n               headB =headA;\n           }\n       }\n        return headA;\n    }\n}\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n + m)，\n- 空间复杂度：O(1)，\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"razor1895":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922267169","body":"## 思路\n\n由题目可知，参数中给的链表是二叉搜索树中序遍历的结果。\n\n因此，链表的中点即是二叉搜索树的根节点，中点左边为二叉搜索树的左子树，右边为右子树，分别递归左右子树即可\n\n```go\nfunc sortedListToBST(head *ListNode) *TreeNode {\n\tif head == nil {\n\t\treturn nil\n\t}\n\n\treturn recur(head, nil)\n}\n\nfunc recur(head *ListNode, tail *ListNode) *TreeNode {\n\tif head == tail {\n\t\treturn nil\n\t}\n\tfast, slow := head, head\n\tfor fast != tail && fast.Next != tail {\n\t\tfast = fast.Next.Next\n\t\tslow = slow.Next\n\t}\n\troot := &TreeNode{Val: slow.Val}\n\troot.Left = recur(head, slow)\n\troot.Right = recur(slow.Next, tail)\n\treturn root\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"famine330":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/24#issuecomment-922281446","body":"递归：先用快慢指针找到中点，然后分左右递归\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        slow = fast = head\n        pre = ListNode()\n        #用来记录中点前面的节点\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        #断开节点避免成环\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        #跳出递归\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsu-arch":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922414322","body":"### Method One: Hash Table \r\n\r\n\r\n### Discussion：\r\n1. Whether the two linked-list will be empty.\r\n2. If they intersect at one node, will the node have the same value? -yes\r\n\r\n\r\n### Method：\r\n1. We store all the nodes in List A in hash table, traverse all the node in list B and then check whether node in list B exists in the hash table. \r\n\t\tIf it does, return it as it must be at the intersection node. \r\n\t\tIf not, we go to the end of list A and cannot find an intersection node, return null.\r\n\r\n### Important points：\r\n\t1. Check the condition if either of the list is empty.\r\n\r\n\r\n\r\n### Code\r\n\r\n```Python3\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        node_in_A = set()\r\n        \r\n        while headA is not None:\r\n            node_in_A.add(headA)\r\n            headA = headA.next\r\n        \r\n        while headB is not None:\r\n            #If in the node_a_set we found headB, we return the node\r\n            if headB in node_in_A:\r\n                return headB\r\n            headB = headB.next\r\n            \r\n        return None\r\n``` \r\n\r\n\r\n\r\n### Complexity Analysis\r\n\r\n- Time Complexity O(N+M), given the length of list A is N and the length of list B is M.\r\n\tWhen we insert item into hash table, it costs O(1). We need to do this step for each of the N nodes in List A. Then, the cost of building up a hash table is O(N).\r\n\tWhen we check whether each node in List B(M nodes in total), we traverse the list. And it takes O(1) to check whether an item is in the hash table or not. So the complexity is O(M).\r\n\tCombining two parts, we received O(N) +O(M) = O(N+M)\r\n- Space Complexity O(N)\r\n\tSince we store all the nodes in list A. The space complexity is O(N). It would also be linear if we store all the nodes in list B. So it's linear either way.\r\n\r\n\r\n### Method Two: Two Pointers \r\n\r\n\r\n### Discussion：\r\n\r\n1. Whether the two linked-list will be empty.\r\n2. If they intersect at one node, will the node have same value?\r\n3. Why do we wan to use two pointers? Because we want to get the Space Complexity DOWN!\r\n\r\n\r\n### Method：See your notes\r\n\r\n### Important points：\r\n\tNA\r\n\r\n\r\n\r\n### Code\r\n\r\n\r\n```Python3\r\n\r\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        \r\n        pA = headA\r\n        pB = headB\r\n        \r\n        while (pA != pB):\r\n            if pA is None:\r\n                pA = headB\r\n            else:\r\n                pA = pA.next\r\n            if pB is None:\r\n                pB = headA\r\n            else:\r\n                pB = pB.next\r\n        return pA\r\n\r\n``` \r\n\r\n\r\n\r\n### Complexity Analysis\r\n\r\n- Time Complexity O(N+M), \r\n\tIf they don't have intersection nodes, the worst case is that we need to traverse the lists twice.The path for one node is a+b -c, and there is no c. O(2M+2N) = O(M+N).\r\n\tWhen they have the same length, we only need to do traverse each list once. \r\n\t\r\n- Space Complexity O(1)\r\n\tSince we didn't use any additional data structures. The amount of space does not grow beyond the size of inputs. ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yxq1997":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922467711","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n## 前置知识\n- 双指针\n## 代码\n- 语言支持：Java\nJava Code:\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode l1 = headA, l2 = headB;\n        while(l1 != l2){\n            if(l1 == null)\n                l1 = headB;\n            else\n                l1 = l1.next;\n            if(l2 == null)\n                l2 = headA;\n            else\n                l2 = l2.next;\n        }\n        return l1;\n    }\n}\n```\n**复杂度分析**\n\n令 n 为数组长度。\n- 时间复杂度：$O(m+n)$ --> m和n分别为两链表的长度\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zbqnb":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922490216","body":"## **91学算法DAYN\n\n#### 思路：\n\n取巧容易忘，简简单单先走几步\n\n\n\n****\n\n#### 复杂度分析：Om + On\n\n\n\n#### Code：\n\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* curA = headA;\n        ListNode* curB = headB;\n        int lenA = 0, lenB = 0;\n        while (curA != NULL) { // 求链表A的长度\n            lenA++;\n            curA = curA->next;\n        }\n        while (curB != NULL) { // 求链表B的长度\n            lenB++;\n            curB = curB->next;\n        }\n        curA = headA;\n        curB = headB;\n        // 让curA为最长链表的头，lenA为其长度\n        if (lenB > lenA) {\n            swap (lenA, lenB);\n            swap (curA, curB);\n        }\n        // 求长度差\n        int gap = lenA - lenB;\n        // 让curA和curB在同一起点上（末尾位置对齐）\n        while (gap--) {\n            curA = curA->next;\n        }\n        // 遍历curA 和 curB，遇到相同则直接返回\n        while (curA != NULL) {\n            if (curA == curB) {\n                return curA;\n            }\n            curA = curA->next;\n            curB = curB->next;\n        }\n        return NULL;\n    }\n};\n\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Awenbocc":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922490890","body":"## 思路\n双指针，如果有交集，短、长序列指针走过的路程相同\n第一次遍历结束时，短序列的指针指到长序列的首部\n第二次长序列指导短首部，两指针在走相同步数后会相遇\n\n## 代码\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if headA is None or headB is None:\n            return None\n\n        pA, pB = headA, headB\n        while pA!=pB:\n            pA = headB if pA is None else pA.next \n            pB = headA if pB is None else pB.next\n\n        return pB\n\n## 复杂度分析\n\n- 时间复杂度： O(n+m)\n- 空间复杂度： O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Mrhero-web":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/25#issuecomment-922494077","body":"\n## 题目地址(160. 相交链表)\n\n[题目源地址](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)\n\n\n\n## 前置知识\n1.HashSet\n\n2.双指针\n\n3.链表\n\n## 思路\n解法1：哈希表。第一次遍历链表A，用HashSet记录A的值（特性是不重复），第二次遍历链表B，用HashSet中存储的元素比对，若相同则是相同节点。若无相同的则返回NULL。\n\n解法2：双指针。分别为链表A和链表B设置指针A和指针B，然后开始遍历链表，如果遍历完当前链表，则将指针指向另外一个链表的头部继续遍历，直至两个指针相遇。\n最终两个指针分别走过的路径为：\n指针A :a+c+b\n指针B :b+c+a\n明显 a+c+b = b+c+a,因而如果两个链表相交，则指针A和指针B必定在相交结点相遇。\n\n解法3：双指针。计算出两个链表的长度差diff，指向长的链表头结点的指针先遍历[ diff ]个结点后，等指向链表A,B的指针处于同一起跑线再开始同时遍历，直至遇到相同节点为止，如果则null。\n\n\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n\n/**\n*解法2\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null){\n            return null;\n        }\n        ListNode pa = headA,pb = headB;\n        while( pa!= pb){\n            pa = pa== null ? headB:pa.next;\n            pb = pb== null ? headA:pb.next;  \n        }\n        return pa;\n    }\n}\n\n```\n\n\n**复杂度分析**\n解法2：\n令 n 为数组长度。\n\n- 时间复杂度：$O(n+m)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}