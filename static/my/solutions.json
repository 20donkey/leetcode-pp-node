{"1":[],"2":[],"3":[],"4":[],"5":[],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[],"13":[],"14":[],"15":[],"16":[],"17":[],"18":[],"19":[],"20":[],"21":[],"22":[],"23":[],"24":[],"25":[],"26":[],"27":[],"28":[],"29":[],"30":[],"31":[],"32":[],"33":[],"34":[],"35":[],"36":[],"37":[],"38":[],"39":[],"40":[],"41":[],"42":[],"43":[],"44":[],"45":[],"46":[],"47":[],"48":[],"49":[],"50":[],"51":[],"52":[],"53":[],"54":[],"55":[],"56":[],"57":[],"58":[],"59":[],"60":[],"61":[],"62":[],"63":[],"64":[],"65":[],"66":[],"67":[],"68":[],"69":[],"70":[],"71":[],"72":[],"73":[],"74":[],"75":[],"76":[],"77":[],"78":[],"79":[],"80":[],"81":[],"82":[],"83":[],"84":[],"85":[],"86":[],"87":[],"88":[],"89":[],"90":[],"91":[],"839781960":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"954545647":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1541732340":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"michaelxi3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817528676","body":"### 思路\n可以通过vector容器实现栈的基本功能，除``increment``方法外，时间复杂度均为``O(1)``，increment方法因为遍历栈，所以时间复杂度为``O(lim)``\n通过一额外数组存储栈中每一元素的加值，并在pop时将元素加上其加值，一同返回，可避免遍历\n### 代码\n```c++\nclass CustomStack {\npublic:\n    vector<int> stk;\n    vector<int> add;\n    int top;\n\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        add.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != stk.size() - 1) {\n            ++top;\n            stk[top] = x;\n        }\n    }\n    \n    int pop() {\n        if(top == -1)\n            return -1; \n        int ret = stk[top] + add[top];\n        if(top != 0)\n            add[top - 1] += add[top];\n        add[top] = 0;\n        --top;\n        return ret;\n    }\n    \n    void increment(int k, int val) {\n        int lim = min(k - 1, top);\n        if(lim >= 0)\n            add[lim] += val;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817874820","body":"### 思路\n使用递归，遇到数字，记录至multi，遇到字母，将其加入本层的字符串中，遇到\"[\"进入新的一层递归，并将下一层返回的字符串重复multi次加至本层的字符串中，遇到“]”返回本层字符串\n### 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int i = 0;\n        return dfs(s, i);\n    }\n\n    string dfs(string &s, int &i){\n        int multi = 0;\n        string res = \"\";\n        for(; i < s.size(); ++i){\n            if('0' <= s[i] && s[i] <= '9')\n                multi = multi * 10 + (s[i] - '0');\n            else if(s[i] == '['){\n                string temp = dfs(s ,++i);\n                while(multi != 0){\n                    res += temp;\n                    --multi;\n                }\n            }\n            else if(s[i] == ']')\n                return res;\n            else\n                res += s[i];\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818859160","body":"### 思路 \n区分了输入和输出栈，只有在输出栈为空时，才从输入栈中取元素压入，如此一来每一个元素最多被分别被压入压出2次\n### 代码\n```c++\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stk1.push(x);\n    }\n    \n    int pop() {\n        int ret = 0;\n        if(stk2.empty())\n            in2out();\n        ret = stk2.top();\n        stk2.pop();\n        return ret;\n    }\n  \n    int peek() {\n        if( stk2.empty()){\n            in2out();\n        }\n        return stk2.top();\n    }\n    \n    bool empty() {\n        return stk1.empty() && stk2.empty();\n    }\nprivate:\n    stack<int> stk1;\n    stack<int> stk2;\n\n    void in2out(){\n        while(!stk1.empty()){\n            stk2.push(stk1.top());\n            stk1.pop();\n        }\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1823761517","body":"### 思路\n本题目的是将链表中相邻两个节点两两交换，可通过递归的方式实现\n* 每一层递归实现传入函数的节点及其下个节点的两两交换，进入下一层\n* 退出条件为传入节点和其下一节点中任一为空\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr)\n            return head;\n        ListNode* newhead = head->next;\n        ListNode* node = newhead->next;\n        newhead->next = head;\n        head->next = swapPairs(node);\n        return newhead;\n    }\n};\n```\n### 复杂度\n* 时间复杂度：O(n) 函数会遍历整个链表 \n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/10#issuecomment-1825633177","body":"### 思路\n找到中间节点，递归构造其左右节点\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode* findmid(ListNode* left, ListNode* right) {\n        ListNode* fast = left;\n        ListNode* slow = left;\n        while(fast != right && fast->next != right){\n            fast = fast->next;\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n\n    TreeNode* buildtree(ListNode* left, ListNode* right) {\n        if(left == right)\n            return nullptr;\n        ListNode* mid = findmid(left, right);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = buildtree(left, mid);\n        root->right = buildtree(mid->next, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildtree(head, nullptr);\n    }\n};\n```\n### 复杂度\n* 时间：O(nlogn)\n* 空间：O(logn)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1827053006","body":"### 思路\n访问和增删操作都要达到O(1)，还要存入对值，这里可以使用unorder_map，每一个key可以访问唯一的链表节点，在链表节点中存储value，维护链表，使最近使用的节点移至表头，在链表超过预设容量时，删除表尾节点及unorded_map的对应成员\n### 代码\n```c++\n\nstruct DList {\n    int key, value;\n    DList* prev;\n    DList* next;\n    DList() : key(0), value(0), prev(nullptr), next(nullptr) {}\n    DList(int _key, int _value) : key(_key), value(_value), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DList*> cache;\n    DList* head;\n    DList* tail;\n    int size;\n    int capacity;\n    \npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0){\n    head = new DList();\n    tail = new DList();\n    head->next = tail;\n    tail->prev = head;\n    }\n    \n    int get(int key) {\n        if(!cache.count(key))\n        {\n            return -1;\n        }\n        DList* node = cache[key];\n        MoveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if(!cache.count(key)) {\n            DList* node = new DList(key, value);\n            cache[key] = node;\n            AddToHead(node);\n            ++size;\n            if(size > capacity) {\n                DList* removed = RemoveTail();\n                cache.erase(removed->key);\n                delete removed;\n                --size;\n            }\n        }\n        else {\n            DList* node = cache[key];\n            node->value = value;\n            MoveToHead(node);\n        }\n    }\n\n\n    void AddToHead(DList* node) {\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n\n    void RemoveNode(DList* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void MoveToHead(DList* node) {\n        RemoveNode(node);\n        AddToHead(node);\n    }\n\n    DList* RemoveTail() {\n        DList* node = tail->prev;\n        RemoveNode(node);\n        return node;\n    }\n};\n```\n* 可以使链表构成一个循环链表，这样就可以只用一个哨兵节点","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1828875144","body":"### 思路\nDFS，二叉树中节点的高度等于其左右子树中最高的高度+1，当遍历到的节点为空时返回0，递归求出答案\n### 代码\n```c++\nclass Solution {\npublic:\n    int depth = 0;\n    int maxDepth(TreeNode* root) {\n        if(root == nullptr)\n            return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n        \n    }\n};\n```\n### 复杂度\n* 时间：O(n) 每个元素都会遍历一次\n* 空间：O(h) h为二叉树层数，递归每一层占用一层栈","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1833259198","body":"### 思路\n每一节点所代表的数字应为其父节点代表数字乘以10再加上该节点的值\n#### dfs：\n编写dfs函数递归求叶节点值之和\n* 先判断root是否为空\n* 计算该节点的值\n* 若该节点为叶节点时返回该节点的值\n* 若否，对该节点的左右节点调用函数\n#### bfs：\n维护两个队列，分别存储节点和节点的值\n* 先判断root是否为空\n* 将root节点和其值加入相应队列\n* 判断队列头节点是否为叶节点\n* 若是，将其值加入sum\n* 若否，将其非空子节点加入队列，计算这些节点对应的值，加入队列\n### 代码\n```c++\n//dfs：\nclass Solution {\npublic:\n    int sum = 0;\n    int dfs(TreeNode* root, int n) {\n        if(!root)\n            return 0;\n        int sum = n * 10 + root->val;\n        if(!root->left && !root->right)\n            return sum;\n        else\n            return dfs(root->left, sum) + dfs(root->right, sum);\n    }\n\n    int sumNumbers(TreeNode* root) {\n        return dfs(root, 0);\n    }\n};\n```  \n```c++\n//bfs：\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        queue<TreeNode*> nodes;\n        queue<int> nums;\n        nodes.push(root);\n        nums.push(root->val);\n        int sum = 0;\n        while(!nodes.empty()) {\n            TreeNode* node = nodes.front(); nodes.pop();\n            int num = nums.front() ; nums.pop();\n            if(node->left) {\n                nodes.push(node->left);\n                nums.push(num * 10 + node->left->val);\n            }\n            if(node->right) {\n                nodes.push(node->right);\n                nums.push(num * 10 + node->right->val);\n            }\n            if(!node->left && !node->right) \n                sum += num;\n        }\n        return sum;\n    }\n};\n```\n### 时间复杂度\n* dfs：\n1. 时间：每个节点都会遍历一次，O(n)\n2. 空间：调用的栈空间为二叉树的高度h，最坏情况h为n，O(n)\n* bfs：\n1. 时间：每个节点都会遍历一次，O(n)\n2. 空间：队列中的元素个数最大不超过n，O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/17#issuecomment-1835913842","body":"### 思路\n不论是dfs还是bfs都是迭代求解，从右到左遍历节点，更新最右值，当遍历到最后一个节点，自然得到了最下层最左节点的值\n### 代码\n```c++\n//dfs\nclass Solution {\npublic:\n    int maxdepth = 0;\n    int lval = 0;\n    void dfs(TreeNode* root, int depth) {\n        ++depth;\n        if(depth >= maxdepth) {\n            lval = root->val;\n            maxdepth = depth;\n        }\n        if(root->right != nullptr)\n            dfs(root->right, depth);\n        if(root->left != nullptr)\n            dfs(root->left, depth);\n    }\n    int findBottomLeftValue(TreeNode* root) {\n        dfs(root, 0);\n        return lval;\n    }\n};\n```\n```c++\n//bfs\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int ans = 0;\n        while(!q.empty()) {\n            TreeNode* node = q.front();\n            q.pop();\n            ans = node->val;\n            if(node->right != nullptr)\n                q.push(node->right);\n            if(node->left != nullptr)\n                q.push(node->left);\n        }\n        return ans;\n    }\n};\n```\n### 复杂度\n* dfs：\n1. 时间：O(n)\n2. 空间：O(n)\n* bfs：\n1. 时间：O(n)\n2. 空间：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1837128432","body":"### 思路\n`serialize()`和`deserialize()`都是bfs\n* `serialize()` 用`X`代表空节点的值，将树中节点的值加入字符串，每个值用`,`间隔开\n* 依据单个值分割字符串，存储至vector中，用队列辅助树广度优先顺序构建\n### 代码\n```c++\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string str;\n        if(root == nullptr)\n            return str;\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()) {\n            TreeNode* node = q.front(); q.pop();\n            if(node == nullptr) {\n                str += \"X,\";\n                continue;\n            }\n            if(node != nullptr) \n                str += to_string(node->val) + \",\";\n            q.push(node->left);\n            q.push(node->right);\n        }\n        return str;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        TreeNode* root = new TreeNode();\n        if(data == \"\")\n            return nullptr;\n        vector<string> datavec;\n        string str;\n        for(auto ch : data) {\n            if(ch == ',') {\n                datavec.push_back(str);\n                str.clear();\n            } else {\n                str.push_back(ch);\n            }\n        }\n        root->val = stoi(datavec[0]);\n        queue<TreeNode*> q;\n        q.push(root);\n        int i = 1;\n        while(!q.empty()) {\n            TreeNode* node = q.front(); q.pop();\n            if(node == nullptr)\n                continue;\n            node->left = datavec[i] == \"X\" ? nullptr : new TreeNode(stoi(datavec[i]));\n            q.push(node->left);\n            ++i;\n            node->right = datavec[i] == \"X\" ? nullptr : new TreeNode(stoi(datavec[i]));\n            q.push(node->right);\n            ++i;\n        }\n        return root;\n    }\n};\n```\n### 复杂度\n#### serialize()\n* 时间：O(n) 遍历了每一个元素\n* 空间：O(n) 队列最大元素值不超过n\n#### deserialize()\n* 时间：O(n) 构建vector，再构建节点树为n的树\n* 空间：O(n) 使用的空间结构有元素数为n的vector，最大元素值不超过n的队列\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/19#issuecomment-1837438984","body":"### 思路\ndfs遍历整个树，用tuple存储列，行，值，sort函数依次根据列, 行, 值进行排列\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<tuple<int, int, int>> vec;\n    \n    void dfs(TreeNode* root, int col, int row) {\n        if(!root)\n            return ;\n        vec.emplace_back(col, row, root->val);\n        dfs(root->left, col - 1, row + 1);\n        dfs(root->right, col + 1, row + 1);\n    }\n\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root, 0, 0);\n        sort(vec.begin(), vec.end());\n        vector<vector<int>> ans;\n        int lastcol = INT_MIN;\n        for(auto& [col, row, val] : vec) {\n            if(lastcol != col) {\n                ans.emplace_back();\n                lastcol = col;\n            } \n            ans.back().push_back(val);\n        }\n        return ans;\n    }\n};\n```\n### 复杂度\n* 时间：O(nlogn)\n1. 遍历所有节点 O(n)\n2. sort()排序O(nlogn)\n3. 构建最终答案O(n)\n* 空间：O(n)\n1. 遍历树节点的栈空间O(n)\n2. vector的空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1838244040","body":"### 思路\n* 使用哈希表存入（值，下标）\n* 判断目前哈希表中是否存在等于target - current的值\n* 若存在，返回找到的值的下标和current的下标\n* 若否，将(下标, 值)存入哈希表\n* 先判断，后将值加入dict是了避免current和自己相加为target的情况\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> dict;\n        for(int i = 0; i < nums.size(); ++i) {\n            if(dict.find(target - nums[i]) != dict.end()) {\n                return {dict[target - nums[i]], i};\n            }\n            dict[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n### 复杂度\n* 时间：O(n)\n* 空间：O(n)哈希表最多存入n个元素","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/21#issuecomment-1840661203","body":"### 思路\n* 使用unordered_map存储元素及其出现次数\n* 依据出现次数对元素进行排列，输入前k个\n* 时间复杂度要求优于O(nlogn)，所以此处采用小顶堆维护出现次数前k个的元素，遍历unordered_map\n* 若堆中元素小于k，直接插入\n* 若堆中元素大于等于k，判断堆顶的出现次数与当前元素出现次数的大小，堆顶大，舍弃当前值；堆顶小，弹出堆顶，插入当前值\n### 代码\n```c++\nclass Solution {\npublic:\n    static bool cmp(pair<int, int>& m, pair<int, int>& n) {\n        return m.second > n.second;\n    }\n\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> occurrences;\n        for (auto& v : nums) {\n            occurrences[v]++;\n        }\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\n        for (auto& [num, count] : occurrences) {\n            if (q.size() == k) {\n                if (q.top().second < count) {\n                    q.pop();\n                    q.emplace(num, count);\n                }\n            } else {\n                q.emplace(num, count);\n            }\n        }\n        vector<int> ret;\n        while (!q.empty()) {\n            ret.emplace_back(q.top().first);\n            q.pop();\n        }\n        return ret;\n    }\n};\n```\n### 复杂度\n* 时间：遍历操作耗时O(n)，堆操作耗时O(logk)，总为O(nlogk)\n* 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/22#issuecomment-1842650767","body":"### 思路\n* 因为需要考虑点的排列顺序，求回旋镖的个数实际上是求`以i为原点，在于其距离相等的共m个点中选出两个点`，也就是`在m个元素中，选两个元素的排列数`，以`m*(m-1)`计算\n* 遍历每个点作为i点，计算其与其他点之间的距离，以哈希表记录点间距离及该距离的点数m\n* 遍历哈希表，获得m的个数，计算排列值，加入答案\n### 代码\n```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int ans = 0;\n        unordered_map<int, int> dict;\n        for(auto i : points) {\n            dict.clear();\n            for(auto j : points) {\n                if(j == i)  continue;\n                int dis = pow(i[0] - j[0], 2) + pow(i[1] - j[1], 2);\n                ++dict[dis];\n            }\n            for(auto &[key, val] : dict) {\n                ans += val * (val - 1);\n            }\n        }\n        return ans;\n    }\n};\n```\n### 复杂度\n* 时间：O(n^2)\n* 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1845323278","body":"### 思路\n* 遍历string，使用unorderd_set来存储出现过的字符，当当前遍历的字符存在于unorderd_set中时，移动左指针至重复字符的下一个字符\n* 若当前字符未出现在unorderd_set中时，将字符添加进unorderd_set，计算当前的子字符串长度，若更长则更新最大子字符串长度\n### 代码\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int max = 0;\n        int left = 0;\n        unordered_set<char> dict;\n        for(int i = 0; i < s.size(); ++i) {\n                if(dict.find(s[i]) != dict.end()) {\n                    while(dict.find(s[i]) != dict.end()) {\n                        dict.erase(s[left]);\n                        ++left;\n                    }\n                }\n                    dict.insert(s[i]);\n                    if((i - left + 1) > max)\n                        max = i - left + 1;\n            }          \n       return max; \n    }\n};\n```\n### 复杂度\n* 时间：O(n)\n* 空间：O(128) unorderd_set最大容量为unorderd_set中字符的数量，ascii字符共128个","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/24#issuecomment-1846580059","body":"\n> Problem: [30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/)\n\n[TOC]\n\n# 思路\n\n> 维护两个哈希表，一个用来存储words中单词的出现频率，一个用来维护目前遍历中的s的子字符串的单词频率，若两个哈希表相等，则当前子字符串为串联单词字符串\n* 第一版答案没有使用移动窗口的思路，每次重新构建子字符串的单词频率表，导致超时，而且左右指针每次只移动一个字符\n* 第二版采用了移动窗口，当子字符串右移size个字符时，只需移出左侧单词，加入右侧单词即可\n* 在遍历s的过程中因为s可能无法被size整除，所以有size种遍历方法\n\n# 复杂度\n\n时间复杂度:\n>遍历了size次s： $O(size * ls)$\n\n空间复杂度:\n>维护的哈希表最大为n， $O(size * length)$\n\n\n\n# Code\n```C++ []\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int size = words[0].size();\n        int length = words.size();\n        int ls = s.size();\n        int totallength = length * size;\n        unordered_map<string, int> wordfreq;\n        unordered_map<string, int> currentfreq;\n        vector<int> ans;\n        for(auto str : words) {\n            ++wordfreq[str];\n        }\n        for(int start = 0; start < size && start + totallength <= ls; ++start){\n          currentfreq.clear();\n          for(int j = 0; j < length; ++j) {\n            string currentword = s.substr(start + j * size, size);\n            ++currentfreq[currentword];\n          }\n          if(currentfreq == wordfreq)\n            ans.emplace_back(start);\n\n          for(int i = start + size; i <= ls - totallength; i += size) {\n            string leftword = s.substr(i - size, size);\n            --currentfreq[leftword];\n            if(currentfreq[leftword] == 0)\n              currentfreq.erase(leftword);\n\n            string rightword = s.substr(i + (length - 1) * size, size);\n            ++currentfreq[rightword];\n\n            if(currentfreq == wordfreq)\n              ans.emplace_back(i);\n          }\n        }\n        return ans;\n    }\n};\n```\n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/25#issuecomment-1848376992","body":"\n> Problem: [1590. 使数组和能被 P 整除](https://leetcode.cn/problems/make-sum-divisible-by-p/description/)\n\n[TOC]\n\n# 思路\n\n* 找到一个最小的子数组，将其删除可使数组和能被p整除，也就是说这个子数组的和等于数组和对p取模的`余数x`\n* 所以本题的暴力解法是遍历所有子数组，计算其和，与余数对比，记录数组长度，最后返回最小的数组，但是时间复杂达到`O((n+1)n/2)`，超时\n* 此时引入前缀和，也即建立一个存储原数组的前i项和的数组prefix，若要求`[l,r]`区间的和，则为`refix[r]-prefix[l-1]`，因为前缀和`prefix[i]=prefix[i-1]+num[i]`,为了包含l处的值，应该减去l-1处的前缀和，`l=0`时需要有特殊判断，此时和即为prefix[r]\n> 也可以在前缀和首项添加一个0省去这个特殊判断\n* 问题这时候可以转变为，求`[l,r]`使得`prefix[r]-prefix[l-1]`等于目标余数x\n* 此时再引入同余定理，`a % p = x`,`b % p = x`则`a ≡ b`,称作a与b对p同余\n1. 可知prefix[r]-prefix[l-1] = x，左右都小于p\n2. (prefix[r]-prefix[l-1])%p = x%p\n3. (prefix[r]-prefix[l-1]-x)%p = 0\n4. 由上移项合并得(prefix[r]-x)%p = prefix[l-1]%p\n* 维护一个哈希表，存储历史前缀和的模和该前缀和的下标\n> 为了使prefix求模结果为负数，为了使其始终为正数，求模的表达式改为`((a%p)+p)%p)`\n\n# 复杂度\n\n时间复杂度:\n> $O(n)$\n\n空间复杂度:\n> $O(n)$\n\n\n\n# Code\n```C++ []\nclass Solution {\npublic:\n   int minSubarray(vector<int>& nums, int p) {\n        int x = accumulate(nums.begin(), nums.end(), 0LL) % p;\n        if(x == 0)\n            return 0;\n        int n = nums.size(), ans = n, s = 0;\n        unordered_map<int, int> dict{{s, -1}};\n        for(int i = 0; i < n; ++i) {\n            s = (s + nums[i]) % p;\n            dict[s] = i;\n            auto it = dict.find((s - x + p) % p);\n            if(it != dict.end())\n                ans = min(ans, i - it->second);\n        }\n        return ans == n ? -1 : ans;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849831729","body":"### 思路\n* 双指针，对比写指针前一个元素和读指针的元素\n* 不相等将读指针的值赋值给写指针，两指针前移\n* 相等前移读指针，直至值不相等\n### 代码\n```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size() < 2)\n            return nums.size();\n        int n = nums.size(), read = 1, write = 1;\n        for(; read < n; ++read) {\n            if(nums[write - 1] != nums[read]) {\n                nums[write++] = nums[read];\n            }\n        }\n        return write;\n    }\n};\n```\n### 复杂度\n* 时间：O(n)\n* 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1852138441","body":"### 思路\n二分法查找，若无则返回第一个不小于目标的元素的下标\n### 代码\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        int ans = nums.size();\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if(target <= nums[mid]) {\n                right = mid - 1;\n                ans = mid;\n            } else {\n            left = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n```\n### 复杂度\n* 时间：O(logn)\n* 空间：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/35#issuecomment-1862595287","body":"### 思路\n将开始时间，结束时间换算为分钟，减去未满15分钟的多余的时间，计算开始时间和结束时间之差，除以15分钟，其结果为完整盘数\n### 代码\n```c++\nclass Solution {\npublic:\n    int numberOfRounds(string loginTime, string logoutTime) {\n        int h1, h2, m1, m2, t1, t2;\n        h1 = stoi(loginTime.substr(0, 2));\n        h2 = stoi(logoutTime.substr(0,2));\n        m1 = stoi(loginTime.substr(3,2));\n        m2 = stoi(logoutTime.substr(3,2));\n        t1 = h1 * 60 + m1;\n        t2 = h2 * 60 + m2;\n        if(t2 < t1) {\n            t2 += 24 * 60;\n        }\n        return (t2 - t2 % 15 - t1) / 15;\n    }\n};\n```\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/42#issuecomment-1869603576","body":"### 思路\n二分求值，但不是具体的值，通过小于该值的差值的对数来判断，更新左右边界\n\n### 代码\n```c++\nbool possible(vector<int>& nums, int d, int k)\n{\n    const int N = nums.size();\n    long count = 0; \n    int i = 0, j = 0;\n    while (i < N || j < N)\n    {\n        while (j < N && nums[j] - nums[i] <= d) j++;\n        count += j - i - 1;\n        i++;\n    }\n    return count >= k;\n};\nint solve(vector<int>& nums, int k) {\n    const int N = nums.size();\n    sort(begin(nums), end(nums));\n    k += 1;    \n    int left = 0, right = nums[N - 1] - nums[0];\n    while (left < right)\n    {\n        int guess = left + (right - left) / 2; \n        if (possible(nums, guess, k))\n            right = guess;\n        else\n            left = guess + 1;\n    }\n    return left;\n}\n```\n### 复杂度\n时间：O(nlogn)排序\n空间：O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/48#issuecomment-1873298230","body":"### 思路\n问题既是求去除两端元素的最小个数使其和等于target，将这个问题转换成求其补集，即求和为sum(nums) - target的最大集合，通过滑动窗口可求\n### 代码\n```c++\nint solve(vector<int>& nums, int target) {\n    int n = nums.size();\n    int newTarget = accumulate(nums.begin(), nums.end(), 0) - target;\n    if(newTarget == 0) return n;\n    int curSum = 0;\n    int maxLen = 0;\n    int left = 0;\n    for(int i = 0; i < n; ++i) {\n        curSum += nums[i];\n        while(curSum >= newTarget && i >= left) {\n            if(curSum == newTarget) {\n                maxLen = max(maxLen, i - left + 1);\n            }\n\n            curSum -= nums[left];\n            ++left;\n        }\n    }\n    return maxLen == 0 ? -1 : n - maxLen;\n}\n```\n### 复杂度\n* 时间：O(n)\n* 空间：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/58#issuecomment-1881107879","body":"```c++\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int size = cost.size();\n        vector<int> minCost(size);\n        minCost[0] = 0;\n        minCost[1] = min(cost[0], cost[1]);\n        for (int i = 2; i < size; i++) {\n            minCost[i] = min(minCost[i - 1] + cost[i], minCost[i - 2] + cost[i - 1]);\n        }\n        return minCost[size - 1];\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnvsd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yueza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cusanity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay-xzj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyue-ma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"steven72574":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowangcoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james0608":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaneyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"azl397985856":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengfengfengwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bulingbulingbuling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eden-ye":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingtrains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"starorbiting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo-xiaoxiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"passengersa":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shellylcooper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testplm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tom-zhouch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skylarxu214":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taihui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huaxueguakele":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yang-chenyu104":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mlking15":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"-3":[],"cyonline":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jetery":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"klspta":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bookyue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jancerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"buer1121":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ceramickitten":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gg925407590":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alyenor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggohem":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dark-volute":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ronething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmastella":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dd2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayloveless":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuexi001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abby-xu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsw9818":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaomingshixiaotang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snmyj":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1814727714","body":"```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> kvet,res;\n        while(k>=1){\n            kvet.push_back(k%10);\n            k/=10;\n        }\n        reverse(kvet.begin(),kvet.end());\n        int n=num.size(),m=kvet.size(),cnt;\n        if(n>=m){\n            cnt=0;\n            for(int i=m-1,j=n-1;i>=0;i--,j--){\n                int a=num[j]+kvet[i]+cnt;\n                if(a>=10) {\n                    res.push_back(a-10);\n                    cnt=1;\n                }\n                else {\n                    res.push_back(a);\n                    cnt=0;\n                }\n            }\n            for(int i=n-m-1;i>=0;i--){\n                int a=num[i]+cnt;\n                if(a>=10) {\n                    res.push_back(a-10);\n                    cnt=1;\n                }\n                else {\n                    res.push_back(a);\n                    cnt=0;\n                }\n            }\n        }\n        else if(n<m){\n            cnt=0;\n            for(int i=n-1,j=m-1;i>=0;i--,j--){\n                int a=num[i]+kvet[j]+cnt;\n                if(a>=10) {\n                    res.push_back(a-10);\n                    cnt=1;\n                }\n                else {\n                    res.push_back(a);\n                    cnt=0;\n                }\n            }\n            for(int i=m-n-1;i>=0;i--){\n                int a=kvet[i]+cnt;\n                if(a>=10) {\n                    res.push_back(a-10);\n                    cnt=1;\n                }\n                else {\n                    res.push_back(a);\n                    cnt=0;\n                }\n            }\n        }\n        if(cnt!=0) res.push_back(cnt);\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\nT:max(m,n)+n\nS:o(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1816671054","body":"```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n=s.length();\n        \n        vector<int> res;\n        for(int i=0;i<n;i++){\n           \n            if(s[i]==c) res.push_back(0);\n            else{\n                 for(int p=1;;p++){\n                     if(i+p<n){\n                     if((s[i+p]==c)&&(i+p)<n) {\n                         res.push_back(p);\n                         break;\n                     }\n                     }\n                     if(i-p>=0){\n                    if((s[i-p]==c)&&(i-p)>=0){\n                        res.push_back(p);\n                        break;\n                    }\n                     }\n                 }\n                \n                \n            }\n            \n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817543805","body":"```\nclass CustomStack {\npublic:\n    vector<int> s;\n    int len=0,maxlen;\n    CustomStack(int maxSize) {\n            maxlen=maxSize;\n    }\n    \n    void push(int x) {\n        if(len<maxlen){\n        s.push_back(x);\n        len++;\n        }\n       \n    }\n    \n    int pop() {\n        if(len>0) {\n          int temp=s[len-1];\n          s.pop_back();\n        \n        len--;\n        return temp;\n        }\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n            if(k<=len) {\n                for(int i=0;i<k;i++) s[i]+=val;\n            }\n            else {\n                for(int i=0;i<s.size();i++) s[i]+=val;\n            }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817894914","body":"class Solution {\npublic:\n    string decodeString(string s) {\n        stack<char> ss;\n        string ans=\"\",re=\"\",rereverse=\"\";\n        int sign=0,cnt=0;\n        for(int i=0;i<s.size();i++){\n            ss.push(s[i]);\n        }\n        for(int t=s.size()-1;t>=0;t--){\n            if(sign==0&&ss.top()>='a'&&ss.top()<='z') {\n                ans+=ss.top();\n                ss.pop(); \n                continue;         \n              }\n            if(ss.top()==']'){\n                sign++;\n                ss.pop(); \n                continue;    \n            }\n            if(ss.top()=='[') {\n                sign--;\n                ss.pop();\n                continue;\n            }\n            if(sign!=0&&ss.top()>='a'&&ss.top()<='z') {\n                    re+=ss.top();\n                    ss.pop();\n                    continue;\n            }\n            if(ss.top()>='0'&&ss.top()<='9') {\n                cnt=ss.top()-'0';\n                ss.pop();\n                continue;\n            }\n            if(cnt!=0) {\n                for(int i=re.size()-1;i>=0;i--) rereverse+=re[i];\n                     if(sign==0){\n                            for(int j=cnt;j>0;cnt--){\n                                ans+=rereverse;\n                            }\n                     }      \n                     if(sign!=0){\n                            for(int j=cnt;j>0;cnt--){\n                                re+=rereverse;\n                            }\n                     }    \n                 \n            }\n            re=\"\";\n            rereverse=\"\";\n            cnt=0;\n            \n        }\n        return ans;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1819338983","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        self.arr=[]\n    \n    def push(self, x: int) -> None:\n        self.arr.append(x)\n\n    def pop(self) -> int:\n        return self.arr.pop(0)\n\n    def peek(self) -> int:\n        return self.arr[0]\n        \n\n    def empty(self) -> bool:\n        return not self.arr\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1821197290","body":"```\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n=arr.size(),max=0;;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>=i;j--){\n                if(arr[j]<=arr[i]) {\n                    max++;\n                    for(int k=j-1;k>=i;k--){\n                        if(arr[k]==arr[j])\n                        max++;\n                        else if(arr[i]==arr[j]) {\n                            \n                            if(arr[k]==arr[j]){\n                                max++;\n                                j=k;\n                            }\n                            \n                        }\n                    }\n                    if(j!=n-1){\n                    i=j;\n                    break;\n                    }\n                    \n                    return max;\n                   \n                }\n            }\n        }\n        return max;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822937184","body":"class Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        int n = 1;\n        ListNode* iter = head;\n        while (iter->next != nullptr) {\n            iter = iter->next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter->next = head;\n        while (add--) {\n            iter = iter->next;\n        }\n        ListNode* ret = iter->next;\n        iter->next = nullptr;\n        return ret;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1824604574","body":"\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n        ListNode temp = dummyHead;\n        while (temp.next != null && temp.next.next != null) {\n            ListNode node1 = temp.next;\n            ListNode node2 = temp.next.next;\n            temp.next = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n            temp = node1;\n        }\n        return dummyHead.next;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/10#issuecomment-1825610624","body":"class Solution {\r\n    \r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        \r\n        if (head == null) {\r\n            return null;\r\n        }           \r\n        if (head.next == null) {\r\n            return new TreeNode(head.val);\r\n        }           \r\n       \r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        ListNode pre = null;\r\n        while (fast != null && fast.next != null) {\r\n            pre = slow;\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        pre.next = null;\r\n        \n\r\n        TreeNode node = new TreeNode(slow.val);\r\n        \r\n        node.left = sortedListToBST(head);\r\n        \r\n        node.right = sortedListToBST(slow.next);\r\n        return node;\r\n\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/11#issuecomment-1826352967","body":"public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<>();\n        ListNode temp = headA;\n        while(temp != null){\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while(temp != null){\n            if(visited.contains(temp)){\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826799606","body":"\nstruct ListNode *detectCycle(struct ListNode *head) {\n    struct ListNode *fast=head,*low=head;\n\n    while(fast&&fast->next){\n        fast=fast->next->next;\n        low=low->next;\n        if(fast==low){\n            struct ListNode *meet=low;\n            struct ListNode *heed=head;\n            while(heed!=meet){\n                meet=meet->next;\n                heed=heed->next;\n            }\n            return meet;\n        }\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1827987984","body":"class LRUCache {\n    int cap;\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\n    public LRUCache(int capacity) { \n        this.cap = capacity;\n    }\n    \n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1;\n        }\n        \n        makeRecently(key);\n        return cache.get(key);\n    }\n    \n    public void put(int key, int val) {\n        if (cache.containsKey(key)) {\n            cache.put(key, val);\n            makeRecently(key);\n            return;\n        }\n        \n        if (cache.size() >= this.cap) {\n            int oldestKey = cache.keySet().iterator().next();\n            cache.remove(oldestKey);\n        }\n        cache.put(key, val);\n    }\n    \n    private void makeRecently(int key) {\n        int val = cache.get(key);\n        cache.remove(key);\n        cache.put(key, val);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1830146948","body":"\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint maxDepth(struct TreeNode* root) {\n    if(root == NULL)\n    {\n        return 0;\n    }\n\n    int ldep = maxDepth(root->left);\n    int rdep = maxDepth(root->right);\n    int maxdep = ldep > rdep ? ldep : rdep;\n    return maxdep + 1;\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1832175745","body":"class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null)  \n            return true;\n        if(p == null || q == null) \n            return false;\n        if(p.val != q.val)  \n            return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);//递归比较\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1833966978","body":"public class Solution {\n    public int SumNumbers(TreeNode root) {\n        int sum = 0;\n        Queue<TreeNode> nodeQueue = new Queue<TreeNode>();\n        Queue<int> numQueue = new Queue<int>();\n        nodeQueue.Enqueue(root);\n        numQueue.Enqueue(root.val);\n        while (nodeQueue.Count > 0) {\n            TreeNode node = nodeQueue.Dequeue();\n            int num = numQueue.Dequeue();\n            if (node.left == null && node.right == null) {\n                sum += num;\n            } else {\n                if (node.left != null) {\n                    nodeQueue.Enqueue(node.left);\n                    numQueue.Enqueue(num * 10 + node.left.val);\n                }\n                if (node.right != null) {\n                    nodeQueue.Enqueue(node.right);\n                    numQueue.Enqueue(num * 10 + node.right.val);\n                }\n            }\n        }\n        return sum;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/17#issuecomment-1836190282","body":"\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNod\nclass Solution {\npublic:\nvoid dfs(TreeNode *root,int height,int &curval,int &curHeight){\n    if(root==nullptr){\n        return ;\n    }\n    height++;\n    dfs(root->left,height,curval,curHeight);\n    dfs(root->right,height,curval,curHeight);\n    if(height>curHeight){\n        curHeight=height;\n        curval=root->val;\n    }\n}\n    int findBottomLeftValue(TreeNode* root) {\n        int curval,curHeight=0;\n        dfs(root,0,curval,curHeight);\n        return curval;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1837181960","body":"    string serialize(TreeNode* root) {\n        string res;\n        if(root == nullptr) {\n            return res;\n        }\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()) {\n            int cur_size = q.size();\n            bool flag = true;\n            for(int i = 0; i < cur_size; i++) {\n                TreeNode* tmp = q.front();\n                q.pop();\n                if( tmp ) {\n                    res += \",\" + to_string(tmp->val);\n                    if( tmp->left || tmp->right )\n                        flag = false;\n                    q.push(tmp->left);\n                    q.push(tmp->right);\n                }\n                else \n                    res += \",null\";\n            }\n            if(flag)\n                break;\n        }\n        res.erase(res.begin());  \n \n        return res;\n    }\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/19#issuecomment-1837520219","body":"\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root, 0, 0);     \n        vector<vector<int>> ans;  \n        map<int, vector<pair<int, int>>>::iterator itB = myMap.begin(), itE = myMap.end();         //用于遍历mymap\n        while(itB != itE){\n            vector<pair<int, int>> &col = itB->second;   \n            sort(col.begin(), col.end());           \n            const int length = col.size();         \n            vector<int> tmp(length);              \n            for(int i = 0; i < length; ++i)\n                tmp[i] = col[i].second;          \n            ans.push_back(tmp);                   \n            ++itB;\n        }\n        return ans;\n    }\nprivate:\n    map<int, vector<pair<int, int>>> myMap;  \n    void dfs(TreeNode* root, int row, int col){\n        if(root == nullptr)        \n            return;\n        myMap[col].push_back({row, root->val});\n        dfs(root->left, row + 1, col - 1);   \n        dfs(root->right, row + 1, col + 1);\n    }\n};\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1838683515","body":"class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int i,j;\n        for(i=0;i<nums.size()-1;i++)\n        {\n            for(j=i+1;j<nums.size();j++)\n            {\n                if(nums[i]+nums[j]==target)\n                {\n                   return {i,j};\n                }\n            }\n        }\n        return {i,j};\n    };\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/21#issuecomment-1841015313","body":"```\nclass Solution {\npublic:\n    static bool cmp(pair<int, int>& m, pair<int, int>& n) {\n        return m.second > n.second;\n    }\n\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> occurrences;\n        for (auto& v : nums) {\n            occurrences[v]++;\n        }\n\n        \n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\n        for (auto& [num, count] : occurrences) {\n            if (q.size() == k) {\n                if (q.top().second < count) {\n                    q.pop();\n                    q.emplace(num, cou\n                }\n            } else {\n                q.emplace(num, count);\n            }\n        }\n        vector<int> ret;\n        while (!q.empty()) {\n            ret.emplace_back(q.top().first);\n            q.pop();\n        }\n        return ret;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/22#issuecomment-1843176442","body":"```\nclass Solution {\r\n\n    public int numberOfBoomerangs(int[][] points) {\r\n        \r\n        int ans = 0;\r\n\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n\r\n        int n = points.length;\r\n        for (int i = 0; i < n; i++) {\r\n            int[] p0 = points[i];\r\n            for (int j = 0; j < n; j++) {\r\n                if (i != j) {\r\n                    int[] p1 = points[j];\r\n                    int deltaX = p0[0] - p1[0];\r\n                    int deltaY = p0[1] - p1[1];\r\n                    // distance = (x1-x2)^2 + (y1-y2)^2\r\n                    int distance = deltaX * deltaX + deltaY * deltaY;\r\n                    map.put(distance, map.getOrDefault(distance, 0) + 1);\r\n                }\r\n            }\r\n\r\n           \r\n            for (int val : map.values()) {\r\n                ans += val * (val - 1);\r\n            }\r\n\r\n            map.clear();\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1845593624","body":"```\n    int lengthOfLongestSubstring(string s) {\r\n\n        vector<int> m(128, 0);\r\n        int ans = 0;\r\n        int i = 0;\r\n        for (int j = 0; j < s.size(); j++) {\r\n            i = max(i, m[s[j]]);\r\n            m[s[j]] = j + 1;\r\n            ans = max(ans, j - i + 1);\r\n        }\r\n        return ans;\r\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/24#issuecomment-1847418549","body":"```\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:return []\n        all_len = sum(map(len, words))\n        n = len(s)\n        words = Counter(words)\n        res = []\n        for i in range(0, n - all_len + 1):\n            tmp = s[i:i+all_len]\n            flag = True\n            for key in words:\n                if words[key] != tmp.count(key):\n                    flag = False\n                    break\n            if flag:res.append(i)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/25#issuecomment-1848442812","body":"```\nclass Solution {\r\n\n    public int minSubarray(int[] nums, int p) {\r\n        int x = 0;\r\n        \r\n        for(int num: nums){\r\n            x = (x + num) % p;\r\n        }\r\n        \r\n        if(x  == 0){\r\n            return 0;\r\n        }\r\n        int res = nums.length;\r\n        int y = 0;  \r\n        int target;\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        map.put(0, -1); \r\n        for(int i = 0; i < nums.length; i++){\r\n            y = (y + nums[i]) % p;  \r\n            target = (y - x + p) % p;   \r\n            if(map.containsKey(target)){\r\n                res = Math.min(res, i - map.get(target));\r\n            }\r\n            map.put(y, i);  \r\n        }\r\n        \r\n        return res == nums.length ? -1 : res;\r\n    }\r\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/26#issuecomment-1848999996","body":"```\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode *fast = head, *slow = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1850326013","body":"```\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n\n        int slow = 1;\n        for (int fast = 1; fast < nums.length; fast++) {\n                if (nums[fast] != nums[fast-1]) {\n                    nums[slow] = nums[fast];\n                    slow++;\n                }\n            }\n        return slow;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1852191677","body":"```\nclass Solution{\npublic:\n    int searchInsert(vector<int>& nums, int target){\n        int n = (int)nums.size();\n        int l=0,r=n-1;\n        while(l<=r){\n            int mid = (l+r)>>1;\n            if(target>nums[mid]) l = mid+1;\n            else if (target<nums[mid]) r=mid-1;\n            else return mid;\n        }\n        return l;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/29#issuecomment-1854069459","body":"```\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        if(nums == null || nums.length < 2) return nums; LinkedList<Integer> queue = new LinkedList();\r\n        int[] result = new int[nums.length-k+1];\r\n        for(int i = 0;i < nums.length;i++){\r\n          while(!queue.isEmpty() && nums[queue.] <= nums[i]) queue.pollLast();\r\n            }\r\n            queue.addLast(i);\r\n            \r\n            if(queue.peek() <= i-k){\r\n                queue.poll();   \r\n            } \r\n           \r\n            if(i+1 >= k){\r\n                result[i+1-k] = nums[queue.peek()];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/30#issuecomment-1856100155","body":"```\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        if(n==1){\n            return 1;\n        }\n        Set<Integer> set=new HashSet<>();\n        List<Integer> list=new ArrayList<>();\n        int ans=0;\n        for(int i=0;i<trust.length;i++){\n            set.add(trust[i][0]);\n        }\n        if(set.size()<n-1){return -1;}\n\n        for(int i=1;i<=n;i++){\n            if(!set.contains(i)){\n                ans=i;\n                break;\n            }\n        }\n        if(ans==0){\n            return -1;\n        }\n        \n        for(int i=0;i<trust.length;i++){\n            if(trust[i][1]==ans){\n                list.add(trust[i][0]);\n            }\n        }\n        return set.size()==list.size()?ans:-1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/31#issuecomment-1858010527","body":"```\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[][] matrix = new int[n + 1][n + 1];\n        for (int[] item : dislikes)\n            matrix[item[0]][item[1]] = matrix[item[1]][item[0]] = 1;\n        int[] record = new int[n + 1]; // 记录分组情况\n        for (int i = 1; i <= n ; i++) \n            if (record[i] == 0 && ! dfs(matrix, record, i, 1, n)) return false;\n        return true;\n    }\n\n    public boolean dfs(int[][] matrix, int[] record, int index, int group, int n) {\n        record[index] = group;\n        for (int i = 1; i <= n ; i++) {\n            if(i == index) continue;\n            if (matrix[index][i] == 1 && record[i] == group) return false;\n            if (matrix[index][i] == 1 && record[i] == 0 && !dfs(matrix, record, i, group * -1, n)) return false;\n        }\n        return true;\n   \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/32#issuecomment-1858780018","body":"```\nclass Solution {\npublic:\n    vector<int> topSort(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\n        queue<int> Q;\n        for (auto& item: items) {\n            if (deg[item] == 0) {\n                Q.push(item);\n            }\n        }\n        vector<int> res;\n        while (!Q.empty()) {\n            int u = Q.front(); \n            Q.pop();\n            res.emplace_back(u);\n            for (auto& v: graph[u]) {\n                if (--deg[v] == 0) {\n                    Q.push(v);\n                }\n            }\n        }\n        return res.size() == items.size() ? res : vector<int>{};\n    }\n\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> groupItem(n + m);\n\n        // 组间和组内依赖图\n        vector<vector<int>> groupGraph(n + m);\n        vector<vector<int>> itemGraph(n);\n\n        // 组间和组内入度数组\n        vector<int> groupDegree(n + m, 0);\n        vector<int> itemDegree(n, 0);\n        \n        vector<int> id;\n        for (int i = 0; i < n + m; ++i) {\n            id.emplace_back(i);\n        }\n\n        int leftId = m;\n        // 给未分配的 item 分配一个 groupId\n        for (int i = 0; i < n; ++i) {\n            if (group[i] == -1) {\n                group[i] = leftId;\n                leftId += 1;\n            }\n            groupItem[group[i]].emplace_back(i);\n        }\n        // 依赖关系建图\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (auto& item: beforeItems[i]) {\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i] += 1;\n                    itemGraph[item].emplace_back(i);   \n                } else {\n                    groupDegree[curGroupId] += 1;\n                    groupGraph[beforeGroupId].emplace_back(curGroupId);\n                }\n            }\n        }\n\n        // 组间拓扑关系排序\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \n        if (groupTopSort.size() == 0) {\n            return vector<int>{};\n        } \n        vector<int> ans;\n        // 组内拓扑关系排序\n        for (auto& curGroupId: groupTopSort) {\n            int size = groupItem[curGroupId].size();\n            if (size == 0) {\n                continue;\n            }\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\n            if (res.size() == 0) {\n                return vector<int>{};\n            }\n            for (auto& item: res) {\n                ans.emplace_back(item);\n            }\n        }\n        return ans;\n    }\n};\n\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/33#issuecomment-1859048325","body":"```\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        int length = moves.length();\n        for (int i = 0; i < length; i++) {\n            char move = moves.charAt(i);\n            if (move == 'U') {\n                y++;\n            } else if (move == 'D') {\n                y--;\n            } else if (move == 'L') {\n                x--;\n            } else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/34#issuecomment-1860891896","body":"```\n\nclass Solution \n{\n    struct mystr\n    {\n        int btime;\n        int rtime;\n        int index;\n    };\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) \n    {\n        vector<mystr>vc;\n        vector<int>ret;\n        for(int i=0;i<tasks.size();i++)\n        {\n            vc.push_back({tasks[i][0],tasks[i][1],i});\n        }\n\n        sort(vc.begin(),vc.end(),[](mystr&a,mystr&b)->bool\n        {\n            if(a.btime==b.btime)\n            return a.rtime<b.rtime;\n            else \n            return a.btime<b.btime;\n        });\n\n\n        typedef pair<int,int> PP;\n        priority_queue<PP,vector<PP>,greater<PP>>q;\n\n        long long time=vc[0].btime;\n        int index=0;\n        \n        while(index<vc.size()&&time>=vc[index].btime)\n        {\n            q.push({vc[index].rtime,vc[index].index});\n            index++;\n        }\n        while(q.size())\n        {\n            time+=q.top().first;\n            ret.push_back(q.top().second);\n            q.pop();\n\n            if(index<vc.size()&&time<vc[index].btime&&q.size()==0)\n            {\n                time=vc[index].btime;\n            }\n            while(index<vc.size()&&time>=vc[index].btime)\n            {\n                q.push({vc[index].rtime,vc[index].index});\n                index++;\n            }\n            \n        }\n        return ret;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/35#issuecomment-1862794293","body":"class Solution \n{\npublic:\n    int numberOfRounds(string startTime, string finishTime) \n    {\n        int h1 = stoi(startTime.substr(0, 2));\n        int m1 = stoi(startTime.substr(3, 2));\n        int h2 = stoi(finishTime.substr(0, 2));\n        int m2 = stoi(finishTime.substr(3, 2));\n\n        int a1 = h1 * 60 + m1;\n        int a2 = h2 * 60 + m2;\n        if (a1 > a2)\n            a2 += 24 * 60;\n        \n        int a = ceil(double(a1) / 15);\n        int b = floor(double(a2) / 15);\n\n        return max(0, b - a);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/36#issuecomment-1864732104","body":"```\nclass Solution {\npublic:\n    int minCharacters(string a, string b) {\n        vector<int> acnt(26, 0);\n        vector<int> bcnt(26, 0);\n        int an = a.size(), bn = b.size();\n        \n        for (char c : a) acnt[c-'a']++;\n        for (char c : b) bcnt[c-'a']++;\n        \n        int ans = INT_MAX, asum = 0, bsum = 0;\n        for (int i = 0; i < 25; i++) {\n            asum += acnt[i];\n            bsum += bcnt[i];\n            ans = min(min(ans, an-acnt[i]+bn-bcnt[i]), min(an-asum+bsum, bn-bsum+asum));\n        }\n        ans = min(ans, an-acnt[25]+bn-bcnt[25]);\n        \n        return ans;\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/37#issuecomment-1866472516","body":"```\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        \n        pivot_index = random.randint(0,len(nums)-1)\n        pivot = nums[pivot_index]\n\n        le = [x for x in nums if x < pivot]\n        eq = [x for x in nums if x == pivot]\n        rt = [x for x in nums if x > pivot]\n\n        return self.sortArray(le) + eq + self.sortArray(rt)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/38#issuecomment-1867810457","body":"```\nclass Solution {\n    public int mySqrt(int x) {\n        if(x==2147483647)\n        return 46340;\n          int res=0;\n    int start=1;\n    int end=46340;\n    int mid=(start+end)/2;\n    while (start<end)\n    {\n        if(x<mid*mid)\n        {\n            end=mid-1;\n            mid=(start+end)/2;\n        }else\n        {\n            start=mid+1;\n            mid=(start+end)/2;\n        }\n        if(mid*mid<x&&(mid+1)*(mid+1)>x||mid*mid==x)\n        {\n             res=mid;\n        }\n    }\n    return res;   \n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/39#issuecomment-1868319394","body":"```\nclass Solution {\r\n\npublic:\r\n    int firstBadVersion(int n) {\r\n        int left = 1;\r\n        int right = n;\r\n\r\n        while (left < right) {\r\n            int mid = (right-left)/2 + left;\r\n            if (isBadVersion(mid)) {\r\n                right = mid;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        \r\n        return left; \r\n    }\r\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/40#issuecomment-1868541915","body":"```\nclass Solution {\r\n\npublic:\r\n\n    int find_reversed_pairs(vector<int>& nums,int& left,int& right){\r\n        int res = 0,mid = left + (right-left)/2;\r\n        int i = left,j = mid+1;\r\n        for(;i <= mid;i++){\r\n            while(j <= right && (long)nums[i] > 2*(long)nums[j]) {\r\n                res += mid - i + 1;\r\n                j++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    int merge_sort(vector<int>& nums,int nums_sorted[],int left,int right){\r\n        if(left >= right) return 0;\r\n        int mid = left + (right-left) / 2;\r\n        \r\n        int res = merge_sort(nums,nums_sorted,left,mid) + \r\n                  merge_sort(nums,nums_sorted,mid+1,right) + \r\n                  find_reversed_pairs(nums,left,right);\r\n        \r\n        int i = left,j = mid+1,ind = left;\r\n        \r\n        while(i <= mid && j <= right){\r\n            if(nums[i] <= nums[j]) nums_sorted[ind++] = nums[i++];\r\n            else nums_sorted[ind++] = nums[j++];\r\n        }\r\n        while(i <= mid) nums_sorted[ind++] = nums[i++];\r\n        while(j <= right) nums_sorted[ind++] = nums[j++];\r\n        \r\n        for(int ind = left;ind <= right;ind++) nums[ind] = nums_sorted[ind];\r\n    \r\n        return res;\r\n    }\r\n    \r\n    int reversePairs(vector<int>& nums) {\r\n        if(nums.empty()) return 0;\r\n        int nums_sorted[nums.size()];\r\n        memset(nums_sorted,0,sizeof(nums_sorted));\r\n        return merge_sort(nums,nums_sorted,0,nums.size()-1);\r\n    }\r\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/41#issuecomment-1869014763","body":"```\nclass Solution {\npublic:\n    int findRadius(vector<int> &houses, vector<int> &heaters) {\n        int ans = 0;\n        sort(heaters.begin(), heaters.end());\n        for (int house: houses) {\n            int j = upper_bound(heaters.begin(), heaters.end(), house) - heaters.begin();\n            int i = j - 1;\n            int rightDistance = j >= heaters.size() ? INT_MAX : heaters[j] - house;\n            int leftDistance = i < 0 ? INT_MAX : house - heaters[i];\n            int curDistance = min(leftDistance, rightDistance);\n            ans = max(ans, curDistance);\n        }\n        return ans;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/42#issuecomment-1869919027","body":"```\nclass Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n=nums.size(), l=0, r=nums[n-1]-nums[0];\n        while(l <= r){\n            int m=(l+r)/2, cnt=0;\n            for(int i=0,j=0;j<n;j++){\n                while(nums[j]-nums[i] > m)\n                    i++;\n                cnt += j-i;\n            }\n            if(cnt >= k)\n                r = m-1;\n            else\n                l = m+1;\n        }\n        return l;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/43#issuecomment-1869919815","body":"```\nclass Solution {\npublic:\n    int swimInWater(vector<vector<int>>& grid) {\n        int m=grid.size();\n        int n=grid[0].size();\n        UnionFind uf(m*n);\n        vector<tuple<int,int,int>>edge;\n        for(int i=0;i<m;i++)\n        for(int j=0;j<n;j++){\n            int id=i*n+j;\n            if(i>0)edge.emplace_back(max(grid[i][j],grid[i-1][j]),id,id-m);\n            if(j>0)edge.emplace_back(max(grid[i][j],grid[i][j-1]),id,id-1);\n        }\n        sort(edge.begin(),edge.end());\n        int res=0;\n        for(auto&[v,x,y]:edge){\n            uf.merge(x,y);\n            if(uf.connected(0,n*n-1)){\n                res=v;\n                break;\n            }\n        }\n        return res;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/44#issuecomment-1887460937","body":"```\r\npublic int maxVowels(String s, int k) {\r\n\r\n    if (s == null || s.length() < k)\r\n        return 0;\r\n\r\n    int res = 0;\r\n    Set<Character> set = new HashSet<>(){{\r\n        add('a');add('e');add('i');add('o');add('u');\r\n    }};\r\n\r\n    // init\r\n    for (int i = 0; i < k; i++)\r\n        if (set.contains(s.charAt(i)))\r\n            res++;\r\n\r\n    int cur = res;\r\n    for (int i = 1; i < s.length() - k + 1; i++) {\r\n\r\n        if (set.contains(s.charAt(i - 1)))\r\n            cur--;\r\n        if (set.contains(s.charAt(i + k - 1)))\r\n            cur++;\r\n\r\n        res = Math.max(res, cur);\r\n    }\r\n\r\n    return res;\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/45#issuecomment-1871313505","body":"```\nclass Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        dp=[None]*(K+W)\n        s=0\n        for i in range(K,K+W):          \n            dp[i] = 1 if i<=N else 0\n            s+=dp[i]\n        for i in range(K-1,-1,-1):      \n            dp[i]=s/W\n            s=s-dp[i+W]+dp[i]\n        return dp[0]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/46#issuecomment-1879591305","body":"```\r\nclass Solution {\r\n    public List<Integer> findAnagrams(String s, String p) {\r\n        int sLen = s.length(), pLen = p.length();\r\n\r\n        if (sLen < pLen) {\r\n            return new ArrayList<Integer>();\r\n        }\r\n\r\n        List<Integer> ans = new ArrayList<Integer>();\r\n        int[] sCount = new int[26];\r\n        int[] pCount = new int[26];\r\n        for (int i = 0; i < pLen; ++i) {\r\n            ++sCount[s.charAt(i) - 'a'];\r\n            ++pCount[p.charAt(i) - 'a'];\r\n        }\r\n\r\n        if (Arrays.equals(sCount, pCount)) {\r\n            ans.add(0);\r\n        }\r\n\r\n        for (int i = 0; i < sLen - pLen; ++i) {\r\n            --sCount[s.charAt(i) - 'a'];\r\n            ++sCount[s.charAt(i + pLen) - 'a'];\r\n\r\n            if (Arrays.equals(sCount, pCount)) {\r\n                ans.add(i + 1);\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/47#issuecomment-1872900746","body":"```\n    def minWindow(self, s: str, t: str) -> str:\n        need=collections.defaultdict(int)\n        for c in t:\n            need[c]+=1\n        needCnt=len(t)\n        i=0\n        res=(0,float('inf'))\n        for j,c in enumerate(s):\n            if need[c]>0:\n                needCnt-=1\n            need[c]-=1\n            if needCnt==0:       \n                while True:      \n                    c=s[i] \n                    if need[c]==0:\n                        break\n                    need[c]+=1\n                    i+=1\n                if j-i<res[1]-res[0]:  \n                    res=(i,j)\n                need[s[i]]+=1  \n                needCnt+=1\n                i+=1\n        return '' if res[1]>len(s) else s[res[0]:res[1]+1]    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/48#issuecomment-1877105818","body":"```\r\nclass Solution {\r\npublic:\r\n    int minOperations(vector<int>& nums, int x) {\r\n        int target = 0;\r\n        for (int num : nums) target += num;\r\n        target -= x;\r\n\r\n        int sum = 0, len = -1;\r\n        for (int l = 0, r = 0; r < nums.size(); r++) {\r\n            sum += nums[r];\r\n            while (l <= r && sum > target) sum -= nums[l++];\r\n            if (sum == target) len = max(len, r - l + 1);\r\n        }\r\n\r\n        return len == -1 ? -1 : nums.size() - len;\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/49#issuecomment-1874205243","body":"```\nclass Solution {\npublic:\n    vector<string> readBinaryWatch(int turnedOn) {\n        vector<string> ans;\n        if(turnedOn>=9)return {};\n        for(int i=0;i<1024;i++){\n            int h=i>>6,m=i&63;\n            if(h<12&&m<60&&__builtin_popcount(i)==turnedOn){\n                ans.push_back(to_string(h)+\":\"+(m<10?\"0\"+to_string(m):to_string(m)));\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/50#issuecomment-1874959073","body":"```\nclass Solution {\r\n\npublic:\r\n    int totalNQueens(int n) {\r\n        int ans = 0;\r\n        vector<int> on_path(n), diag1(n * 2 - 1), diag2(n * 2 - 1);\r\n        function<void(int)> dfs = [&](int r) {\r\n            if (r == n) {\r\n                ans++;\r\n                return;\r\n            }\r\n            for (int c = 0; c < n; ++c) {\r\n                int rc = r - c + n - 1;\r\n                if (!on_path[c] && !diag1[r + c] && !diag2[rc]) {\r\n                    on_path[c] = diag1[r + c] = diag2[rc] = true;\r\n                    dfs(r + 1);\r\n                    on_path[c] = diag1[r + c] = diag2[rc] = false; \r\n                }\r\n            }\r\n        };\r\n        dfs(0);\r\n        return ans;\r\n    }\r\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/54#issuecomment-1877103183","body":"```\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n\n        m,n = len(grid), len(grid[0])\n        ans = 0\n        def dfs(i,j):\n            if i < 0 or i >= m or j < 0 or j >= n: return 0\n            if grid[i][j] == 0: return 0\n            grid[i][j] = 0\n            top = dfs(i+1,j)\n            bottom = dfs(i-1,j)\n            left = dfs(i,j-1)\n            right = dfs(i,j+1)\n            return 1 + sum([top, bottom,left, right])\n\n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i,j))\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/55#issuecomment-1878795171","body":"```\nclass Solution {\npublic:\n    int maxDistance(vector<vector<int>>& grid) {\n        int N = grid.size();\n        int count_land = 0;\n        int count_turn = 0;\n        int count_last_space;\n        for(int i=0;i<N;i++){\n            for(int j =0;j<N;j++){\n                if(grid[i][j]==1){\n                    count_land++;\n                }\n            }\n        }\n        if(count_land==N*N||count_land==0){\n            return -1;\n        }\n        count_last_space = N*N-count_land;\n        while(count_last_space!=0){\n            count_turn++;\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    if(grid[i][j]==count_turn){\n                        if(i>0&&grid[i-1][j]==0){\n                            grid[i-1][j]=count_turn+1;\n                            count_last_space--;\n                        }\n                        if(i<N-1&&grid[i+1][j]==0){\n                            grid[i+1][j]=count_turn+1;\n                            count_last_space--;\n                        }\n                        if(j>0&&grid[i][j-1]==0){\n                            grid[i][j-1]=count_turn+1;\n                            count_last_space--;\n                        }\n                        if(j<N-1&&grid[i][j+1]==0){\n                            grid[i][j+1]=count_turn+1;\n                            count_last_space--;\n                        }\n                    }\n                }\n            }\n        }\n        return count\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/56#issuecomment-1879591121","body":"```\nclass Solution {\npublic:\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {\n        int sum=0;\n        vector<bool> candysigns(candies.size(),1);\n        vector<bool> boxsigns(candies.size(),1);\n        vector<int> getbox;\n        for(int i=0;i<initialBoxes.size();i++){\n            int m=initialBoxes[i];\n            boxsigns[m]=0;\n            if(status[m]==1) {\n                sum+=candies[m];\n                candysigns[m]=0;\n            }\n            if(keys[m].size()!=0){\n                for(int j=0;j<keys[m].size();m++){\n                    if(candysigns[j]!=0) {\n                         sum+=candies[j];\n                         candysigns[j]=0;\n                    }\n                }\n            }\n            if(containedBoxes[m].size()!=0){\n                for(int k=0;k<containedBoxes[m].size();k++){\n                getbox.push_back(containedBoxes[m][k]);\n                if(boxsigns[k]!=0) boxsigns[containedBoxes[m][k]]=1;\n            }\n        }\n        for(int i=0;i<boxsigns.size();i++){\n            if(boxsigns[i]==1){\n                if(candysigns[i]!=0) sum+=candies[i];\n            }\n        }\n        return sum;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/57#issuecomment-1879924443","body":"```\nclass Solution {\npublic:\n    int findRadius(vector<int> &houses, vector<int> &heaters) {\n        int ans = 0;\n        sort(heaters.begin(), heaters.end());\n        for (int house: houses) {\n            int j = upper_bound(heaters.begin(), heaters.end(), house) - heaters.begin();\n            int i = j - 1;\n            int rightDistance = j >= heaters.size() ? INT_MAX : heaters[j] - house;\n            int leftDistance = i < 0 ? INT_MAX : house - heaters[i];\n            int curDistance = min(leftDistance, rightDistance);\n            ans = max(ans, curDistance);\n        }\n        return ans;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/58#issuecomment-1881124525","body":"```\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int size = cost.size();\n        vector<int> spend(size+1, 0);\n        int minCost;\n\n        spend[0] = spend[1] = 0;        \n        for(int index=2; index < size+1; index++){\n            spend[index] = min(spend[index - 1] + cost[index - 1], spend[index - 2] + cost[index - 2]);\n        }\n\n        return spend[size];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/59#issuecomment-1883154203","body":"```\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int size = nums.size();\n        if (size == 1) {\n            return nums[0];\n        }\n        \n        vector<int> count = vector<int>(size, 0);\n        count[0] = nums[0];\n        count[1] = max(nums[0], nums[1]);\n\n        for (int i = 2; i < size; i++) {\n            count[i] = max(count[i - 2] + nums[i], count[i - 1]);\n        }\n        return count[size - 1];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/60#issuecomment-1883459567","body":"```\nclass Solution {\npublic:\n    int findNumberOfLIS(vector<int> &nums) {\n        int n = nums.size(), maxLen = 0, ans = 0;\n        vector<int> dp(n), cnt(n);\n        for (int i = 0; i < n; ++i) {\n            dp[i] = 1;\n            cnt[i] = 1;\n            for (int j = 0; j < i; ++j) {\n                if (nums[i] > nums[j]) {\n                    if (dp[j] + 1 > dp[i]) {\n                        dp[i] = dp[j] + 1;\n                        cnt[i] = cnt[j]; \n                    } else if (dp[j] + 1 == dp[i]) {\n                        cnt[i] += cnt[j];\n                    }\n                }\n            }\n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n                ans = cnt[i]; \n            } else if (dp[i] == maxLen) {\n                ans += cnt[i];\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/61#issuecomment-1887456919","body":"```\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int len1 = text1.length(), len2 = text2.length();\n        vector<vector<int>> lens(len1 + 1, vector<int>(len2 + 1));\n\n        for (int i = 1; i <= len1; i++) {\n            for (int j = 1; j <= len2; j++) {\n                if (text1[i - 1] == text2[j - 1]) {\n                    lens[i][j] = lens[i - 1][j - 1] + 1;\n                } else {\n                    lens[i][j] = max(lens[i - 1][j], lens[i][j - 1]);\n                }\n            }\n        }\n\n        return lens[len1][len2];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/62#issuecomment-1887495610","body":"```\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,1));\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\n            }\n        }\n        return dp[m-1][n-1];\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flipn9":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wabw1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqmmy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-pricity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sclihuiming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"amazeding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tzuikuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ringo1597":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brucezhang-utf-8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luanxing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moin-jer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihua1997":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cuizezhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tiandao043":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"restlessbreeze":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruikiwi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiminren":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saitochen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wtdcai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"albert556":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wuxiaoshawn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zrtch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuzhu096":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whoam-challenge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weisday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"syh-coder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaaller":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyrie96521":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cavecrypto":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cxgbro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erjian96":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-polarbear":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexno1no2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yetfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bwspsu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arinzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mdge":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yin02":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elsa-zhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asur4s":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhihaowan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"apockira":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guowei0223":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuqianyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sj941127":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darwintk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"h-steven":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mischaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wurongronga":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miduoliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyshenzhengkang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y4h2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yoco323":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forschers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shanshuiqiankun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"annabellhyx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwfrankfung":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huibinny":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggmybro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"myleetcodejourney":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"want2333":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"staringwhere":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryanbaiyansong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dou-yu-xuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cs12300":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chiehw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aesir-idun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaldsk12":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hxj2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"for123s":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzhilin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yfu6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mengsixing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"import-ant":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangqianqian202301":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"airwalkers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhumengcheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leonalhq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hjy-u":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"csthaha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zepherust":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feefeefee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hughlin07":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huizsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chanceyliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hshen11":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"horace7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzh0114":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dragonfcl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huifeng248":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sarah11qing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"el1as7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zcytm3000":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xb798298436":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ywang525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"limbo42":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorapocket":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoeyzyzyzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jasonqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lp1506947671":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"texamc2":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joemonkeylee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"northseacoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dominique9898":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wl678":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"meisgithub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sye9286":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fuku-l":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangliqi1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richardtaok":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chocolate-emperor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lydia61":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangjiahuan17":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"seanutf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyong-hub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erquaner":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiujingxukong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x1aox1a":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"drinkmorekaik":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dinjufen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzmt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"munmust":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan-jie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hktangshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpbc007":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linlizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"krabbejing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"firehaosky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chao-cc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cruiseyugh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quieter2018":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jadeliu13":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoq777":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangyanlineu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxiner":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufanzh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"franciszq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangqinsen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"manwzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"soso1105":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pkuphy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenya-zhu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wty9sky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skyoct":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingzxy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaodingc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jyjsunny":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aoxiangw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"enrilwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aswrise":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aneureka":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ljqchlsw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jingyuzhou123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dianlandu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jameswangxin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhenxied":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuozhouzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shin-guid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bochengwan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyo-tom":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uratora":[null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831707707","body":"### 思路\n* 层序遍历，用一个队列管理两个二叉树的节点，依次对比相应节点，先对比结构，再对比数值\n* 对比实现:\n1. 同为空节点，无需将其子节点加入队列\n2. 其中任一为空节点，两树不相等\n3. 值不等，两树不等\n4. 两节点相等，将其子节点按顺序加入队列\n### 代码\n```c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n     if(!p && !q)\n         return true;\n     else if(!p || !q)\n         return false;\n      queue<TreeNode*> que;\n      que.push(p);\n      que.push(q);\n      while(!que.empty())\n      {\n       TreeNode* lefttree = que.front();que.pop();\n       TreeNode* righttree = que.front();que.pop();\n       if(!lefttree&&!righttree) \n         continue;\n       if(!lefttree||!righttree||(lefttree->val!=righttree->val))\n         return false;\n       que.push(lefttree->left);\n       que.push(righttree->left);\n       que.push(lefttree->right);\n       que.push(righttree->right);\n      }\n      return true;\n}\n};\n```\n### 复杂度\n* 时间: O(2*min(n1,n2))\n* 空间: O(2*min(n1,n2))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/42#issuecomment-1869461525","body":"### 思路\n二分求值，但不是具体的值，通过小于该值的差值的对数来判断，更新左右边界\n### 代码\n```c++\nbool possible(vector<int>& nums, int d, int k)\n{\n    const int N = nums.size();\n    long count = 0; \n    int i = 0, j = 0;\n    while (i < N || j < N)\n    {\n        while (j < N && nums[j] - nums[i] <= d) j++;\n        count += j - i - 1;\n        i++;\n    }\n    return count >= k;\n};\nint solve(vector<int>& nums, int k) {\n    const int N = nums.size();\n    sort(begin(nums), end(nums));\n    k += 1;    \n    int left = 0, right = nums[N - 1] - nums[0];\n    while (left < right)\n    {\n        int guess = left + (right - left) / 2; \n        if (possible(nums, guess, k))\n            right = guess;\n        else\n            left = guess + 1;\n    }\n    return left;\n}\n```\n### 复杂度\n* 时间：O(nlogn)排序\n* 空间：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guitarys":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sosdogecoin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lrwhc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwewwt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyk1337":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyu1131":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"diana21170648":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"61hhh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quaaaaaack":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acy925":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bi9potato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaoygcq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"catkathy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yqycs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuxinyu-znb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freesan44":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo660":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sencc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"randong22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beginner-jamji":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yzhyzhyzh123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunstrongchina":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dongzegithub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"metsystem":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miller-em":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorian-byte":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yizhewill":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qiaojunch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhouliuhuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beanza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kingxiaozhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ygnauh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzbwzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iambigchen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weiboshi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"master-guang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jennyjgao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangjay408":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chang-you":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rocjemaintiendrai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ainfinitedz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengistchan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiyingc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyli4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"momogir":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jamjid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freeroo2":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1812927006","body":"### 思路\r\n\r\n直接模拟竖式加法，没有想到reverse，代码写的有点啰嗦\r\n\r\n### 代码\r\n\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n            int length = num.length;\r\n            List<Integer> res = new ArrayList<>();\r\n            int plus = 0;\r\n            int i = length - 1;\r\n            for (; i >= 0 && k > 0; i--) {\r\n                int t = k % 10;\r\n                k /= 10;\r\n                num[i] += t + plus;\r\n                plus = 0;\r\n                if (num[i] >= 10) {\r\n                    plus = 1;\r\n                    num[i] %= 10;\r\n                }\r\n            }\r\n            // 如果k=0，说明k位数小于num，可能会进位\r\n            if (k == 0) {\r\n                if (plus == 1) {\r\n                    while (i >= 0 && plus == 1) {\r\n                        num[i]++;\r\n                        plus = 0;\r\n                        if (num[i] >= 10) {\r\n                            plus = 1;\r\n                            num[i] %= 10;\r\n                        }\r\n                        i--;\r\n                    }\r\n                    if (plus == 1) {\r\n                        res.add(1);\r\n                    }\r\n                }\r\n                for (int j = 0; j < length; j++) {\r\n                    res.add(num[j]);\r\n                }\r\n            }\r\n            // 如果i<0，k>0,说明k位数大于num\r\n            else if (i < 0 && k > 0) {\r\n                k += plus;\r\n                Stack<Integer> st = new Stack<>();\r\n                while (k > 0) {\r\n                    st.add(k % 10);\r\n                    k /= 10;\r\n                }\r\n                while(!st.empty()) {\r\n                    res.add(st.pop());\r\n                }\r\n                for (int j = 0; j < length; j++) {\r\n                    res.add(num[j]);\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1816416461","body":"### 思路\n使用last记录上次遇到c的位置，从左向右遍历字符串，只需在每次遇到c时更新last~当前c之间的元素的距离\n注意遇到第一个c之前的所有最短距离只能是第一个c的index减去i\n注意只有在遇到c时才会更新上一个区间，故可能会有最后一个c之后到最后一个字符这个区间没有被更新，需要处理\n\n### 代码\n\n\n```java\n    class Solution {\n        public int[] shortestToChar(String s, char c) {\n            int last = -1;\n            int n = s.length();\n            int[] ans = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (s.charAt(i) == c) {\n                    int j = last + 1;\n                    while (j <= i) {\n                        if (last == -1) {\n                            ans[j] = i - j;\n                        } else {\n                            ans[j] = Math.min(i - j, j - last);\n                        }\n                        j++;\n                    }\n                    last = i;\n                }\n            }\n            if (last != n - 1) {\n                for (int j = last + 1; j < n; j++) {\n                    ans[j] = j - last;\n                }\n            }\n            return ans;\n        }\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1) 除返回结果外不需要额外空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817505207","body":"```java\r\nclass CustomStack {\r\n        private int[] array;\r\n        private int pointer; // 指向下一个栈顶元素该放入的下标\r\n\r\n        public CustomStack(int maxSize) {\r\n            array = new int[maxSize];\r\n            pointer = 0;\r\n        }\r\n\r\n        public void push(int x) {\r\n            if (pointer < array.length) {\r\n                array[pointer] = x;\r\n                pointer++;\r\n            }\r\n        }\r\n\r\n        public int pop() {\r\n            int res = -1;\r\n            if (pointer > 0) {\r\n                res = array[pointer - 1];\r\n                pointer--;\r\n            }\r\n            return res;\r\n        }\r\n\r\n        public void increment(int k, int val) {\r\n            if (k > pointer) {\r\n                for (int i = 0; i < pointer; i++) {\r\n                    array[i] = array[i] + val;\r\n                }\r\n            } else {\r\n                for (int i = 0; i < k; i++) {\r\n                    array[i] = array[i] + val;\r\n                }\r\n            }\r\n        }\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817881830","body":"### 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        return dfs(s, 0)[0];\n    }\n    private String[] dfs(String s, int i) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        while(i < s.length()) {\n            if(s.charAt(i) >= '0' && s.charAt(i) <= '9') \n                multi = multi * 10 + Integer.parseInt(String.valueOf(s.charAt(i))); \n            else if(s.charAt(i) == '[') {\n                String[] tmp = dfs(s, i + 1);\n                i = Integer.parseInt(tmp[0]);\n                while(multi > 0) {\n                    res.append(tmp[1]);\n                    multi--;\n                }\n            }\n            else if(s.charAt(i) == ']') \n                return new String[] { String.valueOf(i), res.toString() };\n            else \n                res.append(String.valueOf(s.charAt(i)));\n            i++;\n        }\n        return new String[] { res.toString() };\n    } \n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1819157526","body":"### 思路\n用两个栈，一个输入栈一个输出栈。每次入队操作直接push到输入栈，每次遇到pop/peek就尝试从输出栈输出，若没有元素可输出了，就将输入栈的所有元素全部出栈并依次push到输出栈中，这样输出栈就可以按照队列从前往后的顺序出栈了。\n### 代码\n```java\nclass MyQueue {\n        private Stack<Integer> in;\n        private Stack<Integer> out;\n\n        public MyQueue() {\n            in = new Stack<>();\n            out = new Stack<>();\n        }\n\n        public void push(int x) {\n            in.push(x);\n        }\n\n        public int pop() {\n            if (out.empty()) {\n                in2out();\n            }\n            return out.pop();\n        }\n\n        public int peek() {\n            if (out.empty()) {\n                in2out();\n            }\n            return out.peek();\n        }\n\n        public boolean empty() {\n            return in.isEmpty() && out.isEmpty();\n        }\n\n        public void in2out() {\n            while (!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1820154313","body":"### 思路\n- 如果遇到比当前栈顶大的数，就压入栈\n- 如果遇到比当前栈顶小的数，就将栈中比该元素大的数清空，然后将被清空的数中最大的值（即原栈顶）压入栈中，也就是将num合并到当前块中\n- 也就是说取每一个块的最大值作为代表放在栈中，最后栈有多少个单调非递减元素就有多少个块\n### 代码\n```java\npublic int maxChunksToSorted(int[] arr) {\n            Stack<Integer> stack = new Stack<>();\n            for (int num :\n                    arr) {\n                if (stack.empty() || num >= stack.peek()) {\n                    stack.push(num);\n                } else {\n                    int max_num = stack.pop();\n                    while (!stack.empty() && stack.peek() > num) {\n                        stack.pop();\n                    }\n                    stack.push(max_num);\n                }\n//                System.out.println(stack.toString());\n            }\n            return stack.size();\n        }\n```\n### 复杂度\n时间复杂度 O(n)\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822705853","body":"### 思路\n双指针找到倒数第k个节点\n### 代码\n```java        \npublic ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        ListNode tail = head;\n        // tail先走k%n步\n        for (int i = 0; i < k; i++) {\n            if (tail.next == null) {\n                tail = head;\n            } else {\n                tail = tail.next;\n            }\n        }\n     \n        ListNode pre = head;\n        while (tail.next != null) {\n            tail = tail.next;\n            pre = pre.next;\n        }\n        // 截断、拼接pre后面的节点至表前\n        tail.next = head;\n        head = pre.next;\n        pre.next = null;\n        return head;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1823814580","body":" ```java\r\nclass Solution {\r\n        public ListNode swapPairs(ListNode head) {\r\n            if (head == null || head.next == null)\r\n                return head;\r\n            ListNode pre = null;\r\n            ListNode node1 = head, node2 = head.next;\r\n            head = node2;\r\n            while (node1 != null && node2 != null) {\r\n//                System.out.println(\"node1 \" + node1.val + \", node2 \" + node2.val);\r\n                ListNode nxt = node2.next;\r\n                node2.next = node1;\r\n                node1.next = nxt;\r\n                if (pre != null) {\r\n                    pre.next = node2;\r\n                }\r\n                pre = node1;\r\n                node1 = node1.next;\r\n                if (node1 != null) {\r\n                    node2 = node1.next;\r\n                }\r\n            }\r\n            return head;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/10#issuecomment-1825315221","body":"### 思路\n给出的链表的元素顺序就是BST的中序遍历的顺序，所以在构造BST时可以按照中序遍历的形式来构造，维护一个全局的curr来指明按照中序遍历的顺序下次填充节点是哪个。\n### 代码\n```java\nclass Solution {\n    private ListNode curr;\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        curr = head;\n        int length = 0;\n        while(head != null) {\n            head = head.next;\n            length++;\n        }\n        return buildBst(0, length-1);\n    }\n    public TreeNode buildBst(int start, int end) {\n        if(start>end) {\n            return null;\n        }\n        int mid = (start + end) >> 1;\n        TreeNode left = buildBst(start, mid - 1);\n        TreeNode root = new TreeNode(curr.val);\n        curr = curr.next;\n        TreeNode right = buildBst(mid+1, end);\n        root.left = left;\n        root.right = right;\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/11#issuecomment-1826285730","body":"### 思路\n首先计算 链A和链B的长度差x，并判断两条链链尾是否为同一节点\n假设A比B长x个节点，且二者有交点\n两个指针分别指向A和B，pA先往前走x步，然后两个指针开始一起走，直到相遇\n### 代码\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA, pB = headB, tailA = null, tailB = null;\n        int la = 0, lb = 0;\n        while(pA!=null) {\n            if(pA.next==null) {\n                tailA = pA;\n            }\n            pA = pA.next;\n            la++;\n        }\n        while(pB!=null) {\n            if(pB.next==null) {\n                tailB = pB;\n            }\n            pB = pB.next;\n            lb++;\n        }\n        if(tailA!=tailB) {\n            return null;\n        }\n        pA = headA;\n        pB = headB;\n        if(la>=lb) {\n            int x = la - lb;\n            while(x>0) {\n                pA = pA.next;\n                x--;\n            }\n        } else {\n            int x = lb - la;\n             while(x>0) {\n                pB = pB.next;\n                x--;\n            }\n        }\n        while(pA!=null && pB!=null) {\n            if(pA==pB) {\n                return pA;\n            }\n            pA = pA.next;\n            pB = pB.next;\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826821209","body":"### 代码\n```java    \npublic ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        while (true) {\n            if (fast == null || fast.next == null) return null;\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) break;\n        }\n        fast = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return fast;\n    }\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1830070314","body":"```java\n    class Solution {\n\n        public int maxDepth(TreeNode root) {\n            if (root == null) {\n                return 0;\n            }\n            int left = maxDepth(root.left);\n            int right = maxDepth(root.right);\n            return Math.max(left, right) + 1;\n        }\n\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1847299398","body":"```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        } else if (p == null || q == null) {\r\n            return false;\r\n        } else if (p.val != q.val) {\r\n            return false;\r\n        } else {\r\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1834045734","body":"### 代码\n```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n    public int dfs(TreeNode root, int val) {\n        val = val * 10 + root.val;\n        if (root.left == null && root.right==null) {\n            return val;\n        }\n        int total = 0;\n        if(root.left!=null) {\n            total += dfs(root.left, val);\n        }\n        if(root.right!=null) {\n            total += dfs(root.right, val);\n        }\n        return total;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/17#issuecomment-1836201913","body":"### 思路\n深度优先搜索，先序遍历寻找最大深度层第一次出现的值\n### 代码\n```java\nclass Solution {\n    private int maxDepth, res;\n    public int findBottomLeftValue(TreeNode root) {\n        maxDepth = 0;\n        res = 0;\n        dfs(root, 1);\n        return res;\n    }\n    public void dfs(TreeNode root, int depth) {\n        if(root==null) {\n            return;\n        }\n        if(maxDepth < depth) {\n            res = root.val;\n            maxDepth = depth;\n        }\n        dfs(root.left, depth+1);\n        dfs(root.right, depth+1);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1837183802","body":"### 思路\n层序遍历\n### 代码\n```java\npublic class Codec {\n\n        // Encodes a tree to a single string.\n        public String serialize(TreeNode root) {\n            if (root == null) return \"[]\";\n            List<Integer> arr = new ArrayList<>();\n            Queue<TreeNode> que = new LinkedList<>();\n            que.add(root);\n            StringBuilder builder = new StringBuilder(\"[\");\n            while (!que.isEmpty()) {\n                TreeNode t = que.poll();\n                if (t != null) {\n                    builder.append(t.val + \",\");\n                    que.add(t.left);\n                    que.add(t.right);\n                } else {\n                    builder.append(\"null,\");\n                }\n            }\n            builder.deleteCharAt(builder.length() - 1);\n            builder.append(\"]\");\n            return builder.toString();\n        }\n\n        // Decodes your encoded data to tree.\n        public TreeNode deserialize(String data) {\n            if (data.equals(\"[]\")) return null;\n            // 去掉首尾的方括号，并将字符串按逗号分隔\n            String[] elements = data.substring(1, data.length() - 1).split(\",\");\n            Queue<TreeNode> queue = new LinkedList<>();\n            TreeNode root = new TreeNode(Integer.parseInt(elements[0]));\n            queue.offer(root);\n            int i = 1;\n            while (!queue.isEmpty() && i < elements.length) {\n                TreeNode node = queue.poll();\n                if (!elements[i].equals(\"null\")) {\n                    node.left = new TreeNode(Integer.parseInt(elements[i]));\n                    queue.add(node.left);\n                }\n                i++;\n                if (!elements[i].equals(\"null\")) {\n                    node.right = new TreeNode(Integer.parseInt(elements[i]));\n                    queue.add(node.right);\n                }\n                i++;\n            }\n            return root;\n        }\n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/19#issuecomment-1837516140","body":"### 思路\n先dfs记录所有节点的信息，然后对所有节点按照优先级 列>行>值 排序，最后遍历排完序的所有节点列表，将同列的放入同一个list，合并所有list到答案中。\n### 代码\n```java\nclass Solution {\n        public List<List<Integer>> verticalTraversal(TreeNode root) {\n            List<int[]> nodes = new ArrayList<>();\n            dfs(root, 0, 0, nodes);\n            Collections.sort(nodes, new Comparator<int[]>() {\n                @Override\n                public int compare(int[] o1, int[] o2) {\n                    if (o1[0] != o2[0]) return o1[0] - o2[0];\n                    else if (o1[1] != o2[1]) return o1[1] - o2[1];\n                    else return o1[2] - o2[2];\n                }\n            });\n            int size = 0;\n            int lastCol = Integer.MIN_VALUE;\n            List<List<Integer>> ans = new ArrayList<>();\n            for (int[] node : nodes) {\n                int col = node[0], row = node[1], value = node[2];\n                if (col != lastCol) {\n                    List<Integer> temp_arr = new ArrayList<>();\n                    lastCol = col;\n                    ans.add(temp_arr);\n                    size++;\n                }\n                ans.get(size - 1).add(value);\n\n            }\n            return ans;\n\n        }\n\n        public void dfs(TreeNode root, int row, int col, List<int[]> nodes) {\n            if (root == null) {\n                return;\n            }\n            nodes.add(new int[]{col, row, root.val});\n            dfs(root.left, row + 1, col - 1, nodes);\n            dfs(root.right, row + 1, col + 1, nodes);\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1838827741","body":"```java \nclass Solution {\n        public int[] twoSum(int[] nums, int target) {\n            HashMap<Integer, Integer> map = new HashMap<>();\n            for (int i = 0; i<nums.length; i++) {\n                var num = nums[i];\n                if (map.containsKey(target - num)) {\n                   return new int[]{i, map.get(target-num)};\n                }\n                map.put(num, i);\n            }\n            return new int[0];\n        }\n    }\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/22#issuecomment-1843153538","body":"```java\n    class Solution {\n        public int numberOfBoomerangs(int[][] points) {\n            int ans = 0;\n            for (int[] point :\n                    points) {\n                Map<Integer, Integer> map = new HashMap<>();\n                for (int[] q :\n                        points) {\n                    int dis = (point[0] - q[0]) * (point[0] - q[0]) + (point[1] - q[1]) * (point[1] - q[1]);\n                    map.put(dis, map.getOrDefault(dis, 0) + 1);\n                }\n                for (int m :\n                        map.values()) {\n                    ans += m * (m - 1);\n                }\n            }\n            return ans;\n        }\n    }\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849254964","body":"### 代码\n```java\nclass Solution {\n        public int removeDuplicates(int[] nums) {\n            int lastNum = nums[0], cnt = 1, length = nums.length;\n            for (int i = 1; i < length; i++) {\n                while (i < length && nums[i] == lastNum) {\n                    i++;\n                }\n                if (i < length) {\n                    nums[cnt] = nums[i];\n                    lastNum = nums[cnt];\n                    cnt++;\n                }\n            }\n            return cnt;\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1851721489","body":"### 代码\n```java\n    class Solution {\n        public int searchInsert(int[] nums, int target) {\n            int left = 0, right = nums.length - 1;\n            while (left <= right) {\n                int mid = (right - left >> 2) + left;\n                if (nums[mid] < target) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n            return left;\n        }\n    }\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/31#issuecomment-1858048025","body":"### 代码\n```java\nclass Solution {\n        public boolean possibleBipartition(int n, int[][] dislikes) {\n            int[] fa = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                fa[i] = i;\n            }\n            List<Integer>[] g = new List[n + 1];\n            for (int i = 0; i <= n; ++i) {\n                g[i] = new ArrayList<Integer>();\n            }\n            for (int[] p : dislikes) {\n                g[p[0]].add(p[1]);\n                g[p[1]].add(p[0]);\n            }\n            for (int i = 1; i <= n; ++i) {\n                for (int j = 0; j < g[i].size(); ++j) {\n                    unit(g[i].get(0), g[i].get(j), fa);\n                    if (isconnect(i, g[i].get(j), fa)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        public void unit(int x, int y, int[] fa) {\n            x = findFather(x, fa);\n            y = findFather(y, fa);\n            if (x != y) {\n                fa[x] = y;\n            }\n        }\n\n        public boolean isconnect(int x, int y, int[] fa) {\n            x = findFather(x, fa);\n            y = findFather(y, fa);\n            return x == y;\n        }\n\n        public int findFather(int x, int[] fa) {\n            int a = x;\n            while (x != fa[x]) {\n                x = fa[x];\n            }\n            while (a != fa[a]) {\n                int z = a;\n                a = fa[a];\n                fa[z] = x;\n            }\n            return x;\n        }\n    }\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/36#issuecomment-1864271969","body":"### 代码\r\n```java\r\nclass Solution {\r\n        public int minCharacters(String a, String b) {\r\n            int[] c1 = new int[26], c2 = new int[26];\r\n            int n = a.length(), m = b.length(), ans = Integer.MAX_VALUE;\r\n            for (char c : a.toCharArray()) {\r\n                c1[c - 'a']++;\r\n            }\r\n            for (char c : b.toCharArray()) {\r\n                c2[c - 'a']++;\r\n            }\r\n            for (int i = 0; i < 26; i++) {\r\n                int r1 = 0, r2 = 0;\r\n                // 3\r\n                int ra = n - c1[i], rb = m - c2[i];\r\n                ans = Math.min(ans, ra + rb);\r\n                if (i == 0) continue; // 不存在严格小于a的字符\r\n                // 1\r\n                for (int j = i; j < 26; j++) {\r\n                    r1 += c1[j];\r\n                }\r\n                for (int j = 0; j < i; j++) {\r\n                    r1 += c2[j];\r\n                }\r\n                // 2\r\n                for (int j = i; j < 26; j++) {\r\n                    r2 += c2[j];\r\n                }\r\n                for (int j = 0; j < i; j++) {\r\n                    r2 += c1[j];\r\n                }\r\n                ans = Math.min(ans, Math.min(r1, r2));\r\n            }\r\n            return ans;\r\n\r\n        }\r\n    }\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/38#issuecomment-1867739006","body":"### 代码\n```java\n    class Solution {\n        public int mySqrt(int x) {\n            if (x == 0 || x == 1) return x;\n            int left = 1, right = x, ans = -1;\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                if (mid <= x / mid) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n            return left - 1;\n\n        }\n    }\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/44#issuecomment-1870911252","body":"### 代码\n```java\nclass Solution {\n        public int maxVowels(String s, int k) {\n            int left = 0, right = 0, ans = -1, cnt = 0, length = s.length();\n            while (right < k) {\n                if (isVowel(s.charAt(right))) {\n                    cnt++;\n                }\n                right++;\n            }\n            ans = Math.max(ans, cnt);\n            while (right < length) {\n                if (isVowel(s.charAt(left))) {\n                    cnt--;\n                }\n                left++;\n                if (isVowel(s.charAt(right))) {\n                    cnt++;\n                }\n                right++;\n                ans = Math.max(ans, cnt);\n            }\n            return ans;\n        }\n\n        private boolean isVowel(char c) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                return true;\n            }\n            return false;\n        }\n    }\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/49#issuecomment-1873997544","body":"### 代码\n```java\nclass Solution {\n        private int[] hours = {1, 2, 4, 8};\n        private int[] minites = {1, 2, 4, 8, 16, 32};\n        private List<String> ans = new ArrayList<>();\n\n        private void backtrack(int n, int start, int hour, int minite) {\n            if (n == 0) {\n                if (hour > 11 || minite > 59) {\n                    return;\n                }\n                String time = String.format(\"%d:%02d\", hour, minite);\n                ans.add(time);\n                return;\n            }\n            for (int i = start; i < 10; i++) { //从待选集合中选择\n                if (i < 4) { //选时钟\n                    if (hour + hours[i] < 12) { //剪枝\n                        backtrack(n - 1, i + 1, hour + hours[i], minite);\n                    }\n                } else { //选分钟\n                    if (minite + minites[i - 4] < 60) { //剪枝\n                        backtrack(n - 1, i + 1, hour, minite + minites[i - 4]);\n                    }\n                }\n            }\n        }\n\n        public List<String> readBinaryWatch(int turnedOn) {\n            backtrack(turnedOn, 0, 0, 0);\n            return ans;\n        }\n    }\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/57#issuecomment-1880087457","body":"### 代码\nclass Solution:\n    def solve(self, root):\n        q = collections.deque([(root, 0)])\n        d = {}\n        while q:\n            cur, pos = q.popleft()\n            if pos not in d:\n                d[pos] = cur.val\n            if cur.left:\n                q.append((cur.left, pos - 1))\n            if cur.right:\n                q.append((cur.right, pos + 1))\n        return list(map(lambda x:x[1], sorted(d.items(),key=lambda x: x[0])))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ycan253":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1813575541","body":"## 思路\n\n1. 从数组的最高位开始（对应的是数字的最低位），使用数K和该位相加，得到的和的最低位就是所要求的最低位。\n\n2. 对这个和右移1位，丢弃掉最低位\n3. 重复这个过程，直到处理完数组为止\n\n处理完数组后，还需要对剩下的和进行处理，有两种情况：\n\n1. 剩下的和没有进位，无需处理，如最高为数组为[1]，数位8，则和为9，没有进位\n2. 剩下的和产生了进位，如\n   - 最高位数组为[7], 数为7，则和为14\n   - 最高位数组为[7]，数为97，则和为104（也对应数组长度为1的情况）\n\n​\t这两种情况，需要把这个和列表化。\n\n## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        rem = k\n        for i in range(len(num) - 1, -1, -1):\n            num[i], rem = (rem + num[i]) % 10, (rem + num[i]) // 10\n            \n    \t# 这部分注释是分情况的代码\n        # if rem == 0: # 最高位没有进位\n        #     return num  \n        # elif 0 < rem < 10: # 最高位加法结果有进位\n        #     return [rem] + num\n        # else: # 处理num长度为1的情况\n        #     res = []\n        #     while rem > 0:\n        #         res = [rem % 10] + res\n        #         rem = rem // 10\n        #     return res + num\n         \n        # 下面的代码是统一处理的情况\n        # 处理有最高位和有进位的情况\n        while rem > 0:\n            num = [rem % 10] + num\n            rem = rem // 10\n        return num \n\n\n```\n\n## 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1816261879","body":"## 思路\n\n1. 找出字符c对应的下标数组\n2. 对str中的每个元素，求出该元素和下标数组的最小差值\n3. 把最小差值加入到结果中\n\n## 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # 找出字符c对应的下标数组\n        e_idx = []\n        for i in range(len(s)):\n            if s[i] == c:\n                e_idx.append(i)\n\n        # 对str中的每个字符，求它和e_idx的差的最小值加入到结果中\n        res, e_idx_len = [], len(e_idx)\n        for i in range(len(s)):\n            min_diff = abs(i - e_idx[0])\n            for j in range(1, e_idx_len):\n                diff = abs(i - e_idx[j])\n                if diff < min_diff:\n                    min_diff = diff\n            res.append(min_diff)\n                \n        return res\n```\n\n## 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817414151","body":"## 思路\n\n因为栈的大小固定，所以在构造函数中直接生成maxSize大小的列表。对于这个栈，考虑以下不变式：\n\n1. self.top总是指向下一个入栈的位置，且self.top的大小也是栈中元素的个数\n2. 栈顶元素的下标总是self.top- 1\n3. 空栈即self.top为0\n\n## 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxSize  = maxSize\n        self.top = 0\n        self.items = [0 for i in range(maxSize)]\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        # 栈没有慢，则可以入栈\n        if self.top < self.maxSize:\n            self.items[self.top] = x\n            self.top += 1\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.top == 0: # 栈为空则返回-1\n            return -1\n        else:\n            removedItem = self.items[self.top - 1]\n            self.top -= 1\n            return removedItem\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(k, self.top)):\n            self.items[i] += val\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 复杂度分析\n\n空间复杂度：O(maxSize)\n\n时间复杂度：\n\n- 构造函数: O(maxSize)\n- push/pop:O(1)\n- increment: O(min(k, top))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817789340","body":"## 思路\r\n\r\n参考“Dijkstra 的双栈算术表达式求值算法“，《算法》第四版P80\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []  # (str, int) 记录之前的字符串和括号外的上一个数字\r\n        num = 0\r\n        res = \"\"  # 实时记录当前可以提取出来的字符串\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c) # 计算k的值\r\n            elif c == \"[\":\r\n                stack.append((res, num)) # 碰到左括号，把之前的res和num入栈\r\n                res, num = \"\", 0         # 入栈后，清除res和num，用于下次记录\r\n            elif c == \"]\":  # 碰到右括号，出栈并计算需要的字符串\r\n                top = stack.pop()\r\n                res = top[0] + res * top[1]\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n时间复杂度:O(n)\r\n\r\n空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818262280","body":"## 思路\r\n没有使用双栈实现队列，双栈实现可参考 [232. 用栈实现队列（清晰图解）](https://leetcode.cn/problems/implement-queue-using-stacks/)\r\n\r\n## 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.deque = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.deque.insert(0, x)\r\n\r\n    def pop(self) -> int:\r\n        return self.deque.pop()\r\n\r\n    def peek(self) -> int:\r\n        return self.deque[len(self.deque) - 1]\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.deque) == 0\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n```\r\n\r\n## 复杂度分析\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1820787691","body":"## 思路\n\n有点难，参考了，仅供打卡\n\n(https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solutions/22785/zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-deng-jie-/)[最多能完成排序的块 II]\n\n\n\n## 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n```\n\n\n\n## 复杂度分析","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822648764","body":"## 思路\n\n1. 计算链表总体长度，得到链表末尾节点的指针，连接至头\n2. 找到倒数第k个节点，把这个节点和下一个节点当做新的头尾\n\n## 代码   \n\n```python\n class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        p, list_len = head, 1\n        while p.next:\n            list_len += 1\n            p = p.next\n        tail = p\n    p, k = head, k % list_len\n    if k == 0: return head\n\n    for _ in range(list_len - k - 1):\n        p = p.next\n    new_tail, new_head = p, p.next\n    new_tail.next = None\n    tail.next = head\n    return new_head\n```\n\n## 复杂度分析\n\n时间：O(n)\n\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1823917462","body":"## 思路\n\n使用递归进行处理\n\n1. 链表为空或长度为1，那么直接返回原链表即可\n2. 链表长度大于1，即为2及以上时，假设递归能够正确解决问题（the recursion leap of faith）\n   - 交换头两个元素\n   - 把交换后第二个元素的next设置为 swapPairs(head.next.next)\n\ndone！\n\n## 代码\n\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None: # 链表长度为0或1时\n            return head\n\n        res = self.swapPairs(head.next.next) # 保存在子链表上进行递归调用返回的链表头\n        # 下面是交换头两个链表节点\n        res_head = head.next \n        head.next = res\n        res_head.next = head\n        return res_head\n```\n\n\n\n## 复杂度分析\n\n时间：O(n)\n\n空间：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1827174527","body":"```python\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.data = dict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        #  get操作后先pop再插入，相当于进行一次使用\n        s = self.data.get(key, -1)\n        if s != -1:\n            self.data.pop(key)\n            self.data[key] = s\n        return s\n\n    def put(self, key: int, value: int) -> None:\n        #  key存在，更新，再次进行使用\n        if key in self.data:\n            self.data.pop(key)\n            self.data[key] = value\n        else:\n            # 判断容量是否达到capacity，未达到，直接插入\n            if len(self.data) < self.capacity:\n                self.data[key] = value\n            else:\n                #  达到capacity，将第一个也就是要求的最久未使用的逐出pop\n                k = next(iter(self.data))\n                self.data.pop(k)\n                self.data[key] = value\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831279239","body":"## 思路\n\n两个树要相同，那么当前节点要相同且对应的左右子树需要相同。使用递归可以很容易解决。\n\n## 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) \n```\n\n## 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1833697412","body":"## 思路\n利用递归从根节点到叶节点计算累计值，因为根节点为数字的最高位，需要利用到辅助函数\n\n## 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def helper(root, res): # 辅助函数\n            if root is None:      # 根节点为空，直接返回0\n                return 0\n            \n            res = 10 * res + root.val # 计算到达当前根节点时的值\n            if root.left is None and root.right is None: # 如果为叶节点了，返回上面求的值\n                return res\n\n            # 否则需要继续向下，分别求出左右子树的代表的数字值并求和\n            return helper(root.left, res) + helper(root.right, res)\n        \n        return helper(root, 0) # 启动递归函数\n```\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1837138313","body":"```python\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n\n        def dfs(node):\n            if node:\n                vals.append(str(node.val))\n                dfs(node.left)\n                dfs(node.right)\n            else:\n                vals.append(\"#\")\n\n        vals = []\n        dfs(root)\n        return \",\".join(vals)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n\n        def dfs():\n            v = next(vals)\n            if v == \"#\":\n                return None\n            node = TreeNode(int(v))\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        vals = iter(data.split(\",\"))\n        return dfs()\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1838467142","body":"```python\\\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n = len(nums)\n        mp = {}\n        for i in range(n):\n            t = target - nums[i]\n            if t in mp:\n                return [mp[t], i]\n            # 存放nums[i]\n            mp[nums[i]] = i\n        return []\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/22#issuecomment-1842236934","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        point_num = len(points)\n        for i in range(point_num):\n            hashmap = {}\n            for j in range(point_num):\n                if i==j: continue\n                num = (points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2\n                hashmap[num] = hashmap[num] + 1 if num in hashmap else 1\n            for key in hashmap:\n                res += hashmap[key] * (hashmap[key] - 1)\n        return res\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/24#issuecomment-1847188409","body":"class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        allWords = collections.Counter(words)\n        wordNum = len(words)\n        wordLen = len(words[0])\n        res = []\n        for i in range(len(s) - wordNum * wordLen + 1):\n            subWords = collections.defaultdict(int)\n            index = i\n            while index < i + wordNum * wordLen:\n                curWord = s[index: index + wordLen]\n                if curWord not in allWords or subWords[curWord] == allWords[curWord]:\n                    break\n                subWords[curWord] += 1\n                index += wordLen\n            if index == i + wordNum * wordLen:\n                res.append(i)\n        return res","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/26#issuecomment-1848801169","body":"## 思路\n使用快慢指针，快指针每次走两步，慢指针每次走一步，当块指针达到链表末尾时，慢指针就指向中\n\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = head\n        slow = head\n\n        while fast != None and fast.next != None:\n            fast = fast.next.next\n            slow = slow.next\n\n        return slow\n```\n\n## 复杂度分析\n- 时间： O(N)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849888636","body":"## 思路\n使用快慢指针进行处理\n- 慢指针用来指向 [a[0]，...，a[n-1]]中的第n-1项，其中 [a[0]，...，a[n-1]]表示去除重复元素后的数组\n- 快指针用来指向[a[n],...a[N-1]]，用来指向没有被处理的项\n- 初始时，slow=fast=0\n- 执行过程一旦发现 a[fast] ！= a[slow]，那么就需要把 a[fast]赋值给a[slow+1]\n\n## 代码\n```python\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) == 0:\n            return 0\n\n        slow, fast = 0, 0\n\n        while fast < len(nums):\n            if nums[fast] != nums[slow]:\n                slow += 1\n                nums[slow] = nums[fast]\n                \n            fast += 1\n        \n        return slow + 1\n```\n\n## 复杂度分析\n- 时间：O(n)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1851398803","body":"## 思路\n二分查找\n\n## 代码\n```python\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            elif nums[mid] > target:\n                right = mid - 1 \n        \n        // 运行到这里，就说明没有找到\n        return left\n```\n\n### 复杂度分析\n时间：O(log n)\n空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/30#issuecomment-1855367469","body":"```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int: \n        t = [set() for _ in range(n)]\n        for a, b in trust: \n            t[a-1].add(b)\n\n        possiblePerson = [] \n        for i in range(n):\n            if len(t[i]) == 0:\n                possiblePerson.append(i)\n\n        for k in possiblePerson:\n            isJudge = True\n            for i in range(n):\n                if i != k:\n                    if k+1 not in t[i]:\n                        isJudge = False\n                        break\n            if isJudge:\n                return k+1\n        return -1\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/33#issuecomment-1859060960","body":"class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        h=collections.Counter(moves)\n        if h['U']==h['D'] and h['L']==h['R']:\n            return True\n        return False","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/35#issuecomment-1861950381","body":"class Solution:\n    def numberOfRounds(self, startTime: str, finishTime: str) -> int:\n        # 转化为分钟\n        t0 = 60 * int(startTime[:2]) + int(startTime[3:])\n        t1 = 60 * int(finishTime[:2]) + int(finishTime[3:])\n        if t1 < t0:\n            # 此时 finishTime 为第二天\n            t1 += 1440\n        # 第一个小于等于 finishTime 的完整对局的结束时间\n        t1 = t1 // 15 * 15\n        return max(0, (t1 - t0)) // 15","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/37#issuecomment-1865503227","body":"```java\nclass Solution {\n    private static int[] aux; // 归并所需的辅助数组\n    public int[] sortArray(int[] nums) {\n        aux = new int[nums.length]; // 一次性分配空间\n        sort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    private static void sort(int[] a, int lo, int hi) { // 将数组a[lo..hi]排序\n        if (hi <= lo) return;\n        int mid = lo + (hi - lo)/2;\n        sort(a, lo, mid); // 将左半边排序\n        sort(a, mid+1, hi); // 将右半边排序\n        merge(a, lo, mid, hi); // 归并结果（代码见“原地归并的抽象方法”）\n    }\n\n    public static void merge(int[] a, int lo, int mid, int hi) { // 将a[lo..mid] 和 a[mid+1..hi] 归并\n        int i = lo, j = mid+1;\n        for (int k = lo; k <= hi; k++) // 将a[lo..hi]复制到aux[lo..hi]\n            aux[k] = a[k];\n        for (int k = lo; k <= hi; k++) // 归并回到a[lo..hi]\n            if (i > mid) a[k] = aux[j++];\n            else if (j > hi ) a[k] = aux[i++];\n            else if (aux[j] < aux[i]) a[k] = aux[j++];\n            else a[k] = aux[i++];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/38#issuecomment-1867323431","body":"```java\n\n\n\n\n\n\n\nclass Solution {\n    public int mySqrt(int x) {\n        int l = 0, r = x, ans = -1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if ((long)mid * mid <= x) {\n                ans = mid;\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/41#issuecomment-1868851254","body":"class Solution:\n    def findRadius(self, houses, heaters):\n        med_list = [0] #把houses分成heaters个数的blocks，第一个block左端是0\n        houses = sorted(houses)\n        heaters = sorted(heaters)\n        res = 0\n        for i in range(len(heaters)-1):\n            med_list.append((heaters[i]+heaters[i+1])/2)\n            #取相邻heaters的平均值作为相邻block的左端右端（左开右合）\n        med_list.append(max(houses)+1)#最后一个block右端是houses最大值+1\n        i,j = 0,0 #两个列表分别一个指针\n        while i < len(houses):\n            while med_list[j] <= houses[i]:\n                j+=1 #把每个房子i都放置在对应的block j\n            j -= 1\n            m = abs(houses[i]-heaters[j])\n            res = max(res,m)\n            i += 1   ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/44#issuecomment-1870902713","body":"···python\nclass Solution(object):\n    def maxVowels(self, s, k):\n        # 1.先计算初始窗口\n        vowels = {'a', 'e', 'i', 'o', 'u'}\n        cnt = 0\n        for i in range(k):\n            if s[i] in vowels:\n                cnt += 1\n        # 2.赋值res\n        res = cnt\n        for i in range(k, len(s)):\n            if s[i-k] in vowels:\n                cnt -= 1\n            if s[i] in vowels:\n                # 3.如果当前字符为元音字符，cnt + 1，并且更新res\n                cnt += 1\n                res = max(res, cnt)\n\n        return res\n\n        # 优化\n        res = cur = 0\n        for i in range(len(s)):\n            if s[i] in 'aeiou':\n                cur += 1\n            if i >= k and s[i-k] in 'aeiou':\n                cur -= 1\n            res = max (res,cur)\n        return res\n\n        # 超时\n        n = len(s)\n        yy = {'a', 'e', 'i', 'o', 'u'}\n        ans = 0\n        for i in range(n-k+1):\n            cur = 0\n            temp = s[i:i+k]\n            for j in range(k):\n                if temp[j] in yy:\n                    cur += 1\n                if cur == k:\n                    return k\n            ans = max(ans, cur)\n        return ans\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/48#issuecomment-1873267218","body":"```python\nclass Solution: \n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        res = cursum = sum(cardPoints[-k:])\n        for i in range(k):\n            cursum += cardPoints[i] - cardPoints[-k+i]\n            res = max(res, cursum)\n        return res\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/56#issuecomment-1879577881","body":"```python\nfrom collections import defaultdict\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        # 模拟\n        ans = 0\n        n = len(status)\n        cur_keys = set()\n        cur_boxes = set()\n        visited = set()\n\n        queue = []\n        for i in initialBoxes:\n            queue.append(i)\n            visited.add(i)\n \n        while queue:\n            len_ = len(queue)\n            while len_:\n                p = queue.pop(0)\n                ans += candies[p]\n                for i in keys[p]:\n                    cur_keys.add(i)\n                for i in containedBoxes[p]:\n                    cur_boxes.add(i)\n                inter = set.intersection(cur_keys,cur_boxes)\n                for i in inter:\n                    if i not in visited:\n                        visited.add(i)\n                        queue.append(i)\n                for i in cur_boxes:\n                    if i not in visited and status[i]:\n                        visited.add(i)\n                        queue.append(i)\n                len_ -= 1\n        return ans\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/60#issuecomment-1883991777","body":"```python\n\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        # 定义状态数组\n        # dp[i][0] 表示以 nums[i] 结尾的最长递增子序列的长度\n        # dp[i][1] 表示以 nums[i] 结尾的最长递增子序列的个数\n        dp = [[1, 1] for _ in range(n)]\n        max_length = 1  # 最长递增子序列的长度\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    if dp[j][0] + 1 > dp[i][0]:  # 如果长度更长，则更新\n                        dp[i][0] = dp[j][0] + 1\n                        dp[i][1] = dp[j][1]\n                    elif dp[j][0] + 1 == dp[i][0]:  # 如果长度相等，则累加个数\n                        dp[i][1] += dp[j][1]\n            max_length = max(max_length, dp[i][0])  # 更新最长递增子序列长度\n        res = 0\n        for i in range(n):\n            if dp[i][0] == max_length:  # 如果长度等于最长递增子序列长度，则累加个数\n                res += dp[i][1]\n        return res\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurallalala":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1813793169","body":"```\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        def num2array(num):\r\n            # reversed order 123 -> [3, 2, 1]\r\n            a = []\r\n            while num > 0:\r\n                a.append(num%10)\r\n                num = num // 10\r\n            return a\r\n        \r\n        def addArray(a1, a2):\r\n            res = []\r\n            i = 0\r\n            s = 0\r\n            while i<len(a1) and i<len(a2):\r\n                cur = a1[i]+a2[i]+s\r\n                res.append(cur%10)\r\n                s = cur // 10\r\n                i += 1\r\n            while i<len(a1):\r\n                cur = a1[i]+s\r\n                res.append(cur%10)\r\n                s = cur // 10\r\n                i += 1\r\n            while i<len(a2):\r\n                cur = a2[i]+s\r\n                res.append(cur%10)\r\n                s = cur // 10\r\n                i += 1\r\n            if s != 0:\r\n                res.append(s)\r\n            return res[::-1]\r\n        \r\n        return addArray(num[::-1], num2array(k))\r\n```\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1815877397","body":"```\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [float(\"inf\")]*n\n        last = -float(\"inf\")\n        for i in range(n):\n            if s[i] == c:\n                res[i] = 0\n                last = i\n            else:\n                res[i] = min(res[i], i-last)\n        last = float(\"inf\")\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                res[i] = 0\n                last = i\n            else:\n                res[i] = min(res[i], last-i)\n        return res\n```\n\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817450066","body":"```\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxSize = maxSize\n        self.stack = []\n        \n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.stack:\n            return -1\n        return self.stack.pop()\n        \n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n```\nTime complexity:\npush: O(1)\npop: O(1)\nincrement: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817796704","body":"```\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []\r\n        ct = \"\"\r\n        for i in range(len(s)):\r\n            if s[i].isdigit():\r\n                ct += s[i]\r\n            elif s[i] == \"[\":\r\n                stack.append(ct)\r\n                ct = \"\"\r\n            elif s[i].isalpha():\r\n                stack.append(s[i])\r\n            elif s[i] == \"]\":\r\n                sub = \"\"\r\n                while stack:\r\n                    if stack[-1].isdigit():\r\n                        n = int(stack.pop())\r\n                        stack.append(sub*n)\r\n                        break\r\n                    else:\r\n                        sub = stack.pop() + sub                \r\n        return \"\".join(stack)\r\n```\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818435211","body":"```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.s1, self.s2 = [], []\n        \n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.s1.append(x)\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.s1:\n            self.s2.append(self.s1.pop())\n        first = self.s2.pop()\n        while self.s2:\n            self.s1.append(self.s2.pop())\n        return first\n        \n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.s1:\n            self.s2.append(self.s1.pop())\n        first = self.s2[-1]\n        while self.s2:\n            self.s1.append(self.s2.pop())\n        return first\n        \n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if len(self.s1) == 0:\n            return True\n        else:\n            return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1820439372","body":"```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        stack = []\r\n        for a in arr:\r\n            if not stack:\r\n                stack.append(a)\r\n            else:\r\n                if stack[-1] > a:\r\n                    cur = stack[-1]\r\n                    while stack and stack[-1]>a:\r\n                        stack.pop()\r\n                    stack.append(cur)\r\n                else:\r\n                    stack.append(a)\r\n        return len(stack)\r\n```\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822280662","body":"```\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        l = 0\n        p = head\n        while p:\n            p = p.next\n            l += 1\n        k = k%l\n        if k == 0:\n            return head\n        dh = ListNode(-1, head)\n        right = dh\n        for i in range(k):\n            right = right.next\n        prev = dh\n        while right.next:\n            prev = prev.next\n            right = right.next\n        newh = prev.next\n        right.next = head\n        prev.next = None\n        return newh\n```\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1823904067","body":"```\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        dh = ListNode(0, head)\n        prev, first, second = dh, head, head.next\n        while True:\n            # swap\n            tmp = second.next\n            second.next = first\n            first.next = tmp\n            prev.next = second\n            \n            prev = first\n            if not prev.next:\n                break\n            first = prev.next\n            if not first.next:\n                break\n            second = first.next\n\n        return dh.next\n```\nTime: O(N)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/10#issuecomment-1825251988","body":"```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def helper(l, start, end):\n            if start > end:\n                return None\n            mid = math.ceil((start+end)/2)\n            newRoot = TreeNode(l[mid])\n            newRoot.left = helper(l, start, mid-1)\n            newRoot.right = helper(l, mid+1, end)\n            return newRoot\n        \n        if not head:\n            return head\n        l = []\n        p = head\n        while p:\n            l.append(p.val)\n            p = p.next\n        return helper(l, 0, len(l)-1)\n```\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/11#issuecomment-1826239577","body":"```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        la, lb = 0, 0\n        p = headA\n        while p:\n            p = p.next\n            la += 1\n        p = headB\n        while p:\n            p = p.next\n            lb += 1\n        # make sure la is the longer list\n        if la < lb:\n            la, lb = lb, la\n            headA, headB = headB, headA\n        diff = la-lb\n        pa, pb = headA, headB\n        while diff>0:\n            pa = pa.next\n            diff -= 1\n        while pa:\n            if pa == pb:\n                return pa\n            pa, pb = pa.next, pb.next\n        return None\n```\nTime: O(N)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826715062","body":"```\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return None\n        visited = set()\n        p = head\n        while p and p not in visited:\n            visited.add(p)\n            p = p.next\n        return p\n```\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1827118160","body":"```\nclass DoubleListNode:\n    def __init__(self, key, val, prev=None, nxt=None):\n        self.key = key\n        self.val = val\n        self.prev = prev\n        self.next = nxt\n\nclass LRUCache:\n    '''\n    a dict key->(val, node) to make sure get takes O(1)\n    a double linked list to make sure put also takes O(1)\n        put -> not in the dict, not exceed, create a new node and insert to the front, and add entry to dict\n        put -> not in the dict, exceed, find the front node to evict, and the rest is the same as above\n        put -> in the dict, if not exceed the capacity, update the value and insert the node to front\n    '''\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.head = DoubleListNode(-1, -1)\n        self.tail = DoubleListNode(-1, -1)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.dict = {}\n\n    def get(self, key: int) -> int:\n        if key in self.dict:\n            value, node = self.dict[key]\n            self.moveToFront(node)\n            return self.dict[key][0]\n        else:\n            return -1\n        \n    def put(self, key: int, value: int) -> None:\n        if key not in self.dict:\n            if len(self.dict) == self.capacity:\n                # evict\n                evict = self.tail.prev\n                evict.prev.next = self.tail\n                self.tail.prev = evict.prev\n                print(evict.key)\n                del self.dict[evict.key]\n            node = DoubleListNode(key, value, self.head, self.head.next)\n            self.head.next.prev = node\n            self.head.next = node\n            self.dict[key] = (value, node)    \n        else:\n            _, node = self.dict[key]\n            node.val = value\n            self.moveToFront(node)\n            self.dict[key] = (value, node)\n    \n    def moveToFront(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n        tmp = self.head.next\n        self.head.next = node\n        node.next = tmp\n        node.prev = self.head\n        tmp.prev = node\n```\nTime: get - O(1), put - O(1)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829216966","body":"```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831495161","body":"```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        if p.val == q.val:\n           return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        else:\n            return False\n```\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1833348605","body":"```\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        \r\n\r\n        def helper(node):\r\n            if not node:\r\n                return [], 0\r\n            if not node.left and not node.right:\r\n                # return depth, cur_sum\r\n                return [0], node.val\r\n            cur_sum = 0\r\n            cur_depths = []\r\n            depths, prev_sum = helper(node.left)\r\n            cur_depths += [d+1 for d in depths]\r\n            cur_sum = cur_sum + prev_sum + sum([node.val*10**(d+1) for d in depths])\r\n            depths, prev_sum = helper(node.right)\r\n            cur_sum = cur_sum + prev_sum + sum([node.val*10**(d+1) for d in depths])\r\n            cur_depths += [d+1 for d in depths]\r\n            return cur_depths, cur_sum\r\n        \r\n        _, res = helper(root)\r\n        return res\r\n```\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/17#issuecomment-1835567296","body":"```\r\nimport collections\r\n\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        q = collections.deque([root])\r\n        res = root.val\r\n        while q:\r\n            l = len(q)\r\n            for i in range(l):\r\n                if q[0].left:\r\n                    q.append(q[0].left)\r\n                if q[0].right:\r\n                    q.append(q[0].right)\r\n                q.popleft()\r\n            if q:\r\n                res = q[0].val\r\n        return res\r\n```\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1837051653","body":"```\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        1 l:n r:n \r\n        \"\"\"\r\n        def dfs(root):\r\n            if not root:\r\n                return \"n\"\r\n            s = str(root.val)\r\n            left = dfs(root.left)\r\n            right = dfs(root.right)\r\n            s = s + \" l:{\" + left +  \"} r:{\" + right +\"}\"\r\n            return s\r\n        res = dfs(root)\r\n        return res\r\n        \r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        def helper(data, start, end):\r\n            if data[start:end+1] == \"n\":\r\n                return None\r\n            left_start, right_start = 0, 0\r\n            vals = \"\"\r\n            first_space, first_l = False, False\r\n            root = None\r\n            l_start, l_end, r_start, r_end = 0, 0, 0, 0\r\n            open_brackets = 0\r\n            for i in range(start, end+1):\r\n                if (data[i].isdigit() or data[i]==\"-\") and not first_space:\r\n                    vals += data[i]\r\n                elif not first_space and data[i] == \" \":\r\n                    root = TreeNode(int(vals))\r\n                    first_space = True\r\n                elif not first_l and data[i] == \"l\":\r\n                    first_l = True\r\n                    l_start = i+3\r\n                elif first_l and data[i] == \"{\":\r\n                    open_brackets += 1\r\n                elif first_l and data[i] == \"}\":\r\n                    open_brackets -= 1\r\n                    if open_brackets == 0:\r\n                        l_end = i\r\n                        break\r\n            root.left = helper(data, l_start, l_end-1)\r\n            root.right = helper(data, l_end+5, end-1)\r\n            return root\r\n\r\n        return helper(data, 0, len(data)-1)\r\n```\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/19#issuecomment-1837399406","body":"```\r\nimport collections\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        # first, level order traversal to have x index sorted in a dict e.g. {-1:[9] 0:[3, 15], 1:[20]...}\r\n        d = collections.defaultdict(list)\r\n        q = collections.deque([(root, 0)])\r\n        while q:\r\n            l = len(q)\r\n            tmp = collections.defaultdict(list)\r\n            for i in range(l):\r\n                node, y = q.popleft()\r\n                tmp[y].append(node.val)\r\n                if node.left:\r\n                    q.append((node.left, y-1))\r\n                if node.right:\r\n                    q.append([node.right, y+1])\r\n            # sort the list in the same level to make sure the node with same index is ordered by values\r\n            for y in tmp:\r\n                d[y].extend(sorted(tmp[y]))\r\n        \r\n        return [d[key] for key in sorted(d)]\r\n```\r\nTime: O(NlogN)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1837778996","body":"```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        d = {}\n        for i in range(len(nums)):\n            rest = target - nums[i]\n            if rest in d:\n                return [d[rest], i]\n            d[nums[i]] = i\n```\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/21#issuecomment-1840074078","body":"```\nimport collections\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        ct = collections.defaultdict(int)\n        for num in nums:\n            ct[num] += 1\n        return [k for k, v in sorted(ct.items(), key=lambda item: item[1], reverse=True)][:k]\n```\nTime: O(NlogN)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/22#issuecomment-1842174980","body":"```\r\nclass Solution:\r\n    \"\"\"\r\n    {(x,y): {dis:[(x2,y2), (x3,y3)...]}}\r\n\r\n    {(1,0): {1:[(0,0), (2,0)]}}\r\n    \r\n    \"\"\"\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        if len(points) < 3:\r\n            return 0\r\n        n = len(points)\r\n        res = 0\r\n        for i in range(n):\r\n            d = collections.defaultdict(int)\r\n            for j in range(n):\r\n                dis = (points[i][0]-points[j][0])**2 + (points[i][1]-points[j][1])**2\r\n                d[dis] += 1\r\n        \r\n            for key in d:\r\n                if d[key] >= 2:\r\n                    res += d[key]*(d[key]-1)\r\n        return res\r\n```\r\nTime: O(N^2)\r\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1844457257","body":"```\nimport collections\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if len(s) <= 1:\n            return len(s)\n        d = collections.defaultdict(int)\n        i, j = 0, 0\n        res = 0\n        n = len(s)\n        cur = 0\n        while j<n:\n            if d[s[j]] == 0:  \n                d[s[j]] = 1\n                cur += 1\n                res = max(res, cur)\n            else:\n                while i<j and s[i] != s[j]:\n                    d[s[i]] = 0\n                    i += 1\n                    cur -= 1\n                i += 1\n            j += 1\n        return res\n\n```\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/24#issuecomment-1846836263","body":"```\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n\r\n        def isPermutation(subs, ct, wl):\r\n\r\n            ctsub = collections.defaultdict(int)\r\n            for p in range(0, len(subs)-wl+1, wl):\r\n                ctsub[subs[p: p+wl]] += 1\r\n                        \r\n            if len(ctsub) != len(ct):\r\n                return False\r\n            \r\n            for key in ct:\r\n                if key not in ctsub or ctsub[key] != ct[key]:\r\n                    return False\r\n                \r\n            return True\r\n\r\n\r\n        wl = len(words[0])\r\n        l = len(words)\r\n        if wl*l > len(s):\r\n            return []\r\n\r\n        ct = collections.defaultdict(int)\r\n        for w in words:\r\n            ct[w] += 1\r\n                \r\n        res = []\r\n        for i in range(len(s)-wl*l+1):\r\n            if isPermutation(s[i:i+l*wl], ct, wl):\r\n                res.append(i)\r\n        return res\r\n```\r\nTime: O(N*M*K) N: len of s, M:len of words, K: len of each word\r\nSpace: O(M)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/25#issuecomment-1848265630","body":"```\nclass Solution:\n\n    def minSubarray(self, nums: List[int], k: int) -> int:\n        total = sum(nums)\n        mod = total % k\n        if mod == 0: return 0\n\n        ans = len(nums)\n        total = 0\n        # 处理从0开始的子数组\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            # https://leetcode.cn/problems/make-sum-divisible-by-p/solutions/1/tao-lu-qian-zhui-he-ha-xi-biao-pythonjav-rzl0/ 负数 +k)%k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n```\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/26#issuecomment-1848870412","body":"```\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        while slow and fast and slow.next and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\nTime: O(N)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849396596","body":"```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        n = len(nums)\n        p1, cur = 0, nums[0]\n        for p2 in range(1, n):\n            if nums[p2] != cur:\n                cur = nums[p2]\n                p1 += 1\n                nums[p1] = cur\n        return p1+1\n```\nTime: O(N)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1851396733","body":"```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        if target < nums[0]:\n            return 0\n        if target > nums[-1]:\n            return len(nums)\n        left, right = 0, len(nums)-1\n        mid = left\n        while left <= right:\n            mid = (left+right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1 \n        return left\n```\nTime: O(logn)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/29#issuecomment-1853292794","body":"```\nimport collections\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        dq = collections.deque([])\n        res = []\n        for i in range(len(nums)):\n            if not dq:\n                dq.append(i)\n            else:\n                if i-dq[0] >= k:\n                    dq.popleft()\n                while dq and nums[i] >= nums[dq[-1]]:\n                    dq.pop()\n                if not dq or nums[i] < nums[dq[-1]]:\n                    dq.append(i)\n            if i >= k-1:\n                res.append(nums[dq[0]])\n        return res\n```\nTime: O(N)\nSpace: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/30#issuecomment-1855333262","body":"```\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n\n        countBeTrust = [set() for i in range(n+1)]\n        countTrust = [0]*(n+1)\n\n        for a, b in trust:\n            countBeTrust[b].add(a)\n            countTrust[a] += 1\n        \n        for i in range(1, n+1):\n            if len(countBeTrust[i]) == n-1 and  countTrust[i] == 0:\n                return i\n    \n        return -1\n```\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/31#issuecomment-1857324783","body":"```\r\nimport collections\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        if not dislikes:\r\n            return True\r\n\r\n        graph = collections.defaultdict(list)\r\n        for a, b in dislikes:\r\n            graph[a].append(b)\r\n            graph[b].append(a)\r\n        \r\n        visited = [-1]*n\r\n\r\n        def dfs(node, color):\r\n            if visited[node-1] != -1:\r\n                if color != visited[node-1]:\r\n                    return False\r\n                else:\r\n                    return True\r\n            visited[node-1] = color\r\n            res = True\r\n            for e in graph[node]:\r\n                res = res and dfs(e, 1-color)\r\n            return res\r\n        \r\n        res = True\r\n        for a, b in dislikes:\r\n            if visited[a-1] == -1 and visited[b-1] == -1:\r\n                res = res and dfs(a, 0)\r\n        return res\r\n```\r\nTime: O(V+E)\r\nSpace: O(V+E)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/32#issuecomment-1858740592","body":"```\nclass Solution:\n    def has_cycle(self, graph, cur_node, visited, result):\n        if visited[cur_node] == 1:\n            return False\n        if visited[cur_node] == 2:\n            return True\n        visited[cur_node] = 2\n        for next_node in graph[cur_node]:\n            if self.has_cycle(graph, next_node, visited, result):\n                return True\n        visited[cur_node] = 1\n        result.append(cur_node)\n        return False\n\n    def sortItems(self, n: int, m: int, group: List[int],\n                  beforeItems: List[List[int]]) -> List[int]:\n        # Map between group_id and item_ids\n        group_items_map = defaultdict(list)\n        # Visited for items in each group. Will be used later\n        visited_item = defaultdict(dict)\n        for i in range(n):\n            # Assign no-group items to a new group\n            if group[i] == -1:\n                group[i] = m\n                m += 1\n            group_items_map[group[i]].append(i)\n            visited_item[group[i]][i] = 0\n\n        # key - group_id : value - next_groups\n        graph_group = defaultdict(set)\n        # key - group_id : value - {key - item_id : value: next_items}\n        graph_item = {i: defaultdict(list) for i in range(m)}\n\n        # Create graph for items and groups\n        for item_after, before_items in enumerate(beforeItems):\n            for item_before in before_items:\n                group_before = group[item_before]\n                group_after = group[item_after]\n\n                # If two items belong to different groups,\n                #   add a dependency between groups\n                # Otherwise, add a dependency between items in the same group\n                if group_before != group_after:\n                    graph_group[group_before].add(group_after)\n                else:\n                    graph_item[group_before][item_before].append(item_after)\n\n        # Use DFS to find group order\n        visited_group = [0] * m\n        group_order = []\n        for group_id in range(m):\n            if self.has_cycle(graph_group, group_id,\n                              visited_group, group_order):\n                return []\n\n        # Use DFS to find item order in each group\n        full_item_order = []\n        for group_id in group_order:\n            for item_id in group_items_map[group_id]:\n                if self.has_cycle(graph_item[group_id], item_id,\n                                  visited_item[group_id], full_item_order):\n                    return []\n        return full_item_order[::-1]\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/34#issuecomment-1859817360","body":"```\r\nimport heapq\r\nclass Solution:\r\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\r\n        n = len(tasks)\r\n        ind = 0\r\n        for i in tasks:\r\n            i.append(ind)\r\n            ind+=1\r\n        tasks.sort()\r\n        print(tasks)\r\n\r\n\r\n        heap = []\r\n        i = 0\r\n        arrivalTime = tasks[0][0]\r\n        while(i < n):\r\n            if tasks[i][0] == arrivalTime:\r\n                heapq.heappush(heap, [tasks[i][1], tasks[i][2]])\r\n            else:\r\n                break \r\n            i+=1\r\n\r\n        order = []\r\n        while(heap):\r\n            process = heapq.heappop(heap)\r\n            order.append(process[1])\r\n            arrivalTime += (process[0])\r\n\r\n            while(i < n and tasks[i][0] <= arrivalTime):\r\n                heapq.heappush(heap, [tasks[i][1], tasks[i][2]])\r\n                i+=1\r\n\r\n            if not heap and i < n:\r\n                arrivalTime = tasks[i][0]\r\n                while(i < n):\r\n                    if tasks[i][0] == arrivalTime:\r\n                        heapq.heappush(heap, [tasks[i][1], tasks[i][2]])\r\n                    else:\r\n                        break \r\n                    i+=1\r\n\r\n        return order\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"danielyan86":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1813902612","body":"# 思路\n\n## 解法 1: 直接用 list-》string-》int 方法，遇到超出限制问题\n\n```\nValueError: Exceeds the limit (4300) for integer string conversion: value has 10000 digits; use sys.set_int_max_str_digits() to increase the limit\n    res=str(int(num_st)+k)\n```\n\n- 修改长度限制后可以通过 （time: 34%, memory: 56%）\n\n## 解法 2: 转化 k 为 list 后，用循环方法让两个 list 想加\n\n- 怎么处理进位问题，用一个 carry 变量标记\n- 需要考虑全面：carry 不为 0 时候，可能是 num 还没处理完，也可能是 k 没有处理完\n- 显著高于第一种（time: 34%, memory: 56%）\n\n### 代码\n\n```py\n#solution1\n#需要增加默认长度限制\nsys.set_int_max_str_digits(100000)\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_st=\"\"\n        for i in num:\n            num_st=\"\".join((num_st,str(i)))\n        res=str(int(num_st)+k)\n        return [int(i) for i in res]\n\n```\n\n```py\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # no need to convert k into list\n        # no need to create a new list, update the num directly\n        carry = 0\n        # travsal the list first\n        for i in range(len(num) - 1, -1, -1):\n            tmp = k % 10  # get the last number of K\n            s = num[i] + tmp + carry\n            if s < 10:\n                num[i] = s\n                carry = 0\n            elif s >= 10:\n                num[i] = s % 10\n                carry = 1\n            k //= 10  # pop out the last number of K\n\n        while k > 0:\n            s = k % 10 + carry\n            if s >= 10:\n                carry = 1\n                s = s % 10\n            else:\n                carry = 0\n            num.insert(0, s)  # insert to first one\n            k //= 10\n        if carry == 1:\n            num.insert(0, 1)\n        return num\n```\n\n```python\n 第二种解法code还可以再次优化\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # no need to convert k into list\n        # no need to create a new list, update the num directly\n        carry = 0\n        # travsal the list first\n        for i in range(len(num) - 1, -1, -1):\n            tmp = k % 10  # get the last number of K\n            s = num[i] + tmp + carry\n            carry = s // 10\n            num[i] = s if s < 10 else s % 10\n            k //= 10  # pop out the last number of K\n\n        while k > 0:\n            s = k % 10 + carry\n            carry = s // 10\n            if s >= 10:\n                s = s % 10\n            num.insert(0, s)  # insert to first one\n            k //= 10\n        # add the last 1 to the first\n        if carry == 1:\n            num.insert(0, 1)\n        return num\n\n```\n\n**复杂度分析**\nm 和 n 为数组长度\n解法 1:\n\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(m+n)\n\n解法 2:\n因为没有新创建数组，也没有把 k 转化成整数，时间和空间优于第一种\n\n- 时间复杂度：O(m)\n- 空间复杂度：O(m)\n\n## 总结\n\n- 搞清楚，//，/，%区别\n- 搞清楚按位加法的算法\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1815963893","body":"### 思路\n\n通过题目发现这么几个点\n\n- 至少有一个桩（目标字符），想到了用 find 找到第一个\n- 第一次扫描所有距离可以用 abs 得出\n- 不确定有几个桩，所以一次遍历肯定不行\n- 想到用双指针发动态更新距离，如果发现一个新桩后和上一个字符中间的距离值\n\n### code\n\n```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pre = cur = s.find(c)\n        res = [0] * len(s)\n\n        for i, st in enumerate(s):\n            if st == c and i > cur:\n                cur = i\n                for mi in range(pre + (cur - pre) // 2 + 1, cur):\n                    res[mi] = abs(cur - mi)\n                pre = cur\n            else:\n                res[i] = abs(i - cur)\n        return res\n\n```\n\n###复杂度\nn=len(s)\n第二个指针因为从两个指针中间位置开始扫描，平均时间复杂度应该是小于 2n\n时间复杂度：O（2n）\n空间复杂度：O（2n）\n\n### 总结\n\n看了官方思路，发现这个思路实现细节方面更容易出错，准备用官方思路再写一遍\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817419720","body":"### 思路\n\n这题用 python 已经有的 list 实现比较简单，pop 是现成方法，append 也就是题目对应的 push，需要注意两点\n\n- 超出 size 不能再 push\n- k 长度可能大于已有的数组长度，可能小于，取小即可\n\n### code\n\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        # Only need to consider the length of k and stack\n        for i in range(0, min(k, len(self.stack))):\n            self.stack[i] += val\n```\n\n### 复杂度\n\n- time\n  push，pop: O（1）\n  increment: O(n) n is the length of the stack\n- memory\n  push，pop: O（1）\n  increment: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817808581","body":"### 思路\n\n看题目分析后发现，有括号的嵌套，所以按照顺序单次遍历是没法确定具体展开的字母个数，被嵌套里层的数字和外层有个相乘的关系，很容易想到 stack 和 recursive 方法\n通常可以用 stack 解决的问题也可以用递归，递归本质上也是系统维护了一个 stack。\n但是代码实现时候在细节上没有处理好，发现写的过于复杂，最后参考了一些题解。\n两个地方实现想的过于复杂\n\n- 怎么处理数字，想到的是先入栈，再处理，其实可以正向处理\n- 增加一个格外的 string 来维护栈里面生成的字符串\n- 栈的数据结构没有设计好，没有想到用一个 tuple 成对记录数字和字符串\n\n### code\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_num = 0\n        cur_str = \"\"\n\n        for char in s:\n            if char.isdigit():\n                # 处理完数字后，再入栈\n                current_num = current_num * 10 + int(char)\n            elif char == \"[\":\n                # 遇到”【“后，当前数字和字符串一起入栈\n                # 重新初始化num 和ctr\n                stack.append((current_num, cur_str))\n                current_num = 0\n                cur_str = \"\"\n            elif char == \"]\":\n                #出栈，乘以对应的数字\n                num, prev_str = stack.pop()\n                cur_str = prev_str + num * cur_str\n                \"\".join((prev_str, cur_str))\n            else:\n\n                \"\".join((cur_str,char))\n\n        return cur_str\n```\n\n### complexity\n\ntime: O(n)\nSpace: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818286217","body":"### 思路\r\n- 其实不用所谓的双栈，直接用 del stack[0] 就可以实现栈的 pop 功能，但是题目要求必须使用双栈实现\r\n- 很多示例代码处理了 pop 时候 stack 为空的时候情况，其实题目已经说了“例如，一个空的队列不会调用 pop 或者 peek 操作）”\r\n\r\n#### 双栈实现\r\n\r\n- 两个 list，一个模拟入栈，一个模拟出栈\r\n- pop 和 peek 都操作出栈的 list\r\n- 如果出栈的 list 为空，则把入栈 list 的元素搬过来，用 pop 和 list 方法刚好反转\r\n- 如果两个 list 都为空，则为空\r\n\r\n### code\r\n\r\n```python\r\n\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.A, self.B = [], []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.A.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.B:\r\n            return self.B.pop()\r\n        self._move()\r\n        return self.B.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.B:\r\n            return self.B[-1]\r\n        self._move()\r\n        return self.B[-1]\r\n\r\n    def _move(self):\r\n        while self.A:\r\n            self.B.append(self.A.pop())\r\n\r\n    def empty(self) -> bool:\r\n        return not (self.A or self.B)\r\n```\r\n\r\n```python\r\n# with one list\r\nclass MyQueue2(object):\r\n    def __init__(self):\r\n        self._data = []\r\n\r\n    def push(self, x):\r\n        self._data.append(x)\r\n\r\n    def pop(self):\r\n        if not self.empty():\r\n            first_item = self._data[0]\r\n            del self._data[0]\r\n            return first_item\r\n\r\n    def peek(self):\r\n        if not self.empty():\r\n            return self._data[0]\r\n\r\n    def empty(self):\r\n        if self._data:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\n\r\n### complexity\r\n\r\nN is length of the queue\r\n\r\n- push, peek, empty is O(1)\r\n- move method : time O(N), space O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1820533389","body":"### solution\n\n这题没有思路，理解题目就花了点时间。\n思路参考\nhttps://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/hard/768.max-chunks-to-make-sorted-ii\n采用计数法比较好理解，也容易实现\n\n- 基本思想-1，两个数组如果数字个数一样，则排序后也一样 2.把原数组和一个升序数组挨个比较计数，则可以算出最大分割数目\n- 如果原数组严格按照升序，则会出现最大分割，n，如果是降序，则是 1\n\n### code\n\n- 使用 defaultdict 好处是不用初始化字典默认子，比如 a=collections.defaultdict(int), 那么 a['key'] 的默认初始值是 0，并且不用每次判断 key 是否存在\n- 利用 zip 方法每次分别取两个数组统一个位置数字加到字典\n- 字典一样则表示当前位置数组一样，也就是可以按升序分割，结果加一\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        orgin_d, sorted_d = collections.defaultdict(int), collections.defaultdict(int)\n        res = 0\n        for i, j in zip(arr, sorted(arr)):\n            orgin_d[i] = orgin_d[i] + 1\n            sorted_d[j] = sorted_d[j] + 1\n            if orgin_d == sorted_d:\n                res += 1\n        return res\n\n```\n\n### complexity\n\nN 为数组长度\ntime: 取决于排序，假设为快速排序：O(n log n)\nspace： O（2N）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1821990563","body":"### solution\n\n分析题目之后想到了用环形链表解决，先闭环，找到对应节点后再断开\n需要注意这几点：\n\n- 搞清楚断开的边界节点\n- k 的值可能大于链表长度 n，使用取余数方法让 k 小于 n（k%=step），因为整数部分其实就是 n 的倍数\n- 如果刚好是整数倍，直接返回，不用再构造环\n\n### code\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head is None or head.next is None: return head\n        cur = head\n        step = 0\n\n        # calculate node number\n        while cur:\n            step += 1\n            pre = cur\n            cur = cur.next\n        k %= step #use remainder to re-calculate the k\n        if k == 0: return head\n        pre.next = head #make loop link\n\n        for i in range(step - k):\n            pre = pre.next\n        new_head = pre.next\n        pre.next = None\n        return new_head\n\n```\n\n### complexity\n\nn is the length of the link\n\n- space: O(n)\n- time: O(2n-(step%k))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1823940728","body":"### solutions\n\n#### 迭代大法\n\n- 初始化两个指针，pre，cur\n- 让当前指针和下一个节点交换，并且需要提前记录下下个节点位置\n- pre 指向 cur.next，cur.next 指向当前，当前指向 cur.next.next\n- 移动 pre，cur 到下一个位置\n- cur，cur.next 都为 true 才进入循环\n\n实际操作需要操作和记录四个 node，稍微有些麻烦\n\n#### 递归\n\n代码更简洁，但是不熟悉这种写法，参考官方实现。\n相当于先把链表最后的节点交换完毕，再通过递归方式把前面的节点依次交换\n\n### code\n\n```python\n\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n        dummy = ListNode(0, head)\n        pre, cur = dummy, head\n\n        # if current node is None or next is None, then end loop\n        while cur and cur.next:\n            next = cur.next\n            next_tmp = next.next\n            pre.next = next\n            next.next = cur\n            cur.next = next_tmp\n            pre = cur\n            cur = next_tmp\n        return dummy.next\n\n```\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n```\n\n### complexity\n\n- 迭代 time： O（N），space（1）\n- 递归 time：O（N），space（n）space 取决于栈空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/10#issuecomment-1825527910","body":"### solution\n\nBST 的特性是中序遍历单调递增，再根据题目要求是平衡二叉树，先找到链表的中间节点\n\n- 利用快慢指针找到中间节点\n- 返回后创建根节点\n- 依次往下递归，找到左边和右边的中间节点返回\n\n写完之后看代码其实和二叉树前序遍历代码模版类似\n\n### code\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        # get the value of middle node\n        def get_middle(left, right):\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n\n        def build_tree(left, right):\n            if left == right:\n                return None\n            mid = get_middle(left, right)\n            root = TreeNode(mid.val)  # build root node\n            root.left = build_tree(left, mid)\n            root.right = build_tree(mid.next, right)\n            return root\n\n        return build_tree(head, None)\n\n```\n\n### complexity\n\n快指针是跳着走的，并没有遍历每一个节点，是小于 n 的\n\ntime:O(nlogn)\n调用栈空间产生格外的空间\nspace：O（logn）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/11#issuecomment-1826262530","body":"### solution\n\n很容易想到合集法，或者说 hash 法，把 A 所有节点放到一个集合，遍历 B 判断是否在集合 A，如果在则返回节点，这样会产生一个格外的 n or m 的 space\n\n第二个指针法，不太容易想到，\n\n- 假设 m 和 n 相交，则 m=a+b，n=c+b\n- 两个指针同时开始遍历 A 和 B，谁先走完则重新指向对方，如果有相交节点，两个指针则会想等，因为 a+b+c=c+b+a\n\n看了思路并不复杂，但要写出简洁代码不太容易，参考了官方例子\n\n### code\n\n```python\n# use set data structure\nclass Solution1:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a_set = set()\n        a, b = headA, headB\n        while a:\n            a_set.add(a)\n            a = a.next\n        while b:\n            if b in a_set:return b\n            b = b.next\n\nclass Solution2:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        pointerA, pointerB = headA, headB\n        while pointerA != pointerB:\n            # Move the pointers to the next node\n            pointerA = pointerA.next if pointerA else headB\n            pointerB = pointerB.next if pointerB else headA\n\n        # At this point, either pointers have met at the intersection or both are None\n        return pointerA\n```\n\n### complexity\n\nsolution2\n\n- time: O(m+n)\n- space:O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826468119","body":"### solutions\n\n- hash 大法，更容易想到，也更容易实现，实际测试运行速度也更快\n- 双指针法，第一次相遇 fast 是 slow 的两倍速度，然后 fast 从头开始一步一步走直到相遇，原理不太容易想到\n\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None: return\n        node_s = set()\n        cur = head\n        while cur:\n            if cur in node_s: return cur\n            node_s.add(cur)\n            cur=cur.next\n\nclass Solution2:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None: return\n        if head.next is head: return head\n        slow, fast = head, head\n\n        while True:\n            if fast is None or fast.next is None: return\n            slow, fast = slow.next, fast.next.next\n            if slow == fast: break\n\n        fast = head  # set the fast pointer from start position\n        # the fast need to move 1 step for second time\n        while fast:\n            if slow == fast: return slow\n            slow, fast = slow.next, fast.next\n```\n\n### complexity\n\n- space: hash 法要用到格外一个 O（N），双指针法为 O（1）\n\n- time: hash O(N), 双指针法在有换时候大于 O（N）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1827770710","body":"### 思路\n\n- 直接使用内置函数，这题就失去考算法意义了。\n- hash + 双向链表实现\n\n思路不是很复杂，但是实际实现 code 时候细节很多，很容易出错，需要注意这几点\n\n- 链表里面也需要存一个 key，方便通过 node 获取到字典的 key，可以理解成 hash 和链表的 node 也是双向的\n- 初始化头尾哨兵节点，让插入和删除更加方便\n- delete 和 add node 的操作可以封装，方便 get 和 put 调用，del 字典操作操作不要放到子方法里，减少冗余\n- put 一个已经存在 key 操作因为包括了一个 get 步骤，可以直接调用 get 方法\n- 才用末尾节点为最新的是为了和 ordereddict 方向保持一致\n- get 不要忘了 return value\n\n### code\n\n```python\n# hash + Doubly linked list\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.size = capacity\n        self.cache = dict()\n        self.head, self.tail = LinkNode(), LinkNode()\n        self.head.next, self.tail.pre = self.tail, self.head\n\n    def get(self, key: int) -> int:\n        if key not in self.cache: return -1\n        node = self.cache[key]\n        self.remove_node(node)\n        self.add_tail(node)\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache[key].value = value\n            self.get(key)\n        else:\n            if len(self.cache) == self.size:\n                node = self.head.next # get the head node and remove it\n                self.remove_node(node)\n                del self.cache[node.key]\n            node = LinkNode(key, value)\n            self.add_tail(node)\n            self.cache[key] = node\n\n    def remove_node(self, node):\n        pre, nt = node.pre, node.next\n        pre.next = nt\n        nt.pre = pre\n        node.pre = node.next = None\n\n    def add_tail(self, node):\n        pre = self.tail.pre\n        pre.next = node\n        node.pre = pre\n        node.next = self.tail\n        self.tail.pre = node\n\n```\n\n```python\n# ordereddict\nclass LRUCache:\n    #let's assume the fist item is the less used due to orderedDict feature\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache: return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        # need to judge the key existing in dictionary d[k]=v is enough\n        self.cache[key] = value # add to the end by default\n        self.cache.move_to_end(key)\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False) # pop the first item\n```\n\n### complexity\n\nBecause using the hash table to find the node, the time is constant\n\n- time: O(1)\n- space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829190537","body":"### solutions\n\n#### DFS\n\n个人觉得相比 BFS 不太好写，尤其是简洁的代码\n\n- 设置一个全局的 max_depth,每次传一个表示深度的变量 depth 给递归函数\n- 当走到末尾的时候，也就是左右节点都是为空的时候开始计算 depth 并和全局的 max_depth 相比较\n\n看了官方的 DFS 代码后发现要简洁得多，其实可以直接利用递归栈来计算深度，也就是在左右节点都为空时候从下往上加，并且取深度更大的一边的数，这样返回到最上层的时候就是最大深度\n\n#### BFS\n\n- 可以直接用 deque 实现，也可以用 stack 实现\n\n### code\n\n```python\n#DFS\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        self.max_depth = 0\n        depth = 0\n\n        def helper(node, depth):\n            if node is None:\n                return\n            depth += 1\n            if node.left is None and node.right is None:\n                self.max_depth = max(self.max_depth, depth)\n            helper(node.left, depth)\n            helper(node.right, depth)\n\n        helper(root, depth)\n        return self.max_depth\n```\n\n```python\n#DFS clean version\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None: return 0\n        left=self.maxDepth(root.left)\n        right=self.maxDepth(root.right)\n        return max(left,right)+1\n```\n\n```python\n#BFS\nclass Solution2:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        depth = 0\n        deque = collections.deque([root])\n        while deque:\n            depth += 1\n            for _ in range(len(deque)):\n                node = deque.popleft()\n                if node.left:\n                    deque.append(node.left)\n                if node.right:\n                    deque.append(node.right)\n        return depth\n```\n\n### complexity\n\n- time: O(n)\n- space: DFS O(hight) 格外栈空间调用取决于递归深度 BFS： 最坏为 O（n），n 为一层节点个数\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831056032","body":"### solution\n\n用 DFS 方式比较直观，直接比较每个节点的结构和值，结构通过判断当前是否为 None 值决定，需要注意是考虑完四种情况\n\n- 都为 None 值时候已经到头，并且结构一样，return True\n- 其中一个有节点，另外一个没有，表示结构不一样，则返回 False\n- 当前节点都存在，结构一样，再比较值，如果值一样，则继续向下递归\n\n### code\n\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p is None and q is None: return True\n        if p is None or q is None: return False\n        if p.val!=q.val: return False\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n\n```\n\n### complexity\n\nm 和 n 分别代表节点数目\n\n- time: O（min（m，n））\n- time: O（min（m，n））\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1833041974","body":"### Solutions\n\n看题目分析之后，想到用二叉树遍历解决，题目转换过来其实就是每条遍历的路径求和，只不过不是简单的数字相加，而是上层节点会转换成十进制高位数字，刚开始用的数字转字符，字符拼接好之后再转数字，有点麻烦，其实可以直接把上层来的数字\\*10 再和本层相加即可。需要注意这几点\n\n- 子节点为 None 的时候应该返回什么？因为需要通过递归出栈时候计算，不能再返回 None 了，返回 0\n- 辅助递归函数需要多传一个数字作为参数\n- 左右节点都为空的时候，也就是走到叶子节点时候，返回数字，否则是在中间，返回左右数字之和\n\n### code\n\n```python\n# convert number to string, this version is not simple\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n\n        def helper(node, num_st):\n            if node is None: return 0\n            num_st+=str(node.val)\n            l=helper(node.left,num_st)\n            r=helper(node.right,num_st)\n            if not l and not r:\n                return int(num_st)\n            else:\n                return l+r\n\n        return helper(root,\"\")\n```\n\n```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def helper(node, num):\n            if node is None: return 0\n            num = num * 10 + node.val\n            l = helper(node.left, num)\n            r = helper(node.right, num)\n            return num if not l and not r else l + r\n        return helper(root, 0)\n```\n\n### complexity\n\nn 为节点个数\n\n- time: O(n)\n- spcae：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/17#issuecomment-1835368426","body":"### Solutions\n\n刚开始对题目理解有误，把 Left Tree Value 理解成了一定是左节点，其实就是最下面一层第一个节点的值，用 bfs 实现比较容易，需要注意是每次进入队列是右节点先进入，根据先进先出原则，最后出来的就是最左边的节点\n\n### code\n\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return\n        queue = [root]  # use list to simulate the queue\n        while queue:\n            node = queue.pop(0)  # Pop the leftmost node in the current level\n            if node.right:  # the right node should be append firstly\n                queue.append(node.right)\n            if node.left:\n                queue.append(node.left)\n            ans = node.val\n        # The last node visited in the bottom row is the leftmost value\n        return ans\n```\n\n### complexity\n\ntime: O(n)\nspace: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1837070764","body":"### solutions\n\n联想到平时比较常见的 json 的序列化和反序列化，序列化需要把二叉树转化成 string，反序列化把 string 转化成二叉树\n\n- 可以用 BFS 和 DFS 实现\n- 注意处理null节点从而保证结构的完整性\n- serilization and deserialization should be use same strategy. 比如 serilization use pre-order, deserialization use pre-order\n\n### code\n\n```python\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\"\"\"\n\n        def helper(node):\n            if node is None: return \"None\"\n            return \"\".join((str(node.val) + \",\" + helper(node.left) + \",\" + helper(node.right)))\n\n        return helper(root)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\"\"\"\n\n        def helper(data_list):\n            if data_list[0] == \"None\":\n                data_list.popleft()\n                return None\n            # if string is not None, construct the node\n            root = TreeNode(int(data_list[0]))\n            data_list.popleft()\n            root.left = helper(data_list)\n            root.right = helper(data_list)\n            return root\n\n        # use deque to improve the efficiency of poping the first item of list\n        data_list = collections.deque(data.split(\",\"))\n        return helper(data_list)\n```\n\n### complexity\n\nSerialization:\n\nTime Complexity: O(N)\nSpace Complexity: O(N)\nDeserialization:\n\nTime Complexity: O(N)\nSpace Complexity: O(N) in the worst case, O(log N) on average.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/19#issuecomment-1837454616","body":"### solutions\n\n参考官方题解\n\n- 用 dfs 方法遍历，按照题目 记录每要求格外传入 row，col 参数，记录每个节点坐标信息\n- 在遍历完成后，按照 col 为第一关键字升序，row 为第二关键字升序，value 为第三关键字升序，对所有的节点进行排序即可。\n- 输出时候将同一列的所有节点放入同一个数组中，对 nodes 进行一次遍历，并在遍历的过程中记录上一个节点的列号 lastcol。如果当前遍历到的节点的列号 col 与 lastcol 相等，则将该节点放入与上一个节点相同的数组中，否则放入不同的数组中\n\n### code\n\n```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        nodes = list()\n\n        def dfs(node: TreeNode, row: int, col: int) -> None:\n            if not node: return\n            nodes.append((col, row, node.val))\n            dfs(node.left, row + 1, col - 1)\n            dfs(node.right, row + 1, col + 1)\n\n        dfs(root, 0, 0)\n        nodes.sort()\n        ans, lastcol = list(), float(\"-inf\")\n\n        for col, row, value in nodes:\n            if col != lastcol:\n                lastcol = col\n                ans.append(list())\n            ans[-1].append(value)\n\n        return ans\n\n```\n\n### complexity\n\n-time: O(nlog⁡n)\n-space O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1837742857","body":"### solutions\n\n暴力法时间太长，用 list 切片再用 index 取索引效率也不够高，毕竟是数组，没法达到常数级别查找。采用 hash 法，用空间换时间。\n注意以下几点：\n\n- 不用一次先把所有元素放到字典，因为可能出现重复的 key，也会产生浪费的空间。只有当目标数找不到时候才把当前数字放到字典。\n- return 过后程序不会再往下走，不用写 else\n- 题目已经说了有唯一解，只有这个前置条件才能用字典\n\n### code\n\n```python\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        index_d = dict()\n        for i, num in enumerate(nums):\n            if target - num in index_d:\n                return [index_d[target - num], i]\n            index_d[num] = i\n\n```\n\n```python\n    def twoSum4(self, nums: List[int], target: int) -> List[int]:\n        for index1 in range(len(nums) - 1):\n            num1 = nums[index1]\n            num2 = target - num1\n            if num2 in nums[index1 + 1 :]:\n                index2 = nums[index1 + 1 :].index(num2)\n                return [index1, index1 + index2 + 1]\n```\n\n### complexity\n\n- space: 最坏情况下 O(n)\n- time: 最坏情况下 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/21#issuecomment-1840708650","body":"### solutions\n\n1. Python buildin collections.counter + 列表推导字典 value 排序，\n2. counter + buildin heap\n3. 手动构建堆，有些复杂，暂时还搞不出来\n\n### code\n\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        cn = collections.Counter(nums) # 统计list里面的value出现次数\n        #用value排序，再取key值\n        tmp = [x[0] for x in sorted(cn.items(), key=lambda item: item[1], reverse=True)]\n        return tmp[:k]\n\n```\n\n```python\nclass Solution2:\n    count = collections.Counter(nums)\n    min_heap = []\n    for i in count:\n        heapq.heappush(min_heap, (count[i], i))\n        if len(min_heap) > k:\n            heapq.heappop(min_heap)\n    return [num[1] for num in min_heap]\n```\n\n### complexity\n\nspace: O(n)\ntime: O(nlogk)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/22#issuecomment-1842731725","body":"## solutions\n\n这题目理解了很久，还是搞不懂，先是被 i 迷惑了，以为 xi，yi 和 i 有什么关系，也不知道 k 又是哪里来的。\n其实翻译过来就是坐标上任意三个点，A，B，C，如果有一个点到另外两个点具体距离一样则符合要求，记录下来，但是顺序必须是【中左右】或这【中右左】（假设中间一点到左右相等），每个点用 tuple 表示（x,y）\n\n- 用哈希表记录每个点到其他点的距离，距离一样则加一\n\n- 两个循环遍历所有点\n- 计算\n\n### code\n\n```python\n\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res=0\n        for i in range(len(points)):\n            hashmap=collections.defaultdict(int)\n            for j in range(len(points)):\n                distant=(points[i][0]-points[j][0])**2+(points[i][1]-points[j][1])**2\n                hashmap[distant]+=1\n                res+=hashmap[distant]*2-2\n        return res\n\n```\n\n### complexsity\n\nspace: O(n)\ntime: O(n\\*n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1844871411","body":"### Solutions\n\n通过双指针大法维护一个变动的或者固定的窗口大小，从而避免暴力搜索浪费时间\n\n- 创建一个字典存储字符和下标\n- r 指针永远往后移动\n- 左指针遇到重复字符出现时候更新。注意加一个判断，保证左指针往后移动。\n- 每次 r-l+1 迭代计算字符长度并取最大值\n\n### code\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s: return 0\n        l=0 # left pointer\n        max_l=0 # default max length\n        win_d=dict() # use dictionary to record the scaned characters and index\n        for r,ch in enumerate(s):\n            if ch in win_d and win_d[ch]>=l:  # the new left pointer have to grater than the old one\n                l=win_d[ch]+1   # update the left pointer\n            win_d[ch]=r\n            max_l=max(max_l,r-l+1)\n        return max_l\n```\n\n### complexity\n\nspace: O(n)\ntime:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/24#issuecomment-1846657367","body":"### solutions\n\n字典计数法：如果某一个连续的字符分割出来的字符 list 的每个 word 的数目和希望的一样，则满足需求，记录下标\n\n- 统计 words 里面每个 word 出现次数\n- 遍历字符串下标\n- 因为每个 word 长度相等，下标+3 为一个 word，如果在字典里面，则从当前下标开始取整个 words 长度，并分割成新的 words list\n- 统计新的 words list 和期望比较\n\n### code\n\n```python\n\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        words_counter = collections.Counter(words)\n        word_l = len(words[0])\n        words_l = word_l * len(words)\n        index = 0\n        while index + words_l <= len(s) and index < len(s):\n            if s[index : index + word_l] in words_counter:\n                tmp_list = [\n                    s[j : j + word_l] for j in range(index, index + words_l, word_l)\n                ]\n                if collections.Counter(tmp_list) == words_counter:\n                    res.append(index)\n            index += 1\n        return res\n```\n\n### complexity\n\nn 为 s 长度\nm 为 words 长度\n\n- time: 小于 O（n\\*n）\n- space： O（n+m）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/25#issuecomment-1848262085","body":"### solution\n\n没做过类似题目，没思路，参考官方题解 前缀和。\n\n### code\n\n```python\n\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        x = sum(nums) % p\n        if x == 0: return 0\n        y = 0\n        index = {0: -1}\n        ans = len(nums)\n        for i, v in enumerate(nums):\n            y = (y + v) % p\n            if (y - x) % p in index:\n                ans = min(ans, i - index[(y - x) % p])\n            index[y] = i\n        return ans if ans < len(nums) else -1\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/26#issuecomment-1848891696","body":"### solution\n\n快慢指针法，快指针移动速度为慢指针的两倍，快指针到终点时候，慢指针刚好到题目要求的中间位置。\n\n- 需要注意循环跳出条件需要加上 fast.next 不为空\n\n### code\n\n```python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head.next is None: return head\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\n\n### complexity\n\n- space: O(1)\n- time: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849216816","body":"### solution\n\n这题之前做过，用双指针法并不难解决。\n\n- 左右指针分别从 0，1 位置开始移动\n- right pointer 每次移动一位直到结束\n- 如果左右值不想等，则把 right pointer 指向的值赋值给左边，这样其实覆盖了两个场景，一个是左右指针相邻情况，一个是已经不相邻情况\n- 如果相等，则什么都不做，继续移动右指针\n- 需要注意最后返回不是数组，也不是下标，而是长度，需要左指针+1 ！\n\n### code\n\n```python\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) == 1: return 1  #返回是长度\n        l = 0\n        for r in range(1, len(nums)):\n            if nums[r] != nums[l]:\n                nums[l + 1] = nums[r]\n                l += 1\n        return l + 1\n```\n\n### complexity\n\n- space: O(1)\n- time: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1851349235","body":"### solution\n\n有序，单调递增，可以用二分法\n\n- 初始化左右指针为数组的两头\n- 取中间值开始比较，如果目标值恰好等于中间，则返回中间值的下标\n- 如果大于，则移动左指针\n- 如果小于，则移动右指针\n- 直到两个指针相遇\n\n### code\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l, r=0, len(nums)-1\n        while l<=r:\n            mid=l+(r-l)//2\n            if nums[mid]==target:\n                return mid\n            if target > nums[mid]:\n                l=mid+1\n            else:\n                r=mid-1\n        return l\n```\n\n### complexity\n\nspace: O(1)\ntime: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/29#issuecomment-1854131307","body":"### code\n\n刚开始用 max 法超时，参考官方双向队列\n\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        q = collections.deque()\n        for i in range(k):\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n\n        ans = [nums[q[0]]]\n        for i in range(k, n):\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n            while q[0] <= i - k:\n                q.popleft()\n            ans.append(nums[q[0]])\n        return ans\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/30#issuecomment-1855436495","body":"```python\n\nclass Solution:\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\n        # Create two lists to represent incoming and outgoing trusts for each person\n        in_degree = [0] * (N + 1)\n        out_degree = [0] * (N + 1)\n\n        # Iterate through the trust relationships and update the degrees\n        for a, b in trust:\n            out_degree[a] += 1\n            in_degree[b] += 1\n\n        # Check for a person who is trusted by everyone else (in-degree is N-1) and trusts nobody (out-degree is 0)\n        for i in range(1, N + 1):\n            if in_degree[i] == N - 1 and out_degree[i] == 0:\n                return i\n\n        return -1\n\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/31#issuecomment-1857341335","body":"参考官方题解，BFS\n\n```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        group = [[] for _ in range(n)]\n        for x, y in dislikes:\n            group[x - 1].append(y - 1)\n            group[y - 1].append(x - 1)\n        color = [0] * n  # color[x] = 0 表示未访问节点 x\n        def dfs(x: int, c: int) -> bool:\n            color[x] = c\n            return all(color[y] != c and (color[y] or dfs(y, -c)) for y in group[x])\n        return all(c or dfs(i, 1) for i, c in enumerate(color))\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/32#issuecomment-1858804133","body":"```python\n\nclass Solution:\n    def tp_sort(self, items, indegree, neighbors):\n        deque = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                deque.append(item)\n        while deque:\n            cur = deque.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    deque.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/33#issuecomment-1859015062","body":"> Problem: [657. 机器人能否返回原点](https://leetcode.cn/problems/robot-return-to-origin/description/)\r\n\r\n[TOC]\r\n\r\n# 思路\r\n\r\n> 通过分析题目之后发现，只要保证左右移动步数相等，上下移动步数相等即可，其实也就是统计字符串里面 L 和 R 的个数，U 和 D 个数是否相等\r\n\r\n# 解题方法\r\n\r\n> 直接调用 Collections.Counter 统计到字典里\r\n\r\n# 复杂度\r\n\r\n时间复杂度:\r\n\r\n> O(n) 统计个数至少要遍历一遍字符串\r\n\r\n空间复杂度:\r\n\r\n> 最大为 O(n)\r\n\r\n# Code\r\n\r\n```Python3\r\nclass Solution:\r\n    def judgeCircle(self, moves: str) -> bool:\r\n        moves_dic = collections.Counter(moves)\r\n        return moves_dic[\"U\"] == moves_dic[\"D\"] and moves_dic[\"L\"] == moves_dic[\"R\"]\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/34#issuecomment-1860578887","body":"```python\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        length = len(tasks)\n        indices = list(range(length))\n        indices.sort(key=lambda x: tasks[x][0])\n\n        ans = []\n        que = []  # Priority queue\n        timestamp, ptr = 0, 0\n\n        while ptr < length or que:\n            if not que:\n                timestamp = max(timestamp, tasks[indices[ptr]][0])\n\n            while ptr < length and tasks[indices[ptr]][0] <= timestamp:\n                heapq.heappush(que, (tasks[indices[ptr]][1], indices[ptr]))\n                ptr += 1\n\n            process, index = heapq.heappop(que)\n            timestamp += process\n            ans.append(index)\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/35#issuecomment-1862210490","body":"```python\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        # Convert to minutes\n        t0 = 60 * int(loginTime[:2]) + int(loginTime[3:])\n        t1 = 60 * int(logoutTime[:2]) + int(logoutTime[3:])\n        \n        # If logoutTime is on the next day, add 1440 minutes (24 hours)\n        if t1<t0: t1+=1440\n        \n        t1=t1//15*15\n        # Calculate the number of full rounds played\n        \n        return max(0, (t1-t0))//15\n```\n\n\n### complexity\n- space: O(1)\n- time: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/36#issuecomment-1863695016","body":"```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        # Initialize counters for each letter in the alphabet\n        counter1, counter2 = [0] * 26, [0] * 26\n\n        # Count occurrences of each letter in string 'a'\n        for c in a:\n            counter1[ord(c) - ord(\"a\")] += 1\n\n        # Count occurrences of each letter in string 'b'\n        for c in b:\n            counter2[ord(c) - ord(\"a\")] += 1\n\n        # Calculate minimum operations for condition 1\n        way1 = min(sum(counter1[i:]) + sum(counter2[:i]) for i in range(1, 26))\n\n        # Calculate minimum operations for condition 2\n        way2 = min(sum(counter2[i:]) + sum(counter1[:i]) for i in range(1, 26))\n\n        # Calculate minimum operations for condition 3\n        way3 = min(len(a) + len(b) - counter1[i] - counter2[i] for i in range(26))\n\n        # Return the overall minimum operations among the three conditions\n        return min(way1, way2, way3)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/37#issuecomment-1865577717","body":"> Problem: [912. 排序数组](https://leetcode.cn/problems/sort-an-array/description/)\n\n# 思路\n\n> 快排，随机取出一个数字作为哨兵，比较之后分成三个区域，小于，等于，大于，递归实现。\n> base case 为长度为一的时候直接返回数组自己\n\n# 复杂度\n\n时间复杂度:\n\n> 添加时间复杂度, 示例： $ O(n log n）$\n\n空间复杂度:\n\n> 添加空间复杂度, 示例： $O(log n)$\n\n# Code\n\n```Python3\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums)<=1: return nums\n        pos=random.choice(nums)\n        return self.sortArray([x for x in nums if x< pos]) + [x for x in nums if x==pos] + self.sortArray([x for x in nums if x > pos])\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/38#issuecomment-1867292261","body":"> Problem: [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/description/)\n\n# 思路\n\n> 二分法。需要注意两点：\n\n- 如果结果不是整数，跳出循环后需要减一\n- 右指针的边界值不用从 x 开始取，从中间开始取即可，因为一个数取平方根后必然小于他的一半\n\n# 复杂度\n\n时间复杂度:\n\n> 添加时间复杂度, 示例： $O(logx)$\n\n空间复杂度:\n\n> 添加空间复杂度, 示例： $O(1)$\n\n# Code\n\n```Python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x==0: return 0\n        l,r = 0, x//2+1\n        while l <=r:\n            mid=l+(r-l)//2\n            if mid*mid==x:\n                return mid\n            elif mid*mid > x:\n                r=mid-1\n            else:\n                l=mid+1\n        return l-1\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/39#issuecomment-1868182306","body":"> Problem: [278. 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/description/)\n\n# 思路\n\n> 有序数组，二分法。因为要找到第一个，其实就是其中元素不是唯一的，和有一道二分法题类似，多了一个判断，如果刚好找到那个数字前一个为 false，则为第一个直接返回，如果不是，则把右指针往前移动一位。刚开始用的嵌套两层 if，效率不高，统一用 elif 反而效率高了。\n\n# 解题方法\n\n> 描述你的解题方法\n\n# 复杂度\n\n时间复杂度:\n\n> 添加时间复杂度, 示例： $O(logn)$\n\n空间复杂度:\n\n> 添加空间复杂度, 示例： $O(1)$\n\n# Code\n\n```Python\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        if n == 1:\n            return 1\n        l, r = 1, n\n        while l <= r:\n            mid = l + (r - l) // 2\n            # 如果前面一个也为true，则继续往前找，否则直接返回\n            if isBadVersion(mid) and isBadVersion(mid - 1):\n                r = mid - 1\n            elif isBadVersion(mid) and not isBadVersion(mid - 1):\n                return mid\n            else:\n                l = mid + 1\n        return l\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/40#issuecomment-1868449424","body":"```python\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        n2_lst, res = [], 0\n        # 反转过后，下标大的就在前面了\n        for n in nums[::-1]:\n            res += bisect.bisect_left(n2_lst, n)\n            n2 = 2 * n\n            idx = bisect.bisect_left(n2_lst, n2)\n            n2_lst.insert(idx, n2)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/41#issuecomment-1868837844","body":"```python\nclass Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n        res = 0\n        heaters.sort()  # 加热器排序\n        for h in houses:  # 把房屋依次插入heaters list计算距离\n            r = bisect.bisect_right(heaters, h)  # 找到最右边插入位置\n            l = r - 1\n            rightDistance = heaters[r] - h if r < len(heaters) else float(\"inf\")  # 注意边界的处理\n            leftDistance = h - heaters[l] if l >= 0 else float(\"inf\")\n            curDistance = min(leftDistance, rightDistance)\n            res = max(res, curDistance)\n        return res\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/42#issuecomment-1869283495","body":"```python\n\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        def count(mid: int) -> int:\n            cnt = 0\n            for j, num in enumerate(nums):\n                i = bisect_left(nums, num - mid, 0, j)\n                cnt += j - i\n            return cnt\n\n        nums.sort()\n        return bisect_left(range(nums[-1] - nums[0]), k, key=count)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/43#issuecomment-1870022453","body":"```python\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        res = 0\n        n = len(grid)\n        heap = [(grid[0][0],0,0)]\n        visited = set([(0,0)])\n        \n        while heap:\n            height,x,y = heapq.heappop(heap)\n            res = max(res,height)\n            if x == n-1 and y == n-1:\n                return res\n            \n            for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)]:\n                new_x,new_y = x + dx,y + dy\n                if 0 <= new_x < n and 0 <= new_y < n and (new_x,new_y) not in visited:\n                    visited.add((new_x,new_y))\n                    heapq.heappush(heap,(grid[new_x][new_y],new_x,new_y))\n        \n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/44#issuecomment-1871163102","body":"\n> Problem: [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)\n\n[TOC]\n\n# 思路\n\n> 滑动窗口\n\n# 解题方法\n\n- 初始化一个滑动窗口，计算里面元音字母数量\n- 开始向后滑动，如果后面一个是则+1\n- 如果前面一个不是，则-1\n\n# 复杂度\n\n时间复杂度:\n $O(n)$\n\n空间复杂度:\n> 添加空间复杂度, 示例： $O(1)$\n\n\n\n# Code\n```Python3 []\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        vowels = \"aeiou\"\n        max_vowels,cur_vowels = 0,0\n\n\n        # Count vowels in the first window of length k\n        for i in range(k):\n            if s[i] in vowels:\n                cur_vowels += 1\n\n        max_vowels = cur_vowels\n        if max_vowels==k: return k\n\n        # Slide the window through the rest of the string\n        for i in range(k, len(s)):\n            if s[i - k] in vowels:\n                cur_vowels -= 1\n            if s[i] in vowels:\n                cur_vowels += 1\n                if max_vowels==k: return k\n                max_vowels = max(max_vowels, cur_vowels)\n\n        return max_vowels\n```\n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/45#issuecomment-1871823096","body":"```python\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        if k == 0 or n >= k + maxPts: return 1.0\n\n        dp = [0.0] * (n + 1)\n        dp[0] = 1.0\n        window_sum = 1.0  # Sum of probabilities in the sliding window\n\n        for i in range(1, n + 1):\n            dp[i] = window_sum / maxPts\n            if i < k:\n                window_sum += dp[i]\n            if i - maxPts >= 0:\n                window_sum -= dp[i - maxPts]\n\n        result = sum(dp[i] for i in range(k, n + 1))\n        return result\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/46#issuecomment-1872438961","body":"\n> Problem: [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)\n\n[TOC]\n\n# 思路\n\n> 滑动窗口法，统计p长度内的每个字符出现次数，相等则取起始下标\n\n# 解题方法\n\n> 可以用字典和列表两种方式统计。\n- 列表需要用ord方法影射下标\n- 字典需要注意移除为0的key\n\n# 复杂度\n\n时间复杂度:\n>  $O(n)$\n\n空间复杂度:\n>  $O(1)$\n\n\n\n# Code\n```Python3 []\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        s_len,p_len = len(s),len(p)\n        if s_len<p_len: return []\n        res=[]\n        s_cnt=[0]*26\n        p_cnt=[0]*26\n        for i in range(p_len):\n            s_cnt[ord(s[i]) - 97] += 1\n            p_cnt[ord(p[i]) - 97] += 1\n        if s_cnt == p_cnt:\n            res.append(0)\n        for i in range(len(p),len(s)):\n            s_cnt[ord(s[i]) - 97]+=1\n            s_cnt[ord(s[i-p_len])-97]-=1\n            if s_cnt==p_cnt:\n                res.append(i-p_len+1)\n        return res\n```\n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/47#issuecomment-1872657095","body":"```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        s_len, t_len = len(s), len(t)\n        if t_len > s_len:\n            return \"\"\n\n        cnt = collections.Counter(t)\n        need = t_len\n\n        start, end = 0, -1\n        min_len = s_len + 1\n        l = r = 0\n\n        for r in range(s_len):\n            ch = s[r]\n            if ch in cnt:\n                if cnt[ch] > 0:\n                    need -= 1\n            cnt[ch] -= 1\n\n            while need == 0:\n                if r - l + 1 < min_len:\n                    min_len = r - l + 1\n                    start, end = l, r\n                ch = s[l]\n                if ch in cnt:\n                    if cnt[ch] >= 0:\n                        need += 1\n                    cnt[ch] += 1\n                l += 1\n        return s[start : end + 1]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/48#issuecomment-1873103812","body":"### solution\n\n越到后面编号越大的题目，题目描述越绕，所以卷到后面就开始叠加阅读理解考察了，这题转化过来其实就是\n\n- 从 nums 移除一个和为(sum(nums)-x)的最长子数组\n\n- 双指针实现\n\n### code\n\n```python\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        target = sum(nums) - x #子数组目标和\n        if target < 0:  # 小于0，则不存在\n            return -1\n        res = -1\n        l = 0\n        sum_n = 0\n        for r, v in enumerate(nums):\n            sum_n += v\n            while sum_n > target: #大于目标，移动左指针\n                sum_n -= nums[l]\n                l += 1\n            if sum_n == target: # 等于目标，开始计算窗口大小\n                res = max(res, r - l + 1)\n        return -1 if res < 0 else len(nums) - res\n```\n\n### complexity\n\n- space: O(1)\n- time: O(n) 最坏情况下 2n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/49#issuecomment-1873866709","body":"```python\nfrom typing import List\n\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        # Initialize an empty list to store the resulting times\n        res = list()\n\n        # Iterate through all possible hours (0 to 11)\n        for h in range(12):\n            # Iterate through all possible minutes (0 to 59)\n            for m in range(60):\n                # Check if the total number of illuminated LEDs is equal to the given 'turnedOn'\n                if bin(h).count(\"1\") + bin(m).count(\"1\") == turnedOn:\n                    # If true, add the formatted time string to the result list\n                    res.append(f\"{h}:{m:02d}\")\n\n        # Return the list of valid times\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/50#issuecomment-1875282717","body":"```python\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def is_safe(board, row, col):\n            # Check if there is a queen in the same column\n            for i in range(row):\n                if board[i] == col or \\\n                board[i] - i == col - row or \\\n                board[i] + i == col + row:\n                    return False\n            return True\n\n        def backtrack(row):\n            nonlocal count\n            if row == n:\n                count += 1\n                return\n            for col in range(n):\n                if is_safe(board, row, col):\n                    board[row] = col\n                    backtrack(row + 1)\n\n        count = 0\n        board = [-1] * n\n        backtrack(0)\n        return count\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/54#issuecomment-1876824670","body":"\n> Problem: [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/description/)\n\n[TOC]\n\n# 思路\n\n> 和https://leetcode.cn/problems/number-of-islands/description/ 几乎一样，\ndfs遍历每个grid格子，遇到1的时候为入口，唯一不同的是需要计算每个岛屿面积，也就是每个岛屿有几个格子，也就是每次遇到1的时候几个数字并返回。\n\n\n\n# 复杂度\n\n时间复杂度:\n $O(n*m)$\n\n空间复杂度:\n $O(n*n)$\n\n\n\n# Code\n```Python3 []\nfrom typing import List\n\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        def dfs(grid, r, c):\n            if r < 0 or c < 0 or r >= len(grid) or c >= len(grid[0]):\n                return 0\n            if grid[r][c] == 0 or grid[r][c] == 2:\n                return 0\n            if grid[r][c] == 1:\n                grid[r][c] = 2  # Mark as visited\n                area = 1\n                area += dfs(grid, r + 1, c)\n                area += dfs(grid, r - 1, c)\n                area += dfs(grid, r, c + 1)\n                area += dfs(grid, r, c - 1)\n                return area\n\n        max_area = 0\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    max_area = max(max_area, dfs(grid, r, c))\n\n        return max_area\n```\n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/55#issuecomment-1878318606","body":"```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        # 获取网格的大小\n        n = len(grid)\n        \n        # 初始化步数为 0\n        steps = 0\n        \n        # 将所有陆地的坐标添加到队列中\n        queue = collections.deque((i, j) for i in range(n) for j in range(n) if grid[i][j] == 1)\n        \n        # 如果队列为空或者队列的大小等于网格的大小，说明没有水域或者所有格子都是水域\n        if len(queue) == 0 or len(queue) == pow(n, 2):\n            return steps - 1\n\n        # 使用BFS进行遍历\n        while queue:\n            # 遍历当前队列中的所有元素\n            for area in range(len(queue)):\n                # 弹出队列中的元素坐标\n                x, y = queue.popleft()\n                \n                # 遍历当前位置的上下左右四个相邻位置\n                for xi, yj in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n                    # 如果相邻位置在网格范围内且为水域\n                    if 0 <= xi < n and 0 <= yj < n and grid[xi][yj] == 0:\n                        # 将水域坐标加入队列\n                        queue.append((xi, yj))\n                        # 将水域标记为已访问，减少值以避免重复访问\n                        grid[xi][yj] -= 1\n            \n            # 每完成一轮的遍历，步数加一\n            steps += 1\n        \n        # 返回步数减一，因为最后一次循环没有进入下一层级\n        return steps - 1\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/56#issuecomment-1879505309","body":"```python\nimport collections\nfrom typing import List\n\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n        # 获取盒子的总数\n        n = len(status)\n        \n        # 判断是否可以打开每个盒子\n        can_open = [status[i] == 1 for i in range(n)]\n        \n        # 记录每个盒子是否拥有糖果和是否已经使用过\n        has_box, used = [False] * n, [False] * n\n        \n        # 使用双端队列作为BFS的数据结构\n        q = collections.deque()\n        \n        # 初始化答案为0\n        ans = 0\n        \n        # 将初始盒子放入队列，并处理可以打开的情况\n        for box in initialBoxes:\n            has_box[box] = True\n            if can_open[box]:\n                q.append(box)\n                used[box] = True\n                ans += candies[box]\n        \n        # 开始BFS\n        while len(q) > 0:\n            # 弹出队列中的盒子\n            big_box = q.popleft()\n            \n            # 处理当前盒子中的钥匙\n            for key in keys[big_box]:\n                can_open[key] = True\n                # 如果钥匙可以打开并且盒子未使用过并且盒子存在\n                if not \n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/57#issuecomment-1879917995","body":"```python\nclass TreeNode:\n    def __init__(self, key):\n        self.val = key\n        self.left = None\n        self.right = None\n\ndef top_view(root):\n    if not root:\n        return []\n\n    result = []\n    queue = deque([(root, 0)])  # (node, horizontal_distance)\n    horizontal_distance_map = defaultdict(list)\n\n    while queue:\n        node, hd = queue.popleft()\n\n        if hd not in horizontal_distance_map:\n            horizontal_distance_map[hd].append(node.val)\n\n        if node.left:\n            queue.append((node.left, hd - 1))\n        if node.right:\n            queue.append((node.right, hd + 1))\n\n    # Sort the result based on horizontal distance\n    sorted_hd = sorted(horizontal_distance_map.keys())\n    for hd in sorted_hd:\n        result.append(horizontal_distance_map[hd][0])\n\n    return result\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/58#issuecomment-1880333068","body":"\n> Problem: [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)\n\n[TOC]\n\n# 思路\n\n> 经典动态规划题，和青蛙跳楼梯类似，由于每次只能跳一步或者两步，当前位置最小值只能是前两个格子最小值，所以状态转移方程为dp[i]=min(dp[i-1],dp[i-2])+cost[i]\n\n# 解题方法\n\n> 由于只和前两个格子相关，内存空间还可以进一步优化，和fibonacci sequence类似，只用两个变量存储即可\n\n# 复杂度\n\n时间复杂度:\n>  $O(n)$\n\n空间复杂度:\n>  $O(n)$\n\n\n\n# Code\n```Python3 []\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        dp=[0]*len(cost)\n        dp[0],dp[1]=cost[0],cost[1] \n        for i in range(2,len(cost)):\n            dp[i]=min(dp[i-1],dp[i-2])+cost[i]\n        return min(dp[-1],dp[-2])\n```\n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/59#issuecomment-1882409659","body":"\n> Problem: [198. 打家劫舍](https://leetcode.cn/problems/house-robber/description/)\n\n[TOC]\n\n# 思路\n\n>    动态规划，和昨天https://leetcode.cn/problems/min-cost-climbing-stairs/description/\n    基本类似，只不过爬楼梯是找最小开销，这个是找最大费用\n    从最小集合开始推导，如果是3个格子，第三个要取最大，要么1+3格子值最大，要么取第二个\n    通过推到发现当前最大值只和前面两个格子有关，可以优化内存空间\n\n# 解题方法\n\n> 描述你的解题方法\n\n# 复杂度\n\n时间复杂度:\n $O(n)$\n\n空间复杂度:\n $O(1)$\n\n\n\n# Code\n```Python3 []\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n== 1: return nums[0]\n        if n==2: return max(nums[0],nums[1])\n        a, b = nums[0], max(nums[0],nums[1])\n        for i in range(2,n):\n           a, b =b, max(nums[i]+a,b)\n            \n        return b\n```\n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/60#issuecomment-1884305396","body":"```python\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        nums.append(float('inf'))\n        n = len(nums)\n        dp = [1]*n  # dp[i] 表示以位置i结尾的最长子序列的长度\n        max_cnt = [1]*n  # max_cnt[i] 表示以位置i结尾的最长子序列的个数\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if dp[i] < dp[j] + 1:\n                        dp[i] = dp[j] + 1\n                        max_cnt[i] = max_cnt[j]\n                    elif dp[i] == dp[j] + 1:\n                        max_cnt[i] += max_cnt[j]\n        return max_cnt[n-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/61#issuecomment-1886364709","body":"```python\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        # Get the lengths of the input texts\n        m, n = len(text1), len(text2)\n        \n        # Create a 2D array to store the length of the common subsequence\n        # dp[i][j] represents the length of the common subsequence of text1[:i] and text2[:j]\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        # Iterate through the texts to fill the dp array\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                # If the current characters match, extend the common subsequence\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                # If the characters don't match, take the maximum length from the previous rows or columns\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        # The final value in the dp array represents the length of the longest common subsequence\n        return dp[m][n]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/62#issuecomment-1888281650","body":"\n> Problem: [62. 不同路径](https://leetcode.cn/problems/unique-paths/description/)\n\n[TOC]\n\n# 思路\n\n> 动态规划，通过观察发现只能向下和向右移动，因此除去第一列和第一行，剩下满足状态转移dp[r][c]=dp[r-1][c]+dp[r][c-1]\n\n# 解题方法\n\n> 以前写过一篇解答\nhttps://zhuanlan.zhihu.com/p/43358393\n\n# 复杂度\n\n时间复杂度:\n> $O(n*n)$\n\n空间复杂度:\n>  $O(n*m)$\n\n\n\n# Code\n```Python3 []\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp=[[1]*n]*m\n        for r in range(m):\n            for c in range(n):\n                if r>0 and c>0:\n                    dp[r][c]=dp[r-1][c]+dp[r][c-1]\n        return dp[m-1][n-1]\n```\n  \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rennzhang":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1813974720","body":"## 思路\n\n### 1. “暴力解法”\n\n作为一个算法小白，会自然而然带入平时对写业务的理解来实现，即：\n- 求 num 数组实际数字总和，`[1,2,0,0]` => `1200`\n- 总和加 `k`, `1200 + k`\n- 转为字符串遍历，在放到新的数组中\n\n> 但学算法应该从数据结构的特性出发\n\n### 2. 倒序-逐个相加-进位\n\n通过倒序遍历数组，从个位开始相加 `k`，并记录进位\n-  `k` 加当前位大于 9 时，保留个位\n- 处理进位，减去个位除以10（十进制）\n- 处理最后位，即最终剩余进位 加`num[0]` 大于9，需要再次向前进位的情况\n\n### 代码\n```js\nvar addToArrayForm = function (num, k) {\n  let carry = k;\n  let res = [];\n\n  for (let idx = num.length - 1; idx >= 0; idx--) {\n    let cur = num[idx];\n    // 向 res 数组中 push 相加后所得的个位数\n    res.push((cur + carry) % 10);\n    // 处理进位，减去个位除以10\n    carry = Math.floor((cur + carry) / 10);\n  }\n\n  while (carry > 0) {\n    res.push(carry % 10);\n    carry = Math.floor(carry / 10);\n  }\n\n  return res.reverse();\n};\n\n```\n\n### 复杂度分析\n\n- 时间复杂度：`O(n + log(k-n))`,\n- 时间复杂度：`O(n + (k - n))`\n\n> 对于时间复杂度：遍历 `num`需要 `O(n)` 时间 ，处理多余进位的情况为`O(log(k-n))`\n\n> 对于空间复杂度：新开了一个数组，其长度是 `n + (k - n)`, `k - n` 是最后处理剩余进位的情况\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1816073277","body":"## 题目\r\n[821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\n\r\n```py\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n```\r\n## 思路\r\n\r\n### 双向遍历\r\n\r\n第一次正向遍历，找到 c 后，index 为 0，后续每一个递增 1，直到找到下一个 c，重复上述步骤。\r\n\r\n第二次反向遍历，从每个 c 的下一个坐标位判断当前位 是否大于 `上一位+1`，如果大于则替换更小的距离\r\n\r\n\r\n### 代码\r\n```js\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = [len(s)] * len(s)\r\n        for i in range(0,len(s)):\r\n            pre = res[i - 1] + 1 \r\n            if s[i] == c:\r\n                res[i] = 0\r\n            else:\r\n                res[i] = pre\r\n\r\n        for i in range(len(s)-1,-1,-1):\r\n            if 0 <= i+1 < len(s):\r\n                res[i] = min(res[i], res[i+1]+1)\r\n        return res\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：`O(n)`\r\n> for的时间复杂度为 O(n), 两次 for 总体为 O(n)\r\n\r\n---\r\n\r\n- 时间复杂度：`O(n)`\r\n> 对数组 res 进行操作，长度是 s 的长度，所以为 O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817496067","body":"## 题目\n[1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/description/)\n\n## 思路\n当进行`increment`操作时，让所有元素一次出栈进入另一个临时栈，然后再依次入栈并执行相加操作\n\n\n## 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n  this.topPos = 0;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  // 说明已经在栈顶的位置了，不能继续push\n  if (this.topPos >= this.maxSize) return;\n  this.topPos += 1;\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  if (this.topPos == 0) return -1;\n  this.topPos -= 1;\n  return this.stack.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  const tempStack = [];\n  const len = this.topPos;\n\n  while (this.topPos) {\n    tempStack.push(this.pop());\n  }\n  for (let i = 1; i <= len; i++) {\n    let ele = tempStack.pop();\n    if (i <= k) ele += val;\n    this.push(ele);\n  }\n};\n\n```\n\n## 复杂度分析\n\n- 时间复杂度：`O(2n)`,\n> 需要进行两次遍历出入栈操作\n\n- 空间复杂度：`O(2maxSize)`\n> 需要多维护一个临时栈\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1818510090","body":"## 题目\n[394. 字符串解码](https://leetcode.cn/problems/decode-string/)\n\n## 思路\n当进行`increment`操作时，让所有元素一次出栈进入另一个临时栈，然后再依次入栈并执行相加操作\n\n\n## 代码\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  const stack = [];\n  let str = \"\";\n  let num = \"\";\n  for (let i = 0; i < s.length; i++) {\n    const el = s[i];\n    if (el == \"]\") {\n      let popEl = \"\";\n      let tempS = \"\";\n      while (popEl !== \"[\") {\n        popEl = stack.pop();\n        if (popEl !== \"[\") {\n          tempS = popEl + tempS;\n        }\n      }\n      let nnn = parseInt(stack.pop())\n      for (let ii = 0; ii < nnn; ii++) {\n        stack.push(tempS);\n      }\n    } else if (el == \"[\") {\n      stack.push(num);\n      num = \"\";\n      stack.push(el);\n    } else if (!isNaN(parseInt(el))) {\n      num += el;\n    } else {\n      stack.push(el);\n    }\n  }\n\n  while (stack.length) {\n    str = stack.pop() + str;\n  }\n  return str;\n};\n\n```\n## 复杂度分析\n\n- 时间复杂度：`O(N)`\n\n- 空间复杂度：`O(N)`\n\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818271221","body":"## 题目\n[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n## 思路\n按照题目所说，使用两个栈来操作，我的思路是`队列每次进行 push 操作`时，同时对 `栈A 进行入栈操作`，直到队列使用`pop\\peek` 方法时，操作 A 栈全部弹出并依次入栈 B，此时栈顶就是队列首部。\n\n队列的`push`操作依旧全部同时入栈 A，直到栈 B 为空并且队列使用`pop\\peek`时，重复以上步骤。\n\n\n## 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stackA = []\n        self.stackB = []\n\n\n    def push(self, x: int) -> None:\n        self.stackA.append(x)\n\n\n    def pop(self) -> int:\n        self.transferEl()\n        return self.stackB.pop()\n\n\n    def peek(self) -> int:\n        self.transferEl()\n        return self.stackB[-1]\n\n\n    def empty(self) -> bool:\n        return not self.stackA and not self.stackB\n    \n    def transferEl(self) -> None:\n        if not self.stackB:\n            while self.stackA:\n                self.stackB.append(self.stackA.pop())\n\n```\n## 复杂度分析\n\n- 时间复杂度：`O(N)`,\n\n- 空间复杂度：`O(N)`\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1820608707","body":"## 题目\n[768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/description/)\n\n## 思路\n利用递增[单调栈](https://lucifer.ren/blog/2020/11/03/monotone-stack/)实现：\n\n遍历数组，如果栈顶元素大于当前元素，则一直 pop 到小于为止（不包括等于，等于可以分一个块）\n\n另外有一个关键点(`append操作`)卡住了，比如 `[2, 3, 1, 4, 2, 5, 6, 8]`\n\n\n当：`元素等于4` 时\n栈: `[1]`\n\n当：`元素等于2` 时\n栈: `[1,4]`\n\n如果继续按照单调栈操作，则会得到栈`[1, 2, 4]`，显然不合理，因为前面有一个3被弹出了，所以应该记录下栈中的最大值，并且入栈元素应该是一个最小块中的最大值，确保不会影响后面的块，后面的块应该保持最小值`>=`上一个块的最大值\n\n\n> 确实很难，题目看半天才理解，需要先了解下前置知识，单调栈\n\n## 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr) -> int:\n        stack = []\n        max_val = 0\n        for c in arr:\n            while(len(stack) > 0 and c < stack[-1]):\n                k = stack.pop()\n                # 取栈中的最大值\n                max_val = max(max_val,k)\n\n            stack.append(max(c,max_val))\n        return len(stack)\n```\n## 复杂度分析\n\n- 时间复杂度：`O(N)`\n> 遍历数组，并且对栈进行操作，最换的情况是所有元素都入栈一次，所以总体时间复杂度为 O(N)\n\n- 空间复杂度：`O(N)`\n> 栈的空间不会超过数组的最大长度，再加一个`max_val`变量，总体为 N\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822846158","body":"## 题目\n[61. 旋转链表](https://leetcode.cn/problems/rotate-list/)\n\n## 思路\n整体思路是用`while`找到链表最后一个节点，同时将所有的节点按照next顺序记录到数组中去\n\n然后应该算出一个最小的操作数，即`k % 链表的节点个数`，余数就是需要操作的次数，其他的都是多余操作\n\n可以按照算出的操作次数倒序遍历`record`逐个进行链表节点修改，但其实可以合并为一次操作：\n\n- 即从`record`数组中倒数 `k+1` 一直到数组中最后一个“这一串”链表就是需要操作的结点\n- 直接把这一串拼到原链表最前方即可，也就是只需要修改一次即可\n\n\n## 代码\n```python\nclass Solution:\n    def rotateRight(self, head, k: int) -> ListNode:\n        if not k or not head or not head.next: return head\n        # 用数组记录所有的指针\n        record = [head]\n\n        endNode = head\n        while endNode.next:\n            endNode = endNode.next\n            record.append(endNode)\n\n        # 去掉多余的操作\n        k = k % len(record)\n        if not k: return head \n\n        # 从数组记录中取出需要旋转的串，直接拼到最前端\n        pre = record[-(k+1)]\n        newHead = pre.next\n        record[-1].next = head\n        pre.next = None\n        \n        return newHead\n```\n## 复杂度分析\n\n- 时间复杂度：`O(N)`\n> while 遍历，最大长度是链表的长度，即 N\n\n- 空间复杂度：`O(N)`\n> 开辟的新数组长度同样为链表的长度，所以也是N\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1824130225","body":"## 题目\n[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)\n\n## 思路\n思路挺简单，但一直调不对，指针修改有点绕\n\n- 定义一个虚拟头结点，作为前置节点和最后 return 方便使用\n\n- while循环，定义`node1` 为当前的节点，`node2` 为下一个节点\n\n    - 把 `node1.next` 指向 `node2` 的下一个节点\n\n    - 把 `node2.next` 指向 `node1`\n\n    - 把 `pre.next` 指向 `node2`, 如此便完成了一次交换\n\n- 注意题目描述为`两两交换`，因此直接把 `pre` 设置为上面操作完成后面的节点，相当于直接跳过了后面奇数节点的交换操作\n\n\n## 代码\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:  \n        if not head or not head.next: return head\n        dump = ListNode(-1)\n        dump.next = head\n        pre = dump\n\n        while head and head.next:\n            node1 = head\n            node2 = head.next\n\n            pre.next = node2\n            node1.next = node2.next\n            node2.next = node1\n\n            pre = node1\n            head = head.next\n        \n        return dump.next\n```\n## 复杂度分析\n\n- 时间复杂度：`O(N)`\n> while 遍历，最大长度是链表的长度，即 N\n\n- 空间复杂度：`O(1)`\n> 未开辟新的空间，只对链表进行操作，并且声明常数个变量，总体为 O(1)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/11#issuecomment-1826369885","body":"哈希法\n## 代码\n```js\nvar getIntersectionNode = function (headA, headB) {\n\n  \n  let map = new Map()\n\n  let nextA = headA\n  while (nextA) {\n    map.set(nextA,true)\n    nextA = nextA.next\n  }\n  \n  let nextB = headB\n  while (nextB) {\n    if (map.get(nextB)) return nextB\n    nextB = nextB.next\n  }\n  return null\n};\n```\n## 复杂度分析\n\n- 时间复杂度：`O(N)`\n\n- 空间复杂度：`O(N)`\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826721455","body":"## 题目\n[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)\n\n## 思路\n第一种是借助哈希实现\n\n第二种是双指针\n\n- 快指针走两步，慢指针走一步，如果有环一定会相遇，不相遇则说明没有环\n\n- 记录相遇点，作为“断开点”，把他当做相交链表来处理即可\n\n\n\n## 代码\n```py\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: return None\n        fast=head.next\n        slow = head\n        while fast != slow:\n            if not fast or not fast.next: return None\n            fast = fast.next.next\n            slow = slow.next\n            if slow == slow.next: return slow\n        \n        a = head\n        b = slow.next\n        \n        while a!=b:\n            a = a.next\n            b= b.next\n            if not a: a = slow.next\n            if not b: b = head\n        \n        return a \n```\n## 复杂度分析\n\n- 时间复杂度：`O(N)`\n\n- 空间复杂度：`O(1)`\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1827999743","body":"## 题目\n[146. LRU 缓存机制](https://leetcode.cn/problems/lru-cache/)\n\n## 思路\n题目有要求时间复杂度必须`O(1)`，因此不能使用遍历的方式；\n\n首先看了下 `LRU缓存` 的概念，用链表实现简单来说就是，链表一头是最新的，另一头是最旧的。因此在`get` 或者 `put` 时应该把当前放到最新的那一头，而当超出的时候从最旧的那一头移除一个节点即可，同时需要更新哈希表；\n\n所以至少需要一个虚拟头结点和虚拟尾节点，可以直接获取到 `使用频率最高或最低的节点`，那么尾节点需要一个 `prev` 指针，并且 `put` 的节点可能在链表的任何位置，在不借助其他结构存储节点位置的情况（如用数组），那么每个节点都需要有一个 `prev` 指针，用来修改前后节点的指针，至此，能确定这道题需要用到`双向链表`。\n\n但细节比较多，尤其是指针的操作，很容易出错，最终代码还是参考了题解写出来的。\n\n\n\n## 代码\n```js\n/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n  this.capacity = capacity;\n  this.head = new ListNode();\n  this.last = new ListNode();\n  this.head.next = this.last;\n  this.last.prev = this.head;\n  this.useSpace = 0\n  this.map = {};\n};\n\nLRUCache.prototype.isFull = function () {\n  return this.useSpace == this.capacity;\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n  let node = this.map[key];\n  if (node) {\n    this.appendHead(this.removeNode(node));\n    return node.val;\n  }\n  return -1;\n};\nLRUCache.prototype.removeNode = function (node) {\n  node.prev.next = node.next;\n  node.next.prev = node.prev;\n  node.prev = null;\n  node.next = null;\n\n  return node;\n};\n\nLRUCache.prototype.appendHead = function (node) {\n  node.prev = this.head;\n  node.next = this.head.next;\n  this.head.next = node;\n  node.next.prev = node;\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n  if (key in this.map) {\n    let node = this.map[key]\n    this.appendHead(this.removeNode(node));\n    this.map[key] = node\n\n    node.val = value;\n  } else {\n    if (this.isFull()) {\n      const node = this.last.prev;\n      delete this.map[node.key];\n      const newNode = this.removeNode(node)\n      newNode.val = value\n      newNode.key = key\n      this.appendHead(newNode);\n      this.map[key] = newNode\n    } else {\n      let node = new ListNode(value);\n      node.key = key\n      this.appendHead(node);\n      this.map[key] = node\n      this.useSpace ++\n    }\n  }\n};\n\n```\n## 复杂度分析\n\n- 时间复杂度：`O(1)`\n\n- 空间复杂度：`O(N)`\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829019800","body":"## 题目\n[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)\n\n## 思路\n一碰到递归大脑就像浆糊，这道题看第一眼觉得很简单，但其实不然，代码慢慢调出来通过后，才慢慢理清楚思路的。\n\n简单来说就是两个变量，记录每次递归的根节点的左树和右树的最大层数，也就是如果当前根节点有左子节点，那么 `maxL + 1`，右子节点同理`maxR + 1`，如果没有子节点了就停止了，但另一边还在继续，这样每次递归返回`max(maxL, maxR)`即可\n\n\n\n## 代码\n```py\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode], _max = 1) -> int:\n        if not root:\n            return 0\n        maxL = _max\n        maxR = _max\n\n        if root.left:\n            maxL = self.maxDepth(root.left, maxL + 1)\n\n        if root.right:\n            maxR = self.maxDepth(root.right, maxR + 1)\n\n        return max(maxL, maxR)\n```\n\n\n## 复杂度分析\n\n- 时间复杂度：`O(N)`\n\n> 使用递归，次数为二叉树的节点数量\n\n- 空间复杂度：`O(1)`\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831419638","body":"## 题目\n[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)\n\n## 思路\n\n### 方法一\n\n利用递归加上 DFS 的思路，即每次递归对比传入的两个树节点是否相同，相同则继续递归，直到找到不相同的返回 `False`, 否则返回 `True`\n\n### 方法二\n\n利用栈来做对比，栈的初始值是 `[p, q]`，如果栈不为空则取出两个节点（分别是两个树的同一位置的节点）进行比较：\n- 如果都为 `null`，跳过进行下一次\n- 对比他们的值是否相同\n  - 不同则`return False`\n  - 相同则按组想栈中添加节点，即 `append[树1的左子节点，树2的左子节点] append[树1的右子节点，树2的右子节点]`\n- 进入下一次对比\n\n\n\n\n\n## 代码\n```py\n# 方法一：递归 + DFS\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        return bool(\n            p\n            and q\n            and p.val == q.val\n            and self.isSameTree(p.left, q.left)\n            and self.isSameTree(p.right, q.right)\n        )\n```\n\n\n```py\n# 方法二：利用栈实现\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n\n        stack = [[p, q]]\n\n        while len(stack):\n            [n1, n2] = stack.pop()\n\n            if not n1 and not n2:\n                continue\n            if not n1 or not n2 or n1.val != n2.val:\n                return False\n\n            stack.append([n1.left, n2.left])\n            stack.append([n1.right, n2.right])\n\n        return not stack\n```\n\n## 复杂度分析\n- 时间复杂度：`O(N)`\n\n> 以上两种方法的时间复杂度都是 N，递归或者遍历，最坏的情况是遍历所有节点\n\n- 空间复杂度：`O(h)` \n\n> h介于 logN 和 N之间，如果树是一个平衡二叉树，最好的情况是 logN，当树是 完全偏斜的树 时是 N\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1851455652","body":"```js\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar searchInsert = function (nums, target) {\r\n  let l = 0;\r\n  let r = nums.length - 1;\r\n  while (l <= r) {\r\n    let mid = parseInt((l + r) / 2);\r\n    if (nums[mid] === target) return mid;\r\n    if (nums[mid] < target) {\r\n      l = mid + 1;\r\n    } else {\r\n      r = mid - 1;\r\n    } \r\n  }\r\n\r\n    return l\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"larscheng":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1813980726","body":"### 思路\n- 从低位开始逐位相加，相加结果大于10，则当前位的数字对10取余，同时进位，收集当前位数字\n- 如果k的位数大于num的长度，则按位收集剩余数字\n- 将数组反转\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n\n        for (int i = num.length - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k = k / 10;\n            if (sum >= 10) {\n                //进位，当前位取余数\n                k++;\n                sum = sum % 10;\n            }\n            list.add(sum);\n        }\n        //k位数 大于num.length\n        while (k > 0) {\n            list.add(k % 10);\n            k = k / 10;\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1816132306","body":"### 思路\n- 遍历字符串每一个元素，如果当前元素为目标字符，则距离为0\n- 从当前元素出发，分别向左、右寻找目标字符，最先找到目标字符，即为最小距离\n### 代码\n```java\n    class Solution {\n        public int[] shortestToChar(String s, char c) {\n            int[] result = new int[s.length()];\n\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == c) {\n                    result[i] = 0;\n                    continue;\n                }\n                int l = i--;\n                int r = i++;\n                while (l >= 0 || r < s.length()) {\n                    if (l >= 0) {\n                        if (s.charAt(l) == c) {\n                            result[i] = Math.abs(i - l);\n                            break;\n                        } else {\n                            l--;\n                        }\n                    }\n                    if (r < s.length()) {\n                        if (s.charAt(r) == c) {\n                            result[i] = Math.abs(i - r);\n                            break;\n                        } else {\n                            r++;\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n    }\n```\n### 复杂度\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1819024319","body":"### 思路\n暴力：\n- 长度为100的数组 stack存储队列元素，变量len记录已使用的位数\n- push：入栈，len++\n- peek：返回数组第首个元素\n- pop：删除stack[0]，剩余元素整体前移，返回删除的stack[0]\n- empty：判断数组第一个元素是否为0\n\n双栈（利用栈：**先进后出**的特性，来实现队列**先进先出**）：\n- 定义两个栈intput/output\n- push：入栈元素压入input（先进后出）\n- peek(pop)：若output无元素，将input中的元素压入output(先进后出)，从output中peek(pop)出栈\n- empty：判断两个栈中元素是否为空\n\n整体流程如下，通过在两个栈中流转，实现了队列特性：先进先出\n压入input[1,2,3] => input出栈[3,2,1] => 压入output[3,2,1] => output出栈[1,2,3]\n\n### 代码\n```java\n//双栈\nclass MyQueue {\n\n    Stack<Integer> input;\n    Stack<Integer> output;\n    public MyQueue() {\n        input = new Stack<>();\n        output = new Stack<>();\n    }\n    \n    public void push(int x) {\n        input.push(x);\n    }\n    \n    public int pop() {\n        if (output.empty()){\n            in2out();\n        }\n        return output.pop();\n    }\n    \n    public int peek() {\n        if (output.empty()){\n            in2out();\n        }\n        return output.peek();\n    }\n\n    private void in2out() {\n        while (!input.empty()){\n            output.push(input.pop());\n        }\n    }\n\n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n}\n```\n\n### 复杂度\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1820674975","body":"### 思路\r\n- 数组拆分 => 局部升序 => 合并所有子序列 => 与原数组升序一致\r\n\r\n要保证最终合并后的序列整体升序，那么拆分出来的数组块之间，必须要为递增趋势\r\n- [2,1,3,4,4] 可拆分为 [2, 1], [3, 4, 4] , 第1块的中所有数组整体都小于第2块\r\n- [2,1,3,4,4] 可拆分为 [2, 1], [3], [4], [4], 可见数组块之间整体递增趋势\r\n题目要求最大可拆分数量，可见第二种方案符合条件\r\n\r\n结合单调栈：***找下一个大于xxx、下一个小于xxx的思路***.  \r\n保证最终留在栈内的都是每一轮寻找的最大值，栈的大小即为最大拆分块数\r\n\r\n>单调栈：栈内元素有序，出栈顺序升序为单调递增栈，出栈顺序降序为单调递减栈.  \r\n\r\n>构造单调栈的过程：https://lucifer.ren/blog/2020/11/03/monotone-stack/ （推荐配合食用）\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        for (int num : arr) {\r\n            if (stack.isEmpty() || stack.peek() <= num){\r\n                stack.push(num);\r\n            }else {\r\n                int max = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > num) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(max);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)，数组中的元素最多只会入栈出栈1次，n为数组长度\r\n- 空间复杂度：O(n)，额外空间栈的大小即为数组长度n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822647874","body":"### 思路1\n观察示例不难发现，右旋k位，实际上的链表操作为：记录原始链表第k位节点，最后一位节点next=头节点，倒数k+1位节点next=null、返回原链表倒数第k位节点\n\n所以核心思路即为：***寻找链表倒数第N个节点***-----\n> 特殊情况：k超出链表节点个数时，右旋k位等同于右旋k%count，如果k%count==0，则无需旋转\n\n代码流程如下\n1. 统计链表节点个数\n2. 快慢指针寻找倒数第k+1个节点\n3. 进行节点旋转操作\n\n### 代码\n```java\nclass Solution{\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k==0) {\n            return head;\n        }\n        ListNode result;\n        int len = 1;\n        //统计链表节点个数\n        ListNode current = head;\n        while (current.next != null) {\n            current = current.next;\n            len++;\n        }\n        k = k % len;\n        if (k == 0) {\n            return head;\n        }\n        //寻找倒数第k+1位\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast.next != null) {\n            if (k <= 0) {\n                slow = slow.next;\n            }\n            fast = fast.next;\n            k--;\n        }\n        //进行旋转操作\n        result = slow.next; //记录倒数第k位（原始链表中倒数k+1位的next）\n        fast.next = head;   //最后一位节点next=头节点\n        slow.next = null;   //倒数k+1位节点next=null\n        return result;\n    }\n}\n```\n### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n### 思路2\nn个刻度的环形密码锁，旋转到指定位置\n将链表练成环，找到目标位置length-(k%length)，断开链表环\n### 代码\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k==0) {\n            return head;\n        }\n        int len = 1;\n        //统计链表节点个数\n        ListNode current = head;\n        while (current.next != null) {\n            current = current.next;\n            len++;\n        }\n        //成环\n        current.next = head;\n        //寻找断环节点\n        int index = len - (k % len) ;\n        for (int i = 1; i < index; i++) {\n            head = head.next;\n        }\n        //断开链表环\n        ListNode result = head.next; \n        head.next = null;   //断开环\n        return result;\n    }\n}\n```\n### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1824412451","body":"### 思路\n递归\n假设others为已经交换完成的链表\n> [item1 -> item2 -> others] ===>  [item2 -> item1 -> others]\n交换结束后：item1.next = others，item2.next为item1\n\n伪代码\n- item1.next = 已交换完成的链表头节点\n- item2.next = item1\n- 返回 item2\n\n已交换完成的链表头节点的逻辑 即可通过递归实现\n### 代码\n```java\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        //[1,2,3,4]\n        ListNode temp = head.next;\n        //其他节点递归交换 1->[4,3]\n        head.next = swapPairs(temp.next);\n        //2->[1,4,3]\n        temp.next = head;\n        return temp;\n    }\n\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/10#issuecomment-1825619535","body":"### 思路\n先找到单链表中的中间结点的值，然后依次递归迭代的构建出左右子树\n> 所以，核心点就是从单链表中找到中间结点\n\n使用双指针slow、fast，让slow每次走一步，fast走两步，那么当fast走到尾部的时候，slow刚好走到中间位置\n### 代码\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        };\n        ListNode mid = this.findMiddle(head);\n        TreeNode node = new TreeNode(mid.val);\n        if (head == mid) {\n            return node;\n        }\n        node.left = this.sortedListToBST(head);\n        node.right = this.sortedListToBST(mid.next);\n        return node;\n    }\n\n    public ListNode findMiddle(ListNode node) {\n        if (node == null) {\n            return null;\n        }\n        ListNode pre = null;\n        ListNode slow = node;\n        ListNode fast = node;\n        while (fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        if (pre != null) {\n            pre.next = null;\n        }\n        return slow;\n    }\n}\n```\n### 复杂度\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/11#issuecomment-1826283546","body":"### 思路\n***双指针*** 定义两个指针a,b\n- 当 a 指针将 A 链表遍历完后，重定位到链表 B 的头结点，\n- b 指针将 B 链表遍历完后，重定位到链表 A 的头结点, \n- 然后继续遍历至相交点。\n\n最终当a,b两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度\n\n### 代码\n```java\npublic class Solution {\n\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n\n        if(headA == null || headB == null) {\n            return null;\n        }\n        ListNode a = headA, b = headB;\n        while (a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826616433","body":"### 思路\n> 思路1: 哈希表匹配，思路简单，遍历一次，但是需要一个长度为n的哈希表（O(n)/O(n)）\n\n> 思路2: 双指针\n\n双指针通过两次相遇，找到环的起点\n- 假设链表共有a+b个节点（a个环外节点，b个环内节点）\n- 第一次遍历：fast每次2步，slow每次1步，双指针相遇时，此时slow与环入口节点的距离为a（再走a步就能到达入口节点）\n- 第二次遍历：fast、slow每次都1步，fast从头节点开始，slow从当前节点开始，双指针相遇时，即为环的入口节点\n\n> 推导过程可参考：[环形链表||](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/)\n### 代码\n```java\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while (true) {\n            if (fast == null || fast.next == null) return null;\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) break;\n        }\n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1827772637","body":"### 思路\n分析题目：数据需要频繁的O(1)增删（`链表`）、需要通过O(1)查询（`哈希表`）\n确定数据结构：哈希表+双向链表 \n注意点：\n- get：需要将当前节点移动到头节点\n- put：容量已满时链表尾部节点即为最久未使用节点，要进行删除\n- 使用虚拟头部和虚拟尾部避免边界判断\n\n参考讲义：[链表-套路五：设计题](https://leetcode-solution.cn/solutionDetail?type=2&id=2002&max_id=2008)\n### 代码\n```java\nclass LRUCache {\n    class ListNode{\n\n        int key;\n        int val;\n        ListNode pre;\n        ListNode next;\n        public ListNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n        public ListNode() {}\n    }\n    HashMap<Integer,ListNode> map = new HashMap<>();\n    ListNode head;\n    ListNode tail;\n    int size;\n    int capacity;\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        this.head = new ListNode();\n        this.tail = new ListNode();\n        //dummyhead ⇄ ..... ⇄ dummytail\n        //虚拟头\n        this.head.next = this.tail;\n        //虚拟尾\n        this.tail.pre = this.head;\n    }\n    \n    public int get(int key) {\n        ListNode node = map.get(key);\n        if (node != null) {\n            del(node);\n            addHead(node);\n            return node.val;\n        } else {\n            return -1;\n        }\n    }\n\n\n    public void put(int key, int value) {\n        ListNode node = map.get(key);\n        if (node != null) {\n            node.val = value;\n            map.put(key, node);\n\n            del(node);\n            addHead(node);\n        } else {\n            ListNode newNode = new ListNode(key,value);\n            if (size >= capacity) {\n                //del tail\n                map.remove(this.tail.pre.key);\n                del(this.tail.pre);\n                this.size--;\n            }\n            map.put(key, newNode);\n            addHead(newNode);\n            this.size++;\n        }\n    }\n\n\n    private void del(ListNode listNode) {\n        //del\n        ListNode pre = listNode.pre;\n        ListNode next = listNode.next;\n        pre.next = next;\n        next.pre = pre;\n    }\n\n    private void addHead(ListNode listNode) {\n        //dummyhead     ⇄   otherNode   ⇄   dummytail\n        //dummyhead ⇄ listNode ⇄ otherNode ⇄ dummytail\n        listNode.pre = this.head;\n        listNode.next = this.head.next;\n        this.head.next.pre = listNode;\n        this.head.next = listNode;\n    }\n}\n```\n### 复杂度\n- 时间复杂度： put 和 get 都是 O(1)。\n- 空间复杂度：O(n)，n为链表长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829258682","body":"### 思路\n深度优先搜索，使用递归方式\n> 树的深度 = Max(左子树深度, 右子树深度) + 1\n### 代码\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root==null){\n            return 0;\n        }\n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n        return Math.max(leftDepth,rightDepth)+1;\n    }\n}\n```\n### 复杂度\n- 时间复杂度：O(N)，N为树的节点数量\n- 空间复杂度：O(N)，N为最大递归深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831163380","body":"### 思路\n1. 递归-深度优先搜索\n> 同时遍历两颗树，递归过程中判断2颗树的当前节点是否为空，如果不为空判断值是否相等\n2. 队列-广度优先搜索\n> 两个队列存储两棵树每一层的节点，比对每层元素是否为空，值是否相等，遍历结束后判断两个队列是否为空\n### 代码\n```java\n// DSF深度优先搜索\n    class Solution {\n        public boolean isSameTree(TreeNode p, TreeNode q) {\n            if (p == null && q == null) {\n                return true;\n            }\n            if (p == null || q == null) {\n                return false;\n            }\n            if (p.val != q.val) {\n                return false;\n            }\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n```\n```java\n// BSF广度优先搜索\n    class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        Deque<TreeNode> queue1 = new LinkedList<>();\n        Deque<TreeNode> queue2 = new LinkedList<>();\n        queue1.offer(p);\n        queue2.offer(q);\n\n        while (!queue1.isEmpty() && !queue2.isEmpty()) {\n            TreeNode poll1 = queue1.poll();\n            TreeNode poll2 = queue2.poll();\n            if (poll1.val!=poll2.val){\n                return false;\n            }\n            TreeNode left1 = poll1.left;\n            TreeNode right1 = poll1.right;\n            TreeNode left2 = poll2.left;\n            TreeNode right2 = poll2.right;\n            if ((left1 == null && left2 != null) || (left2 == null && left1 != null)) {\n                return false;\n            }\n            if ((right1 == null && right2 != null) || (right2 == null && right1 != null)) {\n                return false;\n            }\n            if (left1!=null){\n                queue1.push(left1);\n            }\n            if (right1!=null){\n                queue1.push(right1);\n            }\n            if (left2!=null){\n                queue2.push(left2);\n            }\n            if (right2!=null){\n                queue2.push(right2);\n            }\n        }\n        return queue1.isEmpty()&&queue2.isEmpty();\n    }\n}\n```\n### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1833091211","body":"### 思路\n1.递归-深度优先搜索\n> 先序遍历整棵树  \n> 当前节点为空，则直接返回，当前节点不为空则进行加和  \n> 当前节点为叶子节点时返回加和结果，不为叶子节点则递归计算子节点  \n> 将左右子树递归结果加和  \n\n2.队列-广度优先搜索\n> 1个队列用来存储每层节点，1个队列用来存储每个节点对应的当前累加值  \n> 如果当前节点为叶子节点（无左右子节点），获取当前节点对应的累加值，计入结果  \n> 如果当前节点有子节点，则收集子节点、子节点对应的累加值，继续遍历  \n\n### 代码\n\n```java\n//递归-深度优先遍历\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    private int dfs(TreeNode root, int result) {\n        if (root == null) {\n            //左子树为空或者右子树为空\n            return 0;\n        }\n        result = result * 10 + root.val;\n\n        if (root.left == null && root.right == null) {\n            //当前节点为叶子节点\n            return result;\n        } else {\n            //非叶子节点\n            return dfs(root.left, result) + dfs(root.right, result);\n        }\n    }\n}\n```\n\n```java\n//队列-广度优先搜索\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        if (root==null){\n            return 0;\n        }\n        int result = 0;\n        Deque<TreeNode> nodeQueue = new LinkedList<>();\n        Deque<Integer> sumQueue = new LinkedList<>();\n        nodeQueue.offer(root);\n        sumQueue.offer(root.val);\n        while (!nodeQueue.isEmpty() && !sumQueue.isEmpty()) {\n            TreeNode node = nodeQueue.poll();\n            Integer sum = sumQueue.poll();\n            TreeNode left = node.left;\n            TreeNode right = node.right;\n            if (left == null && right == null) {\n                result += sum;\n            }\n            if (left != null) {\n                nodeQueue.offer(left);\n                sumQueue.offer(sum * 10 + left.val);\n            }\n            if (right != null) {\n                nodeQueue.offer(right);\n                sumQueue.offer(sum * 10 + right.val);\n            }\n\n        }\n        return result;\n    }\n}\n```\n### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/17#issuecomment-1835537342","body":"### 思路\r\n找树左下角最左边的值：  \r\n在广度优先搜索中，等同于找最后一层左起第1个节点，或者最后一层右起最后1个节点  \r\n> 广度优先搜索使用队列，有先进先出特性，所以每层右节点先入队列，然后遍历到最后1个就是左起第1个元素  \r\n \r\n在深度优先搜索中，等同于找最大高度中的第1个左节点  \r\n> 后序遍历+递归实现，全局变量记录当前已检查的高度，和当前高度的左节点值  \r\n> 检查递归过程中的高度和当前记录的已检查高度，前者大，则收集新的左节点值  \r\n### 代码\r\n```java\r\n//队列-广度优先搜索\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        if (root == null){\r\n            return 0;\r\n        }\r\n        int result = 0;\r\n        Deque<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        while (!queue.isEmpty()) {\r\n            TreeNode node = queue.poll();\r\n            if (node.right!=null){\r\n                queue.offer(node.right);\r\n            }\r\n            if (node.left!=null){\r\n                queue.offer(node.left);\r\n            }\r\n            result = node.val;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n```java\r\n// 递归-深度优先搜索\r\nclass Solution {\r\n    int curVal;\r\n    int curHeight;\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        dfs(root,0);\r\n        return curVal;\r\n    }\r\n\r\n    private void dfs(TreeNode root, int height) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n        height++;\r\n        dfs(root.left, height);\r\n        dfs(root.right, height);\r\n        //当前递归中的高度 > 此时记录的高度 说明高度增加，最左节点需要记录为当前值\r\n        if (height > curHeight) {\r\n            curHeight = height;\r\n            curVal = root.val;\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1836978064","body":"### 思路\r\n序列化：先序遍历，记录每个节点值，叶子节点的空子树null也进行记录，节点值之间用`,`分隔\r\n反序列化：字符串转为先序遍历的元素列表，然后从左向右遍历，解析左右子树\r\n### 代码\r\n```java\r\npublic class Codec {\r\n    public String serialize(TreeNode root) {\r\n        return encode(root, \"\");\r\n    }\r\n\r\n    public String encode(TreeNode root, String str) {\r\n        if (root == null) {\r\n            str += \"null,\";\r\n        } else {\r\n            str += root.val + \",\";\r\n            str = encode(root.left, str);\r\n            str = encode(root.right, str);\r\n        }\r\n        return str;\r\n    }\r\n\r\n\r\n    public TreeNode deserialize(String data) {\r\n        List<String> list = new LinkedList<>(Arrays.asList(data.split(\",\")));\r\n        return decode(list);\r\n    }\r\n    public TreeNode decode(List<String> dataList) {\r\n        String val = dataList.get(0);\r\n        if (\"null\".equals(val)) {\r\n            dataList.remove(0);\r\n            return null;\r\n        }\r\n\r\n        TreeNode root = new TreeNode(Integer.parseInt(val));\r\n        dataList.remove(0);\r\n        root.left = decode(dataList);\r\n        root.right = decode(dataList);\r\n\r\n        return root;\r\n    }\r\n}\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/19#issuecomment-1837429091","body":"### 思路\r\n在对二叉树进行深度优先遍历时，记录每个节点的col、row、val信息\r\n使用TreeMap结构存储这些信息，key为列号：`列号 -> {[行号,节点值],[行号,节点值]...}`\r\n对遍历结果map按照题目要求进行转换，同列行号升序、同行同列元素值升序\r\n### 代码\r\n```java\r\n    class Solution {\r\n        //列号 -> {[行号,节点值],[行号,节点值]...}\r\n        TreeMap<Integer,List<int[]>> map = new TreeMap<>();\r\n        public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n            //收集每个节点的col、row、val\r\n            dfs(root,0,0);\r\n            //将map内的没列数据排序后转为list\r\n            return map2List();\r\n        }\r\n\r\n        private List<List<Integer>> map2List() {\r\n            List<List<Integer>> result = new ArrayList<>();\r\n            for (Integer col : map.keySet()) {\r\n                List<int[]> items = map.get(col);\r\n                //同行a[0]==b[0]，根据元素值升序排\r\n                //不同行a[0]!=b[0],根据行号升序排\r\n                items.sort((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\r\n                //收集当前列已经排序好的数据\r\n                result.add(items.stream().map(item -> item[1]).collect(Collectors.toList()));\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // dfs 收集每个元素的col、row、val到map\r\n        private void dfs(TreeNode root, int col, int row) {\r\n            if (root == null) {\r\n                return;\r\n            }\r\n            List<int[]> items = map.getOrDefault(col, new ArrayList<>());\r\n            items.add(new int[]{row, root.val});\r\n            map.put(col, items);\r\n            dfs(root.left, col - 1, row + 1);\r\n            dfs(root.right, col + 1, row + 1);\r\n        }\r\n    }\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(NlogN)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1838017777","body":"### 思路\r\n遍历数组，通过哈希表记录每个元素的值和下标\r\n遍历过程中从哈希表中寻找是否有 target-current\r\n如果存在，则直接返回两数下标，如果不存在，则将当前元素和下标存入哈希表\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        //val - index\r\n        Map<Integer,Integer> map = new HashMap<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            int num = target-nums[i];\r\n            if (map.containsKey(num)) {\r\n                return new int[]{i, map.get(num)};\r\n            } else {\r\n                map.put(nums[i], i);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/21#issuecomment-1840205555","body":"### 思路\r\n哈希表存储：元素值-出现频率\r\n大顶推按元素出现次数排序，将全部元素入堆\r\n大顶堆弹出k个元素\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer,Integer> map = new HashMap<>();\r\n        for (int num : nums) {\r\n            map.put(num, map.getOrDefault(num, 0) + 1);\r\n        }\r\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> map.get(b)-map.get(a));\r\n        queue.addAll(map.keySet());\r\n\r\n        int[] result = new int[k];\r\n        for (int i = 0; i < k; i++) {\r\n            result[i] = queue.poll();\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 复杂度\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/22#issuecomment-1842165618","body":"### 思路\r\n以i为起点，统计与i距离相等的 j,k 的组合个数\r\n假设有n个点到 i 的距离相等，从n中取出2个则有 n(n-1) 种取法\r\n- 遍历所有的点，当前坐标点作为起点\r\n  - 计算他与其他坐标点的距离，记录相同距离出现的次数到map\r\n  - 遍历map，累加符合条件的坐标点数量\r\n\r\n\r\n> 两点间距离：(x1-x2)^2 + (y1-y2)^2 = distance^2\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int result = 0;\r\n        for (int[] a : points) {\r\n            //distance -> count\r\n            Map<Integer, Integer> map = new HashMap<>();\r\n            for (int[] b : points) {\r\n                if (a == b) {\r\n                    continue;\r\n                }\r\n                int distance = (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\r\n                map.put(distance, map.getOrDefault(distance, 0) + 1);\r\n            }\r\n\r\n            for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\r\n                result += entry.getValue() * (entry.getValue() - 1);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n^2)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1844837218","body":"### 思路\r\n通过双指针构建滑动窗口，窗口内只能存放无重复的子串，移动窗口过程中，最大窗口值即为最长无重复子串.   \r\n- 右指针移动过程中记录每个元素及其下标至哈希表中，并记录最大窗口值\r\n- 如果出现重复元素，则移动左指针到当前元素的下一位，收缩窗口，继续遍历\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        if (s.isEmpty()) {\r\n            return 0;\r\n        }\r\n        int result = 0;\r\n        //字符-下标位置\r\n        HashMap<Character, Integer> map = new HashMap<>();\r\n        //左指针\r\n        int left = 0;\r\n        for (int right = 0; right < s.length(); right++) {\r\n            if (map.containsKey(s.charAt(right))) {\r\n                //收缩窗口，左指针为重复元素的下一位置\r\n                left = Math.max(left, map.get(s.charAt(right)) + 1);\r\n            }\r\n            map.put(s.charAt(right), right);\r\n            //取最大窗口\r\n            result = Math.max(result, right - left + 1);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/24#issuecomment-1846746291","body":"### 思路\r\n- 传统滑动窗口，指针每次移动步长为1，本题中每个单词的长度都相同，可以改造为每次移动步长1个单词  \r\n- 改造后，从下标0开始，每次步长1个单词进行滑动窗口逻辑，会漏掉从下标1、2、3...开始的滑动窗口逻辑  \r\n> 所以需要一个多起点、指定移动步长的滑动窗口  \r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int strLen = s.length();\r\n        int len = words.length;\r\n        int wordLen = words[0].length();\r\n        int subLen = words[0].length() * len;\r\n        if (strLen<subLen){\r\n            return result;\r\n        }\r\n        //map 记录words每个单词出现次数\r\n        Map<String,Integer> map = new HashMap<>();\r\n        for (String word : words) {\r\n            map.put(word, map.getOrDefault(word, 0) + 1);\r\n        }\r\n\r\n        for (int i = 0; i < wordLen; i++) {\r\n            //多个起点的滑动窗口，每次滑动一个单词长度wordLen\r\n            Map<String,Integer> subMap = new HashMap<>();\r\n            //起点为i，步长为wordLen\r\n            for (int j = i; j <= strLen-wordLen; j+=wordLen) {\r\n                String curWord = s.substring(j, j + wordLen);\r\n                subMap.put(curWord, subMap.getOrDefault(curWord, 0) + 1);\r\n                //判断窗口内是否需要移动\r\n                if (j - i >= subLen) {\r\n                    //移动左窗口：map中最左侧单词,出现次数减1或者删除\r\n                    int start = j-subLen;\r\n                    String first = s.substring(start, start + wordLen);\r\n                    if (subMap.get(first)==1){\r\n                        subMap.remove(first);\r\n                    }else {\r\n                        subMap.put(first,subMap.get(first)-1);\r\n                    }\r\n                }\r\n                if (!map.containsKey(curWord)){\r\n                    continue;\r\n                }\r\n                if (subMap.equals(map)){\r\n                    result.add(j+wordLen-subLen);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n>  n 为字符串 s 的长度，m 为数组 words 的长度（单词的个数），w 为单个单词的长度\r\n- 时间复杂度：O(m + w* n) 收集每个单词出现频率 O(m)  多个起点(单词长度w)* 字符串长度 O(w*n)\r\n- 空间复杂度：O(m*w) 每个滑动窗口都需要一个map 空间，共有w个容量为m的map","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/25#issuecomment-1848245507","body":"### 思路\r\n\r\n数组能被p整除，即元素之和sum%p==0，若不能整除，必然会有余数x\r\n找到数组中元素和为x或者元素和%p==x的最短子数组即可\r\n\r\n题解参考：[【套路】前缀和+哈希表](https://leetcode.cn/problems/make-sum-divisible-by-p/solutions/1/tao-lu-qian-zhui-he-ha-xi-biao-pythonjav-rzl0/)\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int minSubarray(int[] nums, int p) {\r\n        int n = nums.length, ans = n;\r\n        var s = new int[n + 1];\r\n        for (int i = 0; i < n; ++i)\r\n            s[i + 1] = (s[i] + nums[i]) % p;\r\n        int x = s[n];\r\n        if (x == 0) return 0;\r\n\r\n        var last = new HashMap<Integer, Integer>();\r\n        for (int i = 0; i <= n; ++i) {\r\n            last.put(s[i], i);\r\n            // 如果不存在，-n 可以保证 i-j >= n\r\n            int j = last.getOrDefault((s[i] - x + p) % p, -n);\r\n            ans = Math.min(ans, i - j);\r\n        }\r\n        return ans < n ? ans : -1;\r\n    }\r\n}\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/26#issuecomment-1848907034","body":"### 思路\r\n快慢指针\r\n- 定义两个指针，fast/slow，fast每次移动2步，slow每次移动1步\r\n- 当fast移动到最后一个节点时，slow即为中间节点\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849820175","body":"### 思路\r\n双指针\r\n- 定义a，b两个指针，a始终指向数组中最后一个不重复的数字，b指向待遍历数字，初始状态a=0，b=1；\r\n- 遍历数组元素，当 nums[a] == nums[b] 时，指针a不动，指针b继续移动\r\n- 当 nums[a] != nums[b] 时，指针b的数字移动到a+1处，指针a，b都向后移动\r\n- 直到指针b遍历结束，指针a即为最后一个不重复的数字，a+1即为唯一元素个数\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int a = 0;\r\n        int b = 1;\r\n        while (b < nums.length) {\r\n            if (nums[a] != nums[b]) {\r\n                nums[a + 1] = nums[b];\r\n                a++;\r\n            }\r\n            b++;\r\n        }\r\n        return a + 1;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1851513555","body":"### 思路\r\n- 原始2分查找，可以通过指针遍历元素，查找目标元素\r\n- 本题稍作变化，当找不到目标元素时，返回第一个大于他的元素下标\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int mid, left = 0, result = 0;\r\n        int right = nums.length - 1;\r\n        while (left < right) {\r\n            mid = left + (right - left) / 2;\r\n            if (nums[mid] == target) {\r\n                //存在直接返回\r\n                return mid;\r\n            }else if (nums[mid] > target){\r\n                //不存在记录大于target的位置\r\n                result = mid;\r\n                right = mid - 1;\r\n            }else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(log n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/29#issuecomment-1853533176","body":"### 思路\r\n**大顶堆**\r\n数组形式记录元素下标和元素值，在大顶堆中维护一个滑动窗口，堆顶为最大值\r\n- 当堆中元素大于等于k时，取出堆顶元素，同时判断该元素是否在滑动窗口范围内：\r\n- 在窗口范围内：记录堆顶元素\r\n- 不在窗口范围内：弹出该元素，继续取在范围内的堆顶元素\r\n\r\n> 判断是否在滑动窗口内：判断堆中元素的下标值是否小于窗口左端元素下标(i-k+1),i为窗口右端元素下标\r\n<hr>\r\n\r\n**双端队列**\r\n大顶堆实现需要在窗口中维护完整的k个元素，但实际上滑动过程中如果新元素大于窗口中所有原本的元素，最终的有效结果只会是新元素\r\n所以这种情况时，我们可以只保留这个最大元素在窗口中，最终滑动窗口中的元素会形成一个单调递减趋势\r\n- 可以通过双端队列来保存滑动窗口内的元素下标\r\n- 右移时判断新元素与老元素的大小，只保留大于新元素的数\r\n- 右移过程中维护最左侧窗口外失效元素的移除，最终取出窗口内最左端元素即可\r\n\r\n\r\n### 代码\r\n```java\r\n//大顶堆\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        PriorityQueue<int[]> queue = new PriorityQueue<>((o1, o2) -> o2[1] - o1[1]);\r\n        int[] result = new int[nums.length - k + 1];\r\n        int index = 0;\r\n        for (int i = 0; i < nums.length; i++) {\r\n            queue.offer(new int[]{i, nums[i]});\r\n            if (queue.size() >= k) {\r\n                //最大值在窗口外，则直接丢弃\r\n                while (queue.peek()[0] < i - k + 1) {\r\n                    queue.poll();\r\n                }\r\n                //取出最大值，放入新数组\r\n                result[index++] = queue.peek()[1];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n\r\n```java\r\n// 双端队列\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        int[] result = new int[nums.length - k + 1];\r\n        int index = 0;\r\n        Deque<Integer> deque = new ArrayDeque<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            //当前元素大于窗口内元素，清除窗口元素\r\n            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {\r\n                deque.pollLast();\r\n            }\r\n            deque.addLast(i);\r\n            //窗口收缩，小于左端点（i - k + 1）都移除\r\n            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {\r\n                deque.pollFirst();\r\n            }\r\n            //当前下标大于等于窗口大小时，开始收集结果\r\n            if (i >= k - 1) {\r\n                result[index++] = nums[deque.peekFirst()];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n#### 大顶堆\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)\r\n#### 双端队列\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/30#issuecomment-1855036815","body":"### 思路\r\n图的入度出度\r\n> 编号为 ai 的人信任编号为 bi 的人，可表示为：ai的出度+1，bi的入度+1\r\n> 最终法官的出度为0，入度为n-1\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int findJudge(int n, int[][] trust) {\r\n        int[] in = new int[n+1];\r\n        int[] out = new int[n+1];\r\n        for (int[] ints : trust) {\r\n            //入度+1\r\n            in[ints[1]]++;\r\n            //出度+1\r\n            out[ints[0]]++;\r\n        }\r\n        //法官：入度=n-1(除法官自己外所有人都信任法官)、出度=0(法官不信任任何人)\r\n        //检查数字从1开始到n\r\n        for (int i = 1; i <= n; i++) {\r\n            if (in[i] == n - 1 && out[i] == 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n- 时间复杂度：O(m+n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/31#issuecomment-1857404490","body":"### 思路\r\n邻接矩阵建立dislike图，记录每个元素的分组情况，0-未分组，1-a组，-1-b组\r\n### 代码\r\n```java\r\n\r\nclass Solution {\r\n    public boolean possibleBipartition(int n, int[][] dislikes) {\r\n        List<Integer>[] matrix = new ArrayList[n + 1];\r\n        for (int i = 1; i < matrix.length; i++) {\r\n            matrix[i] = new ArrayList(n + 1);\r\n        }\r\n        //邻接矩阵记录dislikes 矩阵中记录每行元素的dislike元素\r\n        for (int[] item : dislikes) {\r\n            matrix[item[0]].add(item[1]);\r\n            matrix[item[1]].add(item[0]);\r\n        }\r\n        // 记录分组情况 0，-1，1\r\n        int[] record = new int[n + 1];\r\n        for (int i = 1; i < matrix.length ; i ++){\r\n            if (record[i] == 0 && !dfs(matrix, record, i, 1)) {\r\n                //未分组，分组失败\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private boolean dfs(List<Integer>[] matrix, int[] record, int index, int group) {\r\n        record[index] = group;\r\n        //检查当前元素的所有dislike\r\n        List<Integer> dislike = matrix[index];\r\n        for (int i = 0; i < dislike.size() ; i++) {\r\n            int num = dislike.get(i);\r\n            // 已分组且同一组，直接返回失败\r\n            if (record[num] == group) {\r\n                return false;\r\n            }\r\n            // 没分组，dfs进行分组，扔进对立组\r\n            if (record[num] == 0 && !dfs(matrix, record, num, group * -1)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n- 时间复杂度：O(n+m)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/32#issuecomment-1858816417","body":"### 思路\r\n本题个人感觉难度较大，参考了题解先打个卡，知识点：建图、入度出度、拓扑排序\r\n参考题解：  [【图解】拓扑排序（1203. 项目管理）](https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/solutions/556721/tu-jie-tuo-bu-pai-xu-1203-xiang-mu-guan-4xrll/)、[1203. 项目管理-视频讲解](https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/solutions/556811/1203-xiang-mu-guan-li-by-leetcode-t63b/)\r\n### 代码\r\n```java\r\n\r\npublic class Solution {\r\n\r\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\r\n        for (int i = 0; i < group.length; i++) {\r\n            if (group[i] == -1) {\r\n                group[i] = m;\r\n                m++;\r\n            }\r\n        }\r\n\r\n        // 第 2 步：实例化组和项目的邻接表\r\n        List<Integer>[] groupAdj = new ArrayList[m];\r\n        List<Integer>[] itemAdj = new ArrayList[n];\r\n        for (int i = 0; i < m; i++) {\r\n            groupAdj[i] = new ArrayList<>();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            itemAdj[i] = new ArrayList<>();\r\n        }\r\n\r\n        // 第 3 步：建图和统计入度数组\r\n        int[] groupsIndegree = new int[m];\r\n        int[] itemsIndegree = new int[n];\r\n\r\n        int len = group.length;\r\n        for (int i = 0; i < len; i++) {\r\n            int currentGroup = group[i];\r\n            for (int beforeItem : beforeItems.get(i)) {\r\n                int beforeGroup = group[beforeItem];\r\n                if (beforeGroup != currentGroup) {\r\n                    groupAdj[beforeGroup].add(currentGroup);\r\n                    groupsIndegree[currentGroup]++;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            for (Integer item : beforeItems.get(i)) {\r\n                itemAdj[item].add(i);\r\n                itemsIndegree[i]++;\r\n            }\r\n        }\r\n\r\n        // 第 4 步：得到组和项目的拓扑排序结果\r\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\r\n        if (groupsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\r\n        if (itemsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n\r\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\r\n        // key：组，value：在同一组的项目列表\r\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\r\n        for (Integer item : itemsList) {\r\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\r\n        }\r\n\r\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\r\n        List<Integer> res = new ArrayList<>();\r\n        for (Integer groupId : groupsList) {\r\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\r\n            res.addAll(items);\r\n        }\r\n        return res.stream().mapToInt(Integer::valueOf).toArray();\r\n    }\r\n\r\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for (int i = 0; i < n; i++) {\r\n            if (inDegree[i] == 0) {\r\n                queue.offer(i);\r\n            }\r\n        }\r\n\r\n        while (!queue.isEmpty()) {\r\n            Integer front = queue.poll();\r\n            res.add(front);\r\n            for (int successor : adj[front]) {\r\n                inDegree[successor]--;\r\n                if (inDegree[successor] == 0) {\r\n                    queue.offer(successor);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (res.size() == n) {\r\n            return res;\r\n        }\r\n        return new ArrayList<>();\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/33#issuecomment-1859044654","body":"### 思路\r\n模拟机器人从(0,0)位置开始移动，不同移动方式会修改x/y值，移动结束后，判断x/y是否仍在(0,0)位置\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public boolean judgeCircle(String moves) {\r\n        int x = 0,y = 0;\r\n        for (char move: moves.toCharArray()) {\r\n            switch (move){\r\n                case 'U': y++; break;\r\n                case 'D': y--; break;\r\n                case 'L': x--; break;\r\n                case 'R': x++; break;\r\n            }\r\n        }\r\n        return x == 0 && y == 0;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/34#issuecomment-1860063472","body":"### 思路\r\n待执行任务数组转换为3维数组，记录任务下标，使用优先队列来实现任务队列控制优先级\r\n优先队列按照题目要求进行排序(`选择 执行时间最短 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的`)\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] getOrder(int[][] tasks) {\r\n        int n = tasks.length;\r\n        int[][] newTasks  = new int[n][3];\r\n\r\n        //转为3元数组，记录每个任务的下标\r\n        for (int i = 0; i < n; i++) {\r\n            newTasks[i] = new int[]{tasks[i][0], tasks[i][1], i};\r\n        }\r\n\r\n        //任务按照入对时间排序\r\n        Arrays.sort(newTasks, (a, b) -> a[0] - b[0]);\r\n        //优先队列：选择 执行时间最短 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的\r\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> {\r\n            if (a[1] == b[1]) {\r\n                // 执行时间相同时，下标最小的先执行\r\n                return a[2] - b[2];\r\n            } else {\r\n                // 默认按照耗时时间最短的先执行\r\n                return a[1] - b[1];\r\n            }\r\n        });\r\n        \r\n        int[] res = new int[n];\r\n        //当前执行时间\r\n        int time = 0;\r\n        //已执行的任务数量\r\n        int resIdx = 0;\r\n        //已进入队列的数量\r\n        int enqIdx = 0;\r\n        while (resIdx < n) {\r\n            //小于等于 当前执行时间time的任务入队\r\n            while (enqIdx < n && newTasks[enqIdx][0] <= time) {\r\n                queue.offer(newTasks[enqIdx++]);\r\n            }\r\n            //优先队列为空，当前执行时间time=未入队的任务\r\n            if (queue.isEmpty()) {\r\n                time = newTasks[enqIdx][0];\r\n                continue;\r\n            }\r\n            //弹出任务，开始执行，当前执行时间time += 当前任务的执行耗时\r\n            int[] nextJob = queue.poll();\r\n            res[resIdx++] = nextJob[2];\r\n            time += nextJob[1];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n logn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/35#issuecomment-1862231021","body":"### 思路\r\n- 将开始时间和结束时间转换为距离0点的分钟数\r\n- 特殊处理通宵场景\r\n- 结束分钟完整局数-开始分钟完整局数\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int numberOfRounds(String loginTime, String logoutTime) {\r\n        //转化为距离0点的分钟\r\n        int login = 60 * Integer.parseInt(loginTime.substring(0, 2)) + Integer.parseInt(loginTime.substring(3));\r\n        int logout = 60 * Integer.parseInt(logoutTime.substring(0, 2)) + Integer.parseInt(logoutTime.substring(3));\r\n        //结束时间小于开始时间，说明通宵了，加一天\r\n        if (login > logout) {\r\n            logout += 1440;\r\n        }\r\n        return Math.max(logout / 15 - (login + 14) / 15, 0);\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/36#issuecomment-1864061676","body":"### 思路\r\n前缀和\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int minCharacters(String a, String b) {\r\n        int lenA = a.length();\r\n        int lenB = b.length();\r\n        //收集每个字符出现的数量\r\n        int[] countA = new int[26];\r\n        int[] countB = new int[26];\r\n        for (char c : a.toCharArray()) {\r\n            countA[c-'a']++;\r\n        }\r\n        for (char c : b.toCharArray()) {\r\n            countB[c-'a']++;\r\n        }\r\n        //计算每个字符的前缀和\r\n        int[] preA = new int[26];\r\n        int[] preB = new int[26];\r\n        for (int i = 0; i < 26 ; i++) {\r\n            preA[i] = (i == 0) ? countA[0] : preA[i - 1] + countA[i];\r\n            preB[i] = (i == 0) ? countB[0] : preB[i - 1] + countB[i];\r\n        }\r\n\r\n        //遍历26个字母，检查三个条件需要的操作数量，取最小\r\n        int res = Integer.MAX_VALUE;\r\n        for (int i = 0; i < 26; i++) {\r\n            if (i > 0) {\r\n                //a<b \r\n                res = Math.min(res, lenA - preA[i - 1] + preB[i - 1]);\r\n                //a>b\r\n                res = Math.min(res, preA[i - 1] + lenB - preB[i - 1]);\r\n            }\r\n            //a==b\r\n            res = Math.min(res, lenA - countA[i] + lenB - countB[i]);\r\n        }\r\n        return res;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/37#issuecomment-1865932835","body":"### 思路\r\n**快速排序**\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] sortArray(int[] nums) {\r\n        quickSort(nums, 0, nums.length - 1);\r\n        return nums;\r\n    }\r\n\r\n    private void quickSort(int[] nums, int left, int right) {\r\n        if (left>=right){\r\n            return;\r\n        }\r\n        int index  = partition(nums,left,right);\r\n        quickSort(nums, left, index - 1);\r\n        quickSort(nums, index + 1, right);\r\n    }\r\n\r\n    private int partition(int[] nums, int left, int right) {\r\n        int temp = nums[left];\r\n        while (left<right){\r\n            //从右往左找小于temp的数\r\n            while (left< right && nums[right] > temp){\r\n                //大于temp，移动指针继续找\r\n                right--;\r\n            }\r\n            nums[left] = nums[right];\r\n            //从左往右找大于temp的数，移动到右侧\r\n            while (left< right && nums[left] < temp){\r\n                //小于temp，移动指针继续找\r\n                left++;\r\n            }\r\n            nums[right]=nums[left];\r\n        }\r\n        nums[left] = temp;\r\n        //left==right\r\n        return left;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(N logN)\r\n- 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/38#issuecomment-1867275209","body":"### 思路\r\n二分法\r\n- 针对x=0和x=1直接返回\r\n- 通过二分法，寻找一个整数n\r\n- 如果n*n==x，则为目标结果\r\n- 如果n*n > x，则从左区间继续二分查找\r\n- 如果n*n < x，则从右区间继续二分查找\r\n\r\n注意点：\r\n- 计算n*n防止int溢出，转为long类型\r\n- 二分查找计算中间节点mid时，当只剩2个元素时防止死循环 mid = left + (right - left+1) / 2\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int mySqrt(int x) {\r\n        if (x==0){\r\n            return 0;\r\n        }\r\n        if (x==1){\r\n            return 1;\r\n        }\r\n        int left = 1;\r\n        int right = x / 2;\r\n        while (left < right) {\r\n            //防止区间为2时的死循环\r\n            int mid = left + (right - left+1) / 2;\r\n            if ((long) mid * mid == x) {\r\n                return mid;\r\n            } else if ((long) mid * mid > x) {\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid;\r\n            }\r\n        }\r\n        //left==right\r\n        return left;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(logx)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/39#issuecomment-1868214681","body":"### 思路\r\n二分查找\r\n- 某个版本为正确版本时，其左侧所有版本都是正确版本，首个错误版本只会在其右侧区间\r\n- 某个版本为错误版本时，其右侧所有版本都是错误版本，首个错误版本只会在其左侧区间\r\n### 代码\r\n```java\r\n\r\n    public class Solution extends VersionControl {\r\n        public int firstBadVersion(int n) {\r\n            int left = 1, right = n;\r\n            while (left < right) {\r\n                int mid = left + (right - left) / 2; \r\n                if (isBadVersion(mid)) {\r\n                    //mid右侧全都是错误的版本,左区间继续查找\r\n                    right = mid;\r\n                } else {\r\n                    //mid左侧都为正确版本，右区间继续查找\r\n                    left = mid + 1; \r\n                }\r\n            }\r\n            // left == right\r\n            return left;\r\n        }\r\n    }\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(logn)\r\n- 空间复杂度：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/40#issuecomment-1868481392","body":"### 思路\r\n在归并排序中，整体上是重复拆分左区间、右区间，最终合并有序的左区间和右区间的过程\r\n\r\n假定i始终在左区间，j始终在右区间，且左右区间均为升序。\r\n如果`nums[i] > 2*nums[j]`，则必定存在：i的右侧元素均满足 `> 2*nums[j]`，此时j的翻转对数量有`mid-i+1`个\r\n\r\n在归并排序的merge逻辑之前，进行翻转对数量的查找，刚好符合上面的查找条件\r\n\r\n思路参考： [「手画图解」在归并排序中，加几行代码 | 493.翻转对](https://leetcode.cn/problems/reverse-pairs/solutions/501079/shou-hua-tu-jie-yi-bu-yi-bu-jie-xi-gui-bing-pai-xu/)\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n\r\n    private int count;\r\n\r\n    public int reversePairs(int[] nums) {\r\n        if (nums == null || nums.length < 2) {\r\n            return 0;\r\n        }\r\n        count = 0;\r\n        mergeSort(nums, 0, nums.length - 1);\r\n        return count;\r\n    }\r\n\r\n    private void mergeSort(int[] nums, int start, int end) {\r\n        if (start == end) {\r\n            return;\r\n        }\r\n        int mid = start + (end - start) / 2;\r\n        mergeSort(nums, start, mid);\r\n        mergeSort(nums, mid + 1, end);\r\n        int i = start;\r\n        int j = mid + 1;\r\n        while (i <= mid && j <= end) {\r\n            if ((long) nums[i] > 2 * (long) nums[j]) {\r\n                count += mid - i + 1;\r\n                j++;\r\n            } else {\r\n                i++;\r\n            }\r\n        }\r\n        // 统计完之后合并\r\n        int[] tempArr = new int[end - start + 1];\r\n        i = start;\r\n        j = mid + 1;\r\n        int idx = 0;\r\n        while (i <= mid && j <= end) {\r\n            tempArr[idx++] = nums[i] < nums[j] ? nums[i++] : nums[j++];\r\n        }\r\n        while (i <= mid) {\r\n            tempArr[idx++] = nums[i++];\r\n        }\r\n        while (j <= end) {\r\n            tempArr[idx++] = nums[j++];\r\n        }\r\n        for (i = 0, j = start; j <= end; i++, j++) {\r\n            nums[j] = tempArr[i];\r\n        }\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n logn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/41#issuecomment-1868949479","body":"### 思路\r\n二分查找\r\n- 每个房屋，与最近的供暖器距离为：最小加热半径 dis_houses = min(dis_left,dis_right)\r\n- 所有房屋，所需的最小加热半径为：每个房屋最小加热半径的最大值\r\n- 针对每个房屋，通过二分查找，找首个 >=house 的供暖器下标 \r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int findRadius(int[] houses, int[] heaters) {\r\n        int ans = 0;\r\n        Arrays.sort(heaters);\r\n        for (int house : houses) {\r\n            int i = binarySearch(heaters, house);\r\n            int j = i + 1;\r\n            int leftDistance = i < 0 ? Integer.MAX_VALUE : house - heaters[i];\r\n            int rightDistance = j >= heaters.length ? Integer.MAX_VALUE : heaters[j] - house;\r\n            int curDistance = Math.min(leftDistance, rightDistance);\r\n            ans = Math.max(ans, curDistance);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public int binarySearch(int[] nums, int target) {\r\n        int left = 0, right = nums.length - 1;\r\n        if (nums[left] > target) {\r\n            return -1;\r\n        }\r\n        while (left < right) {\r\n            int mid = (right - left + 1) / 2 + left;\r\n            if (nums[mid] > target) {\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n}\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：O((n + m) log n)\r\n- 空间复杂度：O(log n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/42#issuecomment-1869365295","body":"### 思路\r\n[719. 找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/description/)\r\n> 暴力：计算所有可能的对数距离，使用堆找出第k小的数\r\n\r\n- 二分查找：从距离数组dis中，查找一个数(距离)满足：在所有数对距离中第k小的数对距离\r\n- 则有距离数组有left、right、mid，\r\n- 有 x 组数对的距离 小于 dis[mid]， 则dis[mid]是第x+1小的数，x+1记为cnt\r\n- cnt=k时：此时mid可能刚好是第k小\r\n- cnt>k时：mid距离过大，小于该距离的对数过多，需要查看左区间 right=mid\r\n- cnt<k时：mid距离过小，小于该距离的对数过少，需要查看右区间 left=mid+1\r\n\r\n有多少对数距离小于 dis[mid],使用双指针\r\n\r\n参考题解： [[动图演示]思路分析+二分+双指针](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/solutions/1602091/-by-xiaohu9527-ioe6/)\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int smallestDistancePair(int[] nums, int k) {\r\n        Arrays.sort(nums);\r\n        int left = 0;\r\n        int right = nums[nums.length-1]-nums[0];\r\n        while (left < right) {\r\n            int mid = left + (right - left) / 2;\r\n            int cnt = 0;\r\n            for (int i = 0, j = 0; i < nums.length; i++) {\r\n                while (j < nums.length && nums[j] - nums[i] <= mid) {\r\n                    j++;\r\n                }\r\n                cnt += j - i - 1;\r\n            }\r\n            if (cnt >= k) {\r\n                right = mid;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n- 时间复杂度：O(n (log n + log D)) n为数组长度，D为数对距离数组长度nums[nums.length-1]-nums[0]\r\n- 空间复杂度：O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/43#issuecomment-1870239760","body":"### 思路\r\n**二分查找+深度优先遍历**\r\n\r\n在方格数值区间[0,N*N-1]中找一个数作为等待时间，使其满足：存在从左上角到右下角的路径，且该数要最小\r\n- 通过二分查找在区间内找符合条件的数值\r\n- 如果mid满足条件，继续检查小于mid的数，right=mid\r\n- 如果mid不满足，说明等待时间太小，需要继续检查更大的数值，left=mid+1\r\n- 通过深度优先遍历，从左上角（0,0）开始检查当前等待时间下，是否存在有效路径\r\n\r\n### 代码\r\n```java\r\npublic class Solution {\r\n\r\n    private int N;\r\n\r\n    public  int[][] DIRECTIONS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\r\n\r\n    public int swimInWater(int[][] grid) {\r\n        this.N = grid.length;\r\n        int left = 0;\r\n        int right = N * N - 1;\r\n        while (left < right) {\r\n            int mid = (left + right) / 2;\r\n            boolean[][] visited = new boolean[N][N];\r\n            if (grid[0][0] <= mid && dfs(grid, 0, 0, visited, mid)) {\r\n                right = mid;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n\r\n    private boolean dfs(int[][] grid, int x, int y, boolean[][] visited, int threshold) {\r\n        visited[x][y] = true;\r\n        for (int[] direction : DIRECTIONS) {\r\n            int newX = x + direction[0];\r\n            int newY = y + direction[1];\r\n            if (inArea(newX, newY) && !visited[newX][newY] && grid[newX][newY] <= threshold) {\r\n                if (newX == N - 1 && newY == N - 1) {\r\n                    return true;\r\n                }\r\n\r\n                if (dfs(grid, newX, newY, visited, threshold)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private boolean inArea(int x, int y) {\r\n        return x >= 0 && x < N && y >= 0 && y < N;\r\n    }\r\n}\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n^2 logn)\r\n- 空间复杂度：O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/44#issuecomment-1870927576","body":"### 思路\r\n**滑动窗口：固定窗口大小**\r\n> 当前窗口元音数 = 上一窗口元音数 + 当前窗口新元素是否元音(1/0) - 上一个窗口左端元素是否元音(1/0) \r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int maxVowels(String s, int k) {\r\n        int window = 0;\r\n        for (int i = 0; i < k; i++) {\r\n            window += check(s.charAt(i));\r\n        }\r\n        int result = window;\r\n        for (int i = k; i < s.length(); i++) {\r\n            //i为当前窗口右端新元素，i-k是上一个窗口左端元素\r\n            //当前窗口元音数 = 上一窗口元音数 + 当前窗口新元素是否元音 - 上一个窗口左端元素是否元音\r\n            window = window + check(s.charAt(i)) -check(s.charAt(i-k));\r\n            result = Math.max(result, window);\r\n        }\r\n        return result;\r\n    }\r\n    int check(char s){\r\n        return s == 'a' || s == 'e' || s == 'i' || s == 'o' || s == 'u' ? 1 : 0;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/45#issuecomment-1871916553","body":"### 思路\r\n动态规划\r\n### 代码\r\n```java\r\nclass Solution {\r\n     public double new21Game(int N, int K, int W) {\r\n        if (K == 0 || N >= K + W) return 1;\r\n        double dp[] = new double[N + 1],  Wsum = 1, res = 0;\r\n        dp[0] = 1;\r\n        for (int i = 1; i <= N; ++i) {\r\n            dp[i] = Wsum / W;\r\n            if (i < K) Wsum += dp[i]; else res += dp[i];\r\n            if (i - W >= 0) Wsum -= dp[i - W];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(K+W)\r\n- 空间复杂度：O(K+W)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/46#issuecomment-1872551103","body":"### 思路\r\n滑动窗口：固定窗口大小\r\n记录窗口内的字母频次，与异或词字母频次进行比较\r\nps：字符s的长度一定要大于字符p的长度，否则不存在异位词\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> findAnagrams(String s, String p) {\r\n        List<Integer> ans = new ArrayList<>();\r\n        int s_len = s.length(), p_len = p.length();\r\n\r\n        if (s_len < p_len) {\r\n            return ans;\r\n        }\r\n\r\n        int[] window_count = new int[26];\r\n        int[] p_count = new int[26];\r\n\r\n        //统计首个窗口\r\n        for (int i = 0; i < p_len; i++) {\r\n            window_count[s.charAt(i) - 'a']++;\r\n            p_count[p.charAt(i) - 'a']++;\r\n        }\r\n\r\n        //检查首个窗口是否符合\r\n        if (Arrays.equals(window_count, p_count))\r\n            ans.add(0);\r\n\r\n        //窗口开始滑动,左右都按照同频率滑动\r\n        for (int i = 0; i < s_len - p_len; i++) {\r\n            window_count[s.charAt(i) - 'a']--;    // 左指针移动\r\n            window_count[s.charAt(i + p_len) - 'a']++;  // 右指针移动\r\n\r\n            //判断是否满足异位词的条件，满足加入到ans中\r\n            if (Arrays.equals(window_count, p_count))\r\n                ans.add(i + 1);\r\n\r\n        }\r\n\r\n        return ans;\r\n    }\r\n\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/47#issuecomment-1872980653","body":"```java\r\nclass Solution {\r\n    public String minWindow(String s, String t) {\r\n        Map<Character, Integer> need = new HashMap<>();\r\n        Map<Character, Integer> window = new HashMap<>();\r\n        for (int i = 0; i < t.length(); i++) {\r\n            need.put(t.charAt(i), need.getOrDefault(t.charAt(i), 0) + 1);\r\n        }\r\n        int right = 0, left = 0;\r\n        int valid = 0;\r\n        int start = 0, minLen = Integer.MAX_VALUE;\r\n        while (right < s.length()) {\r\n            char cur = s.charAt(right);\r\n            right++;\r\n            // 进行窗口数据一系列更新\r\n            if (need.containsKey(cur)) {\r\n                Integer total = window.getOrDefault(cur, 0);\r\n                window.put(cur, total + 1);\r\n                if (window.get(cur).equals(need.get(cur))) {\r\n                    valid++;\r\n                }\r\n            }\r\n            while (need.size() == valid) {\r\n                if (right - left < minLen) {\r\n                    start = left;\r\n                    minLen = right - left;\r\n                }\r\n                // d 是将移除窗口的字符串\r\n                char d = s.charAt(left);\r\n                // 左边移动窗口\r\n                left++;\r\n                // 进行窗口内数据当一系列更新\r\n                if (window.containsKey(d)) {\r\n                    if (window.get(d).equals(need.get(d))) {\r\n                        valid--;\r\n                    }\r\n                    window.put(d, window.get(d) - 1);\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(start, start + minLen);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/48#issuecomment-1873256132","body":"### 思路\r\n\r\n**滑动窗口**：[1423.获得的最大分数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)\r\n\r\n通过求剩余卡牌的最小值，来计算拿走卡牌的最大值\r\n剩余的卡牌是长度为n-k的连续字符串，可以通过固定长度的滑动窗口来获取\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n        public int maxScore(int[] cardPoints, int k) {\r\n            int window = 0;\r\n            int windowSize = cardPoints.length - k;\r\n            for (int i = 0; i < windowSize; i++) {\r\n                window += cardPoints[i];\r\n            }\r\n            int windowMin = window;\r\n            for (int i = windowSize; i < cardPoints.length; i++) {\r\n                //窗口右侧新元素 i ，窗口左侧淘汰元素 i-windowSize\r\n                window = window + cardPoints[i] - cardPoints[i - windowSize];\r\n                windowMin = Math.min(windowMin, window);\r\n            }\r\n            return Arrays.stream(cardPoints).sum() - windowMin;\r\n        }\r\n    }\r\n```\r\n\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/49#issuecomment-1873869321","body":"### 思路\r\n**回溯+递归**\r\n\r\n- 分钟数有6个灯，小时数有4个灯；\r\n- 如果分钟数有x个开启，小时数turnedOn-x个灯开启\r\n- 先从分钟数开始回溯，在对小时数进行回溯\r\n- 当turnedOn==0时，格式化时间输出格式\r\n\r\n### 代码\r\n```java\r\n   class Solution {\r\n        List<Integer> mins;\r\n        List<String> res;\r\n\r\n        public List<String> readBinaryWatch(int turnedOn) {\r\n            res = new ArrayList<>();\r\n            mins = new ArrayList<>();\r\n\r\n            for (int i = 0; i < 6 && turnedOn >= i; i++) {\r\n                //分针中点亮i个灯\r\n                dfs(0, 0, i, true);\r\n                //时针中点亮turnedOn-i个灯\r\n                dfs(0, 0, turnedOn - i, false);\r\n                //一轮结束，重置变量\r\n                mins.clear();\r\n            }\r\n\r\n            return res;\r\n        }\r\n\r\n        private void dfs(int st, int sum, int cnt, boolean flag) {\r\n            if (cnt == 0) {\r\n                if (flag) {//收集分钟数\r\n                    mins.add(sum);\r\n                } else {//格式化：小时数+分钟数\r\n                    format(sum);\r\n                }\r\n                return;\r\n            }\r\n\r\n            for (int i = st; i < (flag ? 6 : 4); i++) {\r\n                int temp = (int) Math.pow(2, i);\r\n                if (flag && sum + temp >= 60 || !flag && sum + temp >= 12) {\r\n                    break;\r\n                }\r\n                dfs(i + 1, sum + temp, cnt - 1, flag);\r\n            }\r\n        }\r\n\r\n        private void format(int sum) {\r\n            if (!mins.isEmpty()) {\r\n                for (int m : mins) {\r\n                    StringBuilder sb = new StringBuilder();\r\n                    sb.append(sum).append(':');\r\n                    if (m < 10) {\r\n                        sb.append('0');\r\n                    }\r\n                    sb.append(m);\r\n                    res.add(sb.toString());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/50#issuecomment-1874963269","body":"### 思路\r\n**回溯**\r\n\r\n- 皇后之间不能同行、同列、同斜线\r\n- 所以要记录已经放置皇后的行号、列号、斜线号（左斜线的row-col值固定，右斜线的row+col值固定）\r\n- 按行递归，遍历行内每个元素，寻找可放置的位置，并记录，当行号=n时结束\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n        //已放皇冠的列\r\n        Set<Integer> col = new HashSet<>();\r\n        //已放皇后的左斜线(左上角->右下角，row-col值固定)\r\n        Set<Integer> line1 = new HashSet<>();\r\n        //已放皇后的右斜线(右上角->左下角，row+col值固定)\r\n        Set<Integer> line2 = new HashSet<>();\r\n\r\n        public int totalNQueens(int n) {\r\n            return backtrace(n, 0);\r\n        }\r\n\r\n        private int backtrace(int n, int row) {\r\n            if (row == n) {\r\n                //递归结束，n个皇后都放完了，记录1次有效解决方案\r\n                return 1;\r\n            }else {\r\n                int count = 0;\r\n                //检查当前行每一列可放置皇后的位置\r\n                for (int i = 0; i < n; i++) {\r\n                    int line1Num = row-i;\r\n                    int line2Num = row+i;\r\n                    if (col.contains(i) || line1.contains(line1Num) || line2.contains(line2Num)) {\r\n                        continue;\r\n                    }\r\n                    col.add(i);\r\n                    line1.add(line1Num);\r\n                    line2.add(line2Num);\r\n\r\n                    //递归：检查下一行可放置的位置，并记录\r\n                    count += backtrace(n, row + 1);\r\n\r\n                    //撤销回溯记录\r\n                    col.remove(i);\r\n                    line1.remove(line1Num);\r\n                    line2.remove(line2Num);\r\n                }\r\n                return count;\r\n            }\r\n        }\r\n    }\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/54#issuecomment-1876476386","body":"### 思路\r\n**DFS**\r\n- 遍历矩阵中每个元素，从当前元素为起点，往上下左右位置进行岛屿搜索，找到岛屿就把结果+1\r\n- 搜索结束条件：如果搜索到矩阵外，或者搜索到的位置值为0，则直接返回\r\n- 避免死循环：搜索时，会探查当前位置的上下左右位置，所以每搜索到1个新位置，就将其置为0，避免死循环\r\n- 最终取 以每个元素为起点，搜索结果的最大值\r\n### 代码\r\n```java\r\nclass Solution {\r\n\r\n    //当前位置的上、下、左、右位置偏移值\r\n    public int[][] DIRECTIONS = {{-1,0}, {1, 0}, {0, -1},{0, 1}};\r\n    public int maxAreaOfIsland(int[][] grid) {\r\n        int res = 0;\r\n        for (int i = 0; i < grid.length; i++) {\r\n            for (int j = 0; j < grid[0].length; j++) {\r\n                res = Math.max(res, dfs(grid,i,j));\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n        private int dfs(int[][] grid, int x, int y) {\r\n            if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == 0) {\r\n                //当前位置不是岛屿，直接返回0\r\n                return 0;\r\n            }\r\n            //当前位置为岛屿，开始向上下左右方向搜索其他岛屿，把结果累加（当前位置置为0，避免搜索时死循环）\r\n            grid[x][y] = 0;\r\n            int temp = 1;\r\n            for (int[] direction : DIRECTIONS) {\r\n                int newX = x + direction[0];\r\n                int newY = y + direction[1];\r\n                temp += dfs(grid, newX, newY);\r\n            }\r\n            return temp;\r\n        }\r\n    }\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(`m*n`)，已经搜索过的位置置为0，所以每个位置只会访问1次，复杂度为`m*n`\r\n- 空间复杂度：O(`m*n`)，递归最大深度为`m*n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/55#issuecomment-1878364347","body":"### 思路\r\n**常规bfs(单源bfs)**\r\n> 对所有海洋(n^2)进行一次bfs搜索(O(n^2))，找到距离最近的陆地，再对所有海洋区域的最近陆地距离取最大值\r\n\r\n折腾半天终于写出来，当全部都为海洋时直接超时,最差情况下时间复杂度O(n^4)\r\n\r\n**多源bfs** 参考[题解](https://leetcode.cn/problems/as-far-from-land-as-possible/solutions/849103/gong-shui-san-xie-ru-he-shi-yong-duo-yua-vlea/)\r\n- 先收集所有的陆地区域到队列中，作为第1批搜索节点\r\n- 依次弹出陆地区域并向外扩散1圈，搜索海洋区域，此时的圈数即为海洋到最近陆地的距离\r\n- 被搜索到的海洋区域修改其值为与最近陆地的距离，防止重复搜索，这些海洋区域继续放入队列，作为下一批搜索节点\r\n- 如此往复，直到搜索到的最后一个区域即为 【离最近陆地区域的距离】最大的海洋区域\r\n\r\n### 代码\r\n``` java\r\nclass Solution {\r\n\r\n    public int maxDistance(int[][] grid) {\r\n        int res = -1;\r\n        Queue<int[]> queue = new LinkedList<>();\r\n        for (int i = 0; i < grid.length; i++) {\r\n            for (int j = 0; j < grid[0].length; j++) {\r\n                if (grid[i][j]==1){\r\n                    //收集所有陆地位置\r\n                    queue.offer(new int[]{i,j});\r\n                }\r\n            }\r\n        }\r\n        if (queue.isEmpty() || queue.size() == grid.length * grid[0].length) {\r\n            //全是海洋或者全是陆地\r\n            return res;\r\n        }\r\n        int[][] directions = {{-1,0}, {1, 0}, {0, -1},{0, 1}};\r\n        while (!queue.isEmpty()){\r\n            int[] curPosition = queue.poll();\r\n            int x = curPosition[0];\r\n            int y = curPosition[1];\r\n            //向外扩散一圈搜索\r\n            for (int[] direction : directions) {\r\n                int newX = x + direction[0];\r\n                int newY = y + direction[1];\r\n                if (newX < 0 || newX >= grid.length || newY < 0 || newY >= grid[0].length) {\r\n                    //不在网格内\r\n                    continue;\r\n                }\r\n                if (grid[newX][newY]!=0){\r\n                    //不是海洋 或者已被搜索\r\n                    continue;\r\n                }\r\n                queue.offer(new int[]{newX, newY});\r\n                //已经搜索过的位置，设置其值为距离值，避免重复搜索\r\n                grid[newX][newY] = grid[x][y] + 1;\r\n                res = Math.max(res, grid[newX][newY]);\r\n            }\r\n        }\r\n        //圈数是从1开始计算，所以最终结果-1\r\n        return res - 1;\r\n    }\r\n\r\n}\r\n````\r\n\r\n### 复杂度\r\n- 时间复杂度:O(n^2) 搜索过的区域修改其值，每个区域都只会被搜索1次\r\n- 空间复杂度:O(n^2) 若全为陆地区域，队列空间n^2","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/56#issuecomment-1879698163","body":"### \r\n**广度优先搜索 + 队列**\r\n- 记录可开启的盒子canOpen，已拥有的盒子hasBox，已开启的盒子used\r\n- 将`【已拥有且可开启】`的盒子放入队列\r\n- 进行搜索时，每次从队列中取出队首盒子，累加其糖果数，根据新获得的钥匙和盒子，将符合开启条件的盒子放入队列\r\n- 如此往复，直至队列为空\r\n\r\n### \r\n```java\r\nclass Solution {\r\n    public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\r\n        int n = status.length;\r\n        boolean[] canOpen = new boolean[n];\r\n        boolean[] hasBox = new boolean[n];\r\n        boolean[] used = new boolean[n];\r\n\r\n        for(int i = 0; i < n; i++){\r\n            canOpen[i] = (status[i] == 1);\r\n        }\r\n        Deque<Integer> q = new ArrayDeque<>();\r\n        for(int i : initialBoxes){\r\n            hasBox[i] = true;\r\n            if(canOpen[i]){\r\n                used[i] = true;\r\n                q.add(i);\r\n            }\r\n        }\r\n        int ans = 0;\r\n        while(!q.isEmpty()){\r\n            int i = q.poll();\r\n            ans += candies[i];\r\n            for(int k : keys[i]){\r\n                canOpen[k] = true;\r\n                if(hasBox[k] && !used[k]){\r\n                    used[k] = true;\r\n                    q.add(k);\r\n                }\r\n            }\r\n            for(int k : containedBoxes[i]){\r\n                hasBox[k] = true;\r\n                if(canOpen[k] && !used[k]){\r\n                    used[k] = true;\r\n                    q.add(k);\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/57#issuecomment-1880026164","body":"### 思路\r\n[987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)\r\nMap+DFS\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n     // key为横坐标x,value为[纵坐标y,节点值]的pair列表\r\n    TreeMap<Integer, List<int[]>> map = new TreeMap<>();   \r\n\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        /*\r\n        TreeMap+DFS:\r\n        我们用TreeMap记录每个垂直列内的节点值,通过横坐标x与纵坐标y的DFS进行递归求解\r\n         */\r\n        dfs(root, 0, 0);\r\n        List<List<Integer>> res = new ArrayList<>();\r\n        // 排列后加入结果\r\n        for (Integer idx : map.keySet()) {\r\n            List<int[]> tmp = map.get(idx);\r\n            tmp.sort((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\r\n            List<Integer> list = new ArrayList<>();\r\n            for (int[] t : tmp) {\r\n                list.add(t[1]);\r\n            }\r\n            res.add(list);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    // 遍历root所在子树并将同一x内的节点信息加入map,其中x与y为root横纵坐标(前序遍历)\r\n    private void dfs(TreeNode root, int x, int y) {\r\n        // base case\r\n        if (root == null) return;\r\n        // 取出list进行插入并更新map\r\n        List<int[]> list = map.getOrDefault(x, new ArrayList<>());\r\n        list.add(new int[]{y, root.val});\r\n        map.put(x, list);\r\n        // 递归遍历左右子节点\r\n        dfs(root.left, x - 1, y + 1);\r\n        dfs(root.right, x + 1, y + 1);\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n logn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/58#issuecomment-1880447395","body":"### 思路\r\n因为可以从0或1台阶开始爬，所以当i=0或1时,最小花费都为0\r\n- 因为每次可选择向上爬1个或2个台阶，所以到达顶部前，最后一步有以下2种情况\r\n- 如果最后一步从i-1开始，上爬1个台阶，则到达顶部的最小花费 dp(i) = dp(i-1) + cost[i-1]\r\n- 如果最后一步从i-2开始，上爬2个台阶，则到达顶部的最小花费 dp(i) = dp(i-2) + cost[i-2]\r\n对这两种情况取最小值，就是爬到i层的最小花费\r\n> dp[i] = Min(dp(i-1) + cost[i-1],dp(i-2) + cost[i-2])\r\n> O(n)/O(n)\r\n\r\n空间复杂度优化：\r\n- 观察方程式可发现，dp[i]计算出来后，dp[i-2]以前的数据就不会再用到\r\n- 所以每次循环只关心dp[i-1]和dp[i-2]，将其分别记做cur、pre，dp[i]记为next\r\n> next = Min(cur + cost[i-1],pre + cost[i-2])\r\n> O(n)/O(1)\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int minCostClimbingStairs(int[] cost) {\r\n        int n = cost.length;\r\n        int pre = 0;\r\n        int cur = 0;\r\n        for (int i = 2; i <= n; i++) {\r\n            int next = Math.min(cur + cost[i - 1], pre + cost[i - 2]);\r\n            pre = cur;\r\n            cur = next;\r\n        }\r\n        return cur;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/59#issuecomment-1882454728","body":"### 思路\r\n从n个房间里偷出来的最大金额f(n)\r\n- 1:偷前n-1个房子但最后一间不偷\r\n- 2:偷前n-2个房子和最后一间房子\r\n>  f(n) = Max(f(n-1),f(n-2)+h[n-1])\r\n> f(0) = 0\r\n> f(1) = num[1]\r\n> f(2) = Max(f(1), f(0)+num[1])\r\n\r\n结合昨天的思路，在O(n)的空间复杂度上进行优化f(n-1)记做cur，f(n-2)记做pre，f(n)记做next\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int rob(int[] nums) {\r\n        if (nums.length == 1) {\r\n            return nums[0];\r\n        }\r\n        int cur = 0;\r\n        int pre = 0;\r\n        for (int num : nums) {\r\n            int next = Math.max(cur, pre + num);\r\n            pre = cur;\r\n            cur = next;\r\n        }\r\n        return cur;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/60#issuecomment-1884348289","body":"### 思路\r\n\r\n从长度为n的数组nums中找最长递增子序列，并统计一共有多少个\r\n> 一共两个问题：求最长递增子序列的长度，求这个最大长度的子序列一共有多少个\r\n> 求最长递增子序列的长度可参考：[300.最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/solutions/147667/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/)\r\n\r\n遍历nums数组，以nums[i]结尾的最长递增子序列长度dp[i],共有cnt[i]个; dp[i]和cnt[i]默认为1\r\n- i=1时, dp[i] = 1, cnt[i] = 1\r\n- i>1时，dp[i] = Max(dp[i], dp[j] + 1), 0<=j<i,num[j]<num[i]\r\n- 当dp[j] + 1  >  dp[i]时，意味着有新的最长递增子序列，记录其个数cnt[j]\r\n- 当dp[j] + 1 ==  dp[i]时，意味着同一长度的多个递增子序列，cnt[j]个数累加\r\n- 最终取dp最大的cnt值，如果dp最大值有多个则进行累加\r\n\r\n\r\n### 代码\r\n```java\r\n    class Solution {\r\n        public int findNumberOfLIS(int[] nums) {\r\n            int n = nums.length, maxLen = 0, ans = 0;\r\n            int[] dp = new int[n];\r\n            int[] cnt = new int[n];\r\n            for (int i = 0; i < n; ++i) {\r\n                dp[i] = 1;\r\n                cnt[i] = 1;\r\n                for (int j = 0; j < i; ++j) {\r\n                    if (nums[i] > nums[j]) {\r\n                        if (dp[j] + 1 > dp[i]) {\r\n                            //新长度\r\n                            dp[i] = dp[j] + 1;\r\n                            //新长度子序列个数\r\n                            cnt[i] = cnt[j];\r\n                        } else if (dp[j] + 1 == dp[i]) {\r\n                            //又找到1个当前长度的子序列，累加次数\r\n                            cnt[i] += cnt[j];\r\n                        }\r\n                    }\r\n                }\r\n                if (dp[i] > maxLen) {\r\n                    maxLen = dp[i];\r\n                    ans = cnt[i];\r\n                } else if (dp[i] == maxLen) {\r\n                    ans += cnt[i];\r\n                }\r\n            }\r\n            return ans;\r\n        }\r\n    }\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n^2)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/61#issuecomment-1886425419","body":"### 思路\r\n- `dp[i][j]` 代表text1前i个字符text1[0:i-1]，与text2前j个字符text2[0:j-1] 的最长公共子序列长度\r\n- 当`text[i-1]==text[j-1]`时,说明两个字符串最后一个字符相同\r\n   - 此时在text1前i-1个字符，与text2前j-1个字符的最长公共子序列长度(`dp[i-1][j-1]`)的基础上+1即可\r\n   - _**`dp[i][j] = dp[i-1][j-1] + 1`**_\r\n- 当`text[i-1]!=text[j-1]`时,说明两个字符串最后一个字符不同\r\n   - 此时需要考虑两种情况\r\n     - text1前i-1个字符 与 text2前j个字符的 最大公共子序列长度  `dp[i-1][j]`\r\n     - text1前i个字符 与 text2前j-1个字符的 最大公共子序列长度  `dp[i][j-1]`\r\n   - 取两者最大值即可 **_`dp[i][j] = Max(dp[i-1][j], dp[i][j-1])`_**\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int longestCommonSubsequence(String text1, String text2) {\r\n        int m = text1.length(), n = text2.length();\r\n        int[][] dp = new int[m + 1][n + 1];\r\n        for (int i = 1; i <= m; i++) {\r\n            char c1 = text1.charAt(i - 1);\r\n            for (int j = 1; j <= n; j++) {\r\n                char c2 = text2.charAt(j - 1);\r\n                if (c1 == c2) {\r\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\r\n                } else {\r\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\r\n                }\r\n            }\r\n        }\r\n        return dp[m][n];\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：`O(m*n)`\r\n- 空间复杂度：`O(m*n)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/62#issuecomment-1888486282","body":"### 思路\r\ndp[i][j] 是到达`(i,j)`的最多路径\r\n\r\n> dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n\r\n对于`(i,0), (0,j)`这类边界点，其最多路径都是1，即`dp[i][0]=1`, `dp[0][j]=1`\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int uniquePaths(int m, int n) {\r\n        int[][] dp = new int[m][n];\r\n        for (int i = 0; i < m; i++) {\r\n            dp[i][0] = 1;\r\n        }\r\n        for (int j = 0; j < n; j++) {\r\n            dp[0][j] = 1;\r\n        }\r\n        for (int i = 1; i < m; i++) {\r\n            for (int j = 1; j < n; j++) {\r\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\r\n            }\r\n        }\r\n        return dp[m-1][n-1];\r\n    }\r\n}\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(m*n)\r\n- 空间复杂度：O(m*n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qingkediguo":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1813993817","body":"### 思路\n\n将 num 填充成和 k 相同长度的数组，然后记录每次需要进位的数。按照每一位模拟计算\n\n### 代码\n\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    return way1(num, k);\n}\n\nprivate List<Integer> way1(int[] num, int k) {\n    // 前面填充 0，是 num 长度和 kString 的长度一致\n    int maxLength = Math.max(String.valueOf(k).length(), num.length);\n    if (num.length != maxLength) {\n        num = padZero(maxLength, num);\n    }\n\n    List<Integer> result = new ArrayList<>(maxLength);\n\n    // 需要向上进位的数\n    int carryNum = 0;\n    for (int i = num.length - 1; i >= 0; i--) {\n        // 当前位数计算需要加的值\n        int addNum = num[i] + k % 10;\n        k = k / 10;\n\n        if (carryNum != 0) {\n            addNum = addNum + carryNum % 10;\n            carryNum = carryNum / 10;\n        }\n        if (addNum > 9) {\n            result.add(0, addNum % 10);\n            carryNum = carryNum + (addNum / 10);\n        } else {\n            result.add(0, addNum);\n        }\n    }\n\n    // 处理没有处理完的需要进位的数\n    if (carryNum != 0) {\n        // 没有处理完的进位的位数\n        int carryNumLength = String.valueOf(carryNum).length();\n        for (int i = 0; i < carryNumLength; i++) {\n            result.add(0, carryNum % 10);\n            carryNum = carryNum / 10;\n        }\n    }\n\n    return result;\n}\n\nprivate int[] padZero(int maxLength, int[] targetNum) {\n    int[] num;\n    int padLength = maxLength - targetNum.length;\n    int[] newNum = new int[maxLength];\n    for (int i = 0; i < maxLength; i++) {\n        if (i < padLength) {\n            newNum[i] = 0;\n        } else {\n            newNum[i] = targetNum[i - padLength];\n        }\n    }\n    num = newNum;\n    return num;\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1816452229","body":"```java\npublic int[] shortestToChar(String s, char c) {\n        char[] charArray = s.toCharArray();\n        int[] result = new int[s.length()];\n        Arrays.fill(result, Integer.MAX_VALUE);\n        // 左边的距离，此时从 index0 到 第一次出现 c 的字母，都还没有赋值（因为他们的距离只有右边的距离）\n        Integer cIndex = null;\n        for (int i = 0; i < charArray.length; i++) {\n            if (charArray[i] == c) {\n                cIndex = i;\n            }\n            if (null != cIndex) {\n                result[i] = i - cIndex;\n            }\n        }\n\n        // 再计算右边的距离，然后和左边的距离取短的\n        cIndex = null;\n        for (int i = charArray.length - 1; i >= 0; i--) {\n            if (charArray[i] == c) {\n                cIndex = i;\n            }\n            if (null != cIndex) {\n                result[i] = Math.min(cIndex - i, result[i]);\n            }\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817460903","body":"```java\npublic static class MyStack {\n        private final int maxSize;\n        private final List<Integer> stack;\n\n        public MyStack(int maxSize) {\n            this.maxSize = maxSize;\n            this.stack = new ArrayList<>();\n        }\n\n        public MyStack push(int x) {\n            if (stack.size() < maxSize) {\n                stack.add(x);\n            } else {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n            return this;\n        }\n\n        public int pop() {\n            if (!stack.isEmpty()) {\n                return stack.remove(stack.size() - 1);\n            } else {\n                return -1;\n            }\n        }\n\n        public MyStack increment(int k, int val) {\n            // incr 的元素个数\n            int addCount = Math.min(k, stack.size());\n            for (int index = 0; index < addCount; index++) {\n                stack.set(index, stack.get(index) + val);\n            }\n            return this;\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817793391","body":"```java\n    public String decodeString(String s) {\n        // 以下两个栈的长度应该是一致的\n        // 重复次数\n        ArrayDeque<Integer> repeatCountStack = new ArrayDeque<>();\n        // 重复的文字\n        ArrayDeque<StringBuilder> repeatCharStack = new ArrayDeque<>();\n\n        // 结果\n        StringBuilder result = new StringBuilder();\n\n        // 重复数字\n        int continuousNumber = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char currentChar = s.charAt(i);\n            if (currentChar == '[') {\n                repeatCountStack.add(continuousNumber);\n                repeatCharStack.add(new StringBuilder());\n                continuousNumber = 0;\n            } else if (currentChar == ']') {\n                Integer repeatCount = repeatCountStack.pollLast();\n                String msg = repeatCharStack.pollLast().toString();\n                for (int integer = 0; integer < repeatCount; integer++) {\n                    // 如果栈空，则直接加入答案\n                    if (repeatCharStack.isEmpty()) {\n                        result.append(msg);\n                    }\n                    // 如果栈不空，则需要添加到上个栈中\n                    else {\n                        repeatCharStack.peekLast().append(msg);\n                    }\n                }\n            } else {\n                // 说明是数字\n                if (Character.isDigit(currentChar)) {\n                    // 之前的值乘 10 再加上当前数字\n                    continuousNumber = continuousNumber * 10 + Integer.parseInt(String.valueOf(currentChar));\n                }\n                // 说明是字母\n                else {\n                    // 如果符号栈为空，则直接加入结果\n                    if (repeatCountStack.isEmpty()) {\n                        result.append(currentChar);\n                    }\n                    // 说明当前处于 [] 之中，需要将当前内容添加入栈\n                    else {\n                        StringBuilder stringBuilder = repeatCharStack.getLast();\n                        stringBuilder.append(currentChar);\n                    }\n                }\n            }\n        }\n\n        return result.toString();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818936457","body":"```java\npublic static class MyQueue {\n        private Deque<Integer> inStack;\n        private Deque<Integer> outStack;\n\n        public MyQueue() {\n            this.inStack = new ArrayDeque<>();\n            this.outStack = new ArrayDeque<>();\n        }\n\n        public MyQueue push(int x) {\n            inStack.push(x);\n            return this;\n        }\n\n        public int pop() {\n            if (outStack.isEmpty()) {\n                moveInStackToOutStack();\n            }\n            return outStack.pop();\n        }\n\n        public int peek() {\n            if (outStack.isEmpty()) {\n                moveInStackToOutStack();\n            }\n            return outStack.peek();\n        }\n\n        public boolean empty() {\n            return inStack.isEmpty() && outStack.isEmpty();\n        }\n\n        private void moveInStackToOutStack() {\n            while (!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1821198241","body":"```java\npublic int maxChunksToSorted(int[] arr) {\n        // 单调栈\n        Deque<Integer> dullStack = new ArrayDeque<>();\n\n        for (int item : arr) {\n            // 如果双端队列为空，或者当前元素大于等于双端队列的顶部元素，直接将当前元素入队\n            if (dullStack.isEmpty() || dullStack.peek() <= item) {\n                dullStack.push(item);\n            }\n            // 如果当前元素小于双端队列的顶部元素\n            else {\n                // 弹出顶部元素，作为当前块的最大值\n                int max = dullStack.pop();\n                // 将双端队列中大于当前元素的元素全部弹出，保证当前块中的元素都小于最大值\n                while (!dullStack.isEmpty() && dullStack.peek() > item) {\n                    dullStack.pop();\n                }\n                dullStack.push(max);\n            }\n        }\n        return dullStack.size();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1823043102","body":"```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        if (k == 0) {\n            return head;\n        }\n        ListNode tail = head;\n        ListNode newtail = head;\n        ListNode newHead;\n        int len = 1;\n        while (tail.next != null) {\n            tail = tail.next;\n            len = len + 1;\n        }\n        tail.next = head;\n        for (int i = 0; i < (len - k % len - 1); i++) {\n            newtail = newtail.next;\n        }\n        newHead = newtail.next;\n        newtail.next = null;\n\n        return newHead;\n    }\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829420591","body":"```java\npublic int maxDepth(TreeNode root) {\n        if (null == root) {\n            return 0;\n        }\n\n        // 左子树最大高度\n        int leftDepth = maxDepth(root.left);\n        // 右子树最大高度\n        int rightDepth = maxDepth(root.right);\n        // 需要加上当前层的高度(加上我)，即+1\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"adfvcdxv":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1814037010","body":"### 思路\n\n从数组 num 的最后一个元素开始，逐位与整数 k 相加。\n使用进位来处理相加的过程，并将每一位的结果插入结果数组 result 的开头。\n\n### 代码\n\n`var addToArrayForm = function (num, k) {`\n  `const result = [];`\n  `for (let i = num.length - 1; i >= 0 || k > 0; i-- ,k = Math.floor(k / 10)) {`\n`if(i>=0) k+=num[i]`\n `result.unshift(k % 10)`\n  `}`\n  `return result;`\n`};`\n\n### 复杂度分析\n\n时间复杂度： O(max(n, m))，其中 n 是数组 num 的长度，m 是整数 k 的位数。整体时间复杂度由单次循环决定，取决于较大的那个数的位数。\n空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1815919734","body":"#### 思路\r\n\r\n1. 首先，定义一个变量`hasC`，初始值为一个较小的负数（-s.length * 3），用于记录上一个字符`c`出现的位置。\r\n2. 创建一个空数组`res`，用于存储每个字符到字符`c`的最短距离。\r\n3. 第一个循环遍历字符串`s`，从左到右，对每个字符进行处理：\r\n   - 如果当前字符等于`c`，更新`hasC`为当前索引`i`。\r\n   - 计算当前字符到字符`c`的距离，即`i - hasC`，并将结果存入`res`数组的对应位置。\r\n4. 重置`hasC`为一个较大的正数（s.length * 3），用于记录下一个字符`c`出现的位置。\r\n5. 第二个循环遍历字符串`s`，从右到左，对每个字符进行处理：\r\n   - 如果当前字符等于`c`，更新`hasC`为当前索引`i`。\r\n   - 计算当前字符到字符`c`的距离，即`hasC - i`，与之前计算的距离`res[i]`取较小值，并更新`res[i]`。\r\n6. 返回最终的结果数组`res`。\r\n\r\n#### 代码\r\n\r\n`var shortestToChar = function (s, c) {`\r\n\r\n  `let hasC = -s.length * 3`\r\n\r\n  `let res = []`\r\n\r\n  `for (let i = 0; i < s.length; i++) {`\r\n\r\n​    `if (s[i] === c) {`\r\n\r\n​      `hasC = i`\r\n\r\n​    `}`\r\n\r\n​    `res[i] = i - hasC`\r\n\r\n  `}`\r\n\r\n  `hasC = s.length * 3`\r\n\r\n  `for (let i = s.length - 1; i >= 0; i--) {`\r\n\r\n​    `if (s[i] === c) {`\r\n\r\n​      `hasC = i`\r\n\r\n​    `}`\r\n\r\n​    `res[i] = Math.min(hasC - i, res[i])`\r\n\r\n  `}`\r\n\r\n  `return res`\r\n\r\n`};`\r\n\r\n#### 复杂度分析\r\n\r\n第一个循环和第二个循环都是线性遍历字符串，时间复杂度为O(n)，其中n为字符串`s`的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817461950","body":"第一想法：java不是有Stack包装类么？直接上啊！\n过了以后看题解：哦好吧，要自己拿数组模拟啊（\n\n题解第一种思路：好像实际上和用stack区别差不多，区别就是自己拿个指针手动加加减减；\n题解第二种思路：inc的时候不在数组本身上加，而是再弄个数组，要取值的时候再看加多少；\n\nclass CustomStack {\n\n    Stack<Integer> stack;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        stack = new Stack<Integer>();\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if (stack.size() >= maxSize) {\n            \n        } else {\n            stack.push(x);\n        }\n    }\n    \n    public int pop() {\n        if (stack.empty()) {\n            return -1;\n        } else {\n            return stack.pop();\n        }\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, stack.size());\n        for (int i = 0; i < limit; i ++) {\n            stack.set(i, stack.get(i) + val);\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817777886","body":"疑研定真鉴定为：春春的体力活\n跟我平时做项目从excel里面一个个抠字段的操作差不多，做这题感觉在上班\n\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                stk.removeLast();\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818183543","body":"#### 思路\n\n双栈：一个栈输入，一个输出\n\npop和peek只有在输出栈为空，才将输入栈的元素push到输出栈\n\n#### 代码\n\n```\nvar MyQueue = function () {\n    this.instack = []\n    this.outstack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.instack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    if (!this.outstack.length) this.intoout()\n    return this.outstack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    if (!this.outstack.length) this.intoout()\n    return this.outstack[this.outstack.length - 1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    return !this.outstack.length && !this.instack.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\nMyQueue.prototype.intoout = function () {\n    while (this.instack.length) {\n        this.outstack.push(this.instack.pop())\n    }\n};\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：O(1)。\n\n空间复杂度：O(n)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1820159601","body":"#### 思路\n\n单调栈\n\n#### 代码\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n    let res = []\n    let max = 0\n    for (let i = 0; i < arr.length; i++) {\n        if (res.length === 0 || arr[i] >= res[res.length - 1]) {\n            res.push(arr[i])\n        } else {\n            max = res.pop()\n            while (arr[i] < res[res.length - 1]) {\n                res.pop()\n            }\n            res.push(max)\n        }\n    }\n    return res.length\n};\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：O(n)。\n\n空间复杂度：O(n)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1821973005","body":"#### 思路\n\n循环链表\n\n#### 代码\n\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n    if (!head || k === 0) return head;  // 特判\n    let copyHead = head\n    let pre = head\n    let length = 1\n    while (pre.next) {\n        pre = pre.next\n        length++\n    }\n    pre.next = copyHead\n    let move = length - k % length\n    while (move--) {\n        pre = pre.next\n    }\n    copyHead = pre.next\n    pre.next = null\n    return copyHead\n};\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：O(n)。\n\n空间复杂度：O(1)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1824036957","body":"#### 思路\n\n递归\n\n#### 代码\n\n```\nvar swapPairs = function (head) {\n    if (head === null || head.next === null) return head\n    let pre = head.next\n    head.next = swapPairs(pre.next)\n    pre.next = head\n    return pre\n};\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：O(n)。\n\n空间复杂度：O(n)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/10#issuecomment-1825252246","body":"#### 思路\n\n分治\n\n#### 代码\n\n```\nvar sortedListToBST = function (head) {\n    function getMid(left, right) {\n        let fast = left\n        let slow = left\n        while (fast !== right && fast.next !== right) {\n            fast = fast.next.next\n            slow = slow.next\n        }\n        return slow\n    }\n    function buildTree(left, right) {\n        if (left == right) return null\n        let mid = getMid(left, right)\n        let root = new TreeNode(mid.val)\n        root.left = buildTree(left, mid)\n        root.right = buildTree(mid.next, right)\n        return root\n    }\n    return buildTree(head, null)\n};\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：O(*n*log*n*)。\n\n空间复杂度：O(*logn*)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/11#issuecomment-1826262855","body":"两个链表比长度的题，一眼双指针\r\n\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) {\r\n            return null;\r\n        }\r\n        ListNode pA = headA, pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == null ? headB : pA.next;\r\n            pB = pB == null ? headA : pB.next;\r\n        }\r\n        return pA;\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826742247","body":"典中典快慢指针\n\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head, fast = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n            if (fast == slow) {\n                ListNode ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1827317052","body":"#### 思路\n\nhash+双向链表\n\n#### 代码\n\n```\nclass Node {\n    constructor(key = 0, value = 0) {\n        this.key = key;\n        this.value = value;\n        this.prev = null;\n        this.next = null;\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.dummy = new Node(); // 哨兵节点\n        this.dummy.prev = this.dummy;\n        this.dummy.next = this.dummy;\n        this.keyToNode = new Map();\n    }\n\n    getNode(key) {\n        if (!this.keyToNode.has(key)) { // 没有这本书\n            return null;\n        }\n        const node = this.keyToNode.get(key); // 有这本书\n        this.remove(node); // 把这本书抽出来\n        this.pushFront(node); // 放在最上面\n        return node;\n    }\n\n    get(key) {\n        const node = this.getNode(key);\n        return node ? node.value : -1;\n    }\n\n    put(key, value) {\n        let node = this.getNode(key);\n        if (node) { // 有这本书\n            node.value = value; // 更新 value\n            return;\n        }\n        node = new Node(key, value) // 新书\n        this.keyToNode.set(key, node);\n        this.pushFront(node); // 放在最上面\n        if (this.keyToNode.size > this.capacity) { // 书太多了\n            const backNode = this.dummy.prev;\n            this.keyToNode.delete(backNode.key);\n            this.remove(backNode); // 去掉最后一本书\n        }\n    }\n\n    // 删除一个节点（抽出一本书）\n    remove(x) {\n        x.prev.next = x.next;\n        x.next.prev = x.prev;\n    }\n\n    // 在链表头添加一个节点（把一本书放在最上面）\n    pushFront(x) {\n        x.prev = this.dummy;\n        x.next = this.dummy.next;\n        x.prev.next = x;\n        x.next.prev = x;\n    }\n}\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：对于 put 和 get 都是 O(1)O(1)O(1)。\n\n空间复杂度：O(capacity)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829206319","body":"#### 思路\n\n广度优先搜索\n\n#### 代码\n\n```\nvar maxDepth = function (root) {\n    if (root === null) return 0\n    let res = 0\n    let queue = []\n    queue.push(root)\n    while (queue.length > 0) {\n        let size = queue.length;\n        while (size > 0) {\n            let node = queue.shift();\n            if (node.left !== null) {\n                queue.push(node.left);\n            }\n            if (node.right !== null) {\n                queue.push(node.right);\n            }\n            size--;\n        }\n        res++;\n    }\n    return res\n};\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：O(n)。\n\n空间复杂度：O(n)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831142794","body":"\nvar isSameTree = function (p, q) {\n    let queue1 = [p]\n    let queue2 = [q]\n    if (p === null && q === null) {\n        return true\n    } else if (p === null || q === null) {\n        return false\n    } else {\n        while (queue1.length !== 0 && queue1.length !== 0) {\n            const tmp1 = queue1.shift()\n            const tmp2 = queue2.shift()\n            if (tmp1.val !== tmp2.val) return false\n            let left1 = tmp1.left, right1 = tmp1.right, left2 = tmp2.left, right2 = tmp2.right;\n            if ((left1 === null) !== (left2 === null)) {\n                return false;\n            }\n            if ((right1 === null) !== (right2 === null)) {\n                return false;\n            }\n            if (left1 !== null) {\n                queue1.push(left1);\n            }\n            if (right1 !== null) {\n                queue1.push(right1);\n            }\n            if (left2 !== null) {\n                queue2.push(left2);\n            }\n            if (right2 !== null) {\n                queue2.push(right2);\n            }\n        }\n        return queue1.length === 0 && queue2.length === 0;\n    }\n}; //BFS","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1833005220","body":"var sumNumbers = function(root) {\n    function helper(root,cur){\n        if(root===null) return 0\n        cur=10*cur+root.val\n        if(root.left===null&&root.right===null) return cur\n        return helper(root.left,cur)+helper(root.right,cur)\n    }\n    return helper(root,0)\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/17#issuecomment-1835406197","body":"BFS\nvar findBottomLeftValue = function (root) {\n    const queue = []\n    let res = 0\n    queue.push(root)\n    while (queue.length) {\n        const node = queue.shift()\n        const left = node.left\n        const right = node.right\n        if (right) queue.push(right)\n        if (left) queue.push(left)\n        res = node.val\n    }\n    return res\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1837109369","body":"梦回大二数据结构原理课堂\n\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/19#issuecomment-1837406650","body":"class Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes, new Comparator<int[]>() {\n            public int compare(int[] tuple1, int[] tuple2) {\n                if (tuple1[0] != tuple2[0]) {\n                    return tuple1[0] - tuple2[0];\n                } else if (tuple1[1] != tuple2[1]) {\n                    return tuple1[1] - tuple2[1];\n                } else {\n                    return tuple1[2] - tuple2[2];\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        int size = 0;\n        int lastcol = Integer.MIN_VALUE;\n        for (int[] tuple : nodes) {\n            int col = tuple[0], row = tuple[1], value = tuple[2];\n            if (col != lastcol) {\n                lastcol = col;\n                ans.add(new ArrayList<Integer>());\n                size++;\n            }\n            ans.get(size - 1).add(value);\n        }\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null) {\n            return;\n        }\n        nodes.add(new int[]{col, row, node.val});\n        dfs(node.left, row + 1, col - 1, nodes);\n        dfs(node.right, row + 1, col + 1, nodes);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1837769667","body":"var twoSum = (nums, target) => {\n    let map = new Map()\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(target - nums[i])) {\n            return [map.get(target - nums[i]), i]\n        } else {\n            map.set(nums[i], i)\n        }\n    }\n    return null\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/21#issuecomment-1840144756","body":"var topKFrequent = function (nums, k) {\n    let map = new Map()\n    let res = []\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(nums[i])) {\n            map.set(nums[i], map.get(nums[i]) + 1)\n        } else {\n            map.set(nums[i], 1)\n        }\n    }\n    let sortArray = Array.from(map).sort((a, b) => b[1] - a[1]);\n    for (let i = 0; i < k; i++) {\n        res.push(sortArray[i][0]);\n    }\n    return res\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/22#issuecomment-1842150880","body":"var numberOfBoomerangs = function (points) {\n    let ans = 0;\n    for (const p of points) {\n        const cnt = new Map();\n        for (const q of points) {\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n            cnt.set(dis, (cnt.get(dis) || 0) + 1);\n        }\n        for (const [_, m] of cnt.entries()) {\n            ans += m * (m - 1);\n        }\n    }\n    return ans;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1844516564","body":"var lengthOfLongestSubstring = function (s) {\n    let set = new Set()\n    let res = 0\n    let rigth = -1\n    for (let i = 0; i < s.length; i++) {\n        if (i != 0) {\n            set.delete(s.charAt(i - 1))\n        }\n        while (rigth + 1 < s.length && !set.has(s.charAt(rigth + 1))) {\n            set.add(s.charAt(rigth + 1))\n            ++rigth\n        }\n        res = Math.max(res, rigth - i + 1)\n    }\n    return res\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/24#issuecomment-1846875701","body":"var findSubstring = function (s, words) {\n    const res = []\n    const m = words.length,\n        n = words[0].length,\n        ls = s.length\n    for (let i = 0; i < n; i++) {\n        if (i + m * n > ls) {\n            break\n        }\n        const differ = new Map()\n        for (let j = 0; j < m; j++) {\n            const word = s.substring(i + j * n, i + (j + 1) * n)\n            differ.set(word, (differ.get(word) || 0) + 1)\n        }\n        for (const word of words) {\n            differ.set(word, (differ.get(word) || 0) - 1)\n            if (differ.get(word) === 0) {\n                differ.delete(word)\n            }\n        }\n        for (let start = i; start < ls - m * n + 1; start += n) {\n            if (start !== i) {\n                let word = s.substring(start + (m - 1) * n, start + m * n)\n                differ.set(word, (differ.get(word) || 0) + 1)\n                if (differ.get(word) === 0) {\n                    differ.delete(word)\n                }\n                word = s.substring(start - n, start)\n                differ.set(word, (differ.get(word) || 0) - 1)\n                if (differ.get(word) === 0) {\n                    differ.delete(word)\n                }\n            }\n            if (differ.size === 0) {\n                res.push(start)\n            }\n        }\n    }\n    return res\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/25#issuecomment-1848299212","body":"省流：这个要先理解数学公式怎么推导出来的才能做\n\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n        int x = 0;\n        for (int num : nums) {\n            x = (x + num) % p;\n        }\n        if (x == 0) {\n            return 0;\n        }\n        Map<Integer, Integer> index = new HashMap<Integer, Integer>();\n        int y = 0, res = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            index.put(y, i); // f[i] mod p = y，因此哈希表记录 y 对应的下标为 i\n            y = (y + nums[i]) % p;\n            if (index.containsKey((y - x + p) % p)) {\n                res = Math.min(res, i - index.get((y - x + p) % p) + 1);\n            }\n        }\n        return res == nums.length ? -1 : res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/26#issuecomment-1848968494","body":"最值得一提的做法：快慢指针喵\n简单的喵，飞舞的雏草姬最喜欢简单题了喵(●'◡'●)\n\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849197916","body":"var removeDuplicates = function (nums) {\n    let n = nums.length\n    let fast = slow = 1\n    while (fast < n) {\n        if (nums[fast] !== nums[fast - 1]) {\n            nums[slow] = nums[fast]\n            slow++\n        }\n        fast++\n    }\n    return slow\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1851457639","body":"var searchInsert = function (nums, target) {\n    const n = nums.length;\n    let left = 0, right = n - 1, ans = n;\n    while (left <= right) {\n        let mid = Math.floor((right + left) / 2);\n        if (target <= nums[mid]) {\n            ans = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return ans;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/29#issuecomment-1853595283","body":"var maxSlidingWindow = function(nums, k) {\n    const ans = [];\n    const q = [];\n    for (let i = 0; i < nums.length; i++) {\n        // 1. 入\n        while (q.length && nums[q[q.length - 1]] <= nums[i]) {\n            q.pop(); // 维护 q 的单调性\n        }\n        q.push(i); // 入队\n        // 2. 出\n        if (i - q[0] >= k) { // 队首已经离开窗口了\n            q.shift(); // 力扣没有 Deque，不过这样写也挺快的\n        }\n        // 3. 记录答案\n        if (i >= k - 1) {\n            // 由于队首到队尾单调递减，所以窗口最大值就是队首\n            ans.push(nums[q[0]]);\n        }\n    }\n    return ans;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/30#issuecomment-1855010812","body":"/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function (n, trust) {\n    // 相当于入度\n    let arr = new Array(n + 1).fill(0)\n    // 出度\n    let arr1 = new Array(n + 1).fill(0)\n    for (let i = 0; i < trust.length; i++) {\n        let index = trust[i][1]\n        let index1 = trust[i][0]\n        arr[index] = arr[index] + 1\n        arr1[index1] = arr1[index1] + 1\n\n    }\n    for (let j = 1; j < n + 1; j++) {\n        if (arr[j] === n - 1 && arr1[j] === 0) {\n            return j\n        }\n    }\n    return -1\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/31#issuecomment-1857560018","body":"var possibleBipartition = function(n, dislikes) {\n    \n    //五. 深度优先算法：不了解深度优先算法的友友可以先百度了解一下概念\n\n    /*\n        参数1：表示当前遍历的人\n        参数2：给当前遍历的人进行染色的色号：只有1号色和2号色两种情况\n        参数3：标志数组，标志i是否染色，以及染***号\n        参数4：二维数组：g[i]中保存着i不喜欢的人\n    */\n    const dfs = (i,nowcolor,color,g)=>{\n\n        //进入这一步，表示i已经进行染色，修改标志\n        color[i] = nowcolor\n\n        //循环i不喜欢的人\n        for(let p of g[i]){\n            //若i不喜欢的人已经染色，并且色号和i一样，则发生冲突，返回false\n            if(color[p]!==0&&color[p]===color[i]){\n                return false\n            }\n            //若i不喜欢的人没有进行染色，则递归对其进行染色\n            //3^nowcolor表示 3 和nowcolor进行异或：即3^2=1 3^1=2,实现颜***号在1，2间轮流\n            if(color[p]===0&&!dfs(p,3^nowcolor,color,g)){\n                return false\n            }\n        }\n        return true\n    }\n\n\n    //一. 创建一个标志数组:大小为n+1，默认值全部为零，表示没有进行染色\n    let color = new Array(n+1).fill(0)\n\n    //二. 创建一个长度为n+1的数组，再将里面每个项初始化为空数组，也就是g是一个二维数组\n    let g = new Array(n+1)\n    for(let i=0;i<=n;i++){\n        g[i]=[]\n    }\n\n    //三. 对g数组进行初始化：g[i]中保存着i不喜欢的人\n    for(let p of dislikes){\n        g[p[0]].push(p[1])\n        g[p[1]].push(p[0])\n    }\n\n    //四. 对1-n个人进行遍历，遍历过程中没有冲突，则不会进入该判断，最终返回true，否则返回false\n    for(let i=1;i<=n;i++){\n        if(color[i]===0&&!dfs(i,1,color,g)){\n            return false\n        }\n    }\n    return true\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/32#issuecomment-1858820891","body":"什么dick题目，读了半天都没读懂题目\n\nclass Solution {\npublic:\n    using UMIV = unordered_map<int, vector<int> >;\n    using UMII = unordered_map<int, int>;\n    using VVI = vector<vector<int> >;\n    using VI = vector<int>;\n    UMIV sub;\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& befores) {\n        for (int j = 0; j < n; j++) {\n            if (group[j] == -1) group[j] = m++;\n        }\n        \n        vector<vector<int> > gg(m);\n        for (int j = 0; j < n; j++) gg[group[j]].push_back(j);\n\n        for (int i = 0; i < gg.size(); i++) {\n            // 对于组内只有一个任务的小组，直接加入sub结果集，不走topo\n            if (gg[i].size() == 1) {\n                int itemId = gg[i][0];\n                sub[group[itemId]]= {itemId};\n                continue;\n            }\n            bool f = topoSort(i, gg[i], befores);\n            if (f == false) return {};\n        }\n\n        VI groups; \n        for (int i = 0; i < m; i++) groups.push_back(i);\n        VVI newbefore(m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < befores[i].size(); j++) {\n                int prevId = group[befores[i][j]];\n                if (prevId != group[i]) newbefore[group[i]].push_back(prevId);\n            }\n        }\n        if(!topoSort(m, groups, newbefore)) return {};\n        VI rs;\n        for (auto v : sub[m]) rs.insert(rs.end(), sub[v].begin(), sub[v].end());\n        return rs;\n    }\n\n    bool topoSort(int gpid, VI& num, VVI& bef) {\n        int n = num.size();\n        UMII degree; \n        UMIV g; \n        for (int i = 0; i < n; i++) {\n            degree[num[i]] = 0;\n            g[num[i]] = vector<int>();\n        }\n        for (int i = 0; i < n; i++) {\n            int idx = num[i];\n            if(bef[idx].size() == 0) continue;\n            for (int j = 0; j < bef[idx].size(); j++) {\n                int last = bef[idx][j];\n                if (degree.find(last) == degree.end()) continue;\n                g[last].push_back(idx);\n                degree[idx]++;\n            }\n        }\n        VI res;\n        queue<int> q;\n        for (int i = 0; i < n; i++) {\n            if (degree[num[i]] == 0) \n                q.push(num[i]);\n        }\n        while (!q.empty()) {\n            int cur = q.front();\n            res.push_back(cur);\n            if (g[cur].size() != 0) {\n                for (int i = 0; i < g[cur].size(); i++) {\n                    if (--degree[g[cur][i]] == 0) q.push(g[cur][i]);\n                }\n            }\n            q.pop();\n        }\n        sub[gpid] = move(res);\n        return sub[gpid].size() == n;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/33#issuecomment-1859165598","body":"有种写平时业务代码的美\n\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        int length = moves.length();\n        for (int i = 0; i < length; i++) {\n            char move = moves.charAt(i);\n            if (move == 'U') {\n                y--;\n            } else if (move == 'D') {\n                y++;\n            } else if (move == 'L') {\n                x--;\n            } else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/34#issuecomment-1859867033","body":"const topSort = (deg, graph, items) => {\n    const Q = [];\n    for (const item of items) {\n        if (deg[item] === 0) {\n            Q.push(item);\n        }\n    }\n    const res = [];\n    while (Q.length) {\n        const u = Q.shift(); \n        res.push(u);\n        for (let i = 0; i < graph[u].length; ++i) {\n            const v = graph[u][i];\n            if (--deg[v] === 0) {\n                Q.push(v);\n            }\n        }\n    }\n    return res.length == items.length ? res : [];\n}\n\nvar sortItems = function(n, m, group, beforeItems) {\n    const groupItem = new Array(n + m).fill(0).map(() => []);\n\n    // 组间和组内依赖图\n    const groupGraph = new Array(n + m).fill(0).map(() => []);\n    const itemGraph = new Array(n).fill(0).map(() => []);\n\n    // 组间和组内入度数组\n    const groupDegree = new Array(n + m).fill(0);\n    const itemDegree = new Array(n).fill(0);\n    \n    const id = new Array(n + m).fill(0).map((v, index) => index);\n\n    let leftId = m;\n    // 给未分配的 item 分配一个 groupId\n    for (let i = 0; i < n; ++i) {\n        if (group[i] === -1) {\n            group[i] = leftId;\n            leftId += 1;\n        }\n        groupItem[group[i]].push(i);\n    }\n    // 依赖关系建图\n    for (let i = 0; i < n; ++i) {\n        const curGroupId = group[i];\n        for (const item of beforeItems[i]) {\n            const beforeGroupId = group[item];\n            if (beforeGroupId === curGroupId) {\n                itemDegree[i] += 1;\n                itemGraph[item].push(i);   \n            } else {\n                groupDegree[curGroupId] += 1;\n                groupGraph[beforeGroupId].push(curGroupId);\n            }\n        }\n    }\n\n    // 组间拓扑关系排序\n    const groupTopSort = topSort(groupDegree, groupGraph, id); \n    if (groupTopSort.length == 0) {\n        return [];\n    } \n    const ans = [];\n    // 组内拓扑关系排序\n    for (const curGroupId of groupTopSort) {\n        const size = groupItem[curGroupId].length;\n        if (size == 0) {\n            continue;\n        }\n        const res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\n        if (res.length === 0) {\n            return [];\n        }\n        for (const item of res) {\n            ans.push(item);\n        }\n    }\n    return ans;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/35#issuecomment-1861943826","body":"var numberOfRounds = function (loginTime, logoutTime) {\n    var start = 60 * parseInt(loginTime.slice(0, 2)) + parseInt(loginTime.slice(3));\n    var end = 60 * parseInt(logoutTime.slice(0, 2)) + parseInt(logoutTime.slice(3));\n    if (start > end) end += 24 * 60;\n    end = Math.floor(end / 15) * 15\n    return Math.max(Math.floor((end - start) / 15), 0)\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/36#issuecomment-1864057244","body":"var minCharacters = function (a, b) {\n    let arr1 = new Array(26).fill(0)\n    let arr2 = new Array(26).fill(0)\n    for (let i in a) {\n        arr1[a.charCodeAt(i) - 97]++\n    }\n    for (let i in b) {\n        arr2[b.charCodeAt(i) - 97]++\n    }\n    let an = a.length, bn = b.length, asum = 0, bsum = 0, res = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i < 25; i++) {\n        asum += arr1[i]\n        bsum += arr2[i]\n        res = Math.min(res, an + bn - arr1[i] - arr2[i], an - asum + bsum, bn - bsum + asum)\n    }\n    return Math.min(res, an + bn - arr1[25] - arr2[25])\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/37#issuecomment-1865392967","body":"var sortArray = function (nums) {\n            class MinHeap {\n                constructor(nums) {\n                    this.heap = [];\n                    for (let num of nums) {\n                        this.add(num);\n                    }\n                }\n                getHeap() {\n                    return this.heap;\n                }\n                add(value) {\n                    //调整当前heap为小根堆\n                    //先把value添加到最后\n                    this.heap.push(value);\n                    //然后上滤\n                    let index = this.heap.length - 1;\n                    while (index > 0) {\n                        let parent = (index - 1) >> 1; //p为index节点的父节点序号\n                        if (this.heap[parent] > this.heap[index]) {\n                            this.swap(index, parent)\n                        }\n                        index = parent;\n                    }\n                }\n                getMin() {\n                    return this.heap[0];\n                }\n                popMin() {\n                    if (this.heap.length == 0) return;\n                    if (this.heap.length == 1) return this.heap.pop();\n                    let v = this.heap.pop();\n                    let min = this.heap[0];\n                    this.heap[0] = v;\n                    //调整当前heap为小根堆\n                    let index = 0;\n                    while (index <= this.heap.length) {\n                        let leftIndex = 2 * index + 1;\n                        let rightIndex = 2 * index + 2;\n                        if (rightIndex < this.heap.length) {\n                            if (this.heap[rightIndex] <= this.heap[leftIndex]) {\n                                if (this.heap[index] > this.heap[rightIndex]) {\n                                    this.swap(index, rightIndex);\n                                }\n                                index = rightIndex;\n                            } else {\n                                if (this.heap[index] > this.heap[leftIndex]) {\n                                    this.swap(index, leftIndex);\n                                }\n                                index = leftIndex;\n                            }\n                        } else if (leftIndex >= this.heap.length) {\n                            break;\n                        } else {\n                            if (this.heap[index] > this.heap[leftIndex]) {\n                                this.swap(index, leftIndex);\n                            }\n                            index = leftIndex;\n                        }\n                    }\n                    return min;\n                }\n                swap(i, j) {\n                    let temp = this.heap[i];\n                    this.heap[i] = this.heap[j];\n                    this.heap[j] = temp;\n                }\n            }\n            let ans = [];\n            let minHeap = new MinHeap(nums);\n            while (minHeap.getHeap().length > 0) {\n                ans.push(minHeap.popMin())\n            }\n            return ans;\n        }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/38#issuecomment-1867314227","body":"var mySqrt = function (x) {\n    let left = 0, right = x, res = -1\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2)\n        if (mid * mid <= x) {\n            res = mid\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return res\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/39#issuecomment-1874888284","body":"var solution = function (isBadVersion) {\n    /**\n     * @param {integer} n Total versions\n     * @return {integer} The first bad version\n     */\n    return function (n) {\n        let left = 0, right = n\n        let res = 0\n        while (left <= right) {\n            let middle = Math.floor((left + right) / 2)\n            if (isBadVersion(middle)) {\n                res = middle\n                right = middle - 1\n            } else {\n                left = middle + 1\n            }\n        }\n        return res\n    };\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/40#issuecomment-1868506914","body":"class Solution {\n    public int reversePairs(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        return reversePairsRecursive(nums, 0, nums.length - 1);\n    }\n\n    public int reversePairsRecursive(int[] nums, int left, int right) {\n        if (left == right) {\n            return 0;\n        } else {\n            int mid = (left + right) / 2;\n            int n1 = reversePairsRecursive(nums, left, mid);\n            int n2 = reversePairsRecursive(nums, mid + 1, right);\n            int ret = n1 + n2;\n            int i = left;\n            int j = mid + 1;\n            while (i <= mid) {\n                while (j <= right && (long) nums[i] > 2 * (long) nums[j]) {\n                    j++;\n                }\n                ret += j - mid - 1;\n                i++;\n            }\n            int[] sorted = new int[right - left + 1];\n            int p1 = left, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= right) {\n                if (p1 > mid) {\n                    sorted[p++] = nums[p2++];\n                } else if (p2 > right) {\n                    sorted[p++] = nums[p1++];\n                } else {\n                    if (nums[p1] < nums[p2]) {\n                        sorted[p++] = nums[p1++];\n                    } else {\n                        sorted[p++] = nums[p2++];\n                    }\n                }\n            }\n            for (int k = 0; k < sorted.length; k++) {\n                nums[left + k] = sorted[k];\n            }\n            return ret;\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/41#issuecomment-1868884696","body":"var findRadius = function (houses, heaters) {\n    houses.sort((a, b) => a - b);\n    heaters.sort((a, b) => a - b);\n    let ans = 0;\n    for (let i = 0, j = 0; i < houses.length; i++) {\n        let curDistance = Math.abs(houses[i] - heaters[j]);\n        while (j < heaters.length - 1 && Math.abs(houses[i] - heaters[j]) >= Math.abs(houses[i] - heaters[j + 1])) {\n            j++;\n            curDistance = Math.min(curDistance, Math.abs(houses[i] - heaters[j]));\n        }\n        ans = Math.max(ans, curDistance);\n    }\n    return ans;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/42#issuecomment-1869376391","body":"var smallestDistancePair = function(nums, k) {\n    nums.sort((a, b) => a - b);\n    let n = nums.length, left = 0, right = nums[n - 1] - nums[0];\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        let cnt = 0;\n        for (let j = 0; j < n; j++) {\n            const i = binarySearch(nums, j, nums[j] - mid);\n            cnt += j - i;\n        }\n        if (cnt >= k) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n};\n\nconst binarySearch = (nums, end, target) => {\n    let left = 0, right = end;\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/43#issuecomment-1874887747","body":"var swimInWater = function (grid) {\n    let n = grid.length\n    let low = grid[0][0]\n    let high = n * n\n    while (low < high) {\n        let mid = Math.floor((low + high) / 2)\n        if (!isCanSwim(mid, grid)) {\n            low = mid + 1\n        } else {\n            high = mid\n        }\n    }\n    return low\n};\nconst isCanSwim = (t, grid) => {\n    let n = grid.length\n    let vis = Array.from(Array(n), () => Array(n).fill(false))\n    let dfs = (row, col) => {\n        if (row < 0 || col < 0 || row >= n || col >= n || vis[row][col] || grid[row][col] > t) {\n            return false\n        }\n        if (row == n - 1 && col == n - 1) {\n            return true\n        }\n        vis[row][col] = true\n        return dfs(row + 1, col) || dfs(row - 1, col) || dfs(row, col + 1) || dfs(row, col - 1);\n    }\n    return dfs(0, 0)\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/44#issuecomment-1870886465","body":"var maxVowels = function (s, k) {\n    const yy = ['a', 'e', 'i', 'o', 'u']\n    let left = 0,\n        right = k - 1\n    let res = 0\n    for (let i = left; i <= right; i++) {\n        if (yy.includes(s[i])) {\n            res++\n        }\n    }\n    var maxLen = res\n    while (right < s.length) {\n        if (yy.includes(s[left])) {\n            res--\n        }\n        left++\n        right++\n        if (yy.includes(s[right])) {\n            res++\n        }\n        maxLen = Math.max(maxLen, res)\n    }\n    return maxLen\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/45#issuecomment-1871845297","body":"```\nvar new21Game = function (N, K, W) {\n  let dp = new Array(K + W).fill(null);\n  let s = 0;\n  for (let i = K; i < K + W; i++) {\n    dp[i] = i <= N ? 1 : 0;\n    s += dp[i];\n  }\n  for (let i = K - 1; i >= 0; i--) {\n    dp[i] = s / W;\n    s = s - dp[i + W] + dp[i];\n  }\n  return dp[0];\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/46#issuecomment-1872541150","body":"Sounds not bad, but I do not wanna solve problem even holiday\n\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        int sLen = s.length(), pLen = p.length();\n\n        if (sLen < pLen) {\n            return new ArrayList<Integer>();\n        }\n\n        List<Integer> ans = new ArrayList<Integer>();\n        int[] sCount = new int[26];\n        int[] pCount = new int[26];\n        for (int i = 0; i < pLen; ++i) {\n            ++sCount[s.charAt(i) - 'a'];\n            ++pCount[p.charAt(i) - 'a'];\n        }\n\n        if (Arrays.equals(sCount, pCount)) {\n            ans.add(0);\n        }\n\n        for (int i = 0; i < sLen - pLen; ++i) {\n            --sCount[s.charAt(i) - 'a'];\n            ++sCount[s.charAt(i + pLen) - 'a'];\n\n            if (Arrays.equals(sCount, pCount)) {\n                ans.add(i + 1);\n            }\n        }\n\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/47#issuecomment-1872937910","body":"你说的对，但是今天是元旦\n\nclass Solution {\n    Map<Character, Integer> ori = new HashMap<Character, Integer>();\n    Map<Character, Integer> cnt = new HashMap<Character, Integer>();\n\n    public String minWindow(String s, String t) {\n        int tLen = t.length();\n        for (int i = 0; i < tLen; i++) {\n            char c = t.charAt(i);\n            ori.put(c, ori.getOrDefault(c, 0) + 1);\n        }\n        int l = 0, r = -1;\n        int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;\n        int sLen = s.length();\n        while (r < sLen) {\n            ++r;\n            if (r < sLen && ori.containsKey(s.charAt(r))) {\n                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);\n            }\n            while (check() && l <= r) {\n                if (r - l + 1 < len) {\n                    len = r - l + 1;\n                    ansL = l;\n                    ansR = l + len;\n                }\n                if (ori.containsKey(s.charAt(l))) {\n                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);\n                }\n                ++l;\n            }\n        }\n        return ansL == -1 ? \"\" : s.substring(ansL, ansR);\n    }\n\n    public boolean check() {\n        Iterator iter = ori.entrySet().iterator(); \n        while (iter.hasNext()) { \n            Map.Entry entry = (Map.Entry) iter.next(); \n            Character key = (Character) entry.getKey(); \n            Integer val = (Integer) entry.getValue(); \n            if (cnt.getOrDefault(key, 0) < val) {\n                return false;\n            }\n        } \n        return true;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/48#issuecomment-1873378020","body":"读题读了半天\n\nint solve(vector<int>& nums, int target) {\n    int n = nums.size();\n    int newTarget = accumulate(nums.begin(), nums.end(), 0) - target;\n    if(newTarget == 0) return n;\n    int curSum = 0;\n    int maxLen = 0;\n    int left = 0;\n    for(int i = 0; i < n; ++i) {\n        curSum += nums[i];\n        while(curSum >= newTarget && i >= left) {\n            if(curSum == newTarget) {\n                maxLen = max(maxLen, i - left + 1);\n            }\n\n            curSum -= nums[left];\n            ++left;\n        }\n    }\n    return maxLen == 0 ? -1 : n - maxLen;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/49#issuecomment-1874885743","body":"var readBinaryWatch = function (num) {\n    const timeList = [];\n    function dfs(time, n, index) {\n        const hour = time >> 6, minute = time & 0b111111;\n        if (hour > 11 || minute > 59) return;\n        if (n === 0) {\n            timeList.push(`${hour}:${minute < 10 ? \"0\" + minute : minute}`);\n            return;\n        }\n        const end = 10 - n;\n        while (index <= end) {\n            dfs(time | (1 << index), n - 1, ++index);\n        }\n    }\n    dfs(0, num, 0);\n    return timeList;\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/50#issuecomment-1874780241","body":"/**\n * @param {number} n\n * @return {string[][]}\n */\nvar solveNQueens = function (n) {\n    let res = []\n    let path = []\n    backtrack(0, path)\n    return res\n\n    function backtrack(row, tmp) {\n        // 1.终止条件\n        if (row === n) {\n            res.push(\n                tmp.map(c => {\n                    let arr = new Array(n).fill('.')\n                    arr[c] = 'Q'\n                    return arr.join('')\n                })\n            )\n        }\n\n        // 2.迭代：\n        for (let col = 0; col < n; col++) {\n            let canNotSet = tmp.some((c, r) => {\n                return c == col || ((r - c) === (row - col)) || ((r + c) === (row + col))\n            })\n            if (canNotSet) {\n                continue\n            }\n            backtrack(row + 1, [...tmp, col])\n        }\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/54#issuecomment-1877177499","body":"var maxAreaOfIsland = function(grid) {\n    let count=0,x=grid[0].length,y=grid.length;\n    for(let i=0;i<y;i++){\n        for(let j=0;j<x;j++){\n            if(grid[i][j]===1) count=Math.max(count,areaOfIsland(grid,i,j,y,x))\n        }\n    }\n    return count\n};\n\nvar areaOfIsland = (grid,i,j,y,x) =>{\n    if(i>=y||i<0||j>=x||j<0||grid[i][j]===0) return 0\n    let num=1;\n    grid[i][j]=0;\n    num+=areaOfIsland(grid,i+1,j,y,x);\n    num+=areaOfIsland(grid,i-1,j,y,x);\n    num+=areaOfIsland(grid,i,j+1,y,x);\n    num+=areaOfIsland(grid,i,j-1,y,x);\n    return num\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/55#issuecomment-1878008391","body":"var maxDistance = function (grid) {\n    var result = -1; //距离\n    var land = [];//存放陆地的队列\n    var row = grid.length;//行数\n    var col = grid[0].length;//列数\n    for (var i = 0; i < row; i++) { // 所有陆地入队\n        for (var j = 0; j < col; j++) {\n            if (grid[i][j] == 1) {\n                land.push([i, j]);\n            }\n        }\n    }\n    //全是海洋或者陆地\n    if (land.length == 0 || land.length == row * col) { return -1; }\n    //对每一块陆地进行BFS，对每一块遍历过的海洋标记成陆地\n    while (land.length > 0) {\n        var size = land.length;//记录当前层陆地的个数\n        while (size > 0) {\n            size--;\n            var cur = land.shift();//第一个入队的陆地\n            //四个方向\n            var directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\n            for (var i = 0; i < 4; i++) {\n                var r = cur[0] + directions[i][0];\n                var c = cur[1] + directions[i][1];\n                //越界，跳过此方向\n                if (r < 0 || r > col - 1 || c < 0 || c > row - 1 || grid[r][c] == 1) {\n                    continue;\n                }\n                //如果是海洋，标记为陆地，加入到队列中，距离＋1\n                if (grid[r][c] == 0) {\n                    grid[r][c] = 1;\n                    land.push([r, c]);\n                }\n            }\n        }\n        result++;\n    }\n    return result;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/56#issuecomment-1879594523","body":"越写越觉得像是我最近在写的业务代码，看着就烦，实际上没有什么难度，就是计算的时候恶心人\n\nclass Solution {\n        public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\n\n            // initial vars\n            int n = status.length;\n            int ret = 0;\n            boolean[] openableBox = new boolean[n], existedBox = new boolean[n], usedBox = new boolean[n];\n            Deque<Integer> deque = new ArrayDeque<>();\n\n            // revert status of box from int to bool\n            for (int i = 0; i < n; i++) {\n                openableBox[i] = status[i] == 1;\n            }\n\n            // all the initial boxes is openable and used\n            // just add the index of all such boxes to queue\n            for(int i : initialBoxes){\n                existedBox[i] = true;\n                if(openableBox[i]) {\n                    usedBox[i] = true;\n                    deque.add(i);\n                }\n            }\n\n            // turns of opening box, each time open a box, can get candies and get more keys from current box\n            for (Integer i : deque) {\n                // purchase candies\n                ret += candies[i];\n                // purchase keys from this box, and mark this box into existed also used\n                for(int k : keys[i]){\n                    openableBox[k] = true;\n                    if(existedBox[k] && !usedBox[k]){\n                        usedBox[k] = true;\n                        deque.add(k);\n                    }\n                }\n                // the box contained should be searched by the two dimension array\n                for(int k : containedBoxes[i]){\n                    existedBox[k] = true;\n                    if(openableBox[k] && !usedBox[k]){\n                        usedBox[k] = true;\n                        deque.add(k);\n                    }\n                }\n            }\n\n            return ret;\n        }\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/57#issuecomment-1880062474","body":"高级\n\nclass Solution {\npublic:\n    int findRadius(vector<int> &houses, vector<int> &heaters) {\n        int ans = 0;\n        sort(heaters.begin(), heaters.end());\n        for (int house: houses) {\n            int j = upper_bound(heaters.begin(), heaters.end(), house) - heaters.begin();\n            int i = j - 1;\n            int rightDistance = j >= heaters.size() ? INT_MAX : heaters[j] - house;\n            int leftDistance = i < 0 ? INT_MAX : house - heaters[i];\n            int curDistance = min(leftDistance, rightDistance);\n            ans = max(ans, curDistance);\n        }\n        return ans;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/58#issuecomment-1880418639","body":"var minCostClimbingStairs = function (cost) {\n    const n = cost.length;\n    let prev = 0, curr = 0;\n    for (let i = 2; i <= n; i++) {\n        let next = Math.min(curr + cost[i - 1], prev + cost[i - 2]);\n        prev = curr;\n        curr = next;\n    }\n    return curr;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/59#issuecomment-1882450668","body":"var rob = function(nums) {\n    let dp = [];dp[0]= nums[0];dp[1]= Math.max(dp[0],nums[1])\n    for(let i=2;i<nums.length;i++) dp[i]= Math.max(dp[i-2] + nums[i],dp[i-1])\n    return dp[nums.length-1]\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/60#issuecomment-1884518105","body":"var findNumberOfLIS = function(nums) {\n    let n = nums.length, maxLen = 0, ans = 0;\n    const dp = new Array(n).fill(0);\n    const cnt = new Array(n).fill(0);\n    for (let i = 0; i < n; ++i) {\n        dp[i] = 1;\n        cnt[i] = 1;\n        for (let j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                if (dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    cnt[i] = cnt[j]; // 重置计数\n                } else if (dp[j] + 1 === dp[i]) {\n                    cnt[i] += cnt[j];\n                }\n            }\n        }\n        if (dp[i] > maxLen) {\n            maxLen = dp[i];\n            ans = cnt[i]; // 重置计数\n        } else if (dp[i] === maxLen) {\n            ans += cnt[i];\n        }\n    }\n    return ans;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/61#issuecomment-1886761121","body":"var longestCommonSubsequence = function(text1, text2) {\n    const m = text1.length, n = text2.length;\n    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for (let i = 1; i <= m; i++) {\n        const c1 = text1[i - 1];\n        for (let j = 1; j <= n; j++) {\n            const c2 = text2[j - 1];\n            if (c1 === c2) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/63#issuecomment-1890341711","body":"const dirs = [[-2, -1], [-2, 1], [2, -1], [2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2]];\nvar knightProbability = function(n, k, row, column) {\n    const dp = new Array(k + 1).fill(0).map(() => new Array(n).fill(0).map(() => new Array(n).fill(0)));\n    for (let step = 0; step <= k; step++) {\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                if (step === 0) {\n                    dp[step][i][j] = 1;\n                } else {\n                    for (const dir of dirs) {\n                        const ni = i + dir[0], nj = j + dir[1];\n                        if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                            dp[step][i][j] += dp[step - 1][ni][nj] / 8;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dp[k][row][column];\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"javajianghu":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1814185749","body":"### 题目 \n\n[989. 数组形式的整数加法](https://leetcode.cn/problems/add-to-array-form-of-integer/description/)\n\n### 解题思路\n\n#### 思路一【失败】\n\n把数组的最后一位认为是个位，然后向前依次为个位、十位、百位，那么数值为：\n\n个位 = 10的0次方 * 个位的数\n\n十位 = 10的1次方 * 十位的数\n\n...\n\n依次类推，就可以得出代码如下：\n\n##### 代码\n\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        long total = k;\n        int len = num.length;\n        for (int i = len; i > 0 ; i--) {\n            total += Math.pow(10,len - i) * num[i - 1];\n        }\n        String[] numberArray = String.valueOf(total).split(\"\");\n        return Arrays.stream(numberArray).map(Integer::valueOf).toList();\n    }\n```\n\n当num的长度不大时，total没有超过long的取值范围（ 2^63-1），结果正确，如果超过，数据就是错误的。\n\n```\n解答失败:\n\t测试用例:[1,2,6,3,0,7,1,7,1,9,7,5,6,6,4,4,0,0,6,3]\n\t\t\t516\n\t测试结果:[9,2,2,3,3,7,2,0,3,6,8,5,4,7,7,5,8,0,7]\n\t期望结果:[1,2,6,3,0,7,1,7,1,9,7,5,6,6,4,4,0,5,7,9]\n```\n\n\n#### 思路二\n\n因为直接相加数值太大，那么一位一位相加。相加需要进位的就记录下来，然后这样一位一位这么处理，类似于草稿纸上的加法处理方式。\n\n##### 代码\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        // 先把k装换为数组\n        String[] kArr = String.valueOf(k).split(\"\");\n        \n        // 比对num和kArr数组长度，谁的长，以谁的长度遍历\n        int kArrLength = kArr.length;\n        int numLength = num.length;\n        int forLen = numLength;\n        if(kArrLength > numLength){\n            forLen = kArrLength;\n        }\n        \n        // 结果最多多一位，所以设置结果的长度为forLen + 1\n        int[] result = new int[forLen + 1];\n\n        int moreAddNum = 0;\n        for (int i = 1 ; i <= forLen ; i++) {\n            int val = 0;\n            if(num.length - i >= 0 ){\n                val += num[num.length - i];\n            }\n            if(kArr.length - i >= 0 ){\n                // 从后向前获取数组的某一位值，然后相加\n                val += Integer.parseInt(kArr[kArr.length - i]);\n            }\n            \n            // 如果刚才低位相加的值>0,那就加到当前数值上\n            if(moreAddNum > 0){\n                val += moreAddNum;\n            }\n            \n            // 除以10，得到进位的数字\n            moreAddNum = val / 10;\n           \t// 取除以10的余数就是当前位数的值，小于10就是自己，大于10就是余数\n            result[result.length - i] = val % 10;\n\n            // 给结果的第0位赋值\n            if(i == forLen && moreAddNum != 0){\n                result[0] = moreAddNum;\n            }\n        }\n        \n        // 转换result数组为list\n        List<Integer> list = Arrays.stream(result).boxed().collect(Collectors.toList());\n        if(list.get(0) == 0){\n            list.remove(0);\n        }\n        System.out.println(list);\n        return list;\n    }\n```\n\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1816052736","body":"### 题目 \n\n[821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)\n\n### 解题思路\n\n#### 思路\n1、先遍历字符串，记录每个字符的位置\n2、然后再遍历字符串，根据字符的位置计算字符与字符之间的距离。\n\n##### 代码\n\n```\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        char[] chars = s.toCharArray();\n        // 记录字符c在字符串s中的位置\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < chars.length; i++) {\n            if(chars[i] == c){\n                list.add(i);\n            }\n        }\n        for (int i = 0; i < chars.length; i++) {\n            // 默认第一个为最小距离\n            int minLength = Math.abs(i - list.get(0));\n            if(minLength != 0){\n                // 遍历list，找到最小距离\n                for (int j = 1; j < list.size(); j++) {\n                    minLength = Math.min(minLength, Math.abs(i - list.get(j)));\n                    if(minLength == 0){\n                        break;\n                    }\n                }\n            }\n            res[i] = minLength;\n        }\n        return res;\n    }\n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n：\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817543215","body":"### 题目 \n\n[1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)\n\n### 解题思路\n\n#### 思路\n1、初始化的时候就创建maxSize的int数组，减少后续扩容的操作。\n2、为了能够O(1)进行pop和push，那么需要记录下当前数据到哪个索引下标了，所以增加nextIndex表示下次操作索引，当pop和push时记录对其++或者--\n\n##### 代码\n```\npublic class CustomStack {\n    // 存放元素最大个数\n    private int maxSize;\n\n    // 数组存储\n    private int[] stack;\n\n    // 下一个值存放索引位置\n    private int nextIndex = 0;\n\n    private CustomStack(){}\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.stack = new int[maxSize];\n    }\n\n    public void push(int x){\n        // 当小于最大元素个数时才插入，插入完成后nextIndex++\n        if(nextIndex <= (maxSize - 1)){\n            stack[nextIndex++] = x;\n        }\n    }\n\n    public int pop(){\n        if(0 == nextIndex){\n            return -1;\n        }\n        // 获取当前元素索引\n        nextIndex--;\n        int result = stack[nextIndex];\n        // 取出重置为0\n        stack[nextIndex] = 0;\n        return result;\n    }\n\n    public void inc(int k, int val){\n        if(0 == nextIndex){\n            return;\n        }\n        //\n        int len = Math.min(nextIndex,k);\n        for (int i = 0; i < len ; i++) {\n            stack[i] += val;\n        }\n    }\n\n    public String toString(){\n        return Arrays.toString(stack);\n    }\n}   \n```\n##### 复杂度分析\n- 时间复杂度：\n  - push：O(1)\n  - pop: O(1)\n  - inc: O(n)\n- 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817811488","body":"### 题目 \n\n[394. 字符串解码](https://leetcode.cn/problems/decode-string/)\n\n### 解题思路\n1、要匹配[]，那么使用栈的方式，记录]入栈的时候再处理比较合适。\n2、先把非]的字符压入栈，当字符为]时，开始处理栈里面的数据。\n  2.1 首先获取]之前到[所有的字母。\n  2.2 然后获取[之前所有的数字。\n  2.3 然后根据数字，获取倍数的[]的字母\n  2.4 再把得到的倍数字符串放入到栈中，继续处理，直到下次的]出现，再运行上面的流程。\n3、最后获取栈里面所有的字母转换为字符串\n\n#### 思路\n\n\n##### 代码\n```\npublic String decodeString(String s) {\n        char[] charArray = s.toCharArray();\n        Stack<Character> stack = new Stack();\n\n        for (int i = 0; i < charArray.length; i++) {\n            if(charArray[i] != ']'){\n                stack.push(charArray[i]);\n            }else{\n                // 当字符为]\n\n                // 解析栈里面的字符串,获取]之前，[之后的字符串\n                StringBuilder sb = new StringBuilder();\n                boolean isLetter = false;\n                do{\n                    isLetter = !stack.empty() && Character.isLetter(stack.peek());\n                    if(isLetter){\n                        sb.insert(0,stack.pop());\n                    }else{\n                        break;\n                    }\n                }while (isLetter);\n                // 得到[]的字符串\n                String subStr = sb.toString();\n\n                // 抛出[\n                stack.pop();\n\n                // 获取数字\n                sb = new StringBuilder();\n                boolean isDigit = false;\n                do{\n                    isDigit = !stack.empty() && Character.isDigit(stack.peek());\n                    if(isDigit){\n                        sb.insert(0,stack.pop());\n                    }else{\n                        break;\n                    }\n                }while (isDigit);\n\n                // 获取倍数\n                int count = Integer.parseInt(sb.toString());\n\n                // 把倍数后的字符串再放入栈\n                for (int j = 0; j < count; j++) {\n                    char[] subStrCharArray = subStr.toCharArray();\n                    for (char c : subStrCharArray) {\n                        stack.push(c);\n                    }\n                }\n            }\n        }\n\n        // 获取栈里面所有的数据\n        StringBuilder result = new StringBuilder();\n        while(!stack.empty()){\n            result.insert(0,stack.pop());\n        }\n        return result.toString();\n\n    }\n```\n##### 复杂度分析\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818364439","body":"### 题目 \n\n[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)\n\n### 解题思路\n1、因为栈的操作是先入后出，那么使用pop的话，是把栈最上层的元素出栈，但是题目要求是把最底层的元素出栈。\n\n2、借助另外一个栈，把这个栈的元素都pop到另外一个栈，那么最底层的元素就变成了最上层的元素。\n\n​\t2.1 创建两个栈，firstStack、secondStack，firstStack用于存储插入顺序的栈，secondStack表示倒叙的栈。\n\n​\t2.2 当插入元素时，需要把secondStack的元素都倒回到firstStack中，然后再push\n\n​\t2.3 当弹出元素时，就把firstStack的元素导出到secondStack中，然后secondStack中pop就可以了。\n\n#### 思路\n\n\n##### 代码\n```\nclass MyQueue {\n\n    private Stack<Integer> firstStack = new Stack<>();\n    private Stack<Integer> secondStack = new Stack<>();\n\n    public MyQueue() {\n\n    }\n\n    // 将元素 x 推到队列的末尾\n    public void push(int x) {\n        while (!secondStack.isEmpty()) {\n            firstStack.push(secondStack.pop());\n        }\n        firstStack.push(x);\n    }\n\n    //  从队列的开头移除并返回元素\n    public int pop() {\n        // 把firstStack的全部元素都倒腾到secondStack中\n        while (!firstStack.isEmpty()) {\n            secondStack.push(firstStack.pop());\n        }\n        return secondStack.pop();\n    }\n\n    // 返回队列开头的元素\n    public int peek() {\n        while (!firstStack.isEmpty()) {\n            secondStack.push(firstStack.pop());\n        }\n        return secondStack.peek();\n    }\n\n    // 如果队列为空，返回 true ；否则，返回 false\n    public boolean empty() {\n        return firstStack.isEmpty() && secondStack.isEmpty();\n    }\n}\n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822335738","body":"### 题目 \n\n[[61. 旋转链表)](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\n\n### 解题思路\n\n#### 思路\n\n1、旋转列表，旋转一次，表示最后一个节点变成头节点，而且next变成之前的head，然后倒数第二个节点变成最后的节点，并且对应的next要变成null\n\n2、那么就遍历链接长度，获取到最后一个节点，然后把last作为newHead，做完以后会有一个问题，就是最后一个节点应该指向null，但是现在指向的是之前的last\n\n3、为了解决第2步遗留的问题，还需要再遍历下newHead,当newHead中的长度和之前head的长度一致时，就把最后一个节点的next改为null，这样newHead就正确了。\n\n关键点在于找到移动k次和链表长度的关系，这样才能减少循环次数\n\n\n##### 代码\n```\n    public ListNode rotateRight(ListNode head, int k) {\n        if(null == head || null == head.next){\n            return head;\n        }\n\n        // 获取链表的长度\n        int count = 1;\n        ListNode next = head;\n        while(next.next != null){\n            count++;\n            next = next.next;\n        }\n        // 如果移动k次和链表长度取余 = 0 表示链表不需要移动就是结果\n        if(k % count == 0){\n            return head;\n        }\n\n        ListNode newHead = head;\n        for (int i = 0; i < k % count; i++) {\n            ListNode nt = newHead;\n            // 链表节点数量\n            while(nt.next != null){\n                nt = nt.next;\n            }\n            // 把最后一个节点的next改为之前的head\n            nt.next = newHead;\n            // 然后把last作为新的head\n            newHead = new ListNode(nt.val, nt.next);\n            // 这个遍历的操作是为了把最后一个节点的next改为null，当count == x的时候就表示是最后一个节点\n            ListNode n = newHead;\n            int x = 1;\n            while(n.next != null){\n                x++;\n                n = n.next;\n                if(x == count){\n                    n.next = null;\n                }\n            }\n        }\n        return newHead;\n    }\n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1823754923","body":"### 题目 \n\n[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)\n\n### 解题思路\n\n#### 思路\n\n1、两两交换的话，想起了排序中两两交换，使用中间temp变量的操作，那么就在链表头部引入一个temp临时节点，作为交换用的节点。\n\n2、那么新的链表就是：temp节点->节点1->节点2->null\n\n第一次交换就是：\n\ntemp.next = 节点2\n\n节点1.next = 节点2.next\n\n节点2.next = 节点1\n\n// 将下个起点作为循环的开始节点\n\ntemp =  节点1\n\n\n##### 代码\n```\n     public ListNode swapPairs(ListNode head) {\n        ListNode top = new ListNode(0,head);\n        ListNode temp = top;\n        while(null != temp.next && null != temp.next.next){\n            ListNode one = temp.next;\n            ListNode two = temp.next.next;\n            temp.next = two;\n            one.next = two.next;\n            two.next = one;\n            temp = one;\n        }\n        return top.next;\n    }\n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826737981","body":"### 题目 \n\n[142.环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/description/)\n\n### 解题思路\n\n#### 思路\n循环获取head的下一个节点，然后把节点值存储到set中，当节点在set存在，说明存在环，否则没有环。\n\n##### 代码\n```\n  public ListNode detectCycle(ListNode head) {\n        if(null == head || null == head.next){\n            return null;\n        }\n        Set<ListNode> set = new HashSet<>();\n        set.add(head);\n        ListNode pos = head;\n        while(null != (pos = pos.next)){\n            if(set.contains(pos)){\n                return pos;\n            }\n            set.add(pos);\n        }\n        return null;\n    }   \n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829411515","body":"### 题目 \n\n[104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)\n\n### 解题思路\n\n#### 思路\n\n1、使用递归，获取左子树的深度，再获取右子树的深度，看下哪个深度最大，然后加上本节点，就是总深度。\n\n\n##### 代码\n```\npublic int maxDepth(TreeNode root) {\n        if(null == root){\n            return 0;\n        }\n        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;\n}\n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831343139","body":"### 题目 \n\n[100.相同的树](https://leetcode.cn/problems/same-tree/description/)\n\n### 解题思路\n\n#### 思路\n\n1、判断两个二叉树相同，那么他们的左树和右树值相等，如果不相等就是不相同\n\n2、如果两个树都是null，则一样。\n\n3、两个树有一个为null，则不一样。\n\n4、如果树都存在，就判断值是不是一样。\n\n5、左右子树都一样才算相同。\n\n和上一个题一样，使用递归遍历树是最好的方式\n\n\n##### 代码\n```\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(null == p && null == q){\n            return true;\n        }\n\n        if(null == p || null == q){\n            return false;\n        }\n\n        if(p.val != q.val){\n            return false;\n        }\n\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n    }\n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/17#issuecomment-1835801165","body":"### 题目 \n\n[513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)\n\n### 解题思路\n\n#### 思路\n\n1、既然是找到最下层最左侧，那么使用层序遍历的方式是最好的。\n\n2、使用队列存储结点，放入结点时先放右结点，再放左结点，只要队列不为空，就一直从头取值，每次取值记录下当前节点的值，最后剩下的就是最左侧的节点值。\n\n\n##### 代码\n```\n   public int findBottomLeftValue(TreeNode root) {\n        int result = 0;\n\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            // 队列不为空\n            TreeNode node = queue.poll();\n            if(null != node.right){\n                queue.offer(node.right);\n            }\n            if(null != node.left){\n                queue.offer(node.left);\n            }\n            result = node.val;\n        }\n\n        return result;\n    }\n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1837738808","body":"### 题目 \n\n[1. 两数之和](https://leetcode.cn/problems/two-sum/)\n\n### 解题思路\n\n#### 思路\n\n##### 思路一：\n\n双重for循环，第一层遍历取一个数，然后和此数后面所有的数相加，确认是否和target相等，相等返回对应的下标位置。\n\n##### 思路二：\n\n单层for循环，增加map存储，循环前确认当前值是否在map中存在，存在就表示有相等的值。\n\n此处存储map的时候注意，key存储为target - nums[i] , value存储为i，i表示数组下标，这样循环时判断map.get(nums[i]) 的值是否为空就可以了。\n\n\n##### 代码\n```\n     public int[] twoSum(int[] nums, int target) {\n        for(int i = 0;i < nums.length - 1;i++){\n            for(int j = i +1; j < nums.length;j++){\n                if(nums[i] + nums[j] == target){\n                    return new int[]{i,j};\n                }\n            }\n        }\n        return null;\n    }\n  \n  \n      public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i = 0;i < nums.length;i++){\n            Integer index = map.get(nums[i]);\n            if(null != index){\n                return new int[]{i,index};\n            }\n            map.put(target - nums[i],i);\n        }\n        return null;\n    }\n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/21#issuecomment-1840417618","body":"### 题目 \n\n[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)\n\n### 解题思路\n\n#### 思路\n\n1、先遍历统计出所有元素出现的次数，并把结果放到map中。\n\n2、使用优先队列存储元素的值。注意创建的Comparator是用map的value进行比较，就是用出现的次数。\n\n3、遍历map，当优先队列中的数量小于k时，直接插入，否则判断新出来的元素对应的次数，是否比优先队列中最小的元素的次数大，如果大，就把优先队列中的最小的值删除，把当前元素插入。\n\n4、遍历优先队列就可以得到结果了。\n\n\n##### 代码\n```\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer,Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num,map.getOrDefault(num,0) + 1);\n        }\n\n        PriorityQueue<Integer> pq = new PriorityQueue<>(k, Comparator.comparingInt(map::get));\n        for (Integer key : map.keySet()) {\n            if(pq.size() < k){\n                pq.offer(key);\n            }else if(map.get(key) > map.get(pq.peek())){\n                pq.poll();\n                pq.offer(key);\n            }\n        }\n        int[] result = new int[k];\n        int i = 0;\n        while(null != pq.peek()){\n            result[i] = pq.poll();\n            i ++;\n        }\n        return result;\n    }\n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1844808796","body":"### 题目 \n\n[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\n\n### 解题思路\n\n#### 思路\n\n##### 思路一\n\n1、用map记录下字符及所在索引。\n\n2、插入map前先判断下当前字符是否已经存在，如果不存在直接插入，字符串的长度就是Math.max(max,map.size)，就是map的长度和max的最大值。\n\n3、如果存在，就获取到之前存在的字符位置index，然后获取到index + 1 到 当前索引i的所有字符，就是能获取的最大字符。先把map清空，再重新put进来，\n\n这时map的长度就是字符串的长度。\n\n这个思路主要还是想打印出来最长字符串是什么，所以把字符串都put到map中了。然后直接获取map长度就可以获取最大字符串长度了。\n\n\n\n##### 思路二\n\n1、和思路一类似，不关心字符串内容，只关心长度。\n\n2、上次存在的索引位置为index，当前为i，那么最长字符串就是  index 到 i 的，那就是 i - index,再加上当前字符 + 1\n\nMath.max(max,i-left+1)\n\n3、更新最新的字符索引为当前i。\n\n\n\n\n##### 代码\n```\n    // 思路一\n    public int lengthOfLongestSubstring(String s) {\n        if(null == s || \"\".equals(s)){\n            return 0;\n        }\n        if(1 == s.length()){\n            return 1;\n        }\n\n        int max = 0;\n        char[] chars = s.toCharArray();\n        Map<Character,Integer> map = new LinkedHashMap<>();\n\n        for(int i = 0; i < chars.length; i++){\n            if(null != map.get(chars[i])){\n                int index = map.get(chars[i]);\n                map.clear();\n                for(int j = index + 1; j <= i; j++){\n                    map.put(chars[j],j);\n                }\n                max = Math.max(max,map.size());\n            }else{\n                map.put(chars[i],i);\n                max = Math.max(max,map.size());\n            }\n        }\n        map.forEach((k,v) -> System.out.println(k + \":\" + v + \"\\n\"));\n        return max;\n  }   \n  \n  // 思路二\n  public int lengthOfLongestSubstring(String s) {\n        if(null == s || \"\".equals(s)){\n            return 0;\n        }\n        if(1 == s.length()){\n            return 1;\n        }\n        HashMap<Character, Integer> map = new HashMap<>();\n        int max = 0;\n        int left = 0;\n        for(int i = 0; i < s.length(); i ++){\n            // 是否包含key\n            if(map.containsKey(s.charAt(i))){\n                // 字符开始位置，从重复的字符开始位置+1\n                left = Math.max(left,map.get(s.charAt(i)) + 1);\n            }\n            // 长度就等于当前位置-开始位置+1\n            max = Math.max(max,i-left+1);\n            // 更新字符位置\n            map.put(s.charAt(i),i);\n        }\n        return max;\n}\n```\n##### 复杂度分析\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849595642","body":"### 题目 \n\n[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)\n\n### 解题思路\n\n#### 思路\n\n使用双指针的方式，一个读指针，用于遍历，一步一步走，一个写指针，只有当前值和读取的值不一样，才将读取的值填入写值的下一位。\n\n\n##### 代码\n```\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n       int length = nums.length;\n       int j = 0;\n       for(int i = 1;i < length; i++){\n           if(nums[i] != nums[j]){\n                nums[++j] = nums[i];\n           }\n       }\n       return j + 1;\n    }\n}    \n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1851206992","body":"### 题目 \n\n[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)\n\n### 解题思路\n\n#### 思路\n\n使用二分查找，如果能查到那就是mid的值，如果查不到，那结果就是left的值。\n\n\n##### 代码\n```\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        int left = 0;\n        int right = n - 1;\n        while(left <= right){\n            int mid = left + ((right - left) >> 1);\n            if(nums[mid] > target ){\n                // 往左边查\n                right = mid - 1;\n            }else if(nums[mid] < target){\n                // 往右边查\n                left = mid + 1;\n            }else{\n                return mid;                    \n            }\n        }\n\n        // 执行到这里说明数组中不存在target，经过二分查找，那么target最终需要插入的index就是left\n        return left;\n    }\n}\n```\n##### 复杂度分析\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/33#issuecomment-1859070028","body":"### 题目 \n\n[657. 机器人能否返回原点](https://leetcode.cn/problems/robot-return-to-origin/description/)\n\n### 解题思路\n\n#### 思路\n\n1、机器人只有上、下、左、右四个动作，那么上对下，左对右，一上一下等于没动地方，一左一右等于没动地方。\n2、所以只需要判断上、下是否成对出现，左、右是否成对出现就可以了\n\n\n##### 代码\n```\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        char[] chars = moves.toCharArray();\n        int left = 0;\n        int up = 0;\n        for(char c : chars){\n           switch(c){\n               case 'L':\n                 left++;\n                 break;\n               case 'R':\n                 left--;\n                 break;\n               case 'U':\n                 up++;\n                 break;\n               case 'D':\n                 up--;\n                 break;\n           }\n        }\n        return left == 0 && up == 0;\n    }\n}\n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/36#issuecomment-1864358380","body":"### 题目 \n\n[1737. 满足三条件之一需改变的最少字符数](https://leetcode.cn/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/)\n\n### 解题思路\n\n#### 思路\n\n1、因为都是小写字母，所以用长度为26的数组统计每个字母出现的次数。\n\n2、满足第三个条件：假设要全转换成某个字符，然后计算a、b中需要转换的次数，取最小次数即可。\n\n3、满足第一个、第二个条件，这俩处理方式一样，就是假定一个字符为a中最小，b中最大，然后获取大于i的所有的在a中修改次数，再获取小于i的所有的再b中的修改次数\n\n4、最后获取最小的次数即可。\n\n\n##### 代码\n```\nclass Solution {\n    public int minCharacters(String a, String b) {\n        // 统计字母出现次数\n        int[] arr = new int[26];\n        int[] brr = new int[26];\n        for(char c : a.toCharArray()){\n           arr[c - 'a'] ++; \n        }\n        for(char c : b.toCharArray()){\n            brr[c - 'a'] ++; \n        }\n\n        // 遍历，看最小转换几次。就是假定当前为需要转换的字母，那么a +b 的长度 - 当前字母出现次数，就是需要转换的次数\n        int result = a.length() + b.length();\n        int total = result;\n        for(int i = 0;i < 26; i++){\n            result = Math.min(result,total - (arr[i] + brr[i]));\n        }\n        return Math.min(result,Math.min(smaller(arr,brr),smaller(brr,arr)));\n    }\n\n    private int smaller(int[] a, int[] b) {\n        int result = Integer.MAX_VALUE;\n        for(int i = 0;i < 25; i++){\n            int total = 0;\n            // 获取a中大于i的\n            for(int j= i+1; j < 26; j++) {\n                total += a[j];\n            }\n            // 获取b中小于i的\n            for(int j= 0; j<=i; j++) {\n                total += b[j];\n            }\n            result = Math.min(result, total);\n        }\n        return result;\n    }\n}\n```\n##### 复杂度分析\n- 时间复杂度：O(a.length + b.length)\n- 空间复杂度：O(26)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/38#issuecomment-1867486829","body":"### 题目 \n\n[69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)\n\n### 解题思路\n\n#### 思路\n\n思路1：\n\n暴力破解法，从1一直向上加，最大值就是int的平方46340.每次平台的值都记录下，如果正好等于x，就直接返回。\n\n思路1：\n\n二分法。使用二分法处理。\n\n\n##### 代码\n```\nclass Solution {\n    public int mySqrt(int x) {\n        if(x == 1) return 1;\n        int a = x/2;\n        // 不会超过int最大值的平方\n        a = Math.min(a,46340);\n        int result = 0;\n        for(int i = 1;i<= a; i++){\n        \tlong z = i*i;\n            if(z <= x){\n              result = i;      \n            }else {\n                return result;\n            }\n        }\n        return result;\n    }\n}\n\nclass Solution {\n    public int mySqrt(int x) {\n        if(x == 1) return 1;\n        int left = 0;\n        int right = x / 2;\n        right = Math.min(right,46340);\n        int result = 0;\n        while(left <= right){\n            int mid = left + (( right - left) >> 1);\n            if((long) mid * mid <= x){\n                result = mid;\n                left = mid + 1;\n            }else{\n                right = mid - 1;\n            }\n        }\n        return result;\n    }\n}\n\n```\n##### 复杂度分析\n- 时间复杂度：O(n/2)\n- 空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/44#issuecomment-1870879070","body":"### 题目 \n\n[1456. 定长子串中元音的最大数目 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)\n\n### 解题思路\n\n#### 思路\n\n思路1：\n\n暴力破解法：一位一位遍历，每一位往后面查k个数，获取这k个数中是否有对应的元音字母数量。运行超时\n\n思路2：\n\n其实，每次遍历的时候已经知道上次遍历出的元音数量，只需要处理当前上一个字母和此次遍历最后一个字母是否为元音即可。上一个为元音就-1，最后一个为元音就+1\n\n\n##### 代码\n```\nclass Solution {\n    public int maxVowels(String s, int k) {\n        char[] chars = s.toCharArray();\n        int max = 0;\n        for(int i = 0;i<chars.length;i++){\n            int nowSize = 0;\n            int jSize = Math.min((i + k),chars.length);\n            for(int j = i;j< jSize; j++){\n                switch(chars[j]){\n                    case 'a':\n                        nowSize++;\n                        break;\n                    case 'e':\n                        nowSize++;\n                        break;\n                    case 'i':\n                        nowSize++;\n                        break;\n                    case 'o':\n                        nowSize++;\n                        break;\n                    case 'u':\n                        nowSize++;\n                        break;\n                    default:\n                        break;\n                }\n            }\n            max = Math.max(nowSize,max);\n        }\n        return max;\n    }\n}\n\nclass Solution {\n    public int maxVowels(String s, int k) {\n        char[] chars = s.toCharArray();\n        int max = 0;\n\n        Set<Character> set = new HashSet<>(){{\n            add('a');add('e');add('i');add('o');add('u');\n        }};\n\n        int maxLen = Math.min(chars.length,k);\n        for(int i = 0;i<maxLen;i++){\n            if(set.contains(chars[i])){\n                max++;\n            }\n        }\n        \n        // 假设第一次为最大值\n        int now = max;\n        for(int i = 1;i<chars.length - k + 1;i++){\n            if(set.contains(chars[i + k - 1])){\n                now++;\n            }\n            if(set.contains(chars[i - 1])){\n                now--;\n            }\n            max = Math.max(max,now);\n        }\n        return max;\n    }\n}\n\n```\n##### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chloe-c11":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1814383488","body":"一开始的思路：没考虑到num = [9,9,9,9,9,9,9,9,9,9], k=1连续的进位的情况\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = -1\n        nxt = 0\n        while k:\n            cur_k = k % 10\n            print(cur_k)\n            cur_num = num[i]\n            cur_ans = cur_k + cur_num\n            if cur_k + cur_num > 9:\n                cur_ans = cur_ans % 10\n                num[i] = cur_ans + nxt\n                nxt = 1\n            else:\n                num[i] = cur_ans + nxt\n                nxt = 0\n            k = k // 10\n            i -= 1\n        if nxt == 1:\n            return [1] + num\n        return num\n```\n\n修改后\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        i = len(num) - 1\n        nxt = 0\n        ans = []\n        while k or nxt != 0 or i >= 0:\n            if k > 0:\n                cur_k = k % 10\n            else:\n                cur_k = 0\n            if i >= 0:\n                cur_num = num[i]\n            else:\n                cur_num = 0\n\n            cur_ans = cur_k + cur_num + nxt\n            if cur_ans > 9:\n                cur_ans = cur_ans - 10\n                ans.append(cur_ans)\n                nxt = 1\n            else:\n                ans.append(cur_ans)\n                nxt = 0\n\n            k = k // 10\n            i -= 1\n        return ans[::-1]\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1815996853","body":"1. 第一个循环用于找到目标字符的位置\n2. 第二个循环用于遍历整个字符串，对于每个字符都需要计算到目标字符的最短距离\n3. 时间复杂度为O(n^2)\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        c_set = set()\n        ans = []\n        # find place\n        for i, ci in enumerate(s):\n            if ci == c:\n                c_set.add(i)\n\n        # loop s, find each distance\n        for i, si in enumerate(s):\n            cur_min = len(s) + 1\n            for j in c_set:\n                cur_min = min(cur_min, abs(i - j))\n            ans.append(cur_min)\n        \n        return ans\n```\n\n优化：左右分别遍历，找最近\n\n第一次找到每个i左边最近的 c\n\n第二次找到每个i右边最近的 c\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [n + 1] * n\n        j = -1\n        for i, si in enumerate(s):\n            if si == c:\n                j = i\n            if j != -1:\n                ans[i] = i - j\n        j = -1\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                j = i\n            if j != -1:\n                ans[i] = min(ans[i], j - i)\n        return ans\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817424105","body":"根据题目要求来写，注意长度是否超过maxsize即可\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.s = []\n        self.maxSize = maxSize\n\n\n    def push(self, x: int) -> None:\n        if len(self.s) < self.maxSize:\n            self.s.append(x)\n\n\n    def pop(self) -> int:\n        if self.s:\n            return self.s.pop()\n        return -1\n\n\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.s) < k:\n            for i in range(len(self.s)):\n                self.s[i] += val\n        else:\n            for i in range(k):\n                self.s[i] += val\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817681635","body":"使用栈，遇到\"]\"的时候进行出栈等操作，其他时候都入栈\n\n先获取字符串的长度，剔除“[”，再获取数字的长度\n\n获得新的字符串后，如果栈里面还有元素 – 加入。否则直接加入答案\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        # 使用栈，遇到\"]\"的时候进行出栈等操作，其他时候都入栈\n        ans = []\n        myStack = []\n        for c in s:\n            if c ==\"]\":\n                # 当遇到'['的时候添加到ans里面\n                cur_str = \"\"\n                while myStack and myStack[-1] != \"[\":\n                    cur_str = myStack.pop() + cur_str\n                # 剔除\"[\"\n                myStack.pop()\n                # 遇到‘[’的时候，获取下一个数字\n                cur_num = myStack.pop()\n                # 如果stack里面还有内容 -- 新的字符串入栈\n                # 否则：加入答案\n                if myStack:\n                    myStack.append(int(cur_num) * cur_str)\n                else:\n                    ans.append(int(cur_num) * cur_str)\n            else:\n                myStack.append(c)\n        ans += myStack\n        return \"\".join(ans)\n```\n\n第一遍思路，但是debug发现当遇到s = \"100[leetcode]\"时有误，发现没考虑完全字符串和数字的转换\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        # 使用栈，遇到\"]\"的时候进行出栈等操作，其他时候都入栈\n        ans = []\n        myStack = []\n        for c in s:\n            if c ==\"]\":\n                # 当遇到'['的时候添加到ans里面\n                cur_str = \"\"\n                while myStack and myStack[-1] != \"[\":\n                    cur_str = myStack.pop() + cur_str\n                # 剔除\"[\"\n                myStack.pop()\n                # 遇到‘[’的时候，获取下一个数字\n                # cur_num = myStack.pop()\n                # 但是数字可能不止一个\n                cur_num = \"\"\n                while myStack and myStack[-1].isdigit():\n                    cur_num = myStack.pop() + cur_num\n                # 如果stack里面还有内容 -- 新的字符串入栈\n                # 否则：加入答案\n                if myStack:\n                    myStack.append(int(cur_num) * cur_str)\n                else:\n                    ans.append(int(cur_num) * cur_str)\n            else:\n                myStack.append(c)\n        ans += myStack\n        return \"\".join(ans)\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818060537","body":"用两个栈和一个元素记录\n\n```python\nclass MyQueue:\n    def __init__(self):\n        # stack1 出\n        # stack2 入\n        # s1[]\n        # s2[1,2]\n        # top 1\n        self.stack1 = []\n        self.stack2 = []\n        self.top = None\n\n    def push(self, x: int) -> None:\n        if not self.stack2:\n            self.top = x\n        self.stack2.append(x)\n\n    def pop(self) -> int:\n        if not self.stack1:\n            while self.stack2:\n                self.stack1.append(self.stack2.pop())\n        return self.stack1.pop()\n\n    def peek(self) -> int:\n        # 返回队列开头的元素\n        # 返回最先入栈的元素\n        # 拿一个top来记录\n        if not self.stack1:\n            return self.top\n        else:\n            return self.stack1[-1]\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1820345067","body":"1. 哈希\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # 拿两个哈希数组来统计，看能不能分组\n        map1 = {}\n        map2 = {}\n        ans = 0\n\n        for i, j in zip(arr, sorted(arr)):\n            if i not in map1:\n                map1[i] = 1\n            else:\n                map1[i] += 1\n            if j not in map2:\n                map2[j] = 1\n            else:\n                map2[j] += 1\n            \n            if map1 == map2: ans += 1\n        return ans\n```\n\n2. 前面一段的最大值一定要小于当前段的最小值 ： 单调栈\n\n```python \nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            # 前面一段的最大值一定要小于当前段的最小值\n            # 可以分段的后一段的最小的数，要比前一段最大的数要大\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: \n                stack.append(num)\n        return len(stack)\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822240532","body":"#### 使用计算长度和反转\n\n全部reverse之后，分成两部分再reverse\n\n1. 翻转整个链表，得到新的链表头节点。\n2. 翻转前半部分链表，得到新的前半部分链表头节点。\n3. 翻转后半部分链表，得到新的后半部分链表头节点。\n4. 找到前半部分链表的末尾，将其指向后半部分链表的头节点，完成链表的拼接。\n5. 返回新的前半部分链表头节点。\n\n时间复杂度为O(n)\n\n空间复杂度为O(1)\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # 特殊条件的判断\n        if not head or not head.next or k == 0:\n            return head\n        \n         # 计算链表长度\n        length = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            length += 1\n\n        # 计算实际需要移动的步数\n        k = k % length\n        if k == 0: \n            return head\n\n        # 翻转整个链表\n        pre = None\n        cur = head\n        while cur:\n            cur.next, pre, cur = pre, cur, cur.next\n\n        # 翻转前半部分链表\n        cur = pre\n        pre = None\n        while k:\n            cur.next, pre, cur = pre, cur, cur.next\n            k -= 1\n        new_start_part = pre\n\n        # 翻转后半部分链表\n        pre = None\n        while cur:\n            cur.next, pre, cur = pre, cur, cur.next\n        \n        # 找到前部分链表的末尾，两部分拼接\n        cur = new_start_part\n        while cur.next:\n            cur = cur.next\n        cur.next = pre\n\n        return new_start_part\n```\n\n\n\n#### 快慢指针\n\n1. 使用快慢指针找到倒数第k个节点的前一个节点。\n2. 移动慢指针和快指针，直到快指针到达链表末尾。\n3. 重新连接链表，将慢指针的下一个节点作为新的头节点，将快指针的下一个节点指向原来的头节点。\n4. 返回新的头节点。\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # 特殊条件的判断\n        if not head or not head.next or k == 0:\n            return head\n        \n        # 计算链表长度\n        length = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            length += 1\n        \n        # 计算实际需要移动的步数\n        k = k % length\n        if k == 0:\n            return head\n        \n        # 找到倒数第k个节点的前一个节点\n        slow = fast = head\n        for _ in range(k):\n            fast = fast.next\n        \n        # 移动slow和fast指针，直到fast指针到达链表末尾\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n        \n        # 重新连接链表\n        new_head = slow.next\n        slow.next = None\n        fast.next = head\n        \n        return new_head\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1823589201","body":"使用dummy，遍历链表，每次取出相邻的两个节点进行交换，直到遍历完整个链表，返回dummy.next\n\n```python \n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # 创建虚拟头节点便于后续的操作\n        dummy = ListNode(0, head)\n\n        # 进行两两reverse\n        pre = dummy\n        \n        while pre.next and pre.next.next:\n            node1, node2 = pre.next, pre.next.next\n            pre.next, node1.next, node2.next = node2, node2.next, node1\n            pre = node1\n        \n        return dummy.next\n\n        \n```\n\n2. 递归\n\n   递归终止条件：链表为空或只有一个节点\n\n   当层递归操作：第一个节点和第二个节点进行交换，进入下一层\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return head\n        first = head\n        second = first.next\n        first.next = self.swapPairs(second.next)\n        second.next = first\n\n        return second\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/10#issuecomment-1825356404","body":"1. 递归 + 快慢指针找中间位置\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        # 特殊条件判断\n        if head is None:\n            return None\n        elif head.next is None:\n            return TreeNode(head.val)\n        \n        # 快慢指针找中间点\n        slow, fast = head, head\n        pre = None\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        root = TreeNode(slow.val)\n        # 拆分链表：左半部分（中间元素之前）和右半部分（从中间元素的下一个节点开始）\n        tmp = pre.next\n        pre.next = None\n        # 递归构建子树\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(tmp.next)\n\n        return root\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/11#issuecomment-1826173244","body":"链表相连 得相交或者none\n\n```python\n首先是两个链表（约定，值相同代表同一节点，0 代表空节点）\nA表：[1, 2, 3, 7, 8, 9]\nB表：[4, 5, 7, 8, 9]\n\n连接两个链表（表与表之间用 0 隔开）\nAB表：[1, 2, 3, 7, 8, 9, 0, 4, 5, 7, 8, 9, 0]\nBA表：[4, 5, 7, 8, 9, 0, 1, 2, 3, 7, 8, 9, 0]\n\n观察连接后的两个表，可以发现相交的部分整齐的排列在末尾，\n只需要逐个比较这两张表的节点，就能找到相交的起始位置。\n\n如果没有相交会如何？会陷入死循环吗？\nA表：[1, 2, 3]\nB表：[4, 5]\n\n连接两个链表（表与表之间用 0 隔开）\nAB表：[1, 2, 3, 0, 4, 5, 0]\nBA表：[4, 5, 0, 1, 2, 3, 0]\n\n观察连接后的两个表，可以发现末尾相交的部分必然为空，\n参照上面的逻辑，返回首个相同的节点，为空是符合题意的。\n\n如果连接两表时，不用 0 隔开，表不相交时，就会陷入死循环。\n\n```\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        p1 = headA\n        p2 = headB\n        while p1 != p2:\n            if p1:\n                p1 = p1.next\n            else:\n                p1 = headB\n            if p2:\n                p2 = p2.next\n            else:\n                p2 = headA\n        return p1\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826444702","body":"快慢指针\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head :\n            return None # No cycle in this case\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n\n                slow = head\n                while slow != fast:\n                    slow = slow.next\n                    fast = fast.next\n                return slow\n                \n        return None\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1827535855","body":"双指针\n\n```python\nclass ListNode:\n    def __init__(self, key, value):\n        self.key = key \n        self.value = value \n        self.prev = None \n        self.next = None \n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        # 键到节点的映射\n        self.dic = dict() \n        # 缓存容量\n        self.capacity = capacity \n        # 哨兵节点\n        self.head = ListNode(0, 0) \n        self.tail = ListNode(-1, -1) \n        # 双指针\n        self.head.next = self.tail \n        self.tail.prev = self.head \n\n    def get(self, key: int) -> int:\n        if key in self.dic:\n            node = self.dic[key] \n            self.removeFromList(node) \n            # 将节点插入到链表头部（因为它刚刚被访问）\n            self.insertIntoHead(node) \n            return node.value \n        else:\n            return -1 \n\n    def put(self, key: int, value: int) -> None:\n        # 类似于get()        \n        if key in self.dic:             \n            node = self.dic[key] \n            self.removeFromList(node)\n            self.insertIntoHead(node) \n            node.value = value        \n        # 如果缓存已满\n        else: \n            if len(self.dic) >= self.capacity: \n                # 从列表尾部删除最近最少使用的节点（同时从字典中删除）\n                self.removeFromTail() \n            node = ListNode(key,value) \n            self.dic[key] = node \n            # 将新节点插入到链表头部\n            self.insertIntoHead(node) \n            \n\t# 从链表中删除节点\n    def removeFromList(self, node):\n        node.prev.next = node.next \n        node.next.prev = node.prev\n    \n    def insertIntoHead(self, node):\n        headNext = self.head.next \n        self.head.next = node \n        node.prev = self.head \n        node.next = headNext \n        headNext.prev = node\n    \n    def removeFromTail(self):\n        if len(self.dic) == 0: return\n        tail_node = self.tail.prev\n        del self.dic[tail_node.key]\n        self.removeFromList(tail_node)\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1828706457","body":"dfs\n\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root: return 0\n        left_h = self.maxDepth(root.left)\n        right_h = self.maxDepth(root.right)\n        return max(left_h, right_h) + 1\n```\n\nbfs\n\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root: return 0\n        queue = deque([root])\n        ans = 0\n        while queue:\n            cur_node = len(queue)\n            for i in range(cur_node):\n                node = queue.popleft()\n                if node.left: \n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            ans += 1\n        return ans\n                \n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831434441","body":"Python3\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p or not q:\n            return p == q\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1833034831","body":"```\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        def dfs(root, i):\r\n            if not root: return 0\r\n            temp = i * 10 + root.val\r\n            if not root.left and not root.right: return temp\r\n            return dfs(root.left, temp) + dfs(root.right, temp)\r\n        return dfs(root, 0)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/17#issuecomment-1835371041","body":"\n# Method1\n从左到右按层BFS，记录每一层的第一个的值\n\n```Python3 []\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        # 层次遍历 method1\n        from collections import deque\n        ans = 0\n        queue = deque([root])\n        while queue:\n            cur_size = len(queue)\n            res = queue[0].val\n            while cur_size > 0:\n                cur = queue.popleft()\n                if cur.left:\n                    queue.append(cur.left)\n                if cur.right:\n                    queue.append(cur.right)\n                cur_size -= 1\n        return res\n```\n  \n\n# Method2\n\n层次遍历 method2 从上到下 从右到左 最后一个就是\n\n```Python3 []\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        from collections import deque\n        queue = deque([root])\n        while queue:\n            cur = queue.popleft()\n            if cur.right:\n                queue.append(cur.right)\n            if cur.left:\n                queue.append(cur.left)\n            \n        return cur.val\n```\n  \n# Method3\n递归遍历树的每个节点，并在遍历过程中更新最底层最左边的节点值和长度\n```Python3 []\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        # 初始化长度和答案值为根节点的值\n        self.length = 0\n        self.ans = root.val\n        # 调用辅助函数来寻找最底层最左边的节点\n        self.helper(root, 1)\n        return self.ans\n\n    # 辅助函数用来遍历树\n    def helper(self, root, length):\n        # 如果节点为空，返回\n        if not root:\n            return\n        # 如果当前长度大于已知的长度，更新答案值和长度\n        if length > self.length:\n            self.ans = root.val\n            self.length = length\n        # 递归调用左右子节点，并将长度加1\n        self.helper(root.left, length + 1)\n        self.helper(root.right, length + 1)\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1837143295","body":"11\n\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n    def serialize(self, root):\n        if not root: return \"[]\"\n        queue = collections.deque()\n        queue.append(root)\n        res = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                res.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else: \n                res.append(\"null\")\n        print(res)\n        return '[' + ','.join(res) + ']'\n\n    def deserialize(self, data):\n        print(data)\n        if data == \"[]\": return\n        vals, i = data[1:-1].split(','), 1\n        print(vals)\n        root = TreeNode(int(vals[0]))\n        queue = collections.deque()\n        queue.append(root)\n        while queue:\n            node = queue.popleft()\n            if vals[i] != \"null\":\n                node.left = TreeNode(int(vals[i]))\n                queue.append(node.left)\n            i += 1\n            if vals[i] != \"null\":\n                node.right = TreeNode(int(vals[i]))\n                queue.append(node.right)\n            i += 1\n        return root\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/19#issuecomment-1837381512","body":"1. dfs\n\n最先开始，只注意了按列排序，忘记了按照节点深度排序节点值\n\n```python \n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return []\n\n        self.ans = []  # 存储节点坐标的数组\n\n        def dfs(root, left, right):\n            if not root:\n                return\n            self.ans.append((left, right, root.val))  # 存储节点坐标和值\n            dfs(root.left, left + 1, right - 1)  # 左子树向左下方移动\n            dfs(root.right, left + 1, right + 1)  # 右子树向右下方移动\n\n        dfs(root, 0, 0)  # 开始深度优先搜索\n        self.ans.sort()  # 按照题目要求对节点坐标进行排序\n\n        mymap = {}  # 使用字典存储相同列的节点值\n        for left, right, val in self.ans:\n            if right not in mymap:\n                mymap[right] = [(left, val)]  # 如果该列不存在，则创建并添加节点值\n            else:\n                mymap[right].append((left, val))  # 如果该列已存在，则添加节点值\n\n        ans = []\n        for key in sorted(mymap.keys()):  # 按列顺序遍历字典\n            temp = [val for left, val in sorted(mymap[key])]  # 按照节点深度排序节点值\n            ans.append(temp)  # 添加到最终结果\n\n        return ans\n\n\n```\n\n2. bfs\n\n```python \n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom collections import deque\n\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return []\n\n        nodes = {}  # 使用普通字典管理节点列值\n        queue = deque([(root, 0, 0)])  # 存储节点、列、行信息的队列\n\n        while queue:\n            node, col, row = queue.popleft()\n            if col in nodes:\n                nodes[col].append((row, node.val))  # 如果列已存在于字典中，则添加节点值\n            else:\n                nodes[col] = [(row, node.val)]  # 如果列不存在，则创建新的列表并添加节点值\n            if node.left:\n                queue.append((node.left, col - 1, row + 1))  # 左子树向左下方移动\n            if node.right:\n                queue.append((node.right, col + 1, row + 1))  # 右子树向右下方移动\n\n        cols = sorted(nodes.keys())\n        result = []\n        for col in cols:\n            column = []\n            for row, val in sorted(nodes[col]):\n                column.append(val)  # 添加节点值到列中\n            result.append(column)\n\n        return result\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1837663651","body":"哈希表\n```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        myMap = {}\n        for i in range(len(nums)):\n            if target - nums[i] not in myMap:\n                myMap[nums[i]] = i\n            else:\n                return [myMap[target - nums[i]], i]\n        return [-1, -1]\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/21#issuecomment-1839806332","body":"1. 统计每个元素在列表中出现的次数，使用字典 `count` 记录每个元素及其出现次数。\n2. 使用最小堆 `min_heap` 找出出现频率最高的 `k` 个元素。将每个元素及其出现次数作为元组 `(count[i], i)` 加入最小堆中，如果堆的大小超过了 `k`，则从堆中移除最小的元素，保持堆的大小为 `k`。\n3. 将最小堆中剩余的元素添加到结果列表 `ans` 中，并返回该列表。\n\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        import heapq\n        count = {}\n        for num in nums:\n            count[num] = count.get(num, 0) + 1\n            \n        min_heap = []\n        for i in count:\n            heapq.heappush(min_heap, (count[i], i))\n            if len(min_heap) > k:\n                heapq.heappop(min_heap)\n        \n        ans = []\n        for num in min_heap:\n            ans.append(num[1])\n        return ans\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/22#issuecomment-1841949824","body":"1. 给定 i 的情况下，与 i 距离相等的 (j,k) 组合个数为多少\n\n2. 对于每个给定的i，对其含有的组合数累加计数：因为要考虑顺序 –>\n\n   从n个点任选2个点之后还要全排列\n\n$$\nA_n^2=C_n^2\\cdot A_2^2=n(n-1)\n$$\n\n\n\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        def get_dis(x,y):\n            return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\n        count = 0\n        n = len(points)\n\n        for i in range(n):\n            # 给定 i 的情况下，与 i 距离相等的 (j,k) 组合个数为多少\n            distances = {}\n    \n            for j in range(n):\n                if i != j:\n                    cur_dis = get_dis(points[i], points[j])\n                    distances[cur_dis] = distances.get(cur_dis, 0) + 1\n            \n            # 累加计数\n            for dist in distances:\n                count += distances[dist] * (distances[dist] - 1)\n        \n        return count\n\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1843999231","body":"滑动窗口\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        left, right = 0, 0\n        s_map = {}\n        ans = 0\n        while right < len(s):\n            c = s[right]\n            if c not in s_map:\n                s_map[c] = 1\n            else:\n                s_map[c] += 1\n            while s_map[c] > 1:\n                \ts_map[s[left]] -=  1              \t\t\t\t\n                \tleft += 1\n            right += 1\n            ans = max(right - left, ans)\n        return ans\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/24#issuecomment-1847206628","body":"创建了一个 `word_count` 字典来记录每个单词的出现次数。\n\n检查字符串 `s` 中是否存在满足特定条件的子串：遍历字符串 s 的所有可能起始位置，并检查以该位置为起点的window_len内的子串\n\n模拟单词长度逐个提取单词，检查其在 `word_count` 中是否存在。\n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n        \n        word_count = {}  # 统计单词出现次数的字典\n        for word in words:\n            if word in word_count:\n                word_count[word] += 1\n            else:\n                word_count[word] = 1\n        \n        word_len = len(words[0])  # 单词长度\n        window_len = word_len * len(words)  # 窗口长度\n        res = []  # 结果列表\n        \n        for i in range(len(s) - window_len + 1):\n            substring = s[i:i + window_len]  # 获取当前窗口的子串\n            found_words = {}  # 记录当前窗口内单词出现次数的字典\n            j = 0\n            \n            while j < window_len:\n                word = substring[j:j + word_len]  # 获取当前单词\n                if word in word_count:  # 如果单词在给定的单词列表中\n                    if word in found_words:\n                        found_words[word] += 1\n                    else:\n                        found_words[word] = 1\n                        \n                    if found_words[word] > word_count[word]:  # 如果当前单词出现次数超过期望次数\n                        break\n                else:\n                    break\n                \n                j += word_len\n            \n            if found_words == word_count:  # 如果当前窗口内单词出现次数符合期望\n                res.append(i)\n        \n        return res\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/25#issuecomment-1848411649","body":"```\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        # 去掉的是（最短子数组）\n        # 1. 前缀和\n        # 2. 同余\n        # sum_all所有元素之和，del_all去掉元素之和 -->  sum_all % p == del_all % p\n\n        target = sum(nums) % p  # 获取目标余数\n        if target == 0:\n            return 0  # 如果整个数组的和能被 p 整除，不需要移除任何元素\n\n        prefix_sum = 0\n        prefix_sum_mod = {0: -1}  # 存储前缀和的余数对应的最早出现的索引\n        min_length = len(nums)\n        current_sum_mod = 0\n\n        for i, num in enumerate(nums):\n            prefix_sum += num\n            current_sum_mod = prefix_sum % p  # 当前前缀和的余数\n            target_mod = (current_sum_mod - target) % p  # 计算当前余数所需的补数\n\n            if target_mod in prefix_sum_mod:\n                min_length = min(min_length, i - prefix_sum_mod[target_mod])\n\n            prefix_sum_mod[current_sum_mod] = i\n\n        return min_length if min_length < len(nums) else -1 if min_length == len(nums) else 0\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/26#issuecomment-1848837847","body":"```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849272290","body":"双指针\n遇到新的，就按照顺序拍，如果是遇到过的，就忽略\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        left, right = 0, 1\n        while right < len(nums):\n            if nums[left] != nums[right]:\n                left += 1\n                nums[left] = nums[right]\n            right += 1\n        return left + 1\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1851194957","body":"二分\n```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        # 找到第一个>= target的数字的位置\n        if target > nums[-1]:\n            return len(nums)\n            \n        left, right = 0, len(nums) - 1\n        while left + 1 < right:\n            mid = (left + right) // 2\n            if nums[mid] <= target:\n                left = mid\n            else:\n                right = mid\n        if nums[left] >= target:\n            return left\n        return right\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/29#issuecomment-1853846709","body":"双向队列\n```\n        q, res = [], []\n        for i in range(len(nums)):\n            # 队列为空，直接入队\n            if not q:\n                q.append(i)\n            else:\n                # 队列中，队首的索引在滑动窗口之外\n                if i == q[0] + k:\n                    q.pop(0)\n                # 将小于当前队列新增元素的值的元素都弹出\n                while q and nums[q[-1]] < nums[i]:\n                    q.pop()\n                q.append(i)\n            # 队首为最大值\n            res.append(nums[q[0]])\n        return res[k-1:]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/30#issuecomment-1855793836","body":"# 出度入度\n有向图 -- answer：出度为0，入度为 N - 1\n```\ndef findJudge(N, trust):\n    # 初始化每个人的出度和入度为0\n    out_degree = [0] * (N + 1)\n    in_degree = [0] * (N + 1)\n\n    # 统计每个人的出度和入度\n    for a, b in trust:\n        out_degree[a] += 1\n        in_degree[b] += 1\n\n    # 找到出度为0且入度为N-1的人，即法官\n    for i in range(1, N + 1):\n        if out_degree[i] == 0 and in_degree[i] == N - 1:\n            return i\n\n    return -1  # 没有满足条件的法官\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/31#issuecomment-1858804141","body":"```\nclass Solution:\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        \n        # Constant defined for color drawing to person\n        BLUE, GREEN = 1, -1\n        # -------------------------------------\n        \n        def draw( person_id, color ):\n            \n            # Draw person_id as color\n            color_of[person_id] = color\n            \n            # Draw the_other, with opposite color, in dislike table of current person_id\n            for the_other in dislike_table[ person_id ]:\n   \n                if color_of[the_other] == color:\n                    # the_other has the same color of current person_id\n                    # Reject due to breaking the relationship of dislike\n                    return False\n\n                if (not color_of[the_other]) and (not draw( the_other, -color)):\n                    # Other people can not be colored with two different colors. \n\t\t\t\t\t# Therefore, it is impossible to keep dis-like relationship with bipartition.\n                    return False\n                    \n            return True\n        \n        \n        # ------------------------------------------------\n\t\t\n\t\t\n        if N == 1 or not dislikes:\n            # Quick response for simple cases\n            return True\n        \n        # each person maintain a list of dislike\n        dislike_table = defaultdict( list )\n        \n        # key: person ID\n        # value: color of person\n        color_of = defaultdict(int)\n        \n        for p1, p2 in dislikes:\n            \n            # P1 dislikes P2\n            # P1 and P2 should be painted with two different color\n            dislike_table[p1].append( p2 )\n            dislike_table[p2].append( p1 )\n            \n        \n        # Try to draw dislike pair with different colors in DFS\n        for person_id in range(1, N+1):\n            \n            if (not color_of[person_id])  and (not draw( person_id, BLUE)):\n                # Other people can not be colored with two different colors. \n\t\t\t\t# Therefore, it is impossible to keep dis-like relationship with bipartition.\n                return False \n        \n        return True\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/32#issuecomment-1858803685","body":"```\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        groupId = m\n        for i in range(n):\n            if group[i] == -1:\n                group[i] = groupId\n                groupId += 1\n        \n        itemGraph = defaultdict(list)\n        itemIndegree = [0] * n\n        groupGraph = defaultdict(list)  # Initialize groupGraph\n        groupIndegree = [0] * groupId\n        \n        for i in range(n):\n            for prev in beforeItems[i]:\n                itemGraph[prev].append(i)\n                itemIndegree[i] += 1\n                if group[i] != group[prev]:\n                    groupGraph[group[prev]].append(group[i])\n                    groupIndegree[group[i]] += 1\n        \n        itemOrder = self.topologicalSort(itemGraph, itemIndegree)\n        groupOrder = self.topologicalSort(groupGraph, groupIndegree)\n        \n        if not itemOrder or not groupOrder:\n            return []\n        \n        orderedGroups = defaultdict(list)\n        for item in itemOrder:\n            orderedGroups[group[item]].append(item)\n        \n        answerList = []\n        for groupIndex in groupOrder:\n            answerList.extend(orderedGroups[groupIndex])\n        \n        return answerList\n    \n    def topologicalSort(self, graph: Dict[int, List[int]], indegree: List[int]) -> List[int]:\n        visited = []\n        stk = []\n        for i in range(len(indegree)):\n            if indegree[i] == 0:\n                stk.append(i)\n        \n        while stk:\n            curr = stk.pop()\n            visited.append(curr)\n            \n            for n in graph[curr]:\n                indegree[n] -= 1\n                if indegree[n] == 0:\n                    stk.append(n)\n        \n        return visited if len(visited) == len(graph) else []\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/33#issuecomment-1859057307","body":"```\nfrom collections import Counter\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        # 统计\n        # ans_U, ans_D, ans_R, ans_L = 0, 0, 0,0\n        # for i in moves:\n        #     if i == 'U':\n        #         ans_U += 1\n        #     if i == 'D':\n        #         ans_D += 1\n        #     if i == 'L':\n        #         ans_L += 1\n        #     if i== 'R':\n        #         ans_R += 1\n        # return ans_U == ans_D and ans_L == ans_R\n\n\n        # 使用python的用法统计1\n        # return moves.count('U')==moves.count('D') and moves.count('L')==moves.count('R')\n\n        # 使用python的用法统计2\n        # c = Counter(moves)\n        # return c['U']==c['D'] and c['L']==c['R']\n\n        # x,y 方向\n        x = 0 # 记录当前位置\n        y = 0\n        for i in range(len(moves)):\n            if (moves[i] == 'U'):\n                y += 1\n            if (moves[i] == 'D'):\n                y -= 1\n            if (moves[i] == 'L'):\n                x += 1\n            if (moves[i] == 'R'):\n                x -= 1\n        return x == 0 and y == 0\n\n\n\n\n\n\n\n```","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/41#issuecomment-1868846127","body":"```\nclass Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n \n        '''\n        1. 对于每个房屋，要么用前面的暖气，要么用后面的，二者取近的，得到距离；\n        2. 对于所有的房屋，选择最大的上述距离。\n\n        '''\n        houses.sort()\n        heaters.sort()\n        \n        # 用于检查在半径为 r 的情况下，是否可以将所有房屋加热\n        # 遍历了每个房屋和供暖器的位置，并检查它们之间的距离是否小于或等于 r\n        # 如果所有房屋都可以被加热，则返回 True；否则返回 False。\n        def check(houses, heaters, r):\n            index1, index2 = 0, 0\n            while index1 < len(houses) and index2 < len(heaters):\n                if houses[index1] >= heaters[index2] - r and houses[index1] <= heaters[index2] + r:\n                    index1 += 1\n                else:\n                    index2 += 1\n            return index1 >= len(houses)\n        \n        # 使用二分：检查是否可以使用半径为 mid 的供暖器加热所有房屋。如果是，则将 right 设置为 mid；否则将 left 设置为 mid。\n        left, right = 0, max(houses[-1], heaters[-1])\n        while left + 1 < right:\n            mid = (left + right) // 2\n            if check(houses, heaters, mid):\n                right = mid\n            else:\n                left = mid\n        if check(houses, heaters, left):\n            return left\n        else:\n            return right\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/42#issuecomment-1869640470","body":"\n```\ndef smallestDistancePair(nums, k):\n    # Return: Is there k or more pairs with distance <= guess? i.e. are\n    # there enough?\n    def possible(guess_dist):\n        i = count = 0\n        j = 1\n        # Notice that we never decrement j or i.\n        while i < len(nums):\n            # If the distance calculated from j-i is less than the guess,\n            # increase the window on `j` side.\n            while (j < len(nums)) and ((nums[j] - nums[i]) <= guess_dist):\n                j += 1\n            # Count all places between j and i\n            count += j - i - 1\n            i += 1\n        return count >= k\n\n    nums.sort()\n    lo = 0\n    hi = nums[-1] - nums[0]\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        # If `mid` produced `k` or more results we know it's the upper bound.\n        if possible(mid):\n            # We don't set to `mid - 1` because we found a number of distances\n            # bigger than *or equal* to `k`. If this `mid` ends up being\n            # actually equal to `k` then it's a correct guess, so let's leave it within\n            # the guess space.\n            hi = mid\n        # If `mid` did not produce enouh results, let's increase  the guess\n        # space and try a higher number.\n        else:\n            lo = mid + 1\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/43#issuecomment-1869662603","body":"```\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        res = 0\n        n = len(grid)\n        heap = [(grid[0][0],0,0)]\n        visited = set([(0,0)])\n        \n        while heap:\n            height,x,y = heapq.heappop(heap)\n            res = max(res,height)\n            if x == n-1 and y == n-1:\n                return res\n            \n            for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)]:\n                new_x,new_y = x + dx,y + dy\n                if 0 <= new_x < n and 0 <= new_y < n and (new_x,new_y) not in visited:\n                    visited.add((new_x,new_y))\n                    heapq.heappush(heap,(grid[new_x][new_y],new_x,new_y))\n        \n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/44#issuecomment-1870748854","body":"```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        my_set = set([\"a\",\"e\",\"i\",\"o\",\"u\"])\n        count = 0\n        # count vowels in first windows\n        for i in range(k):\n            if s[i] in my_set:\n                count += 1\n        res = count\n        for r in range(k, len(s)):\n            if s[r] in my_set:\n                count += 1\n            if s[r-k] in my_set:\n                count -= 1\n            res = max(res, count)\n        return res\n\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/46#issuecomment-1872335216","body":"```\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        # 1. 构建 p_map\n        p_map = {}\n        for i in range(len(p)):\n            if p[i] not in p_map:\n                p_map[p[i]] = 1\n            else:\n                p_map[p[i]] += 1\n        \n        # 2. sliding window\n        left, right = 0, 0\n        continueCount = 0\n        ans = []\n        while right < len(s):\n            c = s[right]\n            if c in p_map:\n                p_map[c] -= 1\n                if p_map[c] == 0:\n                    continueCount += 1\n            right += 1\n\n            if continueCount == len(p):\n                ans.append(left)\n\n            # 移动左指针 left，并更新 p_map 中对应字符的计数器\n            if right - left >= len(p):\n                c = s[left]\n                if c in p_map:\n                    p_map[c] += 1\n                    if p_map[c] == 1:\n                        continueCount -= 1\n            \n                left += 1\n        return ans\n       \n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/48#issuecomment-1873068453","body":"1\n\n```\ndef min_operations(nums, target):\n    n = len(nums)\n    left, right = 0, 0\n    current_sum = 0\n    min_operations = float('inf')\n\n    while right < n:\n        current_sum += nums[right]\n\n        while current_sum >= target:\n            min_operations = min(min_operations, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n\n        right += 1\n\n    return min_operations if min_operations != float('inf') else -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/49#issuecomment-1873460115","body":"```\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        \"\"\"\n        1. for h in range(12) for m in range(60): 这两个循环迭代小时和分钟的可能取值，分别在 [0, 12) 和 [0, 60) 的范围内。\n        2. bin(h) + bin(m): 使用bin函数将小时和分钟转换为二进制表示，并将它们连接在一起。例如，如果小时为3，分钟为25，那么这一步会得到字符串'0b11' + '0b110'。\n        3. (bin(h) + bin(m)).count('1'): 统计二进制表示中字符'1'的个数，即亮灯的数量。\n        4. if (bin(h) + bin(m)).count('1') == turnedOn: 检查亮灯的数量是否等于给定的 turnedOn 值。\n        5. ['%d:%02d' % (h, m) for h in range(12) for m in range(60) if (bin(h) + bin(m)).count('1') == turnedOn]: 对于满足条件的小时和分钟组合，将其格式化为字符串，以'%d:%02d'的形式表示小时和分钟，然后将这些字符串放入列表中。\n        \"\"\"\n        return ['%d:%02d' % (h, m)\n                for h in range(12) for m in range(60)\n                if (bin(h) + bin(m)).count('1') == turnedOn]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/50#issuecomment-1874801395","body":"```\nclass Solution:\n    # method1:基本的回溯的思想\n    def __init__(self):\n        self.count = 0\n\n    def totalNQueens(self, n: int) -> int:\n        board = [[\".\"] * n for _ in range(n)]\n        self.backtrack(board, 0)\n        return self.count\n\n    def backtrack(self, board: List[List[str]], row: int) -> None:\n        if row == len(board):\n            self.count += 1\n            return\n\n        n = len(board[row])\n        for col in range(n):\n            if not self.isValid(board, row, col):\n                continue\n\n            board[row][col] = \"Q\"\n            self.backtrack(board, row + 1)\n            board[row][col] = \".\"\n\n    def isValid(self, board: List[List[str]], row: int, col: int) -> bool:\n        # 为什么不检查左下角，右下角和下方的格子，只检查了左上角，右上角和上方的格子呢？\n        # 因为皇后是一行一行从上往下放的，所以左下方，右下方和正下方不用检查（还没放皇后）；因为一行只会放一个皇后，所以每行不用检查。也就是最后只用检查上面，左上，右上三个方向。\n        n = len(board)\n        # 检查列是否有皇后冲突\n        for i in range(n):\n            if board[i][col] == \"Q\":\n                return False\n\n        # 检查右上方是否有皇后冲突\n        r, c = row - 1, col + 1\n        while r >= 0 and c < n:\n            if board[r][c] == \"Q\":\n                return False\n            r -= 1\n            c += 1\n\n        # 检查左上方是否有皇后冲突\n        r, c = row - 1, col - 1\n        while r >= 0 and c >= 0:\n            if board[r][c] == \"Q\":\n                return False\n            r -= 1\n            c -= 1\n\n        return True\n\n        ## method2: DFS\n    # def totalNQueens(self, n: int) -> int:\n# 采用了数组来存储皇后的位置信息，而不是直接在二维数组中修改\n# 三个数组 queens、dif_xy、dif_sum 来分别记录皇后所在的列、左上到右下的对角线以及右上到左下的对角线\n        # def dfs(queens, dif_xy, dif_sum):\n        #     nonlocal ans\n        #     p = len(queens)\n        #     if n == p:\n        #         ans += 1\n        #         return\n        #     for i in range(n):\n        #         if i not in queens and i + p not in dif_sum and p - i not in dif_xy:\n        #             dfs(queens + [i], dif_xy + [p - i], dif_sum + [p + i])\n        \n        # ans = 0\n        # dfs([],[],[])\n        # return ans\n\n\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/54#issuecomment-1876197422","body":"```\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        if not grid: return 0\n\n        def dfs(i, j):\n            if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0:\n               return 0\n            grid[i][j] = 0\n            count = 1\n            for x, y in [(1,0),(-1,0),(0,1),(0,-1)]:\n                count += dfs(i+x, j+y) \n            return count\n\n        ans = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    ans = max(ans, dfs(i, j) )\n\n        return ans\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/56#issuecomment-1879728936","body":"```\nclass Solution:\n    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:\n\n        from collections import deque\n\n        n = len(status)  # 盒子的总数\n        ans = 0  # 最终结果，即能够获得的最大糖果数\n        has_box = [False] * n  # 记录每个盒子是否存在\n        used = [False] * n  # 记录每个盒子是否已经被使用\n        queue = deque()  # 使用队列进行BFS\n\n        # 初始化队列和相关变量\n        for box in initialBoxes:\n            has_box[box] = True  # 标记这个盒子存在\n            if status[box]:  # 如果这个盒子是可打开的\n                queue.append(box)  # 将可打开的盒子加入队列\n                used[box] = True  # 标记这个盒子已经被使用\n                ans += candies[box]  # 将这个盒子内的糖果数加入结果\n\n        # 开始BFS\n        while queue:\n            box = queue.popleft()  # 取出队列中的一个盒子\n\n            # 遍历这个盒子所对应的钥匙，更新盒子的状态\n            for key in keys[box]:\n                status[key] = 1  # 更新盒子的状态为可打开\n                if not used[key] and has_box[key]:\n                    queue.append(key)  # 如果这个盒子未被使用且存在，将其加入队列\n                    used[key] = True  # 标记这个盒子已经被使用\n                    ans += candies[key]  # 将这个盒子内的糖果数加入结果\n\n            # 遍历这个盒子内包含的盒子，更新盒子的状态\n            for sub_box in containedBoxes[box]:\n                has_box[sub_box] = True  # 标记这个盒子存在\n                if not used[sub_box] and status[sub_box]:\n                    queue.append(sub_box)  # 如果这个盒子未被使用且状态可打开，将其加入队列\n                    used[sub_box] = True  # 标记这个盒子已经被使用\n                    ans += candies[sub_box]  # 将这个盒子内的糖果数加入结果\n\n        return ans  # 返回最终的结果\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/57#issuecomment-1879921300","body":"```\ndic = {}\nqu = deque([(root, 0)])\nwhile qu:\n    node, pos = qu.pop()\n    if pos not in dic:\n        dic[pos] = node.val\n\n    if node.left:\n        qu.appendleft((node.left, pos-1))\n\n    if node.right:\n        qu.appendleft((node.right, pos+1))\n\narr = list(dic.items())\narr.sort()\n\nans = []\n\nfor i in range(len(arr)):\n    ans.append(arr[i][1])\nreturn ans\n```\nTc: O(N)\nSC: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/58#issuecomment-1880118077","body":"```\nclass Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        n = len(cost)\n        dp = [0] * (n+1)\n        dp[0], dp[1] = 0, 0\n        for i in range(2, n+1):\n            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])\n        return dp[n]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/59#issuecomment-1882365714","body":"```\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        # max(f(x-1), f(x-2) + nums[x] )\n        n = len(nums)\n        if n == 1: return nums[-1]\n        if n == 2: return max(nums[0], nums[1])\n        dp = [0] * n\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n        for i in range(2, n):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n        return max(dp[-1],dp[-2])\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/60#issuecomment-1883681563","body":"```\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        # 定义状态数组\n        # dp[i][0] 表示以 nums[i] 结尾的最长递增子序列的长度\n        # dp[i][1] 表示以 nums[i] 结尾的最长递增子序列的个数\n        dp = [[1, 1] for _ in range(n)]\n        max_length = 1  # 最长递增子序列的长度\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    if dp[j][0] + 1 > dp[i][0]:  # 如果长度更长，则更新\n                        dp[i][0] = dp[j][0] + 1\n                        dp[i][1] = dp[j][1]\n                    elif dp[j][0] + 1 == dp[i][0]:  # 如果长度相等，则累加个数\n                        dp[i][1] += dp[j][1]\n            max_length = max(max_length, dp[i][0])  # 更新最长递增子序列长度\n        res = 0\n        for i in range(n):\n            if dp[i][0] == max_length:  # 如果长度等于最长递增子序列长度，则累加个数\n                res += dp[i][1]\n        return res\n\n\n\n\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/62#issuecomment-1889502322","body":"```\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1] * n for _ in range(m)]\n        for c in range(1, m):\n            for r in range(1, n):\n                dp[c][r] = dp[c-1][r] + dp[c][r-1]\n        return dp[-1][-1]\n\n        # 因为只和左边和上面的有关，用一维数组记录上一行的值，动态转移方程更新当前行的值\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n\n        # 优化空间复杂度\n        # if m > n:\n        #     m, n = n, m\n        # dp = [1] * m\n        # for i in range(1, n):\n        #     for j in range(1, m):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/63#issuecomment-1889794463","body":"```\nclass Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n\n        # # dfs : 核心 -- 枚举 -- 超时\n        directions = [(2,1), (2,-1), (1,2),(1,-2),(-2,1), (-2,-1), (-1,2),(-1,-2)]\n        # # 棋盘大小n*n, 走k步, 起始位置(row, col)\n        # # 在棋盘里面的结果1, 不在0\n        # def dfs(row, col, count):\n        #     # terminal1 : 走出棋盘 -- 结束循环 -- 0\n        #     if row < 0 or row > n - 1 or col < 0 or col > n-1: return 0\n        #     # terminal2: 走满k步，结束循环 -- 1\n        #     if count == 0:\n        #         return 1\n        #     # current steps： range 每个位置\n        #     res = 0\n        #     for di, dj in directions:\n        #         coli, rowi = col + di, row + dj\n        #         res += dfs(rowi, coli, count - 1)\n        #     return res/8\n        \n        # return dfs(row, column, k)\n\n        # 动态规划\n        dp = [[0 for i in range(n)] for j in range(n)]\n        dp[row][column] = 1\n        directions = [(1, 2), (1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1), (-1, 2), (-1, -2)]\n        for _ in range(k):\n            new_dp = [[0 for i in range(n)] for j in range(n)]\n            for i in range(n):\n                for j in range(n):\n                    for d in directions:\n                        x, y = i + d[0], j + d[1]\n                        if x < 0 or x >= n or y < 0 or y >= n:\n                            continue\n                        new_dp[i][j] += dp[x][y]\n            dp = new_dp\n        return sum(map(sum, dp)) / float(8 ** k)\n\n\n\n\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"verkru":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1814398968","body":"### 初始可执行代码：\n\n```js\n/*\n * @lc app=leetcode.cn id=989 lang=javascript\n *\n * [989] 数组形式的整数加法\n */\n\n// @lc code=start\n/**\n * @param {number[]} A\n * @param {number} K\n * @return {number[]}\n */\nvar addToArrayForm = function (A, K) {\n\n    // 设置必要参数\n    let res = []    // 返回结果\n    let KVal = K\n    let KList = []  // K 的数字数组\n    let carry = 0\n\n\n    // 1，将数字截取成数字数组\n    while (KVal > 0) {\n        KList = [Math.floor(KVal % 10), ...KList]\n        KVal = Math.floor(KVal / 10)\n    }\n\n    // 2，判断 A 与 KList 的长度大小，长度小的末尾不足补零\n    let judgeNum = A.length - KList.length\n    let zeroList = new Array(Math.abs(judgeNum)).fill(0)\n    if (judgeNum > 0) {\n        KList = [...zeroList, ...KList]\n    } else {\n        A = [...zeroList, ...A]\n    }\n\n    // 3，对位循环并输出\n    for (let i = A.length - 1; i >= 0; i--) {\n        \n        // 判断进位\n        let resSingle = A[i] + KList[i] + carry\n        let resVal = Math.floor(resSingle % 10)\n        carry = Math.floor(resSingle / 10)\n        res = [resVal, ...res]\n    }\n\n    // 4，判断最后一次进位\n    if(carry > 0) res = [carry, ...res]\n\n    return res\n};\n// @lc code=end\n```\n\n### 优化后：\n\n```js\n/*\n * @lc app=leetcode.cn id=989 lang=javascript\n *\n * [989] 数组形式的整数加法\n */\n\n// @lc code=start\n/**\n * @param {number[]} A\n * @param {number} K\n * @return {number[]}\n */\nvar addToArrayForm = function (A, K) {\n\n    // 设置必备参数\n    let i = A.length\n    let res = []    // 输出结果\n    let KVal = K\n\n    // 1，循环 A 数组，以 A 数组的每个元素都为个位为标准，对 K 进行位数处理，并加和\n    while (--i >= 0 || KVal > 0) {\n        if(i >= 0) KVal += A[i]  // 最后一次加和的进位处理\n        res.push(Math.floor(KVal % 10))\n        KVal = Math.floor(KVal / 10)    // 由于要配合与数组中的个位数进行加和，需要将 KVal 降位处理\n    }\n\n    // 2,将完成的数组翻转后输出\n    return res.reverse()\n};\n// @lc code=end\n```\n空间复杂度：这个函数的空间复杂度是O(n)，其中n是数组A的长度。这是因为函数中创建了一个与A长度相同的数组res来存储结果。\n\n时间复杂度：这个函数的时间复杂度也是O(n)，其中n是数组A的长度。这是因为在while循环中，会遍历数组A的每个元素一次，同时对K进行相应的处理。因此，总的执行次数与数组A的长度相同。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1816681058","body":"1. 使用两个指针`prev`和`i`来跟踪最近的目标字符的位置\n2. 第一次遍历中，从左到右计算每个字符到目标字符的距离，并将其存储在`result`数组中\n3. 在第二次遍历中，从右到左计算每个字符到目标字符的距离，并将其与之前计算的距离取最小值\n\n```js\n/*\n * @lc app=leetcode.cn id=821 lang=javascript\n *\n * [821] 字符的最短距离\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n  const n = s.length;\n  const result = new Array(n).fill(0);\n\n  let prev = -Infinity;\n  for (let i = 0; i < n; i++) {\n    if (s[i] === c) {\n      prev = i;\n    }\n    result[i] = i - prev;\n  }\n\n  prev = Infinity;\n  for (let i = n - 1; i >= 0; i--) {\n    if (s[i] === c) {\n      prev = i;\n    }\n    result[i] = Math.min(result[i], prev - i);\n  }\n\n  return result;\n};\n// @lc code=end\n```\n\n时间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817346693","body":"## 牛刀初试🪫\n\n```js\n/*\n * @lc app=leetcode.cn id=1381 lang=javascript\n *\n * [1381] 设计一个支持增量操作的栈\n */\n\n// @lc code=start\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.stack.length < this.maxSize) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  if (this.stack.length) {\n    return this.stack.pop();\n  } else {\n    return -1;\n  }\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  for (let index = 0; index < Math.min(k, this.stack.length); index++) {\n    this.stack[index] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n// @lc code=end\n```\n\n时间复杂度为 O(1)，空间复杂度为 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817586433","body":"## 牛刀初试🪫\n\n```js\n/*\n * @lc app=leetcode.cn id=394 lang=javascript\n *\n * [394] 字符串解码\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  let res = \"\";\n  let loop = \"\";\n  let stackCount = 0;\n  let loopTimes = \"\";\n  for (let index = 0; index < s.length; index++) {\n    const element = s[index];\n    if (!isNaN(element) && !loop) {\n      if (stackCount) {\n        loop += element;\n      } else {\n        loopTimes += element;\n      }\n    } else if (element === \"[\") {\n      if (stackCount) {\n        loop += element;\n      }\n      stackCount++;\n    } else if (element === \"]\") {\n      stackCount--;\n      if (!stackCount) {\n        res += decodeString(loop).repeat(loopTimes);\n        loop = \"\";\n        loopTimes = \"\";\n      } else {\n        loop += element;\n      }\n    } else if (stackCount) {\n      loop += element;\n    } else {\n      res += element;\n    }\n  }\n\n  return res;\n};\n// @lc code=end\n```\n\n时间复杂度为 O(n)，空间复杂度为 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818280213","body":"## 牛刀初试🪫\n\n```js\n/*\n * @lc app=leetcode.cn id=232 lang=javascript\n *\n * [232] 用栈实现队列\n */\n\n// @lc code=start\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function () {\n  this.stack = [];\n};\n\n/**\n * Push element x to the back of queue.\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.stack.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  return this.stack.length ? this.stack.splice(0, 1) : -1;\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  return this.stack[0] || -1;\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return !this.stack.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n// @lc code=end\n```\n\n时间复杂度为 O(1)，空间复杂度为 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eggeggliu":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1814465587","body":"[989. 数组形式的整数加法](https://leetcode.cn/problems/add-to-array-form-of-integer/description/)\n# 解题思路\n笨办法把k也变成数组形式，用while循环遍历两个数组进行相加，记得处理进位。(有优化空间，k没必要转换为数组，一个数字本身已经存够了需要的信息)\n## 实现代码\n```Cpp\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    if (!k) return num;\n    vector<int> n;\n    while (k) {\n        n.push_back(k % 10);\n        k /= 10;\n    }\n    reverse(num.begin(), num.end());\n    int plus = 0, ptr = 0;\n    int len = min(num.size(), n.size());\n    vector<int> res;\n    while (ptr < len) {\n        int temp = num[ptr] + n[ptr] + plus;\n        res.push_back(temp % 10);\n        plus = temp / 10;\n        ++ptr;\n    }\n    if (ptr == num.size()) {\n        while (ptr < n.size()) {\n            int temp = n[ptr] + plus;\n            res.push_back(temp % 10);\n            plus = temp / 10;\n            ++ptr;\n        }\n    } else {\n        while (ptr < num.size()) {\n            int temp = num[ptr] + plus;\n            res.push_back(temp % 10);\n            plus = temp / 10;\n            ++ptr;\n        }\n    }\n    if (plus) res.push_back(1);\n    reverse(res.begin(), res.end());\n    return res;\n}\n```\n## 算法复杂度\nO(max(num.size(), log k / log 10))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1815879007","body":"[821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/description/)\n# 解题思路\n遍历一边字符串记录所有c出现的位置。再用一个滑动指针求出每个下标对应的结果。\n## 实现代码\n```Cpp\nvector<int> shortestToChar(string s, char c) {\n    vector<int> chars = {}, res = {};\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == c) {\n            chars.push_back(i);\n        }\n    }\n    int ptr = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (ptr == chars.size() - 1) {\n            res.push_back(fabs(i - chars[ptr]));\n            continue;\n        }\n        int pre = fabs(i - chars[ptr]), next = fabs(i - chars[ptr + 1]);\n        if (pre < next) {\n            res.push_back(pre);\n        } else {\n            res.push_back(next);\n            ++ptr;\n        }\n    }\n    return res;\n}\n```\n## 算法复杂度\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817462981","body":"```cpp\nclass CustomStack {\n    maxSize:number;\n    cnt:number;\n    stack: Array<number>;\n    incrementInfos: Array<number>;\n\n    constructor(maxSize: number) {\n      this.maxSize = maxSize;\n      this.cnt = -1;\n      this.incrementInfos = new Array(maxSize).fill(0);\n      this.stack = [];\n    }\n\n    push(x: number): void {\n      if (this.cnt < this.maxSize -1) {\n        this.cnt++;\n        this.stack.push(x);\n      }\n    }\n\n    pop(): number {\n      if (this.cnt === -1) return -1;\n      const inc = this.incrementInfos[this.cnt];\n\n      if (inc) {\n        this.incrementInfos[this.cnt] = 0;\n        this.incrementInfos[this.cnt -1] += inc;\n      }\n      this.cnt--;\n      return this.stack.pop() + inc;\n    }\n\n    increment(k: number, val: number): void {\n      let i = k;\n      if (this.cnt < i) i = this.cnt + 1;\n      if (i > 0 ) this.incrementInfos[i - 1] += val;\n    }\n}\n```\n复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817892545","body":"# 代码\n```cpp\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // 获取一个数字并进栈\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // 左括号出栈\n                stk.pop_back();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // 构造字符串\n                while (repTime--) t += o; \n                // 将构造好的字符串入栈\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n```\n# 复杂度\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1817900893","body":"# 思路\n学习官方题解的优雅写法\n# 代码\n```cpp\nclass MyQueue {\nprivate:\n    stack<int> inStack, outStack;\n\n    void in2out() {\n        while (!inStack.empty()) {\n            outStack.push(inStack.top());\n            inStack.pop();\n        }\n    }\n\npublic:\n    MyQueue() {}\n\n    void push(int x) {\n        inStack.push(x);\n    }\n\n    int pop() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        int x = outStack.top();\n        outStack.pop();\n        return x;\n    }\n\n    int peek() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        return outStack.top();\n    }\n\n    bool empty() {\n        return inStack.empty() && outStack.empty();\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822236727","body":"# 思路\n快慢指针，注意`k>链表长度`的情况\n# 代码\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr || head->next == nullptr || !k) return head;\n        ListNode* cur = head;\n        int len = 1;\n        while (cur->next) {\n            cur = cur->next;\n            ++len;\n        }\n        k %= len;\n        ListNode* first = head;\n        ListNode* second = head;\n        while (k--) {\n            first = first->next;\n        }\n        while (first->next) {\n            first = first->next;\n            second = second->next;\n        }\n        first->next = head;\n        ListNode* newHead = second->next;\n        second->next = nullptr;\n        return newHead;\n    }\n};\n```\n# 复杂度\nO(N)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829216158","body":"# 思路\nDFS\n# 代码\n```cpp\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        int left = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        return max(left, right) + 1;\n    }\n};\n```\n# 复杂度\nO(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/17#issuecomment-1835406650","body":"# 思路\nBFS\n# 代码\n```cpp\nclass Solution {\npublic:\n    int findBottomLeftValue_bfs(TreeNode* root) {\n        queue<TreeNode*> q;\n        TreeNode* ans = NULL;\n        q.push(root);\n        while (!q.empty()) {\n            ans = q.front();\n            int size = q.size();\n            while (size--) {\n                TreeNode* cur = q.front();\n                q.pop();\n                if (cur->left )\n                    q.push(cur->left);\n                if (cur->right)\n                    q.push(cur->right);\n            }\n        }\n        return ans->val;\n    }\n}\n```\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1837883488","body":"# 思路\n哈希\n# 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> hashtable;\n        for (int i = 0; i < nums.size(); ++i) {\n            auto it = hashtable.find(target - nums[i]);\n            if (it != hashtable.end()) {\n                return {it->second, i};\n            }\n            hashtable[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n# 复杂度\nO(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1844090352","body":"# 思路\n滑动窗口\n# 代码\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        // 哈希集合，记录每个字符是否出现过\n        unordered_set<char> occ;\n        int n = s.size();\n        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n        int rk = -1, ans = 0;\n        // 枚举左指针的位置，初始值隐性地表示为 -1\n        for (int i = 0; i < n; ++i) {\n            if (i != 0) {\n                // 左指针向右移动一格，移除一个字符\n                occ.erase(s[i - 1]);\n            }\n            while (rk + 1 < n && !occ.count(s[rk + 1])) {\n                // 不断地移动右指针\n                occ.insert(s[rk + 1]);\n                ++rk;\n            }\n            // 第 i 到 rk 个字符是一个极长的无重复字符子串\n            ans = max(ans, rk - i + 1);\n        }\n        return ans;\n    }\n};\n```\n# 复杂度\nO(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849253464","body":"# 思路\n双指针\n# 代码\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 0) {\n            return 0;\n        }\n        int fast = 1, slow = 1;\n        while (fast < n) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                ++slow;\n            }\n            ++fast;\n        }\n        return slow;\n    }\n};\n```\n# 复杂度\nO(N)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/34#issuecomment-1859485658","body":"# 思路\n排序 + 优先队列\n# 代码\n```cpp\nclass Solution {\nprivate:\n    using PII = pair<int, int>;\n    using LL = long long;\n\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        int n = tasks.size();\n        vector<int> indices(n);\n        iota(indices.begin(), indices.end(), 0);\n        sort(indices.begin(), indices.end(), [&](int i, int j) {\n            return tasks[i][0] < tasks[j][0];\n        });\n\n        vector<int> ans;\n        // 优先队列\n        priority_queue<PII, vector<PII>, greater<PII>> q;\n        // 时间戳\n        LL timestamp = 0;\n        // 数组上遍历的指针\n        int ptr = 0;\n        \n        for (int i = 0; i < n; ++i) {\n            // 如果没有可以执行的任务，直接快进\n            if (q.empty()) {\n                timestamp = max(timestamp, (LL)tasks[indices[ptr]][0]);\n            }\n            // 将所有小于等于时间戳的任务放入优先队列\n            while (ptr < n && tasks[indices[ptr]][0] <= timestamp) {\n                q.emplace(tasks[indices[ptr]][1], indices[ptr]);\n                ++ptr;\n            }\n            // 选择处理时间最小的任务\n            auto&& [process, index] = q.top();\n            timestamp += process;\n            ans.push_back(index);\n            q.pop();\n        }\n        \n        return ans;\n    }\n};\n```\n# 复杂度\nO(nlogn)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/40#issuecomment-1868473052","body":"归并排序\n# 代码\n```cpp\nclass Solution {\npublic:\n    int reversePairsRecursive(vector<int>& nums, int left, int right) {\n        if (left == right) {\n            return 0;\n        } else {\n            int mid = (left + right) / 2;\n            int n1 = reversePairsRecursive(nums, left, mid);\n            int n2 = reversePairsRecursive(nums, mid + 1, right);\n            int ret = n1 + n2;\n\n            // 首先统计下标对的数量\n            int i = left;\n            int j = mid + 1;\n            while (i <= mid) {\n                while (j <= right && (long long)nums[i] > 2 * (long long)nums[j]) j++;\n                ret += (j - mid - 1);\n                i++;\n            }\n\n            // 随后合并两个排序数组\n            vector<int> sorted(right - left + 1);\n            int p1 = left, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= right) {\n                if (p1 > mid) {\n                    sorted[p++] = nums[p2++];\n                } else if (p2 > right) {\n                    sorted[p++] = nums[p1++];\n                } else {\n                    if (nums[p1] < nums[p2]) {\n                        sorted[p++] = nums[p1++];\n                    } else {\n                        sorted[p++] = nums[p2++];\n                    }\n                }\n            }\n            for (int i = 0; i < sorted.size(); i++) {\n                nums[left + i] = sorted[i];\n            }\n            return ret;\n        }\n    }\n\n    int reversePairs(vector<int>& nums) {\n        if (nums.size() == 0) return 0;\n        return reversePairsRecursive(nums, 0, nums.size() - 1);\n    }\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/47#issuecomment-1872701502","body":"滑动窗口\n# 代码\n```cpp\nclass Solution {\npublic:\n    unordered_map <char, int> ori, cnt;\n\n    bool check() {\n        for (const auto &p: ori) {\n            if (cnt[p.first] < p.second) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        for (const auto &c: t) {\n            ++ori[c];\n        }\n\n        int l = 0, r = -1;\n        int len = INT_MAX, ansL = -1, ansR = -1;\n\n        while (r < int(s.size())) {\n            if (ori.find(s[++r]) != ori.end()) {\n                ++cnt[s[r]];\n            }\n            while (check() && l <= r) {\n                if (r - l + 1 < len) {\n                    len = r - l + 1;\n                    ansL = l;\n                }\n                if (ori.find(s[l]) != ori.end()) {\n                    --cnt[s[l]];\n                }\n                ++l;\n            }\n        }\n\n        return ansL == -1 ? string() : s.substr(ansL, len);\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/56#issuecomment-1879588308","body":"BFS\n# 代码\n```cpp\nclass Solution {\npublic:\n    int maxCandies(vector<int>& status, vector<int>& candies, vector<vector<int>>& keys, vector<vector<int>>& containedBoxes, vector<int>& initialBoxes) {\n        int n = status.size();\n        vector<bool> can_open(n), has_box(n), used(n);\n        for (int i = 0; i < n; ++i) {\n            can_open[i] = (status[i] == 1);\n        }\n\n        queue<int> q;\n        int ans = 0;\n        for (int box: initialBoxes) {\n            has_box[box] = true;\n            if (can_open[box]) {\n                q.push(box);\n                used[box] = true;\n                ans += candies[box];\n            }\n        }\n        \n        while (!q.empty()) {\n            int big_box = q.front();\n            q.pop();\n            for (int key: keys[big_box]) {\n                can_open[key] = true;\n                if (!used[key] && has_box[key]) {\n                    q.push(key);\n                    used[key] = true;\n                    ans += candies[key];\n                }\n            }\n            for (int box: containedBoxes[big_box]) {\n                has_box[box] = true;\n                if (!used[box] && can_open[box]) {\n                    q.push(box);\n                    used[box] = true;\n                    ans += candies[box];\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n```\n# 复杂度\nO(N)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/63#issuecomment-1889717937","body":"dp\n# 代码\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};\n\n    double knightProbability(int n, int k, int row, int column) {\n        vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n, vector<double>(n)));\n        for (int step = 0; step <= k; step++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (step == 0) {\n                        dp[step][i][j] = 1;\n                    } else {\n                        for (auto & dir : dirs) {\n                            int ni = i + dir[0], nj = j + dir[1];\n                            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][row][column];\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dr-kkk":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1814589556","body":"### 思路 \n先对数组操作，如果k较大再通过%10处理，最后通过交换向量中前后两个数实现翻转\n### 代码\n```cpp\nclass Solution\n{\npublic:\n    vector<int> addToArrayForm(vector<int> &num, int k)\n    {\n        vector<int> ans;\n        int len = num.size();\n        for (int i = len - 1; i >= 0; i--)\n        {\n            k += num[i];\n            ans.push_back(k % 10);\n            k /= 10;\n        }\n        while (k > 0)\n        {\n            ans.push_back(k % 10);\n            k /= 10;\n            len++;\n        }\n        for (int i = 0, j = len - 1; i < j;)\n        {\n            swap(ans[i], ans[j]);\n            i++;\n            j--;\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1816236392","body":"### 思路\n先遍历字符串，用一个向量记录目标字符的位置；然后再遍历字符串，取当前字符到两个目标字符的距离之差的绝对值的最小值\n\n### 代码\n```c++\n   class Solution\n{\npublic:\n    vector<int> shortestToChar(string s, char c)\n    {\n        vector<int> appearc, ans;\n        int n = s.size();\n        for (int i = 0; i < n; i++)\n        {\n            if (s[i] == c)\n                appearc.push_back(i);\n        }\n        appearc.push_back(21474836);\n        int cnt = 1;\n        for (int i = 0; i < n; i++)\n        {\n            ans.push_back(min(abs(i - appearc[cnt - 1]), abs(i - appearc[cnt])));\n            if (i == appearc[cnt])\n                cnt++;\n        }\n        return ans;\n    }\n};\n```\n复杂度分析：\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822985213","body":"## 思路：\n先遍历一遍链表获得长度，再找到第n-k个节点的位置，将tail和head相连，将第n-k+1个节点设置为头，断开第n-k个节点和第n-k+1个节点；\n## 代码\n```c++\nclass Solution\n{\npublic:\n    ListNode *rotateRight(ListNode *head, int k)\n    {\n        if (head == nullptr || k == 0)\n            return head;\n        int len = 1;\n        ListNode *tail, *p = head;\n        while (p->next != NULL)\n        {\n            p = p->next;\n            len++;\n        }\n        tail = p;\n        k %= len;\n        p = head;\n        for (int i = 0; i < len - k - 1; i++)\n        {\n            p = p->next;\n        }\n        tail->next = head;\n        head = p->next;\n        p->next = nullptr;\n        return head;\n    }\n};\n```\n时间复杂度：n\n空间复杂度：n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1824048606","body":"## 思路：递归\n先用temp保存head->next，然后再用类似于数字交换的方法完成head和head->next的交换，之后用递归处理head->next->next即可\n## 代码：\n```c++\nclass Solution\n{\npublic:\n    ListNode *swapPairs(ListNode *head)\n    {\n        if (head == nullptr || head->next == nullptr)\n            return head;\n        ListNode *temp = head->next;\n        head->next = temp->next;\n        temp->next = head;\n        head = temp;\n        head->next->next = swapPairs(head->next->next);\n        return head;\n    }\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829709728","body":"## 思路\n首先深度是节点到根节点的节点数，根节点的高度=二叉树的最大深度\n递归函数首先确定参数和返回值：传入根节点\n接下来确定终止条件：遇到空，return 0(根节点的高度是0)\n建立与子问题的关联：max（左高度，右高度）+1；\n\n## 代码\n```c++\nclass Solution\n\n{\n\npublic:\n\n    int maxDepth(TreeNode *root)\n\n    {\n\n        if (root == nullptr)\n\n            return 0;\n\n        int leftheight = maxDepth(root->left);\n\n        int rightheight = maxDepth(root->right);\n\n        return max(leftheight, rightheight) + 1;\n\n    }\n\n};\n```\n## 复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1837919548","body":"## 思路：\n查询一个元素是否出现过的时候用哈希表；我们需要判断这个元素是否出现过，如果出现过返回元素的下标，所以把key设置成元素，value设置成下标。\n之所以可以避免元素重复查找的问题，是因为在遍历到第i个pair的时候，我们查询的是harshmap中存储的前i-1个数，因为i每次都不同，所以不会重复查找。\n## 代码\n```c++\nclass Solution\n\n{\n\npublic:\n\n    vector<int> twoSum(vector<int> &nums, int target)\n\n    {\n\n        unordered_map<int, int> harshmap;\n\n        int len = nums.size();\n\n        for (int i = 0; i < len; i++)\n\n        {\n\n            auto isfind = harshmap.find(target - nums[i]);\n\n            if (isfind != harshmap.end())\n\n            {\n\n                return {isfind->second, i};\n\n            }\n\n            harshmap.insert(pair<int, int>(nums[i], i));\n\n        }\n\n        return {0, 0};\n\n    }\n\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/26#issuecomment-1848863543","body":"```c++\nclass Solution\n{\npublic:\n    ListNode *middleNode(ListNode *head)\n    {\n        ListNode *headptr = head;\n        int n = 1;\n        while (tailptr->next != nullptr)\n        {\n            n++;\n        }\n        int target;\n        if (n % 2 == 1)\n            target = (n - 1) / 2;\n        else\n            target = n / 2;\n        while (target--)\n            headptr = headptr->next;\n        return headptr;\n    }\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/30#issuecomment-1855598345","body":"建立有向图；\n```c++\nclass Solution\n{\npublic:\n    int findJudge(int n, vector<vector<int>> &trust)\n    {\n        vector<int> inDegree(n + 1);\n        vector<int> outDegree(n + 1);\n        for (int i = 0; i < trust.size(); i++)\n        {\n            inDegree[trust[i][1]]++;\n            outDegree[trust[i][0]]++;\n        }\n        for (int i = 1; i <= n; i++)\n        {\n            if (inDegree[i] == n - 1 && outDegree[i] == 0)\n                return i;\n        }\n        return -1;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/33#issuecomment-1859187527","body":"模拟.\n```c++\nclass Solution\n{\npublic:\n    bool judgeCircle(string moves)\n    {\n        int len = moves.length();\n        int x = 0, y = 0;\n        for (int i = 0; i < len; i++)\n        {\n            switch (moves[i])\n            {\n            case 'R':\n                x++;\n                break;\n            case 'L':\n                x--;\n                break;\n            case 'U':\n                y++;\n                break;\n            case 'D':\n                y--;\n                break;\n            default:\n                break;\n            }\n        }\n        if (x == 0 && y == 0)\n            return 1;\n        return 0;\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/39#issuecomment-1868266957","body":"二分查找.\n```c++\nbool isBadVersion(int version);\n\nclass Solution\n{\npublic:\n    int firstBadVersion(int n)\n    {\n        long long LeftPointer = 1, RightPointer = n;\n        long long mid;\n        while (LeftPointer <= RightPointer)\n        {\n            mid = (LeftPointer + RightPointer) / 2;\n            if (isBadVersion(mid))\n            {\n                RightPointer = mid - 1;\n            }\n            else\n            {\n                LeftPointer = mid + 1;\n            }\n        }\n        return LeftPointer;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinhma":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1814610210","body":"思路：先按照k依次加数组中的元素取余来获取结果，最后单独处理k的情况\r\n``` JAVA\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int len = num.length;\r\n        for (int i = 0; i < len; ++i) {\r\n            int a = num[len - i - 1];\r\n            k = k + a;\r\n            int b = k % 10;\r\n            result.add(b);\r\n            k = k / 10;\r\n        }\r\n        while (k != 0) {\r\n            int a = k % 10;\r\n            result.add(a);\r\n            k = k / 10;\r\n        }\r\n        Collections.reverse(result);\r\n        return result;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1815653163","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] result = new int[len];\n        List<Integer> cPosition = new ArrayList<>();\n        for (int i=0;i<len;i++){\n            if (s.charAt(i)==c){\n                cPosition.add(i);\n            }\n        }\n        \n        for (int i=0;i<len;i++){\n            if (s.charAt(i)==c){\n                result[i] = 0;\n                continue;\n            }\n            int min = len;\n            for (int a:cPosition){\n                min = Math.min(min,Math.abs(i-a));\n            }\n            result[i] = min;\n        }\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817501970","body":"\n```java\nclass CustomStack {\n    List<Integer> stack;\n    int size;\n    public CustomStack(int maxSize) {\n        this.stack = new ArrayList<Integer>(maxSize);\n        this.size = maxSize;\n    }\n    \n    public void push(int x) {\n        if(stack.size()+1<=size){\n            stack.add(x);\n        }\n    }\n    \n    public int pop() {\n        if(stack.size() == 0){\n            return -1;\n        }\n        int result = stack.get(stack.size()-1);\n        stack.remove(stack.size()-1);\n        return result;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<stack.size();i++){\n            int var1 = stack.get(i);\n            if(i<k){\n                stack.set(i, var1+val);\n            }\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817835690","body":"\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<Integer> numStack = new LinkedList<>();\n        Deque<StringBuilder> sbStack = new LinkedList<>();\n        int multi = 0;\n        StringBuilder sb = new StringBuilder();\n        for(char ch : s.toCharArray()){\n            if(Character.isDigit(ch)){\n               multi = multi * 10 + ch - '0';\n            }\n            else if(ch == '['){\n                numStack.push(multi);\n                sbStack.push(sb);\n                multi = 0;\n                sb = new StringBuilder();\n            }\n            else if(ch == ']'){\n                StringBuilder sbTemp = sbStack.pop();\n                int numTemp = numStack.pop();\n                for(int i = 0;i<numTemp;i++){\n                    sbTemp.append(sb.toString());\n                }\n                sb = sbTemp;\n            }\n            else{\n                sb.append(ch);\n            }\n        }\n        return sb.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1819205502","body":"\n```java\nclass MyQueue {\n    private Stack<Integer> stackOne;\n    private Stack<Integer> stackTwo;\n    public MyQueue() {\n        this.stackOne = new Stack<Integer>();\n        this.stackTwo = new Stack<Integer>();\n    }\n\n    public void push(int x) {\n        stackOne.add(x);\n    }\n\n    public int pop() {\n        while (!stackOne.empty()){\n            stackTwo.add(stackOne.pop());\n        }\n        int result = stackTwo.pop();\n        while (!stackTwo.empty()){\n            stackOne.add(stackTwo.pop());\n        }\n        return result;\n    }\n\n    public int peek() {\n        while (!stackOne.empty()){\n            stackTwo.add(stackOne.pop());\n        }\n        int result = stackTwo.peek();\n        while (!stackTwo.empty()){\n            stackOne.add(stackTwo.pop());\n        }\n        return result;\n    }\n\n    public boolean empty() {\n        return stackOne.empty();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1820020860","body":"\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            } else {\n                int mx = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(mx);\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822862560","body":"\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        ListNode cur = head;\n        int len = 0;\n        while (cur != null) {\n            len++;\n            cur = cur.next;\n        }\n        k %= len;\n        if (k == 0) return head;\n        // 快指针 fast 先走k步：\n        ListNode fast = head;\n        while (k > 0) {\n            fast = fast.next;\n            k--;\n        }\n        ListNode slow = head;\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        ListNode newHead = slow.next;\n        slow.next = null;\n        fast.next = head;\n        return newHead;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1824298349","body":"\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/10#issuecomment-1827955574","body":"``` java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right) {\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1827951595","body":"\n```java\npublic class LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode() {}\n        public DLinkedNode(int key, int value) {this.key = key; this.value = value;}\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        this.head = new DLinkedNode();\n        this.tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache.put(key, newNode);\n            // 添加至双向链表的头部\n            addToHead(newNode);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode tail = removeTail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829897344","body":"```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        } else {\n            int leftHeight = maxDepth(root.left);\n            int rightHeight = maxDepth(root.right);\n            return Math.max(leftHeight, rightHeight) + 1;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831993173","body":"```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null || q == null) {\n            return false;\n        } else if (p.val != q.val) {\n            return false;\n        } else {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1834002932","body":"```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    public int dfs(TreeNode root, int prevSum) {\n        if (root == null) {\n            return 0;\n        }\n        int sum = prevSum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return sum;\n        } else {\n            return dfs(root.left, sum) + dfs(root.right, sum);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/17#issuecomment-1835237537","body":"```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int result = root.val;\n        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            TreeNode tmp = queue.poll();\n            if(tmp.right!=null){\n                queue.offer(tmp.right);\n            }\n            if(tmp.left!=null){\n                queue.offer(tmp.left);\n            }\n            result = tmp.val;\n        }\n        return result;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1838696347","body":"```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] result = new int[2];\n        for(int i=0;i<nums.length-1;i++){\n            int a = nums[i];\n            for(int j=i+1;j<nums.length;j++){\n                int b = nums[j];\n                if(a+b==target){\n                    result[0] = i;\n                    result[1] = j;\n                }\n            }\n        }\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/21#issuecomment-1839798374","body":"```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> countMap = new HashMap<>();\n        for(int num:nums){\n            countMap.put(num, countMap.getOrDefault(num, 0)+1);\n        }\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n        for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] result = new int[k];\n        for (int i = 0; i < k; ++i) {\n            result[i] = queue.poll()[0];\n        }\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/22#issuecomment-1842997299","body":"```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int ans = 0;\n        for (int[] p : points) {\n            Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n            for (int[] q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                cnt.put(dis, cnt.getOrDefault(dis, 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\n                int m = entry.getValue();\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1851972559","body":"```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        int left = 0, right = n - 1, ans = n;\n        while (left <= right) {\n            int mid = ((right - left) >> 1) + left;\n            if (target <= nums[mid]) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/29#issuecomment-1854147252","body":"```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] pair1, int[] pair2) {\n                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];\n            }\n        });\n        for (int i = 0; i < k; ++i) {\n            pq.offer(new int[]{nums[i], i});\n        }\n        int[] ans = new int[n - k + 1];\n        ans[0] = pq.peek()[0];\n        for (int i = k; i < n; ++i) {\n            pq.offer(new int[]{nums[i], i});\n            while (pq.peek()[1] <= i - k) {\n                pq.poll();\n            }\n            ans[i - k + 1] = pq.peek()[0];\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/30#issuecomment-1855988247","body":"\n```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] aux = new int[n+1];\n        for(int i = 0; i < trust.length; i ++){\n            aux[trust[i][1]]++;\n            aux[trust[i][0]]--;\n        }\n        for(int i = 1; i <= n; i ++)\n            if(aux[i] == n - 1) \n                return i;\n        return -1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/31#issuecomment-1857063955","body":"\n```java\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] color = new int[n + 1];\n        List<Integer>[] g = new List[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            g[i] = new ArrayList<Integer>();\n        }\n        for (int[] p : dislikes) {\n            g[p[0]].add(p[1]);\n            g[p[1]].add(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0) {\n                Queue<Integer> queue = new ArrayDeque<Integer>();\n                queue.offer(i);\n                color[i] = 1;\n                while (!queue.isEmpty()) {\n                    int t = queue.poll();\n                    for (int next : g[t]) {\n                        if (color[next] > 0 && color[next] == color[t]) {\n                            return false;\n                        }\n                        if (color[next] == 0) {\n                            color[next] = 3 ^ color[t];\n                            queue.offer(next);\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/34#issuecomment-1860550451","body":"\n```java\nclass Solution {\n    public int[] getOrder(int[][] ts) {\n        int n = ts.length;\n        // 将 ts 转存成 nts，保留任务编号\n        int[][] nts = new int[n][3];\n        for (int i = 0; i < n; i++) nts[i] = new int[]{ts[i][0], ts[i][1], i};\n        // 根据任务入队时间进行排序\n        Arrays.sort(nts, (a,b)->a[0]-b[0]);\n        // 根据题意，先按照「持续时间」排序，再根据「任务编号」排序\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->{\n            if (a[1] != b[1]) return a[1] - b[1];\n            return a[2] - b[2];\n        });\n        int[] ans = new int[n];\n        for (int time = 1, j = 0, idx = 0; idx < n; ) {\n        \t// 如果当前任务可以添加到「队列」中（满足入队时间）则进行入队\n            while (j < n && nts[j][0] <= time) q.add(nts[j++]);\n            if (q.isEmpty()) {\n\t            // 如果当前「队列」没有任务，直接跳到下个任务的入队时间\n                time = nts[j][0];\n            } else {\n            \t// 如果有可执行任务的话，根据优先级将任务出队（记录下标），并跳到该任务完成时间点\n                int[] cur = q.poll();\n                ans[idx++] = cur[2];\n                time += cur[1];\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/35#issuecomment-1862861623","body":"```java\nclass Solution {\n    public int numberOfRounds(String loginTime, String logoutTime) {\n        int loginHour = getHour(loginTime);\n        int logoutHour = getHour(logoutTime);\n        int loginMin = getMin(loginTime);\n        int logoutMin = getMin(logoutTime);\n        if(logoutHour<loginHour || (logoutHour==loginHour && logoutMin<loginMin)){\n            logoutHour = logoutHour + 24;\n        }\n        int diffMin = logoutHour * 60 + logoutMin - loginHour * 60 - loginMin;\n        if(loginMin%15!=0){\n            diffMin = diffMin - (15-loginMin%15);\n        }\n        if(logoutMin%15!=0){\n            diffMin = diffMin - logoutMin%15;\n        }\n        int result = diffMin/15;\n        return result>0?result:0;\n    }\n\n    private int getHour(String time){\n        String hour = time.split(\":\")[0];\n        return Integer.parseInt(hour);\n    }\n\n    private int getMin(String time){\n        String minute = time.split(\":\")[1];\n        return Integer.parseInt(minute);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/36#issuecomment-1864648595","body":"\n```java\nclass Solution {\n    public int minCharacters(String a, String b) {\n        int n = a.length(), m = b.length(), ans = 0x3f3f3f3f;\n        int[] c1 = new int[26], c2 = new int[26];\n        for (char c : a.toCharArray()) c1[c - 'a']++;\n        for (char c : b.toCharArray()) c2[c - 'a']++;\n        for (int i = 0; i < 26 && ans != 0; i++) {\n            // 3\n            int ca = n - c1[i], cb = m - c2[i];\n            ans = Math.min(ans, ca + cb);\n            if (i == 0) continue;\n            int r1 = 0, r2 = 0;\n            // 1\n            for (int j = i; j < 26; j++) r1 += c1[j];\n            for (int j = 0; j < i; j++) r1 += c2[j];\n            // 2\n            for (int j = i; j < 26; j++) r2 += c2[j];\n            for (int j = 0; j < i; j++) r2 += c1[j];\n            ans = Math.min(ans, Math.min(r1, r2));\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/37#issuecomment-1866482927","body":"```java\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        randomizedQuicksort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    public void randomizedQuicksort(int[] nums, int l, int r) {\n        if (l < r) {\n            int pos = randomizedPartition(nums, l, r);\n            randomizedQuicksort(nums, l, pos - 1);\n            randomizedQuicksort(nums, pos + 1, r);\n        }\n    }\n\n    public int randomizedPartition(int[] nums, int l, int r) {\n        int i = new Random().nextInt(r - l + 1) + l; // 随机选一个作为我们的主元\n        swap(nums, r, i);\n        return partition(nums, l, r);\n    }\n\n    public int partition(int[] nums, int l, int r) {\n        int pivot = nums[r];\n        int i = l - 1;\n        for (int j = l; j <= r - 1; ++j) {\n            if (nums[j] <= pivot) {\n                i = i + 1;\n                swap(nums, i, j);\n            }\n        }\n        swap(nums, i + 1, r);\n        return i + 1;\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/38#issuecomment-1867074846","body":"\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        int l = 0;\n\tint r = x;\n\tint ans = -1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if ((long) mid * mid <= x) {\n                ans = mid;\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/41#issuecomment-1868989303","body":"\n```java\nclass Solution {\n    public double solve(int[] nums) {\n        Arrays.sort(nums);\n        int streetLength = nums[nums.length - 1] - nums[0];\n        int low = 0, high = streetLength / 3 + 1;\n        while (low + 1 < high) {\n            int mid = low + (high - low) / 2;\n            if (isPossible(nums, mid, 3)) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        if (isPossible(nums, low, 3)) {\n            return low / 2D;\n        }\n        return high / 2D;\n    }\n\n    private boolean isPossible(int[] nums, int diameter, int lightNumber) {\n        int lightDiameter = -1;\n        int currentLightNum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > lightDiameter) {\n                currentLightNum++;\n                lightDiameter = nums[i] + diameter;\n            }\n            if (currentLightNum > lightNumber) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/42#issuecomment-1869536299","body":"```java\nclass Solution {\n    public int solve(int[] nums, int k) {\n        Arrays.sort(nums);\n        int absMin = 0;\n        int absMax = nums[nums.length-1] - nums[0];\n\n        while (absMin <= absMax) {\n            int absMid = (absMin + absMax) / 2;\n            if (count_not_greater(nums, absMid) <= k) {\n                absMin = absMid + 1;\n            } else {\n                absMax = absMid - 1;\n            }\n        }\n\n        return absMin;\n    }\n\n    private long count_not_greater(int[] nums, int targetDiff) {\n        long count = 0;\n\n        int l = 0;\n        for (int r=1; r<nums.length; r++) {\n            while (nums[r] - nums[l] > targetDiff) {\n                l++;\n            }\n\n            count += r - l;\n        }\n        return count;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/45#issuecomment-1872132135","body":"```java\nclass Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0) {\n            return 1.0;\n        }\n        double[] dp = new double[k + maxPts];\n        for (int i = k; i <= n && i < k + maxPts; i++) {\n            dp[i] = 1.0;\n        }\n        for (int i = k - 1; i >= 0; i--) {\n            for (int j = 1; j <= maxPts; j++) {\n                dp[i] += dp[i + j] / maxPts;\n            }\n        }\n        return dp[0];\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/54#issuecomment-1876140972","body":"\n```java\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int ans = 0;\n        for (int i = 0; i != grid.length; ++i) {\n            for (int j = 0; j != grid[0].length; ++j) {\n                int cur = 0;\n                Deque<Integer> stacki = new LinkedList<Integer>();\n                Deque<Integer> stackj = new LinkedList<Integer>();\n                stacki.push(i);\n                stackj.push(j);\n                while (!stacki.isEmpty()) {\n                    int cur_i = stacki.pop(), cur_j = stackj.pop();\n                    if (cur_i < 0 || cur_j < 0 || cur_i == grid.length || cur_j == grid[0].length || grid[cur_i][cur_j] != 1) {\n                        continue;\n                    }\n                    ++cur;\n                    grid[cur_i][cur_j] = 0;\n                    int[] di = {0, 0, 1, -1};\n                    int[] dj = {1, -1, 0, 0};\n                    for (int index = 0; index != 4; ++index) {\n                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];\n                        stacki.push(next_i);\n                        stackj.push(next_j);\n                    }\n                }\n                ans = Math.max(ans, cur);\n            }\n        }\n        return ans;\n    }\n}\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/59#issuecomment-1881636023","body":"```java\npublic int rob(int[] nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    // 子问题：\n    // f(k) = 偷 [0..k) 房间中的最大金额\n\n    // f(0) = 0\n    // f(1) = nums[0]\n    // f(k) = max{ rob(k-1), nums[k-1] + rob(k-2) }\n\n    int N = nums.length;\n    int[] dp = new int[N+1];\n    dp[0] = 0;\n    dp[1] = nums[0];\n    for (int k = 2; k <= N; k++) {\n        dp[k] = Math.max(dp[k-1], nums[k-1] + dp[k-2]);\n    }\n    return dp[N];\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/60#issuecomment-1884033997","body":"```java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length, maxLen = 0, ans = 0;\n        int[] dp = new int[n];\n        int[] cnt = new int[n];\n        for (int i = 0; i < n; ++i) {\n            dp[i] = 1;\n            cnt[i] = 1;\n            for (int j = 0; j < i; ++j) {\n                if (nums[i] > nums[j]) {\n                    if (dp[j] + 1 > dp[i]) {\n                        dp[i] = dp[j] + 1;\n                        cnt[i] = cnt[j]; // 重置计数\n                    } else if (dp[j] + 1 == dp[i]) {\n                        cnt[i] += cnt[j];\n                    }\n                }\n            }\n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n                ans = cnt[i]; // 重置计数\n            } else if (dp[i] == maxLen) {\n                ans += cnt[i];\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"emergence23":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1815631366","body":"> Problem: [989. 数组形式的整数加法](https://leetcode.cn/problems/add-to-array-form-of-integer/description/)\r\n\r\n[TOC]\r\n\r\n# 思路\r\n将数组转为字符串，然后转为 int，直接相加，然后再转为字符串拆分保存\r\n\r\n\r\n# 复杂度\r\n- 时间复杂度:\r\n> 添加时间复杂度, 示例： $O(n)$\r\n\r\n- 空间复杂度:\r\n> 添加空间复杂度, 示例： $O(n)$\r\n  \r\n\r\n\r\n# Code\r\n```Java []\r\n\r\nimport java.math.BigInteger;\r\nclass Solution {\r\n    public static List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n\r\n        int nLength = num.length;\r\n        StringBuffer numS = new StringBuffer();\r\n        for (int i = 0; i < nLength; i++) {\r\n            numS.append(String.valueOf(num[i]));\r\n        }\r\n        BigInteger numB = new BigInteger(numS.toString());\r\n        BigInteger add = numB.add(BigInteger.valueOf(k));\r\n        String resS = String.valueOf(add);\r\n        char[] charArray = resS.toCharArray();\r\n\r\n        for (char c : charArray) {\r\n            res.add(Integer.valueOf(String.valueOf(c)));\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n  ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/3#issuecomment-1816031579","body":"# 思路\r\n问题可以转换成，对 s 的每个下标 i，求\r\n\r\ns[i] 到其左侧最近的字符 c 的距离\r\ns[i] 到其右侧最近的字符 c 的距离\r\n这两者的最小值。\r\n\r\n对于前者，我们可以从左往右遍历 s，若 s[i]=c 则记录下此时字符 c 的的下标 idx。遍历的同时更新 answer[i]=i−idx。\r\n\r\n对于后者，我们可以从右往左遍历 s，若 s[i]=c 则记录下此时字符 c 的的下标 idx。遍历的同时更新 answer[i]=min⁡(answer[i],idx−i)。\r\n\r\n代码实现时，在开始遍历的时候 idx 可能不存在，为了简化逻辑，可以用 −n 或 2n 表示，这里 n 是 s 的长度。\r\n\r\n参考\r\n作者：力扣官方题解\r\n链接：https://leetcode.cn/problems/shortest-distance-to-a-character/solutions/1429810/zi-fu-de-zui-duan-ju-chi-by-leetcode-sol-2t49/\r\n来源：力扣（LeetCode）\r\n\r\n\r\n# 复杂度\r\n- 时间复杂度:\r\n> 添加时间复杂度, 示例： $O(n)$，n 为字符串长度\r\n\r\n- 空间复杂度:\r\n> 添加空间复杂度, 示例： $O(1)$\r\n  \r\n\r\n\r\n# Code\r\n```Java []\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n\r\n        for (int i = 0, idx = -n ; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                idx = i;\r\n            }\r\n            ans[i] = i - idx;\r\n\r\n        }\r\n\r\n        for (int i = n -1, idx = 2 * n; i >= 0; i--){\r\n            if (s.charAt(i) == c) {\r\n                idx = i;\r\n            }\r\n\r\n            ans[i] = Math.min(ans[i], idx - i);\r\n        }\r\n\r\n        return ans;\r\n\r\n    }\r\n}\r\n```\r\n  ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818878831","body":"# 思路\r\n参考官方思路\r\n将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\r\n\r\n每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\r\n\r\n\r\n# Code\r\n```Java []\r\n\r\nclass MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new ArrayDeque<Integer>();\r\n        outStack = new ArrayDeque<Integer>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n```\r\n作者：力扣官方题解\r\n链接：https://leetcode.cn/problems/implement-queue-using-stacks/solutions/632369/yong-zhan-shi-xian-dui-lie-by-leetcode-s-xnb6/\r\n来源：力扣（LeetCode）\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822461327","body":"# 思路及算法\r\n\r\n记给定链表的长度为 n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k  mod  n 次即可。因为每 n 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n−1) − (k  mod  n) 个节点（从 0 开始计数）。\r\n\r\n这样，我们可以先将给定的链表连接成环，然后将指定位置断开。\r\n\r\n具体代码中，我们首先计算出链表的长度 nnn，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n - 1) - (k mod n) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。\r\n\r\n特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。\r\n\r\n作者：力扣官方题解\r\n链接：https://leetcode.cn/problems/rotate-list/solutions/681812/xuan-zhuan-lian-biao-by-leetcode-solutio-woq1/\r\n来源：力扣（LeetCode）\r\n\r\n# Code\r\n```Java []\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        int n = 1;\r\n        ListNode iter = head;\r\n        while (iter.next != null) {\r\n            iter = iter.next;\r\n            n++;\r\n        }\r\n        int add = n - k % n;\r\n        if (add == n) {\r\n            return head;\r\n        }\r\n        iter.next = head;\r\n        while (add-- > 0) {\r\n            iter = iter.next;\r\n        }\r\n        ListNode ret = iter.next;\r\n        iter.next = null;\r\n        return ret;\r\n\r\n    }\r\n}\r\n```\r\n  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1824046663","body":"# 思路\r\n* 可以通过递归的方式实现两两交换链表中的节点。\r\n     * 递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。\r\n     * 如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。\r\n     * 用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead。\r\n     * 作者：力扣官方题解\r\n     * 链接：https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/444474/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/\r\n     * 来源：力扣（LeetCode）\r\n    \r\n# Code\r\n```Java []\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\nif (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        ListNode newHead = head.next;\r\n        head.next = swapPairs(newHead.next);\r\n        newHead.next = head;\r\n\r\n        return newHead;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829405306","body":"# 思路\r\n参考官方例子，深度有限遍历+递归方式\r\n\r\n作者：力扣官方题解\r\n链接：https://leetcode.cn/problems/maximum-depth-of-binary-tree/solutions/349250/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/\r\n来源：力扣（LeetCode）\r\n\r\n# 代码\r\n```java \r\npublic int maxDepth(TreeNode root) {\r\n\r\n        if (root == null) {\r\n            return 0;\r\n        } else {\r\n            int leftHeight = maxDepth(root.left);\r\n            int rightHeight = maxDepth(root.right);\r\n            return Math.max(leftHeight, rightHeight) + 1;\r\n        }\r\n\r\n\r\n    }\r\n```\r\n\r\n# 复杂度\r\n\r\n时间复杂度:\r\n添加时间复杂度： $O(n)$\r\n\r\n空间复杂度:\r\n添加空间复杂度： $O(height)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831413872","body":"# 思路\r\n\r\n参考官方题解，深度优先搜索，使用递归比较\r\n\r\n如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。\r\n\r\n如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。\r\n\r\n作者：力扣官方题解\r\n链接：https://leetcode.cn/problems/same-tree/solutions/363636/xiang-tong-de-shu-by-leetcode-solution/\r\n来源：力扣（LeetCode）\r\n\r\n# 复杂度\r\n\r\n时间复杂度： $O(min(m,n))$\r\n\r\n空间复杂度： $O(min(m,n))$\r\n\r\n\r\n\r\n# Code\r\n```Java []\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n if (p == null && q == null) {\r\n            return true;\r\n        } else if (p == null || q == null) {\r\n            return false;\r\n        } else if (p.val != q.val) {\r\n            return false;\r\n        } else {\r\n            return isSameTree(p.left, q.left) && isSameTree(q.right, p.right);\r\n        } \r\n    }\r\n}\r\n```\r\n  \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1833179579","body":"# 思路\r\n\r\n参考官方深度优先题解\r\n这道题中，二叉树的每条从根节点到叶子节点的路径都代表一个数字。其实，每个节点都对应一个数字，等于其父节点对应的数字乘以 101010 再加上该节点的值（这里假设根节点的父节点对应的数字是 000）。只要计算出每个叶子节点对应的数字，然后计算所有叶子节点对应的数字之和，即可得到结果。可以通过深度优先搜索和广度优先搜索实现\r\n\r\n作者：力扣官方题解\r\n链接：https://leetcode.cn/problems/sum-root-to-leaf-numbers/solutions/464666/qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he-by-leetc/\r\n来源：力扣（LeetCode）\r\n\r\n\r\n# 复杂度\r\n\r\n时间复杂度： $O(n)$\r\n\r\n空间复杂度： $O(n)$\r\n\r\n\r\n\r\n# Code\r\n```Java []\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        return dfs(root, 0);\r\n    }\r\n\r\n\r\n    public int dfs(TreeNode root, int prevSum) {\r\n\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n\r\n        int sum = root.val + prevSum * 10;\r\n\r\n        if (root.left == null && root.right == null) {\r\n            return sum;\r\n        } else {\r\n            return dfs(root.left, sum) + dfs(root.right, sum);\r\n        }\r\n\r\n    }\r\n}\r\n```\r\n  \r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1837926069","body":"# 思路\r\n\r\n快速寻找数组中是否存在目标元素。如果存在，需要找出它的索引。\r\n\r\n使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。\r\n\r\n这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。\r\n\r\n作者：力扣官方题解\r\n链接：https://leetcode.cn/problems/two-sum/solutions/434597/liang-shu-zhi-he-by-leetcode-solution/\r\n来源：力扣（LeetCode）\r\n\r\n\r\n# 复杂度\r\n\r\n时间复杂度： $O(n)$\r\n\r\n空间复杂度： $O(n)$\r\n\r\n# Code\r\n```Java []\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (map.containsKey(target - nums[i])) {\r\n                return new int[]{ map.get(target - nums[i]), i};\r\n            }\r\n            map.put(nums[i], i);\r\n        }\r\n        return new int[0];\r\n        }\r\n\r\n\r\n}\r\n```\r\n  \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/21#issuecomment-1840458040","body":"# 思路\r\n首先遍历整个数组，并使用哈希表记录每个数字出现的次数，并形成一个「出现次数数组」。找出原数组的前 kkk 个高频元素，就相当于找出「出现次数数组」的前 kkk 大的值。\r\n\r\n最简单的做法是给「出现次数数组」排序。但由于可能有 O(N)O(N)O(N) 个不同的出现次数（其中 NNN 为原数组长度），故总的算法复杂度会达到 O(Nlog⁡N)O(N\\log N)O(NlogN)，不满足题目的要求。\r\n\r\n在这里，我们可以利用堆的思想：建立一个小顶堆，然后遍历「出现次数数组」：\r\n\r\n如果堆的元素个数小于 kkk，就可以直接插入堆中。\r\n如果堆的元素个数等于 kkk，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 kkk 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。\r\n遍历完成后，堆中的元素就代表了「出现次数数组」中前 kkk 大的值。\r\n\r\n作者：力扣官方题解\r\n链接：https://leetcode.cn/problems/top-k-frequent-elements/solutions/402568/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/\r\n来源：力扣（LeetCode）\r\n\r\n# 复杂度\r\n\r\n时间复杂度: $O(N log k)$\r\n\r\n空间复杂度: $O(n)$\r\n\r\n# Code\r\n```Java []\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\nMap<Integer, Integer> occurrences = new HashMap<Integer, Integer>();\r\n        for (int num : nums) {\r\n            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\r\n        }\r\n\r\n        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\r\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\r\n            public int compare(int[] m, int[] n) {\r\n                return m[1] - n[1];\r\n            }\r\n        });\r\n        for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {\r\n            int num = entry.getKey(), count = entry.getValue();\r\n            if (queue.size() == k) {\r\n                if (queue.peek()[1] < count) {\r\n                    queue.poll();\r\n                    queue.offer(new int[]{num, count});\r\n                }\r\n            } else {\r\n                queue.offer(new int[]{num, count});\r\n            }\r\n        }\r\n        int[] ret = new int[k];\r\n        for (int i = 0; i < k; ++i) {\r\n            ret[i] = queue.poll()[0];\r\n        }\r\n\r\n\r\n        return ret;\r\n    }\r\n}\r\n```\r\n  \r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1844736237","body":"# 思路\r\n\r\n类似本题这样在一个连续的区间内寻找最值的问题，大多数都可以使用滑动窗口求解\r\n\r\n作者：mrawa\r\n链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/645662/javahua-dong-chuang-kou-2ms-ji-bai-100-b-guxy/\r\n来源：力扣（LeetCode）\r\n\r\n\r\n# Code\r\n```Java []\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\nint n = s.length(); \r\n        if(n == 0) {    //如果为空字符串，直接返回0\r\n            return 0;\r\n        }\r\n        //因为本题中字符串只含有英文字母，符号和数字，所以可以使用数组来代替哈希表，提高效率。\r\n        int[] num = new int[128];   \r\n        int res = 0;\r\n        //left: 左指针    right: 右指针\r\n        int left = 0, right = 0;\r\n        //将字符串转换为一个char数组,写起来方便\r\n        char[] cs = s.toCharArray();\r\n\r\n        while(right < n) {\r\n            //每次循环都将右侧指针向前移动一位，并将右侧指针所指向的字符的数量增加1\r\n            //(byte) cs[right]表示将字符cs[right]转换为其所对应的ASCII码，在0~127之间，\r\n            //恰好可以使用byte表示\r\n            num[(byte) cs[right]]++;\r\n            //如果此时右侧指针所对应的字符的数量超过1，表示已经有了重复字符，将左指针右移\r\n            while(num[(byte) cs[right]] > 1) {\r\n                num[(byte) cs[left++]]--;\r\n            }\r\n            //更新结果，取之前的结果与当前窗口长度的最大值\r\n            res = Math.max(res, right - left + 1);\r\n            //右指针右移\r\n            right++;\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n  \r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/30#issuecomment-1855302452","body":"# 思路\r\n\r\n题干描述了一个有向图。每个人是图的节点，trust 的元素 trust[i] 是图的有向边，从 trust[i][0 指向 trust[i][1]。我们可以遍历 trust，统计每个节点的入度和出度，存储在 inDegrees 和 outDegrees 中。\r\n\r\n根据题意，在法官存在的情况下，法官不相信任何人，每个人（除了法官外）都信任法官，且只有一名法官。因此法官这个节点的入度是 n−1, 出度是 0。\r\n\r\n我们可以遍历每个节点的入度和出度，如果找到一个符合条件的节点，由于题目保证只有一个法官，我们可以直接返回结果；如果不存在符合条件的点，则返回 −1。\r\n\r\n# 复杂度\r\n\r\n时间复杂度： $O(n+m)$\r\n\r\n空间复杂度： $O(n)$\r\n\r\n\r\n\r\n# Code\r\n```Java []\r\nclass Solution {\r\n    public int findJudge(int n, int[][] trust) {\r\nint[] inDegrees = new int[n + 1];\r\n        int[] outDegrees = new int[n + 1];\r\n        for (int[] edge : trust) {\r\n            int x = edge[0], y = edge[1];\r\n            ++inDegrees[y];\r\n            ++outDegrees[x];\r\n        }\r\n        for (int i = 1; i <= n; ++i) {\r\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n\r\n\r\n    }\r\n}\r\n```\r\n \r\n\r\n作者：力扣官方题解\r\n链接：https://leetcode.cn/problems/find-the-town-judge/solutions/1162975/zhao-dao-xiao-zhen-de-fa-guan-by-leetcod-0dcg/\r\n来源：力扣（LeetCode）\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"0christ1":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1815320617","body":"### 思路\r\n1. 先把数组num转换成integer数字\r\n2. 再加上k得到total\r\n3. 再把total里的数字存到数组里面\r\n4. 最后返回数组\r\n5. 考虑到edge case，当且仅当total为0的情况\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        num_val = 0\r\n\r\n        for elem in num:\r\n           num_val = num_val * 10 + elem\r\n\r\n        total = num_val + k\r\n\r\n        if total == 0: \r\n           return [0]\r\n\r\n        ans = []\r\n\r\n        while total > 0:\r\n            ans.insert(0, total%10)\r\n            total = total // 10\r\n\r\n        return ans        \r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：因为要获取数组里所有的元素，所以涉及到数组常见操作里的遍历，即 $`O(N)`$\r\n- 空间复杂度：创建了新的空数组，即 $`O(1)`$\r\n\r\n\r\n### 总结\r\n1. 这道题的算法核心思想在于统一处理。先将两种不同类型的数据结构“Array”和“Int”转换成同一个类型“int”，再进行数学运算得到结果。\r\n2. 以此题作延伸，想要操作不同数据结构的变量，可以先尝试是否可以统一。\r\n\r\n***\r\n### 新发现\r\n相同思路但写法不同\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n       integer_result = int(''.join(map(str, num)))\r\n       sum = integer_result+k\r\n       array_result = [int(digit) for digit in str(sum)]\r\n       return(array_result)\r\n```","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1821164421","body":"### 思路\r\n1. 自己想的：先判断数组是不是升序（不是就返回1），于是就没思路了\r\n2. 官方题解：单调栈刚好解决了我的思路问题\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for a in arr:\r\n            if stack and stack[-1] > a:\r\n                cur = stack[-1]\r\n                while stack and stack[-1] > a : \r\n                    stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(a)\r\n        return len(stack)\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：$`O(N)`$, N is the length of array\r\n- 空间复杂度：$`O(N)`$, N is the length of array\r\n\r\n\r\n### 总结\r\n这题对目前的我来说还是太难了\r\n1. 没搞明白stack的特性和如何运用stack这样的adt去解这道算法题\r\n2. 没有吃透排序问题，比如计数排序。","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1827390647","body":"\r\n## [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)\r\n\r\n\r\n## 题目描述\r\n设计和实现一个  `LRU (Least recent use)` 缓存机制 \r\n\r\n\r\n## 前置知识\r\n\r\n- linked list\r\n- Cache\r\n- LRU\r\n\r\n## 思路\r\n\r\n- 题外话：在CompArch课上讲过Cache，但学艺不精 :(。其中一个project作业就是用到了LRU，不过我们只需要写一个function。\r\n- 针对这题，对目前的我来说自己想明白+把code写清楚还是比较难，所以参考了一下官方题解。\r\n   - 我觉得python直接调用库很方便，但是还是得自己搞明白里面的逻辑\r\n\r\n\r\n## 代码\r\n\r\n```python\r\nfrom collections import OrderedDict\r\nclass LRUCache:\r\n    def __init__(self, capacity: init):\r\n        self.maxsize = capacity\r\n        self.lrucache = OrderedDict()\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.lrucache:\r\n            self.lrucache.move_to_end(key)\r\n        return self.lrucache.get(key, -1)\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.lrucache:\r\n            del self.lrucache[key]\r\n        self.lrucache[key] = value\r\n        if len(self.lrucache) > self.maxsize:\r\n            self.lrucache.popitem(last=False)\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：平均的时间都是 $O(N)$\r\n- 空间复杂度：链表和哈希表占用的空间都是 $O(N)$，所以总的时间复杂度为 $O(N)$。N即capacity\r\n\r\n\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1837026522","body":"\r\n## [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)\r\n\r\n## 思路\r\n\r\n-  先打个卡\r\n\r\n\r\n## 代码\r\n\r\n```python\r\nclass Codec:\r\n    def serialize(self, root):\r\n        def preorder(root):\r\n            if not root:\r\n                return \"null,\"\r\n            return str(root.val) + \",\" + preorder(root.left) + preorder(root.right)\r\n\r\n        return preorder(root)[:-1]\r\n\r\n    def deserialize(self, data: str):\r\n        nodes = data.split(\",\")\r\n\r\n        def preorder(i):\r\n            if i >= len(nodes) or nodes[i] == \"null\":\r\n                return i, None\r\n            root = TreeNode(nodes[i])\r\n            j, root.left = preorder(i + 1)\r\n            k, root.right = preorder(j + 1)\r\n            return k, root\r\n\r\n        return preorder(0)[1]\r\n\r\n\r\n```\r\n\r\n\r\n## 复杂度分析\r\n\r\n令 N为数组长度。\r\n\r\n- 时间复杂度： $O(N)$， N为树的节点数\r\n- 空间复杂度： $O(h)$，h为树的高度\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/25#issuecomment-1847585302","body":"## [1590. Make Sum Divisible by P](https://leetcode.com/problems/make-sum-divisible-by-p/)\r\n\r\n## 前置知识\r\n\r\n- Array\r\n- Hash Table\r\n\r\n## 思路\r\n\r\n- 看官方题解是：前缀和+同余定理\r\n- 先打个卡\r\n\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def minSubarray(self, nums, k):\r\n        total = sum(nums)\r\n        mod = total % k\r\n        if mod == 0: return 0\r\n\r\n        ans = len(nums)\r\n        total = 0\r\n        dic = {0: -1}\r\n        for j in range(len(nums)):\r\n            total += nums[j]\r\n            cur = total % k\r\n            target = (cur - mod + k) % k\r\n            if target in dic:\r\n                ans = min(ans, j - dic[target])\r\n            dic[cur] = j\r\n\r\n        if ans == len(nums):\r\n            return -1\r\n        return ans\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：平均的时间都是 $O(N)$\r\n- 空间复杂度： $O(min(N, k))$。","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/31#issuecomment-1856587491","body":"\r\n## [886. Possible Bipartition](https://leetcode.com/problems/possible-bipartition/)\r\n\r\n## 思路\r\n- 先打个卡\r\n\r\n\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def dfs(self, graph, colors, i, color, N):\r\n        colors[i] = color\r\n        for j in range(N):\r\n            # dislike eachother\r\n            if graph[i][j] == 1:\r\n                if colors[j] == color:\r\n                    return False\r\n                if colors[j] == 0 and not self.dfs(graph, colors, j, -1 * color, N):\r\n                    return False\r\n        return True\r\n\r\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\r\n        graph = [[0] * N for i in range(N)]\r\n        colors = [0] * N\r\n        for a, b in dislikes:\r\n            graph[a - 1][b - 1] = 1\r\n            graph[b - 1][a - 1] = 1\r\n        for i in range(N):\r\n            if colors[i] == 0 and not self.dfs(graph, colors, i, 1, N):\r\n                return False\r\n        return True\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度**\r\n\r\n令V和E分别为图中点和边的数目\r\n\r\n- 时间复杂度： $O(V+E)$\r\n- 空间复杂度： $O(V^2)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/37#issuecomment-1865307691","body":"## [912. Sort an Array](https://leetcode.com/problems/sort-an-array/)\r\n\r\n## 思路\r\n- 先打个卡\r\n\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[]}\r\n */\r\nvar sortArray = function (nums) {\r\n  const counts = Array(50000 * 2 + 1).fill(0);\r\n  const res = [];\r\n  for (const num of nums) counts[50000 + num] += 1;\r\n  for (let i in counts) {\r\n    while (counts[i]--) {\r\n      res.push(i - 50000);\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/44#issuecomment-1870586200","body":"## [1456. Maximum Number of Vowels in a Substring of Given Length](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)\r\n\r\n## 思路\r\n- 先打个卡\r\n\r\n\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def maxVowels(self, s: str, k: int) -> int:\r\n        res = 0\r\n        temp = 0\r\n        vowels = set(['a','e','i','o','u'])\r\n        for i in range(k):\r\n            res += s[i] in vowels\r\n        if res==k: return k\r\n        temp = res\r\n        for i in range(k,len(s)):\r\n            temp += (s[i] in vowels) - (s[i-k] in vowels)\r\n            res = max(temp,res)\r\n            if res ==k: return k\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度**\r\n$n$为字串长度\r\n- 时间复杂度： $O(n)$, \r\n- 空间复杂度： $O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junru281":[null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/4#issuecomment-1817403752","body":"Leetcode 1381 Nov 17\n\n[1381. Design a Stack With Increment Operation](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)\n\n\n```java\nclass CustomStack {\n    int[] stack;\n  \t// pointer here represent the current element\n    int pointer = -1;\n  \t// create the stack frame by initialzie an array of size (maxsize)\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    //remember to check if the array is out of space\n    public void push(int x) {\n        if(pointer + 1 <= stack.length-1){\n            stack[pointer+1] = x;\n            pointer ++;\n        }\n    }\n    // remember to check if the stack frame is still null --> pointer is -1\n    public int pop() {\n        if(pointer == -1){\n             return -1;\n        }\n        int ret_val = stack[pointer];\n        pointer --;\n        return ret_val;\n    }\n    //  first to find the correct number of elements to update\n  \t//  then use a for loop to update all \"k\" value\n    public void increment(int k, int val) {\n        int min_count = Math.min(pointer, k-1);\n        for(int i = 0; i<=min_count; i++){\n                stack[i] = stack[i]+val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/5#issuecomment-1817886797","body":"# Leetcode 394 Nov 19 #\n\n[394. Decode String](https://leetcode.cn/problems/decode-string/)\n\n**Ideas**\n\n与括号匹配问题联系, 故而使用stack\n\n主要卡壳在如何提取数字上, 最后用了一个单独的parameter记录. 但何时清零, 何时加1, 还花了点时间. \n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\nStack<String> stack = new Stack<>();\n        int times;\n        int left_ptr;\n        int right_ptr = 0;\n        while(s.contains(\"[\")) {\n            String rep = \"\";\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == '[') {\n                    times = Integer.parseInt(s.substring(i - 1, i));\n                    left_ptr = i - 1;\n                    for (int j = i + 1; j < s.length(); j++) {\n                        stack.push(s.substring(j, j + 1));\n                        if (s.charAt(j) == '[') {\n                            stack.clear();\n                            times = Integer.parseInt(s.substring(j - 1, j));\n                            left_ptr = j - 1;\n                        }\n                        if (s.charAt(j) == ']') {\n                            stack.pop();\n                            right_ptr = j;\n                            break;\n                        }\n                    }\n\n                    while (!stack.isEmpty()) {\n                        rep = stack.pop() + rep;\n                    }\n\n                    String tmp = rep;\n                    for (int m = 0; m < times - 1; m++) {\n\n                        rep = rep + tmp;\n                    }\n\n                    s = s.substring(0, left_ptr) + rep + s.substring(right_ptr + 1);\n                    break;\n                }\n            }\n\n        }\n        return s;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818028298","body":"# Leetcode 232 Nov 20 #\n[232. Implement Queue using Stacks](https://leetcode.cn/problems/implement-queue-using-stacks/)\n\n**Ideas**\n\nThe huge difference between a stack and a queue is the order to retrieve an element. \nBy the hint that we are going to us e two stack, we can use one stack to store elements just as queue and use the other stack to reverse the order of one queue.\nIn other words, before we push the new element, we first pop all existing elements and then push the new element to the bottom of a stack. Then push all the element back, \nso that the first element is still at the top of the stack. \n\n```java\nclass MyQueue {\n    Stack<Integer> queue;\n    Stack<Integer> records;\n\n    public MyQueue() {\n        queue = new Stack<>();\n        records = new Stack<>();\n    }\n    \n    public void push(int x) {\n        while(!queue.empty()){\n            int top_queue = queue.pop();\n            records.push(top_queue);\n        }\n        queue.push(x);\n        while(!records.empty()){\n            int next = records.pop();\n            queue.push(next);\n        }\n    }\n    \n    public int pop() {\n        return queue.pop();\n    }\n    \n    public int peek() {\n        return queue.peek();\n    }\n    \n    public boolean empty() {\n        if(queue.empty()){\n            return true;\n        }\n        else return false;\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1820154274","body":"# Leetcode 768 Nov 20 #\n[768. Max Chunks To Make Sorted II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\n\n**Ideas**\n\nSpent one hour trying to figure out an algorithm but failed. After taking a look at [seedjyh's comment](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/discussion/comments/1701328),\nI figured out how to do using the monotonicity. But forgot we should use stack. :(\n\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int res = 1;\n        for(int i = 0; i< arr.length; i++){\n            if(LeftMax(arr, i) <= RightMin(arr, i+1))\n                res ++;\n        }\n        return res;\n    }\n\n    public int LeftMax(int[] arr, int t){\n        int max = arr[0];\n        for(int i = 0; i<= t; i++){\n            if(max < arr[i]){\n                max = arr[i];\n            }\n        }\n        return max;\n    }\n\n    public int RightMin(int[] arr, int t){\n        if(t>=arr.length)\n            return -1;\n        int min = arr[t];\n        for(int i = t; i< arr.length; i++){\n            if(min > arr[i]){\n                min = arr[i];\n            }\n        }\n        return min;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822158585","body":"# Leetcode 61 Nov 21 #\n[61.Rotate List](https://leetcode.cn/problems/rotate-list/)\n\n**Ideas**\n\n我是直接粗暴上手List, :( 每一次循环找到last node.next =  head, last node的前一个.next设定为null. 直接暴力用for loop.\n\nMistakes: \n1. 没考虑edge case, when empty list, only one node\n2. 没考虑k>>n, 根据评论区小伙伴的提醒, 发现可以用modulus方法\n\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return null;\n        if(head.next == null) return head;\n        int n = 1;\n        ListNode node = head;\n        while(node.next != null){\n            node = node.next;\n            n++;\n        }\n        k = k%n;\n        for(int i =0; i<k; i++){\n            ListNode rotate_node = head;\n            ListNode rotate_node_prev = head;\n            while(rotate_node.next != null){\n                rotate_node_prev = rotate_node;\n                rotate_node = rotate_node.next;\n            }\n            rotate_node_prev.next = null;\n            rotate_node.next = head;\n            head = rotate_node;\n        }\n        return head;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1824602509","body":"# Leetcode 63 Nov 23 #\n\n[24.Swap Nodes in Pairs](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n\n**Ideas**\n\n复杂的迭代法, 写题过程中有意识到可以用递归, 但没想到递归的代码这么简单\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null) return head;\n        if(head.next == null) return head;\n        // 保证LinkedList的长度至少为2 =》 至少有一个pair\n        ListNode node = head;\n        ListNode prev = null;\n        while(node != null){\n            ListNode tmp_node = node.next;\n            node.next = node.next.next;\n            tmp_node.next = node;\n            node = tmp_node;\n            if(prev != null){\n                prev.next = tmp_node;\n            }else head = node;\n            \n            if(node.next.next != null && node.next.next.next != null ){\n                prev = node.next;\n                node = node.next.next;\n            }else break;\n        }\n\n\n        return head;\n    }\n}\n```\nTime Complexity: O(n) # iterate through the linkedlist\n\nSpace Complexity:  O(n) # for each node, create another temp_node","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/10#issuecomment-1825213570","body":"# Leetcode 109 Nov 23#\n\n[109. Convert Sorted List to Binary Search Tree](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)\n\n**Ideas**\n\n这一次看来提示用递归, 但是还没有记得用快慢指针去分离出两个部分. 仍然使用了之前的前遍寻一遍找到总共nodes的数量, 再取对半.\n\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null){\n            return null;\n        }\n        if(head.next == null){\n            return new TreeNode(head.val);\n        }\n        ListNode node = head;\n        int n = 0;\n        while(node != null){\n            n++;\n            node = node.next;\n        }\n        TreeNode root = new TreeNode(head.val);\n        node = head;\n        ListNode prev = head;\n        ListNode right_head = head;\n        for(int i = 0; i< n; i++){\n            if(i == Math.floor(n/2)){\n                prev.next = null;\n                root = new TreeNode(node.val);\n                right_head = node.next;\n                break;\n            }\n            prev = node;\n            node = node.next;\n        }\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(right_head);\n        return root;\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/11#issuecomment-1825971854","body":"# Leetcode 160 Nov 24 #\n\n[160. Intersection of Two Linked Lists](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\n\n**Ideas**\n\n\n1. 首先想到的是两个指针, 一个指向headA里面的nodeA, 一个指向headB里面的nodeB. 然后对于每一个nodeA, 遍历nodeB.\n\n    时间复杂度: O(mn)\n```java\npublic class Solution1 {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode nodeA = headA;\n        while(nodeA!= null){\n            ListNode nodeB = headB;\n            while(nodeB != null){\n                if(nodeA == nodeB) return nodeA;\n                else if(nodeB.next != null){\n                    nodeB = nodeB.next;\n                }else break;\n            }\n            if(nodeA.next != null){\n                nodeA = nodeA.next;\n            }else break;\n        }\n        return null;\n\n    }\n}\n\n```\n\n\n2. 考虑用空间换时间\n\n    利用哈希表来储存A链表内容, 之后再遍历B链表. 本身的algorithm不难, 但是我一开始储存了val而不是ListNode, 就有顺序错乱导致的问题.\n\n```java\nimport java.util.HashSet;\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution2 {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode nodeA = headA;\n        HashSet<ListNode> A = new HashSet<>();\n        while(nodeA!= null){\n            A.add(nodeA);\n            nodeA = nodeA.next;\n        }\n\n        ListNode nodeB = headB;\n        while(nodeB != null){\n            if(A.contains(nodeB)){\n                return nodeB;\n            }\n            nodeB = nodeB.next;\n        }\n        return null;\n\n    }\n}\n```\n\n\n3. 双指针\n    \n    用nodeA标记位置, 如果A遍历结束, 则指向B的头部.\n    用nodeB标记位置, 如果B遍历结束, 则指向A的头部.\n    在此过程中, 如果nodeA = nodeB, 则相交位置为链表相交位置.\n\n    *但是这个algorithm其实依靠一个implicit条件: 如果相交, A,B链表之后的内容都是相同的*\n\n    这个其实题目并没有明确说明?\n\n\n4. 表尾对齐法\n\n    由于有上述的条件, 所以可以先让两个链表的尾部对齐(让长的list先遍历(m-n)个元素), 之后两个指针同步遍历就可以了","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826390290","body":"# Leetcode 142  #\n\n[142. Linked List Cycle II](https://leetcode.cn/problems/linked-list-cycle-ii/)\n\n**Ideas**\n\n由于昨天的Leetcode题目与此题类似, 所以非常容易想到用HashSet来储存已经遍历的node, 下一次如果出现同样的node, 即为cycle的开头.\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode tmp = head;\n        HashSet<ListNode> visited = new HashSet<>();\n        while(tmp != null){\n            if(visited.contains(tmp.next)){\n                return tmp.next;\n            }\n            visited.add(tmp);\n            tmp = tmp.next;\n        }\n        return null;\n        \n    }\n}\n```\n\n**Mistakes**\n\n在写的时候注意到了edge case, 但是重复考虑了. 本身while的condition就可以handle了.\n\n**Complexity**\n\nTime Complexity: O(n) # loop though every element in the LinkedList \nSpace Complexity: O(n) # at most store all the elements in the LinkedList\n\n\n**Improvment**\n\n提示可以使用双指针, 即快慢指针, 但我写的时候没想明白为什么他们相遇的地方会是环的入口. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1826906413","body":"# Leetcode 146 Nov 26 #\n\n[146. LRU Cache](https://leetcode.cn/problems/lru-cache/)\n\n**Ideas**\n\n想要Time complexity小, 又是存pairs, 我直接就考虑的HashMap, 当作cache. 对于如何实现LRU, 我考虑的用另外一个data structure去record visits\n\n如果visited Array 去keep track priority, set的时候是O(1), 但是retrieve的时候, 要遍历array里面的所有elements, 需要O(n)\n\n于是考虑LinkedList, 但是LinkedList的containsKey也需要O(n)时间. 如果要O(1)的话, 可以考虑其他data structure\n\n```java\nclass LRUCache {\n    HashMap<Integer, Integer> cache;\n    int size = 0;\n    LinkedList<Integer> LRU = new LinkedList<>();\n\n\n    public LRUCache(int capacity) {\n        cache = new HashMap<Integer, Integer>(capacity);\n        size = capacity;\n    }\n\n    public int get(int key) {\n        if(cache.get(key) == null)\n            return -1;\n        else {\n            LRU.remove((Integer) key);\n            LRU.add(key);\n            return cache.get(key);\n        }\n    }\n\n    public void put(int key, int value) {\n        if(cache.containsKey(key) || cache.size() < size){\n            LRU.remove((Integer) key);\n        }\n        else{\n            cache.remove(LRU.poll());\n        }\n        LRU.add(key);\n        cache.put(key, value);\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n题解里面是用Hashmap来encode node存放的位置, 并且把node包装成一个object(里面包括prev, next). 用LinkedList类似data structure去改变head, tail指向. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829118868","body":"# Leetcode 104 Nov 27 #\n\n[104. Maximum Depth of Binary Tree](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n\n**Ideas**\n\n因为是找最大深度, 所以立马想到的DFS. 本来还新建了一个stack去储存即将要visit的node. 但在写的时候发现, 如果用recursion的话, 其实不需要存哪一个是下一个visited的. 这里没有先后顺序, 都需要iterate through.\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        int depth = 1;\n        if(root == null) return 0;\n        if(root.left == null&& root.right == null){\n            return depth;\n        }\n        if(root.left == null){\n            return depth = depth + maxDepth(root.right);\n        }\n        if(root.right == null){\n            return depth = depth + maxDepth(root.left);\n        }\n        depth = depth + Math.max(maxDepth(root.left), maxDepth(root.right));\n        return depth;\n        }\n\n    }\n```\n\n一开始没有设置root == null的edge case, 所以分类了如果root.left是null怎么办, 如果root.right 是null 怎么办, 如果左右同时为null怎么办. 包括新加一个variable depth来record深度 但其实这些都可以在root== null的情况下return 0简化. \n\n所以最后其实只需要两行就可以结束\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;     \n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n        }\n\n    }\n```\n\n时间复杂度: O(n) [所有node都需要trace一遍]\n\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831183114","body":"# Leetcode 100 Nov 28 #\r\n\r\n[100. Same Tree](https://leetcode.cn/problems/same-tree/)\r\n\r\n**Ideas**\r\n\r\n思考的时候就考虑遍历root, 然后left node, right node. 每一层都如此遍历, 就做成了递归. \r\n\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n      // edge case when p/ q== null\r\n        if((p != null && q== null)|| (p == null && q!= null))\r\n            return false;\r\n        if(p==null&&q==null) return true;\r\n\r\n        if(p.val != q.val)\r\n            return false;\r\n        if(!isSameTree(p.right, q.right)||!isSameTree(p.left, q.left))\r\n            return false;\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n在翻看大家的回复和官方题解时发现我的代码还是不够简洁. \r\n\r\n处理edge case的时候, 如果p,q同时为null, 则return true. 如果此时再有任一个为null, 则必是either p== null or q== null, 不会出现同时为null的情况, 所以可以直接return false. \r\n\r\n最后判断是否为sameTree的时候, 可以不用多加一行判断之后return false, 而是直接isSameTree(p.right, q.right)&&isSameTree(p.left, q.left);必须同时满足左右subtree都是same tree才能return true;\r\n\r\n简化后的版本:\r\n\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p==null&&q==null) return true;\r\n        if(p == null || q== null)\r\n            return false;\r\n\r\n        if(p.val != q.val)\r\n            return false;\r\n        return isSameTree(p.right, q.right)&&isSameTree(p.left, q.left);\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1833170447","body":"# Leetcode 129 Nov 30 #\n\n[129. Sum Root to Leaf Numbers](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/)\n\n```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return DFS(root, 0);\n    }\n\n    public int DFS(TreeNode root, int cur) {\n        if (root == null) return 0;\n        cur = cur * 10 + root.val;\n        if (root.left == null && root.right == null) return cur;\n        return DFS(root.left, cur) + DFS(root.right, cur);\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/17#issuecomment-1836248708","body":"```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int res = -1;\n        if(root == null){\n            return -1;\n        }\n        LinkedList<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while(!q.isEmpty()){\n            TreeNode node = q.poll();\n            if(node.right != null){\n                q.add(node.right);\n                \n            }\n            if(node.left != null){\n                q.add(node.left);\n               \n            }\n            res = node.val;\n        }\n        \n\n        return res;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1837064473","body":"# Leetcode 597 Dec 1 #\n\n[297. Serialize and Deserialize Binary Tree](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/)\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n    \n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        String res = \"[\";\n        if (root == null) {\n            return \"]\";\n        }\n        LinkedList<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node != null) {\n                res = res + node.val + \", \";\n                queue.add(node.left);\n                queue.add(node.right);\n\n            } else res = res + \"n, \";\n        }\n            return res.substring(0, res.length() - 2) + \"]\";\n\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if(data.length()<=2)\n             return null;\n         data = data.substring(1,data.length()-1);\n         if(data.length() == 1)\n             return new TreeNode(Integer.parseInt(data));\n         if(data.length() == 2){ // [4, 5]\n             TreeNode root = new TreeNode(Integer.parseInt(data.substring(0,1)));\n             root.left = new TreeNode(Integer.parseInt(data.substring(1,2)));\n             return root;\n         }\n         String[] nodes = data.split(\", \");\n         TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));;\n        LinkedList<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n         int p1 = 0; int p2 = 1; int p3 = 2;\n         while(p3<nodes.length&&!queue.isEmpty()){\n             TreeNode curr_node = queue.poll();\n             String lf = nodes[p2];\n             String rig = nodes[p3];\n             if(!lf.equals(\"n\")){\n                 curr_node.left = new TreeNode(Integer.parseInt(lf));\n                 queue.add(curr_node.left);\n             }\n             if(!rig.equals(\"n\")){\n                 curr_node.right = new TreeNode(Integer.parseInt(rig));\n                 queue.add(curr_node.right);\n             }\n             p1++;\n             p2=p2+2;\n             p3= p3+2;\n\n         }\n         return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1838916813","body":"```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] res = new int[2];\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i<nums.length; i++) {\n            int num = nums[i];\n            if(map.containsKey(target - nums[i])){\n                res[0] = i;\n                res[1] = map.get(target - num);\n                return res;\n            }\n            else {\n                map.put(num, i);\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/22#issuecomment-1843178038","body":"```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n      if (points == null || points.length <= 2)\n        return 0;\n      int res = 0;\n      for(int i = 0; i< points.length; i++){\n        HashMap <Integer, Integer> hashmap = new HashMap<>();\n          for(int j = 0; j<points.length; j++){\n            int dx = points[i][0] - points[j][0];\n            int dy = points[i][1] - points[j][1];\n            int dis = dx * dx + dy * dy;\n            hashmap.put(dis, hashmap.getOrDefault(dis, 0) + 1);\n          }\n          for(int val : hashmap.values()){\n            res += val * (val - 1);\n          }\n      }\n      return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1844475392","body":"```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if(s.length() == 0)\n            return 0;\n        int res = 0;\n        HashMap<Character, Integer> hashmap = new HashMap<>();\n        int i = 0; int j = 0;\n        while(i < s.length()){\n            j = i;\n            while(j < s.length()){\n                if(hashmap.containsKey(s.charAt(j))){\n                    if(res < hashmap.size())\n                        res = hashmap.size();\n                    i = hashmap.get(s.charAt(j)) + 1;\n                    hashmap.clear();\n                    break;\n                }\n                else {\n                    hashmap.put(s.charAt(j), j);\n                    j++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/24#issuecomment-1847409810","body":"```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n      List<Integer> res = new ArrayList<>();\n      if(words.length == 0)\n        return res;\n        \n      List<String> wordsList = Arrays.asList(words);\n      // 用sort代替比较次数\n      Collections.sort(wordsList);\n\n      //有几个单词\n      int numberofWords = words.length;\n      //每个单词长度\n      int wordLen = words[0].length();\n      int totalLen = numberofWords * wordLen;\n      // handle edge case\n      if (s.length() < totalLen) {\n        return res;\n      }\n      for (int i = 0; i <= s.length() - totalLen; i++) {\n        String subStr = s.substring(i, i + totalLen);\n        List<String> possiblewordList = new ArrayList<>();\n        for (int k = 0; k < subStr.length(); k = k + wordLen) {\n          possiblewordList.add(subStr.substring(k, k + wordLen));\n        }\n        // 用sort代替比较次数\n        Collections.sort(possiblewordList);\n        if (possiblewordList.equals(wordsList)) {\n          res.add(i);\n        }\n      }\n      return res;\n    }\n    \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/25#issuecomment-1848273946","body":"使用前缀和之后暴力iterate, 最后五个test太大了, 超出时间限制了\n```java\npublic class Solution {\n    public static int minSubarray(int[] nums, int p) {\n        int res = Integer.MAX_VALUE;\n        long[] presum = new long[nums.length + 1];\n        presum[0] = 0;\n        for (int i = 0; i < nums.length; i++) {\n            presum[i + 1] = presum[i] + nums[i];\n            //System.out.println(presum[i+1]);\n\n        }\n\n        long remove = presum[presum.length - 1] % p;\n\n        //System.out.println(\"remove\" + remove);\n        if (remove == 0)\n            return 0;\n        for (int i = 0; i < presum.length; i++) {\n            for (int j = i + 1; j < presum.length; j++) {\n                //System.out.println(presum[j] - presum[i]);\n                long hey = presum[j] - presum[i];\n                long left = (presum[j] - presum[i]);\n                if ((presum[j] - presum[i] - remove) % p == 0) {\n                    if (res > (j - i)) {\n                        System.out.println(\"j\" + j);\n                        System.out.println(\"i\" + i);\n                        res = j - i;\n                    }\n                }\n            }\n        }\n        if (res == Integer.MAX_VALUE || res == nums.length)\n            res = -1;\n        return res;\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/26#issuecomment-1848834929","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if(head == null){\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast.next != null){\n            slow = slow.next;\n            if(fast.next.next == null){\n                fast =fast.next;\n            }else fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```\n本来的想法是双指针, 一个指针指向头部, 一个指针指向尾部. 然后同时向中间靠拢. 当两指针相遇是为最中间的元素. 但是需要先iterate一遍找到尾部. \n这题也可以使用快慢指针.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849054137","body":"本来考虑的是用一个pointer和一个arraylist/ 两个pointers和两个array, 但是最后发现arraylist/array传回去又要iterate through. 所以就考虑直接改变nums的值.\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums == null){\n            return 0;\n        }\n        int j = 1;\n        for(int i = 0; i<nums.length-1; i++){\n            if(nums[i] != nums[i+1]){\n                nums[j] = nums[i+1];\n                j++;\n            }\n        }\n        return j;\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/33#issuecomment-1859194506","body":"将四种情况和对应的坐标变化依次列出来就可以了\n```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        for (int i = 0; i < moves.length(); i++) {\n            char c = moves.charAt(i);\n            if (c == 'U') {\n                y--;\n            } else if (c == 'D') {\n                y++;\n            } else if (c == 'L') {\n                x--;\n            } else if (c == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}\n```\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/37#issuecomment-1865571160","body":"```java\nclass Solution {\n\n    public int[] sortArray(int[] nums) {\n        mergeSort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    public void mergeSort(int[] arr, int l, int r){\n        if(l >= r){\n            return;\n        }\n        int mid = (int)Math.floor((l+r)/2);\n        mergeSort(arr, l, mid);\n        //int[] left = Arrays.copyOfRange(arr, l, mid);\n        mergeSort(arr, mid +1, r);\n        //int[] right = Arrays.copyOfRange(arr, mid+1, r);\n        merge(arr, l, mid, r);\n    }\n\n    public void merge(int[] arr, int left, int mid, int right){\n        int[] res = new int[right -left + 1];\n        int i = left, j = mid + 1;\n        int index = 0;\n        while (i <= mid && j <= right) {\n            if (arr[i] <= arr[j]) {\n                res[index++] = arr[i++];\n            } else {\n                res[index++] = arr[j++];\n            }\n        }\n        if (i <= mid) System.arraycopy(arr, i, res, index, mid - i + 1);\n        if (j <= right) System.arraycopy(arr, j, res, index, right -j + 1); \n        System.arraycopy(res,0,arr,0+left,right-left+1);\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/38#issuecomment-1867830880","body":"```java\nclass Solution {\n    public int mySqrt(int x) {\n        if(x == 1)\n            return 1;\n        int left=0;\n        int right=46340;\n        while(left <= right){\n            int mid = left+(right-left)/2;\n            if(mid*mid == x) return mid;\n            if(mid*mid>x) right=mid-1;\n            if(mid*mid < x) left = mid + 1;\n        }\n        return right; // 因为是round down\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/39#issuecomment-1868316707","body":"```java\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        if(n == 1){\n            return 1;\n        }\n        int left = 1;\n        int right = n;\n        while(left <= right){\n            int mid = left + (right - left)/2;\n             // mid -> true; mid -1 -> false\n            if(isBadVersion(mid)&&!isBadVersion(mid -1)){\n                return mid;\n            }\n        \n            // mid -> true; 从left到mid-1找\n            if(isBadVersion(mid)) right = mid -1;\n            // mid -> false; 从mid +1 到right找\n            else left = mid + 1;\n        }\n        return right;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/42#issuecomment-1869216022","body":"先来打个卡, 完全没意识到这是一个二分法的题目, 借鉴了题解写的二分法.\n```java\nclass Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int left = 0; int right = nums[nums.length-1] - nums[0];\n        while(left <= right){\n            int mid = (left + right)/2;\n            if (count_not_greater(nums, mid) < k) {\n                left = mid + 1;\n            } else {\n                right = mid -1;\n            }\n        }\n        return left;\n    }\n    public long count_not_greater(int[] nums, int targetDiff) {\n        int n = nums.length, count = 0;\n        for (int i = 0, j = 1; i < n; i++) {\n            while (j < n && nums[j] - nums[i] <= targetDiff) j++;\n            count += j - i - 1;\n        }\n        return count;\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/43#issuecomment-1869945782","body":"## Leetcode Dec 26 ##\n\n[778. Swim in Rising Water](https://leetcode.cn/problems/swim-in-rising-water/)\n\n确实很难想到是二分法. \n根据题解, 因为是有限解空间, 所以可以二分法.\n首先就要先找到解空间,上界和下界.然后运用dfs来判断\n\n\n```java\nclass Solution {\n    public boolean dfs(int mid, int x, int y, boolean[][] visited, int[][] grid){\n        if (x > grid.length - 1 || x < 0 || y > grid[0].length - 1 || y < 0) return false;\n        if (grid[x][y] > mid) return false;\n        if(x == grid.length - 1&& y == grid[0].length - 1) return true;\n        if (visited[x][y]) return false;\n        visited[x][y] = true;\n        return dfs(mid, x + 1, y, visited, grid) || dfs(mid, x - 1, y, visited, grid) || dfs(mid, x, y + 1, visited, grid) || dfs(mid, x, y - 1, visited, grid);\n    }\n    public int swimInWater(int[][] grid) {\n        int l = 0;\n        int r = Integer.MAX_VALUE;\n        //先找出解空间\n        for(int i = 0; i< grid.length; i++){\n            for(int j = 0; j<grid[0].length; j++){\n                if(r<grid[i][j]){\n                    r = grid[i][j];\n                }\n            }\n        }\n        // 二分法\n        while (l <= r) {\n            boolean[][] visited = new boolean[grid.length][grid[0].length];\n            int mid = l + (r - l) / 2;\n            if (dfs(mid, 0, 0, visited, grid)) {\n                r = mid - 1; // 成为一个备胎, 但不一定是最小的\n            } else {\n                l = mid + 1; // head towards 最小的选项\n            }\n        }\n        return l;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/44#issuecomment-1870594362","body":"## Leetcode 1456 Dec 27 ##\n\n[1456. Maximum Number of Vowels in a Substring of Given Length\n](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)\n\n今天的题目主要是考察滑动窗口. 在一个固定长度区间内找最值问题\n滑动窗口主要是需要利用之前的信息, 而不是每一次重新计算.\n本来还构建了一个linkedlist的窗口结构, 结果发现其实没必要.\n\n*可以改进的地方:*\n*严谨一些, edge case还是需要handle的*\n\n\n```java\nclass Solution {\n     public int maxVowels(String s, int k) {\n        int maxcount = 0;\n        int count = 0;\n        // initialize the window\n        //LinkedList<Character> window = new LinkedList<Character>();\n        int right = 0;\n        while(right < s.length()){\n            if(right >= k){ // 至少已经有一个比k大的窗口了\n                if(isVowel(s.charAt(right - k))) count--;\n            }\n            if(isVowel(s.charAt(right))) count++;\n            if(count > maxcount) maxcount = count;\n            right++;\n        }\n        return maxcount;\n    }\n    public boolean isVowel(char c){\n        if(c=='a'||c=='e'||c=='i'||c=='o'|c=='u'){\n           return true;\n        }\n        else return false;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/45#issuecomment-1872184400","body":"今天的题求的是Alice获胜的概率.\n\n主要这题的遍历顺序是从后往前的, 与常规思路不同, 是从未来的游戏推断之前的情况的概率.\n\n思路参考: https://leetcode.cn/problems/new-21-game/solutions/273085/huan-you-bi-zhe-geng-jian-dan-de-ti-jie-ma-tian-ge/\n```java\nclass Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        double dp[] = new double[k+maxPts]; // dp[x]为Alice手上所有牌面为x时，能获胜的概率\n        double s = 0;\n        for(int i = k; i<k+maxPts;i++){\n            if(i<= n)   dp[i] = 1;\n            else dp[i] = 0;\n            s = s+dp[i];\n        }\n    \n        for(int i = k-1; i>-1; i--){\n            dp[i]= s/maxPts;\n            s=s-dp[i+maxPts] + dp[i];\n        }\n        return dp[0];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/46#issuecomment-1872380195","body":"今天的题我感觉并不容易, 滑动窗口的算法很好理解, 但是对我来说难的是如何更新窗口里面的内容.\n\n因为会涉及到重复字母出现, 和多个字母同时符合才符合. 所以我其实蛮昏的\n\n参考了题解:https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/9749/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n\t\t// 首先，初始化 window 和 need 两个哈希表，记录窗口中的字符和需要凑齐的字符：\n        HashMap<Character, Integer> need = new HashMap<>();\n\t\tHashMap<Character, Integer> window = new HashMap<>();\n        List<Integer> res = new ArrayList<Integer>();\n\t\tfor(int i = 0; i< p.length(); i++){\n            char m = p.charAt(i);\n\t\t\tneed.put(m, need.getOrDefault(m, 0) + 1);\n\t\t}\n    \n        int left = 0, right = 0;\n        int valid = 0; \n        while (right < s.length()) {\n            // c 是将移入窗口的字符\n            char c = s.charAt(right);\n            // 右移窗口\n            right++;\n            // 进行窗口内数据的一系列更新\n            if(need.containsKey(c)){\n                //更新; occurence + 1\n                window.put(c, window.getOrDefault(c, 0) + 1);\n                // 如果occurence符合, 那么此字母valid\n                if(window.get(c).equals(need.get(c))){\n                    valid ++;\n                }\n                // 是否会出现 occurence 符合, 但是有无用字符在其中?\n                // 答: 不会,因为下面判断的时候, 需要need.size == valid\n            }\n        //System.out.println(\"window: \" + left +right);\n       \n            // 判断左侧窗口是否要收缩\n            while (right - left >= p.length()) {\n                if (valid == need.size())\n                    res.add(left);\n                // d 是将移出窗口的字符\n                char d = s.charAt(left);\n                // 左移窗口\n                left++;\n                // 进行窗口内数据的一系列更新\n                if (need.containsKey(d)) {\n                    // Wrap-up class 不能直接用==, 需要用.equals\n                    if(window.get(d).equals(need.get(d)))\n                        valid--;\n                    window.put(d, window.getOrDefault(d, 0) - 1);\n                }\n            }\n        }\n        return res;\n    }\n    \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/47#issuecomment-1872624657","body":"# Day 46 **[76. Minimum Window Substring](https://leetcode.cn/problems/minimum-window-substring/)**\n\n其实今天的代码与昨天的挺像的, 昨天是要完全一致, 今天是include\n\n一开始很困惑滑动窗口怎么用, 因为是不定长度的窗口. 看了提示, 感觉非常像高中讲过的夹逼原理\n\n先固定右窗口的位置(确认包含所有character), 再固定左窗口的位置(找到minlen). \n\n基本上还是套用昨天的模版, 但是左窗口收缩部分进行了改动.\n```java\nclass Solution {\n    public String minWindow(String s, String t) {\n        // 首先，初始化 window 和 need 两个哈希表，记录窗口中的字符和需要凑齐的字符：\n        HashMap<Character, Integer> need = new HashMap<>();\n\t\tHashMap<Character, Integer> window = new HashMap<>();\n        int minlen = Integer.MAX_VALUE;\n        String res = \"\";\n\t\tfor(int i = 0; i< t.length(); i++){\n            char m = t.charAt(i);\n\t\t\tneed.put(m, need.getOrDefault(m, 0) + 1);\n\t\t}\n    \n        int left = 0, right = 0;\n        int valid = 0; \n        while (right < s.length()) {\n            // c 是将移入窗口的字符\n            char c = s.charAt(right);\n            // 右移窗口\n            right++;\n            // 进行窗口内数据的一系列更新\n            if(need.containsKey(c)){\n                //更新; occurence + 1\n                window.put(c, window.getOrDefault(c, 0) + 1);\n                // 如果occurence符合, 那么此字母valid\n                if(window.get(c).equals(need.get(c))){\n                    valid ++;\n                }\n            }\n        //System.out.println(\"window: \" + left +right);\n       \n            // 判断左侧窗口是否要收缩\n            while (right - left >= t.length()&& valid == need.size()){\n                if(minlen > right - left + 1){\n                    res = s.substring(left, right);\n                }\n                minlen = Math.min(minlen, right - left + 1);\n                // d 是将移出窗口的字符\n                char d = s.charAt(left);\n                // 左移窗口\n                left++;\n                // 进行窗口内数据的一系列更新\n                if (need.containsKey(d)) {\n                    // Wrap-up class 不能直接用==, 需要用.equals\n                    if(window.get(d).equals(need.get(d)))\n                        valid--;\n                    window.put(d, window.getOrDefault(d, 0) - 1);\n                }\n            }\n        }\n        return res;\n        \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/48#issuecomment-1873047831","body":"# Day47 **[1423. Maximum Points You Can Obtain from Cards](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)**\n\n一开始拿到题目以为是一个简单的dp题, 后来发现只考虑当前情况下的两端不对, 所以dp似乎不能解决.\n\n看到最大值, 而且总数值是固定的, 就想到逆向思维求中间的最小值. 但是一开始进入了误区, 想着从最中间开始, 向两边延伸. 这种还是没绕开要考虑当前情况下的两端, 只是换了一个方向而已. \n\n之后看的提示用滑动窗口, 一下意识到是窗口长度为n-k求滑动窗口最小值. 所以还是套用了前两天的模版, 稍微进行了改动.\n\n```java\nclass Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        // window的大小是cardPoints.length - k\n        int left = 0, right = 0;\n        int total = 0; int min = Integer.MAX_VALUE;\n        int sum = 0;\n\n        for(int i = 0; i<cardPoints.length; i++){\n            sum+= cardPoints[i];\n        }\n\n        while (right < cardPoints.length) {\n            // c 是将移入窗口的数字\n            int c = cardPoints[right];\n            total += c;\n            // 需要另加一个if语句, 因为此处如果窗口大小比n-k小, 则不是一个valid的最小值\n            if(right - left < cardPoints.length - k) min = total;\n             // 右移窗口, 但注意需要在if语句之后, 否则会影响right的值\n            right++;\n            \n            // 判断左侧窗口是否要收缩\n            while (right - left > cardPoints.length - k) {\n                // d 是将移出窗口的数字\n                int d = cardPoints[left];\n                // 左移窗口\n                left++;\n                // 进行窗口内数据的一系列更新\n                total -= d;\n                min = Math.min(total, min);\n            }\n        }\n        return sum - min;\n    }\n} \n```   \n\n时间复杂度: O(n)         # n 为cardPoints的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/49#issuecomment-1874180331","body":"说是简单题, 但感觉一点也不简单. 利用backtracking进行枚举, 在有必要的情况下剪枝.\n```java\nclass Solution {\n    int[] hours = new int[]{1, 2, 4, 8, 0, 0, 0, 0, 0, 0};\n    int[] minutes = new int[]{0, 0, 0, 0, 1, 2, 4, 8, 16, 32};\n    List<String> res = new ArrayList<>();\n\n    public List<String> readBinaryWatch(int num) {\n        backtrack(num, 0, 0, 0);\n        return res;\n    }\n\n    public void backtrack(int num, int index, int hour, int minute){\n        if(hour > 11 || minute > 59) \n            return;\n        if(num == 0){\n            StringBuilder sb = new StringBuilder();\n            sb.append(hour).append(':');\n            if (minute < 10) {\n                sb.append('0');\n            }\n            sb.append(minute);\n            res.add(sb.toString());\n            return;\n        }\n        for(int i = index; i < 10; i++){\n            backtrack(num - 1, i + 1, hour + hours[i], minute + minutes[i]);\n        }  \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/50#issuecomment-1874642817","body":"## **[52. N-Queens II](https://leetcode.cn/problems/n-queens-ii/)**\n\n参考官方题解\n\nhttps://leetcode.cn/problems/n-queens-ii/solutions/449388/nhuang-hou-ii-by-leetcode-solution/\n\n我的理解是: 基于排的回溯. 由于每排至多有一个Queens, 每一次更新后首先查看是否已经有皇后在列/diagonal里面. 这里不用排查排, 是因为我们就是按照排的顺序进行的.\n\n当row排到最后一行时, 说明有一个valid解.\n\n当确定了row, 只剩下一个纬度- column需要确定, 即可确定位置. \n\n在确定diagonal的时候, 我本来的思路是用一个int[][]去keep track 哪一些位置是valid, 用1 表示; 哪一些位置是不能放queens的, 用0 表示. 但是复杂度太高了, 每次都要iterate over array 去更新.  这里是观察到对于diagonal, row -col 和row + col的关系. \n\n如果没在这一行找到valid放置位置, 直接count return 0. 因为是穷举法, 所以每次只产生一个valid解. 所以可以用+=. \n\n```java\nclass Solution {\n    public int totalNQueens(int n) {\n        Set<Integer> columns = new HashSet<Integer>();\n        Set<Integer> diagonals1 = new HashSet<Integer>();\n        Set<Integer> diagonals2 = new HashSet<Integer>();\n        return backtrack(n, 0, columns, diagonals1, diagonals2);\n    }\n\n    public int backtrack(int n, int row, Set<Integer> columns, Set<Integer> diagonals1, Set<Integer> diagonals2) {\n        if (row == n) { // iterate到最后一行了, 因为row是从0开始的. \n            return 1;\n        } else {\n            int count = 0; \n            for (int col = 0; col < n; col++) {\n                if (columns.contains(col)) {\n                    continue;\n                }\n                int diagonal1 = row - col;\n                if (diagonals1.contains(diagonal1)) {\n                    continue;\n                }\n                int diagonal2 = row + col;\n                if (diagonals2.contains(diagonal2)) {\n                    continue;\n                }\n                columns.add(col);\n                diagonals1.add(diagonal1);\n                diagonals2.add(diagonal2);\n                count += backtrack(n, row + 1, columns, diagonals1, diagonals2);\n                columns.remove(col);\n                diagonals1.remove(diagonal1);\n                diagonals2.remove(diagonal2);\n            }\n            return count;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/54#issuecomment-1875993833","body":"## [Leetcode 695. Max Area of Island](https://leetcode.cn/problems/max-area-of-island/description/)\n先贴上最终代码\n\n其实今天的题真的蛮基础的, dfs遍历四个方向+一个visited array来记录是否visited. \n\n题解里甚至还提供了原位修改的思路. \n\n```java\nclass Solution {\n    int maxarea = 0;\n    int[][] visited;\n\n    public int maxAreaOfIsland(int[][] grid) {\n        visited = new int[grid.length][grid[0].length];\n        for(int i = 0; i<grid.length; i++){\n            for(int j = 0; j< grid[0].length; j++){\n                if(grid[i][j] == 1&& visited[i][j] != 1){\n                    maxarea = Math.max(dfs(grid, i, j, 1), maxarea);\n                }\n\n            }\n        }\n        return maxarea;\n    }\n    // return max area for that region\n    //因为遍历的顺序是从row-major order, 而且求的是max, 所以不考虑左和上了\n    public int dfs(int[][] grid, int start_i, int start_j, int area){\n        visited[start_i][start_j] = 1;\n        if(start_i + 1 < grid.length&& grid[start_i + 1][start_j] == 1){\n            if(visited[start_i + 1][start_j] != 1) {\n                area = dfs(grid, start_i + 1, start_j, area + 1);\n            }\n        }\n\n        if(start_j + 1 < grid[0].length&& grid[start_i][start_j + 1] == 1){\n            if(visited[start_i][start_j + 1] != 1)\n                area = dfs(grid, start_i, start_j + 1, area + 1);\n        }\n\n        if(start_i - 1 >= 0 && grid[start_i - 1][start_j] == 1){\n            if(visited[start_i - 1][start_j] != 1)\n                area = dfs(grid, start_i - 1, start_j, area + 1);\n        }\n\n        if(start_j - 1 >= 0&& grid[start_i][start_j - 1] == 1){\n            if(visited[start_i][start_j - 1] != 1)\n                area = dfs(grid, start_i, start_j - 1, area + 1);\n        }\n\n        return area;\n    }\n}\n```\n\n加上复杂度分析🧐\n\nTime Complexity: O(m*n) # 每个网格遍历一次\n\nSpace Complexity: O(m * n) # 有一个visited array[m * n]\n\n-------\n\n😭但一开始, 基础不牢靠的我, 愣是没想到用visited来记录.  \n\n也用了dfs的思想, 想要只考虑右和下, 然后特殊情况进行特殊考虑. 但是这个思考量有点大, 挣扎40min, debug不出来就放弃了.\n\n看了别人的思路, 豁然开朗. 这下是记住dfs + visited. \n\n```java\nclass Solution1 {\n    int maxarea = 0;\n\n    public int maxAreaOfIsland(int[][] grid) {\n        for(int i = 0; i<grid.length; i++){\n            for(int j = 0; j< grid[0].length; j++){\n                if(grid[i][j] == 1){\n                    maxarea = Math.max(dfs(grid, i, j, 1), maxarea);\n                }\n\n            }\n        }\n        return maxarea;\n    }\n    // return max area for that region\n    //因为遍历的顺序是从row-major order, 而且求的是max, 所以不考虑左和上了\n    public int dfs(int[][] grid, int start_i, int start_j, int area){\n        if(start_i + 1 < grid.length&& grid[start_i + 1][start_j] == 1){\n            area = dfs(grid, start_i + 1, start_j, area + 1);\n        }\n\n        if(start_j + 1 < grid[0].length) {\n            if (grid[start_i][start_j + 1] == 1) {\n                area = dfs(grid, start_i, start_j + 1, area + 1);\n            } else if(start_j + 2 < grid[0].length && grid[start_i][start_j + 2] == 1 && start_i + 1 < grid.length && grid[start_i + 1][start_j + 1] == 1 && grid[start_i + 1][start_i + 2] == 1 ) {\n                area = dfs(grid, start_i, start_j + 1, area);\n            }\n        }\n\n        // 一旦出现倒三角, 则duplicate了一次, area-1\n        if(start_i + 1 < grid.length&& grid[start_i + 1][start_j] == 1 && start_j + 1 < grid[0].length&& grid[start_i][start_j + 1] == 1 && grid[start_i+1][start_j + 1] == 1){\n            area --;\n        }\n\n        return area;\n    }\n}\n```\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/56#issuecomment-1879504695","body":"```java\nclass Solution {\n    public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\n        int res = 0;\n        // queue 表示即将访问的盒子(有钥匙也有盒子的)\n        Queue<Integer> q = new LinkedList<>();\n        // keyset 表示已经找到的钥匙\n        HashSet<Integer> keyset = new HashSet<>();\n        // boxset 表示已经找到的盒子\n        HashSet<Integer> boxset = new HashSet<>();\n        for (int i : initialBoxes)\n            if (status[i] == 1)\n                q.add(i);\n            //一开始把这个漏掉了, 所以怎么都过不了tests\n            else boxset.add(i);\n\n        while(!q.isEmpty()){\n            int open_box = q.poll();\n            res += candies[open_box];\n            //先把找到的key存入keyset里面\n            for(int i: keys[open_box]){\n                keyset.add(i);\n            }\n            //再把打开的新盒子放到queue或者是boxset里面\n            for (int i : containedBoxes[open_box]) {\n                if (status[i] == 1)\n                    q.add(i);\n                else boxset.add(i);\n            }\n            // 最后看看有无之前找到盒子, 现在找到钥匙\n            //之前找到钥匙, 现在又有盒子的情况\n            for(int i: boxset){\n                if(status[i] == 0 && keyset.contains(i)){\n                    status[i] = 1;\n                    q.add(i);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n时间复杂度: O(n^2)  # boxset里面最多存了所有的element + queue至多循环所有的box\n\n空间复杂度: O(n)    # keyset, boxset 和 queue都至多存了所有可能的box elements","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/57#issuecomment-1880097083","body":"其实整体思路不难, 我主要是卡壳在最后如何把HashMap放到res里面\n参考: https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/solutions/906335/gong-shui-san-xie-yi-ti-shuang-jie-dfs-h-wfm3/\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        Map<TreeNode, int[]> m = new HashMap<>(); // treenode.val, row, col\n        Queue<TreeNode> q = new LinkedList<>();\n\n        m.put(root, new int[]{0, 0, root.val});\n        q.add(root);\n\n        while(!q.isEmpty()){\n            TreeNode cur = q.poll();\n            if(cur.left != null){\n                m.put(cur.left, new int[]{m.get(cur)[0] + 1, m.get(cur)[1]- 1, cur.left.val});\n                q.add(cur.left);\n            }\n\n            if(cur.right != null){\n                m.put(cur.right, new int[]{m.get(cur)[0] + 1, m.get(cur)[1] + 1, cur.right.val});\n                q.add(cur.right);\n            }\n\n        }\n\n        List<int[]> list = new ArrayList<>(m.values());\n        Collections.sort(list, (a, b)->{\n            if (a[1] != b[1]) return a[1] - b[1];\n            if (a[0] != b[0]) return a[0] - b[0];\n            return a[2] - b[2];\n        });\n\n        int n = list.size();\n        for (int i = 0; i < n; ) {\n            int j = i;\n            List<Integer> tmp = new ArrayList<>();\n            while (j < n && list.get(j)[1] == list.get(i)[1]) tmp.add(list.get(j++)[2]);\n            res.add(tmp);\n            i = j;\n        }\n        return res;\n    }\n}\n```\n时间复杂度: 令总节点数量为 n，填充哈希表时进行树的遍历，O(n)；写入res时需要排序，O(nlog⁡n)。整体复杂度为 O(nlog⁡n)\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/58#issuecomment-1880451753","body":"虽然说是简单题, 但是我一拿到手还是没立马想到dp. 看了tag说是dp才恍然大悟...\n然后思路就自然而然的出来了.\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        // dp array 里面放着climb到这个stair的min cost\n        int[] dp = new int[cost.length + 1];\n        dp[0] = 0;\n        dp[1] = 0;\n        for(int i = 2; i<= cost.length; i++){\n            dp[i] = Math.min(dp[i-2] + cost[i-2], dp[i-1] + cost[i-1]);\n        }\n        return dp[cost.length];\n\n    }\n}\n```\n\nTime Complexity: O(n)\n\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/59#issuecomment-1882231180","body":"其实今天的思路并不难，但是主要要考虑到选择两个可以中间隔很多的，比如2112的情况\r\n```java\r\nclass Solution {\r\n    public int rob(int[] nums) {\r\n        if(nums.length == 1) return nums[0];\r\n        if(nums.length == 2) return Math.max(nums[0],nums[1]);\r\n        if(nums.length == 3) return Math.max(nums[0]+ nums[2], nums[1]);\r\n        // dp array这里记录了前k间房间能偷盗的最大值\r\n        int[] dp = new int[nums.length];\r\n        dp[0] = nums[0];\r\n        dp[1] = nums[1];\r\n        dp[2] = Math.max(nums[0]+ nums[2], nums[1]);\r\n        \r\n        for(int i= 3;i<nums.length; i++){\r\n            dp[i] = Math.max(Math.max(dp[i-1], dp[i-2] + nums[i]), dp[i-3]+ nums[i]);\r\n        }\r\n        return dp[nums.length-1];\r\n    }\r\n}\r\n```\r\nTime complexity：O(n)\r\n    \r\nSpace complexity: O(n)\r\n\r\n看了题解，发现之前自己一开始的思路是对的，就是忘记在dp[1]的时候用max函数了🤯🤯🤯\r\n```java\r\n\r\nclass Solution {\r\n    public int rob(int[] nums) {\r\n        if(nums.length == 1) return nums[0];\r\n        if(nums.length == 2) return Math.max(nums[0],nums[1]);\r\n        // dp array这里记录了前k间房间能偷盗的最大值\r\n        int[] dp = new int[nums.length];\r\n        dp[0] = nums[0];\r\n        dp[1] = Math.max(nums[0],nums[1]);\r\n        \r\n        for(int i= 2;i<nums.length; i++){\r\n            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\r\n        }\r\n        return dp[nums.length-1];\r\n    }\r\n}\r\n\r\n```\r\n\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/62#issuecomment-1888385042","body":"今天的题还算dp里面比较简单的，主要注意[1][1]时候值为1\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n    if(m== 1&&n==1){\n        return 1;\n    }\n    dp[0][0] = 0;\n    if(n>1) dp[0][1] = 1;\n    if(m>1) dp[1][0] = 1;\n        \n    for(int i= 0;i < m; i++){\n        for(int j= 0; j<n;j++){\n            if(i -1>= 0){\n                dp[i][j] += dp[i-1][j];\n            }\n            \n            if(j-1>= 0){\n                dp[i][j] += dp[i][j-1];\n            }\n            \n        }\n    }\n         return dp[m-1][n-1];\n    }\n}\n```\nTime complexity：O（m*n）# 两个for loop\n\nSpace Complexity：O（m*n）# 一个2D array","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joe-the-plumber":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818151042","body":"```\r\nclass Stack(object):\r\n    def __init__(self):\r\n        self.stack = []\r\n\r\n    def push(self, x):              # 入栈\r\n        self.stack.append(x)\r\n\r\n    def pop(self):                  # 出栈\r\n        if self.is_empty:           # 注意特殊情况\r\n            return None\r\n        return self.stack.pop()\r\n\r\n    @property\r\n    def length(self):               # 获取栈中元素\r\n        return len(self.stack)\r\n    \r\n    @property                      \r\n    def is_empty(self):            # 获取栈的状态：是否为空\r\n        return self.length == 0\r\n\r\n\r\n\r\nclass MyQueue:\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1 = Stack()                           # 基本栈\r\n        self.stack2 = Stack()                           # 辅助栈\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.stack1.push(x)                             # 入栈，即入队列\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        while self.stack1.length > 1:                   # 卡住要出栈的最后一个元素\r\n            self.stack2.push(self.stack1.pop())         # 其他元素倒进辅助栈\r\n        res = self.stack1.pop()                         # 那个被卡住的元素就是所需\r\n        while not self.stack2.is_empty:                 # 只要辅助栈不为空\r\n            self.stack1.push(self.stack2.pop())         # 辅助栈中的元素倒回基本栈\r\n        return res                                      # 返回栈底元素即为出队队头\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        while self.stack1.length > 1:                   # 卡住要出栈的最后一个元素\r\n            self.stack2.push(self.stack1.pop())         # 其他元素倒进辅助栈\r\n        res = self.stack1.pop()                         # 那个被卡住的元素就是所需\r\n        self.stack2.push(res)                           # 记得把被卡住的元素放回\r\n        while self.stack2.length > 0:                   # 只要辅助栈不为空\r\n            self.stack1.push(self.stack2.pop())         # 辅助栈中的元素倒回基本栈\r\n        return res                                      # 返回栈底元素即为出队队头\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        return self.stack1.is_empty                     # 队列的状态即为基本栈的状态\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822140555","body":"官方题解的python最好改一下。。。现在版本实在不行。。。\n\nanyway,  c++ here, we go!\n```\n//    获取链表的长度\n//   k = k % 链表的长度\n\n//   获取倒数第k + 1,倒数第K个节点与链表尾节点\n//   倒数第k + 1个节点.next = null\n//   链表尾节点.next = head\n//   return 倒数第k个节点\nclass Solution {\n    public:\n        ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr\n            || head->next == nullptr\n            || k == 0)\n            return head;\n\n        int len = 1;\n        ListNode* cur = head;\n        while (cur->next != nullptr) {\n            cur = cur->next;\n            len++;\n        }\n\n        k %= len;\n\n        ListNode* fast = head;\n        ListNode* slow = head;\n\n        while (fast->next != nullptr) {\n            // slow wait k times\n            if (k-- <= 0) {\n                slow = slow->next;\n            }\n            fast = fast->next;\n        }\n\n        fast->next = head;\n        ListNode* new_head = slow->next;\n        slow->next = nullptr;\n        return new_head;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/11#issuecomment-1826591878","body":"```python\n\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if (not headA) or (not headB):\n            return null\n\n        p1, p2 = headA, headB\n        \n        while(p1!=p2):\n            p1 = p1.next if p1 else headB\n            p2 = p2.next if p2 else headA\n        \n        return p1\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826540401","body":"```python # Definition for singly-linked list.\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        #define quick/slow two pointers\n        slow = fast = head\n        catched_place = None\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                catched_place = fast\n                break\n\n        #if fast do not catch slow, 无环         \n        if not catched_place:\n            return None\n\n        #环 , need to find out the beginning\n        slow = head\n        while slow != catched_place:\n            slow = slow.next\n            catched_place = catched_place.next\n\n        return slow      ```\n\nspace O(1) time O(N) \n\nNot easy way to think why fast meet slow again when fast/slow move to head ","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1836545149","body":"打个卡先。。。\n```python\n\nclass Codec:\n\n    def serialize(self, root):\n        if root is None:\n            return \"{}\"\n\n        queue = [root]\n        index = 0\n        while index < len(queue):\n            if queue[index] is not None:\n                queue.append(queue[index].left)\n                queue.append(queue[index].right)\n            index += 1\n\n        while queue[-1] is None:\n            queue.pop()\n\n        return '{%s}' % ','.join([str(node.val) if node is not None else '#'\n                                  for node in queue])\n\n\n    def deserialize(self, data):\n        data = data.strip('\\n')\n\n        if data == '{}':\n            return None\n\n        vals = data[1:-1].split(',')\n            \n        root = TreeNode(int(vals[0]))\n        queue = [root]\n        isLeftChild = True\n        index = 0\n\n        for val in vals[1:]:\n            if val is not '#':\n                node = TreeNode(int(val))\n                if isLeftChild:\n                    queue[index].left = node\n                else:\n                    queue[index].right = node\n                queue.append(node)\n\n            if not isLeftChild:\n                index += 1\n            isLeftChild = not isLeftChild\n\n        return root\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/21#issuecomment-1839790388","body":"```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        hash_map = {}\n\n        # 哈希表统计元素出现频率\n        for num in nums:\n            if num not in hash_map:\n                hash_map[num] = 1\n            hash_map[num] += 1\n        \n        # 建立最小堆，存储频率最大的 k 个元素\n        import heapq\n        pq = []\n\n        for key in hash_map:\n            if len(pq) < k:\n                heapq.heappush(pq, (hash_map[key],key))\n            elif hash_map[key] > pq[0][0]:\n                heapq.heapreplace(pq, (hash_map[key],key))\n\n        # 取出最小堆中的元素\n        res = []\n        while pq:\n            res.append(pq.pop()[1])\n\n        return res\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849043438","body":"```python\n\nclass Solution:\n    def removeDuplicates(self, nums):\n\n        if not nums: \n            return 0\n        \n        #pointer_rewrite point to the last running distinct n\n        pointer_rewrite, pointer_read = 0, 0\n        while pointer_read < len(nums):\n            if nums[pointer_rewrite] != nums[pointer_read]:\n                pointer_rewrite += 1\n                nums[pointer_rewrite] = nums[pointer_read]\n            pointer_read += 1\n\n        return pointer_rewrite + 1\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/29#issuecomment-1855154106","body":"```python\nclass Solution:\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        deque = collections.deque()\n        res, n = [], len(nums)\n        for i, j in zip(range(1 - k, n + 1 - k), range(n)):\n            # 删除 deque 中对应的 nums[i-1]\n            if i > 0 and deque[0] == nums[i - 1]:\n                deque.popleft()\n            # 保持 deque 递减\n            while deque and deque[-1] < nums[j]:\n                deque.pop()\n            deque.append(nums[j])\n            # 记录窗口最大值\n            if i >= 0:\n                res.append(deque[0])\n        return res\n```","onTime":false},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/37#issuecomment-1864860831","body":"quick sort, nlog(n)\n```python\nclass Solution:\n    def sortArray(self, nums):\n        if len(nums) <= 1:\n            return nums\n\n        pivot = random.choice(nums)\n        lt = [v for v in nums if v < pivot]\n        eq = [v for v in nums if v == pivot]\n        gt = [v for v in nums if v > pivot]\n\n        return self.sortArray(lt) + eq + self.sortArray(gt)\n```\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/40#issuecomment-1868401433","body":"二分法\nThe bisect_right() method is provided by the bisect module, which returns the right-most index to insert the given element while maintaining the sorted order.\n\n```python\nfrom sortedcontainers import SortedList\nclass Solution:\n    def reversePairs(self, A):\n        d = SortedList()\n        ans = 0\n\n        for a in A:\n            i = d.bisect_right(a * 2)\n            ans += len(d) - i\n            d.add(a)\n        return ans\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/44#issuecomment-1870822597","body":"移动窗口，update 左边和右边\n```python\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        res = 0\n        temp = 0\n        vowels = set(['a','e','i','o','u'])\n\n        for i in range(k):\n            res += s[i] in vowels\n\n        #if res==k: return k\n        temp = res\n\n        for i in range(k,len(s)):\n            temp += (s[i] in vowels) - (s[i-k] in vowels)\n            res = max(temp,res)\n            \n        return res\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/49#issuecomment-1873555393","body":" filter(lambda a: a < 12, map(sum, combinations([1, 2, 4, 8], count))) 这个用法不错。。。学习了\n```python\nclass Solution:\n    def readBinaryWatch(self, num: int) -> List[str]:\n        def possible_number(count, minute=False):\n            if count == 0: return [0]\n            if minute:\n                return filter(lambda a: a < 60, map(sum, combinations([1, 2, 4, 8, 16, 32], count)))\n            return filter(lambda a: a < 12, map(sum, combinations([1, 2, 4, 8], count)))\n\n        ans = set()\n\n        #最多4个LED on for hours \n        for i in range(min(4, num + 1)):\n            for a in possible_number(i, minute=False):\n                for b in possible_number(num - i, minute=True):\n                    ans.add(str(a) + \":\" + str(b).rjust(2, '0'))\n\n        return list(ans)\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/57#issuecomment-1879926760","body":"打个卡 \r\n\r\n```python\r\nclass Solution:\r\n    def solve(self, root):\r\n        q = collections.deque([(root, 0)])\r\n        d = {}\r\n        while q:\r\n            cur, pos = q.popleft()\r\n            if pos not in d:\r\n                d[pos] = cur.val\r\n            if cur.left:\r\n                q.append((cur.left, pos - 1))\r\n            if cur.right:\r\n                q.append((cur.right, pos + 1))\r\n        return list(map(lambda x:x[1], sorted(d.items(),key=lambda x: x[0])))\r\n\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/61#issuecomment-1887474451","body":"二维DP 打个卡\n\n```python\nclass Solution:\n    def longestCommonSubsequence(self, A: str, B: str) -> int:\n        m, n = len(A), len(B)\n        ans = 0\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if A[i - 1] == B[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    ans = max(ans, dp[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsaki":[{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/2#issuecomment-1818159707","body":"```\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        carry = 0\n        for i in range(len(A) - 1, -1, -1):\n            A[i], carry = (carry + A[i] + K % 10) % 10, (carry + A[i] + K % 10) // 10\n            K //= 10\n        B = []\n        # 如果全部加完还有进位，需要特殊处理。 比如 A = [2], K = 998\n        carry = carry + K\n        while carry:\n            B = [(carry) % 10] + B\n            carry //= 10\n        return B + A\n```","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818162326","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        self.stack=[]\n        self.ex=0\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n        self.ex+=1\n        return self.stack\n\n    def pop(self) -> int:\n        self.ex+=1\n        return self.stack.pop(0)\n\n    def peek(self) -> int:\n        self.ex+=1\n        return self.stack[0]\n\n    def empty(self) -> bool:\n        if self.ex==0:\n            return True\n        if not self.stack:\n            return True\n        return False\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"witerth":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1818400119","body":"### **【Day 5】232. 用栈实现队列**\n\n[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/description/)\n\n#### **思路**\n\n原本思路每次push都要把输出栈压会输入栈，看官方思路后已改进\n\n#### **代码**\n\n```javascript\nvar MyQueue = function() {\n\n​    this.s = [];\n\n​    this.s1 = [];\n\n\n};\n\n\n/** \n\n * @param {number} x\n\n * @return {void}\n\n */\n\nMyQueue.prototype.push = function(x) {\n\n​    this.s.push(x);\n\n​    return this.s;\n\n};\n\n\n/**\n\n * @return {number}\n\n */\n\nMyQueue.prototype.pop = function() {\n\n​    if (!this.s1.length) {\n\n​        while (this.s.length) {\n\n​            this.s1.push(this.s.pop());\n\n​        }\n\n​    }\n\n​    return this.s1.pop();\n\n};\n\n\n/**\n\n * @return {number}\n\n */\n\nMyQueue.prototype.peek = function() {\n\n​    if (!this.s1.length) {\n\n​        while (this.s.length) {\n\n​            this.s1.push(this.s.pop());\n\n​        }\n\n​    }\n\n​    return this.s1[this.s1.length -1];\n\n};\n\n\n/**\n\n * @return {boolean}\n\n */\n\nMyQueue.prototype.empty = function() {\n\n​    return !this.s.length && !this.s1.length;\n\n};\n\n\n/**\n\n * Your MyQueue object will be instantiated and called as such:\n\n * var obj = new MyQueue()\n\n * obj.push(x)\n\n * var param_2 = obj.pop()\n\n * var param_3 = obj.peek()\n\n * var param_4 = obj.empty()\n\n */\n```\n\n\n\n#### **复杂度分析**\n\n\\- 时间复杂度：push和empty复杂的为O(1)  pop和peek复杂度为O(N)\n\\- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1820921082","body":"**【Day 6】768. 最多能完成排序的块 II**\r\n\r\n[**[768. 最多能完成排序的块 II](https://github.com/leetcode-pp/91alg-12-daily-check/issues/**%E3%80%90Day%206%E3%80%91768.%20%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97%20II**)**](**【Day 6】768. 最多能完成排序的块 II**)\r\n\r\n#### 思路\r\n\r\n每个块中的最大值也是按升序排列的，只需要当前数字和前面块的最大值比较即可，如果当前数最大，则加入前面的块作为最大值，否则一直和前面的最大值比较，直到找到比前面最大值小，中间原本算好的块就合并成一个块\r\n\r\n#### 代码\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n\r\n  var stack = [];\r\n\r\n  arr.forEach((i, index) => {\r\n\r\n   if (index === 0) {\r\n\r\n​    stack.push(i);\r\n\r\n   } else {\r\n\r\n​    if (i < stack[stack.length - 1]) {\r\n\r\n​     var max = stack.pop();\r\n\r\n​     while (stack.length) {\r\n\r\n​      if (stack.length && i < stack[stack.length - 1]) {\r\n\r\n​       stack.pop();\r\n\r\n​      } else {\r\n\r\n​       break;\r\n\r\n​      }\r\n\r\n​     }\r\n\r\n​     stack.push(max);\r\n\r\n​    } else {\r\n\r\n​     stack.push(i);\r\n\r\n​    }\r\n\r\n​    }\r\n\r\n  })\r\n\r\n  return stack.length;\r\n\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1822170193","body":"### **【Day 7】61. 旋转链表**\n\n[61. 旋转链表](https://leetcode.cn/problems/rotate-list/description/)\n\n#### **思路**\n\n第一次遍历时，计算链表长度l，算出新的k（k可能比l大，newK = k % l），并且首尾连接。第二次遍历找到新链表的最后一个节点（旧链表的第 l - newK 个节点），将闭合链表断开。\n\n如果k为l的倍数，则新旧链表相同，直接返回旧链表\n\n#### 代码\n\nvar rotateRight = function(head, k) {\n\n  if (k === 0 || !head || !head.next) return head;\n\n  var l = 1;\n\n  var cur = head;\n\n  while (cur.next) {\n\n​    cur = cur.next;\n\n​    l++;\n\n  }\n\n  var n = l - k % l;\n\n  if (n === l) {\n\n​    return head;\n\n  }\n\n  cur.next = head;\n\n  while (n) {\n\n​    cur = cur.next;\n\n​    n--;\n\n  }\n\n  var newHead = cur.next;\n\n  cur.next = null;\n\n  return newHead;\n\n};\n\n#### **复杂度分析**\n\n\\- 时间复杂度：O(N)\n\\- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1823875076","body":"#### **思路**\n\n遍历链表，第一次交换当前节点和next，之后开始交换后两个节点，cur为交换后的第二个节点\n\n看官解后改进，链表开头加一个占位节点，不需要额外处理第一次\n\n#### 代码\n\nvar swapPairs = function(head) {\n\n  if(!head || !head.next) return head;\n\n  const pre = new ListNode(-1, head);\n\n  let cur = pre;\n\n  let next = cur.next;\n\n  while (cur.next && next.next) {\n\n​    let second = next.next;\n\n​    cur.next = second;\n\n​    next.next = second.next;\n\n​    second.next = next;\n\n​    cur = next;\n\n​    next = cur.next;\n\n  }\n\n  return pre.next;\n\n};\n\n#### **复杂度分析**\n\n\\- 时间复杂度：O(N)\n\\- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/10#issuecomment-1825294522","body":"#### **思路**\n\n看到二叉树就想到了递归，但是二叉树的相关知识都忘了，得有点二叉树的基础才能做出来。\n\n先用快慢指针找到中间节点，这个就是二叉树的根节点，树的左边为链表头到中间节点，右边同理，此时，通过递归课得到完整二叉树\n\n#### 代码\n\nvar sortedListToBST = function(head) {\n\n  if (!head) return null;\n\n  return buildTree(head, null)\n\n};\n\nfunction buildTree(head, tail) {\n\n  if (head === tail) return null;\n\n  let fast = head;\n\n  let slow = head;\n\n  while(fast != tail && fast.next != tail) {\n\n​    slow = slow.next;\n\n​    fast = fast.next.next;\n\n  }\n\n  let tree = new TreeNode(slow.val);\n\n  tree.left = buildTree(head, slow);\n\n  tree.right = buildTree(slow.next, tail);\n\n  return tree;\n\n}\n\n#### **复杂度分析**\n\n\\- 时间复杂度：递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn)\n\\- 空间复杂度：空间复杂度为O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/11#issuecomment-1826276924","body":"#### 代码\n\nvar getIntersectionNode = function(headA, headB) {\n\n  if (!headA || !headB) return;\n\n  let s = new Set();\n\n  \n\n  let curA = headA;\n\n  while(curA) {\n\n​    s.add(curA);\n\n​    curA = curA.next;\n\n  }\n\n  let curB = headB;\n\n  while(curB) {\n\n​    if (s.has(curB)) {\n\n​      return curB;\n\n​    }\n\n​    curB = curB.next;\n\n  }\n\n  return null;\n\n  \n\n};\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826767127","body":"#### 代码\n\nvar detectCycle = function(head) {\n\n  let s = new Set();\n\n  let cur = head;\n\n  while(!s.has(cur) && cur) {\n\n​    s.add(cur);\n\n​    cur = cur.next;\n\n  }\n\n  return cur;\n\n};\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/13#issuecomment-1827861099","body":"/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.length = 0;\n    this.hashCache = {};\n    this.head = null;\n    this.tail = null;\n};\n\nvar creatNode = function(key, value, pre) {\n    return {\n        key: key,\n        value: value,\n        pre: pre || null,\n        next: null\n    }\n}\n\nvar moveNode = function(cur) {\n    if (this.head === this.tail) return;\n    if (!cur.next) {\n        return;\n    } \n    if (cur.pre) {\n        cur.next.pre = cur.pre;\n        cur.pre.next = cur.next;\n    } else {\n        this.head = cur.next;\n        cur.next.pre = null;\n    }\n    cur.next = null;\n    this.tail.next = cur;\n    cur.pre = this.tail;\n    this.tail = cur;\n}\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (this.length === 0) return -1;\n    let cur = this.hashCache[key];\n    if (!cur) return -1;\n\n    moveNode.call(this, cur);\n    return this.hashCache[key].value;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    let cur = this.hashCache[key];\n    if (cur) {\n        cur.value = value;\n        moveNode.call(this, cur);\n\n    } else {\n        this.length++;\n        cur = creatNode(key, value, this.tail);\n        this.hashCache[key] = cur;\n        if (this.length === 1) {\n            this.head = cur;\n            this.tail = cur;\n            return null;\n        }\n        this.tail.next = cur;\n        this.tail = cur;\n        if (this.length > this.capacity) {\n            this.length--;\n            this.hashCache[this.head.key] = undefined;\n            this.head = this.head.next;\n            this.head.pre = null;\n\n        }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/14#issuecomment-1829245083","body":"/**\n\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n * this.val = (val===undefined ? 0 : val)\n * this.left = (left===undefined ? null : left)\n * this.right = (right===undefined ? null : right)\n * }\n   */\n   /**\n * @param {TreeNode} root\n * @return {number}\n   */\n   var maxDepth = function(root) {\n   if (!root) return 0;\n   let left = maxDepth(root.left);\n   let right = maxDepth(root.right);\n   return Math.max(left, right) + 1;\n   };","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1831393436","body":"/**\n\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n * this.val = (val===undefined ? 0 : val)\n * this.left = (left===undefined ? null : left)\n * this.right = (right===undefined ? null : right)\n * }\n   */\n   /**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n   */\n   var isSameTree = function(p, q) {\n   if (p === null && q === null) return true;\n   if (p === null || q === null) return false;\n   if (p.val !== q.val) return false;\n   let left = isSameTree(p.left, q.left);\n   let right = isSameTree(p.right, q.right);\n   return left && right;\n   };","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/16#issuecomment-1833369021","body":"#### 代码\n\n/**\n\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n * this.val = (val===undefined ? 0 : val)\n * this.left = (left===undefined ? null : left)\n * this.right = (right===undefined ? null : right)\n * }\n   */\n   /**\n * @param {TreeNode} root\n * @return {number}\n   */\n   var sumNumbers = function(root) {\n   return dfs(root, 0);\n   };\n\nfunction dfs(root, preSum) {\n    if (!root) return 0;\n    let sum = preSum * 10 + root.val;\n    if (!root.left && !root.right)  {\n        return sum;\n    } else {\n        return dfs(root.left, sum) + dfs(root.right, sum);\n    }\n}\n\n#### **复杂度分析**\n\n\\- 时间复杂度：O(N)\n\\- 空间复杂度：O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1837936239","body":"#### **思路**\n\n1.双for循环暴力解法\n\n2.创建一个哈希表，遍历时存入 (值：索引) 的键值对，同时先查看哈希表中是否有和当前值相加为target的值，若有，这返回哈希表中对应值的索引和当前索引\n\n#### 代码\n\nvar twoSum = function(nums, target) {\n\n  // for (let i = 0; i < nums.length; i++) {\n\n  //   let a = target - nums[i];\n\n  //   for (let j = i + 1; j < nums.length; j++) {\n\n  //     if (nums[j] === a) return [i, j]\n\n  //   }\n\n  // }\n\n  let m = new Map();\n\n  for (let i = 0; i < nums.length; i++) {\n\n​    if (m.has(target - nums[i])) return [m.get(target - nums[i]), i];\n\n​    m.set(nums[i], i);\n\n  }\n\n};\n\n#### **复杂度分析**\n\n双for循环\n\n\\- 时间复杂度：O(N2)\n\\- 空间复杂度：O(1)\n\n哈希表\n\n\\- 时间复杂度：O(N)\n\\- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/21#issuecomment-1840318779","body":"/**\n\n \\* @param {number[]} nums\n\n \\* @param {number} k\n\n \\* @return {number[]}\n\n */\n\nvar topKFrequent = function(nums, k) {\n\n  let obj = {};\n\n  nums.forEach((i) => {\n\n​    if (obj[i]) {\n\n​      obj[i].count++;\n\n​    } else {\n\n​      obj[i] = {\n\n​        num: i,\n\n​        count: 1\n\n​      }\n\n​    }\n\n  })\n\n  let list = Object.values(obj).sort((a, b) => b.count - a.count);\n\n  return list.slice(0, k).map((i) => i.num);\n\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1844885856","body":"var lengthOfLongestSubstring = function(s) {\n    let list = new Set();\n    let r = 0;\n    let n = s.length;\n    for (let i = 0; i < n; i++) {\n        let j = 0;\n        let newS = s.slice(i);\n        while(newS[j] && !list.has(newS[j])) {\n            list.add(newS[j]);\n            j++;\n        }\n        r = Math.max(j, r);\n        list = new Set();\n    }\n    return r;\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/27#issuecomment-1849237540","body":"#### **思路**\n\n快慢指针，如果不相等，直接覆盖慢指针的下一位，一次遍历后，数组前几位就是去重后的数组\n\n#### 代码\n\n/**\n\n \\* @param {number[]} nums\n\n \\* @return {number}\n\n */\n\nvar removeDuplicates = function(nums) {\n\n  if (!nums.length) return 0;\n\n  let index = 0;\n\n  for(let i = 1; i < nums.length; i++) {\n\n​    if (nums[i] !== nums[index]) {\n\n​      nums[++index] = nums[i];\n\n​    }\n\n  }\n\n  return index + 1;\n\n};\n\n#### **复杂度分析\n\n\\- 时间复杂度：O(N)\n\\- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1851288601","body":"#### **思路**\n\n二分查找法\n\n#### 代码\n\n/**\n\n \\* @param {number[]} nums\n\n \\* @param {number} target\n\n \\* @return {number}\n\n */\n\nvar searchInsert = function(nums, target) {\n\n   let start = -1;\n\n   let end = nums.length;\n\n   while(start < end - 1) {\n\n​    let middle = start + Math.ceil((end - start) / 2);\n\n​     if (nums[middle] < target) {\n\n​       start = middle;\n\n​     } else {\n\n​       end = middle;\n\n​     }\n\n   }\n\n   return start + 1\n\n};\n\n#### **复杂度分析\n\n\\- 时间复杂度：O(logN)\n\\- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ludwig-ll":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/6#issuecomment-1819205214","body":"**思路**\n\n看到用两个栈来实现队列，就像是用两个#*%#&% 实现#%%&，不懂这个要求的概念。\n先查资料：\n    栈：类似存放的空间，但是像是排队进胡同，要退出来肯定要从最后一个开始退出，然后倒数第二个才能继续。\n    队列：这个比较像火车过山，最先进的车头也一定会最先出山洞。\n（这先进先出、后进先出的概念有点类似会计的存货过程计算）\n\n有了基本的认知之后，就回来再次解读题目：要用两个后进先出的空间，来完成一个先进先出的概念（或是做法）\n这样理解并不合理，因为两个先进后出的栈，他们最先进的只能是最后出，那要怎么达到先进的能先出呢？\n想了一下，如果有两个冰棒袋子，这时候我不管拆开的冰棒袋子露出的是冰棒或木板，我都可以用手拿木板。\n概念就是如果是冰棒，那倒入到另一个冰棒袋中，这样露出的末尾就会是木板。\n（应该是这样）\n看了一下力扣里面大家的说法也像是这样子，接下来就是操作。\n\n**代码**\n功力还不足以进行这个情况的操作，偷看了大佬的设定：\n(目前还不会Markdown 上色，自己看了有点痛苦）\n\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n**时间复杂度**\n还在学习如何对设定进行计算。\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826819869","body":"**思路**\r\n看了题目不懂\r\n去爬了资料知道了所谓双指针是有快与慢的区别。\r\n然后加入了环的概念进行计算就更复杂了，这个推导跟计算看了好一阵子还是看不懂。\r\n:(\r\n\r\n**代码**\r\n抄了大佬的代码：\r\n\r\nclass Solution:\r\n\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n\r\n        slow = fast = head\r\n\r\n        while fast and fast.next:\r\n\r\n            slow = slow.next\r\n\r\n            fast = fast.next.next\r\n\r\n            if fast is slow:\r\n\r\n                while slow is not head:\r\n\r\n                    slow = slow.next\r\n\r\n                    head = head.next\r\n\r\n                return slow\r\n\r\n        return None\r\n\r\n\r\n还没搞懂为什么让slow = fast = head\r\n\r\n**时间复杂度**","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1837164577","body":"**思路**\n\n这个情况处理方式看讲解还是理解的很吃力。\n尤其是Deserialize 的反序列化部分，功底不足以明白 ：（\n\n**代码**\n偷抄大佬的代码：\n\nclass Codec:\n    def serialize(self, root):\n        if not root: return \"[]\"\n        queue = collections.deque()\n        queue.append(root)\n        res = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                res.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else: res.append(\"null\")\n        return '[' + ','.join(res) + ']'\n\n    def deserialize(self, data):\n        if data == \"[]\": return\n        vals, i = data[1:-1].split(','), 1\n        root = TreeNode(int(vals[0]))\n        queue = collections.deque()\n        queue.append(root)\n        while queue:\n            node = queue.popleft()\n            if vals[i] != \"null\":\n                node.left = TreeNode(int(vals[i]))\n                queue.append(node.left)\n            i += 1\n            if vals[i] != \"null\":\n                node.right = TreeNode(int(vals[i]))\n                queue.append(node.right)\n            i += 1\n        return root\n\n**时间复杂度**\n\n大致明白复杂度的计算方式了。\n以这题代码来看，虽然有While，但是if 的部分没有嵌套。\n这样的话应该是N（O）的复杂度。","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/23#issuecomment-1845487412","body":"**思路**\n这题看来简单，直观的直接看很容易看出答案来。\n但是设计算法要具象到用逻辑归纳，发现不是那么容易。\n首先想到dic ，先把一个清单做出来，然后接下来要让每个可能都走过一次。然后把没遇到重复字的每个可能都算出长度，再取最长的字符数。\n\n**代码**\n还没有办法自己写出来，偷看大佬写的：\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        dic, res, i = {}, 0, -1\n        for j in range(len(s)):\n            if s[j] in dic:\n                i = max(dic[s[j]], i) # 更新左指针 i\n            dic[s[j]] = j # 哈希表记录\n            res = max(res, j - i) # 更新结果\n        return res\n\n**时间复杂度**\n以代码看来，应该是O(N^2) 的复杂度。","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/29#issuecomment-1854129371","body":"**思路**\n\ndeque 这个单调队列的概念看了文章还是比较难理解 ：(\n\n为什么不是从滑动窗口的每一组3 个元素中遍历min\n\n**代码**\n\n做不出来，抄的大佬代码\n\nclass Solution:\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        deque = collections.deque()\n        res, n = [], len(nums)\n        for i, j in zip(range(1 - k, n + 1 - k), range(n)):\n            # 删除 deque 中对应的 nums[i-1]\n            if i > 0 and deque[0] == nums[i - 1]:\n                deque.popleft()\n            # 保持 deque 递减\n            while deque and deque[-1] < nums[j]:\n                deque.pop()\n            deque.append(nums[j])\n            # 记录窗口最大值\n            if i >= 0:\n                res.append(deque[0])\n        return res\n\n\n**时间复杂度**\n\n从代码的结构来看，时间复杂度应该是O(N)。\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/34#issuecomment-1860601030","body":"**思路**\r\n\r\n这题很似在哪里看过，是一个排队候判定先后的过程。\r\n\r\n第一步：得先看手上的可执行任务\r\n第二步：可执行任务中，挑出执行时间最短的执行。\r\n第三步：执行之后按执行完的时间点，重新刷出可执行任务\r\n接下来就是一直第二、第三步的过程。\r\n\r\n用伪代码表示：\r\nif enqueuetime(flow) > enqueuetime(task)\r\n    search smallest processingtime(valid task)\r\nif (enqueuetime(flow) + processingtime(last)) > enqueuetime(task)\r\n    search smallest processingtime(valid task)\r\n...\r\n\r\n**代码**\r\n还写不出Python 代码，偷抄大佬代码\r\n\r\nimport queue\r\n\r\nclass Solution:\r\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\r\n        n = len(tasks)\r\n\r\n        indices = list(range(n))\r\n        indices.sort(key=lambda x:tasks[x][0])\r\n        ptr = 0\r\n        timestamp = 0\r\n        \r\n        pq = queue.PriorityQueue()\r\n        res = list()\r\n\r\n        for i in range(n):\r\n            if pq.empty():\r\n                timestamp = max(timestamp, tasks[indices[ptr]][0])\r\n            while ptr < n and tasks[indices[ptr]][0] <= timestamp:\r\n                pq.put((tasks[indices[ptr]][1], indices[ptr]))\r\n                ptr += 1\r\n            time, index = pq.get()\r\n            timestamp += time\r\n            res.append(index)\r\n\r\n        return res\r\n\r\n**时间复杂度**\r\n代码层次有点复杂，这次的看不出来时间复杂度是什么。\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/40#issuecomment-1868478227","body":"**思路**\n看了解释终于知道他问的 i j num(i) num(j) 是什么，原来是不用两个靠在一起的。\n题解说到的使用暴力遍历这个可以理解，但会造成超时，所以不能使用。\n解说的“二分“、”有序“看来是关键，但是”bisect.insort 指的是使用二分找到插入点，并将数插入到数组中，使得插入后数组仍然有序。” 这个观念有点抽象，还比较难理解。\n\n**代码**\n\n偷抄大佬的代码：\nclass Solution:\n    def find_reversed_pairs(self,nums,left,right):\n        res,mid = 0,(left+right)//2\n        \n        j = mid+1\n        for i in range(left,mid+1):\n            while j <= right and nums[i] > 2*nums[j]:\n                res += mid-i+1\n                j += 1\n        return res      \n        \n    def merge_sort(self,nums,nums_sorted,l,r):\n        if l >= r: return 0\n        mid = (l+r) // 2\n        res = self.merge_sort(nums,nums_sorted,l,mid) +\\\n              self.merge_sort(nums,nums_sorted,mid+1,r) +\\\n              self.find_reversed_pairs(nums,l,r)\n        \n        i,j,k = l,mid+1,l\n        while i <= mid and j <= r:\n            if nums[i] <= nums[j]:\n                nums_sorted[k] = nums[i]\n                i += 1\n            else:\n                nums_sorted[k] = nums[j]\n                j += 1\n            k += 1\n                \n        while i <= mid:\n            nums_sorted[k] = nums[i]\n            i += 1\n            k += 1\n        while j <= r:\n            nums_sorted[k] = nums[j]\n            j += 1\n            k += 1\n        \n        for k in range(l,r+1): nums[k] = nums_sorted[k]\n        \n        return res\n        \n    \n    def reversePairs(self, nums: List[int]) -> int:\n        if not nums: return 0\n        nums_sorted = [0] * len(nums)\n        return self.merge_sort(nums,nums_sorted,0,len(nums)-1)\n\n**时间复杂度**\n比较复杂的设计，目前看不出来时间复杂度。","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/45#issuecomment-1872186463","body":"**思路**\n这题难度中等，赶快进来做。\n而且看了一下解释，这就是动态转移方程，听说很重要。\n这题需要用数学，太久没算看了一阵子都还没归纳出算式 ：(\n解释提到的边界条件的概念也还是懵懵懂懂。\n还好滑动窗口的概念之前已经有一些基本认知。但是动态转移方程这东西还没攻克还有数学归纳加在一起弄...\n“需要从后往前遍历，这样才能保证结果的正确性”，还是有点搞不清楚...\n爆炸！\n\n**代码**\n\n做不出来，偷抄大佬的代码：\n\nclass Solution:\n    def new21Game(self, N: int, K: int, W: int) -> float:\n        dp=[None]*(K+W)\n        s=0\n        for i in range(K,K+W):  \n            dp[i] = 1 if i<=N else 0\n            s+=dp[i]\n        for i in range(K-1,-1,-1):   \n            dp[i]=s/W\n            s=s-dp[i+W]+dp[i]\n        return dp[0]\n\n**时间复杂度**\n\n太复杂的层级，看不出复杂度。","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/50#issuecomment-1875509072","body":"**思路**\n\n皇后可以走水平、垂直、斜线的防线。意思是，要能成立的摆法一定是任何一个Queen 的水平、垂直、斜线都没有其他的Queen。\n2*2 是做不了的，3*3 也做不了，4*4 开始可以做。\n看了解说了解意思了，i 相同、j 相同的都失败。\n再来斜线有两种，这个部分还在自己用列举法做归纳...\n\n**代码**\n\n数学跟代码目前都还做不出来，偷抄大佬的代码：\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        m = n * 2 - 1\n        ans = 0\n        on_path, diag1, diag2 = [False] * n, [False] * m, [False] * m\n        def dfs(r: int) -> None:\n            if r == n:\n                nonlocal ans\n                ans += 1\n                return\n            for c, on in enumerate(on_path):\n                if not on and not diag1[r + c] and not diag2[r - c]:\n                    on_path[c] = diag1[r + c] = diag2[r - c] = True\n                    dfs(r + 1)\n                    on_path[c] = diag1[r + c] = diag2[r - c] = False  # 恢复现场\n        dfs(0)\n        return ans\n\n**时间复杂度**\n\n这样的镶嵌，复杂度应该是O(N^2) 才是","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/59#issuecomment-1883170349","body":"**思路**\n\n相邻的不能抢，这是先决条件。\n所以可能的是 第n 个房子决定要抢，然后看n - 1 和 n + 1 那个最值得抢。\n还看不懂“当前的房子可以抢的价值 + dp[i - 2]” 的意思...\n\n**代码**\n\n偷抄大佬的代码...虽然不多，但是现在程度拆解不了。\n\nclass Solution:\n    def rob(self, nums: List[int]) -> int:\n        cur, pre = 0, 0\n        for num in nums:\n            cur, pre = max(pre + num, cur), cur\n        return cur\n\n**时间复杂度**\n看起来代码应该是O（N^2) 的复杂度。\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luster-lyl":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1821156711","body":"```\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function (arr) {\r\n    // 单调栈, 从右向左比较\r\n    const stack = []\r\n    for (const num of arr) {\r\n        const max = stack[stack.length - 1];\r\n        if (stack.length === 0 || num >= max) {\r\n            // 新增的数据大于等于原数字的最大值，就可以单独形成一个块\r\n            stack.push(num)\r\n        } else {\r\n            if (stack.length && max > num) {\r\n                // 新增的数字小于已有的最大值，就不能单独形成块\r\n            } else {\r\n                stack.push(max)\r\n            }\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1823013342","body":"```\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if(k===0 || !head || !head.next) return head\r\n    let n = 1;\r\n    let cur = head\r\n    while(cur.next) { // 链表长度\r\n        cur = cur.next\r\n        n++;\r\n    }\r\n    let add = n - k % n\r\n    if(add === n){\r\n        return head\r\n    }\r\n\r\n    cur.next = head; // 收尾相连\r\n\r\n    // 开始向后旋转\r\n    while (add) {\r\n        cur = cur.next;\r\n        add--;\r\n    }\r\n\r\n    const res = cur.next;\r\n    cur.next = null; // 断开\r\n    return res;\r\n};\r\n```\r\ntime: O(n)\r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1824653039","body":"```\nvar swapPairs = function(head) {\n    if (head === null|| head.next === null) {\n        return head;\n    }\n    const newHead = head.next\n    head.next = swapPairs(newHead.next)\n    newHead.next = head\n    return newHead\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/15#issuecomment-1832119745","body":"```\nvar isSameTree = function(p, q) {\n    if(!p && !q) return true\n    else if(!p || !q) return false\n    else if(p.val != q.val) return false\n    else {\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/20#issuecomment-1838861449","body":"```\nvar twoSum = function(nums, target) {\n    const prevNums = {} //存储出现的数字：index\n    for(let i = 0 ; i<nums.length;i++){\n        const curNum = nums[i] //当前元素\n        const targetNum = target - curNum //满足条件的目标元素\n        const targetNumIndex = prevNums[targetNum]\n        if(targetNumIndex !== undefined){\n            return [targetNumIndex,i]\n        }else{\n            prevNums[curNum] = i\n        }\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/26#issuecomment-1848961797","body":"```\nvar middleNode = function(head) {\n    // 快慢指针\n    // slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。\n    slow = fast = head\n    while(fast && fast.next) {\n        slow = slow.next\n        fast = fast.next.next\n    }\n    return slow\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/33#issuecomment-1859185773","body":"```\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function(moves) {\n    // 上=下，左=右\n    let right = 0\n    let up = 0\n    if(moves.length == 0) return ture\n    for(let i = 0; i < moves.length; i++) {\n        if(moves[i] === 'R'){\n            right++\n        } else if(moves[i] === 'L'){\n            right--\n        } else if(moves[i] === 'U'){\n            up++\n        } else if(moves[i] === 'D'){\n            up--\n        }\n    }\n    return right === 0 && up === 0\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smallppgirl":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/7#issuecomment-1821204358","body":"解题思路：元素评率\r\n\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        c = Counter()\r\n        blk = 0\r\n        for a, b in zip(arr, sorted(arr)):\r\n            c[a] += 1\r\n            if c[a] == 0:\r\n                del c[a]\r\n            c[b] -= 1\r\n            if c[b] == 0:\r\n                del c[b]\r\n\r\n            if len(c) == 0:\r\n                blk += 1\r\n        return blk\r\n```\r\n\r\ntime: nlog(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1823043049","body":"思路：\r\n倒数 第 k % len 个节点为 head\r\n\r\n\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n         \r\n        len = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            len += 1\r\n        \r\n        if not (k := k % len):\r\n            return head\r\n\r\n        cur.next = head  # tail link to head\r\n\r\n        n = len - k\r\n        while n:\r\n            cur = cur.next\r\n            n -= 1\r\n        \r\n        ret = cur.next\r\n        cu.next = None\r\n        return ret\r\n```\r\n        \r\n\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/9#issuecomment-1824573105","body":"#思路\r\n\r\n递归交换， 直到没有节点或者只剩一个节点\r\n\r\nBefore --> head -> next -> After\r\n\r\n```\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        next: ListNode = head.next\r\n        head.next = self.swapPairs(next.next)\r\n        next.next = head\r\n\r\n        return next\r\n```\r\n\r\n复杂度 时间： O(n) 遍历了链表一遍\r\n空间复杂度： O(n) 递归栈调用","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/11#issuecomment-1826372444","body":"思路： 双指针同步向右平移{next}， 当一条移到尾端（null）跳去另一条头部，继续平移，以此消除头部长度差。\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        if not headA or not headB:\r\n            return None\r\n        pointA, pointB = headA, headB\r\n        while pointA != pointB:\r\n            pointA = pointA.next if pointA else headB\r\n            pointB = pointB.next if pointB else headA\r\n        return pointA\r\n```\r\n\r\ntime O(m+n)\r\nspace O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826818055","body":"思路： 哈希表存储所有节点hash 入HashSet, 然后判断有没有节点出现在Set \n\n代码：\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        Set<ListNode> visited = new HashSet<ListNode>();\n        ListNode point = head;\n        while (point != null) {\n            if (visited.contains(point)) {\n                return point;\n            } else {\n                visited.add(point);\n            }\n            point = point.next;\n        }\n        return null;\n    }\n}\n```\n\n时间复杂度： O(n) 遍历一遍linkedlist\n空间复杂度： O(n) 存储所有节点的hash一遍","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/18#issuecomment-1836977651","body":"思路：\r\n\r\n二叉树遍历， BFS, 单调队列 pop\r\n\r\n代码\r\n\r\n```Python3\r\n\r\nclass Codec:\r\n    def serialize(self, root):\r\n        if not root: \r\n            return \"[]\"\r\n        queue = collections.deque()\r\n        queue.append(root)\r\n        res = []\r\n        while queue:\r\n            node = queue.popleft()\r\n            if node:\r\n                res.append(str(node.val))\r\n                queue.append(node.left)\r\n                queue.append(node.right)\r\n            else:\r\n                res.append(\"null\")\r\n        return '[' + ','.join(res) + ']'\r\n\r\n    def deserialize(self, data):\r\n        if data ==\"[]\":\r\n            return\r\n        \r\n        vals = data[1:-1].split(',')\r\n       \r\n        root = TreeNode(int(vals[0]))\r\n        queue = collections.deque()\r\n        queue.append(root)\r\n\r\n        i = 1\r\n        while queue:\r\n            node = queue.popleft()\r\n            if vals[i] != \"null\":\r\n                node.left = TreeNode(int(vals[i]))\r\n                queue.append(node.left)\r\n            i += 1\r\n            if vals[i] != \"null\":\r\n                node.right = TreeNode(int(vals[i]))\r\n                queue.append(node.right)\r\n            i += 1\r\n        return root\r\n\r\n\r\n```\r\n\r\ntime: O(N）\r\nspace O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/19#issuecomment-1837495329","body":"思路：利用哈希表， key 为 column (y) ， 值为tuple , tuple 包括 row (x) 和值， 因为row 优先排序 ， x 在前\n\n代码\n\n```Python\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        hashmap = defaultdict(list)\n        def dfs(node, x, y):\n            if not node:\n                return\n            hashmap[y].append((x, node.val))\n            dfs(node.left, x+1, y-1)\n            dfs(node.right, x+1, y+1)\n        \n        dfs(root, 0, 0)\n        \n        res = []\n        for i in sorted(hashmap.keys()):\n            res.append(list(zip(*sorted(hashmap[i])))[1])\n        return res\n```\n\n时间复杂度 O(nlogn)\n空间复杂度O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/25#issuecomment-1848447916","body":"```\r\nclass Solution:\r\n    def minSubarray(self, nums: List[int], p: int) -> int:\r\n        x = sum(nums) % p\r\n        if x == 0:\r\n            return 0\r\n        y = 0\r\n        index = {0: -1}\r\n        ans = len(nums)\r\n        for i, v in enumerate(nums):\r\n            y = (y + v) % p\r\n            if (y - x) % p in index:\r\n                ans = min(ans, i - index[(y - x) % p])\r\n            index[y] = i\r\n        return ans if ans < len(nums) else -1\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/26#issuecomment-1848987983","body":"快慢指针法\r\n\r\n```Python\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```\r\n\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/31#issuecomment-1857305388","body":"\r\n方法 BFS 循环loop\r\n\r\n```python\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        dis_grp = [[] for _ in range(n)]\r\n        for x, y  in dislikes:\r\n            dis_grp[x - 1].append(y - 1)\r\n            dis_grp[y - 1].append(x - 1)\r\n        color = [0] * n\r\n        for i, c in enumerate(color):\r\n            if c == 0:\r\n                q_list = [i]\r\n                color[i] = 1\r\n                while len(q_list):\r\n                    x = q_list.pop(0)\r\n                    for y in dis_grp[x]:\r\n                        if color[y] == color[x]:\r\n                            return False\r\n                        if color[y] == 0:\r\n                            color[y] = -color[x]\r\n                            q_list.append(y)\r\n        return True\r\n```\r\n\r\nTime: O(n+m) 2 for loop , one is len(n), the other is len(dislike)\r\nSpace: O(n+m)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/35#issuecomment-1862455014","body":"思路： 化小时为分，\r\n\r\n代码\r\n\r\n```Python\r\nclass Solution:\r\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\r\n        startH, startM = loginTime.split(\":\")\r\n        finishH, finishM = logoutTime.split(\":\")\r\n\r\n        startConvM = int(startH) * 60 + int(startM)\r\n        finishConvM = int(finishH) * 60 + int(finishM)\r\n\r\n        if startConvM > finishConvM:\r\n            finishConvM += 1440\r\n\r\n        return max(finishConvM // 15 - (startConvM + 14) // 15, 0)\r\n```\r\n\r\n时间 O(1)\r\n空间 O(1)\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/37#issuecomment-1866511252","body":"思路： 归并排序\r\n\r\n\r\n\r\n```Python\r\nclass Solution:\r\n    def sortArray(self, nums: List[int]) -> List[int]:\r\n        temp_nums = [0] * len(nums)\r\n\r\n        def mergeSort(nums: List[int], left: int, right: int):\r\n            if left >= right:\r\n                return\r\n            \r\n            mid = (left + right) // 2\r\n            mergeSort(nums, left, mid)\r\n            mergeSort(nums, mid+1, right)\r\n\r\n            idx, leftStart, rightStart = left, left, mid + 1\r\n\r\n            while leftStart <= mid and rightStart <= right:\r\n                if nums[leftStart] <= nums[rightStart]:\r\n                    temp_nums[idx] = nums[leftStart]\r\n                    idx += 1\r\n                    leftStart += 1\r\n                else:\r\n                    temp_nums[idx] = nums[rightStart]\r\n                    idx += 1\r\n                    rightStart += 1\r\n            \r\n            while leftStart <= mid:\r\n                temp_nums[idx] = nums[leftStart]\r\n                idx += 1\r\n                leftStart += 1\r\n            \r\n            while rightStart <= right:\r\n                temp_nums[idx] = nums[rightStart]\r\n                idx += 1\r\n                rightStart += 1\r\n            \r\n            for i in range(left, right+1):\r\n                nums[i] = temp_nums[i]\r\n        \r\n        mergeSort(nums, 0, len(nums) - 1)\r\n        return nums\r\n```\r\n\r\n时间 ： O(nlog(n))\r\n空间： O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/44#issuecomment-1870902720","body":"思路 滑动窗口 遍历字符串\r\n\r\n```Python\r\nclass Solution:\r\n    def maxVowels(self, s: str, k: int) -> int:\r\n        def isVowel(ch: str) -> int:\r\n            return 1 if ch in {'a','e','i','o','u'} else 0\r\n        \r\n        sLen = len(s)\r\n        vCount = 0\r\n        for i in range(k):\r\n            vCount += isVowel(s[i])\r\n\r\n        ans = vCount\r\n        for i in range(k, sLen):\r\n            vCount += isVowel(s[i]) - isVowel(s[i-k])\r\n            ans = max(ans, vCount)\r\n            \r\n        return ans\r\n```\r\n\r\n时间复杂 O(n)\r\n空间复杂 O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/48#issuecomment-1873227753","body":"思路： 滑动窗口寻找最长中间子序列\r\n\r\n代码\r\n\r\n```Python\r\nclass Solution:\r\n    def minOperations(self, nums: List[int], x: int) -> int:\r\n        target_sum = sum(nums) - x\r\n        if target_sum < 0:\r\n            return -1\r\n        \r\n        left = right = m_sum = 0\r\n        m_len = -1\r\n\r\n        nums_len = len(nums)\r\n        \r\n        while right < nums_len:\r\n            m_sum += nums[right]\r\n            \r\n            while m_sum > target_sum:\r\n                m_sum -= nums[left]\r\n                left += 1\r\n        \r\n            if m_sum == target_sum:\r\n                m_len = max(m_len, right - left + 1)\r\n\r\n            right += 1\r\n        \r\n        return -1 if m_len == -1 else nums_len - m_len\r\n```\r\n\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/60#issuecomment-1885048051","body":"### 方法 ： DP\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def findNumberOfLIS(self, nums: List[int]) -> int:\r\n        n, max_len, ans = len(nums), 0, 0\r\n        dp = [0] * n\r\n        cnt = [0] * n\r\n        for i, x in enumerate(nums):\r\n            dp[i] = 1\r\n            cnt[i] = 1\r\n            for j in range(i):\r\n                if x > nums[j]:\r\n                    if dp[j] + 1 > dp[i]:\r\n                        dp[i] = dp[j] + 1\r\n                        cnt[i] = cnt[j] \r\n                    elif dp[j] + 1 == dp[i]:\r\n                        cnt[i] += cnt[j]\r\n            if dp[i] > max_len:\r\n                max_len = dp[i]\r\n                ans = cnt[i]  \r\n            elif dp[i] == max_len:\r\n                ans += cnt[i]\r\n        return ans\r\n```\r\n### 时间 O(n2)\r\n### 空间 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/61#issuecomment-1887432270","body":"### 思路： DP (二维）\r\n\r\n### 代码\r\n```Python\r\nclass Solution:\r\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\r\n        m, n = len(text1), len(text2)\r\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\r\n        \r\n        for i in range(1, m + 1):\r\n            for j in range(1, n + 1):\r\n                if text1[i - 1] == text2[j - 1]:\r\n                    dp[i][j] = dp[i - 1][j - 1] + 1\r\n                else:\r\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\r\n        \r\n        return dp[m][n]\r\n```\r\n\r\n*时间复杂度： O(m*n)\r\n*空间复杂度： O(m*n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"realduxy":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/8#issuecomment-1821429570","body":"# 题目名称\n旋转链表\n## 题目链接\n[题目链接](https://leetcode.cn/problems/rotate-list/)\n\n## 题目思路\n拆解链表，重新拼接，重点在于找到断点以及拼接操作\n\n## 题目代码\n```python\n# 这里写下解决问题的Python代码\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k == 0: return head\n        \n        # 特殊情况直接得到答案\n        total_length = 1\n        node = head\n        while node.next:\n            # print(node.next.val)\n            node = node.next\n            total_length += 1\n        print(\"final total length: \", total_length)\n\n        if k == total_length:\n            return head\n        if k > total_length:\n            k = k % total_length\n        print(\"final k: \", k)\n\n        if k == 0:\n            return head\n\n        # 本质上是找到断点，然后将断电后的链表移位\n        peak_node = head\n        for _ in range(total_length-k-1):\n            peak_node = peak_node.next\n        print(peak_node.val)\n\n        post_peak_node = peak_node.next\n        new_head = post_peak_node\n        print(k)\n        for _ in range(k-1):\n            post_peak_node = post_peak_node.next\n            print(post_peak_node.val)\n\n        post_peak_node.next = head\n        peak_node.next=None\n\n        return new_head\n\n## 复杂度\n时间: O(n)\n空间:O(1)\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/12#issuecomment-1826763800","body":"```pytho\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n        if not head :\n            return None \n\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if fast == slow:\n                slow = head\n                while slow != fast:\n                    slow = slow.next\n                    fast = fast.next\n                return slow\n        return None\n```\n\n双指针法，一前一后，有环迟早会相交\n\n时间复杂度O（N），空间复杂度O（1）\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/19#issuecomment-1837484688","body":"```pytho\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        nodes = list()\n\n        def dfs(node: TreeNode, row: int, col: int) -> None:\n            if not node: return\n            nodes.append((col, row, node.val))\n            dfs(node.right, row + 1, col + 1)\n            dfs(node.left, row + 1, col - 1)\n\n        dfs(root, 0, 0)\n        nodes.sort()\n        ans, lastcol = list(), -99999\n\n        for col, row, value in nodes:\n            if col != lastcol:\n                lastcol = col\n                ans.append([])\n            ans[-1].append(value)\n\n        return ans\n```\n\ndfs遍历\n\n时间复杂度O（nlogn），空间复杂度O（n）","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/24#issuecomment-1847415420","body":"```python\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        ls = len(s)         # 字符串s的长度\r\n        m = len(words)      # 总单词数量\r\n        n = len(words[0])   # 单个单词长度\r\n        res = []\r\n        if ls < m * n:\r\n            return res      # 字符串s的长度小于所有单词拼接起来的长度，直接返回\r\n        # 枚举每一个切分单词的起点，共有[0, n-1]个起点\r\n        for i in range(n):\r\n            diff = {}   # 记录滑动窗口中每个单词和words中对应单词的个数差值，diff为空，说明滑动窗口中的单词与word一致\r\n            # 从起点i开始，将前m个子串单词加入哈希表，前m个单词就是首个滑动窗口里的单词; j表示第几个单词\r\n            for j in range(m):\r\n                if i + (j + 1) * n > ls:    # 当前提取的子串单词右边界越界\r\n                    break\r\n                w = s[i + j * n : i + (j + 1) * n]\r\n                diff[w] = diff.get(w, 0) + 1\r\n            # 遍历words，进行做差\r\n            for word in words:\r\n                diff[word] = diff.get(word, 0) - 1\r\n                if diff[word] == 0:\r\n                    diff.pop(word)  # 单词数目为0，说明这个单词在滑动窗口和words的数目匹配，直接移除；\r\n            # 移动这个长度固定为m*n的滑动窗口，左边界left为每个单词的起点，滑动窗口范围[left, left + m * n)\r\n            for left in range(i, ls - m * n + 1, n):\r\n                # 从第二个单词开始，开始要加入新单词，移除旧单词\r\n                if left > i:\r\n                    w = s[left + (m - 1) * n : left + m * n]    # 从右边界right = left + (m - 1) * n，为要加入滑动窗口的单词的起点\r\n                    diff[w] = diff.get(w, 0) + 1    # 滑动窗口中加入一个单词，相当于差值+1\r\n                    if diff[w] == 0:\r\n                        diff.pop(w)\r\n                    w = s[left - n : left]          # 当前left的前一个单词是要移除的单词\r\n                    diff[w] = diff.get(w, 0) - 1    # 滑动窗口中移除一个单词，相当于差值-1\r\n                    if diff[w] == 0:\r\n                        diff.pop(w)\r\n                # diff为空，说明滑动窗口中的单词与word一致；left即为子串起点\r\n                if not diff:\r\n                    res.append(left)\r\n        return res\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/31#issuecomment-1857881998","body":"深度优先搜索\n\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        g = [[] for _ in range(n)]\n        for x, y in dislikes:\n            g[x - 1].append(y - 1)\n            g[y - 1].append(x - 1)\n        color = [0] * n  # color[x] = 0 表示未访问节点 x\n        def dfs(x: int, c: int) -> bool:\n            color[x] = c\n            return all(color[y] != c and (color[y] or dfs(y, -c)) for y in g[x])\n        return all(c or dfs(i, 1) for i, c in enumerate(color))\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/37#issuecomment-1866514234","body":"```python\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        def swap(nums, i, j):\n            nums[i], nums[j] = nums[j], nums[i]\n            return nums\n        # 冒泡排序\n        for i in range(0, len(nums)):\n            # 第 i 轮：开始一个一个调换\n            already_sorted = True\n            for j in range(len(nums)-i-1):\n                if nums[j+1] < nums[j]:\n                    nums = swap(nums, j+1, j)\n                    already_sorted = False\n            if already_sorted:\n                break\n\n        return nums\n```\n\n\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/41#issuecomment-1869035115","body":"class Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n\n        def isPossible(houses, heaters, r):\n            hs_index, ht_index = 0, 0\n            while hs_index < len(houses) and ht_index < len(heaters):\n                if abs(houses[hs_index] - heaters[ht_index]) <= r:\n                    hs_index += 1\n                else:\n                    ht_index += 1\n            \n            if hs_index < len(houses):\n                return False\n            elif hs_index == len(houses):\n                return True\n                \n                    \n      \n\n        if len(heaters) == 1:\n            return max(abs(heaters[-1]-houses[0]), abs(heaters[0] - houses[-1]))\n\n        # binary search\n        \n        left, right = 0, max(abs(heaters[-1]-houses[0]), abs(heaters[0] - houses[-1]))\n\n        while left <= right:\n            mid = (left+right) // 2\n            \n            if isPossible(houses, heaters, mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return left\n    \n    \n计算复杂度：\n假设两个列表长度分别为M,N，最极端的情况N=1，二分查找的最大复杂度明显是 O(logM)\n每次判断是否可以供暖的方法，使用双指针，所以还是O(M)\nSo最大时间复杂度是O(MlogM)\n\n空间复杂度 O（M+N）","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/48#issuecomment-1873367818","body":"class Solution: \n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        res = cursum = sum(cardPoints[-k:])\n        for i in range(k):\n            cursum += cardPoints[i] - cardPoints[-k+i]\n            res = max(res, cursum)\n        return res","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/58#issuecomment-1881236608","body":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        def climbing_stairs_n(n):\n            if n == 0 or n == 1:\n                return 0\n\n            if n - 1 in cost_table:\n                cost1 = cost_table[n-1]\n            else:\n                cost1 = climbing_stairs_n(n-1) + cost[n-1]\n                cost_table[n-1] = cost1\n            \n            if n - 2 in cost_table:\n                cost2 = cost_table[n-2]\n            else:\n                cost2 = climbing_stairs_n(n-2) + cost[n-2]\n                cost_table[n-2] = cost2\n\n    \n            return min(cost1, cost2)\n        \n        top_level = len(cost)\n\n        cost_table = {}\n\n        return climbing_stairs_n(top_level)\n    \n    \n计算复杂度：每阶算一次 O（N）\n\n空间复杂度 O（N）, 保存一个记忆表用于计算从0到n阶的最小化花费","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"awilekong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/28#issuecomment-1851729633","body":"二分查找class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        l = 0\n        r = len(nums)-1\n\n        while(l <= r):\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid+1\n            else:\n                r = mid-1\n        return l","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-12-daily-check/issues/33#issuecomment-1859026460","body":"class Solution:\n    def judgeCircle(self, moves):\n        \"\"\"\n        :type moves: str\n        :rtype: bool\n        \"\"\"\n        return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}