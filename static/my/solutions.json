{"michaelxi3":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184635948","body":"# Idea\r\nArray Iteration，从后往前进位\r\n# Code\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int index = num.length - 1;\r\n        \r\n        while (index >= 0 || k!=0) {\r\n            \r\n            if (index >= 0) {\r\n                k = num[index] + k;\r\n                index--;\r\n            }\r\n            // k != 0 时都要继续loop！因为有进位的 special case！\r\n            res.addFirst(k % 10);\r\n            k = k / 10;\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185699268","body":"# Idea\r\n> Two Pass, Array Manipulation\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] dist = new int[n];\r\n        // Step_1: Initialization\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) continue;\r\n            dist[i] = Integer.MAX_VALUE;\r\n        }\r\n        // First Pass: Left to Right\r\n        for (int i = 0; i < n-1; i++) {\r\n            if (dist[i] == Integer.MAX_VALUE) continue;\r\n            else dist[i + 1] = Math.min(dist[i+1], dist[i] + 1);\r\n        }\r\n        // Second Pass: Right to Left\r\n        for (int i = n-1; i > 0; i--) {\r\n            dist[i-1] = Math.min(dist[i-1], dist[i] + 1);\r\n        }\r\n        return dist; \r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186251631","body":"# Idea\r\n> Implement as an Array and keep track of maxSize and curSize\r\n# Code\r\n```java\r\nclass CustomStack {\r\n\r\n    private int[] arr;\r\n    private int maxSize;\r\n    private int curSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.arr = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        this.curSize = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (this.curSize >= this.maxSize) {\r\n            return;\r\n        } else {\r\n            arr[curSize] = x;\r\n            curSize++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (this.curSize <= 0) {\r\n            return -1;\r\n        } else {\r\n            curSize--;\r\n            return arr[curSize];\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if (curSize > 0) {\r\n            for (int i = 0; i < k && i < this.curSize; i++) {\r\n                arr[i] = arr[i] + val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186559715","body":"# Idea\r\n> Manipulation of Stack\r\n# Code\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Character> stack = new Stack<>(); // Using stack to decode\r\n\r\n        for (int i=0; i < s.length(); i++) {\r\n            char cur = s.charAt(i);\r\n    \r\n            if (cur == ']') {\r\n                StringBuilder sb = new StringBuilder();\r\n\r\n                // Pop out all characters until '['\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                String subString = sb.toString();\r\n                stack.pop(); // Pop out '['\r\n\r\n                // Pop out all numbers as frequency\r\n                sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                String Freq = sb.toString();\r\n\r\n                // Replicate substring based on frequency\r\n                int count = Integer.valueOf(Freq);\r\n                while (count > 0) {\r\n                    count--;\r\n                    for (char j : subString.toCharArray()) {\r\n                        stack.push(j);\r\n                    }\r\n                }\r\n            } else {\r\n                stack.push(cur);\r\n            }\r\n        }\r\n\r\n        // Retrieve answer from stack\r\n        StringBuilder ans = new StringBuilder();\r\n        while (!stack.isEmpty()) {\r\n            ans.insert(0, stack.pop());\r\n        }\r\n        return ans.toString();\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188398549","body":"# Idea\r\n> Input and Output Stack\r\n# Code\r\n```java\r\nclass MyQueue {\r\n    \r\n    Stack<Integer> input;\r\n    Stack<Integer> output;\r\n    \r\n    public MyQueue() {\r\n        this.input = new Stack<>();\r\n        this.output = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        this.input.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (!this.output.empty()) {\r\n            return this.output.pop();\r\n        } else {\r\n            while (!this.input.empty()) {\r\n                this.output.push(this.input.pop());\r\n            }\r\n            return this.output.pop();\r\n        }\r\n    }\r\n    \r\n    public int peek() {\r\n        if (!this.output.empty()) {\r\n            return this.output.peek();\r\n        } else {\r\n            while (!this.input.empty()) {\r\n                this.output.push(this.input.pop());\r\n            }\r\n            return this.output.peek();\r\n        }\r\n    }\r\n    \r\n    public boolean empty() {\r\n        if (this.input.empty() && this.output.empty()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189460545","body":"# Idea\r\n> 利用两个结论解决问题\r\n- 结论_1: Decreasing portion of array cannot be partitioned.\r\n- 结论_2: Non-Decreasing portion of array can be partitioned.\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        // Maintain a non-decreasing monotonic stack\r\n        for (int i=0; i < arr.length; i++) {\r\n            // 1. 出现递减的trend，需要进行融合\r\n            if (!stack.isEmpty() && arr[i] < stack.peek()) {\r\n                // 我们需要将融合后的区块的最大值重新放回栈\r\n                int localMax = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                } \r\n                stack.push(localMax);\r\n            // 2. 递增trend直接push到stack中就好\r\n            } else {\r\n                stack.push(arr[i]);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190558685","body":"# Idea\r\n> 因为题目中的 ListNode 只有 next pointer，所以我们最好先把 list 连接成一个 cycle，并在每次 rotate 后都更新 pointers 的位置。难点在于：pointer 向 next 方向所需移动的步数为 length - k % length，因为考虑到 k (rotate 数量) 大于 List Length 的情况。最后再将 cycle break 一下变成 list 返回 head 即可。\r\n# Code\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        // NULL head situation\r\n        if (head == null) {\r\n            return head;\r\n        }\r\n        \r\n        // Make a cycle\r\n        int length = 1;\r\n        ListNode end = new ListNode();\r\n        end = head;\r\n        while (end.next != null) {\r\n            end = end.next;\r\n            length++;\r\n        }\r\n        end.next = head;\r\n        \r\n        // Move k steps\r\n        for (int i = length - k % length; i >= 1; i--) {\r\n            head = head.next;\r\n            end = end.next;\r\n        }\r\n\t\t\t\t\r\n\t// Break the cycle\r\n        end.next = null;\r\n        \r\n        return head;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(n)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191950906","body":"# Idea\r\n> Linked List 题目的难点在于理清 Nodes 之间的 references，一般来说添加一个或多个 Dummy Node 会 makes life easier.\r\n# Code\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        // Using Dummy node to assist swapPairs\r\n        ListNode dummy = new ListNode(-1);\r\n        dummy.next = head;\r\n        ListNode pointer = dummy;\r\n        \r\n        // Start swapping!\r\n        while (pointer.next != null && pointer.next.next != null) {\r\n            ListNode swap1 = pointer.next;\r\n            ListNode swap2 = pointer.next.next;\r\n            \r\n            pointer.next = swap2;\r\n            swap1.next = swap2.next;\r\n            swap2.next = swap1;\r\n            \r\n            pointer = swap1;\r\n        }\r\n        \r\n        return dummy.next; // dummy.next always refer to the head\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193025145","body":"# Idea\r\n> 理解题目：\r\n观察题目给出的例子，我们可以看出 the middle of sorted list is the root of BST，这个 observation 可以 apply 到 root.left 和 root.right 的构建 recursively！\r\n\r\n> 解题方法：\r\n为了找到 the middle of LinkedList，我们可以使用快指针和慢指针的方法。最开始快慢指针都从 head 出发，快指针每次走两步、慢指针每次走一步。我们需要设置一个 Right Boundary, 当快指针到达或即将下一步越过右边界时停止，此时慢指针所在位置应为 list 的中间。我们把这个位置的慢指针当作本轮的 root node。\r\n# Code\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        // Empty tree case\r\n        if (head == null) { return null;}\r\n        // Initially, tail is null, the right boundary.\r\n        return buildTree(head, null); \r\n    }\r\n    \r\n    public TreeNode buildTree(ListNode head, ListNode tail) {\r\n        // Base case: NULL node\r\n        if (head == tail) { return null;}\r\n        \r\n        // Find the current tree root, the middle of List\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        while (fast != tail && fast.next != tail) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        TreeNode root = new TreeNode(slow.val);\r\n        \r\n        // Keep recursively build the tree\r\n        root.left = buildTree(head, slow);\r\n        root.right = buildTree(slow.next, tail);\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193158709","body":"# Idea\r\n> Use two pointers to one pass m+n\r\n# Code\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        // Boundary Check\r\n        if (headA == null || headB == null) { return null;}\r\n        // Two Pointers\r\n        ListNode aPointer = headA;\r\n        ListNode bPointer = headB;\r\n        \r\n        while (aPointer != bPointer) {\r\n            if (aPointer == null) { aPointer = headB;} else { aPointer = aPointer.next;}\r\n            if (bPointer == null) { bPointer = headA;} else { bPointer = bPointer.next;}\r\n        }\r\n        \r\n        return aPointer;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(m+n) // Two LinkedList Total Sum\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193383091","body":"# Idea\r\n> Fast & Slow Pointers\r\n# Code\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        \r\n        // Find the point of intersection b/w fast and slow pointers\r\n        while(fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            // Identify the intersection point\r\n            // Start the slow2 pointer to find the start of cycle\r\n            if (fast == slow) {\r\n                ListNode slow2 = head;\r\n                while (slow != slow2) {\r\n                    slow = slow.next;\r\n                    slow2 = slow2.next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194368980","body":"# Idea\r\n> Dummy nodes as head and tail && Hashmap to store key and val\r\n# Code\r\n```java\r\nclass LRUCache {\r\n    // 【核心思想】\r\n    // LinkedList: maintain a Double Linked List -> Switch Order based on LRU Rules\r\n    // With Dummy Head and Tail node to assist\r\n    \r\n    private int curSize;\r\n    private int maxSize; // Capacity\r\n    private Node head;   // Dummy Node\r\n    private Node tail;   // Dummy Node\r\n    private HashMap<Integer, Node> map; // Key & Node -> For 'get' method\r\n    \r\n    // Node Class for DLL\r\n    public class Node {\r\n        // Private fields of Node\r\n        private int key;\r\n        private int val;\r\n        private Node prev;\r\n        private Node next;\r\n        \r\n        public Node (int key, int val) {\r\n            this.key = key;\r\n            this.val = val;\r\n        }\r\n\r\n        public Node () {}\r\n    } \r\n    \r\n    // Constructor\r\n    public LRUCache(int capacity) {\r\n        this.head = new Node();\r\n        this.tail = new Node();\r\n        this.maxSize = capacity;\r\n        this.curSize = 0;\r\n        // Build connections\r\n        this.head.next = this.tail;\r\n        this.head.prev = null;\r\n        this.tail.prev = this.head;\r\n        this.tail.next = null;\r\n        this.map = new HashMap<>();\r\n    }\r\n    \r\n    // Get method: get value if key exists\r\n    public int get(int key) {\r\n        Node cur = map.get(key);\r\n        // Case_1: Key doesn't exist\r\n        if (cur == null) { return -1;}\r\n        // Case_2: Key exists, return and move to front since used\r\n        // Action_LRU: Move to the front\r\n        remove(cur);\r\n        addFront(cur);\r\n        return cur.val;\r\n    }\r\n      \r\n    // Put method: maintain size under capacity\r\n    public void put(int key, int value) {\r\n        Node cur = this.map.get(key);\r\n        // Case_1: If this key doesn't exist, add new pair of key and val\r\n        if (cur == null) {\r\n            Node newNode = new Node(key, value);\r\n            addFront(newNode);\r\n            // Check if exceeds size limitation\r\n            if (this.curSize > this.maxSize) {\r\n                remove(this.tail.prev);\r\n            }\r\n        // Case_2: If this key already existed, update value and move to front! Do not create a new one again!!!\r\n        } else {\r\n            cur.val = value;\r\n            // Updated val & Move to front\r\n            remove(cur);\r\n            addFront(cur);\r\n        }\r\n    }\r\n    \r\n    // Helper Methods\r\n    public void addFront (Node cur) {\r\n        // Insert between head dummy node and previous head\r\n        cur.next = this.head.next;\r\n        this.head.next.prev = cur;\r\n        this.head.next = cur;\r\n        cur.prev = head;\r\n        // If new key, add. Otherwise, just move to front\r\n        if (!map.containsKey(cur.key)) {\r\n            this.curSize++;\r\n            this.map.put(cur.key, cur);\r\n        }\r\n    }\r\n    \r\n    public void remove (Node cur) {\r\n        cur.prev.next = cur.next;\r\n        cur.next.prev = cur.prev;\r\n        map.remove(cur.key, cur);\r\n        this.curSize--;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196010591","body":"# Idea\r\n- Recursively find the maxDepth\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        \r\n        TreeNode left = root.left;\r\n        TreeNode right = root.right;\r\n        \r\n        int leftDepth = maxDepth(left);\r\n        int rightDepth = maxDepth(right);\r\n        \r\n        return 1 + Math.max(leftDepth, rightDepth);\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197315981","body":"# Idea\r\n> Recursion DFS check\r\n# Code\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        // Base case\r\n        // 若当前节点都为null，则一致\r\n        if (p == null && q == null) { \r\n            return true; \r\n        } \r\n        // 若当前节点比较中，一个为null、一个不为null，则不一致\r\n        if (p == null || q == null) { \r\n            return false; \r\n        }\r\n\r\n        // Inductive steps\r\n        // 若当前节点比较中，两个node都不为null时，需判读val是否一样 \r\n        // 比较 Left branch 是否一样 && 比较 Right branch 是否一样 \r\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184674932","body":"## 思路\n注意 k 、num数组、以及进位问题即可。\n- Java：数组遍历\n- Python： 字符串偷懒\n\n## 解题\nJava:\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> arr = new LinkedList<>();\n        int index = num.length - 1;\n        int plus = 0;\n        while (k > 0 || plus != 0 || index > -1) {\n            int mod = k % 10 + plus;\n            k /= 10;\n            if (index > -1) {\n                mod += num[index--];\n            }\n            arr.addFirst(mod % 10);\n            plus = mod / 10;\n        }\n        return arr;\n    }\n}\n```\nPython:\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = reduce(lambda x, y: x * 10 + y, num) + k\n        return [0] if n == 0 else [int(i) for i in str(n)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186186080","body":"## 思路\n1. 遍历查询所有s中等于c的下标并保存\n2. 二次遍历并对比该字符到两端的最短距离\n\n## 代码\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ret = new int[s.length()];\n        ArrayList<Integer> index = new ArrayList<>();\n        index.add(-s.length() - 1);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c){\n                index.add(i);\n            }\n        }\n        index.add(s.length() * 2);\n        int point = 1;\n        for (int i = 0; i < s.length(); i++) {\n            ret[i] = Math.min(i - index.get(point - 1),index.get(point) - i);\n            if (i == index.get(point)){\n                point++;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n## 复杂度\n时间复杂度： O(N)\n空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186522499","body":"## 思路\n使用数组模拟栈操作\n\n## 解题\n```Java\nclass CustomStack {\n    int[] stack;\n    int[] nums;\n    int p = -1;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        nums = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (p < stack.length - 1) {\n            stack[++p] = x;\n        }\n    }\n\n    public int pop() {\n        if (p >= 0) {\n            int val = stack[p];\n            int num = nums[p];\n            nums[p--] = 0;\n            if (p >= 0) {\n                nums[p] += num;\n            }\n            return val + num;\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        if ( p >= 0){\n            k = Math.min(k - 1, p);\n            nums[k] += val;\n        }\n    }\n}\n```\n## 复杂度\n时间复杂度: O(1)\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186565468","body":"## 思路\n使用栈的压入弹出，根据右括号作为弹栈的触发。\n\n## 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in s:\n            if i == ']':\n                strs = ''\n                repeat = ''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop() + repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n```\n## 复杂度\n- 时间复杂度： O(N)\n- 空间复杂度： O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188936014","body":"## 思路\n使用两个栈，来实现队列的操作\n## 代码\n```python\nclass MyQueue:\n    def __init__(self):\n        self.stack1, self.stack2 = [], []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        return self.stack2[-1] if self.stack2 else self.stack1[0]\n\n    def empty(self) -> bool:\n        return len(self.stack1) + len(self.stack2) == 0\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190382731","body":"## 思路\n基础栈操作\n## 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i in arr:\n            if stack and i < stack[-1]:\n                head = stack[-1]\n                while stack and i < stack[-1]:\n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(i)\n        return len(stack)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191540789","body":"## 思路\n快慢指针，完成环的断开操作。\n## 代码\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        count = 0\n        cur = head\n        while cur:\n            count += 1\n            cur = cur.next\n        if count <= 1 or k % count == 0:\n            return head\n        k = k % count\n        slow = fast = head\n        while k:\n            fast = fast.next\n            k -= 1\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        new_head = slow.next\n        slow.next = None\n        fast.next = head\n        return new_head\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192641820","body":"## 思路\n使用指针复制，完成交换\n## 代码\n```python\nclass Solution:\n    def swapPairs(self, head):\n        ret = ListNode()\n        ret.next = head\n        tmp = ret\n        while tmp.next and tmp.next.next:\n            t3 = tmp.next.next.next\n            t2 = tmp.next\n            tmp.next = tmp.next.next\n            tmp.next.next = t2\n            t2.next = t3\n            tmp = t2\n        return ret.next\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146136","body":"## 思路\n初始化二叉树，并根据链表构造二叉树\n## 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head):\n        def get_mid(left, right):\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n\n        def tree(left, right):\n            if left == right:\n                return None\n            mid = get_mid(left, right)\n            root = TreeNode(mid.val)\n            root.left = tree(left, mid)\n            root.right = tree(mid.next, right)\n            return root\n\n        return tree(head, None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193296735","body":"## 思路\n使用快慢指针，完成相交链表的确定\n## 代码\n```python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        d = {}\n        while headA:\n            d[headA] = headA.val\n            headA = headA.next\n        while headB:\n            if d.get(headB):\n                return headB\n            headB = headB.next\n        return None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193995380","body":"## 思路\n采用快慢指针，看是否两个指针会相遇，即可判断链表是否有环。\n## 代码\n```python\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                point = head\n                while point!=slow:\n                    point = point.next\n                    slow = slow.next\n                return point\n\n        return None\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196618976","body":"## 代码\n```python\nclass Solution:\n    def maxDepth(self, root):\n        if not root:\n            return 0\n        else:\n            return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184759423","body":"**智商不够，硬解来凑**\n\n----------------------\n\n> 思路：把整数转成数组，同时创建一个长度+1的备用数组防止溢出，各位分别做十进制加法，不溢出则截断数组返回答案。\n\n------------\n\n*代码*\n\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\n/**\n * @author boyu\n */\npublic class Solution {\n    static int[] addArrAndInt(int[] nums,int k){\n        ArrayList<Integer> al = new ArrayList<>();\n        do{\n            al.add(k % 10);\n        }while ((k /= 10) > 0);\n        Collections.reverse(al);\n        int[] arr = new int[al.size()];\n        for (int i = 0; i < al.size(); i ++) {\n            arr[i] = al.get(i);\n\n        }\n        return addTwoArr(nums, arr);\n    }\n    static int[] addTwoArr(int[] arr1, int[] arr2){\n        int tag = 0;\n        int t;\n        int ptr1 = arr1.length;\n        int ptr2 = arr2.length;\n        int[] res = new int[Math.max(ptr1, ptr2) + 1];\n        Arrays.fill(res, 0);\n        for (int i = res.length - 1; i >= 0 ; i --) {\n            if(ptr1 < 1 && ptr2 < 1) {\n                res[i] = tag;\n                break;\n            }else if(ptr1 < 1){\n                t = arr2[-- ptr2] ;\n            }else if(ptr2 < 1){\n                t = arr1[-- ptr1] ;\n            }else {\n                t = arr1[-- ptr1] + arr2[-- ptr2];\n            }\n            res[i] = (t + tag) % 10;\n            if (t + tag >= 10){\n                tag = 1;\n            }else {\n                tag = 0;\n            }\n        }\n        if ( res[0] != 1 ){\n            return Arrays.copyOfRange(res, 1, res.length);\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[] arr= {9, 9, 9};\n        int k = 1;\n        System.out.println(\"{9, 9, 9} + 1 = \" + Arrays.toString(Solution.addArrAndInt(arr, k)));\n    }\n}\n```\n\n--------------\n\n***萌新刚接触算法没思路求大佬们轻喷，后续会努力学习大佬解法，献丑了。***\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185723846","body":"> 思路：对每一个点进行左右遍历，取最小值。\r\n\r\n------------\r\n\r\n代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] ans = new int[len];\r\n        Arrays.fill(ans, Integer.MAX_VALUE);\r\n        int t;\r\n        for (int i = 0; i < len; i++) {\r\n            t = i; //扫左边\r\n            while (t >= 0){\r\n                if (s.charAt(t) == c){\r\n                    ans[i] = Math.min(ans[i], Math.abs(i - t));\r\n                }\r\n                t --;\r\n            }\r\n            t = i; //扫右边\r\n            while (t < len){\r\n                if (s.charAt(t) == c){\r\n                    ans[i] = Math.min(ans[i], Math.abs(t - i));\r\n                }\r\n                t ++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186482276","body":"> 思路：基础栈操作，使用数组作为栈结构\n\n------------\n\n*代码*\n\n```java\nclass CustomStack {\n\n    int[] myStack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        this.myStack = new int[maxSize];\n        this.top = -1;\n    }\n    \n    public void push(int x) {\n        if (this.top < myStack.length - 1){\n            this.top ++;\n            this.myStack[this.top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (this.top <= -1){\n            return -1;\n        }\n        return this.myStack[this.top --];\n    }\n    \n    public void increment(int k, int val) {\n        if (this.top <= k - 1){\n            for (int i = 0; i < this.myStack.length; i++) {\n                this.myStack[i] += val;\n            }\n        }else {\n            for (int i = 0; i < k; i++) {\n                this.myStack[i] += val;\n            }\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187136118","body":"\n> 思路：利用栈进行括号匹配。\n\n------------\n\n*代码*\n\n```java\nclass Solution {\n    int p;\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        p = 0;\n\n        while (p < s.length()){\n            char c = s.charAt(p);\n            if (Character.isDigit(c)){\n                StringBuilder sb = new StringBuilder();\n                while (Character.isDigit(s.charAt(p))){\n                    sb.append(s.charAt(p ++));\n                }\n                stk.addLast(sb.toString());\n            }else if (Character.isLetter(c) || c == '['){\n                stk.addLast(String.valueOf(s.charAt(p ++)));\n            }else{\n                ++ p;\n                LinkedList<String> su = new LinkedList<String>();\n                while (! \"[\".equals(stk.peekLast())){\n                    su.add(stk.removeLast());\n                }\n                Collections.reverse(su);\n                stk.removeLast();\n                int time = Integer.parseInt(stk.removeLast());\n                StringBuilder t = new StringBuilder();\n                String o = getString(su);\n                while (time -- > 0) {\n                    t.append(o);\n                }\n                stk.addLast(t.toString());\n            }\n        }\n        return getString(stk);\n\n    }\n    public String getString(LinkedList<String> v) {\n        StringBuilder ret = new StringBuilder();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n```\n\n--------------\n\nday4\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189016953","body":"\n----------------------\n\n> 思路：利用辅助空间完成两个栈之间内容的交换，一个栈发生变化时同时改变另一个栈。\n\n------------\n\n*代码*\n\n```java\nclass MyQueue {\n    Stack<Integer> stackHead;\n    Stack<Integer> stackTail;\n    List<Integer> tmp;\n    \n    public MyQueue() {\n        this.stackHead = new Stack<>();\n        this.stackTail = new Stack<>();\n        this.tmp = new ArrayList<>();\n    }\n    \n    public void push(int x) {\n        this.stackTail.push(x);\n        exchangeStackContents(this.stackTail, this.stackHead);\n    }\n    public int pop() {\n        int x = stackHead.pop();\n        exchangeStackContents(this.stackHead, this.stackTail);\n        return x;\n    }\n    public void exchangeStackContents(Stack<Integer> stackA, Stack<Integer> stackB){\n        this.tmp.clear();\n        stackB.clear();\n        while (!stackA.empty()){\n            this.tmp.add(stackA.pop());\n        }\n        for (int i = 0; i < this.tmp.size(); i++) {\n            stackA.push(this.tmp.get(this.tmp.size() - i -1));\n            stackB.push(this.tmp.get(i));\n        }\n    }\n    \n    public int peek() {\n        return this.stackHead.peek();\n    }\n    \n    public boolean empty() {\n        return this.stackHead.empty();\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190395437","body":"\n> 思路：利用单调栈的性质。\n\n------------\n\n*代码*\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] t = arr.clone();\n        Arrays.sort(t);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = t[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191615226","body":"----------------------\n\n> 思路：移动链表成环，选好位置切开。\n\n------------\n\n*代码*\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n\n        int length = 0;\n        ListNode left = head;\n        ListNode right = head;\n        if (head == null) {\n            return head;\n        }\n        while (right.next != null) {\n            length++;\n            right = right.next;\n        }\n        length ++;\n        right.next = head;\n        k = (length - k % length) - 1;\n        right = head;\n        while (k > 0) {\n            k --;\n            right = right.next;\n        }\n        left = right.next;\n        right.next = null;\n        return left;\n    }\n```\n--------------","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192639706","body":"> 思路：递归交换节点\n\n------------\n\n*代码*\n\n```java\npublic ListNode swapPairs(ListNode head) { \n        if (head == null || head.next == null) { \n            return head; \n        } \n        ListNode newHead = head.next; \n        head.next = swapPairs(newHead.next); \n        newHead.next = head; \n        return newHead; \n    }\n```\n--------------\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193112537","body":"```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n      if(head == null)return null;\r\n      if(head.next == null)return new TreeNode(head.val);\r\n\r\n      List<Integer> list = new ArrayList<>();\r\n      while(head != null){\r\n        list.add(head.val);\r\n        head = head.next;\r\n      }\r\n      return buildTree(0, list.size() - 1, list);\r\n    }\r\n\r\n    TreeNode buildTree(int left, int right, List<Integer> list){\r\n      if(left > right)return null;\r\n      int mid = left + (right - left + 1) / 2;\r\n      TreeNode root = new TreeNode(list.get(mid));\r\n      root.left = buildTree(left, mid - 1, list);\r\n      root.right = buildTree(mid + 1, right, list);\r\n      return root;\r\n    }\r\n}\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193261334","body":"将已访问结点加入list进行判断，逐个遍历两个链表并判断是否存在\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ArrayList<ListNode> al=new ArrayList<>();\r\n        while(headA!=null){\r\n           if(al.contains(headA)){\r\n                    return headA;\r\n                }else{\r\n                    al.add(headA);\r\n                }\r\n                headA=headA.next;\r\n            }\r\n            \r\n            while(headB!=null){\r\n                if(al.contains(headB)){\r\n                    return headB;\r\n                }else{\r\n                    al.add(headB);\r\n                }\r\n                headB=headB.next;\r\n            }   \r\n        return null;\r\n    }\r\n}\r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194053388","body":"利用set性质解决\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        Set<ListNode> arr=new HashSet<>();\r\n        while (head!=null){\r\n            if (!arr.add(head)) {\r\n                return head;\r\n            }\r\n            head=head.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195433538","body":"```java\r\n class LRUCache extends LinkedHashMap<Integer, Integer>{\r\n    private int capacity;\r\n    \r\n    public LRUCache(int capacity) {\r\n        super(capacity, 0.75F, true);\r\n        this.capacity = capacity;\r\n    }\r\n\r\n    public int get(int key) {\r\n        return super.getOrDefault(key, -1);\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        super.put(key, value);\r\n    }\r\n\r\n    @Override\r\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\r\n        return size() > capacity; \r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196755817","body":"每个子树的高度等于高度最大的子树高度+1\r\n\r\n```java\r\npublic int maxDepth(TreeNode root) {\r\n        if (root == null){\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;\r\n    }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184788930","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = \"\"\n        for i in num:\n            s += str(i)\n            \n        answer = int(s) + k\n        \n        return  \"\".join(str(answer))\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186315034","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = deque()\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) == self.maxSize:\n            return\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        stack2 = deque()\n        if k < len(self.stack):\n            for i in range(len(self.stack) - k):\n                stack2.append(self.stack.pop())\n        while self.stack:\n            stack2.append(self.stack.pop() + val)\n        while stack2:\n            self.stack.append(stack2.pop())\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186584817","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = deque()\n        count = 0\n        string = ''\n        \n        for char in s:\n            if char.isdigit():\n                count = count * 10 + int(char)\n            elif char == '[':\n                stack.append(string)\n                stack.append(count)\n                count = 0\n                string = ''\n            elif char == ']':\n                last_count = stack.pop()\n                last_string = stack.pop()\n                \n                string = last_string + last_count * string\n            else:\n                string += char\n        \n        return string\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187778722","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = deque()\n        self.stack2 = deque()\n\n    # O(1)\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    # O(N)\n    def pop(self) -> int:\n        while len(self.stack1) > 1:\n            self.stack2.append(self.stack1.pop())\n        res = self.stack1.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        \n        return res\n    \n    # O(N)\n    def peek(self) -> int:\n        res = -1\n        while self.stack1:\n            if len(self.stack1) == 1:\n                res = self.stack1[0]\n            self.stack2.append(self.stack1.pop())\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return res\n    \n    # O(1)\n    def empty(self) -> bool:\n        return len(self.stack1) == 0\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189441929","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        res = []\n        \n        for i, n in enumerate(arr):\n            maxn = n\n            while res and res[-1] > n:\n                maxn = max(maxn, res.pop())\n            res.append(maxn)\n        \n        return len(res)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190757842","body":"```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return head\n        count = 0\n        curr = head\n        tail = None\n        while curr:\n            if not curr.next: tail = curr\n            curr = curr.next\n            count += 1\n                \n        k = k % count\n        \n        if k == 0: return head\n        \n        curr = head\n        for i in range(k):\n            curr = curr.next\n        \n        curr2 = head\n        while curr.next:\n            curr = curr.next\n            curr2 = curr2.next\n        dummy = curr2.next\n        curr2.next = None\n        tail.next = head\n        \n        return dummy\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191778580","body":"```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: \n            return head\n        \n        next_node = head.next.next\n        new_head = head.next\n        new_head.next = head\n        head.next = self.swapPairs(next_node)\n        \n        return new_head\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1192970594","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head: \n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        \n        # find mid node\n        slow = head\n        fast = head.next.next\n        while fast and fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        node = TreeNode(slow.next.val)\n        temp_right = slow.next.next\n        slow.next = None\n        node.right = self.sortedListToBST(temp_right)\n        node.left = self.sortedListToBST(head)\n        \n        return node\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193231517","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        p1 = headA\n        p2 = headB\n        \n        swap_1 = False\n        swap_2 = False\n        \n        while p1 and p2:\n            if p1 == p2:\n                return p1\n            \n            p1 = p1.next\n            p2 = p2.next\n            \n            if not p1 and not swap_1:\n                p1 = headB\n                swap_1 = True\n            if not p2 and not swap_2:\n                p2 = headA\n                swap_2 = True\n        \n        return None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193385407","body":"```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head: return head\n        \n        slow = head\n        fast = head\n        meet = None\n        # meet somewhere inside cycle if any\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                meet = slow\n                fast = head\n                break\n        # no cycle\n        if not meet: return None\n        \n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        \n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194493371","body":"```python\nclass ListNode:\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.next = None\n        self.prev = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.head = ListNode(-1, -1)\n        self.tail = ListNode(-1, -1)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        # key - node\n        self.mapping = {}\n        self.capacity = capacity\n\n    def delete(self, node):\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n        node.prev = None\n        node.next = None\n        \n        self.capacity += 1\n        del self.mapping[node.key]\n        \n    def add(self, node):\n        prev_node = self.tail.prev\n        prev_node.next = node\n        node.next = self.tail\n        self.tail.prev = node\n        node.prev = prev_node\n        \n        self.capacity -= 1\n        self.mapping[node.key] = node\n        \n    def get(self, key: int) -> int:\n        if key not in self.mapping: return -1\n        node = self.mapping[key]\n        self.delete(node)\n        self.add(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.mapping:\n            self.delete(self.mapping[key])\n        elif self.capacity == 0:\n            self.delete(self.head.next)\n        node = ListNode(key, value)\n        self.add(node)\n        \n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195747599","body":"```python\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        \n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        \n        return max(left, right) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197019493","body":"```python\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q: return True\n        if not p or not q: return False\n        if p.val != q.val: return False\n        \n        left_check = self.isSameTree(p.left, q.left)\n        right_check = self.isSameTree(p.right, q.right)\n        \n        return left_check and right_check\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184790165","body":"## Add Entire K to the first column to the right and carry over ```addend // 10``` to the next (left) column\n## Python Solution\n```\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        index = len(num) - 1\n        add = k\n        result = []\n        \n        # Iterate from right end of the array\n        while index >= 0 or add > 0:\n             # Whenever not at the end of the array, add the digit\n             if index >= 0:\n                add += num[index]\n            add, mod = divmod(add, 10)\n            result.insert(0, mod)\n            index -= 1\n        return result\n```\n## Complexity\nTime: O(n)   Space: O(n) where n is the length of the array num","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185890807","body":"## Two Pass\n## Python solution\n```\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        prev = float('-inf')\n        ans = []\n        # left\n        for i in range(len(s)):\n            if s[i] == c:\n                prev = i\n            ans.append(i - prev)\n        # right\n        prev = float('inf')\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], prev - i)\n        return ans\n```\n## Complexity\nTime: O(n)\nSpace: O(n) where n is the length of array s","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186247118","body":"## OOD with python list\n## Python solution\n```\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n\n        self.maxSize = maxSize\n        self.data = []\n        \n\n    def push(self, x):\n\n        if len(self.data) < self.maxSize:\n            self.data.append(x)\n        else:\n            pass\n        \n\n    def pop(self):\n\n        if len(self.data) == 0:\n            return -1\n        else:\n            return self.data.pop()\n        \n\n    def increment(self, k, val):\n\n        for i in range(min(len(self.data), k)):\n            self.data[i] += val\n    \n```\n## Complexity\n```push()``` O(1)\n```pop()``` O(1)\n```increment``` O(min(n, k))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186738383","body":"## Use stack to complete the decode within each pairs of bracket, pushing the decoded string in the brackets to the stack again.\n## Python solution\n```\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        ans = \"\"\n        \n        for c in s:\n            # Not closing brackets, push into stack\n            if c != ']':\n                stack.append(c)\n            else:\n                # Otherwise, first get the characters within the brackets\n                r = \"\"\n                while stack and stack[-1] != '[':\n                    # reverse the order\n                    r = stack.pop() + r\n\n                # pop the opening bracket out\n                stack.pop()\n                \n                # get the number of times to repeat\n                n = \"\"\n                while stack and stack[-1].isnumeric():\n                    f = stack.pop()\n                    # reverse order\n                    n = f + n\n                \n                # push the cleaned and decoded string into the stack\n                stack.append(r * int(n))\n        for c in stack:\n            ans += c\n        \n        return ans\n```\n## Complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187711286","body":"## Use two stacks to handle push\n## Python solution\n```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x):\n        while self.s1:\n            self.s2.append(self.s1.pop())\n        self.s1.append(x)\n        while self.s2:\n            self.s1.append(self.s2.pop())\n            \n    def pop(self):\n        return self.s1.pop()\n\n    def peek(self):\n        return self.s1[-1]\n\n    def empty(self):\n        return not self.s1\n```\n## Complexity\nPush O(n) others O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189454716","body":"## Current min greater than previous high, add to stack\r\n## Python sol\r\n```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        stack = []\r\n        \r\n        stack.append((arr[0], arr[0]))\r\n        \r\n        for i in range(1, len(arr)):\r\n            low, high = arr[i], arr[i]\r\n            while stack and stack[-1][1] > low:\r\n                prev_low, prev_high = stack.pop()\r\n                low, high = min(prev_low, low), max(prev_high, high)\r\n            stack.append((low, high))\r\n        return len(stack)\r\n```\r\n## Complexity\r\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190938089","body":"## Idea\nCount total nodes and make a cycle\nUse to mod to determine the break point in the middle\n## Python Solution\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        n = 1\n        dummy = head\n        while dummy.next:\n            n += 1\n            dummy = dummy.next\n        \n        dummy.next = head\n        \n        current = head\n        for i in range(n-k % n-1):\n            current = current.next\n        \n        new = current.next\n        current.next = None\n        return new\n```\n## Complexity\nSpace: O(1)\nTime: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191954438","body":"## Dummy node\n## Python solution\n```\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(-1)\n        dummy.next = head\n        prev = dummy\n        while head and head.next:\n            first = head\n            second = head.next\n            \n            prev.next = second\n            first.next = second.next\n            second.next = first\n            \n            prev = first\n            head = first.next\n        return dummy.next\n```\n## Complexity\nSpace O(1)\nTime O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193046193","body":"## Idea, find mid point, break linked list into left and right part, then use recursion to build mid value node\n## Python Solution\n```\nclass Solution:\n    def findMid(self, head):\n        slow = head\n        fast = head\n        prev = None\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        if prev:\n            prev.next = None\n        return slow\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        mid = self.findMid(head)\n        node = TreeNode(mid.val)\n        \n        if head == mid:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(mid.next)\n        return node\n```\n## Complexity\nTime O(nlogn)\nSpace O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193162405","body":"## Hashset\n## Python solution\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a = set()\n        while headA:\n            a.add(headA)\n            headA = headA.next\n        \n        while headB:\n            if headB in a:\n                return headB\n            headB = headB.next\n        return None\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194271897","body":"## Hash table\n## Python Solution\n```\nclass Solution(object):\n    def detectCycle(self, head):\n        visited = set()\n\n        node = head\n        while node:\n            if node in visited:\n                return node\n            else:\n                visited.add(node)\n                node = node.next\n\n        return None\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194972865","body":"## 从来没懂过，面试遇到也是直接背答案\n## Python solution\n```\nclass Node:\n    def __init__(self, k, v):\n        self.key = k\n        self.val = v\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.dic = dict()\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key):\n        if key in self.dic:\n            n = self.dic[key]\n            self._remove(n)\n            self._add(n)\n            return n.val\n        return -1\n\n    def put(self, key, value):\n        if key in self.dic:\n            self._remove(self.dic[key])\n        n = Node(key, value)\n        self._add(n)\n        self.dic[key] = n\n        if len(self.dic) > self.capacity:\n            n = self.head.next\n            self._remove(n)\n            del self.dic[n.key]\n\n    def _remove(self, node):\n        p = node.prev\n        n = node.next\n        p.next = n\n        n.prev = p\n\n    def _add(self, node):\n        p = self.tail.prev\n        p.next = node\n        self.tail.prev = node\n        node.prev = p\n        node.next = self.tail\n```\n## Complexity\nTime: O(n), O(1)\nSpace: O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195716705","body":"## Recursion\n## Python solution\n```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root:\n            left = self.maxDepth(root.left)\n            right = self.maxDepth(root.right)\n            return max(left, right) + 1\n        else:\n            return 0\n```\n## Complexity\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197092113","body":"```\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if not p:\n            return False\n        if not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184793730","body":"## Go Solution\r\nAdd the last digit of k to the last element in `num` as `sum`, then drop the last digit of k(k=k/10); eventually, check if k is equal to zero, if not, convert it to a new array and attach the num to the end.\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\ti := len(num) - 1\r\n\tfor i >= 0 || k > 0 {\r\n\t\tif i > 0 && k > 0 {\r\n\t\t\tsum := num[i] + k%10\r\n\t\t\tnum[i] = sum\r\n\t\t\tk = k / 10  // drop the last element of k\r\n\r\n\t\t\tif sum > 9 {\r\n\t\t\t\tnum[i] = sum % 10\r\n\t\t\t\tk++ //  add carry(1) to k\r\n\t\t\t}\r\n\t\t\ti--\r\n\t\t} else if i >= 0 {\r\n\t\t\tbreak\r\n\t\t} else {\r\n\t\t\tnum = append([]int{k % 10}, num...) \r\n\t\t}\r\n\t}\r\n\r\n\treturn num\r\n}\r\n```\r\n\r\n## Complexity: \r\nTIme: O(n)\r\nSpace: O(n) where m is the max between the length of num and k.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186121758","body":"## Day 2\r\n\r\n1. first loop: Save position of char c\r\n2. second loop: Compute the min distance between char c and other chars\r\n\r\nTime: O(n), space: O(n)\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n\tvar pos []int\r\n\tfor i, ch := range s {\r\n\t\tif byte(ch) == c {\r\n\t\t\tpos = append(pos, i)\r\n\t\t}\r\n\t}\r\n\tfmt.Printf(\"%v\", pos)\r\n\r\n\tres := []int{}\r\n\tfor i, ch := range s {\r\n\t\tif byte(ch) == c {\r\n\t\t\tres = append(res, 0)\r\n\t\t} else {\r\n\t\t\tmin := math.MaxInt16\r\n\t\t\tfor _, j := range pos {\r\n\t\t\t\tif min > abs(j-i) {\r\n\t\t\t\t\tmin = abs(j - i)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tres = append(res, min)\r\n\t\t}\r\n\t}\r\n\tfmt.Printf(\"%v\", res)\r\n\treturn res\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186433869","body":"## Day 3\r\n\r\n\r\n```go\r\ntype CustomStack struct {\r\n\tstack   []int\r\n\tmaxSize int\r\n\ttop     int\r\n}\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n\tcustomStack := CustomStack{}\r\n\tcustomStack.stack = make([]int, maxSize)\r\n\tcustomStack.maxSize = maxSize\r\n\tcustomStack.top = -1\r\n\r\n\treturn customStack\r\n}\r\n\r\n// Time: O(1)\r\nfunc (this *CustomStack) Push(x int) {\r\n\tif this.top+1 < this.maxSize {\r\n\t\tthis.top++\r\n\t\tthis.stack[this.top] = x\r\n\t}\r\n}\r\n\r\n// Time: O(1)\r\nfunc (this *CustomStack) Pop() int {\r\n\tif this.top < 0 {\r\n\t\treturn -1\r\n\t}\r\n\tx := this.stack[this.top]\r\n\tthis.top--\r\n\treturn x\r\n}\r\n\r\n// Time: O(n)\r\nfunc (this *CustomStack) Increment(k int, val int) {\r\n\tincrements := this.top + 1 // default value\r\n\tif increments > k {\r\n\t\tincrements = k\r\n\t}\r\n\r\n\tfor i := 0; i < increments; i++ {\r\n\t\tthis.stack[i] += val\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186892128","body":"## Day 4\r\n\r\n```go\r\nfunc decodeString(s string) string {\r\n\tstr, _ := expand([]byte(s), 0)\r\n\treturn string(str)\r\n}\r\n\r\nfunc expand(s []byte, i int) ([]byte, int) {\r\n\tvar expanded []byte\r\n\tvar digits []byte\r\n\tfor i < len(s) && s[i] != ']' {\r\n\t\tc := s[i]\r\n\t\tif c >= 'a' && c <= 'z' {\r\n\t\t\texpanded = append(expanded, c)\r\n\t\t} else if c >= '0' && c <= '9' {\r\n\t\t\tdigits = append(digits, c)\r\n\t\t} else if c == '[' {\r\n\t\t\tnested, idx := expand(s, i+1)\r\n\t\t\tnumTimes, _ := strconv.Atoi(string(digits))\r\n\t\t\tdigits = digits[:0]\r\n\t\t\tfor numTimes > 0 {\r\n\t\t\t\texpanded = append(expanded, nested...)\r\n\t\t\t\tnumTimes--\r\n\t\t\t}\r\n\t\t\ti = idx\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn expanded, i\r\n}\r\n```\r\nComplexity: Time: O(n), Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188529736","body":"## Day 5\r\n\r\n```java\r\nclass MyQueue {\r\n\r\n    /** Initialize your data structure here. */\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    int front;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        if(s1.isEmpty()) {\r\n            front = x;\r\n        }\r\n    \r\n        s1.add(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(s2.isEmpty()) {\r\n            while(!s1.isEmpty()){\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        \r\n        return s2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(!s2.isEmpty()) {\r\n            return s2.peek();\r\n        }\r\n        \r\n        return front;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s2.isEmpty() && s1.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190154617","body":"```go \r\nfunc maxChunksToSorted(arr []int) int {\r\n\tchunks := 0\r\n\tsortedArray := make([]int, len(arr))\r\n\tcopy(sortedArray, arr)\r\n\tsort.Ints(sortedArray)\r\n\tdiffer := make(map[int]int)\r\n\tfor i := 0; i < len(arr); i++ {\r\n\t\tdiffer[sortedArray[i]]++\r\n\t\tdiffer[arr[i]]--\r\n\t\tif differ[sortedArray[i]] == 0 {\r\n\t\t\tdelete(differ, sortedArray[i])\r\n\t\t}\r\n\t\tif differ[arr[i]] == 0 {\r\n\t\t\tdelete(differ, arr[i])\r\n\t\t}\r\n\t\tif len(differ) == 0 {\r\n\t\t\tchunks++\r\n\t\t}\r\n\t}\r\n\treturn chunks\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191091790","body":"## Day 07\r\n\r\n```go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    length := 0\r\n    tail := head\r\n    cur := head\r\n    for tail != nil && tail.Next != nil {\r\n        length++\r\n        tail = tail.Next\r\n    }\r\n    length++\r\n    \r\n    // 1,2,3,4,5->null => 1,2,3, 4(curr),5,1,2,3 ->null\r\n    for i := 0; i < length - (k % length); i++ {\r\n        if tail != nil {\r\n            tail.Next = &ListNode{ Val: cur.Val, }\r\n            tail = tail.Next\r\n            cur = cur.Next\r\n        }\r\n    }\r\n    \r\n    return cur\r\n}\r\n```\r\n\r\nTime: O(n), Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192202775","body":"## Day 8\r\n```go\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    if head == nil {\r\n        return nil\r\n    }\r\n    \r\n    return helper(head, true)\r\n}\r\n\r\nfunc helper(head *ListNode, toSwap bool) *ListNode {\r\n    if head.Next == nil {\r\n        return head\r\n    }\r\n    \r\n    if toSwap {\r\n        temp := head.Next.Val\r\n        head.Next.Val = head.Val\r\n        head.Val = temp\r\n    }\r\n    \r\n    return &ListNode{\r\n        Val: head.Val,\r\n        Next: helper(head.Next, !toSwap),\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193064281","body":"## Day 9\r\n\r\n```go\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n\tif head == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tif head.Next == nil {\r\n\t\treturn &TreeNode{head.Val, nil, nil}\r\n\t}\r\n\r\n\tvar prev *ListNode\r\n\tslow, fast := head, head\r\n\r\n\tfor fast != nil && fast.Next != nil {\r\n\t\tprev = slow\r\n\t\tslow = slow.Next\r\n\t\tfast = fast.Next.Next\r\n\t}\r\n\tprev.Next = nil               // break slow and previous node\r\n\troot := NewTreeNode(slow.Val) // set mid point as the root\r\n\r\n\troot.Left = sortedListToBST(head)\r\n\troot.Right = sortedListToBST(slow.Next)\r\n\r\n\treturn root\r\n}\r\n```\r\n\r\nTime: O(n), space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193256679","body":"## Day 10\r\n```go\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n\tset := map[*ListNode]struct{}{}\r\n\r\n\tfor headA != nil || headB != nil {\r\n\t\tif headA != nil {\r\n\t\t\tif _, ok := set[headA]; ok {\r\n\t\t\t\treturn headA\r\n\t\t\t}\r\n\t\t\tset[headA] = struct{}{}\r\n\t\t\theadA = headA.Next\r\n\t\t}\r\n\r\n\t\tif headB != nil {\r\n\t\t\tif _, ok := set[headB]; ok {\r\n\t\t\t\treturn headB\r\n\t\t\t}\r\n\t\t\tset[headB] = struct{}{}\r\n\t\t\theadB = headB.Next\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n```\r\n\r\nTime: O(m+n), space: O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193658695","body":"## Day 11\r\n\r\n```go\r\nfunc detectCycle(head *ListNode) *ListNode {\r\n\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tslow, fast := head, head\r\n\r\n\tfor fast != nil && fast.Next != nil {\r\n\t\tslow = slow.Next\r\n\t\tfast = fast.Next.Next\r\n\r\n\t\tif slow == fast {\r\n\t\t\tslow = head\r\n\t\t\tfor slow != fast {\r\n\t\t\t\tslow = slow.Next\r\n\t\t\t\tfast = fast.Next\r\n\t\t\t}\r\n\t\t\treturn slow\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n```\r\n\r\nTime: O(n), Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194986937","body":"## Day 12\r\n```go\r\ntype Node struct {\r\n\tkey  int\r\n\tval  int\r\n\tprev *Node\r\n\tnext *Node\r\n}\r\n\r\ntype LRU struct {\r\n\tcap   int\r\n\tcache map[int]*Node\r\n\tleft  *Node\r\n\tright *Node\r\n}\r\n\r\nfunc NewLRU(cap int) *LRU {\r\n\tleft := &Node{key: 0, val: 0}\r\n\tright := &Node{key: 0, val: 0}\r\n\r\n\tleft.next = right\r\n\tright.prev = left\r\n\r\n\treturn &LRU{\r\n\t\tcap:   cap,\r\n\t\tcache: make(map[int]*Node),\r\n\t\tleft:  left,\r\n\t\tright: right,\r\n\t}\r\n}\r\n\r\n\r\n// Insert a new node to the right side\r\n// pre ----> NODE ----> right\r\n//     <----      <----\r\nfunc (l *LRU) insert(n *Node) {\r\n\tpre := l.right.prev\r\n\tpre.next = n\r\n\tn.next = l.right\r\n\tl.right.prev = n\r\n\tn.prev = pre\r\n}\r\n\r\nfunc (l *LRU) remove(n *Node) {\r\n\tpre, next := n.prev, n.next\r\n\tpre.next = next\r\n\tnext.prev = pre\r\n}\r\n\r\nfunc (l *LRU) Get(key int) int {\r\n\tif node, ok := l.cache[key]; ok {\r\n\t\tl.remove(node)\r\n\t\tl.insert(node)\r\n\t\tfmt.Printf(\"Find the key/val: %v, %v \\n\", key, node.val)\r\n\t\treturn node.val\r\n\t}\r\n\tfmt.Println(\"no such key =\", key)\r\n\treturn -1\r\n}\r\n\r\nfunc (l *LRU) Put(key, value int) {\r\n\t// Check existing key/value\r\n\tif node, ok := l.cache[key]; ok {\r\n\t\tfmt.Println(\"found existing key, removing node\")\r\n\t\tl.remove(node)\r\n\t}\r\n\tl.cache[key] = &Node{key: key, val: value}\r\n\tl.insert(l.cache[key])\r\n\r\n\t// Check capacity, evict lru\r\n\tif len(l.cache) > l.cap {\r\n\t\tlru := l.left.next\r\n\t\tl.remove(lru)\r\n\t\tdelete(l.cache, lru.key)\r\n\t\tfmt.Printf(\"too many node, remove lru: %v,%v \\n\", lru.key, lru.val)\r\n\t}\r\n\r\n}\r\n\r\nfunc (l *LRU) Show() {\r\n\tfor n := l.left.next; n != l.right; n = n.next {\r\n\t\tfmt.Printf(\"(%v, %v), \", n.key, n.val)\r\n\t}\r\n\tfmt.Println()\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196327653","body":"## Day 13\r\n\r\n```go\r\nfunc maxDepth(root *TreeNode) int {\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\r\n\treturn 1 + max(maxDepth(root.Left), maxDepth(root.Right))\r\n}\r\n```\r\nTIme: O(logn), space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184838625","body":"## Idea\r\nKeep in mind that string is just a list of char, then there is no need to do decimal manipulation but can simply use six-stage conversion: \r\n1. convert int list to char list\r\n2. join char list into singe word\r\n3. convert the single word to int\r\n4. add int with k\r\n5. convert the sum to string\r\n6. map string to int list\r\n## Python Code\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_int = int(\"\".join(map(str, num)))\r\n        re = num_int + k\r\n        return list(map(int, str(re)))\r\n```\r\n## Complexity\r\nSpace: O(N)\r\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186222897","body":"## Idea\nUse to pointers to track the distance\n## Python Code\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        strlen = len(s)\n        re = [-1 for _ in range(strlen)]\n        idx_li = []\n        for i in range(strlen):\n            if s[i] == c:\n                re[i] = 0\n                idx_li.append(i)\n        le = 0\n        ri = 0\n        for i in range(len(idx_li) + 1):\n            if i == 0:\n                re[:idx_li[0]] = [x for x in range(idx_li[0],0,-1)]\n            elif i == len(idx_li):\n                ran = len(re[idx_li[len(idx_li) - 1]:])\n                re[idx_li[len(idx_li) - 1]:] = [x for x in range(ran)]\n            else:\n                curr = 0\n                le = idx_li[i - 1]\n                ri = idx_li[i]\n                while le <= ri:\n                    re[le] = re[ri] = curr\n                    le += 1\n                    ri -= 1\n                    curr += 1\n        return re\n```\n## Complexity\nSpace: O(N)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186538783","body":"## Idea\nUse second stack to track the increment of elements\n## Python Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = maxSize\n        self.stk = []\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.stk) < self.size:\n            self.stk.append(x)\n            self.inc.append(0)\n    def pop(self) -> int:\n        if not self.stk:\n            return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        return self.inc.pop() + self.stk.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            idx = min(len(self.inc), k) - 1\n            self.inc[idx] += val\n```\n## Complexity\nO(1) in time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186765529","body":"## Idea\nUse a single stack to track the input\n## Python Code\n```python\nimport collections\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stk = collections.deque()\n        for idx,c in enumerate(s):\n            if c == ']':\n                curr = stk.pop()\n                temp = \"\"\n                while curr.isalpha():\n                    temp = curr + temp\n                    curr = stk.pop()\n                temp_num = \"\"\n                if curr == '[':\n                    curr = stk.pop()\n                # print(\"curr=\",curr)\n                while curr.isdigit():\n                    temp_num = curr + temp_num\n                    if stk and stk[-1].isdigit():\n                        curr = stk.pop()\n                    else:\n                        curr = \"\"\n                num = int(temp_num)\n                for _ in range(num):\n                    for t in temp:\n                        stk.append(t)\n            else:\n                stk.append(c)\n            # print(stk)\n        return \"\".join(list(stk))\n```\n## Complexity\nTime: O(max(k) * n)\nSpace: O(max(k) * n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189216168","body":"## Idea\nstraight forward\n## Python Code\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stk1 = []\n        self.stk2 = []\n\n    def push(self, x: int) -> None:\n        while self.stk1:\n            self.stk2.append(self.stk1.pop())\n        self.stk1.append(x)\n        while self.stk2:\n            self.stk1.append(self.stk2.pop())\n        return\n\n    def pop(self) -> int:\n        return self.stk1.pop()\n\n    def peek(self) -> int:\n        return self.stk1[-1]\n\n    def empty(self) -> bool:\n        return not self.stk1\n```\n## Complexity\nSpace: O(N) for all \nTime: O(N) for push, O(1) for pop, O(1) for peek","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190301483","body":"## Idea\nUse monotonic stack to track the largest number in each partition\n## Python Code\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            la = num\n            while stack and stack[-1] > num:\n                la = max(la, stack.pop())\n            stack.append(la)\n        return len(stack)\n```\n## Complexity\nSpace O(N)\nTime O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191520718","body":"## Idea\nTraverse the list to assign the n - k - 1 element as the new head\n## Python Code\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return None\n        last = head\n        count = 1\n        while last.next:\n            count += 1\n            last = last.next\n        if count == 1:\n            return head\n        newTail = head\n        k = k % count\n        if k == 0:\n            return head\n        for _ in range(count - k - 1):\n            newTail = newTail.next\n        newHead = newTail.next\n        newTail.next = None\n        last.next = head\n        # print(\"count=%d, newHead=%d, newTail=%d, last=%d, head=%d\" % (count, newHead.val, newTail.val, last.val, head.val))\n        return newHead\n```\n## Complexity\nSpace: O(1)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192708685","body":"## Idea\nUse iterative and temp node\n## Python Code\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        node1 = ListNode(-1)\n        node1.next = head\n        prev = node1\n        while head and head.next:\n            first = head\n            second = head.next\n            prev.next = second\n            first.next = second.next\n            second.next = first\n            prev = first\n            head = first.next\n        return node1.next\n```\n## Complexity\nSpace: O(1)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193147005","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return\n        if not head.next:\n            return TreeNode(head.val)\n        pre, slow, fast = None, head, head\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        pre.next = None\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193316147","body":"## Idea\nUse two pointers for iteration, move one pointer to another head.\n## Python Code\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        dummyA = headA\n        dummyB = headB\n        while headA or headB:\n            if not headA:\n                headA = dummyB\n            if not headB:\n                headB = dummyA\n            if headA == headB:\n                return headA\n            # print(\"A:\",headA.val, \"B:\",headB.val)\n            headA = headA.next\n            headB = headB.next\n        return None\n```\n## Complexity\nSpace: O(1)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194059169","body":"## Idea\nTwo pointers and reset the fats\n## Python Code\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return None\n        slow = head\n        fast = head\n        meet = False\n        while slow and fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next if not meet else fast.next\n            if slow == fast:\n                if meet:\n                    return slow\n                else:\n                    fast = head\n                    if slow == fast:\n                        return slow\n                    meet = True\n        return None\n```\n## Complexity\nSpace: O(1)\nTime: O(N) traverse the linked list twice","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195666655","body":"```python\nfrom collections import OrderedDict\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.dic = collections.OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.dic:\n            return -1\n        p = self.dic.pop(key)\n        self.dic[key] = p\n        return p\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.dic:    \n            self.dic.pop(key)\n        else:\n            if self.capacity > 0:\n                self.capacity -= 1\n            else:\n                self.dic.popitem(last=False)\n        self.dic[key] = value\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195791472","body":"## Idea\nUse dfs to track the maximum height\n## Python Code\n```python\nclass Solution:\n    def dfs(self, node, curr, re):\n        if not node:\n            re = max(curr, re)\n            return re\n        re = max(curr, re)\n        re_le = self.dfs(node.left, curr+1, re)\n        re_ri = self.dfs(node.right, curr+1, re)\n        return max(re_le, re_ri)\n        \n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        re = self.dfs(root, 0, 0)\n        return re\n```\n## Complexity:\nSpace O(1)\nTime O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184887447","body":"**Swift Solution**\r\n\r\n思路：\r\nK作为位数累加然后进位\r\n代码：\r\n```\r\n\r\n    func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] {\r\n        if num.isEmpty { return [] }\r\n        \r\n        var k = k, ans = [Int](), i =  num.count - 1, carry = 0\r\n        while i >= 0 || k > 0 {\r\n            var sum = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry\r\n            ans.append(sum % 10)\r\n            carry = sum / 10\r\n            i -= 1\r\n            k /= 10 \r\n        }\r\n        \r\n        if carry > 0 {\r\n            ans.append(carry)\r\n        }\r\n        \r\n        return Array(ans.reversed())\r\n    }\r\n```\r\n\r\n复杂度：\r\n时间复杂度： O（n）\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185867186","body":"思路:\r\n两次遍历： 从左往右，从右往左；用数组分别记录距离C的值，然后取两者之间的最小值\r\n代码:\r\n\r\n```\r\n func shortestToChar(_ s: String, _ c: Character) -> [Int] {\r\n        let arr = Array(s)\r\n        let n = arr.count\r\n        var res = Array(repeating: 0, count:n)\r\n        var prev = Int.min/2\r\n        for (i, char) in arr.enumerated() {\r\n            if char == c {\r\n                prev = i\r\n            }\r\n            res[i] = i - prev\r\n        }\r\n        \r\n        prev = Int.max/2\r\n        \r\n        for (i, char) in arr.enumerated().reversed() {\r\n            if char == c {\r\n                prev = i\r\n            }\r\n            res[i] = min(res[i], prev - i)\r\n        }\r\n        \r\n        return res\r\n    }\r\n```\r\n\r\n复杂度：\r\n时间复杂度： O(n) n是s的长度\r\n空间复杂度: O(n) 其实可以为O（1)，但是Swift里把String转换为Array性能更高","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186418704","body":"思路：\r\n用数组模拟一个栈的Push(add), Pop(remove),然后只修改k个元素的值(inc)\r\n代码:\r\n```\r\nclass CustomStack {\r\n\r\n    let maxSize: Int\r\n    var items: [Int]\r\n    \r\n    init(_ maxSize: Int) {\r\n        self.maxSize = maxSize\r\n        self.items = [Int]()\r\n    }\r\n    \r\n    func push(_ x: Int) {\r\n        guard items.count < maxSize else { return }\r\n        items.append(x)\r\n    }\r\n    \r\n    func pop() -> Int {\r\n        if items.isEmpty { return -1 }\r\n        return items.popLast()!\r\n    }\r\n    \r\n    func increment(_ k: Int, _ val: Int) {\r\n        let maxCount = min(k, items.count)\r\n        for i in 0..<maxCount {\r\n            items[i] += val\r\n        }\r\n    }\r\n}\r\n```\r\n复杂度:\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186793893","body":"思路: Stack\r\n代码：\r\n```\r\nfunc decodeString(_ s: String) -> String {\r\n\tvar stack = [String]()\r\n\r\n\tfor char in s {\r\n\t\tif char != \"]\" {\r\n\t\t\tstack.append(String(char))\r\n\t\t} else {\r\n\t\t\tvar decoded = \"\"\r\n\r\n\t\t\twhile stack.last! != \"[\" {\r\n\t\t\t\tdecoded = stack.popLast()! + decoded\r\n\t\t\t}\r\n\t\t\tstack.popLast()\r\n\r\n\t\t\tvar k = 0\r\n\t\t\tvar offset = 1\r\n\t\t\twhile !stack.isEmpty, let digit = Int(stack.last!) {\r\n\t\t\t\tstack.popLast()\r\n\t\t\t\tk += offset * digit\r\n\t\t\t\toffset *= 10\r\n\t\t\t}\r\n\r\n\t\t\tstack.append(String(repeating: decoded, count: k))\r\n\t\t}\r\n\t}\r\n\r\n\treturn stack.joined()\r\n}\r\n```\r\n复杂度:\r\nTime: O(K * N), Space: O(K * N) where K is the product of all \"k\"s and N is the number of encoded characters","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188335642","body":"思路： 两个栈Input， Output； Output用来存放最终提供给外部的数据，pop, empty, peek;  Input用于接收Output的数据以及push新元素，最终再把Input里的数据全部push入Output\r\n代码:\r\n```\r\nclass MyQueue {\r\n\r\n    var input: [Int] //用户临时存放和转移元素\r\n    var output:[Int] //对外提供信息，pop， peek, empty\r\n    \r\n    init() {\r\n        input = [Int]()\r\n        output = [Int]()\r\n    }\r\n    \r\n    func push(_ x: Int) {\r\n        // 查看output里有没有元素，有，就全部push到input\r\n        // input 新增元素x\r\n        // 全部再放回ouput\r\n        while let e = output.popLast() {\r\n            input.append(e)\r\n        }\r\n        input.append(x) // 加入新元素，此时x在input的栈顶\r\n        \r\n        //放回output\r\n        while let e = input.popLast() {\r\n            output.append(e)\r\n        }\r\n    }\r\n    \r\n    func pop() -> Int {\r\n        // 直接操作output\r\n        guard let last = output.popLast() else {\r\n            return -1\r\n        }\r\n        return last\r\n    }\r\n    \r\n    func peek() -> Int {\r\n        // output的最后一个元素就是栈顶元素\r\n        if self.empty() { return -1 }\r\n        return output.last!\r\n    }\r\n    \r\n    func empty() -> Bool {\r\n        return output.isEmpty\r\n    }\r\n}\r\n```\r\n复杂度：\r\n时间复杂度： O（n）\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189659902","body":"思路：单调栈\r\n代码：\r\n```\r\nstruct Stack<T> {\r\n    var items = [T]()\r\n    \r\n    mutating func push(_ element: T) {\r\n        items.append(element)\r\n    }\r\n    \r\n    mutating func pop() -> T? {\r\n        guard self.isEmpty == false else { return nil }\r\n        return items.popLast()!\r\n    }\r\n    \r\n    func top() -> T? {\r\n        guard self.isEmpty == false else { return nil }\r\n        return items.last\r\n    }\r\n    \r\n    var count: Int {\r\n        return items.count\r\n    }\r\n    \r\n    var isEmpty: Bool {\r\n        return items.isEmpty\r\n    }\r\n}\r\n\r\nclass Solution {\r\n    func maxChunksToSorted(_ arr: [Int]) -> Int {\r\n        if arr.isEmpty { return 0 }\r\n        var stack = Stack<Int>()\r\n        stack.push(arr[0])\r\n        print(stack)\r\n        \r\n        for i in 1..<arr.count {\r\n            if arr[i] >= stack.top()! {\r\n                stack.push(arr[i])\r\n                continue\r\n            }\r\n            let temp = stack.top()\r\n            while !stack.isEmpty && arr[i] < stack.top()! {\r\n                stack.pop()\r\n            }\r\n            stack.push(temp!)\r\n        }\r\n        return stack.count\r\n    }\r\n}\r\n```\r\n\r\n复杂度：\r\n时间： O(n)\r\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191055659","body":"思路：官方题解的思路，快慢指针+ 求倒数第k个节点\r\n代码:\r\n```\r\nclass Solution {\r\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\r\n        if head == nil { return nil }\r\n        var cur: ListNode? = head\r\n        var count = 0\r\n        while cur != nil {\r\n            count += 1\r\n            cur = cur?.next\r\n        }\r\n        var k = k % count\r\n        print(\"k is \\(k) and count is \\(count)\")\r\n        var slow: ListNode? = head\r\n        var fast: ListNode? = head\r\n        \r\n        while fast?.next != nil {\r\n            k -= 1\r\n            if k < 0 {\r\n                slow = slow?.next\r\n            }\r\n            fast = fast?.next\r\n        }\r\n        \r\n        fast?.next = head\r\n        let res: ListNode? = slow?.next\r\n        slow?.next = nil\r\n        \r\n        return res\r\n    }\r\n}\r\n```\r\n复杂度:\r\n时间: O(n)\r\n空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192183692","body":"思路: 看完官方题解后勉强做出来\r\n代码:\r\n```\r\npublic ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null) return head;\r\n        ListNode dummy = new ListNode(-1);\r\n        ListNode cur = dummy;\r\n        dummy.next = head;\r\n        \r\n        while(cur.next != null && cur.next.next != null) {\r\n            ListNode first = cur.next;\r\n            ListNode second = cur.next.next;\r\n            cur.next = second;\r\n            first.next = second.next;\r\n            second.next = first;\r\n            cur = cur.next.next;\r\n        }\r\n        return dummy.next;\r\n    }\r\n```\r\n复杂度：\r\n时间复杂度: O(n)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193011217","body":"思路：有序链表->数组->利用BST特性 + 二分法构建\r\n代码：\r\n```\r\nclass Solution {\r\n    func sortedListToBST(_ head: ListNode?) -> TreeNode? {\r\n        let nums = toArray(head)\r\n        guard let nums = nums else { return nil }\r\n        \r\n        return buildBST(nums, 0, nums.count - 1)\r\n    }\r\n    \r\n    private func buildBST(_ nums: [Int], _ left: Int, _ right: Int) -> TreeNode? {\r\n        if nums.isEmpty { return nil }\r\n        if left > right { return nil }\r\n        let mid = left + (right - left) / 2\r\n        var root = TreeNode(nums[mid])\r\n        root.left = buildBST(nums, left, mid - 1)\r\n        root.right = buildBST(nums, mid + 1, right)\r\n        return root\r\n    }\r\n    \r\n    private func toArray(_ head: ListNode?) -> [Int]? {\r\n        if head == nil { return nil }\r\n        var nums = [Int]()\r\n        var cur = head\r\n        while cur != nil {\r\n            nums.append(cur!.val)\r\n            cur = cur?.next\r\n        }\r\n        return nums\r\n    }\r\n}\r\n```\r\n复杂度分析：\r\n时间复杂度： O（n）\r\n空间复杂度: O(logn) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193252238","body":"思路：双指针\r\n代码：\r\n```\r\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null) return null;\r\n        ListNode a = headA;\r\n        ListNode b = headB;\r\n        \r\n        while(a != b) {\r\n            a = a == null ? headB : a.next;\r\n            b = b == null ? headA : b.next;\r\n        }\r\n        return a;\r\n    }\r\n```\r\n复杂度： \r\n时间：O(n)\r\n空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194148813","body":"思路:快慢指针\r\n代码：\r\n```\r\nfunc detectCycle(_ head: ListNode?) -> ListNode? {\r\n        if head == nil { return nil }\r\n        var slow = head\r\n        var fast = head\r\n        \r\n        while(fast != nil && fast!.next != nil) {\r\n            fast = fast?.next?.next\r\n            slow = slow?.next\r\n            \r\n            if(slow === fast) {\r\n                break\r\n            }\r\n        }\r\n        if fast == nil || fast!.next == nil { return nil } \r\n        fast = head\r\n        while( slow !== fast) {\r\n            fast = fast?.next\r\n            slow = slow?.next\r\n        }\r\n        return slow\r\n    }\r\n```\r\n时间: O(n)\r\n空间:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196035276","body":"思路：DFS\r\n代码：\r\n```\r\nclass Solution {\r\n    func maxDepth(_ root: TreeNode?) -> Int {\r\n        guard let root = root else { return 0 }\r\n        let leftHeight = maxDepth(root.left)\r\n        let rightHeight = maxDepth(root.right)\r\n        \r\n        return 1 + max(leftHeight, rightHeight)\r\n    }\r\n}\r\n```\r\n时间： O（n）\r\n空间：O(log n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197350759","body":"思路：对比两个结点值是否相等，如果相等，在递归比较两个结点的左子树和右子树；空树是相等的\r\n代码：\r\n```\r\n    func isSameTree(_ p: TreeNode?, _ q: TreeNode?) -> Bool {\r\n        // 对比每个结点的值是不是相等； 两个空树是相等的\r\n        if p == nil && q == nil { return true }\r\n        if p == nil || q == nil { return false }\r\n        if p?.val == q?.val {\r\n            return isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)    \r\n        }\r\n        return false\r\n    }\r\n```\r\n\r\n时间复杂度： O（n）\r\n空间复杂度： O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184914351","body":"```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n\r\n        idx = len(num) - 1\r\n        while k > 0 and idx >= 0:\r\n            if num[idx] + k % 10 < 10:\r\n                num[idx] = num[idx] + k % 10\r\n                k //= 10\r\n            else:\r\n                num[idx] = (num[idx] + k % 10) % 10\r\n                k //= 10\r\n                k += 1\r\n            idx -= 1\r\n        while k:\r\n            if idx < 0:\r\n                num = [k % 10] + num\r\n                k //= 10\r\n            else:\r\n                if num[idx] + k % 10 < 10:\r\n                    num[idx] += k % 10\r\n                    k //= 10\r\n                else:\r\n                    num[idx] = 0\r\n                    k //= 10\r\n                    k += 1\r\n                idx -= 1\r\n            \r\n\r\n        return num\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O(n)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186447070","body":"```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.cur_size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size == self.max_size:\r\n            return\r\n        self.stack.append(x)\r\n        self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cur_size == 0:\r\n            return -1\r\n        self.cur_size -= 1\r\n        return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(k, self.cur_size)):\r\n            self.stack[i] += val\r\n\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O()n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186607379","body":"```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        \r\n        stack = []\r\n\r\n        for c in s:\r\n            if c == ']':\r\n                cur_str = ''\r\n                cur_count = ''\r\n                # get repeat string\r\n                while stack and stack[-1] != '[':\r\n                    cur_str = stack.pop() + cur_str\r\n                # pop '['\r\n                stack.pop()\r\n                # get repeat count\r\n                while stack and stack[-1].isnumeric():\r\n                    cur_count = stack.pop() + cur_count\r\n                # push back to the stack\r\n                stack.append(int(cur_count) * cur_str)\r\n            \r\n            else:\r\n                stack.append(c)\r\n\r\n        return ''.join(stack)\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188297075","body":"Two stacks to implement a queue. \r\n\r\n```python3\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.pop_stack:\r\n            self.push_stack.append(self.pop_stack.pop())\r\n\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        while self.push_stack:\r\n            self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        while self.push_stack:\r\n            self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.pop_stack) + len(self.push_stack) == 0\r\n\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189680587","body":"monostack\r\n\r\n```python3\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        monostack = []\r\n\r\n        # max(current chunk) <= min(next chunk) \r\n\r\n        for n in arr:\r\n            if not monostack or monostack[-1] <= n:\r\n                # new chunk\r\n                monostack.append(n)\r\n            else:\r\n                maxx = monostack.pop()\r\n                while monostack and monostack[-1] > n:\r\n                    monostack.pop()\r\n                monostack.append(maxx)\r\n\r\n        return len(monostack)\r\n```\r\n\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1192975790","body":"* D&C\r\n* Fast slow pointer to find median\r\n\r\n```python3\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n\r\n        def get_median(left, right):\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n\r\n\r\n        def build_tree(left: ListNode, right: ListNode) -> TreeNode:\r\n            if left == right:\r\n                return None\r\n            mid = get_median(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = build_tree(left, mid)\r\n            root.right = build_tree(mid.next, right)\r\n            return root\r\n\r\n        return build_tree(head, None)\r\n\r\n```\r\n\r\n* Time: O(nlogn)\r\n* Space: O(logn)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193283271","body":"* Len(A) + Len(B) = Len(B) + Len(A)\r\n* while loop will stop \r\n   * if:\r\n        * Find insection\r\n    * else:\r\n        * Reaches the end of A+B and B+A\r\n```python3\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        cur_A, cur_B = headA, headB\r\n        while cur_A != cur_B:\r\n            if not cur_A:\r\n                cur_A = headB\r\n            else:\r\n                cur_A = cur_A.next\r\n            if not cur_B:\r\n                cur_B = headA\r\n            else:\r\n                cur_B = cur_B.next\r\n        return cur_A\r\n```\r\n* Time: O(N)\r\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193750016","body":"Fast slow pointers\r\n\r\n```python3\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        \r\n        fast, slow = head, head\r\n        \r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                break\r\n                \r\n        if not fast or not fast.next:\r\n            return None\r\n        \r\n        fast = head\r\n        while fast != slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        return fast\r\n```\r\n\r\n* Time: O(N)\r\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195120679","body":"```python3\r\nclass Node:\r\n    def __init__(self, k, v):\r\n        self.key = k\r\n        self.val = v\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.size = 0\r\n        self.head = Node(0, 0)\r\n        self.tail = Node(0, 0)\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.data = {}\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.data:\r\n            node = self.data[key]\r\n            self.remove(node)\r\n            self.append(node)\r\n            return node.val\r\n        else:\r\n            return -1\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.data:\r\n            node = self.data[key]\r\n            self.remove(node)\r\n            self.append(node)\r\n            node.val = value\r\n        else:\r\n            node = Node(key, value)\r\n            self.data[key] = node\r\n            if self.size < self.capacity:\r\n                self.size += 1\r\n            else:\r\n                key = self.removeTail()\r\n                del self.data[key]\r\n            self.append(node)   \r\n\r\n    def remove(self, node: Node) -> None:\r\n        prev = node.prev\r\n        next = node.next\r\n        prev.next = next\r\n        next.prev = prev\r\n\r\n    def append(self, node: Node) -> None:\r\n        first = self.head.next\r\n        self.head.next = node\r\n        node.prev = self.head\r\n        node.next = first\r\n        first.prev = node\r\n\r\n\r\n    def removeTail(self) -> int:\r\n        key = self.tail.prev.key\r\n        self.remove(self.tail.prev)\r\n        return key\r\n```\r\n\r\n* Time: O(1)\r\n* Space: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184950463","body":"```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            int curr = k%10 + num[i];\r\n            k /= 10;\r\n            \r\n            if (curr >= 10) {\r\n                k += 1;\r\n            }\r\n            \r\n            res.add(0, curr%10); \r\n        }\r\n        \r\n        while (k > 0) {\r\n            res.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n* Time: O(n)\r\n* Space: O(n)\r\n* Where n is Max(num.length, k.length)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185869150","body":"左右遍历\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        int curr = len;\r\n        \r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                curr = i;\r\n            } else {\r\n                res[i] = Math.min(len, Math.abs(i-curr));\r\n            }\r\n        }\r\n        \r\n        for (int i = len-1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                curr = i;\r\n            } else {\r\n                res[i] = Math.min(res[i], Math.abs(curr-i));\r\n            }\r\n            \r\n        }\r\n               \r\n        return res;\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186755547","body":"判断几种可能性，对不同可能性进行单独判断\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        \r\n        Stack<String> sbStack = new Stack<>();\r\n        Stack<Integer> digitStack = new Stack<>();\r\n        int idx = 0;\r\n        while (idx < s.length()) {\r\n            char c = s.charAt(idx);\r\n            if (Character.isDigit(c)) {\r\n                int freq = 0;\r\n                while(Character.isDigit(s.charAt(idx))) {\r\n                    freq = freq * 10 + s.charAt(idx) - '0';\r\n                    idx++;\r\n                }\r\n                \r\n                digitStack.push(freq);\r\n            } else if (c == '[') {\r\n                sbStack.push(res.toString());\r\n                res = new StringBuilder();\r\n                idx++;\r\n            } else if (c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                tmp.append(sbStack.pop());\r\n                \r\n                int freq = digitStack.pop();\r\n                \r\n                for (int j = 0; j < freq; j++) {\r\n                    tmp.append(res.toString());\r\n                }\r\n                \r\n                res = tmp;\r\n                idx++;\r\n            } else {\r\n                res.append(c);\r\n                idx++;\r\n            }\r\n        }\r\n                      \r\n        return res.toString();\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187947131","body":"2个stack，一进一出思路\r\n```\r\nclass MyQueue {\r\n    private Stack<Integer> inStack = new Stack<>(); \r\n    private Stack<Integer> outStack = new Stack<>();\r\n\r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (empty()) return -1;\r\n        \r\n        if (outStack.isEmpty()) {\r\n            move();\r\n        }\r\n        \r\n        return outStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (empty()) return -1;\r\n        \r\n        if (outStack.isEmpty()) {\r\n            move();\r\n        }\r\n        \r\n        return outStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n    \r\n    public void move() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189780663","body":"```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int res = 0;\r\n        \r\n        Deque<Integer> deque = new ArrayDeque<>();\r\n        \r\n        for (int num: arr) {\r\n            int largest = num;\r\n            while (!deque.isEmpty() && num < deque.peekFirst()) {\r\n                largest = Math.max(largest, deque.pollFirst());\r\n            }\r\n            \r\n            deque.offerFirst(largest);\r\n        }\r\n        \r\n        return deque.size();\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190592750","body":"先对k进行简化，使k <= list.length\r\n其次进行rotation\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return null;\r\n        \r\n        int count = 1;\r\n        ListNode tail = head;\r\n        \r\n        while (tail.next != null) {\r\n            count++;\r\n            tail = tail.next;\r\n        }\r\n        \r\n        k %= count;\r\n        if (k == 0) return head;\r\n        \r\n        k = count - k;\r\n        \r\n        ListNode dummy = new ListNode();\r\n        dummy.next = head;\r\n        ListNode curr = dummy;\r\n        \r\n        for (int i = 0; i < k; i++) {\r\n            curr = curr.next;\r\n        }\r\n        \r\n        tail.next = dummy.next;\r\n        dummy.next = curr.next;\r\n        curr.next = null;\r\n        \r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192775350","body":"需要一些辅助的ListNode来进行记录，prev，next，还有当前的两个\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {return head;}\r\n        \r\n        ListNode first = head;\r\n        ListNode second = null;\r\n        ListNode prev = null;\r\n        ListNode nextNode = null;\r\n        \r\n        while (first != null) {\r\n            if (first.next == null) {\r\n                break;\r\n            }\r\n            \r\n            second = first.next;\r\n            nextNode = second.next;\r\n            \r\n            if (head == first) {\r\n                head = second;\r\n            } \r\n            if (prev != null) {\r\n                prev.next = second;\r\n            }\r\n            second.next = first;\r\n            first.next = nextNode;\r\n            prev = first;\r\n            first = first.next;\r\n            \r\n        }\r\n        \r\n        return head;\r\n    }\r\n}\r\n```\r\nT: O(n)\r\nS: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1192855243","body":"递归PostOrder\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {return null;}\r\n        \r\n        return dfs(head, null);\r\n    }\r\n\r\n    public TreeNode dfs(ListNode head, ListNode tail) {\r\n        if (head == tail) return null;\r\n        \r\n        ListNode slow = head, fast = head;\r\n        \r\n        while (fast != tail && fast.next != tail) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        \r\n        TreeNode node = new TreeNode(slow.val);\r\n        \r\n        node.left = dfs(head, slow);\r\n        node.right = dfs(slow.next, tail);\r\n        \r\n        return node;\r\n    }\r\n}\r\n```\r\nT: O(nlgn)\r\nS: O(lgn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193251768","body":"```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) {return null;}\r\n        \r\n        ListNode a = headA;\r\n        ListNode b = headB;\r\n        \r\n        while (a != b) {\r\n            a = a == null ? headB : a.next;\r\n            b = b == null ? headA : b.next;\r\n        }\r\n        \r\n        return a;\r\n    }\r\n}\r\n```\r\nT: O(m+n)\r\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193532973","body":"双指针\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) {return null;}\r\n        ListNode slow = head, fast = head;\r\n        \r\n        while (fast.next != null && fast.next.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            \r\n            if (slow == fast) {\r\n                fast = head;\r\n                \r\n                while (slow != fast) {\r\n                    slow = slow.next;\r\n                    fast = fast.next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        \r\n        return null;\r\n    }\r\n}\r\n```\r\nT: O(n)\r\nS: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196208599","body":"递归，取最大边\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        return maxDepth(root, 0);\r\n    }\r\n    \r\n    public int maxDepth(TreeNode root, int depth) {\r\n        if (root == null) return depth;\r\n        \r\n        return Math.max(maxDepth(root.left, depth), maxDepth(root.right, depth)) + 1;\r\n    }\r\n}\r\n```\r\n\r\nT: O(n)\r\nS: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197599540","body":"```\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null || q == null) return p == q;\r\n        \r\n        if (p.val != q.val) {\r\n            return false;\r\n        }\r\n        \r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\nT: O(n)\r\nS: O(lgn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185032289","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = 0\r\n        num = num[::-1]\r\n        while k:\r\n            mod = k % 10\r\n            k = k//10\r\n            if i < len(num):\r\n                num[i] += mod\r\n            else:\r\n                num.append(mod)\r\n            if num[i] >= 10:\r\n                if i+1 < len(num):\r\n                    num[i+1] += 1\r\n                else:\r\n                    num.append(1)\r\n\r\n                num[i] -= 10\r\n            i+=1\r\n        while i < len(num):\r\n            if num[i] >= 10:\r\n                if i+1 < len(num):\r\n                    num[i+1] += 1\r\n                else:\r\n                    num.append(1)\r\n                num[i] -= 10\r\n                i+=1\r\n            else:\r\n                break\r\n        return num[::-1]\r\n```\r\n一位一位地加并且进位 ripple adder\r\n\r\nTime O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1188563652","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [99999999999] * len(s)\r\n        left_c = -99999999999\r\n        for i,v in enumerate(s):\r\n            if v == c:\r\n                ans[i] = 0\r\n                left_c = i\r\n            ans[i] = min(ans[i], i-left_c)\r\n        \r\n        left_c = 99999999999\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                left_c = i\r\n            \r\n            ans[i] = min(ans[i], left_c-i)\r\n        \r\n\r\n        return ans\r\n```\r\n\r\n正着倒着各parse一次~~\r\n时空 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1188593761","body":"```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0]*maxSize\r\n        self.add = [0]*maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < len(self.stack):\r\n            self.stack[self.size] = x\r\n            self.size += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            ret = self.stack[self.size - 1] + self.add[self.size -1]\r\n            if self.size > 1:\r\n                # if there's more than 1 element \r\n                # propogate\r\n                self.add[self.size - 2] += self.add[self.size - 1]\r\n\r\n\r\n            # must reset because it may incorrectly propogate some add number\r\n            self.add[self.size - 1] = 0\r\n            self.stack[self.size - 1] = 0\r\n            \r\n\r\n            self.size -= 1\r\n\r\n            return ret\r\n\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.size)\r\n        if lim > 0:\r\n            self.add[lim-1] += val\r\n\r\n```\r\n这道题一定要做下increment 为O(1)的followup，去年抖音考过这个followup\r\n\r\n时间O(1)\r\n空间 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188596859","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = \"\"\r\n        string = \"\"\r\n        for i,v in enumerate(s):\r\n            if \"a\" <= v <= \"z\":\r\n                string += v\r\n            elif \"0\" <= v <= \"9\":\r\n                num += v\r\n            elif v == \"[\":\r\n                stack.append((int(num),string))\r\n                string = \"\"\r\n                num = \"\"\r\n            elif v == \"]\":\r\n                prevNum, prevStr = stack.pop()\r\n                string = prevStr + prevNum*string\r\n            \r\n        \r\n        return string\r\n```\r\n这道题太经典了，用stack\r\n时空O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188603854","body":"```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.pushStack = []\r\n        self.popStack = []\r\n        self.front = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if not self.pushStack:\r\n            self.front = x\r\n        self.pushStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.popStack:\r\n            return self.popStack.pop()\r\n        else:\r\n            while self.pushStack:\r\n                self.popStack.append(self.pushStack.pop())\r\n            self.front = None\r\n            return self.popStack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.popStack:\r\n            return self.popStack[-1]\r\n        else:\r\n            return self.front\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if not self.pushStack and not self.popStack:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n# Thought\r\n1. Assign a `self.front` when `self.pushStack` is empty when pushing, so that `peek` is always O(1)\r\n\t\tWhether the existing elements are in self.pushStack or self.popStack, `peek()` is always O(1)\r\n2. For each element, it will only be appended and popped from the two stack twice. Amortized O(1)\r\n\r\n# Time\r\n时间 O(1)\r\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189523970","body":"# non-strictly increasing stack\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for v in arr:\r\n            if not stack:\r\n                stack.append(v)\r\n            else:\r\n                if v >= stack[-1]:\r\n                    stack.append(v)\r\n                else:\r\n                    top = stack.pop()\r\n                    while stack and stack[-1] > v:\r\n                        stack.pop()\r\n                    \r\n                    stack.append(top)\r\n        \r\n        return len(stack)\r\n```\r\n\r\n这道题超级经典，第一次想stack方法很复杂，其实理解后就明白他的玄机不难。重点在于：\r\n1. 每一个chunk我们用chunk中最大的数表示\r\n2. 维护一个 non-strictgly increasing stack，表示可排序的array\r\n3. 每当新进来的数是大于等于栈顶，即可以直接进入排序后array\r\n4. 如果小于栈顶，持续pop 栈顶直到栈顶小于等于新进来的数，这表明chunk需要融合的过程\r\n\r\n时间 O(n)\r\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190790492","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return None\r\n        cur = head\r\n        n = 0\r\n        while cur:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        k %= n\r\n\r\n        if k == 0:\r\n            return head\r\n\r\n        steps = n - k\r\n        \r\n        cur = head\r\n        prev = None\r\n        for _ in range(steps):\r\n            prev = cur\r\n            cur = cur.next\r\n\r\n        end = cur\r\n        while end and end.next:\r\n            end = end.next\r\n        \r\n        if prev:\r\n            prev.next = None\r\n\r\n        end.next = head\r\n\r\n        return cur\r\n        \r\n```\r\n这道题不难，但是有几个edge case 需要注意\r\n1. k > 链表长度时，取余\r\n2. 链表为空\r\n3. k == 链表长度\r\n\r\n时间 O(n)\r\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192190772","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy = prev = ListNode()\r\n        dummy.next = head\r\n        cur = head\r\n        while cur and cur.next:\r\n            n = cur.next\r\n            nn = cur.next.next\r\n\r\n            prev.next = n\r\n            n.next = cur\r\n            cur.next = nn\r\n\r\n            prev = cur\r\n            cur = cur.next\r\n        \r\n        return dummy.next\r\n```\r\n经典老题目了，维护两国variables然后交换便是\r\n\r\n时间 O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197648002","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        lis1 = []\r\n        lis2 = []\r\n        \r\n        def serialize(node, lis):\r\n            if not node:\r\n                lis.append(\"*\")\r\n                return\r\n            \r\n            if node.left:\r\n                serialize(node.left, lis)\r\n            else:\r\n                lis.append(\"*\")\r\n\r\n\r\n            if node.right:\r\n                serialize(node.right, lis)\r\n            else:\r\n                lis.append(\"*\")\r\n\r\n            lis.append(node.val)\r\n\r\n        serialize(p, lis1)\r\n        serialize(q, lis2)\r\n        return lis1 == lis2\r\n```\r\n\r\n测试 Inorder 会失败，postorder可以work\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185034114","body":"explanation:\r\ntake K as a carry and use k to extract the lowest digit with K % 10 and update k with k /10 as the next higher digit\r\ncorner case is once the loop ended, if k is still > 0 need to put 1 on the leftmost digit\r\n\r\ncode\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<>();\r\n        \r\n        for(int j = len - 1; j>=0 || k > 0; j--){\r\n            ans.add(0, (j>=0 ? num[j] + k : k) % 10);\r\n            k = (j>=0 ? num[j] + k : k) / 10;\r\n        }\r\n\r\n        return ans;\r\n\r\n    }\r\n}\r\n```\r\n\r\nTime: O(n) since iterate array once\r\nSpace: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186163128","body":"Explanation:\r\nloop through the array twice first from left to right and keep update pos for char c and calculate the potential distance between each character and matching c\r\nthen loop through the same from right to left and then the result should be taking the min of current distance and previous min distance looping from left to right\r\n\r\ncode:\r\n'''\r\npublic int[] shortestToChar(String s, char c) {\r\n        \r\n        int len = s.length(), pos = -2*len ;\r\n        int[] result = new int[len];\r\n        \r\n        // from left to right\r\n        for(int i = 0; i< len; i++){\r\n            if(s.charAt(i) == c) {\r\n                pos = i;\r\n            }\r\n            result[i] = i - pos;\r\n        }\r\n        \r\n        // from right to left\r\n        pos = 2 * len;\r\n        for(int j = len - 1; j>=0; j--){\r\n            if(s.charAt(j) == c){\r\n                pos = j;\r\n            }\r\n            result[j] = Math.min(result[j], pos - j);\r\n        }\r\n        \r\n        return result;\r\n        \r\n    }\r\n'''\r\n\r\nTime: O(n) loop through twice so will be O(2n) but will be treated as O(n)\r\nSpace: O(n) result array with n length\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186575830","body":"Explanation:\r\nUse an array to represent the stack. Push will add a new integer to the array. Pop removes the last element in the array and increment will add value to the first k elements of the array.\r\n\r\ncode:\r\n```\r\nclass CustomStack {\r\n    \r\n    private int maxSize;\r\n    private List<Integer> stack;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize; \r\n        this.stack = new ArrayList<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        int size = this.stack.size();\r\n        if(size >= maxSize) return;\r\n        this.stack.add(size, x);        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(this.stack.isEmpty()) return -1;\r\n        int lastVal = stack.get(this.stack.size() - 1);\r\n        this.stack.remove(this.stack.size() - 1);\r\n        return lastVal;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int increment_size = k<=stack.size() ? k : this.stack.size();\r\n        for(int i = 0; i < increment_size; i++){\r\n            stack.set(i, stack.get(i) + val);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nTime: for push and pop which is going to be O(1), for increment is O(k) \r\nSpace: O(n) - as we used an array for backing up ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186690012","body":"code:\r\n```\r\npublic String decodeString(String s) {\r\n        int n = s.length();\r\n        Deque<Character> stack = new LinkedList<>();\r\n        char[] ss = s.toCharArray();\r\n        for (char c : ss) {\r\n            if (c != ']') {\r\n                stack.push(c);\r\n            } else {\r\n                StringBuilder sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                stack.pop(); // skip :[\r\n                int num = 0;\r\n                int base = 1;\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    num  += (stack.pop() - '0') * base;\r\n                    base *= 10;\r\n                }\r\n                String str = sb.toString();\r\n                 String temp = \"\";\r\n                while (num !=0){\r\n                    temp += str;\r\n                    num--;\r\n                }\r\n                for (Character t : temp.toCharArray()){\r\n                    stack.push(t);\r\n                }\r\n            }\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        for (char c : stack) {\r\n            sb.insert(0, c);\r\n        }\r\n        return sb.toString();\r\n    }\r\n```\r\n\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188951908","body":"code:\r\n```\r\nclass MyQueue {\r\n    \r\n    Deque<Integer> stack1;\r\n    Deque<Integer> stack2;\r\n\r\n    public MyQueue() {\r\n        stack1 = new ArrayDeque<>();\r\n        stack2 = new ArrayDeque<>();\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        stack1.push(x);\r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        int result = this.peek();\r\n        stack2.poll();\r\n        return result;\r\n        \r\n    }\r\n    \r\n    public int peek() {\r\n        //什么时候stack2 empty 才从stack1 里面不断的push 新的data 进来\r\n        if(stack2.isEmpty()){\r\n            while(!stack1.isEmpty()){\r\n                stack2.push(stack1.poll());      \r\n            }\r\n        }\r\n        return stack2.peek();       \r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n}\r\n\r\n```\r\ntime: peek and pop worst case O(n)\r\nspace: use two additional stack with O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189709208","body":"code\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int n = arr.length;\r\n        int[] maxOfLeft = new int[n];\r\n        int[] minOfRight = new int[n];\r\n\r\n        maxOfLeft[0] = arr[0];\r\n        for (int i = 1; i < n; i++) {\r\n            maxOfLeft[i] = Math.max(maxOfLeft[i-1], arr[i]);\r\n        }\r\n\r\n        minOfRight[n - 1] = arr[n - 1];\r\n        for (int i = n - 2; i >= 0; i--) {\r\n            minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]);\r\n        }\r\n\r\n        int res = 0;\r\n        for (int i = 0; i < n - 1; i++) {\r\n            if (maxOfLeft[i] <= minOfRight[i + 1]) res++;\r\n        }\r\n\r\n        return res + 1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191351570","body":"code \r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null) return head;\r\n        int count = 0;\r\n        ListNode now = head;\r\n        while(now != null){\r\n            now = now.next;\r\n            count++;\r\n        }\r\n        k = k % count;\r\n        ListNode slow = head, fast = head;\r\n        while(fast.next != null){\r\n            if(k-- <= 0){\r\n                slow = slow.next;\r\n            }\r\n            fast = fast.next;\r\n        }\r\n        fast.next = head;\r\n        ListNode res = slow.next;\r\n        slow.next = null;\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\ntime: O(n)\r\nspace:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193113227","body":"explanation:\r\nconvert LinkedList to Array so that finding middle will be O(1) and this question is down to convert sorted array to binary search tree which will be using recursion approcach.\r\n\r\ncode:\r\n```\r\nclass Solution {\r\n    private List<Integer> values = new ArrayList<>();\r\n    \r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        mapLinkedListToArray(head);\r\n        return convertToBSTHelper(0, values.size() - 1);\r\n        \r\n    }\r\n    \r\n    private void mapLinkedListToArray(ListNode head){\r\n        while(head != null){\r\n            values.add(head.val);\r\n            head = head.next;\r\n        }\r\n    }\r\n    \r\n    private TreeNode convertToBSTHelper(int left, int right){\r\n        if(left>right) return null;\r\n        int mid = (right-left) / 2 + left;\r\n        TreeNode root = new TreeNode(values.get(mid));\r\n        if(left == right){\r\n            return root;\r\n        }\r\n        root.left = convertToBSTHelper(left, mid - 1);\r\n        root.right = convertToBSTHelper(mid + 1, right);\r\n        return root;\r\n    }\r\n}\r\n\r\n```\r\n\r\ntime: O(n)\r\nspace: O(n) since we used additional array to hold whole linkedlist","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193300501","body":"explanation:\r\ntwo pointers to go through both m + n and check if there is an intersection.\r\n\r\ncode\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode p1 = headA, p2 = headB;\r\n        \r\n        while(p1 != p2){\r\n            if(p1 == null){\r\n                p1 = headB;\r\n            }else{\r\n                p1 = p1.next;\r\n            }\r\n            if(p2 == null){\r\n                p2 = headA;\r\n            }else{\r\n                p2 = p2.next;\r\n            }\r\n        }\r\n        return p1;\r\n        \r\n    }\r\n}\r\n```\r\n\r\ntime: O(m+n) where m is the length of first LinkedList and n is the length of second LinkedList\r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193397247","body":"explanation:\r\nfast and slow pointer to check if there is a cycle(which downgrades to problem 1) and if there is a cycle， then reassign the slow pointer to the head and move both slow and fast pointer forward at same pace until they met which is the intersection node\r\n\r\ncode:\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow, fast;\r\n        slow = fast = head;\r\n        boolean hasCycle = false;\r\n        \r\n        while(fast != null && fast.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if(slow == fast){\r\n                hasCycle = true;\r\n                break;\r\n            }         \r\n        }\r\n        \r\n        if(hasCycle){\r\n            slow = head;\r\n        }else{\r\n            return null;\r\n        }\r\n        \r\n        \r\n        while(slow != fast){\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return slow;\r\n        \r\n    }\r\n}\r\n```\r\n\r\ntime: O(n) iterate the whole list to check the cycle \r\nSpace: O(1) didn't use any additional auxiliary ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194797359","body":"explanation:\r\nusing linked hash map which by default utilizes map and doubly LinkedList so map get operation returns O(1) and put will also be O(1) since that is a doubly linked list which makes put operation become O(1)\r\n\r\ncode\r\n```\r\nclass LRUCache {\r\n    private int capacity;\r\n    private LinkedHashMap<Integer, Integer> cache;\r\n    \r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        this.cache = new LinkedHashMap<>(); \r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(!cache.containsKey(key)){\r\n            return -1;\r\n        }\r\n        makeRecently(key);\r\n        return cache.get(key);\r\n        \r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(cache.containsKey(key)){\r\n            cache.put(key, value);\r\n            makeRecently(key);\r\n            return;\r\n        }\r\n        \r\n        if(cache.size() >= capacity){\r\n            int oldestKey = cache.keySet().iterator().next();\r\n            cache.remove(oldestKey);\r\n        }\r\n        \r\n        cache.put(key, value);\r\n        \r\n    }\r\n    \r\n    private void makeRecently(int key){\r\n        int value = cache.get(key);\r\n        cache.remove(key);\r\n        cache.put(key, value);\r\n    }\r\n}\r\n```\r\n\r\nTime: O(1) since get and put operation both leveraging map and linked list\r\nSpace: O(capacity) need to initialize a map with at most capacity of keys \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196203778","body":"code\r\n\r\n```\r\nclass Solution {\r\n  public int maxDepth(TreeNode root) {\r\n    if (root == null) {\r\n      return 0;\r\n    } else {\r\n      int left_height = maxDepth(root.left);\r\n      int right_height = maxDepth(root.right);\r\n      return java.lang.Math.max(left_height, right_height) + 1;\r\n    }\r\n  }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197469539","body":"explanation:\r\ntree post order traversal and condition is left tree and right tree are same tree and current value equals which then treated as same tree\r\n\r\ncode:\r\n```\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if( p == null && q != null) return false;\r\n        if( p != null && q == null) return false;\r\n        if(p == null && q == null) return true;        \r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right) && p.val == q.val;\r\n\r\n    }\r\n    \r\n}\r\n```\r\n\r\ntime:  O( max(p, q)) because we need to traverse the whole tree either for p or q\r\nspace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185043729","body":"```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  const len = num.length;\n  const stack = [];\n\n  for (let i = len - 1; i >= 0 || k > 0; i--) {\n    k = k + (num[i] || 0);\n    stack.push(k % 10);\n    k = Math.floor(k / 10);\n  }\n\n  return stack.reverse();\n};\n```\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186120127","body":"## 思路\n左右两次遍历\n\n## 代码\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n  const len = s.length;\n  const ans = new Array(len).fill(10001);\n\n  for (let i = 0; i < len; i++) {\n    if (s[i] === c) {\n      ans[i] = 0;\n    } else {\n      if (i === 0) {\n        continue;\n      }\n      ans[i] = ans[i - 1] + 1;\n    }\n  }\n\n  for (let j = len - 1; j >= 0; j--) {\n    if (j + 1 !== len) {\n      ans[j] = Math.min(ans[j], ans[j + 1] + 1);\n    }\n  }\n\n  return ans;\n};\n```\n\n## 复杂度\n- 时间：O(n)\n- 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186465815","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.max = maxSize;\n  this.stack = [];\n  this.top = 0;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.top < this.max) {\n    this.stack.push(x);\n    this.top++;\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  if (this.top > 0) {\n    this.top--;\n    return this.stack.pop();\n  }\n\n  return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  const min = Math.min(k, this.top);\n  for (let i = 0; i < min; i++) {\n    this.stack[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187606409","body":"```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  const numStack = [];\n  const strStack = [];\n  const len = s.length;\n  let num = 0;\n  let str = '';\n\n  for (let i = 0; i < len; i++) {\n    if (s[i] >= 0 && s[i] < 10) {\n      num = num * 10 + parseInt(s[i]);\n    } else if (s[i] === '[') {\n      numStack.push(num);\n      strStack.push(str);\n      num = 0;\n      str = '';\n    } else if (s[i] === ']') {\n      const times = numStack.pop();\n      str = strStack.pop() + str.repeat(times);\n    } else {\n      str += s[i];\n    }\n  }\n\n  return str;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189138547","body":"```js\nvar MyQueue = function () {\n  this.orderStack = [];\n  this.rOrderStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.orderStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  if (!this.rOrderStack.length) {\n    while (this.orderStack.length) {\n      this.rOrderStack.push(this.orderStack.pop());\n    }\n  }\n  return this.rOrderStack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  if (!this.rOrderStack.length) {\n    while (this.orderStack.length) {\n      this.rOrderStack.push(this.orderStack.pop());\n    }\n  }\n  return this.rOrderStack[this.rOrderStack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return !this.orderStack.length && !this.rOrderStack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190359101","body":"```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\n var maxChunksToSorted = function (arr) {\n  const len = arr.length;\n  const stack = [];\n\n  for (let i = 0; i < len; i++) {\n    if (!stack.length || stack[stack.length - 1] <= arr[i]) {\n      stack.push(arr[i]);\n    } else {\n      const temp = stack.pop();\n      while (stack.length && stack[stack.length - 1] > arr[i]) {\n        stack.pop();\n      }\n      stack.push(temp);\n    }\n  }\n\n  return stack.length;\n};\n\n// 时间复杂度 O(N)\n// 空间复杂度 O(N)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191589115","body":"## 思路\n双指针\n## 代码\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head || !head.next || k === 0) {\n    return head;\n  }\n\n  let p = head;\n  let len = 1;\n\n  while (p.next) {\n    p = p.next;\n    len++;\n  }\n\n  k = k % len;\n  p.next = head;\n\n  for (let i = 0; i < len - k; i++) {\n    p = p.next;\n  }\n\n  const newLink = p.next;\n  p.next = null;\n\n  return newLink;\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193329977","body":"````js\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n  // 双指针，两个指针相遇即为相交节点\n  let P1 = headA, P2 = headB;\n  while (P1 != P2) {\n    // 到达结尾指向B\n    P1 = P1 ? P1.next : headB;\n    // 到达结尾指向A\n    P2 = P2 ? P2.next : headA;\n  }\n  return P1 ? P1 : null;\n};\n\n// 时间复杂度 O(M+N)\n// 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194176957","body":"```js\nvar detectCycle = function (head) {\n  let fast = head;\n  let slow = head;\n  let iscycle = false;\n\n  while (fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n\n    if (fast === slow) {\n      iscycle = true;\n      break;\n    }\n  }\n\n  if (!iscycle) {\n    return null;\n  }\n\n  fast = head;\n  while (fast !== slow) {\n    fast = fast.next;\n    slow = slow.next;\n  }\n\n  return fast;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195607925","body":"```js\nvar ListNode = function (key, value) {\n  this.key = key;\n  this.value = value;\n  this.prev = null;\n  this.next = null;\n};\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n  this.size = capacity;\n  this.map = {};\n  this.dummyHead = new ListNode(null, null);\n  this.dummyTail = new ListNode(null, null);\n  this.dummyHead.next = this.dummyTail;\n  this.dummyTail.prev = this.dummyHead;\n};\n\nLRUCache.prototype.isFull = function () {\n  return this.size === Object.keys(this.map).length;\n};\n\nLRUCache.prototype.remove = function (node) {\n  node.prev.next = node.next;\n  node.next.prev = node.prev;\n  node.prev = null;\n  node.next = null;\n\n  return node;\n};\n\nLRUCache.prototype.toHead = function (node) {\n  const tempNode = this.dummyHead.next;\n  node.next = tempNode;\n  tempNode.prev = node;\n  this.dummyHead.next = node;\n  node.prev = this.dummyHead;\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n  if (key in this.map) {\n    const node = this.map[key];\n    this.toHead(this.remove(node));\n    return node.value;\n  } else {\n    return -1;\n  }\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n  if (key in this.map) {\n    const node = this.map[key];\n    node.value = value;\n    this.toHead(this.remove(node));\n  } else {\n    if (this.isFull()) {\n      const deNode = this.dummyTail.prev;\n      const key = deNode.key;\n      delete this.map[key];\n      this.remove(deNode);\n    }\n    const node = new ListNode(key, value);\n    this.map[key] = node;\n    this.toHead(node);\n  }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196821850","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n  if (!root) {\n    return 0;\n  }\n  let depth = 0;\n  let queue = [root];\n\n  while (queue.length) {\n    let len = queue.length;\n    while(len--) {\n      const temp = queue.shift();\n      temp.left && queue.push(temp.left);\n      temp.right && queue.push(temp.right);\n    }\n    depth++;\n  }\n\n  return depth;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185062953","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        import math\r\n        n = max(len(num), int(math.log10(k))+1) + 1\r\n        result = [0] * n\r\n        num = [0] * (n - len(num)) + num\r\n        \r\n        carry = 0\r\n        for i in range(n - 1, -1, -1):\r\n            result[i] = num[i] + k % 10 + carry\r\n            carry = result[i] // 10\r\n            result[i] = result[i] % 10\r\n            k = k // 10\r\n            \r\n        if result[0] == 0:\r\n            return result[1:]\r\n        else:\r\n            return result\r\n```\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185734047","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        left = [float('inf')] * len(s)\n        right = [float(\"inf\")] * len(s)\n        \n        index_left = []\n        index_right = []\n        \n        for idx, ch in enumerate(s):\n            if ch == c:\n                index_left.append(idx)\n                index_right.append(idx)\n        \n        for i in range(len(s)-1, -1, -1):\n            if not index_left:\n                break\n            d = i - index_left[-1]\n            left[i] = d\n            if d == 0:\n                index_left.pop()\n        \n        for i in range(len(s)):\n            if not index_right:\n                break\n            d = index_right[0] - i\n            right[i] = d\n            if d == 0:\n                index_right = index_right[1:]\n                \n        result = []\n        for i in range(len(s)):\n            result.append(min(left[i],right[i]))\n        return result\n```\n时间复杂度：O(n)\n空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186255230","body":"# Increase every number for the increment operation\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.s = []\n        self.maxSize = maxSize\n    def push(self, x: int) -> None:\n        if len(self.s) < self.maxSize:\n            self.s.append(x)\n    def pop(self) -> int:\n        if not self.s:\n            return -1\n        return self.s.pop()\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.s))):\n            self.s[i] += val\n```\n时间复杂度：O(1) for pop and push, O(n) for increment\n空间复杂度：O(1)\n\n# Increase at pop\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.s = []\n        self.maxSize = maxSize\n    def push(self, x: int) -> None:\n        if len(self.s) < self.maxSize:\n            self.s.append(x)\n    def pop(self) -> int:\n        if not self.s:\n            return -1\n        return self.s.pop()\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.s))):\n            self.s[i] += val\n```\n时间复杂度：O(1)\n空间复杂度：O(len(s))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186767291","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                num = ''\n                cur_s = ''\n                while stack[-1] != '[':\n                    cur_s = stack.pop() + cur_s\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    num = stack.pop() + num\n                stack.append(int(num) * cur_s)\n            else:\n                stack.append(c)\n        return ''.join(stack)\n                \n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187977739","body":"```python\nclass MyQueue:\n    def __init__(self):\n        self.main_s = []\n        self.alt_s = []\n\n    def push(self, x: int) -> None:\n        self.main_s.append(x)\n\n    def pop(self) -> int:\n        while len(self.main_s) != 1:\n            self.alt_s.append(self.main_s.pop())\n        result = self.main_s.pop()\n        while self.alt_s:\n            self.main_s.append(self.alt_s.pop())\n        return result\n\n    def peek(self) -> int:\n        while len(self.main_s) != 1:\n            self.alt_s.append(self.main_s.pop())\n        result = self.main_s[-1]\n        while self.alt_s:\n            self.main_s.append(self.alt_s.pop())\n        return result\n\n    def empty(self) -> bool:\n        return bool(self.main_s)\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189810329","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        s = []\n\n        for num in arr:\n            if s and s[-1] > num:\n                cur = s[-1]\n                while s and s[-1] > num:\n                    s.pop()\n                s.append(cur)\n            else:\n                s.append(num)\n        return len(s)\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190937521","body":"```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        n = 0\n        current = head\n        while current.next:\n            n += 1\n            current = current.next\n        \n        tail = current\n        n = n + 1\n        \n        if k%n == 0:\n            return head\n        \n        k = n - k % n - 1\n                \n        new_tail = head\n        for _ in range(k):\n            new_tail = new_tail.next\n        \n        new_head = new_tail.next\n        new_tail.next = None\n        tail.next = head\n        \n        return new_head\n```\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192150377","body":"```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        dummy = ListNode(0, head)\n\n        cur = dummy\n        \n        while cur.next and cur.next.next:\n            tmp = cur.next\n            tmp1 = cur.next.next.next\n            \n            cur.next = cur.next.next\n            cur.next.next = tmp\n            cur.next.next.next = tmp1\n            \n            cur = cur.next.next\n        return dummy.next\n```\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193061720","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        \n        pre = None\n        fast = head\n        slow = head\n        \n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n            \n        node =TreeNode(slow.val)\n        \n        if slow == fast:\n            return node\n        \n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        \n        return node\n```\n时间复杂度：O(nlogn)\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193197025","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:        \n        A = headA\n        lenA = 0\n        B = headB\n        lenB = 0\n        \n        while A:\n            lenA += 1\n            A = A.next\n        \n        while B:\n            lenB += 1\n            B = B.next\n        \n        if lenB > lenA:\n            headA , headB = headB, headA\n            lenA , lenB = lenB, lenA\n        \n        \n        for _ in range(lenA - lenB):\n            headA = headA.next\n\n        while headA and headA != headB:\n            headA = headA.next\n            headB = headB.next\n        \n        return headA\n```\n时间复杂度：O(nlogn)\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193387566","body":"```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = head\n        slow = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                fast = head\n                break\n        \n        if not fast or not fast.next:\n            return None\n        \n        while fast != slow:\n            slow = slow.next\n            fast = fast.next\n        return slow\n```\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194453410","body":"```python\nclass doublyLinkedListNode:\n    def __init__(self, key = 0, val = 0, pre_node = None, next_node = None):\n        self.key = key\n        self.val = val\n        self.pre_node = pre_node\n        self.next_node = next_node        \n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache_map = dict()\n        self.dummy_head = doublyLinkedListNode()\n        self.dummy_tail = doublyLinkedListNode()\n        self.dummy_head.next_node = self.dummy_tail\n        self.dummy_tail.pre_node = self.dummy_head        \n    \n    def remove_mode(self, node):\n        node.pre_node.next_node, node.next_node.pre_node = node.next_node, node.pre_node\n        node.pre_node, node.next_node = None, None        \n        del self.cache_map[node.key]\n        return node\n    \n    def insert_node(self, node):\n        node.next_node = self.dummy_head.next_node\n        node.pre_node = self.dummy_head\n        self.dummy_head.next_node.pre_node = node\n        self.dummy_head.next_node = node\n        self.cache_map[node.key] = node\n        return node\n        \n    def get(self, key: int) -> int:\n        if key not in self.cache_map:\n            return -1\n        node = self.cache_map[key]\n        self.remove_mode(node)\n        self.insert_node(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache_map:\n            node = self.cache_map[key]\n            node.val = value\n            self.remove_mode(node)\n            self.insert_node(node)\n            return\n            \n        if len(self.cache_map) >= self.capacity:\n            to_remove_node = self.dummy_tail.pre_node\n            self.remove_mode(to_remove_node)\n        new_node = doublyLinkedListNode(key = key, val = value)\n        self.insert_node(new_node)\n```\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195852688","body":"```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        left_depth = self.maxDepth(root.left)\n        \n        right_depth = self.maxDepth(root.right)\n        \n        return 1 + max(left_depth, right_depth)\n```\n时间复杂度：O(N)\n空间复杂度：O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197088770","body":"```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        \n        if p and not q:\n            return False\n        \n        if not p and q:\n            return False\n        \n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n时间复杂度：O(N)\n空间复杂度：O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185063354","body":"\n```java\n  // key point : A > 0  add digit by digit\n  // input : int A[], int k     return: int []\n  // A.length <= 10000     T: O(n) < n^2\n  // brute force : \n  //   1) get last digit from k and cur A[i]; \n  //   2) add to array, renew carry and digit; \n  //   3) check carry, return array;\n\t  public int[] addInteger(int[]A, int K){\n\t    LinkedList<Integer> list = new LinkedList<Integer>();\n\t    int curA = A.length - 1;\n\t    int curK = K;\n\t    int carry = 0;\n\t    while(curA >= 0 || curK != 0){\n\t      int sum = curA < 0 ? carry + curK%10 : carry + A[curA] + curK%10;\n\t      int digit = sum % 10;\n\t      carry = sum / 10;\n\t      list.add(digit);  // add to end O(1) \n\t      curK/=10;\n\t      curA--;\n\t    }\n\t    if(carry != 0) list.addFirst(1); // add to head O(1)\n\t    return list.stream().mapToInt(x -> x).toArray(); // can't directly turn into primitive type O(n)\n\t  }\n```\nT: O(n)\nS: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185992291","body":"```java\n// S > 0   shortest dist   DP \n// input : char S[], char C   return int[]\n// A.length <= 10000   O(n) < n^2\n// brute force : \n//\t 1) find every s[i] == target, fill to left and right with dist until reach next target;  \n//\t 2) while finish filling, stop and find next target; \n//\t 3) finish filling and return res;\n//\n// improve:\n//   1) traverse from left to right, get left shortest dist from every target\n//   2) traverse from right to left, get right shortest dist from every target \n//   3) compare left and right and return res;\n\t  public int[] shortestToChar(char[]S, char C){\n\t\t  if(S.length == 1) return new int[] {0};\n\t\t  int[] res = new int[S.length];\n\t\t  Arrays.fill(res, S.length);\n\t\t  for(int i = 0, c = -1; i < S.length; i++){\n\t\t\t  if(S[i] == C) {\n\t\t\t\t  c = i;\n\t\t\t  }\n\t\t\t  if(c != -1) {\n\t\t\t\t  res[i] = i - c;\n\t\t\t  }\n\t\t  }\n\t\t  for(int i = S.length -1, c = -1; i >= 0; i--) {\n\t\t\t  if(S[i] == C) {\n\t\t\t\t  c = i;\n\t\t\t  }\n\t\t\t  if(c != -1) {\n\t\t\t\t  res[i] = Math.min(c - i, res[i]);\n\t\t\t  }\n\t\t  }\n\t\t  return res;\n\t  }\n```\nT:O(n)\nS:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186550641","body":"```java\n// use array to stimulate stack\n// every method must <= O(n^2)\nclass CustomStack {\n\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top < stack.length - 1) stack[++top] = x;\n    }\n    \n    public int pop() {  \n        return  top <= -1 ? -1 : stack[top --];\n    }\n    \n    public void increment(int k, int val) {\n        int len = Math.min(k, stack.length);\n        for (int i = 0; i < len; i++) {\n            stack[i] += val;\n        }      \n    }\n}\n```\nT:\npush(): O(1)\npop(): O(1)\nincrement(): O(n)\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187576674","body":"\n```java\n    // key point : stack  decode string\n    public String decodeString(String s) {\n        String res = \"\";\n        String repeat = \"\";\n        Deque<String> stack = new ArrayDeque<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack.push(res.toString());\n                res = \"\";\n                stack.push(repeat);\n                repeat = \"\";\n            }\n            else if(c == ']') {\n                String tmp = \"\";\n                int cur_rpeat = Integer.parseInt(stack.pop());\n                for(int i = 0; i < cur_rpeat; i++) tmp += res;\n                res = stack.pop() + tmp;\n            }\n            else if(c >= '0' && c <= '9') repeat += c ;\n            else res += c;\n        }\n        return res.toString();\n    }\n```\nT:O(n)\nS:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188415329","body":"```java\n\n// design data structure\n// input integer 1 - 9    S <= O(n^4)\nclass MyQueue{\n    Stack<Integer> out, in;\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void push(int x) {\n        in.push(x); // O(1)\n    }\n    \n    public int pop() {\n        if (out.isEmpty()) {\n            while (!in.isEmpty()) out.push(in.pop());\n        } // O(n)\n        return out.pop();\n    }\n    \n    public int peek() {\n        if (out.isEmpty()) {\n            while (!in.isEmpty()) out.push(in.pop());\n        }//O(n)\n        return out.peek();\n    }\n    \n    public boolean empty() {//O(1)\n        return out.isEmpty() && in.isEmpty();\n    }\n}\n// T: push: O(1), peek: O(n), pop: O(n), empty: O(1) \n// Amortized T: push: O(1), peek: O(1), pop: O(1), empty: O(1) \n// S: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190461632","body":"find chunck  =>   check sum\n```java\n    public int maxChunksToSorted(int[] arr) {\n        int curMax = arr[0];\n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(arr[0]);\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] >= stack.peek()){\n                stack.push(arr[i]);\n                curMax = arr[i];\n            }else {\n                stack.pop();\n                while (!stack.isEmpty()){\n                    if (arr[i]>=stack.peek()){\n                        stack.push(curMax);\n                        break;\n                    }\n                    stack.pop();\n                }\n                if (stack.isEmpty()){\n                    stack.push(curMax);\n                }\n            }\n        }\n        return stack.size();\n    }\n//T:O(n) S:O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191590901","body":"```java\n// use two pointers to locate the k+1 element from right\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return head;\n        ListNode cur = head, tail = head;\n        int len = 1;\n        while (cur.next != null) {\n            cur = cur.next;\n            len++;\n        }\n        cur.next = head;\n        k %= len;\n        for (int i = 0; i < len - k - 1; i++) {\n            tail = tail.next;\n        }\n        cur = tail.next;\n        tail.next = null;\n        return cur;\n    }\n}\n// T:O(n)  S:O(1)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193138292","body":"```java\n// construct tree   BST  \n// T < O(n^2)  get mid\nclass Solution {\n\t  public TreeNode sortedListToBST(ListNode head) {\n\t      if(head == null) return null;\n\t      return buildTree(head,null);\n\t  }\n\t  private TreeNode buildTree(ListNode head, ListNode tail){\n\t      if(head == tail) return null;\n\t      ListNode fast = head, slow = head;\n\t      while(fast != tail && fast.next != tail){// O(n/2)\n\t          fast = fast.next.next;\n\t          slow = slow.next;\n\t      }\n\t      TreeNode root = new TreeNode(slow.val);\n\t      root.left = buildTree(head, slow); \n\t      root.right = buildTree(slow.next, tail);\n\t      return root;\n\t  }\n\t}\n// T:O(nlogn)  n(num of nodes for recurtion tree) * logn (accumulated binary search  operation)\n// S:O(logn)  depth of call stack\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193990889","body":"\n```java\n// two pointer approach \npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(slow == fast){\n                fast = head;\n                while(slow != fast){\n                    slow = slow.next;\n                    fast = fast.next;\n                }\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n// T: O(n)  S: O(1)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185072053","body":"1. 将 num 转为 数字\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        t = 10\r\n        n = len(num)\r\n        res = 0\r\n        for i in range(n):\r\n            res += t**i*num[n-i-1]\r\n        res += k\r\n        print(res)\r\n        out = []\r\n        while res:\r\n            out.append(res%10)\r\n            res = res//10\r\n        return out[::-1]\r\n```\r\n时间复杂度：$O(N)$\r\n空间复杂度：$O(N)$\r\n\r\n2. 逐位相加\r\n>  ![image](https://user-images.githubusercontent.com/16497652/179130663-29ae5da6-b53c-4569-bd7c-327bf30c97e6.png)\r\n> [https://leetcode.cn/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/](url)\r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        res = []\r\n        if len(num)<len(str(k)):\r\n            num = [0]*(len(str(k))-len(num))+num\r\n        n = max(len(str(k)),len(num))-1\r\n        while n>=0 or k:\r\n            sums = num[n]+k%10+carry\r\n\r\n            basic = sums%10\r\n            carry = sums//10\r\n            res.insert(0,basic)\r\n\r\n            n -= 1\r\n            k//=10\r\n        if carry:\r\n            res.insert(0,carry)\r\n            return res\r\n        else:\r\n            return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186098194","body":"* 从左到右正序遍历一次字符串 `s`，记录字符串 `s` 中每个字符到左侧字符 `c` 的距离\n* 从右到左逆序遍历一次字符串 `s`，记录字符串 `s` 中每个字符到右侧字符 `c` 的距离\n需要考虑的是最开始没有出现 `c` 时，`c` 的位置该如何处理，要保证使用该位置计算后的距离不会影响最终的结果。\n* 初始化 `s` 中各字符的距离为无穷大（ s 长度）\n* 正序遍历记未出现`c`的位置为 `-1`\n* 逆序遍历记未出现`c`的位置为 `n`\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [n+1]*n\n        idx = -1\n        for i in range(n):  # 左侧 c 位置\n            if s[i]==c:\n                idx = i\n            if idx!=-1:\n                res[i] = i - idx\n        idx = n\n        for i in range(n-1,-1,-1): # 右侧 c 位置\n            if s[i] == c:\n                idx = i\n            if idx!= n:\n                res[i]= min(idx - i,res[i])\n        return res\n        \n```\n## 复杂度\n* 时间复杂度：遍历`s`即可，$O(N)$\n* 空间复杂度： 和`s`等长的结果数组，$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186423067","body":"``` python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack)>0:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack)<k:\n            self.stack = [i+val for i in self.stack]\n        else:\n            self.stack[:k] = [i+val for i in self.stack[:k]]\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186677475","body":"### 思路\n将每个字符入栈，当遇到`']'`时出栈，直至遇到`'['`，`'['`前的所有数字出栈，即为`k`，将出栈得到的括号内所有字符重复 `k`次，入栈。\n### 代码\n``` python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        for i in s:\n            if i == \"]\":\n                tmp = stack.pop()\n                ch = \"\"\n                while tmp != \"[\":\n                    ch = tmp + ch\n                    tmp = stack.pop()\n                time = 0\n                c = 0\n                while stack and stack[-1].isdigit():\n                    t1 = stack.pop()\n                    time += int(t1) * 10 ** c\n                    c+=1\n                ch = ch * time\n                stack.append(ch)\n            else:\n                stack.append(i)\n        if stack:\n            res = \"\".join(i for i in stack)\n        return res\n```\n### 复杂度\n* 时间复杂度：$O(N)$，需要遍历一遍字符\n* 空间复杂度：$O(N)$，主要来源于栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188499379","body":"## 思路\n用两个栈实现队列。一个栈执行 `push`操作，另一个栈执行 `pop` 和 `peek` 操作。当队列出队时，将`push`到第一个栈的所有元素出栈至第二个栈，栈中元素即为第一个栈的逆序排列，栈顶元素即使队头元素。\n## 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.inqueue = []\n        self.outqueue = []\n\n    def push(self, x: int) -> None:\n        self.inqueue.append(x)\n\n    def pop(self) -> int:\n        if not self.outqueue:\n            while self.inqueue:\n                self.outqueue.append(self.inqueue.pop())\n        return self.outqueue.pop()\n\n    def peek(self) -> int:\n        if not self.outqueue:\n            while self.inqueue:\n                self.outqueue.append(self.inqueue.pop())\n        return self.outqueue[-1]\n\n    def empty(self) -> bool:\n        if not self.inqueue and not self.outqueue: # 两个栈均为空时\n            return True\n        else:\n            return False\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n## 复杂度\n* 空间复杂度： $2N \\rightarrow O(N)$\n* 时间复杂度：\n    * 入队：$O(1)$\n    * 出队：$O(N)$\n    * peek：$O(N)$\n    * empty：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189804822","body":"## 思路\n* 从题目可知左侧块的最大值应小于右侧块的最小值，从而记录下每一个局部最大值即是答案。\n* 每个块的最大值从左到右顺序递增，使用单调递增栈（入栈元素大于等于栈中所有元素）进行记录。\n* 由于单调递增栈每个元素入栈时都要把比当前元素大的所有值出栈后再入栈，修改原始递增栈为局部最大值入栈即可。\n## 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n#        print(stack)\n        return len(stack)\n```\n## 复杂度\n* T: $O(N)$\n* S: $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190931989","body":"## 思路\n* 将链表首尾串联形成循环链表\n* 旋转 k 次后的尾结点位置为 $(len(link) - k)\\% len(link)$，从该位置断开，取该位置下个结点为头节点即可。\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return None\n        length = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            length+=1\n        target = (length-k)%length \n        # print(target)\n        cur.next = head\n        # cur = head\n        for _ in range(target):\n            cur = cur.next\n        head = cur.next\n        cur.next = None\n        return head\n```\n## 复杂度\n* T: $O(N)$\n* S:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192086784","body":"## 思路\r\n链表中间交换两个结点`->a->b->`需要用到三个结点\r\n* 要交换的两个结点 `a,b`;\r\n* `a` 前面的结点 `pre`。\r\n交换操作时 **修改未标记的结点`b.next`要先指向`b.next`**，防止丢失链接 ，也就是 1 必须在 2之前执行，其余可任意交换先后顺序，如 `1->3->2`：\r\n1. `a.next = b.next `\r\n2.  `b.next = a`\r\n3. ` pre.next = b`\r\n## 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        pre = ListNode()\r\n        pre.next = head\r\n        st = pre\r\n        slow,fast = head,head.next\r\n        while slow and fast:\r\n            # print(f\"{pre.val}-{slow.val}-{fast.val}\")\r\n            slow.next = fast.next\r\n            fast.next = slow\r\n            pre.next = fast\r\n            if slow.next:\r\n                pre = slow\r\n                slow = slow.next\r\n                fast = slow.next\r\n            else:\r\n                break\r\n        return st.next\r\n```\r\n精简版\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n\r\n        st=pre = ListNode()\r\n        pre.next = head \r\n        while pre.next and pre.next.next:\r\n\r\n            slow,fast = pre.next, pre.next.next\r\n\r\n            slow.next = fast.next\r\n            fast.next = slow\r\n            pre.next = fast\r\n\r\n            pre = slow\r\n\r\n        return st.next\r\n````\r\n## 复杂度\r\n* T:$O(N)$\r\n* S:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193122006","body":"## 思路\n中序遍历 + 二分\n``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getLength(head: ListNode) -> int:\n            ret = 0\n            while head:\n                ret += 1\n                head = head.next\n            return ret\n        \n        def buildTree(left: int, right: int) -> TreeNode:\n            if left > right:\n                return None\n            mid = (left + right + 1) // 2\n            root = TreeNode()\n            root.left = buildTree(left, mid - 1)\n            nonlocal head\n            root.val = head.val\n            head = head.next\n            root.right = buildTree(mid + 1, right)\n            return root\n        \n        length = getLength(head)\n        return buildTree(0, length - 1)\n```\n## 复杂度\nT: $O(N)$\nS: $O\\log(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193263695","body":"## 思路\r\n不失一般性，假设链表 `headA` 比链表 `headB` 长，记录两个链表的长度差 $ diff = l_a - l_b$，将 `a` 向前移动 $diff$ 步，保证剩余长度和 `b` 相等，然后二者同时向前移动，若能指向同一结点则返回该结点即可，否则二者没有相交结点。\r\n## 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        dummy1,dummy2 = ListNode(),ListNode()\r\n        dummy1.next = headA\r\n        dummy2.next = headB\r\n        p1,p2 = dummy1,dummy2\r\n\r\n        while p1.next and p2.next:\r\n            p1 = p1.next\r\n            p2 = p2.next\r\n        \r\n        diff1 = 0\r\n        while p1.next: # len(p1) > len(p2)\r\n            p1 = p1.next\r\n            diff1 += 1\r\n        \r\n        diff2 = 0\r\n        while p2.next:\r\n            p2 = p2.next\r\n            diff2 +=1\r\n        \r\n        p1,p2 = dummy1,dummy2\r\n        while diff1>0:\r\n            p1 = p1.next\r\n            diff1 -= 1\r\n        while diff2>0:\r\n            p2 = p2.next\r\n            diff2 -= 1\r\n\r\n        \r\n        while p1.next and p2.next:\r\n            # print(f\"{p1} {p2} {p1==p2}\")\r\n            if p1.next == p2.next:\r\n                return p1.next\r\n            else:\r\n                p1 = p1.next\r\n                p2 = p2.next\r\n        return None\r\n ```\r\n## 复杂度：\r\nT: $O(m+n)$\r\nS: $O(1)$\r\n## 优化版本\r\n### 思路\r\n链表 `headA` 和 `headB` 的长度分别是 $m$ 和 $n$。假设链表 `headA` 的不相交部分有 $a$ 个节点，链表 `headB` 的不相交部分有 $b$ 个节点，两个链表相交的部分有 $c$ 个节点，则有 $a+c=m$，$b+c=n$。\r\n当 `a` 移动 $a+c+b$, `b` 移动 $b+c+a$ 后**二者移动相同步数**，若指向同一结点，则相交，否则不相交。\r\n### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193997986","body":"## 思路\n环长减去入环点到相遇位置的长度等于头结点到入环点的距离。\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow,fast = head,head\n        while True:\n            if not fast or not fast.next:\n                return None\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n        fast = head\n        while slow!=fast:\n            slow = slow.next\n            fast = fast.next\n        return slow\n```\n## 复杂度：\n* T: $O(N)$\n* S: $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195104051","body":"## 思路\n采用哈希链表实现，表头是最近使用的元素，表尾是最远使用的元素。\npython 中使用 `collections.Ordereddict` 实现：\n* `get(key)`\n  * 若`key`在哈希表中，每次访问 `key` 时，将 `key` 移动至链表头；\n* `put(key, val)`\n  * 若哈希表不满，直接插入哈希表，并将`key`移动至链表头；\n  * 若哈希表已满\n    * 若 `key` 在哈希表中，替换 `key` 的值即可;\n    * 若不在哈希表中，删除链表尾部元素，再插入 `{key: val}`。\n## 代码\n```python\nfrom collections import OrderedDict\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.dict = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.dict:\n            return -1\n        else:\n            self.dict.move_to_end(key)\n            return self.dict[key]\n\n    def put(self, key: int, value: int) -> None:\n        self.dict[key] = value\n        self.dict.move_to_end(key)\n        if len(self.dict) > self.capacity:\n            self.dict.popitem(last=False)\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197606233","body":"## 二叉树的确定\n### 思路\n* 给定一棵二叉树，其前序遍历/中序遍历/后序遍历的序列是唯一的\n* 可以通过前中后三种遍历的顺序唯一确定一棵二叉树：\n  * 前序遍历+中序遍历\n  * 中序遍历+后序遍历\n\n从而，给定两棵树，如果其前序遍历的结果和中序遍历的结果都一样的话，那么这两棵树的结构是一样的。\n\n### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        p_pre_res, p_in_res = [], []\n        q_pre_res, q_in_res = [], []\n        self.preorderTraversal(p, p_pre_res)\n        self.inorderTraversal(p, p_in_res)\n        self.preorderTraversal(q, q_pre_res)\n        self.inorderTraversal(q, q_in_res)\n        if p_pre_res == q_pre_res and p_in_res == q_in_res:\n            return True\n        else:\n            return False\n\n    def preorderTraversal(self, p: TreeNode, res=[]):\n        if not p:\n            res.append(None)\n            return\n        res.append(p.val)\n        self.preorderTraversal(p.left, res)\n        self.preorderTraversal(p.right, res)\n\n    def inorderTraversal(self, p: TreeNode, res=[]):\n        if not p:\n            res.append(None)\n            return\n        self.inorderTraversal(p.left, res)\n        res.append(p.val)\n        self.inorderTraversal(p.right, res)\n```\n\n#### 优化遍历代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n\n        p_pre_res = self.preorderTraversal(p)\n        p_in_res = self.inorderTraversal(p)\n        q_pre_res = self.preorderTraversal(q)\n        q_in_res = self.inorderTraversal(q)\n        print(f\"{p_pre_res} {q_pre_res}\")\n        print(f\"{p_in_res} {q_in_res}\")\n        if p_pre_res == q_pre_res and p_in_res == q_in_res:\n            return True\n        else:\n            return False\n\n    def preorderTraversal(self, p: TreeNode):\n        if not p:\n            return [None]\n        return (\n            [p.val] + self.preorderTraversal(p.left) + self.preorderTraversal(p.right)\n        )\n\n    def inorderTraversal(self, p: TreeNode):\n        if not p:\n            return [None]\n        return self.inorderTraversal(p.left) + [p.val] + self.inorderTraversal(p.right)\n```\n### 复杂度\n* T: $O(\\max\\{n_p,n_q\\})$，需要遍历两个二叉树，取较大值\n* S: $O(\\max\\{h_p,h_q\\})$，取较深者\n\n## 同时遍历两棵树\n### 思路\n同时对两棵树进行遍历，如果遍历过程中所有结点值全部一致，则两棵树结 构一致。\n> https://leetcode.cn/problems/same-tree/solution/xie-shu-suan-fa-de-tao-lu-kuang-jia-by-wei-lai-bu-/\n\n### 代码\n```python\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:  # 二者均为空\n            return True\n        if (not p and q) or (p and not q):  # 一个为空，另一个非空\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185074522","body":"### 思路\n将list→str→int → result+k → str → list\n\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        result = int(''.join(map(str, num))) + k\n        \n        return [int(i) for i in str(result)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186187289","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        n = len(s)\n        ans = [0] * n\n        idx = -n\n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx-i)\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186540856","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stack) - 1:\n            self.top += 1\n            self.stack[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1: \n            return -1\n        ans = self.stack[self.top]\n        self.top -= 1\n\n        return ans\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stack[i] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186999400","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        \n        ans = []\n        \n        for c in s:\n            \n            if c == ']':\n                temp_str = ''\n                temp_iter = ''\n                while ans and ans[-1] != '[':\n                    temp_str = ans.pop() + temp_str\n                ans.pop()\n                \n                while ans and ans[-1].isdigit():\n                    temp_iter = ans.pop() + temp_iter\n                    \n                ans.append(temp_str * int(temp_iter))\n            else:\n                ans.append(c)\n                \n        return ''.join(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189157737","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self._in_stack, self._out_stack, self._front = [], [], None\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self._in_stack:  # 判断有没有元素\n            self._front = x  # 表示队首\n        \n        self._in_stack.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.empty():\n            raise Exception(\"[ERROR] The queue is empty!\")\n\n        if not self._out_stack:  # 如果空, 添加元素\n            while self._in_stack:\n                self._out_stack.append(self._in_stack.pop())\n        \n        return self._out_stack.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.empty():\n            raise Exception(\"[ERROR] The queue is empty!\")\n\n        if not self._out_stack:  # 空的话，直接输出None\n            return self._front\n        else:\n            return self._out_stack[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not self._in_stack and not self._out_stack\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191611666","body":"```c++\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n\n        iters = (n - k) % n\n        if iters == n: return head\n\n        cur.next = head\n        while iters:\n            iters -= 1\n            cur = cur.next\n\n        ans = cur.next\n        cur.next = None\n\n        return ans\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194245982","body":"```python\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast;\n        ListNode slow;\n        fast = slow = head;\n        while ((fast != null) && (fast.next != null)) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                fast = head;\n                while (slow != fast) {\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185077761","body":"y总说这个是高精度加法\n# 高精度加法\nc++中的高精度加法一般是从低位到高位\n所以需要reverse\n然后正常加就行\n# 代码\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        for (int & c : num) {\n            k += c;\n            c = k % 10;\n            k /= 10;\n        }\n        while (k) num.push_back(k % 10), k /= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186107567","body":"# 思路\n左边右边分别求一下最近的值，然后求最小\n# 代码\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, INT_MAX);\n        for (int i = 0, j = -1; i < n; i ++) {\n            if (s[i] == c) j = i;\n            if (j != -1) res[i] = i - j;\n        }\n        for (int i = n - 1, j = -1; i >= 0; i --) {\n            if (s[i] == c) j = i;\n            if (j != -1) res[i] = min(res[i], j - i);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186394469","body":"# 思路\n数组模拟栈\n# 代码\n```C++\nclass CustomStack {\npublic:\n    vector<int> stk, inc;\n    int maxsize;\n    \n    CustomStack(int maxSize) {\n        maxsize = maxSize;\n    }\n    \n    void push(int x) {\n        if (stk.size() < maxsize) {\n            stk.push_back(x);\n        }\n        return ;\n    }\n    \n    int pop() {\n        // 考虑数组为空的情况\n        if (stk.size()) {\n            int t = stk.back();\n            stk.pop_back();\n            return t;\n        }\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        int l = min(k, (int)stk.size());\n        for (int i = 0; i < l; i ++) {\n            stk[i] += val;\n        }\n        return ;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186781852","body":"# 思路\n按规则 dfs 结果\n# 代码\n```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int u = 0;\n        return dfs(s, u);\n    }\n\n    string dfs(string& s, int& u) {\n        string res;\n        while (u < s.size() && s[u] != ']') {\n            if (s[u] >= 'a' && s[u] <= 'z') res += s[u ++];\n            else if (s[u] >= '0' && s[u] <= '9') {\n                int k = u;\n                while (s[k] >= '0' && s[k] <= '9') k ++;\n                int t = stoi(s.substr(u, k - u));\n                u = k + 1;\n                string sa = dfs(s, u);\n                u ++;\n                while (t --) res += sa;\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188480408","body":"# 思路\n简单模拟题\n# 代码\n```C++\nclass MyQueue {\npublic:\n    stack<int> a, b;\n\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        a.push(x);\n    }\n    \n    int pop() {\n        while (a.size()) {\n            b.push(a.top());\n            a.pop();\n        }\n        int c = b.top();\n        b.pop();\n        while (b.size()) {\n            a.push(b.top());\n            b.pop();\n        }\n        return c;\n    }\n    \n    int peek() {\n        while (a.size()) {\n            b.push(a.top());\n            a.pop();\n        }\n        int c = b.top();\n        while (b.size()) {\n            a.push(b.top());\n            b.pop();\n        }\n        return c;\n    }\n    \n    bool empty() {\n        return a.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189700997","body":"# 思路\n贪心解法，排序后数组和原数组相比较，找到分界点\n# 代码\n```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> sarr = arr;\n        sort(sarr.begin(), sarr.end());\n        unordered_map<int, int> cnt;\n        int res = 0;\n        for (int i = 0, s = 0; i < arr.size(); i ++) {\n            if (cnt[arr[i]] == 1) s --;\n            else if (cnt[arr[i]] == 0) s ++;\n            cnt[arr[i]] --;\n            if (cnt[sarr[i]] == -1) s --;\n            else if (cnt[sarr[i]] == 0) s ++;\n            cnt[sarr[i]] ++;\n            if (!s) res ++;\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191186843","body":"# 思路\n链表模拟题\n# 代码\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head) return head;\n        int n = 0;\n        for (ListNode* p = head; p; p = p->next) n ++;\n        k %= n;\n        if (!k) return head;\n\n        ListNode* f = head;\n        while (k -- && f) f = f->next;\n        ListNode* s = head;\n        while (f->next) {\n            s = s->next;\n            f = f->next;\n        }\n        f->next = head;\n        head = s->next;\n        s->next = NULL;\n        return head;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192294693","body":"# 思路\n链表模拟题，可以先比划比划该怎么反转\n# 代码\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (!head || !head->next) return head;\n        ListNode* dummy = new ListNode;\n        dummy->next = head;\n        ListNode* pre = dummy;\n        while (pre->next && pre->next->next) {\n            ListNode* cur = pre->next, * t = cur->next;\n            pre->next = t;\n            cur->next = t->next;\n            t->next = cur;\n            pre = cur;\n        }\n        return dummy->next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193111787","body":"# 代码\n```C++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (!head) return NULL;\n        int n = 0;\n        for (auto p = head; p; p = p->next) n ++ ;\n        if (n == 1) return new TreeNode(head->val);\n        auto cur = head;\n        for (int i = 0; i < n / 2 - 1; i ++ ) cur = cur->next;\n        auto root = new TreeNode(cur->next->val);\n        root->right = sortedListToBST(cur->next->next);\n        cur->next = NULL;\n        root->left = sortedListToBST(head);\n        return root;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193292237","body":"# 打卡\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* p = headA, * q = headB;\n        while (p != q) {\n            p = p ? p->next : headB;\n            q = q ? q->next : headA;\n        }\n        return p;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193448465","body":"# 思路\n快慢指针\n# 代码\n```C++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (!head || !head->next) return NULL;\n        ListNode* f = head;\n        ListNode* s = head;\n        while (f->next && f->next->next) {\n            f = f->next->next;\n            s = s->next;\n            if (f == s) {\n                s = head;\n                while (f != s) {\n                    s = s->next;\n                    f = f->next;\n                }\n                return f;\n            }\n        }\n        return NULL;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194821407","body":"# 思路\n哈希表存储节点索引，双链表更新用到的值\n# 代码\n```C++\nclass LRUCache {\npublic:\n    struct Node{\n        int key, val;\n        Node* left, * right;\n        Node(int _key, int _val) : key(_key), val(_val), left(NULL), right(NULL) {}\n    }*L, *R;\n    unordered_map<int, Node*> h;\n    int n;\n\n    void remove(Node* node) {\n        node->left->right = node->right;\n        node->right->left = node->left;\n    }\n\n    void insert(Node* node) {\n        L->right->left = node;\n        node->right = L->right;\n        L->right = node;\n        node->left = L;\n    }\n\n    LRUCache(int capacity) {\n        n = capacity;\n        L = new Node(-1, -1), R = new Node(-1, -1);\n        L->right = R, R->left = L;\n    }\n    \n    int get(int key) {\n        if (!h.count(key)) return -1;\n        Node* p = h[key];\n        remove(p);\n        insert(p);\n        return p->val;\n    }\n    \n    void put(int key, int value) {\n        if (h.count(key)) {\n            Node* p = h[key];\n            p->val = value;\n            remove(p);\n            insert(p); \n        } else {\n            if (h.size() == n) {\n                Node* p = R->left;\n                remove(p);\n                h.erase(p->key);\n                delete(p);\n            }\n            Node* p = new Node(key, value);\n            h[key] = p;\n            insert(p);\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196157783","body":"# 思路\n简单递归\n# 代码\n```C++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197545786","body":"# 思路\n遍历，分情况讨论\n# 代码\n```C++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (!p && !q) return true;\n        if (!p || !q || p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185084170","body":"# 思路\n类似于大数相加，由于可能溢出，所以把两个数转成数组存储，从数组对应的数字低位开始相加，若同位相加大于10，需要进位。\n\n# 代码JS\n```js\nvar addToArrayForm = function(num, k) {\n    let num2 = (k + '').split('')\n    let len = Math.max(num.length, num2.length)\n    let flag = 0 // 进位标志\n    let result = []\n    num.reverse()\n    num2.reverse()\n    for (let i = 0; i < len; i++) {\n        let sum = (num[i] || 0) + (num2[i] || 0) / 1 + flag\n        flag = Math.floor(sum / 10)\n        sum = sum % 10\n        result.push(sum)\n    }\n    if (flag) {\n        result.push(flag)\n    }\n    return result.reverse()\n};\n```\n# 复杂度\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186191642","body":"### 思路\r\n先找出字符c在字符串s中的所有下标数组cArr，然后先遍历字符串s，再遍历数组cArr，获得字符串s中每个字符下标和cArr中值的最小距离。\r\n### 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let len = s.length\r\n    let cArr = []\r\n    let start = 0\r\n    let index, answer = []\r\n    while(~(index = s.indexOf(c, start))) {\r\n        cArr.push(index)\r\n        start = index + 1\r\n    }\r\n    for (let i = 0; i < s.length; i++) {\r\n        let temp\r\n        for (let j = 0; j < cArr.length; j++) {\r\n            if (temp === void 0) {\r\n                temp = Math.abs(i - cArr[j])\r\n            } else {\r\n                temp = Math.min(Math.abs(i - cArr[j]), temp)\r\n            }\r\n        }\r\n        answer.push(temp)\r\n    }\r\n    return answer\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186501052","body":"### 思路\r\n数组模拟栈\r\n### 代码\r\njs\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length > 0) {\r\n        return this.stack.pop()\r\n    } else {\r\n        return -1\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for (let i = 0; i < this.stack.length && i < k; i++) {\r\n        this.stack[i] += val\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187595971","body":"### 思路\r\n### 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let stack = [], resStack = []\r\n    let num = 0\r\n    let str = ''\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === '[') {\r\n            stack.push(num)\r\n            resStack.push(str)\r\n            num = 0\r\n            str = ''\r\n        } else if (s[i] === ']') {\r\n            let count = stack.pop()\r\n            let temp = new Array(count).fill(str).join('')\r\n            str = resStack.pop() + temp\r\n        } else if (/\\d/.test(s[i])) {\r\n            num = num * 10 + s[i] * 1\r\n        } else {\r\n            str += s[i]\r\n        }\r\n    }\r\n    return str\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188839685","body":"### 思路\n栈只能后进先出\n### 代码\n```js\nvar MyQueue = function() {\n    this.inStack = []\n    this.outStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out()\n    }\n    return this.outStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out()\n    }\n     return this.outStack[this.outStack.length - 1];\n};\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190051620","body":"### 代码\n\n```JS\nvar maxChunksToSorted = function (arr) {\n    const sorted = [...arr];\n    sorted.sort((a, b) => a - b);\n\n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n\n        if (sum1 === sum2) {\n            count++;\n        }\n    }\n\n    return count;\n};\n```\n### 复杂度\n时间复杂度：O(NlogN) \n控件复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191554442","body":"### 代码\r\n```js\r\nvar rotateRight = function(head, k) {\r\n    if (k === 0 || !head || !head.next) {\r\n        return head;\r\n    }\r\n    let len = 1;\r\n    let cur = head;\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        len++;\r\n    }\r\n\r\n    k = len - k % len;\r\n    if (k === len) {\r\n        return head;\r\n    }\r\n\r\n    cur.next = head;\r\n    while (k) {\r\n        cur = cur.next;\r\n        k--;\r\n    }\r\n\r\n    const ret = cur.next;\r\n    cur.next = null;\r\n    return ret;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192596118","body":"### 代码\r\n```js\r\nvar swapPairs = function(head) {\r\n    const dummyHead = new ListNode(0);\r\n    dummyHead.next = head;\r\n    let temp = dummyHead;\r\n    while (temp.next !== null && temp.next.next !== null) {\r\n        const node1 = temp.next;\r\n        const node2 = temp.next.next;\r\n        temp.next = node2;\r\n        node1.next = node2.next;\r\n        node2.next = node1;\r\n        temp = node1;\r\n    }\r\n    return dummyHead.next;\r\n};\r\n```\r\n### 复杂度\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193130431","body":"### 进度太快了，已经不会了\r\n### 代码\r\n借鉴的\r\n```js\r\nvar sortedListToBST = function(head) {\r\n    if (head === null) return null;\r\n    let node = head;\r\n    let valArr = [];\r\n    while (node !== null) {\r\n        valArr.push(node.val);\r\n        node = node.next;\r\n    }\r\n    let left = 0, right = valArr.length-1;\r\n    return help(valArr, left, right);\r\n};\r\n\r\nfunction help(valArr, left, right) {\r\n    if (left > right) return null;\r\n    let mid = Math.floor((left + right) / 2);\r\n    let node = new TreeNode(valArr[mid]);\r\n    node.left = help(valArr, left, mid-1);\r\n    node.right = help(valArr, mid+1, right);\r\n    return node;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193332172","body":"### 代码\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    const visited = new Set();\r\n    let temp = headA;\r\n    while (temp !== null) {\r\n        visited.add(temp);\r\n        temp = temp.next;\r\n    }\r\n    temp = headB;\r\n    while (temp !== null) {\r\n        if (visited.has(temp)) {\r\n            return temp;\r\n        }\r\n        temp = temp.next;\r\n    }\r\n    return null;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193826881","body":"### 代码\n```js\nvar detectCycle = function(head) {\n    const visited = new Set();\n    while (head !== null) {\n        if (visited.has(head)) {\n            return head;\n        }\n        visited.add(head);\n        head = head.next;\n    }\n    return null;\n};\n```\n### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195268428","body":"### 代码\n```js\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.map = new Map();\n    this.capacity = capacity;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(this.map.has(key)){\n        let value = this.map.get(key);\n        this.map.delete(key); // 删除后，再 set ，相当于更新到 map 最后一位\n        this.map.set(key, value);\n        return value\n    } else {\n        return -1\n    }\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 如果已有，那就要更新，即要先删了再进行后面的 set\n    if(this.map.has(key)){\n        this.map.delete(key);\n    }\n    this.map.set(key, value);\n    // put 后判断是否超载\n    if(this.map.size > this.capacity){\n        this.map.delete(this.map.keys().next().value);\n    }\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196791673","body":"### 代码\r\n```js\r\nvar maxDepth = function(root) {\r\n    if(!root) {\r\n        return 0;\r\n    } else {\r\n        const left = maxDepth(root.left);\r\n        const right = maxDepth(root.right);\r\n        return Math.max(left, right) + 1;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185084621","body":"## Idea\n\n首先循环处理num，k提供加数/辅助处理进位\n\n再单独拿出一个循环处理剩下的k，直接加在num头部\n\n## Code\n\n```GO\nfunc reverse(num []int) {\n\tfor i, n := 0, len(num); i < n/2; i++ {\n\t\tnum[i], num[n-1-i] = num[n-1-i], num[i]\n\t}\n}\nfunc addToArrayForm(num []int, k int) []int {\n\tvar res_head []int\n\tvar n int = len(num)\n\ti := n - 1\n\tfor i >= 0 || k > 0 {\n\t\tif i < 0 {\n\t\t\tbreak\n\t\t}\n\t\tsum := num[i] + k%10\n\t\tk /= 10\n\t\tif sum >= 10 {\n\t\t\tsum -= 10\n\t\t\tk++ // add the 10 as 1 to k\n\t\t}\n\t\tnum[i] = sum // 0<=sum<=9\n\t\ti--\n\t}\n\tfor k > 0 {\n\t\tres_head = append(res_head, k%10)\n\t\tk /= 10\n\t}\n\treverse(res_head)\n\tnum = append(res_head, num...)\n\treturn num\n}\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186197390","body":"## Idea\n\nres[i] = min(d to left c, d to right c)\n\n* first loop from l to r: record \"c\" as idx and update res[i]=i-idx\n* second loop from r to l: record \"c\" as idx and update res[i]=min(res[i], idx-i) \n\n## Code\n\n```go\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\nfunc shortestToChar(s string, c byte) []int {\n\t// res[i] = min(d to left c, d to right c)\n\tn := len(s)\n\tres := make([]int, n)\n    // -n --> make res[i] = (i + n) large enough for the second round iteration to overwrite it\n\tidx := -10007 \n\tfor i, a := range s {\n\t\tif byte(a) == c {\n\t\t\tidx = i\n\t\t}\n\t\tres[i] = i - idx\n\t}\n    // \n    // 2n --> make (2n - i) large enough for the first iteration record to be min\n\tidx = 20007\n\tfor i := n - 1; i >= 0; i-- {\n\t\tif s[i] == c {\n\t\t\tidx = i\n\t\t}\n\t\tres[i] = min(res[i], idx-i)\n\t}\n\treturn res\n}\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(1) | return not considered ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186371628","body":"## Idea\n\nstk array +  cur --> top\n\nuse diff to implement incrementing \n\n## Code\n\n```go\ntype CustomStack struct {\n\tstk  []int\n\tdiff []int\n\tcur  int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{\n\t\tcur:  -1,\n\t\tstk:  make([]int, maxSize, maxSize),\n\t\tdiff: make([]int, maxSize, maxSize),\n\t}\n}\n\nfunc (this *CustomStack) Push(x int) {\n\tif this.cur < len(this.stk)-1 {\n\t\tthis.cur++\n\t\tthis.stk[this.cur] = x\n\t}\n}\n\nfunc (this *CustomStack) Pop() int {\n\tif this.cur == -1 {\n\t\treturn -1\n\t}\n\tres := this.stk[this.cur] + this.diff[this.cur]\n\tif this.cur != 0 {\n\t\tthis.diff[this.cur-1] += this.diff[this.cur]\n\t}\n\tthis.diff[this.cur] = 0\n\tthis.cur--\n\treturn res\n}\n\nfunc (this *CustomStack) Increment(k int, val int) {\n\tif this.cur == -1 {\n\t\treturn\n\t}\n\tif k > this.cur+1 {\n\t\tthis.diff[this.cur] += val\n\t} else {\n\t\tthis.diff[k-1] += val\n\t}\n}\n```\n\n## Complexity\n\n* Time O(1)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187636290","body":"## Idea\n\n遍历字符串，分情况处理\n\n* 数字\n* 字母\n* [\n  * 进入到新的[]，需要重新记录对应的num和str\n  * 则上个[]的num和str入栈，记录该num和str\n* ]\n  * num和str出栈，拼接\n\n整体理解为进入到最里面的[]，向外扩展；肯定还可以用递归实现，下次看到再写吧~\n\n## Code\n\n```cpp\nclass Solution\n{\npublic:\n    string decodeString(string s)\n    {\n        vector<string> strstk;\n        vector<int> numstk;\n\n        int num = 0;\n        string str = \"\";\n        for (char c : s)\n        {\n            if (c >= '0' && c <= '9')\n            {\n                num *= 10;\n                num += (c - '0');\n            }\n            else if (c == '[')\n            {\n                numstk.push_back(num);\n                strstk.push_back(str);\n                num = 0;\n                str = \"\";\n            }\n            else if (c == ']')\n            {\n                int numtmp = numstk.back();\n                string strtmp = strstk.back();\n                numstk.pop_back();\n                strstk.pop_back();\n                for (int i = 0; i < numtmp; i++)\n                {\n                    strtmp = strtmp + str;\n                }\n                str = strtmp;\n            }\n            else\n            {\n                str += c;\n            }\n        }\n        return str;\n    }\n};\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(N)\n  * 辅助栈的极端情况","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188484263","body":"## Idea\n\n双栈模拟队列；而非栈+辅助栈模拟队列\n\n**后者push总是O(N)**，pop简单为O(1)。\n\n但是在双栈模拟情况下，仍能保证pop为O(1)，即进行一次O(N)操作后，在s2不为空前，总是O(1)的操作。\n\n## Code\n\n```cpp\nclass MyQueue {\npublic:\n\t// stack in\n\tstack<int> s1;\n\t// stack out\n\tstack<int> s2;\n    MyQueue() {\n    \n    }\n    \n    void push(int x) {\n    \ts1.push(x);\n    }\n    \n    int pop() {\n    \tif(s2.empty())\n    \t{\n    \t\twhile(!s1.empty())\n    \t\t{\n    \t\t\ts2.push(s1.top());\n    \t\t\ts1.pop();\n    \t\t}\n    \t}\n    \tint res = s2.top();\n    \ts2.pop();\n    \treturn res;\n    }\n    \n    int peek() {\n    \tint res = this->pop();\n    \ts2.push(res);\n    \treturn res;\n    }\n    \n    bool empty() {\n    \treturn s1.empty()&&s2.empty();\n    }c\n};\n```\n\n## Complexity\n\n* Time O(1)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190460557","body":"## Idea\n\n单调栈\n\n## Code\n\n```java\n// 参考题解，没有特别理解\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190929199","body":"## Idea\n\n利用环找到新的头尾节点，因为内部关系没变，只修改\n\n* 尾节点指向头节点\n* 找到新的尾节点后\n  * 设置新头节点（新尾节点的下一个）\n  * 设置新尾节点（next置为nullptr）\n\n## Code\n\n```cpp\nclass Solution\n{\npublic:\n    ListNode *rotateRight(ListNode *head, int k)\n    {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return head;\n        }\n        if (k == 0)\n        {\n            return head;\n        }\n        ListNode *tail = head;\n        ListNode *newtail = head;\n        ListNode *newhead;\n        int n = 1;\n        // 原来的尾结点指向原来的头结点，形成环\n        while (tail->next != nullptr)\n        {\n            tail = tail->next;\n            n++;\n        }\n        tail->next = head;\n        // 找到断开环的位置\n        for (int i = 0; i < (n - k % n - 1); i++)\n        {\n            newtail = newtail->next;\n        }\n        // 新的头结点指向断开环的位置\n        newhead = newtail->next;\n        newtail->next = nullptr;\n\n        return newhead;\n    }\n};\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192285735","body":"#### Idea\n\n```\n// preA -> A -> B -> nextB\n// preA -> B -> A -> nextB \n```\n\n> 创建虚拟头节点，以避免判断边界条件。\n\n#### Code\n\n```\nclass Solution\n{\npublic:\n    ListNode *swapPairs(ListNode *head)\n    {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return head;\n        }\n        ListNode *dummy = new ListNode(-1, head);\n        ListNode *pre = dummy;\n        ListNode *cur = pre->next;\n        while (cur != nullptr && cur->next != nullptr)\n        {\n            // pre->cur->(cur->next)->(cur->next->next)\n            // pre->(cur->next)->cur->(cur->next->next)\n            // cur指向(cur->next->next)\n            ListNode *next = cur->next;\n            cur->next = next->next;\n\n            // (cur->next)指向cur\n            next->next = cur;\n\n            // pre指向cur->next\n            pre->next = next;\n\n            // 更新\n            pre = cur;\n            cur = cur->next;\n        }\n        return dummy->next;\n    }\n};\n```\n\n#### Complexity\n\n* Time O(N)\n* Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193026046","body":"#### Idea\n\n快慢指针找中点，递归构造左右子树。\n\n/利用数组存储链表的值，空间换时间。\n\n#### Code\n\n```c++\nclass Solution\n{\npublic:\n    TreeNode *sortedListToBST(ListNode *head, ListNode *tail)\n    {\n        if (head == tail)\n            return nullptr;\n        // 找中点\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while (fast != tail && fast->next != tail)\n        {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        // 主逻辑：构造树\n        TreeNode *root = new TreeNode(slow->val);\n        root->left = sortedListToBST(head, slow);\n        root->right = sortedListToBST(slow->next, tail);\n        return root;\n    }\n    TreeNode *sortedListToBST(ListNode *head)\n    {\n        if (head == nullptr)\n            return nullptr;\n        return sortedListToBST(head, nullptr);\n    }\n};\n```\n#### Complexity\n\n快慢指针\n\n* Time O(nlogn)\n* Space O(logn)\n\n数组转存\n\n* Time O(n)\n  * 每个节点O(1)\n* Space O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193223156","body":"#### Idea\n\n使pA指针走过A+C+B；pB指针走过B+C+A，则相遇至两链表相交位置。\n\n#### Code\n\n```cpp\nclass Solution\n{\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\n    {\n        ListNode *pa = headA;\n        ListNode *pb = headB;\n        while (pa != pb)\n        {\n            pa = pa == nullptr ? headB : pa->next;\n            pb = pb == nullptr ? headA : pb->next;\n        }\n        return pa;\n    }\n};\n```\n\n#### Complexity\n\n* Time O(N)\n* Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193440259","body":"#### Idea\n\n构造D==L；使fast从起点出发走L到入口，slow从第一次交点出发走D到入口，得到入口指针。\n\n#### Code\n\n```cpp\nclass Solution\n{\npublic:\n    ListNode *detectCycle(ListNode *head)\n    {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return nullptr;\n        }\n        ListNode *fast = head;\n        ListNode *slow = head;\n        do\n        {\n            if (fast != nullptr && fast->next != nullptr)\n            {\n                fast = fast->next->next;\n            }\n            else\n            {\n                fast = nullptr;\n            }\n            slow = slow->next;\n        } while (fast != slow);\n        if (fast == nullptr)\n        {\n            return nullptr;\n        }\n        fast = head;\n        while (fast != slow)\n        {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return fast;\n    }\n};\n```\n\n#### Complexity\n\n* Time O(N)\n* Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194995629","body":"#### Idea\n\n* 逻辑上保持顺序关系 --> 数组、链表\n* 对数据进行频繁的增删O(1) -->链表\n* 数据读取O(1) -->哈希\n\n--> 双向链表+哈希\n\n> 双向链表按最后一次访问的时间的顺序进行排列，**链表头部为最近访问的节点**。\n\n#### Code\n\n```cpp\nstruct LinkedNode\n{\n    int key;\n    int val;\n    LinkedNode *pre;\n    LinkedNode *next;\n    LinkedNode() : key(0), val(0), pre(nullptr), next(nullptr) {}\n    LinkedNode(int _key, int _val) : key(_key), val(_val), pre(nullptr), next(nullptr) {}\n};\n\nclass LRUCache\n{\npublic:\n    LRUCache(int _capacity) : capacity(_capacity), size(0)\n    {\n        // 使用虚拟头节点、尾节点\n        head = new LinkedNode();\n        tail = new LinkedNode();\n        head->next = tail;\n        tail->pre = head;\n    }\n\n    int get(int key)\n    {\n        if (!cache.count(key))\n        {\n            return -1;\n        }\n        LinkedNode *node = cache[key];\n        moveToHead(node);\n        return node->val;\n    }\n\n    void put(int key, int val)\n    {\n        if (!cache.count(key))\n        {\n            LinkedNode *node = new LinkedNode(key, val);\n            cache[key] = node;\n            addToHead(node);\n            size++;\n            if (size > capacity)\n            {\n                LinkedNode *removed = removeTail();\n                cache.erase(removed->key);\n                delete removed;\n                size--;\n            }\n        }\n        else\n        {\n            LinkedNode *node = cache[key];\n            node->val = val;\n            moveToHead(node);\n        }\n    }\n    void addToHead(LinkedNode *node)\n    {\n        node->pre = head;\n        node->next = head->next;\n        head->next->pre = node;\n        head->next = node;\n    }\n    void removeNode(LinkedNode *node)\n    {\n        node->pre->next = node->next;\n        node->next->pre = node->pre;\n    }\n    void moveToHead(LinkedNode *node)\n    {\n        removeNode(node);\n        addToHead(node);\n    }\n    LinkedNode *removeTail()\n    {\n        LinkedNode *node = tail->pre;\n        removeNode(node); // 双向链表不可以直接删除\n        return node;\n    }\n\nprivate:\n    unordered_map<int, LinkedNode *> cache;\n    LinkedNode *head;\n    LinkedNode *tail;\n    int size;\n    int capacity;\n};\n```\n\n#### Complexity\n\n* Time\n  * put O(1)\n  * get O(1)\n* Space O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196155638","body":"#### Idea\n\n`f(root)=1+max(f(root->left),f(root->right))`\n\n/层序遍历，计数层数\n\n#### Code\n\n```cpp\nclass Solution\n{\npublic:\n    int maxDepth(TreeNode *root)\n    {\n        if (root == nullptr)\n        {\n            return 0;\n        }\n        int left = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        return 1 + max(left, right);\n    }\n};\n```\n\n#### Complexity\n\n* Time O(N)\n  * N: nodes\n* Space O(h)\n  * h: depth","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197531458","body":"### 100 相同的树\n\n#### Idea\n\n遍历，逻辑处理中判断是否相同。\n\n#### Code\n\n```cpp\nclass Solution\n{\npublic:\n    bool isSameTree(TreeNode *p, TreeNode *q)\n    {\n        if (p == nullptr && q == nullptr)\n        {\n            return true;\n        }\n        else if (p == nullptr || q == nullptr)\n        {\n            return false;\n        }\n        else if (p->val != q->val)\n        {\n            return false;\n        }\n        return isSameTree(p->left, q->left) &&\n               isSameTree(p->right, q->right);\n    }\n};\n```\n\n#### Complexity\n\n* Time O(N)\n* Space O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185093417","body":"## 思路\r\n1. convert to num to integer\r\n2. add k to integer to get sum\r\n3. convert sum to list of integers\r\n\r\n## 代码 （Python)\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_int = int(''.join(map(str, num)))\r\n        sum = num_int + k\r\n        new_num = []\r\n        for d in str(sum):\r\n            new_num.append(int(d))\r\n        return new_num\r\n```\r\n\r\n时间复杂度： O(n)\r\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186098624","body":"## 思路\r\n1. initialize the res array with the largest possible distance：len(s) \r\n2. iterate through the input, if we encounter c, update res for indices < index of latest c and memorize the index of the latest c\r\n3. update res for indices >= index of latest c until we encounter the next c\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        last_c = 0\r\n        for i in range(0, len(s)):\r\n            res.append(len(s))\r\n        for i in range(0, len(s)):\r\n            if s[i] == c:\r\n                #update left hand side up to the last seen c\r\n                for j in range (last_c, i):\r\n                    res[j] = min(res[j], i-j)\r\n                last_c = i\r\n                #update right hand side\r\n                for j in range (i, len(s)):\r\n                    res[j] = j - i\r\n                    # stop updating right side if see next c\r\n                    if s[j] == c:\r\n                        continue\r\n        return res\r\n```\r\n\r\n### time complexity: O(n)\r\n### space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186290559","body":"## 思路 (python)\n用list来实现stack\n\n## Code\n\n```python\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.n = maxSize\n        self.stack = []\n        self.inc = []\n        \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.n: return\n        self.stack.append(x)\n        return\n        \n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(len(self.stack), k)):\n            self.stack[i] += val\n```\n\n## 时间复杂度\npop: O(1) \npush: O(1)\nincrement: O(k), 1<= k <=n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187674314","body":"## 思路 （用stack)\n遍历input string\n如果element不是“]\", 放进stack\n如果element是”[\", 算出repeatSubstring, 然后放入stack\n最后把返回stack里的elements as a string\n\n## Code (python)\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        for c in s:\n            if c != \"]\":\n                stack.append(c)\n            else:\n                repeatSubstring=\"\"\n                multiplier=\"\"\n                while stack and stack[-1] !='[':\n                    repeatSubstring = stack.pop() + repeatSubstring\n                stack.pop() #remove '['\n                while stack and stack[-1].isnumeric():\n                    multiplier=stack.pop() + multiplier\n                stack.append(repeatSubstring*int(multiplier))\n        return \"\".join(stack)\n```\n\n### time complexity: O(n)\n### space compolexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189212437","body":"## 思路 \n用两个stack来实现queue, stack2的作用是暂时缓存stack1的elements\n\n## Code (python)\n```Python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1=[]\n        self.stack2=[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n        \n\n    def pop(self) -> int:\n        front_element=None\n        while(self.stack1):\n            self.stack2.append(self.stack1.pop())\n        front_element=self.stack2.pop()\n        while(self.stack2):\n            self.stack1.append(self.stack2.pop())\n        return front_element\n\n    def peek(self) -> int:\n        front_element=None\n        while(self.stack1):\n            self.stack2.append(self.stack1.pop())\n        front_element=self.stack2[-1]\n        while(self.stack2):\n            self.stack1.append(self.stack2.pop())\n        return front_element\n\n    def empty(self) -> bool:\n        return len(self.stack1)==0\n```\n\n### 时间复杂度： push O(1), pop和peek O(n), empty O(1)\n### 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190445393","body":"## 思路\n参考了答案 自己没想出来\nThe key idea here is: at any time where both counter arrays are identical it means we've reached a new sortable chunk \n\n## code:\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        chunks, counter_a, counter_b = 0, collections.Counter(), collections.Counter()\n        for a, b in zip(arr, sorted(arr)):\n            counter_a[a] += 1\n            counter_b[b] += 1\n            #at any time where both counter arrays are identical\n            #it means we've reached a new sortable chunk \n            chunks += counter_a == counter_b\n        return chunks\n```\n\n### time complexity:  sorting: O(nlogn), check for identical counter arrays: O(n^2) --> overall: O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190970849","body":"## 思路\r\nbrute force\r\n如果head为空 直接返回空\r\n先遍历一遍linkedlist找到长度，先简化一下k (k=k % length)\r\n遍历到倒数k的node 切断与前面node的连接 让它变成新的head node\r\n把第二个linkedlist的尾巴连到原始的head上\r\n\r\n##代码（Python）\r\n```python\r\n\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        ### return if head is empty\r\n        if not head: return None\r\n        \r\n        # find out the total number of nodes in the linkedlist\r\n        # apply modulo to k to get the actual number of rotations needed\r\n        length = -1\r\n        dummy = ListNode(0)\r\n        dummy.next = head\r\n        while dummy:\r\n            length += 1\r\n            dummy = dummy.next\r\n        k = k % length\r\n        # if no rotation is needed, directly return head\r\n        if k == 0: return head\r\n        \r\n        # 1. create a dummy node, travel the list nodes to the node to be cut (new end)\r\n        # 2. after this operation we end up with 2 smaller linkedlists\r\n        dummy = ListNode(0)\r\n        dummy.next = head\r\n        for i in range(0, length - k):\r\n            dummy = dummy.next\r\n        new_head = ListNode(0)\r\n        new_head = dummy.next # new_head points to the new head node\r\n        \r\n        dummy.next = None #make dummy the end node, now we have 2 linkedlists\r\n        \r\n        # 3. create dummy2 to point to the second linkedlist and travel to its end node\r\n        dummy2 = ListNode(0)\r\n        dummy2 = new_head\r\n        \r\n        while dummy2.next:\r\n            dummy2 = dummy2.next\r\n        \r\n        # 4. now relink the two linkedlists\r\n        dummy2.next = head\r\n        return new_head\r\n```\r\n空间复杂度： O(1)\r\n时间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192169689","body":"## 思路 \nReturn head if it's empty or is a single node\nSwap two nodes at a time, and recursion with the next node\n\n## Code (Python)\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        \n        #swap two nodes at a time and recursion with the next node\n        a = head #first node\n        b = head.next #second node\n        c = head.next.next #third node\n        \n        #let the first node point to the third node\n        #the third node passed in the next recursive call\n        a.next = self.swapPairs(c)\n        #let the second node point to the first node (backtracking)\n        b.next = a\n        return b\n```\nTime complexity: O(n)\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193063477","body":"## 思路 recursion\n## 代码\n```python\n\nclass Solution:\n    def sortedListToBST(self, head):\n        if not head:\n            return \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow, fast = head, head.next.next\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n        # mid points to root\n        mid = slow.next\n\n        # cut down the left child\n        slow.next = None\n       \n        # recursion\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        return root\n```\n\nO(n) time, O(1) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193339415","body":"## 思路 \nTwo pointers: first pointer iterate linkedlist A then linkedlist B, second point iterates linkedlist B then linkedlistA\nAssuming there is an intersection, if linkedlist A and linkedlist B have different lengths before the intersection, both pointers would have visited the same nodes (but in different order) prior to both reaching the intersection node.\n\nIf there's no intersection, after both pointers have travelled both linkedlists, the iteration loop will terminate and return null.\n\n## code\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        dummyA=ListNode(0)\n        dummyB=ListNode(0)\n        dummyA.next = headA\n        dummyB.next = headB\n        while headA or headB:\n            if headA == headB:\n                return headA\n            headA = headA.next if headA else dummyB.next\n            headB = headB.next if headB else dummyA.next\n        return None\n```\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193558504","body":"##思路 \r\nhash set\r\n## code\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        visited = {} # a hash set\r\n        \r\n        while head and head not in visited:\r\n            visited[head] = index\r\n            head = head.next\r\n           \r\n        return head\r\n```\r\ntime: O(n), space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195619382","body":"## 思路\nOrderedDict\n\n## Code\n\n```python\n\nfrom collections import OrderedDict\n\nclass LRUCache(OrderedDict):\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self:\n            return - 1\n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last = False)\n            \n```\ntime complexity: get and put: O(1)\nspace complexity: O(n), n = capacity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196275531","body":"## 思路\nRecursion, at each level of the recursive call, return 1 + the max of the node's left and right\n\n## code\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\ntime: O(n)  space: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185096544","body":"## 思路\n1.将 num和k从后往前相加，两者长度未知，通过 while k!=0 or i>=0 来使长度统一。\n2.每一位的累加和sum放入res中，是否进位通过carry判断。\n3.while完毕后，需要判断carry是否为零。\n\n##  python代码\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res=[]\n        carry=0\n        i=len(num)-1\n        while k!=0 or i>=0:\n            x=num[i] if i>=0 else 0 \n            y=k%10 if k!=0 else 0\n\n            sum = x+y+carry\n            res.append(sum%10)\n            carry=sum//10\n\n            i-=1\n            k//=10\n        \n        if carry!=0: res.append(carry)\n\n        return res[::-1]\n```\n## 复杂度分析\n设N为数组长度\n时间复杂度： O(max(N，K))\n空间复杂度： O(max(N，K))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186190287","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [n+1]*n\n        idx = -1\n        for i in range(n):  # 左侧 c 位置\n            if s[i]==c:\n                idx = i\n            if idx!=-1:\n                res[i] = i - idx\n        idx = n\n        for i in range(n-1,-1,-1): # 右侧 c 位置\n            if s[i] == c:\n                idx = i\n            if idx!= n:\n                res[i]= min(idx - i,res[i])\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186413552","body":"## python代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack=[]\n        self.length=0\n        self.maxSize=maxSize\n    def push(self, x: int) -> None:\n        if self.length!=self.maxSize:\n            self.stack.append(x)\n            self.length+=1\n\n    def pop(self) -> int:\n        if self.stack:\n            self.length-=1\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,self.length)):\n            self.stack[i]+=val\n\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186814030","body":"解法一：辅助栈法\n本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应。\n\n算法流程：\n\n构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n\t当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n\t当 c 为字母时，在 res 尾部添加 c；\n\t当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 0：\n\t\t记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\n\t\t记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n\t\t进入到新 [ 后，res 和 multi 重新记录。\n\t当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\n\t\tlast_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\n\t\tcur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n返回字符串 res。\n\n复杂度分析：\n\n时间复杂度 O(N)，一次遍历 s；\n空间复杂度 O(N)，辅助栈在极端情况下需要线性空间，例如 2[2[2[a]]]。\n\n```\n# k神写法\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9': # 这里用isdigit（）合适\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n\n# 自己的\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []  # (str, int) 记录之前的字符串和括号外的上一个数字\n        num = 0\n        res = \"\"  # 实时记录当前可以提取出来的字符串\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == \"[\":\n                stack.append((res, num))\n                res, num = \"\", 0\n            elif c == \"]\":\n                top = stack.pop()\n                res = top[0] + res * top[1]\n            else:\n                res += c\n        return res\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188539903","body":"# 用两个栈解决\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.A, self.B = [], []\n    \n    def push(self, x: int) -> None:\n        self.A.append(x)\n\n    def pop(self) -> int:\n        if self.B: return self.B.pop()\n        #if not self.A: return -1\n        while self.A:\n            self.B.append(self.A.pop())\n        return self.B.pop()\n\n    def peek(self) -> int:\n        if self.B: return self.B[-1]\n        #if not self.A: return -1\n        while self.A:\n            self.B.append(self.A.pop())\n        return self.B[-1]\n\n    def empty(self) -> bool:\n        if self.A or self.B:\n            return False\n        else:\n            return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189768482","body":"理解排序块：也就是分好块之后进行排序，将所有块连在一起可以成为升序排序。\n比如[7，8，1]，后面出现了一个1，导致前面的都需要一起排序。\n\n如何将题目和单调栈联系在一起：\n1 单调栈，保证栈是递增的，如果出现一个小于栈顶的数字x，保存栈顶并弹出，然后弹出栈中比x小的数字，最后存入栈顶。记录栈的长度\n2 题目中，数组需要是递增的，如果出现一个小于前面数字的数字x，则将前面大于x的数字都需要进行排序（类似上面栈顶弹出的操作）\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \t\t\t\t\t # 栈顶对比\n                head = stack.pop()\t\t\t\t\t\t\t # 保存栈顶\n                while stack and num < stack[-1]: stack.pop() # 弹出栈中比x小的数字，\n                stack.append(head)\t\t\t\t\t\t     # 存入栈顶\n            else: stack.append(num)\n        return len(stack)\n```\n\n复杂度分析：\n时间复杂度 O(N) \n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191123114","body":"# 方法1：每次右移1格，k次执行k次。但是方法超时。\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        def rightmove(head):\n            pre=head\n            cur=head\n            tailpre=ListNode(-1)\n            tailpre.next=head\n            tail=head\n            while cur:\n                cur=cur.next\n                if cur:\n                    tail=tail.next\n                    tailpre=tailpre.next\n            tailpre.next=None\n            tail.next=pre\n\n            return tail\n        \n        while k>0:\n            k-=1\n            head=rightmove(head)\n        \n        return head\n```\n# 方法2，成环，成环之后右移动k次，然后断开。\n代码就不写了，想法比较重要","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192253761","body":"# 递归法（关注思想）\n关注最小子结构，即将两个节点进行逆转。\n将逆转后的尾节点.next 指向下一次递归的返回值\n返回逆转后的链表头节点（ps:逆转前的第二个节点）\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head == None or head.next == None:\n            return head\n\n        l1 = head.next\n        head.next = self.swapPairs(head.next.next)\n        l1.next = head\n\n        return l1\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196345467","body":"BFS\n```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        queue,res=[root],0\n        while queue:\n            tmp=[]\n            for node in queue:\n                if node.left: tmp.append(node.left)\n                if node.right: tmp.append(node.right)\n            \n            queue=tmp\n            res+=1\n        return res\n```\nDFS(后序遍历)\n```\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        def dfs(root):\n            if not root:return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return max(left,right) + 1\n        return dfs(root)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185097387","body":"/*\r\n思路 \r\n先将数组x遍历,用字符串类型拼接,强制转换与k相加,\r\n在csdn 找到的方法(大佬求解释,不太懂)直接将数值,转换成字符串\r\n*/\r\n//代码\r\nvar x=[1,2,3,4]\r\nvar k=54\r\nfor(var i=0,str='';i<x.length;i++){\r\n        str+=x[i]\r\n}\r\nvar A=Number(str)+k\r\n const converToArray = number => [...`${number}`].map(el => parseInt(el))\r\nconsole.log(converToArray(A) ); \r\n//复杂度：\r\n//时间复杂度： O（n）\r\n//空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186209924","body":"var shortLen = function(s, c) {\r\nvar s2 = Array(s.length).fill(0);\r\nfor (var i = 0; i < s.length; i++) {\r\n                       if (s1[i] === c) {\r\n                       continue;\r\n                       }\r\nfor (let j = i, count1 = 0; j < s.length; j++, count1++) {\r\n                        if (s1[j] === c) {\r\n                        return count1;\r\n                      }\r\n}\r\nfor (let j = s.length, count2 = 0; j >= 0; j--, count2++) {\r\n                      if (s1[j] === c) {\r\n                      return count2;\r\n                        }\r\n}\r\n         s2[i] = Math.min(count1, count2);\r\n}\r\nconsole.log(s2);\r\n}\r\n\r\nvar s = \"loveleetcode\", c = 'e';\r\nconsole.log(shortLen(s, c));\r\n##时间复杂度\r\n空间O(N^2)\r\n时间O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188954566","body":"### 思路就是用两个栈来模拟队列，当进行弹出操作时，将一个栈的元素全部弹出，再压入另一个栈，栈顶元素就为最先进入的元素\r\nvar MyQueue = function() {\r\n  this.stack1 = [];\r\n  this.stack2 = [];\r\n};\r\n\r\n\r\nMyQueue.prototype.push = function(x) {\r\n  this.stack1.push(x);\r\n};\r\n\r\n\r\nMyQueue.prototype.pop = function() {\r\n  if (this.stack2.length === 0) {\r\n    while (this.stack1.length > 0) {\r\n      this.stack2.push(this.stack1.pop());\r\n    }\r\n  }\r\n\r\n  return this.stack2.pop();\r\n};\r\n\r\n\r\nMyQueue.prototype.peek = function() {\r\n  if (this.stack2.length > 0) {\r\n    return this.stack2[this.stack2.length - 1];\r\n  } else {\r\n    return this.stack1[0];\r\n  }\r\n};\r\n\r\n\r\nMyQueue.prototype.empty = function() {\r\n  return this.stack1.length === 0 && this.stack2.length === 0;\r\n};\r\n### 复杂度\r\n时间复杂度：O（1）\r\n空间复杂度：O（n）","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193519470","body":"`思路` 两个指针遍历整个链表，如果两者相遇则表示链表有环\r\n\r\n> 代码\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {boolean}\r\n */\r\nvar hasCycle = function(head) {\r\n    if (!head) return false;\r\n    let stepOne = head;\r\n    let stepTwo = head;\r\n\r\n    while(stepOne && stepTwo) {\r\n        stepOne = stepOne.next;\r\n        stepTwo = stepTwo.next && stepTwo.next.next;\r\n        if (stepOne && stepOne === stepTwo) return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n复杂度\r\n时间复杂度O(N)\r\n空间复杂度O（N）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185097824","body":"# 整体思路\r\n1. 转换num或转换K，相加后再转换成数组\r\n2. 防止进位问题，可以将数组转换成数字，而后和k相加，再转换成数组\r\n# 代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        s, m = 0, 1\r\n        ans = []\r\n        for i in num[::-1]:\r\n            s += i * m\r\n            m *= 10\r\n        s += k\r\n        for i in str(s):\r\n            ans.append(int(i))\r\n        return ans\r\n```\r\n# 复杂度分析\r\n- 时间复杂度On\r\n- 空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186075787","body":"# 思路\n首尾两次遍历\n# 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [0] * n\n\n        idx = -n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx - i)\n        return ans\n```\n# 复杂度分析\n时间复杂度On\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186546631","body":"# 思路\n模拟所有的操作，注意边界条件和特判\n# 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n```\n# 复杂度\n时间复杂度On\n空间复杂度On\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187612890","body":"# 思路\r\n使用一个栈和一个数组解决问题\r\n# 代码\r\n ```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []  # (str, int) 记录左括号之前的字符串和左括号外的上一个数字\r\n        num = 0\r\n        res = \"\"  # 实时记录当前可以提取出来的字符串\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c)\r\n            elif c == \"[\":\r\n                stack.append((res, num))\r\n                res, num = \"\", 0\r\n            elif c == \"]\":\r\n                top = stack.pop()\r\n                res = top[0] + res * top[1]\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n# 复杂度分析\r\n时间复杂度On\r\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188535834","body":"# 思路\n使用两个栈，第一个记录进队元素，第二个记录队头元素\n# 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.s1 = []\n        self.s2 = []\n        self.front = None\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self.s1: self.front = x\n        self.s1.append(x)\n        \n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            self.front = None\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.s2: \n            return self.s2[-1]\n        return self.front\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if not self.s1 and not self.s2:\n            return True\n        return False\n```\n# 复杂度分析\n时间复杂度On\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190270184","body":"今天的题目有点难，没有思路，学习了一波单调栈\n# 思路\n对于第i个数 当且仅当i和它前面所有数的最大值 小于 i后面所有数的最小值时 可以把i和它前面的数分出去 结果 + 1\n# 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr = zip(arr, range(len(arr)))\n        arr = sorted(arr)\n        arrs = [0]*len(arr)\n        for idx,i in enumerate(arr):\n            arrs[i[1]] = idx\n        m = -float('inf')\n        res = 0\n        for i in range(len(arrs)):\n            m = max(m, arrs[i])\n            if m == i:\n                res += 1\n        return res\n```\n引用自力扣 @Thinking first\n# 复杂度分析\n时间复杂度On\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191071447","body":"# 思路\n双指针典型题，取巧的话可以转成数组再转回来\n# 代码\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # 双指针\n        if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n```\n# 复杂度分析\n时间复杂度On\n空间复杂度O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192254152","body":"# 思路\n使用虚拟头节点，递归进行\n# 代码\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        thead = ListNode(-1)\n        thead.next = head\n        c = thead\n        while c.next and c.next.next:\n            a, b=c.next, c.next.next\n            c.next, a.next = b, b.next\n            b.next = a\n            c = c.next.next\n        return thead.next\n```\n# 复杂度分析\n时间复杂度On\n空间复杂度O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193144298","body":"# 思路\n快慢指针递归进行\n# 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n# 复杂度\n时间复杂度Onlogn\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193241430","body":"# 思路\n两个链表的指针走过等长的路\n# 代码\n```python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB: return null\n        A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```\n# 复杂度分析\n时间复杂度On，因为最多进行了两轮循环\n空间复杂度O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193718303","body":"# 思路\n双指针快慢指针，去年小米算法工程师面试问了这道\n# 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        quick, slow = head, head\n        while quick != None and quick.next != None:\n            quick = quick.next.next\n            slow = slow.next\n            if quick == slow:\n                break\n        if quick == None or quick.next == None:\n            return None\n        quick = head\n        while quick != slow:\n            quick = quick.next\n            slow = slow.next\n        return quick\n```\n# 复杂度\n时间复杂度On\n空间复杂度O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195231632","body":"# 思路\n这题第一次见，看了很多篇题解，记录一下后面反复学习几遍\n# 代码\n```python\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        # 新建两个节点 head 和 tail\n        self.head = ListNode()\n        self.tail = ListNode()\n        # 初始化链表为 head <-> tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # 因为get与put操作都可能需要将双向链表中的某个节点移到头部(变成最新访问的)，所以定义一个方法\n    def move_node_to_header(self, key):\n            # 先将哈希表key指向的节点拎出来，为了简洁起名node\n            #      hashmap[key]                               hashmap[key]\n            #           |                                          |\n            #           V              -->                         V\n            # prev <-> node <-> next         pre <-> next   ...   node\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            # 之后将node插入到头部节点前\n            #                   hashmap[key]                     hashmap[key]\n            #                       |                                 |\n            #                       V        -->                      V\n            # header <-> next  ... node                   header <-> node <-> next\n            node.prev = self.head\n            node.next = self.head.next\n            self.head.next.prev = node\n            self.head.next = node\n            \n    def add_node_to_header(self, key,value):\n        new = ListNode(key, value)\n        self.hashmap[key] = new\n        new.prev = self.head\n        new.next = self.head.next\n        self.head.next.prev = new\n        self.head.next = new\n        \n    def pop_tail(self):\n        last_node = self.tail.prev\n        # 去掉链表尾部的节点在哈希表的对应项\n        self.hashmap.pop(last_node.key)\n        # 去掉最久没有被访问过的节点，即尾部Tail之前的一个节点\n        last_node.prev.next = self.tail\n        self.tail.prev = last_node.prev\n        return last_node\n    \n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            # 如果已经在链表中了久把它移到头部（变成最新访问的）\n            self.move_node_to_header(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\n            # 但是需要更新字典该值对应节点的value\n            self.hashmap[key].value = value\n            # 之后将该节点移到链表头部\n            self.move_node_to_header(key)\n        else:\n            if len(self.hashmap) >= self.capacity:\n            # 若cache容量已满，删除cache中最不常用的节点 \n                self.pop_tail()\n            self.add_node_to_header(key,value)\n```\n# 复杂度\n时间复杂度On\n空间复杂度O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196389430","body":"# 思路\n深度优先遍历\n# 代码\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left)+1, self.maxDepth(root.right)+1)\n```\n# 复杂度\n时间复杂度Onlogn\n空间复杂度为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197582481","body":"# 思路\n要想学会递归，就要学会递归\n# 代码\n```python\nif p==None and q!=None: return False\n        if p!=None and q==None: return False\n        if p==None and q==None: return True\n        if p.val!=q.val: return False\n        #2.递归本体\n        if p.val==q.val:\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```\n# 复杂度\n时间复杂度On\n空间复杂度On","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185098164","body":"## 思路\r\n每次循环，把数组的最后一位pop出来 和 K除10取余的结果相加，如果有进位再加1，K等于K/10取整，再记一下当前进位标记，开始下一次循环，直到 A为空 且 K为0 且 进位标记为false\r\n\r\n## 代码（JS）\r\n```javascript\r\nfunction addToArrayFormOfInteger(A, K) {\r\n  // res存结果，sum是每一位加的结果，addOneFlag是进位标记\r\n  let res = [], sum = 0, addOneFlag = false\r\n  while(A.length || K || addOneFlag) {\r\n    sum = (A.pop() || 0) + K % 10 + addOneFlag\r\n    K && (K = Math.floor(K / 10))\r\n    addOneFlag = sum >= 10\r\n    res.push(sum % 10)\r\n  }\r\n  return res.reverse()\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186092929","body":"## 思路\n遍历每一个字符，在前后同时寻找目标字符，找到了就停止，开始遍历下一个字符\n\n```javascript\nfunction shortestToChar(s, c) {\n  let res = []\n  for (let i = 0; i < s.length; i++) {\n    let count = 0\n    while (i - count >= 0 || count < s.length - i) {\n      if (s[i - count] === c || s[i + count] === c) {\n        res.push(count)\n        break\n      }\n      count ++\n    }\n  }\n  return res\n}\n```\n\n## 复杂度\n- 时间复杂度 O(n^2)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186431946","body":"## 思路\r\n数组实现，push时判断长度超出，pop时判断数组内是否还有数据\r\n\r\n## 代码\r\n```javascript\r\nclass CustomStack {\r\n  constructor(maxSize) {\r\n    this.data = []\r\n    this.maxSize = maxSize\r\n  }\r\n\r\n  push(x) {\r\n    if(this.data.length < this.maxSize) {\r\n      this.data.push(x)\r\n    }\r\n  }\r\n\r\n  pop() {\r\n    return this.data.pop() || -1\r\n  }\r\n\r\n  increment(k, val) {\r\n    for(let i = 0; i < this.data.length; i++) {\r\n      if(i >= k) break\r\n      this.data[i] += val\r\n    }\r\n  }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186825671","body":"## 思路\n1.创建两个栈，一个存数字，一个存字符\n2.遇到 '[' 时，把数字和当前的结果分别放入两个栈内\n3.遇到 ']' 时，把当前的结果 * (数字栈顶的数字）次，再加上字符栈顶的字符，视作当前的结果\n4.遇到数字时，multi值记录，可能会有几位数，所以 * 10\n5.遇到普通字符时，直接在当前结果后面加上该字符\n\n## 代码\n```javascript\nfunction decodeString (s) {\n  let multiStack = [], resStack = [], res = '', multi = 0\n  for(let str of s) {\n    if(str === '[') {\n      multiStack.push(multi)\n      resStack.push(res)\n      multi = 0\n      res = ''\n    } else if(str === ']') {\n      res = resStack.pop() + res.repeat(multiStack.pop())\n    } else if(!isNaN(str)) {\n      multi = multi*10 + parseInt(str)\n    } else {\n      res += str\n    }\n  }\n  return res\n}\n```\n\n## 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189095766","body":"## 思路\r\n\r\n创建两个栈，一个表示队列内的数据，一个作为数据转移的临时栈\r\n\r\n\r\n## 代码\r\n```javascript\r\nvar MyQueue = function() {\r\n    this.stack1 = []\r\n    this.stack2 = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    while(this.stack1.length > 1) {\r\n        this.stack2.push(this.stack1.pop())\r\n    }\r\n    let res = this.stack1.pop()\r\n    while(this.stack2.length) {\r\n        this.stack1.push(this.stack2.pop())\r\n    }\r\n    return res\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    while(this.stack1.length > 1) {\r\n        this.stack2.push(this.stack1.pop())\r\n    }\r\n    let res = this.stack1[0]\r\n    while(this.stack2.length) {\r\n        this.stack1.push(this.stack2.pop())\r\n    }\r\n    return res\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack1.length === 0\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190319047","body":"## 思路\r\n参考了答案，使用map计数分桶的方式实现\r\n\r\n## 代码\r\n```javascript\r\nfunction maxChunksToSorted(arr) {\r\n  let sortArr = [...arr].sort((x,y) => x-y)\r\n  let countMap = new Map();\r\n  let ans = 0\r\n  let diffNum = 0\r\n  for(let i = 0; i < arr.length; i++) {\r\n    let m = arr[i]\r\n    countMap.set(m, (countMap.get(m) || 0) + 1)\r\n    if(countMap.get(m) === 1) {\r\n      diffNum ++\r\n    }\r\n    if(countMap.get(m) === 0) {\r\n      diffNum --\r\n    }\r\n\r\n    let n = sortArr[i]\r\n    countMap.set(n, (countMap.get(n) || 0) - 1)\r\n    if(countMap.get(n) === -1) {\r\n      diffNum ++\r\n    }\r\n    if(countMap.get(n) === 0) {\r\n      diffNum --\r\n    }\r\n\r\n    if(diffNum === 0) ans ++\r\n  }\r\n  return ans\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度 O(n*logn)\r\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191177194","body":"## 思路\n1.先遍历一遍获取链表长度，k/长度取余得到需要移动的次数\n\n2.循环第一步得到的次数，每一次都把最后一个node的next指向当前的第一个node，倒数第二个node的next置为null\n\n3.需要注意链表为空和只有一个node的情况\n\n## 代码\n```javascript\nvar rotateRight = function(head, k) {\n  if(!head || !head.next) return head\n  let cur = head\n  let length = 1\n  while(cur.next) {\n    length ++\n    cur = cur.next\n  }\n  let count = k % length\n  while(count > 0) {\n    let pre = null\n    let cur = head\n    while(head.next) {\n      pre = head\n      head = head.next\n    }\n    head.next = cur\n    pre.next = null\n    count --\n  }\n  return head\n};\n```\n\n## 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192380001","body":"## 思路\n\n两两交换会涉及到4个节点，步骤拆解如下，同时new一个虚拟节点pre解决边界问题\n\n初始：pre -> A -> B -> next\n\npre -> A -> next , B -> next\n\npre -> A -> next , B -> A\n\npre -> B -> A -> next\n\n## 代码\n```javascript\nfunction swapPairs(head) {\n  if(!head || !head.next) return head\n  let res = head.next\n  let node = head\n  let preNode = new ListNode()\n  while(node && node.next) {\n    let nNode = node.next\n    let nnNode = nNode.next\n    node.next = nnNode\n    nNode.next = node\n    preNode.next = nNode\n\n    preNode = node\n    node = nnNode\n  }\n  return res\n}\n```\n\n## 复杂度\n- 空间复杂度 O(1)\n- 时间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193126981","body":"## 思路\r\n看了题解写出来的，通过快慢指针方法找到中间节点，以此为根，左节点是再以相同方法找到首节点和此根节点的中间节点，右节点是此根节点到尾节点的中间节点，通过递归构建树，中间碰到首尾节点相同则说明没有中间节点，返回null\r\n\r\n## 代码\r\n```javascript\r\nfunction sortedListToBST(head) {\r\n    if(!head) return null\r\n    return dfs(head, null)\r\n};\r\nfunction dfs(head, tail) {\r\n    if(head === tail) return null\r\n    let fast = head, slow = head\r\n    while(fast !== tail && fast.next !== tail) {\r\n        fast = fast.next.next\r\n        slow = slow.next\r\n    }\r\n    let root = new TreeNode(slow.val)\r\n    root.left = dfs(head, slow)\r\n    root.right = dfs(slow.next, tail)\r\n    return root\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193257940","body":"## 思路\r\n双指针\r\n\r\n## 代码\r\n```javascript\r\nfunction getIntersectionNode(headA, headB) {\r\nlet a = headA, b = headB\r\n  while (a != b) {\r\n    a = a ? a.next : headB\r\n    b = b ? b.next : headA\r\n  }\r\n  return a;\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194074127","body":"## 思路\r\n遍历节点 哈希判断\r\n\r\n## 代码\r\n```javascript\r\nvar detectCycle = function(head) {\r\n    let map = new Map();\r\n    while(head) {\r\n        if(map.has(head)) {\r\n            return head\r\n        }\r\n        map.set(head, 1)\r\n        head = head.next\r\n    }\r\n    return null\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195142078","body":"## 思路\n使用Map实现，get时把当前get的这个放到最后，put时判断长度是不是超出了，超出则删掉第一个，再把需要put的值塞到最后\n\n## 代码\n```javascript\nvar LRUCache = function(capacity) {\n  this.limit = capacity\n  this.data = new Map()\n};\n\nLRUCache.prototype.get = function(key) {\n  if(this.data.has(key)) {\n    let tmp = this.data.get(key)\n    this.data.delete(key)\n    this.data.set(key, tmp)\n    return tmp\n  }\n  return -1\n};\n\nLRUCache.prototype.put = function(key, value) {\n  if(this.data.has(key)) {\n    this.data.delete(key)\n    this.data.set(key, value)\n    return\n  }\n  if(this.data.size >= this.limit) {\n    this.data.delete(this.data.keys().next().value)\n    this.data.set(key, value)\n  } else {\n    this.data.set(key, value)\n  }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196441585","body":"## 思路\n递归，把当前node和深度作为参数，找左右两个节点深度较深的那个\n\n## 代码\n```javascript\nvar maxDepth = function(root) {\n  return dfs(root, 0)\n};\n\nvar dfs = function(node, max) {\n  if(!node) return max\n  return Math.max(dfs(node.left, max + 1), dfs(node.right, max + 1))\n}\n```\n\n## 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185100852","body":"##Go解法思路\n```\nfunc addToArrayForm(num []int,k int)(ans []int){\n\tfor i := len(num)-1;i>=0;i--{\n\t\tsum := num[i] + k%10\n\t\tk /= 10\n\t\tif sum >=10{\n\t\t\tk ++\n\t\t\tsum -= 10\n\t\t}\n\t\tans = append(ans,sum)\n\t}\n\tfor ; k>0;k/=10{\n\t\tans = append(ans,k%10)\n\t}\n\treverse(ans)\n\treturn\n}\n\nfunc reverse(num []int){\n\tfor i,n := 0,len(num);i<n/2;i++{\n\t\tnum[i],num[n-1-i] = num[n-1-i],num[i]\n\t}\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186893829","body":"##Go代码\r\n\r\n'''\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n)\r\n\r\nfunc shortestToChar(s string, c byte) []int {\r\n\tpos, answer := -len(s), make([]int, len(s))\r\n\tfor i := 0; i < len(s); i++ {\r\n\t\tif s[i] == c {\r\n\t\t\tpos = i\r\n\t\t}\r\n\t\tanswer[i] = i - pos\r\n\t}\r\n\tfor i := pos - 1; i >= 0; i-- {\r\n\t\tif s[i] == c {\r\n\t\t\tpos = i\r\n\t\t}\r\n\t\tanswer[i] = int(math.Min(float64(answer[i]), float64(pos-i)))\r\n\t}\r\n\treturn answer\r\n}\r\n\r\nfunc main() {\r\n\ts := \"loveleetcode\"\r\n\tvar str byte = 'e'\r\n\tfmt.Println(shortestToChar(s,str))\r\n}\r\n\r\n'''","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186911685","body":"#Day 4  GO解法\n```\nvar i int\n\nfunc run(s string) string{\n\tres := \"\"\n\tnum := 0\n\tfor ; i<len(s);i++{\n\t\tif s[i] >= '0' && s[i] <= '9'{\n\t\t\tnum = num *10 + int(s[i]-'0')\n\t\t}else if (s[i] >= 'a'&& s[i] <= 'z'){\n\t\t\tres += string(s[i])\n\t\t}else if s[i] == '[' {\n\t\t\ti++\n\t\t\ttmp := run(s)\n\t\t\tfor j := 0;j<num;j++{\n\t\t\t\tres += tmp\n\t\t\t}\n\t\t\tnum =0\n\t\t}else{\n\t\t\tbreak\n\t\t}\n\t}\n\treturn res\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185100878","body":"### 思路\nlist变为str再变为int然后求和后再转化为list\n### 代码\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        sum = int(''.join(map(str, num))) + k\n        return [int(i) for i in str(sum)]\n```\n**复杂度分析**\n- 时间复杂度：O(n) \n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186084611","body":"### 思路\n遍历s，如果在相应位置的字符等于c，则该位置的最短距离一定为0。如果不是c，则重新遍历s，计算离每个c的距离，从中取最小值\n### 代码\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            if s[i] == c:\n                res.append(0)\n            else:\n                res.append(min(abs(i - j) for j in range(len(s)) if s[j] == c))\n        return res\n```\n**复杂度分析**\n- 时间复杂度：O(n^2) 这里嵌套了两层for循环\n- 空间复杂度：O(n) n为res长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186393084","body":"### 代码\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        self.n = maxSize\n        self.stack = []\n        self.inc = []\n\n\n    def push(self, x):\n        if(len(self.stack) < self.n):\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self):\n        if(len(self.stack) == 0):\n            return -1\n        else:\n            return self.stack.pop() + self.inc.pop()\n\n\n    def increment(self, k, val):\n        for i in range(min(k, len(self.inc))):\n            self.inc[i] += val\n```\n**复杂度分析**\n- 时间复杂度：O(n) \n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187081216","body":"### 思路\n这里面括号都是整对出现的，是一个很经典的括号问题，可以用到栈来解决。，遇到左括号进栈，右括号出栈\n### 代码\n```python\nclass Solution(object):\n    def decodeString(self, s):\n        stack = [(1, [])]\n        currK = []\n        for i in range(len(s)):\n            if s[i].isdigit():\n                currK.append(s[i])\n            elif s[i] == '[':\n                k = int(\"\".join(currK))\n                stack.append((k, []))\n                currK = []\n            elif s[i] == ']':\n                k, cstr = stack.pop()\n                stack[-1][1].extend(k*cstr)\n            else:\n                stack[-1][1].append(s[i])\n\n        return \"\".join(stack[0][1])\n```\n**复杂度分析**\n- 时间复杂度：O(n),其中n为解码后的s的长度。\n- 空间复杂度：O(n),其中n为解码后的s的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188442598","body":"### 思路\n进队列和进栈操作相同，都可以用append来实现，这里设置两个栈，出队列的时候，需要先用栈一元素全部到栈二，然后栈二出栈即可得到相应元素\n### 代码\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack.append(x)\n\n    def pop(self):\n        if len(self.stack) == 0:\n            return -1\n        else:\n            while len(self.stack) > 1:\n                self.stack2.append(self.stack.pop())\n            res = self.stack.pop()\n            while len(self.stack2) > 0:\n                self.stack.append(self.stack2.pop())\n            return res\n\n    def peek(self):\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack[0]\n\n    def empty(self):\n        return len(self.stack) == 0\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189697436","body":"### 借鉴官方题解\n### 代码\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        stack = []\n        for a in arr:\n            if stack and stack[-1] > a:\n                cur = stack[-1]\n                while stack and stack[-1] > a:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)\n```\n**复杂度分析**\n- 时间复杂度：O(n) \n- 空间复杂度：O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190937927","body":"### 思路\n我们可以先确定链表的长度和链表的最后一个元素，把链表变成一个环。然后找到第length-k-1的位置将幻切割即可得到最终答案\n### 代码\n```python\nclass Solution(object):\n    def rotateRight(self, head, k):\n        lastElement = head\n        length = 1\n        while ( lastElement.next ):\n            lastElement = lastElement.next\n            length += 1\n        k = k % length\n        lastElement.next = head\n        tempNode = head\n        for _ in range( length - k - 1 ):\n            tempNode = tempNode.next\n        answer = tempNode.next\n        tempNode.next = None\n        return answer\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192194926","body":"### 思路\n遍历链表，两两进行交换\n### 代码\n```python\nclass Solution(object):\n    def swapPairs(self, head):\n        pre = head\n        while pre and pre.next:\n            a = pre.val\n            b = pre.next.val\n            pre.val = b\n            pre.next.val = a\n            pre = pre.next.next\n        return head\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193032471","body":"```\nclass Solution(object):\n    def sortedListToBST(self, head):\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        slow,fast = head,head.next.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        tmp = slow.next\n        slow.next = None\n        root = TreeNode(tmp.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(tmp.next)\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193234551","body":"### 思路\n以相反的顺序连接AB，A+B和B+A。这样，遍历连接后的链表，最后一定会遇到相交的节点\n### 代码\n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        a,b = headA,headB\n        while (a != b):\n            a = headB if not a else a.next\n            b = headA if not b else b.next\n        return a\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193475712","body":"```python\nclass Solution(object):\n    def detectCycle(self, head):\n        slow = fast = head\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            if slow == fast: break\n        if not (fast and fast.next): return None\n        while head != slow:\n            head, slow = head.next, slow.next\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195461532","body":"```python\nclass LRUCache(object):\n    def __init__(self,capacity):\n        self.dic = collections.OrderedDict()\n        self.remain = capacity\n    def get(self,key):\n        if key not in self.dic:\n            return -1\n        v = self.dic.pop(key)\n        self.dic[key] = v\n        return v\n    def set(self,key,value):\n        if key in self.dic:\n            self.dic.pop(key)\n        else:\n            if self.remain > 0:\n                self.remain -= 1\n            else:\n                self.dic.popitem(last=False)\n        self.dic[key] = value\n```\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196271612","body":"```python\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197580305","body":"```\ndef isSameTree1(self, p, q):\n    if p and q:\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n    else:\n        return p == q\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185102829","body":"```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        int kLength = 0;\n        int kcounter = k;\n        while(kcounter > 0){\n            kcounter /= 10;\n            kLength++;\n        }\n        int numLength = num.length;\n        List<Integer> res = new ArrayList<Integer>();\n        // find num or k whichever has smallest length as counter to loop\n        int counter = kLength > numLength ? numLength : kLength;\n        int carry = 0;\n        // add digit with digit and if exceed 10 then add 1 to carry and remainder to list\n        while(counter > 0){\n            int remainder = k % 10;\n            k /= 10;           \n            int digit = (num[numLength - 1] + remainder + carry) % 10;\n            carry = (num[numLength - 1] + remainder + carry) / 10;\n            // add remainder to each digit\n            res.add(0, digit);\n            counter--;\n            numLength--;\n        }\n        // if k is longer digit, then we add remaining k to list\n        while(k > 0){\n            int remainder = k % 10;\n            k /= 10;\n            int digit = (remainder + carry) % 10;\n            carry = (remainder + carry) / 10;\n            // add remainder to each digit\n            res.add(0, digit);\n        }\n        // if num array is longer, then we add remaining num array to list\n        while(numLength > 0){\n            int digit = (num[numLength - 1] + carry) % 10;\n            carry = (num[numLength - 1] + carry) / 10;\n            res.add(0, digit);\n            numLength--;\n        }\n        // if we have remaining carry, we add carry to list\n        if(carry > 0){\n            res.add(0, carry);\n        }\n        return res;\n    }\n```\n\n  Time Complexity: O(max(N,M)) which N is length of num array and M is digit of k  <br/>\n  Space Complexity: O(max(N, M)) since we need to store the result and it is the longest number between length num array and digit of k <br/>\n## 思路\n#### 我需要把两个数相加，那我就只需要把每个digit的数相加然后除以10，余数就是现在的digit的数，如果超过10就加入carry 加到下一个digit 比如个位上 num array是5，k的个位是6，那最终结果的个位必然是1，我们把多出来的10加到十位数就行，具体可视化参照小学加法列式子","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186091786","body":"#### 思路\n- 先从左往右遍历整个string，遇到和c一样的字母，那它的distance就是0，往右的字母就以左边的这个字母为基准记录距离\n- 然后从右往左遍历整个string，同样道理，遇到和c一样的字母，那它的distance就是0，往左的字母就以这个字母为基准记录距离，但是需要和原本位置的array item比小，小的才是答案\n\n```java\npublic int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n        int prev = Integer.MIN_VALUE / 2;\n        \n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) == c) \n                prev = i;\n            \n            res[i] = i - prev;\n        }\n        \n        prev = Integer.MAX_VALUE / 2;\n        for (int i = n-1; i >= 0; --i) {\n            if (s.charAt(i) == c) \n                prev = i;\n            res[i] = Math.min(res[i], prev - i);\n        }\n\n        return res;\n    }\n```\nTime Complexity: O(N) -- loop through string twice, N is length of string <br/>\nSpace Complexity: O(N) -- we store the answer with an array in length N which is the length of string","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186520151","body":"### 思路\r\n- 用array模拟\r\n\r\n```java\r\nclass CustomStack {\r\n    int maxSize;\r\n    int size;\r\n    int[] data;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        this.size = 0;\r\n        this.data = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(size < maxSize)\r\n            data[size++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size == 0) return -1;\r\n        return data[--size];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(k > size){\r\n            for(int i = 0; i < size; i++){\r\n                data[i] += val;\r\n            }\r\n        }else{\r\n            for(int i = 0; i < k; i++){\r\n                data[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\nTime complexity: <br/>\r\n- push O(1)\r\n- pop O(1)\r\n- inc O(min(k, size))\r\nSpace complexity: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187342571","body":"#### 思路 <br/>\nuse two stack\n- one hold the multiplier\n- one to hold the string characters\nwe push the string characters to charStack and we convert the multiplier to digit and store into count stack. Once we meet ']' that means we have a complete '[ ]' so we could apply the mulitplier on the top of countStack to the char pattern inside the bracket. Then we get the decoded char arrays and push it back to charStack. we continue doing this until the string input is at the end. Then we would have the result string character in stack. Then we need to use string builder to convert the char stack to string.\n\n```java\npublic String decodeString(String s) {\n        Stack<Character> charStack = new Stack<>();\n        Stack<Integer> countStack = new Stack<>();\n        for(int i = 0; i < s.length(); i++){\n            // start to pop when we find ]\n            if(s.charAt(i) == ']'){\n                List<Character> tempString = new ArrayList<Character>();\n                while(charStack.peek() != '['){\n                    tempString.add(charStack.pop());\n                }\n                // remove [\n                charStack.pop();\n                int k = 0;\n                // get the number k\n                if(!countStack.isEmpty()){\n                    k = countStack.pop();\n                }\n                // push back multiplied partial string back to stack\n                while(k > 0){\n                    for (int j = tempString.size() - 1; j >= 0; j--) {\n                        charStack.push(tempString.get(j));\n                    }\n                    k--;\n                }\n            }else if(Character.isDigit(s.charAt(i))){\n                int k = s.charAt(i) - '0';\n                while(Character.isDigit(s.charAt(i+1))){\n                    k = k*10 + (s.charAt(i+1) - '0');\n                    i++;\n                }\n                countStack.push(k);\n            }else{\n                charStack.push(s.charAt(i));\n            }\n        }\n        StringBuilder res = new StringBuilder();\n        while(!charStack.isEmpty()){\n            res.insert(0, charStack.pop());\n        }\n        return res.toString();\n    }\n```\nTime Complexity: O(N* M) we loop through all characters in string thus it will have N loops, which N is the length of string, and for each time we need to run k times in order to apply multiplier, so the worst case is Max(k), thus M, so it is N * M\n\nSpace Complexity: we use to stacks which the total length is the length of string, we also use stringBuilder to hold result, so the space is O(N), N is the length of result.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189061235","body":"##### 思路\n\n使用两个stack来模拟queue的运行模式，因为stack是FILO，所以我们要把它调个头。假设queue的顺序是FIFO，那新的element进来时我们应该把它加在屁股上，所以把所有queue的element都加入holder里面然后在把element加入进去就是加在屁股上了，然后我们再把holder的所以element都返回给queue\n\n```java\nclass MyQueue {\n    Stack<Integer> queue;\n    Stack<Integer> holder;\n    public MyQueue() {\n        queue = new Stack<>();\n        holder = new Stack<>();\n    }\n    \n    public void push(int x) {\n        while(!queue.isEmpty()){\n            holder.push(queue.pop());\n        }\n        holder.push(x);\n        while(!holder.isEmpty()){\n            queue.push(holder.pop());\n        }\n    }\n    \n    public int pop() {\n        return queue.pop();\n    }\n    \n    public int peek() {\n        return queue.peek();\n    }\n    \n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n```\nTime Complexity:\n- push: O(n)\n- pop: O(1)\n- peek: O(1)\n- empty: O(1) \n\nSpace Complexity: using two stack, so it is O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189747262","body":"##### 思路\n可以观察到在sort好的array中，左边chunk的最大值一定小于等于右边chunk的最小值，所以我们只需要找到array里面每个position的右边chunk最小值(可以通过反向遍历得到)，然后我们再遍历array并记录左边的最大值，对比两个值，只要最小值大于等于最大值，那这便说明符合条件\n\n```java\npublic int maxChunksToSorted(int[] arr) {\n        // we need to find right side chunk min for each position\n        int[] rightMin = new int[arr.length + 1];\n        rightMin[arr.length] = Integer.MAX_VALUE;\n        for(int i = arr.length - 1; i >= 0; i--){\n            rightMin[i] = Math.min(arr[i], rightMin[i+1]);\n        }\n        int leftMax = Integer.MIN_VALUE;\n        int res = 0;\n        for(int i = 0; i < arr.length; i++){\n            leftMax = Math.max(leftMax, arr[i]);\n            if(leftMax <= rightMin[i+1]){\n                res++;\n            }\n        }\n        return res;\n    }\n```\nTime Complexity: O(N) which N is the length of array - 遍历两遍array\n\nSpace Complxity: O(N) which N is the length of array - 用一个array储存右边chunk最小值","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190954446","body":"##### 思路\n因为list有长度，所以移动了k次，其实是移动了k%length次。我们先算出实际移动的k，然后利用快慢双指针，让快指针先移动实际k次，然后快慢指针同时向后移动，直到快指针到达list末尾时停止。此时慢指针的下一个node就是新的头，慢指针本身是新的尾巴，所以我们就把新的头拿出来，然后把慢指针的next设置为null，最后把快指针的next设置成老的head，然后return新的头就得到正确答案\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return head;\n        // find the length of list\n        ListNode count = head;\n        int counter = 0;\n        while(count != null){\n            count = count.next;\n            ++counter;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        k = k % counter;\n        if(k == 0) return head;\n        while(k > 0){\n            fast = fast.next;\n            --k;\n        }\n        while(fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        ListNode newHead = slow.next;\n        slow.next = null;\n        fast.next = head;\n        return newHead;\n    }\n```\nTime Complexity: O(N) which N is length of list\n\nSpace Complextiy: O(1), we did not use additional data structure ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192593911","body":"##### 思路\nwe repeatedly swap two node, so we could use recursion to repeat the swap steps\n\n```java\npublic ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        \n        // Nodes to be swapped\n        ListNode firstNode = head;\n        ListNode secondNode = head.next;\n        \n        // Swap\n        firstNode.next = swapPairs(secondNode.next);\n        secondNode.next = firstNode;\n        \n        // Now the head is second node, so return it\n        return secondNode;\n}\n```\nTime Complexity: for each recursion the time complexity is O(1), and we run through the whole list nodes, thus it is O(N)\n\nSpace Complexity: we didn't use additional data structures, so it is O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193124003","body":"```java\n    public TreeNode sortedListToBST(ListNode head) {\n        // 使用dfs 快慢双指针能定位中点\n        if(head == null) return null;\n        return dfs(head, null);\n    }\n    \n    public TreeNode dfs(ListNode head, ListNode tail){\n        if(head == tail) return null;\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n       }\n       TreeNode root = new TreeNode(slow.val);\n       root.left = dfs(head, slow);\n       root.right = dfs(slow.next, tail);\n       return root;\n    }\n```\nTime Complexity: O(nlog(n))\n\nSpace Complexity: O(log(n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193317905","body":"##### 思路\n双指针 当双指针在同一node上 那个node一定是交叉的node\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode a = headA;\n        ListNode b = headB;\n        \n        while(a != b){\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n```\nTime Complexity: O(N) which N is the total length of list A and B\n\nSpace Complexity: O(1) we didn't use additional data structure","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194111195","body":"```java\npublic ListNode detectCycle(ListNode head) {\n        if(head == null) return null;\n        ListNode slow = head, fast = head;\n        while(fast != null){\n            slow = slow.next;\n            if(fast.next != null){\n                fast = fast.next.next;\n            }else{\n                return null;\n            }\n            if(fast == slow){\n                ListNode ptr = head;\n                while(ptr != slow){\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n```\nTime Complexity: O(N)\n\nSpace Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194992894","body":"Using LinkedHashMap to keep order\n\n```java\nclass LRUCache extends LinkedHashMap<Integer, Integer> {\n\n    private int capacity;\n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n    \n    public void put(int key, int value) {\n        super.put(key, value);      \n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity; \n    }\n}\n```\nTime Complexity: O(1)\n\nSpace Complexity: O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196228604","body":"##### 思路\r\n使用DFS，树的最大高度取决于它的左边和右边的最大高度，所以它的最大高度就是1+Max（左边高度，右边高度），如果node是null，那就说明到底部了，return 0\r\n\r\n```java\r\npublic int maxDepth(TreeNode root) {\r\n        if(root == null) return 0;\r\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n}\r\n```\r\nTime Complexity: O(N) which n is the total number of node in tree\r\n\r\nSpace Complexity: O(height) since we use recursion call stack","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185108946","body":"```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\t\tLinkedList<Integer> list = new LinkedList<Integer>();\r\n    \t        int carry = 0;\r\n\t\tint i = num.length-1;\r\n    \twhile(i >= 0||k != 0){\r\n    \t\tif(k == 0 && carry == 0){\r\n    \t\t\tlist.push(num[i]);\r\n    \t\t\ti--;\r\n    \t\t\tcontinue;\r\n\t\t     }\r\n    \t\tint cur = carry + k%10;\r\n\t\tif(i >= 0)  cur += num[i];\r\n\t\tlist.push(cur%10);\r\n\t\tcarry = cur/10;\r\n\t\tk /= 10;\r\n\t\ti--;\r\n\t}\r\n    \tif(carry != 0){\r\n    \t\tlist.push(1);\r\n\t}\r\n    \treturn list;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186383932","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n    \tif(s.length() == 1)  return new int[]{0};\r\n    \tint left = 0;\r\n    \tint right = 0;\r\n    \tint temp = Integer.MAX_VALUE;\r\n    \tint[] dist = new int[s.length()];\r\n    \twhile(right < s.length()){\r\n    \t\twhile(right != s.length() && s.charAt(right) != c)  right++;\r\n    \t\twhile(left < right){\r\n    \t\t\tif(right != s.length())  dist[left] = Math.min(Math.abs(left-temp), right-left);\r\n    \t\t\telse  dist[left] = left-temp;\r\n\t\t\tleft++;\r\n\t\t}\r\n    \t\tif(right != s.length()){\r\n\t\t\tdist[left] = 0;\r\n\t\t\ttemp = left;\r\n\t\t\tright++;\r\n\t\t}\r\n\t}\r\n    \treturn dist;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186394234","body":"```java\r\nclass CustomStack {\r\n\t     private int[] arr;\r\n\t     private int top;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != arr.length-1)\r\n            arr[++top] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top != -1){\r\n            top--;\r\n            return arr[top+1];\r\n        }else  return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int i = 0;\r\n        while(k != 0 && i <= top){\r\n            arr[i++] += val;\r\n            k--;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186949660","body":"```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n\t\tLinkedList<Character> stack = new LinkedList<Character>();\r\n\t\tLinkedList<Character> temp = new LinkedList<Character>();\r\n\t\tStringBuilder str = new StringBuilder();\r\n\t\t//暴力栈\r\n\t\tfor(int i = 0; i < s.length(); i++){\r\n\t\t\tchar c = s.charAt(i);\r\n\t\t\tif(c >= 'a' && c <= 'z' && stack.isEmpty())  str.append(c);\r\n\t\t\telse if(c != ']')  stack.push(c);\r\n\t\t\telse{\r\n\t\t\t\twhile(stack.peek() != '[')\r\n\t\t\t\t\ttemp.push(stack.pop());\r\n\t\t\t\tstack.pop();\r\n\t\t\t\tString times = \"\";\r\n\t\t\t\twhile(!stack.isEmpty() && stack.peek() >= '0' && stack.peek() <= '9')\r\n\t\t\t\t\ttimes = stack.pop() + times;\r\n\t\t\t\tif(stack.isEmpty()){\r\n\t\t\t\t\tString t = \"\";\r\n\t\t\t\t\tfor(char ch : temp)\r\n\t\t\t\t\t\tt += ch;\r\n\t\t\t\t\tfor(int j = 0; j < Integer.valueOf(times); j++)\r\n\t\t\t\t\t\tstr.append(t);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tCollections.reverse(temp);\r\n\t\t\t\t\tfor(int j = 0; j < Integer.valueOf(times); j++)\r\n\t\t\t\t\t\tstack.addAll(0, temp);\r\n\t\t\t\t}\r\n\t\t\t\ttemp.clear();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn str.toString();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1192632713","body":"```java\r\nclass MyQueue {\r\n\tprivate LinkedList<Integer> stack1 ;\r\n    private LinkedList<Integer> stack2 ;\r\n    //维护队首元素，这样就不需要区分pop和peek了\r\n    //队首元素要么出现在stack1栈底，要么出现在stack2栈顶\r\n    private int front;\r\n\r\n    public MyQueue() {\r\n        stack1 = new LinkedList<Integer>();\r\n        stack2 = new LinkedList<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(stack2.isEmpty() && stack1.isEmpty())\r\n            front = x;\r\n        stack1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(stack2.isEmpty()){\r\n            while(!stack1.isEmpty())\r\n                stack2.push(stack1.pop());\r\n        }\r\n        int top = stack2.pop();\r\n        if(empty())  return top;\r\n\r\n        if(stack2.isEmpty()){\r\n            while(!stack1.isEmpty())\r\n                stack2.push(stack1.pop());\r\n        }\r\n        front = stack2.peek();\r\n        return top;\r\n    }\r\n    \r\n    public int peek() {\r\n        return front;\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1193091951","body":"```java\r\nclass Solution {\r\n\tpublic int maxChunksToSorted(int[] arr) {\r\n\t\tif(arr.length == 1)  return 1;\r\n\t\tif(arr.length == 2){\r\n\t\t\tif(arr[0] <= arr[1])  return 2;\r\n\t\t\telse return 1;\r\n\t\t}\r\n\r\n\t\tLinkedList<Integer> stack = new LinkedList<Integer>();\r\n\t\tfor(int i = 0; i < arr.length; i++){\r\n\t\t\tif(stack.isEmpty() || arr[i] >= stack.peek())  stack.push(arr[i]);\r\n\t\t\telse{\r\n\t\t\t\tint head = stack.pop();\r\n\t\t\t\twhile(!stack.isEmpty() && arr[i] < stack.peek())\r\n\t\t\t\t\tstack.pop();\r\n\t\t\t\tstack.push(head);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn stack.size();\r\n\t}\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1193127212","body":"```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n    \tif(head == null || head.next == null)  return head;\r\n    \tif(k == 0)  return head;\r\n\r\n    \t//链表尾倒数第k个是头结点，快指针和慢指针间的初始距离为k-1\r\n\t\tListNode fast = head;\r\n\t\tfor(int i = 0; i < k-1; i++){\r\n\t\t\tif(fast.next != null)  fast = fast.next;\r\n\t\t\telse  fast = head;\r\n\t\t}\r\n\t\tListNode slow = head;\r\n\t\twhile(fast.next != null){\r\n\t\t\tfast = fast.next;\r\n\t\t\tslow = slow.next;\r\n\t\t}\r\n\t\tfast.next = head;\r\n\t\tfast = head;\r\n\t\twhile(fast.next != slow)\r\n\t\t\tfast = fast.next;\r\n\t\tfast.next = null;\r\n\t\treturn slow;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1193224227","body":"```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n    \tif(head == null || head.next == null)  return head;\r\n\r\n    \tListNode temp = head.next.next;\r\n    \tListNode newHead = head.next;\r\n    \thead.next.next = head;\r\n    \thead.next = swapPairs(temp);\r\n    \treturn newHead;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193238078","body":"```java\r\n//结合快慢指针\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n    \t//排除问题规模<=2的情况\r\n    \tif(head == null)  return null;\r\n    \tif(head.next == null)  return new TreeNode(head.val);\r\n    \tif(head.next.next == null)  return new TreeNode(head.val, null, new TreeNode(head.next.val));\r\n\r\n    \tListNode slow = head;\r\n    \tListNode fast = head.next;\r\n    \tListNode tail = null;\r\n    \twhile(fast.next != null){\r\n    \t\ttail = slow;\r\n    \t\tslow = slow.next;\r\n    \t\tif(fast.next.next != null)  fast = fast.next.next;\r\n    \t\telse fast = fast.next;\r\n\t\t}\r\n    \tif(tail != null)  tail.next = null;\r\n\r\n    \tTreeNode root = new TreeNode(slow.val);\r\n    \troot.right = sortedListToBST(slow.next);\r\n    \tslow.next = null;\r\n    \troot.left = sortedListToBST(head);\r\n\r\n    \treturn root;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1194922683","body":"```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n    \t//单个结点的情况\r\n\t\tif(headA.next == null || headB.next == null){\r\n\t\t\twhile(headA.next != null)  headA = headA.next;\r\n\t\t\twhile(headB.next != null)  headB = headB.next;\r\n\t\t\tif(headA == headB)  return headA;\r\n\t\t\telse return null;\r\n\t\t}\r\n\r\n        ListNode p1 = headA;\r\n        ListNode p2 = headB;\r\n\r\n        boolean p1Flag = false;\r\n        boolean p2Flag = false;\r\n        while(p1 != p2 && (p1.next != null && p2.next != null)){\r\n        \tp1 = p1.next;\r\n        \tp2 = p2.next;\r\n\t\t\tif(p1.next == null && !p1Flag){\r\n\t\t\t\tp1 = headB;\r\n\t\t\t\tp1Flag = true;\r\n\t\t\t}\r\n\t\t\tif(p2.next == null && !p2Flag){\r\n\t\t\t\tp2 = headA;\r\n\t\t\t\tp2Flag = true;\r\n\t\t\t}\r\n\t\t}\r\n        if(p1 == p2)  return p1;\r\n        else  return null;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194955584","body":"```java\r\n//基于两个数学关系：（1）快慢指针相遇时：快指针走过距离是慢指针的2倍 a+b = 2(a+c)\r\n//                （2）快指针的环内路程b 慢指针环内路程c 环长l b = k1l+x c = k2l+x\r\n// (2)代入（1)得到 a+k1l+x = 2a+2k2l+2x ---> (k1-2k2)l-x = a\r\n//显然整数倍环长减去相遇时入环距离x--->剩余环长，也就是说相遇之后一个指针继续走，另一个指针从链表头走，相遇点就是入环点\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n    \tif(head == null || head.next == null || head.next.next == null)  return null;\r\n\r\n    \tListNode slow = head;\r\n    \tListNode fast = head.next;\r\n    \twhile(fast.next != null && fast != slow){\r\n    \t\tslow = slow.next;\r\n    \t\tif(fast.next.next != null)  fast = fast.next.next;\r\n    \t\telse  fast = fast.next;\r\n\t\t}\r\n    \tif(fast.next == null)  return null;\r\n    \t//fast应该从虚拟结点出发\r\n    \tfast = new ListNode(-1);\r\n    \tfast.next = head;\r\n    \twhile(fast != slow){\r\n    \t\tfast = fast.next;\r\n    \t\tslow = slow.next;\r\n\t\t}\r\n    \treturn fast;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1196259121","body":"```java\r\nclass LRUCache {\r\n\tprivate class ListNode{\r\n\t    private int key;\r\n\t    private int value;\r\n\t    private ListNode next;\r\n\t    private ListNode pre;\r\n\t    ListNode(int key, int value){\r\n\t        this.key = key;\r\n\t        this.value = value;\r\n        }\r\n    }\r\n\r\n    private HashMap<Integer, ListNode> map;\r\n\tprivate ListNode head;\r\n\tprivate ListNode tail;\r\n\tprivate int capacity;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        map = new HashMap<Integer, ListNode>();\r\n    }\r\n    \r\n    public int get(int key) {\r\n       ListNode x = map.get(key);\r\n       if(x == null)  return -1;\r\n\r\n       if(x.next != null){\r\n           if(x.pre != null)  x.pre.next = x.next;\r\n           else  head = x.next;\r\n\r\n           x.next.pre = x.pre;\r\n           tail.next = x;\r\n           x.pre = tail;\r\n           x.next = null;\r\n           tail = x;\r\n       }\r\n       return x.value;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        ListNode x = map.get(key);\r\n        if(x == null && map.size() == capacity){\r\n            map.remove(head.key);\r\n            if(head.next == null){\r\n                head = null;\r\n                tail = null;\r\n            }else{\r\n                head.next.pre = null;\r\n                head = head.next;\r\n            }\r\n        }\r\n\r\n        if(x != null){\r\n            x.value = value;\r\n            if(x.next != null){\r\n                if(x.pre != null)  x.pre.next = x.next;\r\n                else  head = x.next;\r\n\r\n                x.next.pre = x.pre;\r\n                tail.next = x;\r\n                x.pre = tail;\r\n                x.next = null;\r\n                tail = x;\r\n            }\r\n        }else{\r\n            x = new ListNode(key, value);\r\n            if(map.isEmpty()){\r\n                head = x;\r\n                tail = x;\r\n            }else{\r\n                tail.next = x;\r\n                x.pre = tail;\r\n                tail = x;\r\n            }\r\n        }\r\n        map.put(key, x);\r\n    }\r\n}\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185110660","body":"```\r\nclass Solution:\r\n    def listsum1(self, a: list[int], k: int) -> list[int]:\r\n        # 时间和空间复杂度都为O(n)\r\n        carry = 0\r\n        n = max(len(a), len(str(k))+1\r\n        res = [0] * n\r\n        a = [0] * (n-len(a)) + a\r\n\r\n        for i in range(n-1, -1, -1):\r\n            res[i] = a[i] + k % 10 + carry\r\n            carry = res[i] // 10\r\n            res[i] = res[i] % 10\r\n            k = k // 10\r\n\r\n        return res[1:] if res[0] == 0 else res\r\n\r\n    def listsum2(self, a: list[int], k: int) -> list[int]:\r\n        a = \"\".join(map(str,a))\r\n        res = int(a) + k\r\n        return list(map(int, str(res)))\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186078578","body":"## 思路\r\n\r\n> 三指针：slow指针指向目前的字符位置，fast1和fast2指向离s[solw]最近的两个'e'的位置。\r\n\r\n##代码\r\n\r\n```python\r\n#代码\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        from collections import defaultdict\r\n        s = list(s)\r\n        distance = [0]*len(s)\r\n        slow = fast1 = 0\r\n        fast2 = float(\"inf\")\r\n        while slow < len(s):\r\n            while fast1 < len(s) and s[fast1] != c:\r\n                fast1 +=1\r\n            while slow < len(s) and slow <= fast1:\r\n                if fast1 < len(s):\r\n                    distance[slow] = min(abs(fast1-slow), abs(fast2-slow))\r\n                    slow +=1\r\n                else:\r\n                    distance[slow] = abs(fast2-slow)\r\n                    slow +=1\r\n            fast2 = fast1\r\n            fast1 +=1\r\n        return distance\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186370986","body":"## 思路\r\n\r\n> 用list实现栈\r\n\r\n##代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        return self.stack.pop() if self.stack else -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] +=val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: push-O(1);pop-O(1);inc-O(n)\r\n> + 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186688323","body":"## 思路\r\n\r\n> \"在栈里面每次存储两部分信息：左括号前的字符串, 左括号前的数字, 比如abc3[def], 当遇到第一个左括号的时候，压入栈中的是(\"abc\", 3), 然后遍历括号里面的字符串def, 当遇到右括号的时候, 从栈里面弹出一个元素(s1, n1), 得到新的字符串为s1+n1*\"def\", 也就是abcdefdefdef。对于括号里面嵌套的情况也是同样处理方式。\"\r\n>左括号触发压栈，右括号触发弹出。\r\n\r\n##代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = deque()\r\n        cnt = 0\r\n        string = ''\r\n\r\n        for char in s:\r\n            if char.isdigit():\r\n                cnt = int(char) + cnt*10\r\n                continue\r\n            elif char == '[':\r\n                stack.append((string, cnt))\r\n                string = ''\r\n                cnt = 0\r\n            elif char == ']':\r\n                tmp = stack.pop()\r\n                string = tmp[0] + tmp[1]*string\r\n            else:\r\n                string +=char\r\n\r\n        return string\r\n\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188677459","body":"## 思路\r\n\r\n> + 双栈\r\n\r\n##代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack_in = []\r\n        self.stack_out = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_in.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n\r\n        if self.stack_out:\r\n            return self.stack_out.pop()\r\n        else:\r\n            for i in range(len(self.stack_in)):\r\n                self.stack_out.append(self.stack_in.pop())\r\n            return self.stack_out.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack_out.append(ans) # pop完需要补回去才能保持栈内元素不变\r\n        return ans\r\n\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not (self.stack_in or self.stack_out)\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189785879","body":"### [思路]\r\n>+ 单调栈\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n\r\n        for i in range(len(arr)):\r\n    \r\n            if stack and stack[-1] > arr[i]: # arr[i] 小于栈顶元素说明会改变前面的数组排序\r\n                head = stack.pop() \r\n                #储存当前的栈顶，以方便后续压栈，因为该栈顶仍是目前排序块的最大值\r\n                while stack and stack[-1] > arr[i]:\r\n                    stack.pop() # 去掉不能成为排序块最大值的元素\r\n                stack.append(head)\r\n            else:\r\n                stack.append(arr[i])\r\n        \r\n        return len(stack)\r\n```\r\n\r\n### 复杂度\r\n>+时间复杂度：O(n)\r\n>+空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191019155","body":"## 思路\r\n\r\n> + 找到链表尾巴和链表长度，形成环链条，再找到新链表头，断开链表。\r\n\r\n##代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        start = head\r\n        end = head\r\n        cnt = 1 # 计算链表长度\r\n\r\n        while end.next:\r\n            end = end.next\r\n            cnt += 1\r\n        \r\n        end.next = head\r\n\r\n        pos = cnt - k%cnt # 从链表头向后移动的步数，到达新链表头\r\n\r\n        while pos > 1:\r\n            start = start.next\r\n            pos -= 1\r\n\r\n        head = start.next\r\n        start.next = None\r\n\r\n        return head\r\n\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192324679","body":"## 思路\r\n\r\n> + pre, cur, post三个节点进行操作，每次交换后pre后移至post节点继续交换。\r\n\r\n##代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy_head = ListNode(next = head)\r\n        pre = dummy_head\r\n        \r\n        while pre.next and pre.next.next:\r\n            cur = pre.next\r\n            post = pre.next.next\r\n\r\n            pre.next = post\r\n            cur.next = post.next\r\n            post.next = cur\r\n\r\n            pre = pre.next.next\r\n        return dummy_head.next\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193116800","body":"```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        return self.helper(head,None)\r\n\r\n    def helper(self,head,tail):\r\n        if head==tail:\r\n            return\r\n        slow=head\r\n        fast=head\r\n        while fast!=tail and fast.next!=tail:\r\n            slow=slow.next\r\n            fast=fast.next.next\r\n        root=TreeNode(slow.val)\r\n        root.left=self.helper(head,slow)\r\n        root.right=self.helper(slow.next,tail)\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193235372","body":"## 思路\r\n\r\n> + 最关键的点在于队尾对齐，然后从短链表的头开始比较。\r\n\r\n##代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        cnt_A = 0\r\n        cnt_B = 0\r\n\r\n        curA = headA\r\n        curB = headB\r\n\r\n        while curA != None:\r\n            cnt_A +=1\r\n            curA = curA.next\r\n        \r\n        while curB != None:\r\n            cnt_B +=1\r\n            curB = curB.next\r\n\r\n        curA = headA\r\n        curB = headB\r\n\r\n        if cnt_A < cnt_B:\r\n            curA, curB = headB, headA\r\n            cnt_A, cnt_B = cnt_B, cnt_A\r\n            \r\n        while cnt_A - cnt_B > 0:\r\n            cnt_A -=1\r\n            curA = curA.next\r\n            \r\n        while curA != None:\r\n            if(curA == curB):\r\n                return curA\r\n            else:\r\n                curA = curA.next\r\n                curB = curB.next\r\n\r\n        return None\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n+m)\r\n> + 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194001596","body":"## 思路\r\n\r\n> + 设从head需要走 a 步到达环的入口，如果环存在的话，再走 b 步可以再次到达该入口（即环的长度为b)\r\n> + 如果存在环的话，快指针 fast 和慢指针slow （相对速度为1 -- 因c此快慢指针必然会相遇）必然会相遇，且此时slow走的路长为 a + x，当快慢指针相遇时，快指针已经至少走完一圈环了，不妨设相遇时走了完整的m圈(m >= 1)，有：\r\n        快指针走的路长为 a + mb + x\r\n        慢指针走的路长为 a + x\r\n> + 由于快指针fast 走的路长始终是慢指针的 2倍，所以：a + mb + x = 2(a + x)\r\n\r\n\r\n## 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast = head\r\n        slow = head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if slow == fast:\r\n                p = head\r\n                q = slow\r\n\r\n                while p!=q:\r\n                    p = p.next\r\n                    q = q.next\r\n                return p\r\n\r\n        return None\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195581523","body":"```python\r\nclass ListNode:\r\n    def __init__(self, key=None, value=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        # 新建两个节点 head 和 tail\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        # 初始化链表为 head <-> tail\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法\r\n    def move_node_to_tail(self, key):\r\n            # 先将哈希表key指向的节点拎出来，为了简洁起名node\r\n            #      hashmap[key]                               hashmap[key]\r\n            #           |                                          |\r\n            #           V              -->                         V\r\n            # prev <-> node <-> next         pre <-> next   ...   node\r\n            node = self.hashmap[key]\r\n            node.prev.next = node.next\r\n            node.next.prev = node.prev\r\n            # 之后将node插入到尾节点前\r\n            #                 hashmap[key]                 hashmap[key]\r\n            #                      |                            |\r\n            #                      V        -->                 V\r\n            # prev <-> tail  ...  node                prev <-> node <-> tail\r\n            node.prev = self.tail.prev\r\n            node.next = self.tail\r\n            self.tail.prev.next = node\r\n            self.tail.prev = node\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.hashmap:\r\n            # 如果已经在链表中了久把它移到末尾（变成最新访问的）\r\n            self.move_node_to_tail(key)\r\n        res = self.hashmap.get(key, -1)\r\n        if res == -1:\r\n            return res\r\n        else:\r\n            return res.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\r\n            # 但是需要更新字典该值对应节点的value\r\n            self.hashmap[key].value = value\r\n            # 之后将该节点移到末尾\r\n            self.move_node_to_tail(key)\r\n        else:\r\n            if len(self.hashmap) == self.capacity:\r\n                # 去掉哈希表对应项\r\n                self.hashmap.pop(self.head.next.key)\r\n                # 去掉最久没有被访问过的节点，即头节点之后的节点\r\n                self.head.next = self.head.next.next\r\n                self.head.next.prev = self.head\r\n            # 如果不在的话就插入到尾节点前\r\n            new = ListNode(key, value)\r\n            self.hashmap[key] = new\r\n            new.prev = self.tail.prev\r\n            new.next = self.tail\r\n            self.tail.prev.next = new\r\n            self.tail.prev = new\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185111126","body":"### 思路\r\n由于k的位数是小于等于A数组位数的，直接利用python转化为字符进行相加\r\n### 代码\r\n```class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        s =  int(''.join(map(str,num))) + k\r\n        return [int(i) for i in str(s)]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186196104","body":"```\nclass Solution:\n    def shortestToChar(self, S: str, C: str) -> List[int]:\n        \n        return [min(abs(i- j)  for j in [i for i in range(len(S)) if S[i] == C]) for i in range(len(S))]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186545431","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.length = 0\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if self.length < self.maxSize:\n            self.length += 1\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.length is 0:\n            return -1\n        else:\n            self.length -= 1\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,self.length)):\n            self.stack[i] += val\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185112285","body":"```\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n    let narr = []\r\n    // k作为每一项都加的东西，余数是要存下的值，除数是下一次要加的东西\r\n    for (let i = num.length - 1; i > -1 || k > 0; i--, k = Math.floor(k / 10)) {\r\n        // 防止num遍历到最头部的时候，k依然有值,需要继续使用\r\n        if (i > -1) {\r\n            k = k + num[i]\r\n        }\r\n        narr.unshift(k % 10)\r\n    }\r\n    return narr\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186096624","body":"```js\nvar shortestToChar = function (s, c) {\n    let res = Array(s.length).fill(Infinity);\n    let cindexs = []\n   for(let i=0;i<s.length;i++){\n       if(s[i]===c) {\n           cindexs.push(i)\n           \n       }\n   }\n   for(let i=0;i<s.length;i++){\n       if(s[i]===c) {\n           res.push(0)\n           continue\n       }\n       for(let ci of cindexs) {\n           let distance = Math.abs(ci-i)\n           //当发现distance开始大于当前res[i]了，说明res[i]已经是最小距离了，后边只会越来越大\n           if(distance>res[i]) break\n           res[i] = distance\n       }\n\n   }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186360684","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.maxSize = maxSize\n    this.curSize = 0\n    this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.curSize < this.maxSize) {\n        this.stack.push(x)\n        this.curSize++\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    if (this.curSize === 0) {\n        return -1\n    }\n    this.curSize--\n    return this.stack.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    this.stack.map((item,i)=>{\n        if(i<k){\n            this.stack[i] += val\n        }\n    })\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186911027","body":"```js\nvar decodeString = function (s) {\n    let stack = []\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == ']') {\n            let repeatStr = ''\n            let repeatCount = ''\n            while (stack && stack[stack.length - 1] != '[') {\n                repeatStr = stack.pop() +repeatStr\n            }\n            stack.pop()\n            while (stack && /\\d/.test(stack[stack.length - 1])) {\n                repeatCount = stack.pop() + repeatCount\n            }\n            repeatStr = repeatStr.repeat(repeatCount * 1);\n            stack.push(repeatStr)\n        } else {\n            stack.push(s[i])\n        }\n    }\n    return stack.join('')\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188822222","body":"```js\n\nvar MyQueue = function () {\n    this.inStack = []\n    this.outStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.inStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    if (!this.outStack.length) {\n        this.in2out()\n    }\n    return this.outStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    if (!this.outStack.length) {\n        this.in2out()\n    }\n    return this.outStack[this.outStack.length-1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    return !this.inStack.length && !this.outStack.length\n};\n\nMyQueue.prototype.in2out = function () {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop())\n    }\n};\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189717710","body":"```js\nvar maxChunksToSorted = function (arr) {\n    let stack = []\n    for (let i = 0; i < arr.length; i++) {\n        let ac = arr[i]\n        let stc = stack[stack.length - 1]\n        if (stack.length && stc > ac) {\n            while (stack.length && stack[stack.length-1] > ac) stack.pop()\n            stack.push(stc)\n        } else {\n            stack.push(ac)\n        }\n    }\n    return stack.length\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190973981","body":"```js\nvar rotateRight = function (head, k) {\n    if(!head || !head.next) return head\n    let count = 0,now = head\n    while (now) {\n        now = now.next\n        count++\n    }\n    k = k % count\n    let slow = (fast = head)\n    while (fast.next) {\n        if (k-- <= 0) {\n            slow = slow.next\n        }\n        fast = fast.next\n    }\n    fast.next = head\n    let res = slow.next\n    slow.next = null\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192108622","body":"```js\nvar swapPairs = function(head) {\n    if(!head || !head.next) return head\n    let res = head.next\n    let preNode =new ListNode()\n    preNode.next = head\n    let now = head\n    while(now&&now.next) {\n        let nextNode = now.next\n        let lastNode = nextNode.next\n\n        now.next = lastNode\n        nextNode.next = now\n        preNode.next = nextNode\n\n        preNode = now\n        now = lastNode\n\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193068780","body":"```js\nvar sortedListToBST = function(head) {\n    if(!head) return head\n    return dfs(head,null)\n};\nfunction dfs(head,tail) {\n    if(head === tail) return null\n    let fast = head\n    let slow = head\n\n    while(fast !== tail && fast.next !== tail) {\n        fast = fast.next.next\n        slow = slow.next\n    }\n\n    let root = new TreeNode(slow.val)\n    root.left = dfs(head,slow)\n    root.right = dfs(slow.next,tail)\n\n    return root\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193251694","body":"```js\nvar getIntersectionNode = function(A, B) {\n    let data = new Set()\n    while(A){\n        data.add(A)\n        A = A.next\n    }\n    while(B) {\n        if(data.has(B)) return B\n        B = B.next\n    }\n    return null\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193476826","body":"```js\nvar detectCycle = function(head) {\n    let data = new Set()\n    while(head) {\n        if(data.has(head)) return head\n        data.add(head)\n        head = head.next\n    }\n    return null\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194886350","body":"```js\nclass DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        // Mappings of key->node.\n        this.hashmap = {}\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key, value) {\n        if (key in this.hashmap) {\n            // If key exists, update the corresponding node and move it to the head.\n            const node = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n        // If it's a new key.\n            if (this._isFull()) {\n                // If the cache is full, remove the tail node.\n                const node = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            // Create a new node and add it to the head.\n            const node = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196188800","body":"```js\nvar maxDepth = function(root) {\n    if(root === null) return 0\n    return Math.max(maxDepth(root.left),maxDepth(root.right))+1\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197560900","body":"```js\nvar isSameTree = function (p, q) {\n    if (!p || !q) {\n        return !p && !q\n    }\n    return (\n        p.val === q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)\n    )\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185112936","body":"## 思路\n    将数组从后往前加给k k每次取余作为结果 /10参与下一次运算\n## 复杂度\n    时间复杂度 O(max(n,m)) m n 为数组的长度 和k的长度 空间复杂度 O(n)\n## 代码\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> result = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            k += num[i];\n            result.addFirst(k % 10);\n            k /= 10;\n        }\n        while (k > 0) {\n            result.addFirst(k % 10);\n            k /= 10;\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186101492","body":"## 思路 \n     从前到后一次判断c和当前位置的距离 再从后往前判断c和当前位置的距离 取较小的值作为结果\n## 复杂度\n    时间复杂度O(n) 空间复杂度O(n)\n## 代码\n```java\n  public int[] shortestToChar(String s, char c) {\n        char[] ss= s.toCharArray();\n        int[] result = new int[ss.length];\n        int temp = 1-s.length();\n        for(int i=0;i<ss.length;i++){\n            if(c!=ss[i]){\n                result[i] = i-temp;\n            }else{\n                temp = i;\n            }\n        }\n        temp= 0;\n        for(int i=result.length-1;i>=0;i--){\n            if(c!=ss[i]){\n                result[i] = Math.min(Math.abs(temp-i),result[i]);\n            }else{\n                temp = i;\n            }\n        }\n        return result;\n    }\n  ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186520696","body":"## 思路\n\n    使用数组记录栈的数据 使用一个下标记录栈指针当前所在的位置 出入栈的时候处理这个栈指针\n\n## 复杂度\n\n    时间复杂度O(n) 空间复杂度O(n)\n\n## 代码\n\n```java\n    class CustomStack {\n    int[] stack;\n    int len;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        len=-1;\n    }\n\n    public void push(int x) {\n        if(len+1<stack.length){\n            len++;\n            stack[len] =x;\n\n        }\n    }\n\n    public int pop() {\n        if(len<0){\n            return -1;\n        }\n        len--;\n        return stack[len+1];\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k, len + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187600669","body":"## 思路\n\n    使用栈记录数据 左括号入栈 有括号出栈 数字则加倍\n\n## 复杂度\n\n    时间复杂度O(n) 空间复杂度O(n)\n\n## 代码\n\n```java\n class Solution {\n    public String decodeString(String s) {\n        Deque<Integer> stackNumber = new LinkedList<>();\n        Deque<String> stackString = new LinkedList<>();\n        StringBuilder stringBuilder = new StringBuilder();\n        int number = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '[') {\n                stackNumber.push(number);\n                number = 0;\n                stackString.push(stringBuilder.toString());\n                stringBuilder = new StringBuilder();\n            } else if (s.charAt(i) == ']') {\n                StringBuilder temp = new StringBuilder();\n                int curr_number = stackNumber.pop();\n                for (int j = 0; j < curr_number; j++) {\n                    temp.append(stringBuilder);\n                }\n                stringBuilder = temp.insert(0, stackString.pop());\n            } else if (s.charAt(i) > 47 && s.charAt(i) < 58) {\n                number = 10 * number + (s.charAt(i) - '0');\n            } else {\n                stringBuilder.append(s.charAt(i));\n            }\n        }\n        return stringBuilder.toString();\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189219881","body":"## 思路\n\n    使用双栈记录数据  压栈存数 翻转栈取数\n\n## 复杂度\n\n    时间复杂度O(1) 空间复杂度O(n)\n\n## 代码\n\n```java\nclass MyQueue {\n        //头栈\n        private Stack<Integer> headStack = new Stack<>();\n        //尾栈\n        private Stack<Integer> tailStack = new Stack<>();\n\n        public MyQueue() {\n        }\n\n        public void push(int x) {\n\n            headStack.push(x);\n        }\n\n        public int pop() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.pop();\n        }\n\n        public int peek() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.peek();\n        }\n\n        public boolean empty() {\n            return headStack.empty() && tailStack.empty();\n        }\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189967735","body":"## 思路\n\t单调栈 将数组首个入栈 对其后的数据 大于等于当前栈顶则入栈 小于则出栈一个并比较下一个栈顶 直到大于等于栈顶或者栈空再入栈\n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(n)\n## 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new LinkedList<>();\n        stack.push(arr[0]);\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] >= stack.peek()) {\n                stack.push(arr[i]);\n            } else {\n                Integer head = stack.pop();\n                while (stack.size() > 0 && arr[i] < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(head);\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191205570","body":"## 思路\n\t成环再移位\n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n## 代码\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head==null){\n            return head;\n        }\n        ListNode temp = new ListNode(0, head);\n        //链表长度\n        int len = 1;\n        //成环\n        while (head.next != null) {\n            head = head.next;\n            len++;\n        }\n        head.next = temp.next;\n        head = head.next;\n        //后移等于长度- 前移位和长度的余数\n        int number = len - k % len;\n        //移位\n        while (number > 0) {\n            number--;\n            temp = head;\n            head = head.next;\n        }\n        temp.next = null;\n        return head;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192261271","body":"\n## 思路\n\t两两交换位置 \n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n## 代码\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode ans = new ListNode(0, head);\n        ListNode temp = ans;\n        while (head != null && head.next != null) {\n\t\t\t//头指针指向2\n            ans.next = ans.next.next;\n            //1指向3\n\t\t\thead.next= head.next.next;\n            //2指向1\n\t\t\tans.next.next = head;\n            //头指针再后移一位\n\t\t\thead = head.next;\n            //临时指针后移两位\n\t\t\tans= ans.next.next;\n        }\n        return temp.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141648","body":"## 思路\n\t快慢指针 快指针移动两次 慢指针移动一次 快指针移动到尾部的时候慢指针为中位数\n## 复杂度\n\t时间复杂度：O(nlogn)  空间复杂度：O(logn)\n## 代码\n\n```java\n\nclass Solution {\n      public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193285203","body":"## 思路\n\t快慢指针 快指针移动两次 慢指针移动一次  等快指针和慢指针相遇的时候有重合\n## 复杂度\n\t时间复杂度：O(nlogn)  空间复杂度：O(logn)\n## 代码\n\n```java\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode tailA = headA;\n        ListNode tailB = headB;\n        while(tailA!=tailB){\n            tailA = tailA==null?headB:tailA.next;\n            tailB = tailB == null? headA:tailB.next;\n        }\n        return tailA;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193499293","body":"## 思路\n\t快慢指针 存在环的时候使用临时指针从头开始和慢指针一直便利 相遇时为结果 \n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n## 代码\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode temp = null;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                temp = head;\n                break;\n            }\n        }\n        if (temp == null) {\n            return null;\n        }\n        while (temp != slow) {\n            temp = temp.next;\n            slow = slow.next;\n        }\n        return temp;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195189242","body":"\n## 思路\n\t仿LinkedHashMap的思路 map+双链表 \n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n## 代码\n\n```java\n class LRUCache {\n        Map<Integer, DoubleListNode> cache;\n        int max;\n        int len;\n        DoubleListNode head;\n        DoubleListNode tail;\n\n        public LRUCache(int capacity) {\n            cache = new HashMap<>(capacity);\n            max = capacity;\n            head = tail = null;\n            len = 0;\n        }\n\n        public int get(int key) {\n            DoubleListNode ans = cache.get(key);\n            if(ans == null){\n                return -1;\n            }\n            moveToLast(ans);\n            return ans.getValue();\n        }\n\n        public void put(int key, int value) {\n            DoubleListNode doubleListNode = cache.get(key);\n            if (doubleListNode == null) {\n                DoubleListNode temp = new DoubleListNode(key, value);\n                if (max == len) {\n                    DoubleListNode headTemp = head;\n                    if (head == tail) {\n                        head = tail = null;\n                    } else {\n                        head = head.getAfter();\n                        head.setBefore(null);\n                        headTemp.setAfter(null);\n                    }\n                    cache.remove(headTemp.getKey());\n                    len--;\n                }\n                cache.put(key, temp);\n                moveToLast(temp);\n                len++;\n            } else {\n                doubleListNode.setKeyValue(key, value);\n                moveToLast(doubleListNode);\n            }\n        }\n\n        private void moveToLast(DoubleListNode temp) {\n            //分四种情况\n            //新增的 前节点为尾节点 尾节点=这个节点\n            //头节点 下一个节点变为头节点 下一节点置空 前节点为尾节点 尾节点=这个节点\n            //尾节点 不动\n            //中间节点 记录前后节点 调转前后节点的指向 后节点置空 前节点为尾节点 尾节点=这个节点\n            if (temp.getBefore() == null) {\n                if (head == null) {\n                    head = tail = temp;\n                    return ;\n                }\n                if (temp.getAfter() != null) {\n                    //头节点\n                    head = head.getAfter();\n                    head.setBefore(null);\n                    temp.setAfter(null);\n                }\n                tail.setAfter(temp);\n                temp.setBefore(tail);\n                tail = temp;\n            }else {\n                if (temp.getAfter() != null) {\n                    //中间节点\n                    DoubleListNode after = temp.getAfter();\n                    DoubleListNode before = temp.getBefore();\n                    before.setAfter(after);\n                    after.setBefore(before);\n                    temp.setAfter(null);\n                    tail.setAfter(temp);\n                    temp.setBefore(tail);\n                    tail = temp;\n                }\n            }\n        }\n\n        class DoubleListNode {\n            private DoubleListNode before;\n            private Integer key;\n            private Integer value;\n            private DoubleListNode after;\n\n            public DoubleListNode(Integer key, Integer value) {\n                this.key = key;\n                this.value = value;\n                this.before = null;\n                this.after = null;\n            }\n\n            public DoubleListNode(DoubleListNode before, Integer key, Integer value, DoubleListNode after) {\n                this.key = key;\n                this.value = value;\n                this.before = before;\n                this.after = after;\n            }\n\n            public DoubleListNode getBefore() {\n                return before;\n            }\n\n            public DoubleListNode getAfter() {\n                return after;\n            }\n\n            public void setAfter(DoubleListNode after) {\n                this.after = after;\n            }\n\n            public void setBefore(DoubleListNode before) {\n                this.before = before;\n            }\n\n            public Integer getKey() {\n                return key;\n            }\n\n            public Integer getValue() {\n                return value;\n            }\n\n            public void setKeyValue(Integer key, Integer value) {\n                this.key = key;\n                this.value = value;\n            }\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196156669","body":"\n## 思路\n\t递归\n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n## 代码\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null){\n        \treturn 0;\n\t\t}\n        return Math.max(getDeep(root.left,0),getDeep(root.right,0))+1;\n    }\n\n    public int getDeep(TreeNode tree,int deep){\n        if(tree==null){\n            return deep;\n        }\n        return Math.max(getDeep(tree.left,deep),getDeep(tree.right,deep))+1;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185118358","body":"### 思路\r\n按位依次相加\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int>res;\r\n        for(int i=num.size()-1;i>=0 || k>0;i--,k/=10){\r\n            if(i>=0){\r\n                k+=num[i];\r\n            }\r\n            res.push_back(k%10);\r\n        }\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度：o(n)\r\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186071498","body":"### 思路\n两次遍历，找到离得最近的C的距离\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int>res;\n        //从前遍历\n        int index=INT_MAX;\n        for(int i=0;i<s.size();i++){\n            if(s[i]==c){\n                index=i;\n            }\n            res.push_back(abs(i-index));\n        }\n        //从后遍历\n        index=INT_MAX;\n        for(int i=s.size()-1;i>=0;i--){\n            if(s[i]==c){\n                index=i;\n            }\n            res[i]=min(res[i],abs(index-i));\n        }\n        return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度:o(n)\n* 空间复杂度:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186377067","body":"### 代码\n```C++\nclass CustomStack {\nprivate:\n    int cap;//最大容量\n    int top;//目前元素栈顶\n    int* arr;//数组指针\npublic:\n    CustomStack(int maxSize) {\n        cap=maxSize;\n        top=-1;\n        arr=new int[cap];\n    }\n    ~CustomStack() {\n        delete [] arr;\n    }\n    \n    void push(int x) {\n        if(top<cap-1){\n            arr[++top]=x;\n        }\n    }\n    \n    int pop() {\n        if(top==-1)return -1;\n        return arr[top--];\n    }\n    \n    void increment(int k, int val) {\n        int board=min(k,top+1);\n        for(int i=0;i<board;i++){\n            arr[i]+=val;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186710233","body":"### 思路\n用栈匹配括号，分别处理数字，字母和括号\n### 代码\n```C++\nclass Solution {\npublic:\n    string GetDigit(const string& s,size_t& ptr){\n        string ret=\"\";\n        //因为数字不止一位\n        while(isdigit(s[ptr])){\n            ret.push_back(s[ptr++]);//对ptr有改动，因此需要&\n        }\n        return ret;\n    }\n    string GetString(vector<string>& sub){\n        string temp=\"\";\n        for(string& s:sub){\n            temp+=s;\n        }\n        return temp;\n    }\n    string decodeString(string s) {\n        vector<string>myvec;\n        size_t ptr=0;\n        while(ptr<s.size()){\n            char ch=s[ptr];\n            //1、处理数字\n            if(isdigit(ch))myvec.push_back(GetDigit(s,ptr));\n            //2、处理字母\n            else if(isalpha(ch) || ch=='[')myvec.push_back(string(1,s[ptr++]));\n            //3、处理']'\n            else{\n                ++ptr;\n                vector<string>sub;\n                while(myvec.back()!=\"[\"){\n                    sub.push_back(myvec.back());\n                    myvec.pop_back();\n                }\n                myvec.pop_back();\n                reverse(sub.begin(),sub.end());\n                string temp=GetString(sub);\n                int times=stoi(myvec.back());\n                myvec.pop_back();\n                string temp_1;\n                while(times--){\n                    temp_1+=temp;\n                }\n                myvec.push_back(temp_1);\n            }\n        }\n        return GetString(myvec);\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188847635","body":"### 思路\n使用两个栈，来实现队列先进先出\n### 代码\n```C++\nclass MyQueue {\n    //优化，存在重复代码\nprivate:\n    stack<int>instack;\n    stack<int>outstack;\n    void in_out(){\n        if(outstack.empty()){\n            while(!instack.empty()){\n                outstack.push(instack.top());\n                instack.pop();\n            }\n        }\n    }\npublic:\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        instack.push(x);\n    }\n    \n    int pop() {\n        in_out();\n        int temp=outstack.top();\n        outstack.pop();\n        return temp;\n    }\n    \n    int peek() {\n        in_out();\n        return outstack.top();\n    }\n    \n    bool empty() {\n        return instack.empty() && outstack.empty();\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189989210","body":"### 思路\n单调栈，从栈底到栈头从小到大，注意留下的是每个区间的大值\n### 代码\n```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>mystack;\n        //单调栈,栈底到栈头从小到大\n        for(int i=0;i<arr.size();i++){\n            if(!mystack.empty() && arr[i]<arr[mystack.top()]){\n                int temp=mystack.top();\n                while(!mystack.empty() && arr[i]<arr[mystack.top()]){\n                    mystack.pop();\n                }\n                mystack.push(temp);\n            }\n            else{\n                mystack.push(i);\n            }\n        }\n        return mystack.size();\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190975716","body":"### 思路\n将链表相接成环，判断头结点的位置\n### 代码\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head==nullptr)return nullptr;\n        //相接成环\n        ListNode* temp=head;\n        int size=1;\n        while(temp->next!=nullptr){\n            temp=temp->next;\n            size++;\n        }\n        //temp是原来的尾结点\n        temp->next=head;\n        int num=abs(size-k%size);\n        while(num--){\n            head=head->next;\n            temp=temp->next;\n        }\n        temp->next=nullptr;\n        return head;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192116529","body":"### 思路\n迭代，交换两个节点，\n### 代码\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        //迭代法\n        if(head==nullptr || head->next==nullptr)return head;\n        //最前面接一个空节点，方便处理\n        ListNode* virhead=new ListNode(0);\n        virhead->next=head;\n        ListNode* cur=virhead;\n        while(cur->next!=nullptr && cur->next->next!=nullptr){\n            ListNode* temp1=cur->next;\n            ListNode* temp2=cur->next->next;\n            cur->next=temp2;\n            temp1->next=temp2->next;\n            temp2->next=temp1;\n            cur=cur->next->next;\n        }\n        return virhead->next;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O(n)\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193076346","body":"### 思路\n快慢指针找中间节点，递归建树\n### 代码\n```C++\nclass Solution {\npublic:\n    //寻找中间节点\n    ListNode* findMid(ListNode* left,ListNode* right){\n        ListNode* slow=left,*fast=left;\n        while(fast!=right && fast->next!=right){\n            slow=slow->next;\n            fast=fast->next->next;\n        }\n        return slow;\n    }\n    //递归建树\n    TreeNode* makeTree(ListNode* left,ListNode* right){\n        if(left==right)return nullptr;//递归结束条件\n        ListNode* mid=findMid(left,right);\n        TreeNode* root=new TreeNode(mid->val);\n        root->left=makeTree(left,mid);//此处就体现出左闭右开的必要性，因为链表不能前指\n        root->right=makeTree(mid->next,right);\n        return root;\n    }\n    TreeNode* sortedListToBST(ListNode* head){\n        return makeTree(head,nullptr);\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(nlogn)\n* 空间复杂度：o(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193244098","body":"### 思路\n让两个指针走相同的长度m+n,如果链表相交就会相遇\n### 代码\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if(headB==nullptr || headA==nullptr)return nullptr;\n        ListNode* tmpA=headA,*tmpB=headB;\n        while(tmpA!=tmpB){\n            tmpA=tmpA==nullptr?headB:tmpA->next;\n            tmpB=tmpB==nullptr?headA:tmpB->next;\n        }\n        return tmpA;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O(m+n)\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193718752","body":"### 思路\n快慢指针，从相遇点开始，分别从头结点与相遇点开始的指针会相遇与环形入口处\n### 代码\n```C++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        //快慢指针\n        if(head==nullptr ||head->next==nullptr)return nullptr;\n        ListNode* fast=head,*slow=head;\n        while(fast!=nullptr && fast->next!=nullptr){\n            slow=slow->next;\n            fast=fast->next->next;\n            if(slow==fast){//相遇点\n                ListNode* tmp0=head;\n                ListNode* tmp1=slow;\n                while(tmp0!=tmp1){\n                    tmp1=tmp1->next;\n                    tmp0=tmp0->next;\n                }\n                return tmp0;\n            }\n        }\n        return nullptr;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195441624","body":"### 思路\n用哈希表+双向链表，记得及时更新哈希表\n### 代码\n```C++\nstruct Node{\n    Node* prev;\n    Node* next;\n    int key,val;\n    Node():prev(nullptr),next(nullptr),key(0),val(0){};\n    Node(int key,int val):prev(nullptr),next(nullptr),key(key),val(val){};\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int,Node*>mymap;\n    Node* virHead;\n    Node* virTail;\n    int size;//实际元素数量\n    int cap;//最大容量\n\n    void removeNode(Node* tmp){\n        tmp->prev->next=tmp->next;\n        tmp->next->prev=tmp->prev;\n        size--;\n    }\n    void movetoHead(Node* tmp){\n        tmp->prev=virHead;\n        tmp->next=virHead->next;\n        virHead->next->prev=tmp;\n        virHead->next=tmp;\n        size++;\n    }\n    void removeTail(){\n         Node* tmp=virTail->prev;\n         tmp->prev->next=virTail;\n         virTail->prev=tmp->prev;\n         mymap.erase(tmp->key);//哈希表中移除\n         delete tmp;\n         size--;\n    }\npublic:\n    LRUCache(int capacity):size(0),cap(capacity),mymap() {\n        virHead=new Node();\n        virTail=new Node();\n        virHead->next=virTail;\n        virTail->prev=virHead;\n    }\n    \n    int get(int key) {\n        if(mymap.find(key)!=mymap.end()){\n            Node* tmp=mymap[key];\n            //将其节点移动到双向链表头部\n            //1、删除当前节点\n            removeNode(tmp);\n            //2、在头部添加tmp\n            movetoHead(tmp);\n            //3、返回值\n            return tmp->val;\n        }\n        return -1;\n    }\n    \n    void put(int key, int value) {\n        if(mymap.find(key)!=mymap.end()){\n            Node* tmp=mymap[key];\n            tmp->val=value;\n            removeNode(tmp);\n            movetoHead(tmp);\n        }\n        else{\n            if(size==cap){//删除尾部节点\n                removeTail();\n            }\n            //插入新节点到尾部\n            Node* tmp=new Node(key,value);\n            mymap[key]=tmp;//添加新的哈希表\n            movetoHead(tmp);\n        }\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(1)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196213148","body":"### 思路\n层序遍历，用队列遍历\n### 代码\n```C++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root==nullptr)return 0;\n        //层序遍历,用队列遍历\n        int count=0;\n        queue<TreeNode*>myque;\n        myque.push(root);\n        while(!myque.empty()){\n            int size=myque.size();\n            count++;\n            while(size--){\n                TreeNode* tmp=myque.front();\n                myque.pop();\n                if(tmp->left)myque.push(tmp->left);\n                if(tmp->right)myque.push(tmp->right);\n            }\n        }\n        return count;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185118412","body":"### Idea\n\nInput: an int in array form **num**, an int **k** to add\nOutput: result in array form\n\n1. array to int, add k, int to array\n   ~~2. int k to array, add array~~\n\n### Code\n\n```python\n    def addToArrayForm(self, num, k):\n        # array to int\n        int_res = int(''.join(str(n) for n in num))\n        int_res+=k\n        # int to array\n        res = [int(n) for n in str(int_res)]\n        return res\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)+O(n) = O(n)\n- Space Complexity: O(1)+O(n) = O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186139244","body":"### Idea\n- 1st loop: find all indices of *c*\n- 2nd loop: get abs min for all elements in *s*\n### Code\n```python\ndef shortestToChar(self, s, c):\n        index = []\n        res = [0]*len(s)\n        for i in range(len(s)):\n            if s[i] == c:\n                index.append(i)\n        for i in range(len(s)):\n            if i in index:\n                res[i]=0\n            else:\n                res[i] = min([abs(i-x) for x in index])\n        return res\n```\n\n**Complexity Analysis**\n- Time Complexity: O(n^2)\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186342266","body":"### Idea\n- array with 2 pointers\n- 1 pointer for stack top, help to judge if exceed max size\n- 1 pointer for stack base & increment function, help to judge if empty\n- check max & update base when push/pop\n- increment: compare k with current top index -> decide the number of element to update\n\n### Code\n\n```python\ndef __init__(self, maxSize):\n        self.stack = [0]*maxSize\n        self.max = maxSize-1 # max index\n        self.base = -1\n        self.top = -1\n\n    def push(self, x):\n        if self.top<self.max:\n            if(self.top<0):\n                self.base+=1\n            self.top+=1\n            self.stack[self.top]=x\n        \n    def pop(self):\n        if self.top>=0 :\n            res = self.stack[self.top]\n            self.stack[self.top] = 0\n            self.top-=1\n            if(self.top<0):\n                self.base-=1\n            return res\n        else:\n            return -1\n        \n    def increment(self, k, val):\n        if(self.base>=0):\n            if (self.top+1)>=k:\n                for i in range(k):\n                    self.stack[i]+=val\n            else:\n                for e in range(self.top+1):\n                    self.stack[e]+=val\n\n```\n\n**Complexity Analysis**\n- Time Complexity: \n  - push: O(1)\n  - pop:O(1)\n  - increment: O(n)\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186642403","body":"### Idea\n1. Traverse *s*\n   1. push number to stack *num*\n   2. push [ & characters to stack *char*, until meet ]\n   3. when meet ], pop stack *char* & add characters together until meet [\n   4. pop the stack *num*,  decode characters, push result back to stack *char*\n2. return stack *char* content\n### Code\n\n```python\ndef decodeString(self, s):\n        num = []\n        char = []\n        i = 0\n        while i < len(s):\n            if s[i].isdigit():\n                n = \"\"\n                while(s[i].isdigit()):\n                    n+=s[i]\n                    i+=1\n                num.append(int(n))\n            elif s[i] == ']':\n                tmp = \"\"\n                while char[-1]!='[':\n                    tmp = char.pop()+tmp\n                char.pop()\n                tmp = tmp*num.pop()\n                char.append(tmp)\n                i+=1\n            else:\n                char.append(s[i])\n                i+=1\n        res = \"\"\n        while len(char)>0:\n            res = char.pop()+res\n        return res\n```\n\n**Complexity Analysis**\n\n- Time Complexity:O(n)+O(n)+O(n)=O(n)\n- Space Complexity:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188466203","body":"### Idea\n\n- push: push to stack1\n- pop: pop from stack2\n  - if stack2 is empty, move stack1 content to stack2 first\n- peek: return the first element of stack2\n  - if stack2 is empty, move stack1 content to stack2 first\n- empty: return if stack1 and stack2 all empty\n- check empty before pop, peek\n\n### Code\n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1=[]\n        self.stack2=[]\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.empty():\n            if len(self.stack2)==0:\n                while len(self.stack1)>0:\n                    self.stack2.append(self.stack1[-1])\n                    self.stack1.pop(-1)\n            return self.stack2.pop()\n        else: return None\n\n    def peek(self):\n        if not self.empty():\n            if len(self.stack2)==0:\n                while len(self.stack1)>0:\n                    self.stack2.append(self.stack1[-1])\n                    self.stack1.pop(-1)\n            return self.stack2[-1]\n        else: return None\n\n    def empty(self):\n        return len(self.stack1)+len(self.stack2) == 0\n```\n\n**Complexity Analysis**\n\n- Time Complexity:\n  - push: O(1)\n  - pop: O(n)\n  - peek: O(n)\n  - empty: O(1)\n- Space Complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189956971","body":"### Idea\n1. check if the left subarray is smaller than the right subarray, if smaller, get a new chunck\n2. Traversal, get the max of left subarray and the min of right subarray, compare\n\n### Code\n\n```python\ndef maxChunksToSorted(self, arr):\n\n    length = len(arr)\n    left = [0]*length\n    right = [0]*length\n    \n    for i in range(len(arr)):\n        if i == 0:\n            left[i]=arr[i]\n        else:\n            left[i]=max(left[i-1],arr[i])\n    \n    for i in reversed(range(len(arr))):\n        if i == length-1:\n            right[i]=arr[i]\n        else:\n            right[i]=min(right[i+1],arr[i])\n    res = 0\n    for i in range(len(arr)-1):\n        if left[i]<=right[i+1]:\n            res+=1\n    return res+1\n```\n\n**Complexity Analysis**\n\n- Time Complexity:O(n)+O(n)+O(n)=O(n)\n- Space Complexity:O(n)+O(n)=O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190940014","body":"### Idea\n- find the length of list, k%length to find the rotation needed\n- need to switch two sublists, list splits at length-k\n- one pointer for the end of right sublist\n- one pointer for the end of left sublist\n\n### Code\n\n```python\ndef rotateRight(self, head, k):\n    if k==0:\n        return head\n    if head==None or head.next==None:\n        return head\n    \n    length = 0\n    p1 = head\n    while p1 != None:\n        length+=1\n        p1 = p1.next\n        \n    rotate = k%length\n    \n    p1 = head\n    while rotate>0:\n        p1 = p1.next\n        rotate-=1\n    p2 = head\n    while p1.next!=None:\n        p1=p1.next\n        p2=p2.next\n    p1.next = head\n    head = p2.next\n    p2.next = None\n    return head\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)+O(n)=O(n)\n- Space Complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192012753","body":"### Idea\n\n- need a pre head/pre pointer before the first node for node swap\n- need a pointer to mark the first node in the pair\n- need a temp pointer (always .next of the first node) for the second node in the pair to do node swap\n\n### Code\n\n```python\n        if(head == None or head.next == None):\n            return head\n\n        pre = ListNode(0)\n        pre.next = head\n\n        p0 = pre\n        p1 = head\n        while(p1!=None and p1.next!=None):\n            p2 = p1.next\n            p0.next = p2\n            p1.next = p2.next\n            p2.next = p1\n            p0=p0.next.next\n            p1=p1.next\n        return pre.next\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193092616","body":"### Idea\n1. linked list -> array -> tree\n2. root of the tree/subtree is at middle of the array/subarray\n3. left/right subtree is build from left/right subarray\n\n\n### Code\n\n```python\n    def sortedListToBST(self, head):\n        arr = []\n        while head:\n            arr.append(head.val)\n            head = head.next\n        return self.buildTree(arr)\n    \n    def buildTree(self, arr):\n        if len(arr)==0:\n            return None\n        mid = len(arr)//2\n        root = TreeNode(arr[mid])\n        root.left = self.buildTree(arr[:mid])\n        root.right = self.buildTree(arr[mid+1:])\n        return root\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193250054","body":"### Idea\nTwo pointers traverse list A&B, stop when two pointers point to the same. When a pointer points to none, update pointer to point the head of another list. \nThe pointers will meet at the intersectin node or both are None (no intersaction). \n   \n### Code\n\n```python\n    def getIntersectionNode(self, headA, headB):\n        head1 = headA\n        head2 = headB\n        while head1 != head2:\n            head1 = head1.next if head1 else headB\n            head2 = head2.next if head2 else headA\n        return head1\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(2(n1+n2+n3))\n- Space Complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193666754","body":"### Idea\n- Fast and slow pointer will meet if there is a loop. \n- If pointer points to None, there is no cycle. \n- After fast pointer and slow pointer meet, update fast pointer point to head. \n- Move fast and slow pointer one node at a time until they meet at the cycle entry. \n\n### Code\n\n```python\ndef detectCycle(self, head):\n        fast = head\n        slow = head\n        while fast != None and fast.next!=None:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n        if fast==None or fast.next==None:\n            return None\n        fast = head\n        while fast!=slow:\n            fast=fast.next\n            slow=slow.next\n        return fast\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195357139","body":"### Idea\n1. a dictionary to track the key and its node\n2. a linked list to manage LRU cache\n### Code\n\n```python\nclass ListNode(object):\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.next = None\n        self.pre = None\n    \nclass LRUCache(object):\n\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.size = 0\n        self.addr = {}\n        self.head = ListNode(-1,-1)\n        self.tail = ListNode(-1,-1)\n        self.head.next = self.tail\n        self.tail.pre = self.head\n\n    def get(self, key):\n        if key in self.addr:\n            node = self.addr[key]\n            self.remove(node)\n            self.add(node)\n            return node.val\n        else:\n            return -1\n\n    def put(self, key, value):\n        if key in self.addr:\n            node = self.addr[key]\n            node.val = value\n            self.remove(node)\n            self.add(node)\n        else:\n            node = ListNode(key,value)\n            self.addr[key] = node\n            self.add(node)\n            if(self.size<self.capacity):\n                self.size+=1\n            else:\n                tailKey = self.removeTail()\n                del self.addr[tailKey]\n\n    def remove(self, node):\n        pre = node.pre\n        nex = node.next\n        pre.next = nex\n        nex.pre = pre\n    \n    def add(self, node):\n        node.pre = self.head\n        node.next = self.head.next\n        self.head.next.pre = node\n        self.head.next = node\n        \n    def removeTail(self):\n        node = self.tail.pre\n        self.remove(node)\n        return node.key\n\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(1) for get, put\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196324242","body":"### Idea\nFind the max between left child tree maxDepth and right child tree maxDepth, +1 to get the current node's maxDepth. \n\n### Code\n\n```python\n    def maxDepth(self, root):\n        if root == None:\n            return 0\n        res = 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))\n        return res\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185123309","body":"# 思路\n\n将num与k末位相加，加到k上，k中自动进位，只需将k取余放入数组中即可\n\n# 代码\n\n\n```js\nvar addToArrayForm = function(num, k) {\n    let res = []\n    let len = num.length - 1\n    while(len >= 0 || k > 0) {\n        if(len >= 0) {\n            k += num[len]\n            len--\n        }\n        res.push(k % 10)\n        k = parseInt(k / 10)\n    }\n    return res.reverse()\n};\n```\n\n# 复杂度\n\n时间：O(n)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186075915","body":"# 思路\n\n从S[i]位置开始，分别向左和向右进行搜索，取最小距离存到数组中\n\n# 代码\n\n```js\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length).fill(0);\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    let l = i,r = i,min = Infinity;\n    while (l >= 0) {\n      if (S[l] === C) {\n        min = Math.min(min, i - l);\n        break;\n      }\n      l--;\n    }\n    while (r < S.length) {\n      if (S[r] === C) {\n        min = Math.min(min, r - i);\n        break;\n      }\n      r++;\n    }\n    res[i] = min;\n  }\n  return res;\n};\n```\n\n# 复杂度\n\n时间：O(n)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186353755","body":"# 思路\n\n设置最大容量，维护一个stack\n\n# 代码\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack =[]\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length >= this.maxSize) {\n        return\n    }\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.length ? this.stack.pop() : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let len = Math.min(k,this.stack.length)\n    for(let i = 0;i < len;i++) {\n        this.stack[i] += val\n    }\n};\n```\n\n# 复杂度\n\n时间:O(n)\n\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187084895","body":"# 思路\n\n遇到 [ 数字字母分别入栈，遇到 ] 栈顶元素出栈\n\n# 代码\n\n```js\nconst decodeString = (s) => {\n    let numStack = [];        \n    let strStack = [];       \n    let num = 0;              \n    let result = '';          \n    for (const char of s) {   \n        if (!isNaN(char)) {  \n            num = num * 10 + Number(char); \n        } else if (char == '[') {  \n            strStack.push(result); \n            result = '';           \n            numStack.push(num);   \n            num = 0;              \n        } else if (char == ']') {  \n            let repeatTimes = numStack.pop(); \n            result = strStack.pop() + result.repeat(repeatTimes); \n        } else {                   \n            result += char;       \n        }\n    }\n    return result;\n};\n\n```\n\n# 复杂度\n\n时间:O(n)\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188499267","body":"# 思路\n\n双栈模拟\n\n# 代码\n\n```js\nvar MyQueue = function() {\n    this.stackIn = []\n    this.stackOut = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stackIn.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    const size = this.stackOut.length\n    if(size) {\n        return this.stackOut.pop()\n    }\n    while(this.stackIn.length) {\n        this.stackOut.push(this.stackIn.pop())\n    }\n    return this.stackOut.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    const x = this.pop();\n    this.stackOut.push(x);\n    return x;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n     return !this.stackIn.length && !this.stackOut.length\n};\n```\n\n# 复杂度\n\n时间：O(1)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189726069","body":"# 思路\n\n使用滑动窗口，因为原数组与分块后块的位置相同，可以通过加法求和进行分块\n\n# 代码\n\n```js\nvar maxChunksToSorted = function(arr) {\n    const sortArr = [...arr];\n    sortArr.sort((a, b) => a - b);\n    let count = 0,sum1 = 0,sum2 = 0;\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sortArr[i];\n        if (sum1 === sum2) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n# 复杂度\n\n时间复杂度:O(nlogn)\n\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191528462","body":"# 思路\n\n把链表首尾相接成环后，从头开始往下遍历len - k % len次，切断 len - k -1个结点到len - k节点的连接，返回节点len - k即可。\n\n# 代码\n\n```js\nvar rotateRight = function (head, k) {\n    if (!head || k === 0) return head; \n    let p = head, len = 1;\n    while (p.next) {\n        p = p.next;\n        len++;\n    }\n    p.next = head; \n    k = len - k % len; \n    while (k--) p = p.next;\n    head = p.next;  \n    p.next = null; \n    return head;\n};\n```\n\n# 复杂度\n\n时间:O(n)\n\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192541477","body":"# 思路\n\n定义虚头节点，进行交换\n\n# 代码\n\n```js\nvar swapPairs = function(head) {\n    let ret = new ListNode(0,head) \n    let temp = ret\n    while(temp.next && temp.next.next) {\n        let pre = temp.next\n        let cur = pre.next\n        pre.next = cur.next\n        cur.next = pre\n        temp.next = cur\n        temp = pre\n    }\n    return ret.next\n};\n```\n\n# 复杂度\n\n时间:O(1)\n\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193114398","body":"# 思路\n\n中序遍历\n\n# 代码\n\n```js\nvar sortedListToBST = function(head) {\n    if (head === null) return null;\n    return help([head], 0, countSize(head)-1);\n};\n\nfunction countSize(head) {\n    let count = 0;\n    while (head !== null) {\n        count++;\n        head = head.next;\n    }\n    return count;\n}\n\nfunction help(arr, left, right) {\n    if (left > right) return null;\n    let mid = Math.floor((left + right) / 2);\n    let leftNode = help(arr, left, mid-1);\n    let node = new TreeNode(arr[0].val);\n    arr[0] = arr[0].next;\n    let rightNode = help(arr, mid+1, right);\n    node.left = leftNode;\n    node.right = rightNode;\n    return node;\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193324451","body":"# 思路\n\n使用哈希集合存储链表节点\n\n# 代码\n\n```js\nvar getIntersectionNode = function(headA, headB) {\n    const visited = new Set();\n    let temp = headA;\n    while (temp !== null) {\n        visited.add(temp);\n        temp = temp.next;\n    }\n    temp = headB;\n    while (temp !== null) {\n        if (visited.has(temp)) {\n            return temp;\n        }\n        temp = temp.next;\n    }\n    return null;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194008638","body":"# 思路\n\n遍历链表，将节点加入一个set中，每次判断当前节点是否在set中，如果存在重复的节点，这个节点就是入环节点\n\n# 代码\n\n```js\nvar detectCycle = function(head) {\n    const visited = new Set();\n    while (head !== null) {\n        if (visited.has(head)) {\n            return head;\n        }\n        visited.add(head);\n        head = head.next;\n    }\n    return null;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196833319","body":"# 思路\n\n递归\n\n# 代码\n\n```js\nvar maxDepth = function(root) {\n    if (root === null) return 0;\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185132808","body":"### 思路\n一开始没考虑到大数的运算会丢失精度, 还说题目简单;\n参考的题解用了通用的方法\n### 代码 TS\n```ts\n// 一开始没有考虑到大数计算的进度丢失情况, 使用了下面的写法\n// function addToArrayForm(num: number[], k: number): number[] {\n//     const sum: number = Number(num.join('')) + k;\n\n//     return (sum + '').split('').map(item => Number(item));\n// };\n\nvar addToArrayForm = function (num: number[], k: number): number[] {\n    const res = [];\n    const n = num.length;\n\n    // 从低位加到高位, 所以采用从大到小的顺序循环\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n\n        // 需要进位的情况, 将进位加在K上, 便于下一次循环\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    // 考虑nums比较小, K比较大的情况, 循环结束后, K还有值, 例如:111+88888, 需要将他补充回数组\n    while (k > 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10)\n    }\n    // 不采用反转的话, 每次都需要在数组最前面插值(shift), 时间复杂度高\n    return res.reverse();\n};\n```\n### 复杂度\n时间 O(n)\n空间 O(1) ? 不太确定, 没太搞懂空间复杂度的分析, 求大佬解答","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186154745","body":"## 思路\n先存下所有的c在原数组中的位置; 然后遍历的时候, 对比距离取得最小值\n## 代码 TS\n```ts\nfunction shortestToChar(s: string, c: string): number[] {\n    // 存储匹配字符'c'在原数组中的索引\n    const indexArr: number[] = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            indexArr.push(i);\n        }\n    }\n\n    const res = [];\n\n    // 计算s的每一项索引, 与indexArr绝对值, 然后取最小的\n    for (let index = 0; index < s.length; index++) {\n        if (s[index] === c) {\n            res[index] = 0;\n        } else {\n            const indexDistanceArr: number[] = indexArr.map(item => Math.abs(item - index));\n            res[index] = Math.min(...indexDistanceArr);\n        }\n    }\n\n    return res\n};\n```\n## 复杂度\n时间: O(n2)\n空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186467029","body":"## 思路\n利用数组实现, 难度简单\n## 代码 TS\n```ts\nclass CustomStack {\n    maxSize: number;\n    stack: number[];\n\n    constructor(maxSize: number) {\n        this.maxSize = maxSize;\n        this.stack = [];\n    }\n\n    push(x: number): void {\n        const length = this.stack.length;\n        if (length < this.maxSize) {\n            this.stack.push(x);\n        }\n    }\n\n    pop(): number {\n        const length = this.stack.length;\n        if (length === 0) return -1;\n        return this.stack.pop()\n    }\n\n    increment(k: number, val: number): void {\n        const length = this.stack.length;\n        for (let i = 0; i < Math.min(length, k); i++) {\n            this.stack[i] += val\n        }\n\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n## 复杂度\n时间: O(n)(确切地说: Math.min(N, K)) 空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186563811","body":"## 思路\n\n实在没做出来, 思路太混乱了, 参考大佬的[题解](https://leetcode.cn/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/), 翻译了一个 `TS` 的版本\n\n## 代码 TS\n```ts\nfunction decodeString(s: string): string {\n    let stack = [], str = '', multi = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '[') {\n            stack.push([multi, str]);\n            str = '';\n            multi = 0;\n        } else if (s[i] === ']') {\n            let [currentMulti, lastStr] = stack.pop();\n            str = lastStr + str.repeat(currentMulti);\n        } else if ('0' <= s[i] && s[i] <= '9') {\n            multi = multi * 10 + Number(s[i]);\n        } else {\n            str += s[i]\n        }\n    }\n    return str;\n};\n```\n## 复杂度\n时间:O(n) 空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188630937","body":"## 思路\n这个题目简单, 但是需要注意只能使用指定类型的API\n## 代码 TS\n```ts\nclass MyQueue {\n    stack: number[] = [];\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.stack.push(x)\n    }\n\n    pop(): number {\n        let tempArray = [];\n        const removedItem = this.stack[0];\n        for (let i = 1; i < this.stack.length; i++) {\n            tempArray.push(this.stack[i])\n        }\n        this.stack = tempArray\n        return removedItem\n    }\n\n    peek(): number {\n        return this.stack[0];\n    }\n\n    empty(): boolean {\n        return !this.stack.length;\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n## 复杂度\n时间: O(n) 空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190446229","body":"## 思路\n没做出来, 参考了题解\n##  代码 PY3\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.defaultdict(int)\n        ans = nonzero = 0\n\n        for x, y in zip(arr, sorted(arr))\n            count[x] += 1\n            if count[x] == 0: nonzero -= 1\n            if count[x] == 1: nonzero += 1\n\n            count[y] -= 1\n            if count[y] == -1: nonzero += 1\n            if count[y] == 0: nonzero -= 1\n\n            if nonzero == 0: ans += 1\n\n        return ans\n\n```\n## 复杂度\n时间: O(NlogN)\n空间: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191622404","body":"## 思路\n链表成环, 移动位置: 向右移动K, 等于将倒数第K个放在第一位\n## 代码 TS\n```ts\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    // 链表为空,或链表的长度为1, 或移动的位置数值为0, 返回原链表\n    if (head === null || head.next === null || k === 0) return head;\n    // 统计链表的长度\n    let length = 1;\n    let currentHead = head;\n    while (currentHead.next !== null) {\n        length += 1;\n        currentHead = currentHead.next;\n    }\n    // 如果移动位置K的数值是链表的长度整数倍, 则移动前后不变\n    if (k % length === 0) return head;\n    // 将链表成环, 最后一项的 next 指向第一项\n    // 注意: currentHead在上面的while循环结束后, 指向链表的最后一项\n    currentHead.next = head;\n    // 根据规则, 在合适的地方, 将链表断开\n    let add = length - k % length;\n    while (add) {\n        currentHead = currentHead.next;\n        add--;\n        console.log('currentHead:', currentHead)\n    }\n\n    const result = currentHead.next;\n    currentHead.next = null;\n    return result;\n};\n```\n## 复杂度\n时间 O(n) 空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192698519","body":"## 思路\n递归\n## 代码 JS \n```js\nvar swapPairs = function(head) {\n    if (head === null|| head.next === null) {\n        return head;\n    }\n    const newHead = head.next;\n    head.next = swapPairs(newHead.next);\n    newHead.next = head;\n    return newHead;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141166","body":"```ts\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     val: number\r\n *     next: ListNode | null\r\n *     constructor(val?: number, next?: ListNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.next = (next===undefined ? null : next)\r\n *     }\r\n * }\r\n */\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * class TreeNode {\r\n *     val: number\r\n *     left: TreeNode | null\r\n *     right: TreeNode | null\r\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.left = (left===undefined ? null : left)\r\n *         this.right = (right===undefined ? null : right)\r\n *     }\r\n * }\r\n */\r\n\r\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\r\n\r\n    const arr = [];\r\n    while (head) { // 将链表节点的值逐个推入数组arr\r\n        arr.push(head.val);\r\n        head = head.next;\r\n    }\r\n    // 根据索引start到end的子数组构建子树\r\n    const buildBST = (start, end) => {\r\n        if (start > end) return null;        // 指针交错，形成不了子序列，返回null节点\r\n        const mid = Math.floor((start + end) / 2);     // 求中间索引 中间元素是根节点的值, 这里可以查考偶数使用左边或右边\r\n        const root = new TreeNode(arr[mid]); // 创建根节点\r\n        root.left = buildBST(start, mid - 1); // 递归构建左子树\r\n        root.right = buildBST(mid + 1, end);  // 递归构建右子树\r\n        return root;                          // 返回当前子树\r\n    };\r\n\r\n    return buildBST(0, arr.length - 1);  // 根据整个arr数组构建\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193326133","body":"## 思路\n用数组存储,然后再找有没有肯定可以解决,不过我看都在说双指针\n假设链表A走x步,链表B走y步, 在A走到末尾的时候, 我们将他指向B, 就相当于一个环, 一个顺时针,一个逆时针, 最终都会相遇\n## 代码 TS\n```ts\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n    if (headA === null || headB === null) {\n        return null;\n    }\n    let currentHeadA = headA;\n    let currentHeadB = headB;\n    while (currentHeadA !== currentHeadB) {\n        currentHeadA = currentHeadA === null ? headB : currentHeadA.next;\n        currentHeadB = currentHeadB === null ? headA : currentHeadB.next;\n    }\n    return currentHeadA;\n};\n```\n## 复杂度\n时间O(m+n) 空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194170654","body":"## 思路\n借用Set 存储走过的节点\n## 代码 TS\n```ts\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction detectCycle(head: ListNode | null): ListNode | null {\n    if (head === null || head.next === null) {\n        return null;\n    }\n    let list = new Set();\n\n    let current = head;\n    while (!list.has(current) && current !== null) {\n        list.add(current);\n        current = current.next;\n    }\n\n    return current;\n};\n```\n## 复杂度\n时间: O(n) 空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195648461","body":"## 代码\n```ts\nclass LRUCache {\n  capacity: number\n  map: Map<number, number> = new Map()\n\n  constructor(capacity: number) {\n    this.map = new Map()\n    this.capacity = capacity\n  }\n\n  get(key: number): number {\n    if (this.map.has(key)) {\n      let value = this.map.get(key)\n      this.map.delete(key)\n      this.map.set(key, value)\n      return value\n    } \n    return -1\n  }\n\n  put(key: number, value: number): void {\n    if (this.map.has(key)) {\n      this.map.delete(key)\n    }\n\n    this.map.set(key, value)\n\n\n    if (this.map.size > this.capacity) {\n      this.map.delete(this.map.keys().next().value)\n    }\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196176492","body":"## 思路\n递归左右子树, 然后取最大值\n## 代码 TS\n```ts\nfunction maxDepth(root: TreeNode | null): number {\n    if (root === null) return 0;\n\n    const leftDepth = maxDepth(root.left);\n    const rightDepth = maxDepth(root.right);\n\n    return Math.max(leftDepth, rightDepth) + 1\n};\n```\n## 复杂度\n时间: O(n) 空间O(h) n为节点树 h为树的高度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185136875","body":"### 思路\r\n\r\n暴力解法：字符串转换，然后用 BigInt 转换保证大数精度不丢失\r\n### 代码\r\n\r\n\r\n```typescript（此处换成你的语言，比如js，py 等）\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  return (BigInt(num.join(\"\")) + BigInt(k)).toString().split(\"\").map(item => Number(item))\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，类型转换部分时间复杂度不会算，余下部分应该是 O(2*n)也就是 O(n)\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188549571","body":"### 思路\nJS 实现栈没什么好说的，这里用两个栈的方式实现队列，像是两杯水倒来倒去\n### 代码\n\n```typescript\nclass MyQueue {\n    private stack1: number[] = []\n    private stack2: number[] = []\n\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.stack1.push(x)\n    }\n\n    pop(): number {\n        if(!this.stack1.length) return\n\n        while(this.stack1.length) {\n            const stackValue = this.stack1.pop();\n            this.stack2.push(stackValue)\n        }\n\n        const popValue = this.stack2.pop();\n\n        while(this.stack2.length) {\n            const stackValue = this.stack2.pop();\n            this.stack1.push(stackValue)\n        }\n\n        return popValue\n    }\n\n    peek(): number {\n        return this.stack1[0]\n    }\n\n    empty(): boolean {\n        return this.stack1.length === 0\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185137931","body":"### 思路\n将num[n-1]相加赋值于k，对其结果求余，作为该位的值，k / 10 的结果再和num[n-2]相加，对其结果求余，作为该位的值，以此类推\n\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> vec;\n        int len = num.size();\n        for(int i = len - 1; 0 <= i || k >= 1; i--, k /= 10){\n            if( i >= 0){\n                k += num[i];\n            }\n            vec.push_back(k % 10);\n        }\n        reverse(vec.begin(), vec.end());\n        return vec;\n    }\n};\n```\n### 复杂度分析\n时间：O(max(n,logk) <n为输入数组长度 >\n空间：O(1) 除返回值外，所用空间为常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186083081","body":"### 思路\n打算遍历string的每个字符，再从每个被指向的字符派出两个指针分别从左右同时遍历至string的边界，若元素与c相等，则将计算相对位置差来赋值。\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> answer(n,-1);\n        for(int i = 0 ; i < n; ++i){\n                if(s[r] == c){\n                    answer[i] = i - l;\n                    break;\n                }\n            }\n            for(int r = i; r < n; ++r){\n                if(s[r] == c && answer[i] != -1){\n                    answer[i] = min(answer[i], r - i);\n                    break;\n                }\n                else if(s[r] == c){\n                    answer[i] = r - i;\n                    break;\n                }\n            }\n        }\n        return answer;\n    }\n};\n```\n### 复杂度分析\n时间：O(n^2)\n空间：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186395331","body":"## 思路\r\npush和pop操作只是基于数组的限制操作，\r\nincrement操作为了和其他操作一样消耗常数时间，额外维护一个数组储存每一位的增量，在元素被pop出时再添加上\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass CustomStack {\r\npublic:\r\n    vector<int> vec, add;\r\n    int top = -1;\r\n    CustomStack(int maxSize) {\r\n        vec.resize(maxSize);\r\n        add.resize(maxSize);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top != vec.size() - 1){\r\n            top++;\r\n            vec[top] = x;\r\n        }\r\n    } \r\n    \r\n    int pop() {\r\n        if(top == -1)\r\n            return -1;\r\n        int ret = vec[top] + add[top];\r\n        if(top != 0){\r\n            add[top - 1] += add[top];\r\n        } \r\n        add[top] = 0; \r\n        top--;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim = min(k - 1 , top);\r\n        if(lim >= 0)\r\n            add[lim] += val;\r\n        } \r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n## 复杂度分析\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186731145","body":"## 思路\n使用递归，遇到数字，记录至multi，遇到字母，将其加入本层的字符串中，遇到\"[\"进入新的一层递归，并将下一层返回的字符串重复multi次加至本层的字符串中，遇到“]”返回本层字符串\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int i = 0;\n        return dfs(s, i);\n    }\n\n    string dfs(string &s, int &i){\n        int multi = 0;\n        string res = \"\";\n        for(; i < s.size(); ++i){\n            if('0' <= s[i] && s[i] <= '9')\n                multi = multi * 10 + (s[i] - '0');\n            else if(s[i] == '['){\n                string temp = dfs(s ,++i);\n                while(multi != 0){\n                    res += temp;\n                    --multi;\n                }\n            }\n            else if(s[i] == ']')\n                return res;\n            else\n                res += s[i];\n        }\n        return res;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$ 在递归的过程中索引是更新的，一次遍历\n- 空间复杂度：$O(n)$ 最坏情况下（如：3[3[3[a]]]）递归次数为(n-4)/3，需要线性空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188595534","body":"## 思路\n 区分了输入和输出栈，只有在输出栈为空时，才从输入栈中取元素压入，如此一来每一个元素最多被分别被压入压出2次\n\n## 代码\n```c++\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stk1.push(x);\n    }\n    \n    int pop() {\n        int ret = 0;\n        if(stk2.empty())\n            in2out();\n        ret = stk2.top();\n        stk2.pop();\n        return ret;\n    }\n\n    \n    int peek() {\n        if( stk2.empty()){\n            in2out();\n        }\n        return stk2.top();\n    }\n    \n    bool empty() {\n        return stk1.empty() && stk2.empty();\n    }\nprivate:\n    stack<int> stk1;\n    stack<int> stk2;\n\n    void in2out(){\n        while(!stk1.empty()){\n            stk2.push(stk1.top());\n            stk1.pop();\n        }\n    }\n\n\n\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n## 复杂度分析\nn为栈长度\n空间:O(n)\n时间:每一操作都是O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189824934","body":"## 思路\n建立一个栈来存储每一块中的最大元素，一次遍历数组，若栈为空，或遍历中的数字大于栈顶，即将遍历中的数字压入栈，若栈不为空且遍历中的数字小于栈顶，则将栈顶拷贝存储下来，出栈直至栈顶元素小于或等于遍历中的元素，再将存储起来的最大元素压入栈顶。\n## 代码\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stk;\n        int head = 0;\n        for(int i = 0; i < arr.size(); ++i){\n            if(stk.empty() || arr[i] >= head){\n                stk.push(arr[i]);\n                head = arr[i];\n            }\n            else if(arr[i] < stk.top()){\n                head = stk.top();\n                while(!stk.empty() && arr[i] < stk.top())\n                    stk.pop();\n                stk.push(head);\n            }\n        }\n        return stk.size();\n    }\n};\n```\n## 复杂度分析\nn为数组长度\n时间：一次遍历，对排序块的修正也最多遍历一次 O(n)\n空间：排序块最多为数组长度，这种情况下为线性空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1193265141","body":"## 思路\n将整个链表往右移k位，溢出者补到head处，使倒数k+1位指向null，尾节点指向头节点，倒数k位为新链表的头节点，获得倒数k+1位节点的方法是快慢指针\n## 代码\n```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr || head->next == nullptr || k == 0)\n            return head;\n        int len = 1;\n        ListNode* curr = head;\n        while(curr->next != nullptr){\n            curr = curr->next;\n            len++;\n        }\n        k %= len;\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast->next != nullptr){\n            if(k-- <= 0){\n                slow = slow->next;\n            }\n            fast = fast->next;\n        }\n        fast->next = head;\n        ListNode* new_head = slow->next;\n        slow->next = nullptr;\n        return new_head;\n    }\n};\n```\n## 复杂度分析\n* 时间：遍历两次，一次记录链表长度，一次快慢指针遍历，O(2n)\n* 空间：O（1）","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192414712","body":"## 思路\n递归，原来的头节点是新链表第二个节点，第二个节点在新链表为头节点\n## 代码\n```c++\n            class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr) return head;\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n```\n## 复杂度分析\n时间O(n)\n空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193275489","body":"## 思路\n递归，构建平衡的树需要高度差小于1，通过寻找链表中的中间值构建根节点，链表左侧构建左节点，链表右侧构建右节点\n## 代码\n```C++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head == nullptr) return nullptr;\n        return sortedListToBST(head, nullptr);\n    }\n\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail) {\n        if(head == tail) return nullptr;\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast != tail && fast->next != tail){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        TreeNode* root = new TreeNode(slow->val);\n        root->left = sortedListToBST(head, slow);\n        root->right = sortedListToBST(slow->next, tail);\n        return root;\n    }\n};\n```\n## 复杂度分析\n* 时间：O(nlogn)每一层的操作数是n，递归了logn层\n* 空间：O(logn)递归了logn层","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193258294","body":"## 思路\n分别用两个指针遍历两个链表，当遍历完后，两个指针交换赋值别的链表的头节点，再度遍历，直至两指针指向同一位置\n## 代码\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* a = headA;\n        ListNode* b = headB;\n        while(a != b){\n            b = (b == nullptr)? headA : b->next;\n            a = (a == nullptr)? headB : a->next;\n        }\n        return b;\n    }\n};\n```\n## 复杂度分析\n* 时间：m为链表一长度，n为链表二长度\nO(m+n)\n* 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193504139","body":"## 思路\n使用快慢指针，当快慢指针第一次相遇时将头节点赋值给快指针，快指针步长重置为一，当两者再次相遇节点即为入环节点\n## 代码\n```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(true){\n            if(fast == nullptr || fast->next == nullptr)\n                return nullptr;\n            fast = fast->next->next;\n            slow = slow->next;\n            if(fast == slow) break;\n        }\n        fast = head;\n        while(fast != slow){\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return fast;\n    }\n};\n```\n## 复杂度分析\n* 时间：a为头节点至入环节点长度，b为环长度，x为相遇节点，第一次相遇，快指针走a+nb-x，慢指针走a+b-x，第二次相遇，快慢指针均走a步，总体为线性时间\n* 空间：双指针所用空间为常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195121569","body":"### 要求：get和put在O(1)时间内完成\n### 思路：\n1. 通过键来访问值，应当想到hashmap\n2. 改变数据的访问时间\n* 能够随机访问\n* 数据能够被插入到头部或尾部\n3. 建立一个双向链表，存储key和val\n4. 再建立一个hashmap，用key来作为索引，访问链表\n### 代码\n```C++\nstruct ListNodes {\n    ListNodes* prev;\n    ListNodes* next;\n    int key, val;\n    ListNodes(): key(0), val(0), prev(nullptr), next(nullptr){}\n    ListNodes(int _key, int _value): key(_key), val(_value), prev(nullptr), next(nullptr){}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, ListNodes*> hashmap;\n    ListNodes* head;\n    ListNodes* tail;\n    int capacity, size;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        head = new ListNodes();\n        tail = new ListNodes();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if(!hashmap.count(key))\n            return -1;\n        ListNodes* node = hashmap[key];\n        moveTohead(node);\n        return node->val;\n    }\n    \n    void put(int key, int value) {\n        if(!hashmap.count(key)){\n            ListNodes* node = new ListNodes(key, value);\n            hashmap[key] = node;\n            addTohead(node);\n            ++size;\n            if(size > capacity){\n                ListNodes* removed = removeTail();\n                hashmap.erase(removed->key);\n                --size;\n                delete removed;\n            }\n        }\n        else {\n            ListNodes* node = hashmap[key];\n            node->val = value;\n            moveTohead(node);\n        }\n    }\n\n    void addTohead(ListNodes* node){\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(ListNodes* node){\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveTohead(ListNodes* node){\n        removeNode(node);\n        addTohead(node);\n    }\n\n    ListNodes* removeTail(){\n        ListNodes* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};struct ListNodes {\n    ListNodes* prev;\n    ListNodes* next;\n    int key, val;\n    ListNodes(): key(0), val(0), prev(nullptr), next(nullptr){}\n    ListNodes(int _key, int _value): key(_key), val(_value), prev(nullptr), next(nullptr){}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, ListNodes*> hashmap;\n    ListNodes* head;\n    ListNodes* tail;\n    int capacity, size;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        head = new ListNodes();\n        tail = new ListNodes();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if(!hashmap.count(key))\n            return -1;\n        ListNodes* node = hashmap[key];\n        moveTohead(node);\n        return node->val;\n    }\n    \n    void put(int key, int value) {\n        if(!hashmap.count(key)){\n            ListNodes* node = new ListNodes(key, value);\n            hashmap[key] = node;\n            addTohead(node);\n            ++size;\n            if(size > capacity){\n                ListNodes* removed = removeTail();\n                hashmap.erase(removed->key);\n                --size;\n                delete removed;\n            }\n        }\n        else {\n            ListNodes* node = hashmap[key];\n            node->val = value;\n            moveTohead(node);\n        }\n    }\n\n    void addTohead(ListNodes* node){\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(ListNodes* node){\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveTohead(ListNodes* node){\n        removeNode(node);\n        addTohead(node);\n    }\n\n    ListNodes* removeTail(){\n        ListNodes* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n```\n### 复杂度分析\n* 时间：get(基于hashmap)和put(基于list)操作都达到了O(1)\n* 空间：O(n) n为哈希表和链表的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196244121","body":"### 思路：\n1. 构建一个队列存储每一层的节点\n2. 记录完每一层的节点后，单独维护的记录层数的变量＋1，从队列中删除这些节点，用下一层的节点扩展队列\n### 代码：\n```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root)\n            return 0;\n        queue<TreeNode*> q;\n        int depth = 0;\n        q.push(root);\n        while(!q.empty()){\n            int size = q.size();\n            while(size-- > 0){\n                TreeNode* node = q.front();\n                q.pop();\n                if(node->left != nullptr){\n                    q.push(node->left);\n                }\n                if(node->right != nullptr){\n                    q.push(node->right);\n                }\n            }\n            depth++;\n        }\n        return depth;\n    }\n};\n```\n### 复杂度分析\n* n为二叉树的节点数\n* 时间：一次遍历 O(n)\n* 空间：建立的队列的最大元素数为树中节点数最多那层的节点数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185141689","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n## 思路\n\n---\n\n从低位按位进行相加，记录进位，前面位置不够了插入新的位。（看了题解还是借助str来偷懒比较方便啊！）\n\n## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        count = len(num) - 1\n        while k or carry:\n            if count < 0:\n                num.insert(0,0)\n                count = 0\n            single_k = k % 10\n            k //= 10\n            num[count] += single_k + carry\n            carry = num[count] // 10\n            num[count] %= 10\n            count -= 1\n        return num\n```\n\n## 复杂度\n\n---\n\n- ****Time:**** $O(N)$，\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186122298","body":"[Link to LeetCode Problem](https://leetcode.cn/problems/shortest-distance-to-a-character/submissions/)\n\n## 思路\n\n---\n\n从左和从右分别遍历一遍，找到和目标字符最近的距离\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        num_char = len(s)\n        answer = [num_char for _ in range(num_char)]\n        # find left closest\n        cur_dist = num_char\n        for i in range(num_char):\n            if s[i] == c: \n                cur_dist = 0\n            else: \n                cur_dist += 1\n            answer[i] = cur_dist\n        # find right closest\n        cur_dist = num_char\n        for i in range(num_char):\n            if s[num_char - 1 - i] == c:\n                cur_dist = 0\n            else:\n                cur_dist += 1\n            answer[num_char - 1 - i] = min(answer[num_char - 1 - i], cur_dist)\n        return answer\n```\n\n## 复杂度分析\n\n---\n\n- ****Time:**** $O(N)$\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186487537","body":"Link to LeetCode Problem\n\n## 思路\n\n---\n\n设计一个增量栈用于记录increment操作带来的增量，在pop时返回栈中值和增量栈的和，并调整增量栈，而不是直接在increment操作时直接在栈中加上，能将increment的时间复杂度从O(N)降到O(1)。\n\n## 代码\n\n---\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.inc = []\n        self.maxSize = maxSize\n        self.size = 0\n        \n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.size += 1\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        else:\n            if self.size > 1:\n                self.inc[-2] += self.inc[-1]\n            self.size -= 1 \n            return self.stack.pop(-1) + self.inc.pop()\n            \n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, self.size)-1] += val\n```\n\n## 复杂度分析\n\n- ****Time:**** $O(1)$ （对于pop, push和increment都是）\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186713928","body":"## 思路\n\n---\n\n用一个栈保存遇到的字符，当遇到’]’时开始弹出，直到’[’时当前字符串获取完毕，开始获取重复的次数n，然后将字符串重复n次，并将重复n次后的字符串重新压入栈，如此循环。最终将栈中所有字符串和并后返回\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in range(len(s)):\n            char = s[i]\n            if char != ']':\n                stack.append(char)\n            else:\n                tmp_str = ''\n                while stack[-1] != '[':\n                    tmp_str = stack.pop(-1) + tmp_str\n                stack.pop(-1)\n                num_str = ''\n                while stack and stack[-1].isdigit():\n                    num_str = stack.pop(-1) + num_str\n                tmp_res = tmp_str * int(num_str)\n                stack.append(tmp_res)\n        return ''.join(stack)\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N)， N是字符串解码后的长度*\n- 空间复杂度：*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188541605","body":"## 思路\n\n---\n\n两个栈来回倒，为了使pop和peek两操作都是O(1)的时间复杂度，选择在push的时候倒一下\n\n## 代码\n\n---\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop(-1))\n        self.stack1.append(x)\n        while self.stack2:\n            self.stack1.append(self.stack2.pop(-1))\n    def pop(self) -> int:\n        return self.stack1.pop(-1)\n\n    def peek(self) -> int:\n        return self.stack1[-1]\n\n    def empty(self) -> bool:\n        return not self.stack1\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N) for push，N为队列最长的长度，O(1)for pop,peek和empty*\n- 空间复杂度：*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189740301","body":"## 思路\n\n---\n\n单调栈，能分块的条件是下一个块的最小值大于等于前一个块的最大值，我们使用一个单调栈保存遇到的值，如果新的值大于等于栈顶的值就入栈，否则就要判断这个比栈顶小的值是不是比栈顶前面的块的最大值都大，不满足的就出栈（相当于合并块），最后栈的长度就是最多能完成排序的块的数量。\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for n in arr:\n            if not stack or n >= stack[-1]:\n                stack.append(n)\n            else:\n                tmp = stack.pop()\n                while stack and stack[-1] > n:\n                    stack.pop()\n                stack.append(tmp)\n        return len(stack)\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N)*\n- 空间复杂度：*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190970768","body":"## 思路\n\n---\n\n先遍历一遍找到末尾节点和总节点数，下一遍遍历找到新的末尾节点和头节点（注意k有可能比总节点数大，需要求模），然后更改节点之间的关系即可。\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k==0: return head\n        n_nodes = 1\n        tail = p = head\n        while tail.next:\n            n_nodes += 1\n            tail = tail.next\n        for _ in range(n_nodes - k%n_nodes - 1):\n            p = p.next\n        tail.next = head\n        new_head = p.next\n        p.next = None\n        return new_head\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N)*\n- 空间复杂度：*O(1)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192118850","body":"## 思路\n\n---\n\n设置一个哨兵节点以保持后面操作的一致性，cur节点指向当前准备交换的节点中的第一个，prev指向cur的前一个节点，比较直观地就能修改cur与cur的下一个节点的顺序，如此循环直到cur是空的或者cur没有下一个节点。\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next : return head\n        new_head = ListNode(next=head)\n        prev, cur = new_head, head\n        while cur and cur.next:\n            next_node = cur.next\n            prev.next = next_node\n            cur.next = next_node.next\n            next_node.next = cur\n            prev = cur\n            cur = cur.next\n        return new_head.next\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N)*\n- 空间复杂度：*O(1)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193145441","body":"## 思路---\r\n高度平衡的二叉搜索树正好中序遍历是有序的，所以每棵子树的中间节点正好就是根结点，使用快慢指针找到中间节点然后递归地构建左右子树。\r\n## 代码---\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        def buildTree(start, end):\r\n            if start == end: return None\r\n            mid = findMid(start, end)\r\n            return TreeNode(val=mid.val, left=buildTree(start, mid), right=buildTree(mid.next, end)) \r\n\r\n        def findMid(start, end):\r\n            if start == end: return start\r\n            dummyhead = ListNode(next=start)\r\n            slow = fast = dummyhead\r\n            while fast != end:\r\n                slow = slow.next\r\n                fast = fast.next\r\n                if fast != end: fast = fast.next\r\n            return slow\r\n\r\n        return buildTree(head, None)\r\n```\r\n## 复杂度分析---- \r\n时间复杂度：*O(NlogN)*\r\n空间复杂度：*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193288714","body":"## 思路\n\n---\n\n两个指针同时遍历，a到尾部后从b头部开始遍历，b到尾部后从a头部开始遍历，a和b相遇时即为节点。\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a = headA\n        b = headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N)*\n- 空间复杂度：*O(1)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193498379","body":"## 思路\n\n---\n\n快慢指针同时从头结点出发，分别以2和1的步长遍历链表，在遍历过程中第一次相遇后快指针回到头结点，此时快指针和慢指针到环形链表环的起始点的距离相同，都以1的步长继续遍历，第二次两个指针相遇的节点就是入环的第一个节点。\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head: return None\n        fast = slow = head\n        while fast:\n            fast = fast.next\n            if fast: fast = fast.next\n            slow = slow.next\n            if fast == slow:\n                break\n        if not fast: return None\n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        return fast\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N)*\n- 空间复杂度：*O(1)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194953260","body":"## 思路\n\n---\n\n哈希表+双向链表来保证get和put都是O(1)时间复杂度，使用head和tail两个虚拟节点保持操作一致性，越靠近head的节点越久未被使用，每个节点除了要保存value和邻接的节点，还需要保存key方便弹出哈希表中的键值对。\n\n## 代码\n\n---\n\n```python\nclass BiListNode:\n    def __init__(self, key=0, val=0, next=None, prev=None):\n        self.key = key\n        self.val = val\n        self.next = next\n        self.prev = prev\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.d = {}\n        self.head = BiListNode()\n        self.tail = BiListNode(prev=self.head)\n        self.head.next = self.tail\n        self.cnt = 0\n    def get(self, key: int) -> int:\n        if key not in self.d.keys(): return -1\n        node = self.d[key]\n        self.moveToTail(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.d.keys():\n            node = self.d[key]\n            node.val = value\n            self.moveToTail(node)\n        elif self.cnt < self.cap:\n            self.addNewNode(key, value)\n            self.cnt += 1\n        else:\n            self.addNewNode(key, value)\n            self.discard_LRU()\n\n    def moveToTail(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        self.tail.prev = node\n        node.next = self.tail\n\n    def addNewNode(self, key, value):\n        node = BiListNode(key=key, val=value, next=self.tail, prev=self.tail.prev)\n        self.tail.prev.next = node\n        self.tail.prev = node\n        self.d[key] = node\n    \n    def discard_LRU(self):\n        discard_node = self.head.next\n        self.head.next = discard_node.next\n        discard_node.next.prev = self.head\n        self.d.pop(discard_node.key)\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：get和put都是*O(1)*\n- 空间复杂度：*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196814958","body":"## 思路\n\n---\n\n递归地进行深度优先遍历，遍历过程中保存所有见过的节点的最大深度以及当前层的深度，当深度超过当前保存的最大深度则更新。\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        ans = [0]\n        def dfs(root, level):\n            if not root: return\n            dfs(root.left, level+1)\n            dfs(root.right, level+1)\n            ans[0] = max(ans[0], level)\n        dfs(root, 1)\n        return ans[0]\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N)， N是树中节点的数量*\n- 空间复杂度：*O(M)， M是树的深度*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197564187","body":"## 思路\n\n---\n\n使用相同的顺序同时遍历两棵树，同时比较节点的值是否相同。\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q: return True\n        if (not p and q) or (p and not q): return False\n        if p.val != q.val: return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N)，N是节点数*\n- 空间复杂度：*O(M)， M是树的最大深度*","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185141987","body":"### Idea\nTake K as a carry and add it to the lowest digit, then update carry, and keep going to higher digit.\n\n\n### Code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int cur = k;\n        int i = num.length - 1;\n        while(i >= 0 || cur > 0) {\n            if(i >= 0) {\n                cur = cur + num[i--];\n            }\n            res.add(cur % 10);\n            cur /= 10; \n        }\n        \n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(max(n, logk)), n is the length of num\n- Space complexity: O(max(n, logk))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186075682","body":"### Idea\nLoop twice on the string S.\nFirst forward pass to find shortest distant to character on left.\nSecond backward pass to find shortest distant to character on right.\n\n\n### Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] answer = new int[len];\n        int d = len;\n        for(int i = 0; i < len; i++) {\n            d = s.charAt(i) == c ? 0 : d + 1;\n            answer[i] = d;\n        }\n        \n        d = len;\n        for(int i = len - 1; i >= 0; i--) {\n            d = s.charAt(i) == c ? 0 : d + 1;\n            answer[i] = Math.min(answer[i], d);\n        }\n        \n        return answer;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n), n is the length of string s\n- Space complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186435493","body":"### Idea\nUse an array to represent the stack. Push will add new integer to the array. Pop removes the last element in the array and increment will add val to the first k elements of the array.\n\n### Code\n```java\nclass CustomStack {\n    private List<Integer> stack;\n    private int max;\n\n    public CustomStack(int maxSize) {\n        stack = new ArrayList<>();\n        max = maxSize;\n    }\n    \n    public void push(int x) {\n        if(stack.size() < max) {\n            stack.add(x);\n        }\n    }\n    \n    public int pop() {\n        if(stack.isEmpty()) {\n            return -1;\n        }\n        int top = stack.get(stack.size() - 1);\n        stack.remove(stack.size() - 1);\n        return top;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = Math.min(stack.size(), k); i > 0; i--) {\n            stack.set(i - 1, stack.get(i - 1) + val);\n        }\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(1) for push and pop and O(k) for increment.\n- Space complexity: O(n), n is the maxsize\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186604148","body":"### Idea\nUse 2 stacks one to store all the integer k and one to store all the decoded strings.\n### Code\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder str = new StringBuilder();\n        Stack<Integer> num = new Stack<>();\n        Stack<StringBuilder> letters = new Stack<>();\n        int k = 0;\n        for(char c: s.toCharArray()) {\n            if(Character.isDigit(c)) {\n                k = k * 10 + (c - '0');\n            } else if(c == '[') {\n                num.push(k);\n                k = 0;\n                letters.push(str);\n                str = new StringBuilder();\n            } else if(c == ']') {\n                StringBuilder temp = letters.pop();\n                for(int i = num.pop(); i > 0; i--) {\n                    temp.append(str);\n                }\n                str = temp;\n            } else {\n                str.append(c);\n            }\n        }\n        \n        return str.toString();\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(kn)\n- Space complexity: O(num(k) + num(char))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188233701","body":"### Idea\nuse two stacks to make a queue\n\n### Code\n```java\nclass MyQueue {\n\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n    private int front;\n    \n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    // O(1)\n    public void push(int x) {\n        if(stack1.isEmpty()) {\n            front = x;\n        }\n        stack1.push(x);\n    }\n    \n    // Amortized O(1)\n    public int pop() {\n        if(stack2.isEmpty()) {\n            while(!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    // O(1)\n    public int peek() {\n        if(stack2.isEmpty()) {\n            return front;\n        }\n        return stack2.peek();\n    }\n    \n    // O(1)\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(1) per operation, Pop - Amortized O(1) per operation.\n- Space complexity: O(n) for Push, O(1) for others\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189905757","body":"### Idea\nnon-strictly increasing stack\n\n### Code\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack =  new Stack<>();\n        for(int i: arr) {\n            if(!stack.isEmpty() && i < stack.peek()) {\n                int top = stack.peek();\n                while(!stack.isEmpty() && i < stack.peek()) {\n                    stack.pop();\n                }\n                stack.add(top);\n            } else {\n                stack.add(i);\n            }\n        }\n        \n        return stack.size();\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190800674","body":"### Idea\n1. To close the linked list into the ring.\n\n2. To break the ring after the new tail and just in front of the new head.\n\n### Code\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        ListNode tail = head;\n        int len = 1;\n        while(tail.next != null) {\n            tail = tail.next;\n            len++;\n        }\n        tail.next = head;\n        ListNode cur = head;\n        for(int i = 1; i <  len - (k % len); i++) {\n            cur = cur.next;\n        }\n        tail = cur.next;\n        cur.next = null;\n\n        return tail;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192051192","body":"### Idea\n1. Recursion\n\n2. Iteration\n### Code\n```java\n// Recursion\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode pre = head; \n        ListNode cur = head.next;\n        \n        pre.next = swapPairs(cur.next);\n        cur.next = pre;\n        \n        return cur;\n    }\n}\n\n// Iteration\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        \n        ListNode dummy = new ListNode(-1); \n        dummy.next = head;\n        ListNode pre = dummy;\n        \n        while(head != null && head.next != null) {\n            ListNode cur = head;\n            ListNode second = head.next;\n            \n            pre.next = second;\n            cur.next = second.next;\n            second.next = cur;\n            \n            pre = cur;\n            head = cur.next;\n        }\n        \n        return dummy.next;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n) for recursion, O(1) for iteration\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193000900","body":"### Idea\n- Recursion & Inorder traversal\n- Fast slow pointer to find median and change into subproblems\n\n### Code\n```java\n// O(nlogn)\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) {\n            return null;\n        }\n        return sortedListToBST(head, null);\n    }\n    \n    private TreeNode sortedListToBST(ListNode head, ListNode tail) {\n        if(head == tail) {\n            return null;\n        }\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast != tail && fast.next != tail) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode node = new TreeNode();\n        node.left = sortedListToBST(head, slow);\n        node.val = slow.val;\n        node.right = sortedListToBST(slow.next, tail);\n        return node;\n    }\n}\n\n// O(n) - use a global node and index for recursion\nclass Solution {\n    ListNode node;\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) {\n            return null;\n        }\n        node = head;\n        ListNode cur = head;\n        int size = 1;\n        while(cur.next != null) {\n            cur = cur.next;\n            size++;\n        }\n        return buildBST(1, size + 1);\n    }\n    \n    private TreeNode buildBST(int head, int tail) {\n        if(head == tail) {\n            return null;\n        }\n        \n        int mid = head + (tail - head) / 2;\n        TreeNode res = new TreeNode();\n        res.left = buildBST(head, mid);\n        res.val = node.val;\n        node = node.next;\n        res.right = buildBST(mid + 1, tail);\n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(logn) for recursion\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193190200","body":"Two pointers\n\n### Code\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(m + n)\n- Space complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193620838","body":"### Idea\nHash Table / Fast & slow pointers\n\n### Code\n```java\n// Hash Table\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) {\n            return null;\n        }\n        Set<ListNode> map = new HashSet<>();\n        while(!map.contains(head) && head.next != null) {\n            map.add(head);\n            head = head.next;\n        }\n        return head.next == null ? null : head;\n    }\n}\n\n// Fast & slow pointers\n// a + 2b + c = 2(a + b)\n// a = c\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if(fast == slow) {\n                fast = head;\n                break;\n            }\n        }\n        if(fast == null || fast.next == null) {\n            return null;\n        }\n        while(fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n) / O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195165462","body":"### Idea\nHashmap + DoubleLinkedList\n\n### Code\n```java\nclass LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode pre;\n        DLinkedNode post;\n    }\n    \n    //Create a dummy head and tail to mark the boundary, then we don't need to check the NULL node\n    // Add the new node right after head;\n    private void addNode(DLinkedNode node) {\n        node.pre = head;\n        node.post = head.post;\n        head.post.pre = node;\n        head.post = node;\n    }\n    \n    private void removeNode(DLinkedNode node) {\n        DLinkedNode pre = node.pre;\n        DLinkedNode post = node.post;\n        \n        pre.post = post;\n        post.pre = pre;\n    }\n    \n    private void moveToHead(DLinkedNode node) {\n        this.removeNode(node);\n        this.addNode(node);\n    }\n    \n    private DLinkedNode popTail() {\n        DLinkedNode last = tail.pre;\n        this.removeNode(last);\n        return last;\n    }\n    \n    private Map<Integer, DLinkedNode> cache = new HashMap<>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        head = new DLinkedNode();\n        head.pre = null;\n        tail = new DLinkedNode();\n        tail.post = null;\n        head.post = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        this.moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if(node != null) {\n            node.value = value;\n            this.moveToHead(node);\n        } else {\n            DLinkedNode newNode = new DLinkedNode();\n            newNode.value = value;\n            newNode.key = key;\n            this.cache.put(key, newNode);\n            this.addNode(newNode);\n            size++;\n            if(size > capacity) {\n                DLinkedNode last = this.popTail();\n                this.cache.remove(last.key);\n                size--;\n            }\n        }\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(1)\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196324503","body":"### Idea\nDFS / BFS\n\n### Code\n```java\n// DFS\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        } else {\n            return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n        }\n    }\n}\n\n// BFS\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n        Queue<TreeNode> q = new LinkedList<>();\n        int maxDepth = 0;\n        q.add(root);\n        while(!q.isEmpty()) {\n            maxDepth++;\n            for(int i = q.size(); i > 0; i--) {\n                TreeNode node = q.poll();\n                if(node.left != null) {\n                    q.add(node.left);\n                }\n                if(node.right != null) {\n                    q.add(node.right);\n                }\n            }\n        }\n        return maxDepth;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197072794","body":"### Idea\nDFS / BFS\n\n### Code\n```java\n// DFS\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null & q == null) {\n            return true;\n        } else if(p != null && q != null && p.val == q.val) {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n        \n        return false;\n    }\n}\n\n// BFS\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) {\n            return true;\n        } else if(p == null || q == null) {\n            return false;\n        }\n        \n        Queue<TreeNode> q1 = new LinkedList<>();\n        Queue<TreeNode> q2 = new LinkedList<>();\n        q1.add(p);\n        q2.add(q);\n        while(!q1.isEmpty() && !q2.isEmpty()) {\n            TreeNode n1 = q1.poll();\n            TreeNode n2 = q2.poll();\n            if(n1 ==  null && n2 == null) {\n                continue;\n            } else if(n1 == null || n2 == null) {\n                return false;\n            }\n            if(n1.val != n2.val) {\n                return false;\n            }\n            q1.add(n1.left);\n            q1.add(n1.right);\n            q2.add(n2.left);\n            q2.add(n2.right);\n        }\n\n        return true;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185152522","body":"### 思路\r\n\r\n大数加法的阉割版，将 K 看作是每次加法的进位即可。\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  const { length } = num;\r\n\r\n  let carry = k;\r\n  for (let i = length - 1; i >= 0; i--) {\r\n    const value = (num[i] + carry) % 10;\r\n    carry = Math.floor((num[i] + carry) / 10);\r\n    num[i] = value;\r\n  }\r\n\r\n  while (carry) {\r\n    num.unshift(carry % 10);\r\n    carry = Math.floor(carry / 10);\r\n  }\r\n\r\n  return num;\r\n};\r\n```\r\n\r\n+ 时间复杂度 $O(N + logK)$, N 为传入数据 num 的长度, K 是传入的数字，logK 表示数字K的位数\r\n+ 空间复杂度 $O(N + logK)$, N 为传入数据 num 的长度, K 是传入的数字，logK 表示数字K的位数\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185153547","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int len = num.size() - 1;\n        bool flag = true;\n        \n        while(len >= 0 || k > 0)\n        {\n            if(flag)\n            {\n                if(len >= 0)\n                {\n                    k += num[len];\n                    len--;\n                }\n                res.insert(res.begin(), k % 10);\n                k /= 10;\n            \n                if(k == 0)\n                    flag = false;\n            }\n            else\n            {\n                res.insert(res.begin(), num[len]);\n                len--;\n            }\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186186039","body":"class Solution {\npublic:\n vector<int> shortestToChar(string s, char c) {\n        vector<int> vec;\n        vector<int> res;\n        \n        for(int i = 0; i < s.size(); i++)\n            if(s[i] == c)\n                vec.push_back(i);\n        \n        for(int i = 0; i < s.size(); i++)\n        {\n            int temp = INT_MAX;\n            for(int j = 0; j < vec.size(); j++)\n            {\n                temp = min(temp, abs(vec[j] - i));\n            }\n            res.push_back(temp);\n        }\n        \n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185155634","body":"\n## 题目地址()\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/submissions/\n\n## 前置知识\n\n- 数组的遍历，栈\n\n\n\n## 思路\n-逐位相加\n\n\n## 代码\n\n- 语言支持：JavaScript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let result = [];\n    const n = num.length;\n    //数组遍历循环\n    for(let i = n - 1; i>= 0; i--)\n    {\n        let sum = num[i] + k%10 ;\n        k = Math.floor(k/10);\n        if(sum >= 10)\n        {\n            k++;\n            sum -=10;\n        }\n        result.push(sum);\n    }\n    //如果出现num循环后k还有剩余则需要进行下面循环\n    for(;k>0;k = Math.floor(k/10))\n    {\n        result.push(k % 10);\n    }\n    //由于利用栈的push，所以是先进后出，所以应当将其逆序\n    result.reverse();\n    return result;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，for循环遍历\n- 空间复杂度：$O(n)$，创建新的空间存放结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186208679","body":"\r\n## 题目地址()\r\n\r\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/submissions/\r\n\r\n\r\n## 前置知识\r\n\r\n- 数组的遍历\r\n\r\n\r\n## 思路\r\n首先从左往右遍历字符串s,记录左边最后一个出现的坐标；\r\n然后从右到左遍历，判断到右侧的c字符的距离是否比到左侧距离小或者左侧没有c字符的字符，则进行替换c字符的坐标；\r\n\r\n## 关键点\r\n\r\n-  如何获取距离最小值\r\n\r\n## 代码\r\n\r\n- 语言支持：Javascript\r\n\r\nJavascript\r\n\r\n```Javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let res = Array(s.length);\r\n\r\n    //贪心法\r\n    //先从左到右遍历\r\n    for(let i = 0 ;i <s.length ; i++)\r\n    {\r\n        if(s[i] === c)\r\n        {\r\n            res[i] = i;\r\n        }else{\r\n            //void 0 == undefined)，如果左侧没有出现过c字符，则为Infinity\r\n            res[i] = (res[i-1] === void 0 ? Infinity : res[i-1]);\r\n        }\r\n    }\r\n    //从右往左遍历\r\n    for(let i = s.length -1; i>= 0;i--)\r\n    {\r\n        //如果左侧没有c字符或者右侧出现的c字符距离更近，就更新\r\n        if(res[i] === Infinity || res[i+1] - i < i- res[i])\r\n        {\r\n            res[i] = res[i+1];\r\n        }\r\n    }\r\n    for(let i = 0 ;i <res.length ; i++){\r\n        res[i] = Math.abs(res[i] - i);\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531885","body":"/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    //用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\n    this.max = maxSize;\r\n    this.stack = [];\r\n\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    //如果栈还未增长到 maxSize ，就将 x 添加到栈顶\r\n    if(this.stack.length < this.max)\r\n    {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    //弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1\r\n   var res = this.stack.pop();\r\n   return res == null ? -1 : res;\r\n   \r\n\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i = 0 ; i < this.stack.length;i++)\r\n    {\r\n        if(i <k)\r\n        {\r\n            this.stack[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187669786","body":"/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nconst decodeString = (s) => {\r\n    let numStack = [];       \r\n    let strStack = [];        \r\n    let num = 0;            \r\n    let result = '';     \r\n    for (const char of s) {   \r\n        if (!isNaN(char)) {   \r\n            num = num * 10 + Number(char);\r\n        } else if (char == '[') {  \r\n            strStack.push(result); \r\n            result = '';           \r\n            numStack.push(num);    \r\n            num = 0;               \r\n        } else if (char == ']') {  \r\n            let repeatTimes = numStack.pop(); \r\n            result = strStack.pop() + result.repeat(repeatTimes); \r\n        } else {                   \r\n            result += char;        \r\n        }\r\n    }\r\n    return result;\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189161902","body":"\r\n## 题目地址()\r\n\r\nhttps://leetcode.cn/problems/implement-queue-using-stacks/submissions/\r\n\r\n\r\n## 前置知识\r\n\r\n- 栈，队列\r\n\r\n\r\n\r\n## 关键点\r\n\r\n-  两个栈实现队列\r\n\r\n## 代码\r\n\r\n- 语言支持：Javascript\r\n\r\nja Code:\r\n\r\n```python\r\nvar MyQueue = function() {\r\n    this.stack1 = [];\r\n    this.stack2 = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    // void push(int x) 将元素 x 推到队列的末尾\r\n    this.stack1.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    // int pop() 从队列的开头移除并返回元素\r\n    if(!this.stack2.length){\r\n        this.out();\r\n    }\r\n    return this.stack2.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    // int peek() 返回队列开头的元素\r\n    if(!this.stack2.length){\r\n        this.out();\r\n    }\r\n    return this.stack2[this.stack2.length -1];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack1.length == 0 && this.stack2.length == 0;\r\n};\r\n\r\nMyQueue.prototype.out = function(){\r\n    while(this.stack1.length){\r\n        this.stack2.push(this.stack1.pop());\r\n    }\r\n}\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1192653266","body":"\r\n## 题目地址()\r\nhttps://leetcode.cn/problems/max-chunks-to-make-sorted-ii/\r\n\r\n\r\n\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JS\r\n\r\nJS Code:\r\n\r\n```\r\n\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\n var maxChunksToSorted = function(arr) {\r\n    const stack = [];\r\n    for(let i = 0;i < arr.length ; i++)\r\n    {\r\n        a = arr[i];\r\n    if(stack.length>0 && stack[stack.length-1]>a)\r\n    {\r\n        const curr = stack[stack.length-1];\r\n        while(stack && stack[stack.length-1]>a)\r\n        {\r\n            stack.pop();\r\n        }\r\n        stack.push(curr);\r\n    }else{\r\n        stack.push(a);\r\n    }\r\n    }\r\n    return stack.length;\r\n    };\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1192650196","body":"## 题目地址()\r\n\r\nhttps://leetcode.cn/problems/rotate-list/submissions/\r\n\r\n\r\n\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  快慢指针\r\n\r\n## 代码\r\n\r\n- 语言支持：JS\r\n\r\nJS Code:\r\n\r\n```JS\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if(!head || !head.next)\r\n    return head;\r\n    let count = 0;\r\n    now = head;\r\n    while(now){\r\n        now = now.next;\r\n        count++;\r\n    }\r\n    k = k%count;\r\n    let slow = (fast = head);\r\n    while(fast.next){\r\n        if(k--<= 0){\r\n            slow = slow.next;\r\n        }\r\n        fast = fast.next;\r\n    }\r\n    fast.next = head;\r\n    let res = slow.next;\r\n    slow.next = null;\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192647965","body":"\r\n## 题目地址()\r\n\r\nhttps://leetcode.cn/problems/swap-nodes-in-pairs/submissions/\r\n\r\n## 题目描述\r\n\r\n```\r\n\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  两两进行交换，利用链表的\r\n\r\n## 代码\r\n\r\n- 语言支持：JS\r\n\r\nJS Code:\r\n\r\n``\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    let dummy = new ListNode();\r\n    dummy.next = head;\r\n    let curr = dummy;\r\n    while(curr.next !== null && curr.next.next !== null){\r\n        let n1 = curr.next;\r\n        let n2 = curr.next.next;\r\n        curr.next = n2;\r\n        n1.next = n2.next;\r\n        n2.next = n1;\r\n        curr = n1;\r\n    }\r\n    return dummy.next;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146010","body":"\r\n## 题目地址()\r\n\r\nhttps://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n## 题目描述\r\n\r\n```\r\n\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JS\r\n\r\nJS Code:\r\n\r\n```python\r\n\r\nconst sortedListToBST = (head) => {\r\n  const arr = [];\r\n  while (head) { \r\n    arr.push(head.val);\r\n    head = head.next;\r\n  }\r\n  // 根据索引start到end的子数组构建子树\r\n  const buildBST = (start, end) => {\r\n    if (start > end) return null;       \r\n    const mid = (start + end) >>> 1;  \r\n    const root = new TreeNode(arr[mid]);\r\n    root.left = buildBST(start, mid - 1); \r\n    root.right = buildBST(mid + 1, end); \r\n    return root;                          \r\n  };\r\n\r\n  return buildBST(0, arr.length - 1);  \r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193321010","body":"***\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    const visited = new Set();\r\n    let temp = headA;\r\n    while (temp !== null) {\r\n        visited.add(temp);\r\n        temp = temp.next;\r\n    }\r\n    temp = headB;\r\n    while (temp !== null) {\r\n        if (visited.has(temp)) {\r\n            return temp;\r\n        }\r\n        temp = temp.next;\r\n    }\r\n    return null;\r\n};\r\n***","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194280287","body":"/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n  // 快慢指针初始化指向 head\r\n  let slow = head;\r\n  let fast = head;\r\n  // 快指针走到末尾时停止\r\n  while (fast && fast.next) {\r\n    // 慢指针走一步，快指针走两步\r\n    slow = slow.next;\r\n    fast = fast.next.next;\r\n    // 快慢指针相遇，说明含有环\r\n    if (slow == fast) {\r\n      // 任一一节点指向头节点\r\n      fast = head;\r\n      // 同步向前进\r\n      while (fast != slow) {\r\n        fast = fast.next;\r\n        slow = slow.next;\r\n      }\r\n      // 返回入口节点\r\n      return fast;\r\n    }\r\n  }\r\n  // 不包含环\r\n  return null;   \r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195469446","body":"\r\n\r\n## 代码\r\n\r\n- 语言支持：js\r\n\r\njs Code:\r\n\r\n```python\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n  this.max = capacity\r\n  this.map = new Map()\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  if(this.map.has(key)){\r\n    let value = this.map.get(key)\r\n    this.map.delete(key)\r\n    this.map.set(key, value)\r\n    return value\r\n  } else {\r\n    return -1\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n  if (this.map.has(key)) {\r\n    this.map.delete(key)\r\n  }\r\n  this.map.set(key, value)\r\n  if(this.map.size > this.max){\r\n    this.map.delete(this.map.keys().next().value)\r\n  }\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196751149","body":"var maxDepth = function(root) {\r\nif(root === null){\r\n    return 0\r\n}\r\nreturn Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185157127","body":"1. [题目链接](https://leetcode.cn/problems/add-to-array-form-of-integer/submissions/)\r\n\r\n### 简单理解\r\n- 从低位往高位计算，逢十进一。数组直接从右往左数，而数字的话，每次求10的余数，求完后除10即可。\r\n- 如果数组size不够，那就再首位插入元素1实现进1操作。\r\n- 后面发现可能k比num长。所以还需要把多余的k插入到num中。\r\n- 最后输出结果即可。可以用std::move(num)直接将值移出，防止重复拷贝，节省内存。\r\n\r\n### 最终代码\r\n```bash\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n    // 反向迭代，利用加法进位来计算\r\n    int temp = 0;\r\n    int n = num.size();\r\n    for (int i = 0; i < num.size(); ++i) {\r\n      temp = num[n - i - 1] + k % 10;\r\n      k = k / 10;\r\n      num[n - i - 1] = temp % 10;\r\n      if (temp >= 10) {\r\n        if (n - i - 2 >= 0) {\r\n          num[n - i - 2] += 1;\r\n        } else {\r\n          n += 1;\r\n          num.insert(num.begin(), 1);\r\n        }\r\n      }\r\n    };\r\n    // 补丁，k可能比Num长，需要将k剩余部分插入\r\n    while (k > 0) {\r\n      num.insert(num.begin(), k % 10);\r\n      k = k / 10;\r\n    }\r\n    return std::move(num);\r\n  }\r\n};\r\n\r\n\r\n\r\nint main() {\r\n  std::vector<int> v1 = {1,3,8};\r\n  int data = 955;\r\n  Solution s;\r\n  std::vector<int> v2 = s.addToArrayForm(v1, data);\r\n  for (const int & x: v2) {\r\n    std::cout << x << \" \";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n### 结果\r\n![image](https://user-images.githubusercontent.com/28218658/179150726-78be3d31-e26a-4c6f-812a-8add0dae6953.png)\r\n\r\n用时：24ms，内存25.8MB。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186080712","body":"- 题目[链接](https://leetcode.cn/problems/shortest-distance-to-a-character/submissions/)\r\n### 解题思路\r\n- 左右两边各遍历一次，分别获取邻接最近值，然后用min函数对比两者谁更小。\r\n- 直接string可以改成cosnt string &,减少数据拷贝。\r\n- 返回还是直接用std::move，减少内存拷贝，直接移动结果。\r\n\r\n\r\n### 代码\r\n```cpp\r\n// Copyright 2022\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing std::vector;\r\nusing std::string;\r\n\r\nclass Solution {\r\n public:\r\n  vector<int> shortestToChar(const string & s, char c) {\r\n    // 前向遍历，假设c在最后一个位置\r\n    std::vector<int> result(s.size(), 0);\r\n    int index = s.size() - 1;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        result[i] = abs(i - index);\r\n      }\r\n    }\r\n    // 后向遍历，假设c再第一个位置\r\n    index = 0;\r\n    for (int i = s.size() - 1; i >= 0; --i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        // 此处结果取短距离\r\n        result[i] = std::min(result[i], abs(i - index));\r\n      }\r\n    }\r\n    return std::move(result);\r\n  }\r\n};\r\n\r\n\r\nint main() {\r\n  std::string str(\"loveleetcode\");\r\n  char c1 = 'e';\r\n  Solution s;\r\n  std::vector<int> res = s.shortestToChar(str, c1);\r\n  for (const int & x : res) {\r\n    std::cout << x << \" \";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n1. 时间复杂度：$O(n)$，一层遍历。\r\n2. 空间复杂度：$O(n)$，因为构建了一个数组，且数组内存无法避免，当然可以用std::move做一些空间优化。\r\n\r\n### 优化思路1：\r\n- 第二次遍历的时候，初始值其实就是上一次的最终索引，并且可以优化一下，将一个n遍历拆分成index右边与左边，去掉abs函数，减少n次if判断。\r\n- 优化后时间复杂度与空间复杂度不变。\r\n\r\n```cpp\r\n// Copyright 2022\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing std::vector;\r\nusing std::string;\r\n\r\nclass Solution {\r\n public:\r\n  vector<int> shortestToChar(const string & s, char c) {\r\n    // 前向遍历，假设c在最后一个位置\r\n    std::vector<int> result(s.size(), 0);\r\n    int index = s.size() - 1;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        result[i] = abs(i - index);\r\n      }\r\n    }\r\n    // 后向遍历1，此时已经知道了index的初始值, index右边的均大于index\r\n    // 并且不需要判断s[i] == c\r\n    for (int i = s.size() - 1; i > index; --i) {\r\n        // 此处结果取短距离\r\n        result[i] = std::min(result[i], i - index);\r\n      }\r\n    // 后向遍历2，此时i恒小于index\r\n    for (int i = index; i >= 0; --i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        // 此处结果取短距离\r\n        result[i] = std::min(result[i], index - i);\r\n      }\r\n    }\r\n    return std::move(result);\r\n  }\r\n};\r\n\r\n\r\nint main() {\r\n  std::string str(\"loveleetcode\");\r\n  char c1 = 'e';\r\n  Solution s;\r\n  std::vector<int> res = s.shortestToChar(str, c1);\r\n  for (const int & x : res) {\r\n    std::cout << x << \" \";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n### 成果\r\n![image](https://user-images.githubusercontent.com/28218658/179337923-38b90c6a-552a-4a13-8e33-e7122dba3a55.png)\r\n\r\n执行用时：0ms(估计是bug)，内存6.6MB。\r\n### 优化思路2：\r\n- 既然后向遍历可以通过拆分来取消abs操作，前向遍历也是可以这么干的。\r\n- 先取index=n-1;并且result[i] = index - i;当出现`s[i] == c`，直接break出来，进行后续循环。\r\n- 后续循环时候，result[i] = i - index。这样abs函数就彻底消除了，又少了n个if，应该能再快一些。\r\n- 暂时就不写代码了，感兴趣的自行测试。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186382804","body":"- 题目[链接](https://leetcode.cn/problems/design-a-stack-with-increment-operation/submissions/)\n\n### 解题思路\n- 就是简单设计一个栈就行了，比较常规的数据结构题目\n- 唯一就是多了一个批量增加栈底n个元素值的功能，需要加一个min操作。\n- 由于max_size固定，所以采用数组做栈，而不是用链表或者动态数组。\n\n### 代码\n```cpp\n// Copyright 2022\n#include <iostream>\n\nclass CustomStack {\n private:\n  int * data;\n  int max_size;\n  int top;\n\n public:\n  explicit CustomStack(int maxSize): max_size(maxSize), top(0) {\n    data = new int[maxSize];\n  }\n  ~CustomStack() {\n    delete [] data;\n  }\n\n  void push(int x) {\n    if (top < max_size) {\n      data[top] = x;\n      ++top;\n    }\n  }\n\n  int pop() {\n    if (top > 0) {\n      --top;\n      return data[top];\n    } else {\n      return -1;\n    }\n  }\n\n  void increment(int k, int val) {\n    k = std::min(k, top);\n    for (int i = 0; i < k; ++i) {\n      data[i] += val;\n    }\n  }\n};\n\n\n\nint main() {\n  CustomStack stack(3);\n  stack.push(1);\n  stack.push(2);\n  std::cout << stack.pop() << std::endl;\n  stack.push(2);\n  stack.push(3);\n  stack.push(4);\n  stack.increment(5, 100);\n  stack.increment(2, 100);\n  std::cout << stack.pop() << std::endl;\n  std::cout << stack.pop() << std::endl;\n  std::cout << stack.pop() << std::endl;\n  std::cout << stack.pop() << std::endl;\n}\n```\n\n\n### 复杂度分析\n|            | push   | pop    | increment |\n| ---------- | ------ | ------ | --------- |\n| 时间复杂度 | $O(1)$ | $O(1)$ | $O(n)$    |\n| 空间复杂度 | $O(1)$ | $O(1)$ | $O(1)$    |\n\n\n\n### 成果\n\n![](https://s2.loli.net/2022/07/17/N4iGqMwluScfeE5.png)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186726697","body":"- 题目[连接](https://leetcode.cn/problems/decode-string/submissions/)\n### 代码\n```cpp\n// CopyRight 2022\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing std::string;\n\nclass Solution {\n public:\n  string decodeString(const string & s) {\n    std::string result;\n    std::vector<char> stack1;\n    std::vector<char> temp_stack;\n    int temp_num;\n    int p;\n    std::string temp_str;\n    for (const char & c : s) {\n      if (c != ']') {\n        stack1.emplace_back(c);\n      } else {\n        // 出栈取字符串\n        while(stack1.back() != '[') {\n          temp_stack.emplace_back(stack1.back());\n          stack1.pop_back();\n        }\n        // 去除 \"[\"\n        stack1.pop_back();\n        // 出栈取数组\n        p = 1;\n        temp_num = 0;\n        while((!stack1.empty()) && ('0' <= stack1.back()) && (stack1.back() <= '9')) {\n          temp_num += p * (stack1.back() - '0');\n          stack1.pop_back();\n          p *= 10;\n        }\n        // 获取当前临时字符串(记得反向)\n        temp_str.resize(temp_stack.size());\n        for (int i = 0; i < temp_stack.size(); ++i) {\n          temp_str[temp_stack.size() -1 - i] = temp_stack[i];\n        }\n        // std::cout << temp_num << \"\\t\" << temp_str << \"\\t\" << std::endl;\n        // 成果插入stack1(这里貌似可以优化, 因为会导致后续重复循环, 但是要是不插入，如何做到数据对齐？)\n        for (int i =0; i < temp_num; ++i) {\n          stack1.insert(stack1.end(), temp_str.begin(), temp_str.end());\n        }\n        //清空temp_stack\n        temp_stack.clear();\n        temp_str.clear();\n      }\n    }\n    // 打印最终结果\n    result.resize(stack1.size());\n    for (int i = 0; i < stack1.size(); ++i) {\n      result[i] = stack1[i];\n    }\n    return std::move(result);\n  }\n};\n\n\nint main() {\n  Solution s;\n  std::string res = s.decodeString(\"3[a2[c]]\");\n  std::cout << res << std::endl;\n  std::cout << s.decodeString(\"10[a]2[bc]\") << std::endl;\n  std::cout << s.decodeString(\"2[abc]3[cd]ef\") << std::endl;\n  std::cout << s.decodeString(\"abc3[cd]xyz\") << std::endl;\n}\n```\n\n### 复杂度\n- 时间：$O(n^2)$\n- 空间: $O(n)$\n\n### 结果\n![c61fb2e7d9c552d97327037bad88d5a3.png](https://s2.loli.net/2022/07/18/Y14wDcpRWVGiUMH.png)\n\n### 优化\n- 成果不插入到原stack，减少遍历次数与空间占用(那数据如何对齐？)\n- 中间不加入temp_str，减少空间占用（但是会增加更多遍历次数，不太划算）\n- 所以还是放弃了。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188539976","body":"- 题目[链接](https://leetcode.cn/problems/implement-queue-using-stacks/)\n### 思路\n- 用两个栈，两次遍历，实现队列的功能。\n- 貌似没啥难度，就是费空间，费时间\n\n\n### 代码\n```cpp\n// CopyRight 2022\n#include <stack>\n#include <iostream>\n\n\nclass MyQueue {\n private:\n  std::stack<int> tail_stack;\n  std::stack<int> head_stack;\n public:\n  MyQueue() {\n\n  }\n    \n  void push(int x) {\n    tail_stack.emplace(x);\n  }\n    \n  int pop() {\n    // tail倒腾给head\n    int res = -1;\n    // 先判断tail有没有新加入的元素\n    if (tail_stack.size() > 0) {\n      // 再把tail_stack的值放到head去\n      while (tail_stack.size() > 1) {\n        head_stack.emplace(tail_stack.top());\n        tail_stack.pop();\n      }\n      res = tail_stack.top();\n      tail_stack.pop();\n      // 然后再把head的值倒腾回tail，不然顺序会乱\n      while (head_stack.size() > 0) {\n        tail_stack.emplace(head_stack.top());\n        head_stack.pop();\n      }\n    }\n    return res;\n  }\n    \n  int peek() {\n    // 返回队列开头的元素，需要和pop做差不多相同的动作，只不过最后不需要Pop即可返回\n    // 先判断tail有没有新加入的元素\n    // tail倒腾给head\n    int res = -1;\n    // 先判断tail有没有新加入的元素\n    if (tail_stack.size() > 0) {\n      // 再把tail_stack的值放到head去\n      while (tail_stack.size() > 1) {\n        head_stack.emplace(tail_stack.top());\n        tail_stack.pop();\n      }\n      res = tail_stack.top();\n      // 然后再把head的值倒腾回tail，不然顺序会乱\n      while (head_stack.size() > 0) {\n        tail_stack.emplace(head_stack.top());\n        head_stack.pop();\n      }\n    }\n    return res;\n  }\n    \n  bool empty() {\n    return (head_stack.size() + tail_stack.size() == 0);\n  }\n};\n\n\nint main() {\n  MyQueue queue;\n  queue.push(1);\n  queue.push(2);\n  queue.push(3);\n  queue.push(4);\n  std::cout << queue.pop() << std::endl;\n  queue.push(5);\n  std::cout << queue.pop() << std::endl;\n  std::cout << queue.pop() << std::endl;\n  std::cout << queue.pop() << std::endl;\n  std::cout << queue.pop() << std::endl;\n}\n```\n\n### 复杂度分析\n\n| 复杂度类型 | push   | pop/peer | empty  |\n| ---------- | ------ | -------- | ------ |\n| 时间复杂度 | $O(1)$ | $O(n)$   | $O(1)$ |\n| 空间复杂度 | $O(1)$ | $O(1)$   | $O(1)$ |\n\n\n### 成果\n![b0bcb4b0943617a4ecce3fe6c3a13759.png](https://s2.loli.net/2022/07/19/5GCebk6zsHXtAEo.png)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189779524","body":"- 题目[链接](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\n- \n### code\n```bash\n// Copyright 2022\n#include <iostream>\n#include <vector>\n#include <stack>\n\n\nusing std::vector;\n\n\nclass Solution {\n private:\n  std::stack<int> my_stack;\n public:\n  int maxChunksToSorted(vector<int>& arr) {\n    int top = 0;\n    for(const int & x : arr) {\n      if (my_stack.size() > 0) {\n        if (x >= my_stack.top()) {\n          my_stack.emplace(x);\n        } else {\n          top = my_stack.top();\n          while (my_stack.size() > 0 && my_stack.top() > x) {\n            my_stack.pop();\n          }\n          my_stack.emplace(top);\n        }\n\n      } else {\n        my_stack.emplace(x);\n      }\n    }\n    return my_stack.size();\n  }\n};\n\n\nint main() {\n  /*\n    最多多少块？\n    观察可得，倒序情况下，不可分块，也就是1块整体\n    顺序情况下，理论上可以随便分块，切n-1刀，分成n块（虽然每块1）\n    这样来看，顺序排列的元素个数就是最终能分的块多少\n    利用单调栈求顺序排列元素有多少，即后入栈的元素必须大于先入栈的，否则元素出栈，\n    直到满足要求(或者栈为空), 再将栈顶元素加回来\n  */\n  Solution s1;\n  std::vector<int> v1 = {5,4,3,2,1};\n  std::cout << s1.maxChunksToSorted(v1) << std::endl;\n\n  Solution s2;\n  std::vector<int> v2 = {2,1,3,4,4};\n  std::cout << s2.maxChunksToSorted(v2) << std::endl;\n\n  Solution s3;\n  std::vector<int> v3 = {4, 2, 2, 1, 1};\n  std::cout << s3.maxChunksToSorted(v3) << std::endl;\n\n}\n```\n\n### 复杂度\n- 时间：$O(n)$, 空间$O(n)$\n\n### 成果\n![694cc3d3cd98d9c1eda495ae144297b0.png](https://s2.loli.net/2022/07/20/bWSV4ieN7mYEk5O.png)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190963482","body":"### 思路\n- 普通链表转循环链表，然后偏移head到对应位置就行了。\n- [链接](https://leetcode.cn/problems/rotate-list/submissions/)\n\n### 代码\n```cpp\n#include <iostream>\n\n/**\n * Definition for singly-linked list.\n */\n struct ListNode {\n     int val;\n     ListNode *next;\n     ListNode() : val(0), next(nullptr) {}\n     ListNode(int x) : val(x), next(nullptr) {}\n     ListNode(int x, ListNode *next) : val(x), next(next) {}\n };\nclass Solution {\npublic:\n  ListNode* rotateRight(ListNode* head, int k) {\n    // 旋转链表？循环链表!\n    // list.size() <500, 但是k可能会很大，所以先遍历一下List获取size比较合适\n    // 只要把链表变成循环链表，然后从size - (k % size)的位置断开，就能实现旋转链表了\n    // 第一步：获取最后一个节点，不包含null节点\n    ListNode * p1 = head;\n    std::size_t size = 0;\n    while (p1 && p1->next) {\n      size ++;\n      p1 = p1->next;\n    }\n    if (p1 && !p1->next) {\n      ++size;\n    }\n    // 第二步，构建循环链表(前提head不为null)\n    if (p1) {\n      p1->next = head;\n      // 第三步，计算head偏移位置\n      int n = size - (k % size);\n      // 第四步，偏移head,断开head前一个节点\n      ListNode * p2 = head;\n      for (int i = 1; i < n; ++i) {\n        p2 = p2->next;\n      }\n      head = p2->next;\n      p2->next = nullptr;\n    }\n    return head;\n  }\n};\n```\n\n### 复杂度\n- 时间：$O(n)$\n- 空间：$O(1)$\n\n### 结果\n![2a3d738bd20baaae45bf663d26fe7741.png](https://s2.loli.net/2022/07/21/JOTipmMgB685HsA.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192121602","body":"### 题目\r\n[链接](https://leetcode.cn/problems/swap-nodes-in-pairs/)\r\n### 思路\r\n// 节点交换，首先想到的自然是长短指针\r\n// 因为第二轮交换的时候，2i从指向2i+i变成了指向2i+2,所以需要一个pre指针\r\n### 代码\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * \r\n */\r\n#include <iostream>\r\n#include <vector>\r\n#include <initializer_list>\r\n\r\n\r\nstruct ListNode {\r\n    int val;\r\n    ListNode *next;\r\n    ListNode() : val(0), next(nullptr) {}\r\n    ListNode(int x) : val(x), next(nullptr) {}\r\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n  ListNode* swapPairs(ListNode* head) {\r\n    \r\n    ListNode * short_p = head;\r\n    ListNode * long_p = head;\r\n    ListNode * prev = nullptr;\r\n    ListNode * result = head;\r\n    int i = 0;\r\n    while (short_p && short_p->next) {\r\n      // long_p 比short多走一步\r\n      if (long_p && long_p->next) {\r\n        long_p = long_p->next;\r\n      } else {\r\n        break;\r\n      }\r\n      // 开始节点交换操作\r\n      short_p->next = long_p->next;\r\n      long_p->next = short_p;\r\n      if (prev) {\r\n        prev->next = long_p;\r\n      }\r\n\r\n      if (i == 0) {\r\n        result = long_p;\r\n      }\r\n      // 然后， short_p 走一步，long_p走两步，均走到第2i+ 1个节点\r\n      prev = short_p;\r\n      if(short_p) {\r\n        short_p = short_p->next;\r\n        long_p = short_p;\r\n      }\r\n      i += 2;\r\n    }\r\n    return result;\r\n  }\r\n};\r\n\r\n\r\nint main() {\r\n  // 自定义初始化一个列表\r\n  std::vector<int> v1(std::initializer_list<int>({1, 2, 3, 4}));\r\n  ListNode * head = nullptr;\r\n  if (v1.size() > 0) {\r\n    head = new ListNode(v1[0]);\r\n  }\r\n  ListNode * p = head;\r\n  ListNode * temp = nullptr;\r\n  for (int i = 1; i < v1.size(); ++i) {\r\n    temp = new ListNode(v1[i]);\r\n    p->next = temp;\r\n    p = p->next;\r\n  }\r\n  // 打印结果\r\n  p = head;\r\n  std::cout << \"input list\" << std::endl;\r\n  while(p) {\r\n    std::cout << p->val << \" \";\r\n    p = p->next;\r\n  }\r\n  std::cout << std::endl;\r\n\r\n  // 调用函数\r\n  Solution s;\r\n  ListNode * new_head = s.swapPairs(head);\r\n  p = new_head;\r\n  // 打印结果\r\n  std::cout << \"output list\" << std::endl;\r\n  while(p) {\r\n    std::cout << p->val << \" \";\r\n    p = p->next;\r\n  }\r\n  std::cout << std::endl;\r\n  // 销毁链表\r\n  p = new_head;\r\n  while (p) {\r\n    temp = p;\r\n    p = p->next;\r\n    delete temp;\r\n  }\r\n  std::cout << \"list destory\" << std::endl;\r\n}\r\n```\r\n\r\n### 复杂度\r\n- 时间: $O(n)$\r\n-  空间: $O(1)$\r\n\r\n### 结果\r\n![757f603c8d945754ad633cc404609b96.png](https://s2.loli.net/2022/07/22/bzRLXyUZeAPWu5V.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193104535","body":"### 题目链接\n- [链接](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/submissions/)\n\n### 思路\n- 根据平衡二叉树的定义，先找中间节点。然后把剩下的左右两边递归，找中间节点，最后把中间节点与左边中间和右边中间节点相连接，构成树结构，然后返回。\n- 难点1：如何找中间节点？可以利用长短指针，设定一个开始，结束值，然后短指针走一步，长指针走两步，当长指针走到末尾时，短指针的位置就是中间节点。注意：开始结束值不能一样，如果一样，则返回nullptr。\n- 难点2：如何递归？先找到链表的中间节点。然后写一个创建树的函数，依据中间节点创建树的根节点。然后依次找左右两边中间节点，最后左右两边也创建树（递归），最后将树的根节点与左右边两颗子树相连。注意：中间节点必定不为null值。\n\n\n### 代码实现\n```cpp\n#include <iostream>\n#include <vector>\n\n/**\n * Definition for singly-linked list.\n **/\n\nstruct ListNode {\n  int val;\n  ListNode *next;\n  ListNode() : val(0), next(nullptr) {}\n  ListNode(int x) : val(x), next(nullptr) {}\n  ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n \n/**\n * Definition for a binary tree node.\n * */\n\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode() : val(0), left(nullptr), right(nullptr) {}\n  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n public:\n  TreeNode* sortedListToBST(ListNode* head) {\n    // 思路：利用长短指针，找到中间节点\n    // 中间节点作为树根节点，然后依次递归左右两边剩余节点构成子树 \n    ListNode * mid = find_midden(head);\n    // 构建树的根节点\n    // 利用递归构建树\n    TreeNode * tree = create_tree(head, mid);\n    return tree;\n  }\n\n  TreeNode *  create_tree(ListNode * head, ListNode * mid, ListNode * end=nullptr) {\n    if (mid) {\n      // 用于创建一颗数，返回树的根节点\n      // 构建树的根节点\n      TreeNode * root_tree = new TreeNode(mid->val);\n      if (mid && mid->next) {\n        // 对右子树也执行创建树的操作\n        ListNode * right = mid->next;\n        ListNode * right_mid = find_midden(right, end);\n        TreeNode * right_tree = create_tree(right, right_mid, end);\n        root_tree->right = right_tree;\n      }\n      ListNode * left = find_midden(head, mid);\n      // 对左子树继续执行创建树的操作\n      TreeNode * left_tree = create_tree(head, left, mid);\n      root_tree->left = left_tree;\n      return root_tree;\n    } else {\n      return nullptr;\n    }\n  }\n\n\n  ListNode * find_midden(ListNode * head, ListNode * end=nullptr) {\n    // 该函数用于找中间节点(帮助左边的链表找到中间节点)\n    // end节点为边界，默认为null\n    if (head && head != end) {\n      ListNode * short_p = head;\n      ListNode * long_p = head;\n      while (long_p != end  && long_p->next != end) {\n        short_p = short_p->next;\n        long_p = long_p->next->next;\n      }\n      return short_p;\n    } else {\n      return nullptr;\n    }\n  }\n};\n\n\nint main() {\n  // 自定义初始化一个列表\n  std::vector<int> v1(std::initializer_list<int>({1, 2, 3, 4}));\n  ListNode * head = nullptr;\n  if (v1.size() > 0) {\n    head = new ListNode(v1[0]);\n  }\n  ListNode * p = head;\n  ListNode * temp = nullptr;\n  for (int i = 1; i < v1.size(); ++i) {\n    temp = new ListNode(v1[i]);\n    p->next = temp;\n    p = p->next;\n  }\n  // 打印结果\n  p = head;\n  std::cout << \"input list\" << std::endl;\n  while(p) {\n    std::cout << p->val << \" \";\n    p = p->next;\n  }\n  std::cout << std::endl;\n\n  // 调用函数\n  Solution s;\n  TreeNode * new_head = s.sortedListToBST(head);\n  // 销毁链表\n  p = head;\n  while (p) {\n    temp = p;\n    p = p->next;\n    delete temp;\n  }\n  std::cout << \"list destory\" << std::endl;\n}\n```\n\n\n### 复杂度\n- 空间复杂度：$O(n)$\n- 时间复杂度：每次寻找中间节点需要遍历n+2/n次，每次二分成两段链表，所以时间就是$0(n*log(n))$\n\n\n### 最终结果\n![2f39227d6accb5ea88a24f6ab9301009.png](https://s2.loli.net/2022/07/23/QxWq8MsG6ic7N3F.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193250016","body":"## 题目链接\r\n- [链接](https://leetcode.cn/problems/intersection-of-two-linked-lists/submissions/)\r\n\r\n## 解题思路\r\n- 找出链表的相交节点，如果相交，返回相交节点，否则返回NULL\r\n- 最简单的方法自然是用dict来记录其中一个链表，然后判断另外一个链表是否有重复\r\n- 不过题目要求空间是O(1), 所以大概率还是长短指针\r\n- 用长短指针，先判断两个链表的长度\r\n- 看下哪个链表长，长的为A链表\r\n-  如果相交，则最终有k个节点为共同节点\r\n-  1<= k<=n\r\n-  先让headA走(m-n)个节点\r\n-  最终两边节点同时到达末尾，如果指针相同则相交，返回相交节点即可。\r\n\r\n\r\n## 代码\r\n```cpp\r\n#include <iostream>\r\n\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n */\r\n\r\nstruct ListNode {\r\n    int val;\r\n    ListNode *next;\r\n    ListNode(int x) : val(x), next(NULL) {}\r\n};\r\n\r\n\r\nclass Solution {\r\npublic:\r\n  ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n    // 找出链表的相交节点，如果相交，返回相交节点，否则返回NULL\r\n    // 最简单的方法自然是用dict来记录其中一个链表，然后判断另外一个链表是否有重复\r\n    // 不过题目要求空间是O(1), 所以大概率还是长短指针\r\n    // 用长短指针，先判断两个链表的长度\r\n    int m = size(headA);\r\n    int n = size(headB);\r\n    // 看下哪个链表长，长的为A链表\r\n    if (n > m) {\r\n      NodeList * temp = headA;\r\n      headA = headB;\r\n      headB = temp;\r\n      int t = n;\r\n      n = m;\r\n      m = t;\r\n    }\r\n    // 如果相交，则最终有k个节点为共同节点\r\n    // 1<= k<=n\r\n    // 先让headA走(m-n)个节点,\r\n    ListNode * p1 = headA;\r\n    for (int i = 0; i < m - n; ++i) {\r\n      p1 = p1->next;\r\n    }\r\n    ListNode * p2 = headB;\r\n    while(p1 && p2) {\r\n      if (p1 == p2) {\r\n        return p1;\r\n      } else {\r\n        p1 = p1->next;\r\n        p2 = p2->next;\r\n      }\r\n    }\r\n    return nullptr;\r\n\r\n  }\r\n\r\n  int size(ListNode * head) {\r\n    ListNode * p = head;\r\n    int result = 0;\r\n    while (p) {\r\n      ++result;\r\n      p = p->next;\r\n    }\r\n    return result;\r\n  }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：$O(m+n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n## 成果分享\r\n\r\n![截图 2022-07-24 13-14-11](https://user-images.githubusercontent.com/28218658/180633545-2bc1bfa5-5bf7-4954-8dfa-caf8b59d4f08.png)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193645676","body":"## 题目链接\n[链接](https://leetcode.cn/problems/linked-list-cycle-ii/)\n\n## 思路\n- 快慢指针，快指针2步，慢指针一步，两者相等时有环\n- 但是题目需要的是给出环的位置。\n- 假设环在第k个节点形成，环的长度为m\n- 当慢指针走到第k个位置时候，快指针走到第2k个位置。\n- 相当于,快指针比慢指针先走k步。\n- 设定慢指针从k出发，走了x步后，快慢指针相遇\n- 此时，慢指针走x步,快指针走了k+2x步，且快指针比慢指针多n圈。\n- 即 k + 2x - nm = x; x = nm - k;\n- 从初始点来看，快指针先走k步，相遇点距离初始点还差k步。\n- 所以，另外设一个新指针，新指针从head出发，新指针与slow指针一致。\n- 当新指针走了k步到初始点时，slow指针刚好也走到初始点，此时返回 \n\n## 代码\n```cpp\n/**\n * Definition for singly-linked list.\n * \n */\n#include <vector>\n#include <iostream>\n\n\nstruct ListNode {\n  int val;\n  ListNode *next;\n  ListNode(int x) : val(x), next(nullptr) {}\n};\nclass Solution {\npublic:\n  ListNode *detectCycle(ListNode *head) {\n    ListNode * fast = head;\n    ListNode * slow = head;\n    while (true)\n    {\n      if(fast && fast->next) {\n        fast = fast->next->next;\n        slow = slow->next;\n        if (fast == slow) { \n          break;\n        }\n      } else {\n        return nullptr;\n      }\n    }\n    // 将fast当成新指针\n    fast = head;\n    while(fast != slow) {\n      fast = fast->next;\n      slow = slow->next;\n    }\n    return fast;\n  }\n};\n\n\nint main() {\n  // 自定义初始化一个列表\n  std::vector<int> v1(std::initializer_list<int>({3, 2, 0, -4}));\n  int n = 1;\n  ListNode * head = nullptr;\n  if (v1.size() > 0) {\n    head = new ListNode(v1[0]);\n  }\n  ListNode * p = head;\n  ListNode * temp = nullptr;\n  for (int i = 1; i < v1.size(); ++i) {\n    temp = new ListNode(v1[i]);\n    p->next = temp;\n    p = p->next;\n  }\n\n    // 打印结果\n  p = head;\n  std::cout << \"input list\" << std::endl;\n  while(p) {\n    std::cout << p->val << \" \";\n    p = p->next;\n  }\n  std::cout << std::endl;\n\n  // 增加一个环\n  ListNode * tail = nullptr;\n  ListNode * circle_p = nullptr;\n  circle_p = head;\n  for (int i = 0; i < n; ++i) {\n    circle_p = circle_p->next;\n  }\n  tail = head;\n  for (int i = 0; i < v1.size() - 1; ++i) {\n    tail = tail->next;\n  }\n  tail->next = circle_p;\n\n  // 调用函数\n  Solution s;\n  ListNode * new_head = s.detectCycle(head);\n  p = new_head;\n  // 打印结果\n  if (new_head) {\n    std::cout << \"output :\" << new_head->val << std::endl;\n  } else {\n    std::cout << \"no crcle\" << std::endl;\n  }\n\n  std::cout << std::endl;\n\n  // 销毁链表\n  // 销毁前把tail->置为nullptr\n  tail->next = nullptr;\n  p = new_head;\n  while (p) {\n    temp = p;\n    p = p->next;\n    delete temp;\n  }\n  std::cout << \"list destory\" << std::endl;\n}\n```\n\n## 复杂度分析\n- 时间：$O(n)$\n- 空间：$O(1)$\n\n\n## 成果\n![56909a06c97afcb197f3440fecc1016a.png](https://s2.loli.net/2022/07/25/nk8AVm1tU9QIeMS.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195122312","body":"## 题目链接\n\n## 代码\n```cpp\n#include <map>\n#include <iostream>\n#include <utility>\n\nclass Node {\n public:\n  int key;\n  int value;\n  Node * next;\n  Node * prev;\n  Node(int key, int value): key(key), value(value) {\n    next = nullptr;\n    prev = nullptr;\n  }\n};\n\n\n\nclass MyListNode {\n private:\n  Node * head;\n  Node * tail;\n\n public:\n  MyListNode():head(nullptr), tail(nullptr){}\n  void push_front(Node * new_node) {\n    if (head == nullptr) {\n      head = new_node;\n      tail = head;\n    } else {\n      new_node->next = head;\n      head->prev = new_node;\n      head = new_node;\n    }\n  }\n\n  void push_back(Node * new_node) {\n    // 改成指针操作，方便地址不变\n    if (head == nullptr) {\n      tail = new_node;\n      head = new_node;\n    } else {\n      tail->next = new_node;\n      new_node->prev = tail;\n      tail = new_node;\n    }\n  }\n\n  void pop_back() {\n    // 删除最后一个节点\n    if (tail != nullptr) {\n      Node * pre_node = tail->prev;\n      // 判断是否是单节点\n      if (pre_node != nullptr) {\n        pre_node->next = nullptr;\n        tail = pre_node;\n      } else {\n        tail = nullptr;\n        head = nullptr;\n      }\n    }\n  }\n\n  void remove_node(Node * node) {\n    Node * pre_node = node->prev;\n    if (pre_node != nullptr) {\n      Node * next_node = node->next;\n      pre_node->next = next_node;\n      if (next_node != nullptr) {\n        next_node->prev = pre_node;\n      } else {\n        // 说明tail到头了，需要将tail移到pre的位置\n        tail = pre_node;\n      }\n    } else {\n      // 说明该节点应该是head节点，没有prev\n      Node * next_node = node->next;\n      if (next_node != nullptr) {\n        head = next_node;\n        next_node->prev = nullptr;\n      } else {\n        // 说明是单节点\n        head = tail = nullptr;\n      }\n    }\n  }\n  Node * back() {\n    return tail;\n  }\n};\n\nclass LRUCache {\n private:\n  int capacity;\n  int size;\n  std::map<int, Node *> dict1;\n  MyListNode cache;\n public:\n  LRUCache(int capacity): capacity(capacity), size(0){}\n  ~LRUCache() {\n    // 清理空间\n    auto it = dict1.begin();\n    while(it != dict1.end()) {\n      delete it->second;\n      ++it;\n    }\n  }\n    \n  int get(int key) {\n    int temp = dict1.count(key);\n    // temp会返回啥？\n    if (temp > 0) {\n      // 最简单的方法就是将数据重新入dict即可\n      Node * res = dict1.at(key);\n      int value = res->value;\n      put(key, res->value);\n      return value;\n    } else {\n      return -1;\n    }\n  }\n    \n  void put(int key, int value) {\n    // 首先判断key是否在dict中，如果不再\n    // 如果key在dict中，先将旧的cache清理，然后新cache，再更新数据。\n    // 再判断dict.size() 是否超过capacity\n    // 否则，说明容量不够，利用队列，将旧数据推出，旧数据可以利用一个双链表进行管理\n    if (dict1.count(key) > 0) {\n      // 清理旧数据缓存\n      Node * old_node = dict1.at(key);\n      cache.remove_node(old_node);\n      dict1.erase(old_node->key);\n      delete old_node;\n\n    } else if (size < capacity) {\n      ++size;\n\n    } else {\n      // 清理最后一个数据\n      Node * last_node = cache.back();\n      dict1.erase(last_node->key);\n      cache.pop_back();\n      delete last_node;\n    }\n\n    Node * new_node =  new Node(key, value);\n    dict1.insert(std::make_pair(key, new_node));\n    cache.push_front(new_node);\n  }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\nint main() {\n  LRUCache cache(2);\n  cache.put(1, 1);\n  cache.put(2, 2);\n  std::cout << cache.get(1) << std::endl;\n  cache.put(3, 3);\n  std::cout << cache.get(2) << std::endl;\n}\n```\n\n- 貌似有重复开辟空间的嫌疑，可以优化一下\n- 优化后（优化后本地可跑likou跑了会出错，提示空指针重复利用，不知啥情况）\n```cpp\n\nclass LRUCache {\n private:\n  int capacity;\n  int size;\n  std::map<int, Node *> dict1;\n  MyListNode cache;\n public:\n  LRUCache(int capacity): capacity(capacity), size(0){}\n  ~LRUCache() {\n    // 清理空间\n    auto it = dict1.begin();\n    while(it != dict1.end()) {\n      delete it->second;\n      ++it;\n    }\n  }\n    \n  int get(int key) {\n    int temp = dict1.count(key);\n    if (temp > 0) {\n      // 最简单的方法就是将数据重新入dict即可\n      Node * res = dict1.at(key);\n      int value = res->value;\n      put(key, res->value);\n      return value;\n    } else {\n      return -1;\n    }\n  }\n    \n  void put(int key, int value) {\n    // 首先判断key是否在dict中，如果不再\n    // 如果key在dict中，先将旧的cache清理，然后新cache，再更新数据。\n    // 再判断dict.size() 是否超过capacity\n    // 否则，说明容量不够，利用队列，将旧数据推出，旧数据可以利用一个双链表进行管理\n    // 空间优化，如果已有旧数据，则动一下缓存,然后加dict的指针即可\n    if (dict1.count(key) > 0) {\n      // 清理旧数据缓存\n      Node * old_node = dict1.at(key);\n      cache.remove_node(old_node);\n      cache.push_front(old_node);\n      old_node->value = value;\n\n    } else {\n      if (size < capacity) {\n        ++size;\n\n      } else {\n        // 清理最后一个数据\n        Node * last_node = cache.back();\n        dict1.erase(last_node->key);\n        cache.pop_back();\n        delete last_node;\n      }\n      Node * new_node =  new Node(key, value);\n      dict1.insert(std::make_pair(key, new_node));\n      cache.push_front(new_node);\n    }\n  }\n};\n```\n## 复杂度\n- 时间：put: O(1), get: O(1)\n- 空间：O(n)\n\n## 成果\n![cf8b66fdd9384b4f2ea2f7c17df26f58.png](https://s2.loli.net/2022/07/26/b6OjyczS3U2MKsF.png)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196195321","body":"## 题目链接\n- [链接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/)\n\n## 代码\n```cpp\n#include<iostream>\n/**\n * Definition for a binary tree node.\n */\n\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode() : val(0), left(nullptr), right(nullptr) {}\n  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\nclass Solution {\npublic:\n  int maxDepth(TreeNode* root) {\n    if (root != nullptr) {\n      int left_res = maxDepth(root->left) + 1;\n      int right_res = maxDepth(root->right) + 1;\n      return std::max(left_res, right_res);\n    } else{\n      return 0;\n    }\n  }\n};\n```\n\n## 复杂度\n- 时间：O(n)\n- 空间：O(n)，因为用了递归，所以每层计算结果都要入栈。\n\n- 由于深度为常量，可以用constexpr来优化一下。\n- [参考链接](https://changkun.de/modern-cpp/zh-cn/02-usability/)\n```cpp\nclass Solution {\npublic:\n  constexpr int maxDepth(TreeNode* root) {\n    return root != nullptr ? std::max(maxDepth(root->left) + 1, maxDepth(root->right) + 1): 0;\n  }\n};\n```\n\n## 结果\n![6fa5e9ab520238b8d4f5204f7c5deead.png](https://s2.loli.net/2022/07/27/mUksPtVG1uYf85Z.png)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197559252","body":"## 题目链接\n- [链接](https://leetcode.cn/problems/same-tree/submissions/)\n## 代码\n```cpp\n/**\n * Definition for a binary tree node.\n */\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\n\nclass Solution {\npublic:\n  bool isSameTree(TreeNode* p, TreeNode* q) {\n    if (p && q && p->val == q->val) {\n      if (isSameTree(p->left, q->left) && isSameTree(p->right, q->right)) {\n        return true;\n      } else {\n        return false;\n      }\n    } else if (p == nullptr && q == nullptr) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n};\n```\n\n## 复杂度\n- 时间：O(n)\n- 空间：O(n)\n\n## 成果\n![98a51873fdcc127907ee9bc94905acb9.png](https://s2.loli.net/2022/07/28/5O8GFzIig6Pcf9m.png)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185158822","body":"## 代码（注释解析了每一步的思路）\n\nclass Solution:\n\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        #将数组转化为str形式存储\n        temp = \" \"\n        for i in num:\n            temp = temp + str(i)\n        #整数相加\n        number = int(temp) + k\n        result = []\n        for j in str(number):\n            result.append(int(j))\n        return result\n## 复杂度 \n\n时间复杂度 O(n)\n空间复杂度O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186111174","body":"## 思路\n\n>1.先试用一次循环记录下所有c出现的位置并记录在have_c中\n\n>2.再次循环每一个字母，利用其所在的index分别与have_c相减获取其绝对值并记录最小值\n将最小值记录在result中输出\n\n##代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        have_c = []\n        for i in range(len(s)):\n            if s[i] == c:\n                have_c.append(i)\n        print(have_c)\n        result = []\n        for i in range(len(s)):\n            if s[i] == c:\n                result.append(0)\n            else:\n                min = 99999999999\n                for j in range(len(have_c)):\n                    if min > abs(have_c[j] - i):\n                        min = abs(have_c[j] - i)\n                result.append(min)\n        return result\n\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n^2)\n> + 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186411631","body":"## 思路\r\n\r\n> 注意push时不超过最大maxsize，pop时stack仍有数字\r\n\r\n##代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.max_len = maxSize\r\n        self.current_len = 0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_len:\r\n            self.stack.append(x)\r\n            self.current_len += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0: return -1\r\n        else:\r\n            self.current_len -= 1\r\n            return self.stack.pop()\r\n\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        less = min(k,len(self.stack))\r\n        for i in range(0,less):\r\n            self.stack[i] += val\r\n\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: pop push 为O(1) increment 为O(n)\r\n> + 空间复杂度: O(maxsize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186624023","body":"## 思路\n\n> 判断遇到的是字符串还是数字还是括号，分别作不同处理\n\n##代码\n\n```python\n#\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, times = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([times, res])\n                res, times = \"\", 0\n            elif c == ']':\n                cur_times, last_res = stack.pop()\n                res = last_res + cur_times * res\n            elif '0' <= c <= '9':\n                #判断多位数字情况\n                times =  times * 10 + int(c)            \n            else:\n                res += c\n        return res\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188417974","body":"## 思路\n\n> 使用两个stack来实现队列需求\n\n##代码\n\n```python\n#\nclass MyQueue:\n\n    def __init__(self):\n        #建立input，output两个stack\n        self.input = []\n        self.output = []\n\n\n    def push(self, x: int) -> None:\n        #将新元素放进input stack中\n        self.input.append(x)\n\n\n    def pop(self) -> int:\n        #判断是否为空\n        if self.empty():\n            return None\n        if self.output:\n            return self.output.pop()\n        else:\n            #若不为空，则将input中的pop到output中\n            while self.input:\n                val = self.input.pop()\n                self.output.append(val)\n            #pop output的元素\n            return self.output.pop()\n\n\n\n    def peek(self) -> int:\n        res = self.pop()\n        self.output.append(res)\n\n        return res\n\n\n\n    def empty(self) -> bool:\n        #当两个stack都为空时，才return true\n        if not (self.output or self.input):\n            return True \n        else:\n            return False\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n)\n> + 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189631616","body":"## 借鉴官方题解思路\n\n> + 思路描述\n\n##代码\n\n```python\n#\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        dict_a = collections.defaultdict(int)\n        dict_b = collections.defaultdict(int)\n        max_ans = 0\n        for i,j in zip(arr,sorted(arr)):\n            dict_a[i] += 1\n            dict_b[j] += 1\n            if dict_a == dict_b: max_ans+= 1\n        return max_ans\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190849726","body":"## 思路\n\n> 使用快指针指向新节点的第一位，慢指针获取新节点的最后一位，在对链表进行拼接操作\n\n##代码\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        #初始临界条件\n        if (not head or not head.next): return head\n        total = 0\n        cur = head\n        #获取整个链表的长度\n        while cur:\n            cur = cur.next\n            total += 1\n        #取余数避免重复循环\n        k = k % total\n        #创建快慢指针\n        slow = head\n        fast = head\n        while fast.next:\n            if (k <= 0):\n                slow = slow.next\n            k = k -1 \n            fast = fast.next\n        #快指针的位置即为新链表的头节点\n        fast.next = head\n        result = slow.next\n        slow.next = None\n        return result\n\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192012081","body":"## 思路\n\n> 参考题解使用两个节点a,b以及a的前节点和b的后节点进行位置交换操作\n\n##代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        result = ListNode()\n        result.next = head.next\n        pre = result\n        while head and head.next:\n            second = head.next\n            second_next = second.next\n            second.next = head\n            pre.next = second\n            head.next = second_next\n\n            pre = head\n            head = second_next\n        return result.next\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193043083","body":"##代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        #当头节点为空时\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        slow = head\r\n        fast = head\r\n        #设定左区间边界\r\n        pre = head\r\n        #遍历slow到链表的中点\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        pre.next = None\r\n        root = TreeNode(slow.val)\r\n        \r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(log(n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193241954","body":"## 思路\n\n> 先是用哈希表存储heada中的所有值，遍历headb查找是否有相同的值存在再哈希表中\n\n##代码\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        temp = set()\n        cura,curb = headA,headB \n        while cura:\n            temp.add(cura)\n            cura = cura.next\n        #print(temp)\n        while curb:\n            if curb in temp:\n                return curb\n            curb = curb.next\n        return None\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193410569","body":"## 思路\n\n> + 使用双指针计算，两个指针第二次相遇的位置\n\n##代码\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow,fast = head,head\n        x = None\n        #第一次相遇\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n            #如果仍未空则说明head为空return None\n        if not x:\n            return None\n        #记录第二次相遇位置\n        slow = head\n        while slow != x:\n            slow = slow.next\n            x = x.next\n        return slow\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194746623","body":"## 思路\n\n双指针+哈希表\n\n##代码\n\n```python\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        # 新建两个节点 head 和 tail\n        self.head = ListNode()\n        self.tail = ListNode()\n        # 初始化链表为 head <-> tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法\n    def move_node_to_tail(self, key):\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            node.prev = self.tail.prev\n            node.next = self.tail\n            self.tail.prev.next = node\n            self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            # 如果已经在链表中了久把它移到末尾（变成最新访问的）\n            self.move_node_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\n            # 但是需要更新字典该值对应节点的value\n            self.hashmap[key].value = value\n            # 之后将该节点移到末尾\n            self.move_node_to_tail(key)\n        else:\n            if len(self.hashmap) == self.capacity:\n                # 去掉哈希表对应项\n                self.hashmap.pop(self.head.next.key)\n                # 去掉最久没有被访问过的节点，即头节点之后的节点\n                self.head.next = self.head.next.next\n                self.head.next.prev = self.head\n            # 如果不在的话就插入到尾节点前\n            new = ListNode(key, value)\n            self.hashmap[key] = new\n            new.prev = self.tail.prev\n            new.next = self.tail\n            self.tail.prev.next = new\n            self.tail.prev = new\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n)\n> + 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196102751","body":"## 思路\n\n> + 递归遍历\n##代码\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        return 1+ max(self.maxDepth(root.left),self.maxDepth(root.right))\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197487272","body":"## 思路\n\n> + 坑点：在：\n[1,2]\n[1,null,2]\n测试样例中必须结合递归左右树才可以判断为false\n##代码\n\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not q and not p:\n            return True\n        if not q or not p:\n            return False\n        return q.val == p.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(max(p,q))\n> + 空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185161504","body":"### 思路\r\n目标：实现两个大非负整数相加<br>\r\n背景：像整型integer和long的数据都是有数据范围的\r\n\r\n### 代码\r\n```java\r\n    class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n                // 先把k转换为数组\r\n        char[] chars = String.valueOf(k).toCharArray();\r\n        int maxLength = Math.max(num.length,chars.length);\r\n        int minLength = Math.max(num.length,chars.length);\r\n        int tmp = 0;\r\n        int[] result = new int[maxLength + 1];\r\n        for (int offset = 0; offset < minLength; offset++) {\r\n            int numIdx = num.length - 1 - offset;\r\n            int charsIdx = chars.length -1 - offset;\r\n            if (numIdx>=0&&charsIdx>=0){\r\n                int sum = chars[charsIdx]-'0'+num[numIdx]+tmp;\r\n                tmp = sum/10;\r\n                int y = sum%10;\r\n                result[maxLength-offset] = y;\r\n            }else if (numIdx>=0){\r\n                int sum = num[numIdx]+tmp;\r\n                tmp = sum/10;\r\n                int y = sum%10;\r\n                result[maxLength-offset] = y;\r\n            }else {\r\n                int sum = chars[charsIdx]-'0'+tmp;\r\n                tmp = sum/10;\r\n                int y = sum%10;\r\n                result[maxLength-offset] = y;\r\n            }\r\n        }\r\n        if (tmp!=0){\r\n            result[0] = tmp;\r\n        }\r\n        if (result[0]==0){\r\n            return Arrays.stream(result).skip(1).boxed().collect(Collectors.toList());\r\n        }else {\r\n            return Arrays.stream(result).boxed().collect(Collectors.toList());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186156714","body":"### 思路\n- 方法一：暴力破解，对象下标为i的元素，从数组nums中查找离下标i最近且值为target的下标。 \n- 方法二：两次遍历（今日学习到的），一次从左到右的便利，对于下标为i的数据，我们可以得到左边离它最近的位置，通过两次遍历可以解决问题。\n\n```java\n//方法一\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        // 方法一: 暴力算法\n        // 针对i下标的数据，在数组中查询最近的一个\n        char[] chars = s.toCharArray();\n        int[] result = new int[chars.length];\n        for (int i = 0; i < chars.length; i++) {\n            int offset = s.length();\n            result[i] = getLocalOffset(chars,c,i);\n        }\n        return result;\n    }\n\n    private  int getLocalOffset(char[] array, char target, int idx) {\n        char value = array[idx];\n        if (value==target){\n            return 0;\n        }\n        int tmp = 100000;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i]==target&&Math.abs(i-idx)<tmp) {\n                tmp = Math.abs(i-idx);\n            }\n        }\n        return tmp;\n    }\n}\n```\n### 复杂度\n时间复杂度O(n^2)<br>\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186515973","body":"### 思路\n栈的特点，先进先出，利用数组来实现，下标pushIdx永远指向下一个元素的位置，则pop的位置为pushIdx-1\n### 代码\n```java\nclass CustomStack {\n\n    Integer[] values;\n    int pushIdx = 0;\n\n    public CustomStack(int maxSize) {\n        this.values = new Integer[maxSize];\n    }\n    \n    public void push(int x) {\n        if(pushIdx >= values.length){\n            return;\n        }else{\n            values[pushIdx]=x;\n            pushIdx ++;\n        }\n    }\n    \n    public int pop() {\n        if(pushIdx-1>=0){\n            return values[(pushIdx--)-1];\n        }else{\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        int i = 0;\n        while(i<pushIdx&&i<k){\n            values[i]=values[i]+val;\n            i++;\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186857952","body":"### 思路\n把经过编码的字符串，还原成解码后的字符串\n需要解析匹配口号，如[]，可以利用栈\n```java\nclass Solution {\n    public String decodeString(String s) {\n        //  把经过编码的字符串，还原成解码后的字符串   k[encoded_string]\n        // 我们需要解析匹配括号,如[] ，想到利用栈\n        char[] chars = s.toCharArray();\n        Stack<Character> stack = new Stack<>();\n        int idx = 0;\n        while (true){\n            if (idx>=chars.length){\n                break;\n            }\n            char val = chars[idx];\n            if (val==']'){\n                String blabla = getString(stack);\n                for (char c : blabla.toCharArray()) {\n                    stack.push(c);\n                }\n            }else{\n                stack.push(val);\n            }\n            idx++;\n        }\n        String reversedResult = \"\";\n        while (!stack.isEmpty()){\n            Character pop = stack.pop();\n            reversedResult += pop;\n        }\n\n        return new StringBuilder(reversedResult).reverse().toString();\n    }\n\n    private String getString(Stack<Character> stack) {\n        if (stack.isEmpty()){\n            return \"\";\n        }\n        String reversedVal = \"\";\n        while (true){\n            Character pop = stack.pop();\n            if (pop=='['){\n                break;\n            }else {\n                reversedVal += pop;\n            }\n        }\n        StringBuilder sb = new StringBuilder(reversedVal);\n        String value = sb.reverse().toString();\n        String reverseCount = \"\";\n        while (!stack.isEmpty()){\n            Character countNumb = stack.peek();\n            if (countNumb-'9'>0){\n                break;\n            }\n            reverseCount+=countNumb;\n            stack.pop();\n        }\n        Integer count = Integer.valueOf(new StringBuilder(reverseCount).reverse().toString());\n        String result = \"\";\n        for (Integer i = 0; i < count; i++) {\n            result+=value;\n        }\n        return result;\n    }\n}\n```\n### 复杂度\n时间复杂度：O(n) <br>\n空间复杂度: O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189934192","body":"### 思路\n正如[2,1,3,4,4]分片成[2,1][3][4][4]\n我们可以观察发现**前面的分段**中的最小值小于**后面的分段**<br>\n我们用chunk[]数组来代表分片的结果，fmax(chunk[x])代表以chunk[x]分片中的最大值,fmin(chunk[x])代表chunk[x]分片中的最小值<br>\n则对于正确的分段数组有,对于0<=i<j来说，始终有**fmax(chunk[i])< fmin(chunk[j])**\n\n对于我们如何分片的指导:\n- 对于下标为i的元素，加入当前chunk，如果fmax(chunk)<待处理数据中最小的值，那么这个chunk就可以分出来了\n\n### 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        // 我们用chunk[]数组来代表分片的结果\n        // fmax(chunk[x])代表以chunk[x]分片中的最大值,fmin(chunk[x])代表chunk[x]分片中的最小值\n        // 则对于0<=i<j来说，始终有fmax(i)< fmin(chunk[j])\n        // 贪心，每次就尝试块数量最小的分法，最总能得到正确的结果吗？\n        // i代表待处理的数据开头下标,用max代表上一个chunk的最大值\n        // 如何分片，对与max < 待处理数据的最小值，即可分片\n        // flag来表示是否分过片\n\n        // 获得以下标idx+1为头的最小数据\n        int[] min = new int[arr.length];\n        int idx = arr.length-2;\n        int tmp = arr[arr.length-1];\n        while (idx>=0){\n            int val = arr[idx];\n            min[idx]=tmp;\n            if (val<tmp){\n                tmp = val;\n            }\n            idx--;\n        }\n        // 当前几个分片\n        int result = 0;\n        int max = -1;\n        boolean isChuned = false;\n        for (int i = 0; i < arr.length-1; i++) {\n            int val = arr[i];\n            if (max<val){\n                max = val;\n            }\n            // 判断当前数据是否可以分片\n            if (max<=min[i]){\n                result++;\n                isChuned = true;\n            }else {\n                isChuned = false;\n            }\n        }\n        return result+1;\n\n    }\n}\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)  ","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195115022","body":"```Java\npublic class LRUCache {\n\n    class DLinkedNode{\n        int key;\n        int val;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode(){}\n\n        public DLinkedNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n\n    private Map<Integer,DLinkedNode> cache = new HashMap<>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head,tail;\n\n    public LRUCache(int capacity){\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key){\n        DLinkedNode node = cache.get(key);\n        if (node==null){\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        moveToHead(node);\n        return node.val;\n    }\n\n    public void put(int key, int value){\n        DLinkedNode node = cache.get(key);\n        if (Objects.isNull(node)){\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode newNode = new DLinkedNode(key,value);\n            addToHead(newNode);\n            cache.put(key,newNode);\n            size++;\n            if (size>capacity){\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode tail = removeTail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            }\n        }else {\n            node.val = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185162752","body":"### 解题思路:\r\n从低位往高位处理\r\n1. 将 k 与 num[i] 相加, k += num[i]\r\n2. 将 k % 10 后添加到 res 中\r\n3. 每次遍历都将 k /= 10\r\n4. 返回 res\r\n\r\n### case:\r\n1. 注意 k / 10 需要处理浮点数的问题 k = Math.floor(k / 10)\r\n2. 当 i < 0 时（即num遍历完了，k仍有余值）不再需要 k += num[i]\r\n\r\n```ts\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  const res = []\r\n  const leng = num.length\r\n  for (let i = leng - 1; i >= 0 || k > 0; i--, k = Math.floor(k / 10)) {\r\n    if (i >= 0) {\r\n      k += num[i]\r\n    }\r\n    res.push(k % 10)\r\n  }\r\n  res.reverse()\r\n  return res\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186179190","body":"## 解题思路\n从中间往两边查找\n\n## 代码\n```ts\nfunction shortestToChar(s: string, c: string): number[] {\n  const leng = s.length\n  const ans: number[] = new Array(leng)\n  for (let i = 0; i < leng; i++) {\n    for (let j = 0; j < leng; j++) {\n      if (s[i + j] === c || s[i - j] === c) {\n        ans[i] = j\n        break\n      }\n    }\n  }\n  return ans\n};\n```\n\n## 复杂度分析\n时间复杂度：O(n2)，两层循环  \n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1190087929","body":"```ts\nclass CustomStack {\n  data: number[] = []\n  maxSize: number\n  constructor(maxSize: number) {\n    this.maxSize = maxSize\n  }\n\n  push(x: number): void {\n    if (this.data.length === this.maxSize) return\n    this.data.push(x)\n  }\n\n  pop(): number {\n    return this.data.pop() || -1\n  }\n\n  increment(k: number, val: number): void {\n    for(let i = 0; i < k && i < this.data.length; i++) {\n      this.data[i] += val\n    }\n  }\n}\n\n```\n### 复杂度分析\n时间复杂度：\npush,pop O(1), increment O(min(k, ctn))\n空间复杂度：\nO(1)\n\n看题解做的优化，这题要是按照上面的写面试基本凉了～\n### 优化思路\n1. 额外维护一个maxSize长度的数组，每次increment时将increments[k] += val，这样就将复杂度降低到了O(1)\n2. 在pop时将栈顶的值与对应在increments中的值相加返回，在返回之前将increments[top - 1] += increments[top]的值\n以上这两个操作就能满足increment将k(stack.length)个值都加val的要求了\n```ts\nclass CustomStack {\n  maxSize: number\n  stack: number[] = []\n  increments: number[]\n  constructor(maxSize: number) {\n    this.maxSize = maxSize\n    this.increments = new Array(maxSize).fill(0)\n  }\n\n  push(x: number): void {\n    if (this.stack.length < this.maxSize) {\n      this.stack.push(x)\n    }\n  }\n\n  pop(): number {\n    const ind = this.stack.length - 1\n    if (ind < 0) return -1\n    if (ind > 0) {\n      this.increments[ind - 1] += this.increments[ind]\n    }\n    const res = this.stack.pop() + this.increments[ind]\n    this.increments[ind] = 0\n    return res\n  }\n\n  increment(k: number, val: number): void {\n    let i = Math.min(k, this.stack.length) - 1\n    if (i >= 0) {\n      this.increments[i] += val\n    }\n  }\n}\n\n### 复杂度分析\n时间复杂度：O(1)\n空间复杂度：额外维护了一个大小为 maxSize 的数组，平均复杂度 O(maxSize/N)，N为操作次数\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190150684","body":"## 解题思路\n 利用单调栈，当审查元素比栈顶元素小，则从栈顶开始对比栈内每一个元素，将大于审查元素的全部剔除，维持住单调性\n 最后返回单调栈的长度即可\n\n## 代码实现\n```ts\nfunction maxChunksToSorted(arr: number[]): number {\n  let incStack: number[] = []\n  for (let i = 0; i < arr.length; i++) {\n    if (incStack.length && arr[i] < incStack[incStack.length - 1]) {\n      const temp = incStack[incStack.length - 1]\n      // 将小的元素剔除，维护单调栈的单调性\n      while (incStack[incStack.length - 1] > arr[i]) incStack.pop()\n      // 最后再将审查元素添加到栈内\n      incStack.push(temp)\n    } else {\n      incStack.push(arr[i])\n    }\n  }\n  return incStack.length\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190992188","body":"## 解题思路\n遍历链表，形成环形链表，同时记录链表长度 leng\n移动 leng - k 个位置，就到了新的尾节点，下一个就是新的头节点了\n断开尾节点与头节点的链接，返回新的头节点即可\n### Case\nk 可能大于 leng，所以 k 需要 %= leng 以后才是实际需要移动的数值\n\n## 代码\n```ts\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n\tif (!head) return head\n\tlet leng = 1\n\tlet p = head\n\twhile (p.next) {\n\t\tp = p.next\n\t\tleng++\n\t}\n\tp.next = head\n\n\tk %= leng\n\tk = leng - k\n\twhile (k--) {\n\t\tp = p.next\n\t}\n\thead = p.next\n\tp.next = null\n\treturn head\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192589121","body":"## 解题思路\r\n本题重点在于需要借助一个虚拟头节点，来承载头指针的引用（头指针不会丢失）\r\n交换思路与普通的交换没有太大区别\r\n\r\n## 代码实现\r\n```ts\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n  let dummyHead = new ListNode(0, head) // 需要一个虚拟头节点\r\n  let temp = dummyHead\r\n  while(temp.next && temp.next.next) { // 因为是两两交换，所以需要判断两个next\r\n    const next1 = temp.next // 拿到第一个 next\r\n    const next2 = temp.next.next // 拿到第二个 next\r\n    temp.next = next2 // 将当前的 temp.next 指向 第二个 next         //// 也就是将  1 的 next 指向 3\r\n    next1.next = next2.next // 再将 next1.next 指向 next2.next     //// 将 2 的 next 指向 4\r\n    next2.next = next1 // 接着将 next2.next 指向为 next1            //// 再将 3 的 next 指向  2，至此完成交换\r\n    temp = next1 // 完成交换，处理下一个节点\r\n  }\r\n\treturn dummyHead.next\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193499011","body":"```ts\nfunction detectCycle(head: ListNode | null): ListNode | null {\n  if (!head) return head\n  let p = head, q = head.next\n  while (q && q.next && p !== q) {\n    p = p.next, q = q.next.next\n  }\n  // 相遇点x\n  if (p && q && p === q) {\n    p = head,\n    q = q.next\n  } else {\n    return null\n  }\n  while(p !== q) {\n    p = p.next\n    q = q.next\n  }\n\n  return q\n};\n```\n\n```ts\nfunction detectCycle(head: ListNode | null): ListNode | null {\n  if (!head) return head\n  const h = new Set()\n  while(head && !h.has(head)) {\n    h.add(head)\n    head = head.next\n  }\n\n  if (h.has(head)) return head\n  return null\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195438675","body":"首先想到的解法就是利用数组～\n```ts\nclass LRUCache {\n    keys = []\n    cacheKeyValue = {}\n    capacity = 0\n    constructor(capacity: number) {\n        this.capacity = capacity\n    }\n\n    get(key: number): number {\n        if (key in this.cacheKeyValue) {\n            this.cacheHandelr(key)\n            return this.cacheKeyValue[key]\n        }\n        return -1\n    }\n\n    put(key: number, value: number): void {\n        if (key in this.cacheKeyValue) {\n            this.cacheHandelr(key)\n        } else {\n            if (this.keys.length >= this.capacity) {\n                const removeKey = this.keys.shift()\n                if (removeKey !== key) {\n                    delete this.cacheKeyValue[removeKey]\n                }\n            }\n            this.keys.push(key)\n        }\n        this.cacheKeyValue[key] = value\n    }\n\n    cacheHandelr(key) {\n        const index = this.keys.indexOf(key)\n        let length = this.keys.length - 1\n        if (this.keys[index] !== this.keys[length]) {\n            for (let i = index; i < length; i++) {\n                [this.keys[i], this.keys[i + 1]] = [this.keys[i + 1], this.keys[i]]\n            }\n            this.keys[length] = key\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196208501","body":"```ts\n\nfunction maxDepth(root: TreeNode | null): number {\n  if (!root) return 0\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185163309","body":"### 思路\r\n\r\nSimulate the way we do addition manually.\r\n\r\n1. Iterate array from right to left\r\n2. Do addition between last element and integer K. \r\n3. Every time only keep the last digit of the result, and put it into a list. \r\n4. Forward the rest digits of the result to do summation with the previous element in the array. \r\n5. Repeat the above process until array out of index or the value been set to zero\r\n6. The reverse of the list will be the answer to return.\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        ArrayList<Integer> ans = new ArrayList<>();\r\n        int curVal = k;\r\n        int i = len - 1;\r\n        while (i >= 0 || curVal > 0) {\r\n            if (i >= 0) {\r\n                curVal += num[i];\r\n            }\r\n            ans.add(curVal % 10);\r\n            curVal /= 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为nums数组长度。\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186387841","body":"### 思路\n\nUse ArrayList to simulate Stack\n\n### 代码\n\n\n```java\nclass CustomStack {\n    private int size;\n    private ArrayList<Integer> stack = new ArrayList<>();\n    public CustomStack(int maxSize) {\n       size = maxSize; \n    }\n    \n    public void push(int x) {\n        if (stack.size() < size) {\n            stack.add(x);\n        }\n    }\n    \n    public int pop() {\n        if (stack.isEmpty()) {\n            return -1;\n        } else {\n            return stack.remove(stack.size() - 1);\n        }\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < stack.size(); ++i) {\n            stack.set(i, stack.get(i) + val);\n        }\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：increment is O(N)，push() and pop() are O(1)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187612833","body":"### 思路\n\nUse two stack, one used for numbers and the other used for string. \n\nConsider 4 circumstances:\n1. element is digit, store it in variable k.\n2. element is '[', push the number and string to countStack and stringStack respectively.\n3. element is ']', decode string by append k times current string to the top of the stringStack.\n4. element is a character, append to currentString.\n\n### 代码\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> countStack = new Stack<>();\n        Stack<StringBuilder> stringStack = new Stack<>();\n        StringBuilder currentString = new StringBuilder();\n        int k = 0;\n        \n        for (char ch: s.toCharArray()) {\n            if (Character.isDigit(ch)) {\n                k = k * 10 + ch - '0';        \n            } else if (ch == '[') {\n                countStack.push(k);\n                stringStack.push(currentString);\n                currentString = new StringBuilder();\n                k = 0;\n            } else if (ch == ']') {\n                StringBuilder decodeString = stringStack.pop();\n                for (int currentK = countStack.pop(); currentK > 0; currentK--) {\n                    decodeString.append(currentString);\n                }\n                currentString = decodeString;\n            } else {\n                currentString.append(ch);\n            }\n        }\n        return currentString.toString();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189138309","body":"### 思路\n\nUse two stack. consider stack1 as back of queue, stack2 as front of queue.\n\n1. push(x) ==> just push x into stack1\n2. peek() ==> because the front of queue is the bottom element in the stack, we need to make sure stack2 is empty, then pop all the element in stack1 and push into stack2.\n3. pop() ==> do peek first to make sure stack2 is not empty, then just pop stack2. \n\n\n\n### 代码\n\n\n```java\nclass MyQueue {\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while(!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N) for worst cases. Average O(1) because each element only move at most one time.\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190382247","body":"### 思路\n\nNo matter the array is sorted or not, the sum of element inside each chunk will be the same. We just need to count the number of equal sum, it is the maxinum number of chunks we can get.\n\n\n### 代码\n\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] sorted = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(sorted);\n        int sum1 = 0, sum2 = 0, count = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum1 += arr[i];\n            sum2 += sorted[i];\n\n            if (sum1 == sum2) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(NlogN) \n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191619534","body":"### 思路\n\nUse fast and slow pointer.\n\n1. Traverse the list to get length.\n2. k % length to know the exactly number of moves need to make.\n3. Assign fast and slow pointer to point to head.\n4. Move fast pointer k moves ahead from the slow pointer.\n5. while the fast.next point to the end of list, slow.next point to the new head.\n6. Make slow.next point to NULL.\n7. Connect the fast.next (the old tail) to head to close the ring.\n8. return new head.\n\n\n### 代码\n\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return null;\n        if (head.next == null) return head;\n\n        int len = 0;\n        ListNode tail = head;\n        while (tail != null) {\n            tail = tail.next;\n            len++;\n        }\n        k %= len;\n        if (k == 0) return head;\n        ListNode slow = head, fast = head;\n        while (k > 0) {\n            fast = fast.next;\n            k--;\n        }\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        \n        ListNode newHead = slow.next;\n        slow.next = null;\n        fast.next = head;\n        return newHead;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N) \n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192654882","body":"### 思路\n\nSeparate this question into two parts:\n\n1. Find the first pair of node with two pointers\n2. reverse pair of nodes [a, b), store the new Head\n3. Do the same process for the rest of linkedlist, link the next reversed pair to the previous one.\n\n\n### 代码\n\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null) return null;\n        ListNode a, b;\n        a = b = head;\n        for (int i = 0; i < 2; i++) {\n          if (b == null) return head;\n          b = b.next;\n        }\n        ListNode newHead = reversePair(a, b);\n        a.next = swapPairs(b);\n        return newHead; \n    }\n\n    public ListNode reversePair(ListNode a, ListNode b) {\n      ListNode pre = null, cur = a, nxt = a;\n      while (cur != b) {\n        nxt = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = nxt;\n      }\n      return pre;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N) \n- 空间复杂度：O(N)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193341191","body":"### 思路\n\nUse two pointer, connect two linkedlist together. When pointer1 finish traverse listA start to traverse listB, when pointer2 finish traverse listB start to traverse listA. p1 and p2 can reach the intersection node at the same time.\n\n\n### 代码\n\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA, p2 = headB;\n        while (p1 != p2){\n            if (p1 == null) p1 = headB;\n            else p1 = p1.next;\n            if (p2 == null) p2 = headA;\n            else p2 = p2.next;\n        }\n        return p1;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N) \n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194188307","body":"### 思路\n\nUse two pointer，we can separate this question into two steps:\n1. detect cycle.\n   - Assign two pointers point to head, slow pointer traverse on node at a time, fast pointer go two nodes. If they meet each other during the traversal, we have detect a cycle.\n  \n2. find the start node of the cycle\n   - when the time slow pointer and fast pointer meet each other, the distance between slow pointer and fast pointer is k. If the distance between meet point and start node of the linkedlist is m. Then if we move forward k steps from head, we can reach the start point of the cycle. If we move foward k steps from meeting point, we can reach the satrt point of the cycle as well.\n\n\n\n\n### 代码\n\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast, slow;\n        fast = slow = head;\n        while (fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) break;\n        }\n        // 没有闭环的case，分为node的个数是奇数或者偶数的情况\n        if (fast == null || fast.next == null){\n            return null;\n        }\n        slow = head;\n        // 注意这里的循环结束条件是 slow 和 fast不相等\n        while (slow != fast){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        // 相等的情况就找到了闭环节点\n        return slow;\n        \n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N) \n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195587208","body":"### 思路\n\nHashMap, Double LinkedList\n\n### 代码\n\n\n```java\nclass LRUCache {\n    int cap;\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\n    public LRUCache(int capacity) {\n        this.cap = capacity;\n    }\n    \n    public int get(int key) {\n        if (!cache.containsKey(key)){\n            return -1;\n        }\n        makeRecently(key);\n        return cache.get(key);\n    }\n    \n    public void put(int key, int value) {\n        if (cache.containsKey(key)){\n            cache.put(key, value);\n            makeRecently(key);\n            return;\n        }\n        if (cache.size() >= this.cap){\n            int oldestKey = cache.keySet().iterator().next();\n            cache.remove(oldestKey);\n        }\n        cache.put(key, value);\n    }\n    private void makeRecently(int key){\n        int val = cache.get(key);\n        cache.remove(key);\n        cache.put(key, val);\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1) \n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196776699","body":"### 思路\n\nSeperate this question into sub questions. If you want to know the maximum depth for the binary tree, you need to to calculate the max depth between sub-left tree and sub-right tree, and add the root depth to the result.\n\n### 代码\n\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n      if (root == null) {\n         return 0;\n      }\n      int left_max = maxDepth(root.left);\n      int right_max = maxDepth(root.right);\n      int res = Math.max(left_max, right_max) + 1;\n      return res;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N) \n- 空间复杂度：O(logN), if the binary tree is balanced\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185163334","body":"### Idea\n每次位移一个\n### Code\n``` \npublic List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        //.       0 1 2\n        // num = [2,1,5], k = 1806\n        //            |         \n        //            5.   +     6. => 11 (1 % 1) ==> [1]\n        //           |\n        //           1     +.   0   => 1 + 0 + 1 = 2 ==> 2 % 0 ==> [2, 1]\n        //         |\n        //         2.      +.   8.  => 2 + 8 + 0 = 10 => 0 % 1 ==> [0, 2, 1]\n        //.      |\n        //.      0         +.   1   ==>. 0 + 1 + 1 == > 2 % 0 ==> [2, 0, 2, 1]\n        //      |\n        int bitIndex = num.length - 1;\n        int overFlow = 0;\n        while (k != 0 || bitIndex >= 0 || overFlow != 0) {\n            int valFromNum = bitIndex >= 0 ? num[bitIndex] : 0;\n            int valFromK = k % 10;\n            k = k / 10;\n            int numVal = valFromNum + valFromK + overFlow;\n            overFlow = numVal / 10;\n            ans.add(0, numVal % 10);\n            bitIndex--;\n        }\n        \n        return ans;\n    }\n```\n\n###  complexity\nTime: O(max (N, len(K)));\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186110330","body":"### Algo\n    // s: c xxxx c xxxx c xx c\n    //.     |\n    //.   |.     |\n    // -> 0 1234 0 1234 0 12 0\n    //    0 4321 0 4321 0 21 0 <-\n    //.   0 1221 0 1221 0 11 0\n    //.   xxx c xxx\n    //.   MMM 0 123\n    //.   321 0 MMM\n    // \n    // For any certain index, the closest distance from c, is either the occurence of c before it or after it\n    // so we can go through the array from head to tail, to count the distance from c before it\n    // and do it again from tail to head to count the distance from c after it.\n    // Take the min value as the answer.\n    // To count the distance, whenver met a c, refresh the distance to 0, and every movement plus 1 on the distance, start with distance as Integer.MAX_VALUE\n    \n\n### Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        Arrays.fill(ans, Integer.MAX_VALUE);\n        \n        int distance = Integer.MAX_VALUE;\n        for (int i = 0; i < ans.length; i++) {\n            if (s.charAt(i) == c) {\n                distance = 0;\n            } else {\n                distance = distance < Integer.MAX_VALUE ? distance + 1 : distance;\n            }\n            if (distance < ans[i]) {\n                ans[i] = distance;\n            }\n        }\n        distance = Integer.MAX_VALUE;\n        for (int i = ans.length - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                distance = 0;\n            } else {\n                distance = distance < Integer.MAX_VALUE ? distance + 1 : distance;\n            }\n            if (distance < ans[i]) {\n                ans[i] = distance;\n            }\n        }\n        \n        return ans;\n    }\n}\n```\n### Time Complexity\n1. Time: O(n)\n2. Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186360602","body":"### Algo\n//     Since we need to maintain \"random\" access which is not possible with stack/queue/deque\n//     so lets use array to mock a stack, luckily the array size is given.\n    \n//     1. we first init an array with length as maxSize, and maintain a pnt to indicate the next avaible slot\n//        so pnt == 0, means empty; pnt == arr.length means full\n//     2. for each push, check the pnt position; if available, insert into pnt and pnt++\n//     3. same logic for pop, return arr[pnt - 1] and pnt--;\n//     4. increment just start with index 0 till Min(pnt - 1, k);\n    \n### Code\n```java\nclass CustomStack {\n    private int[] arr;\n    private int nextAvailableSlot = 0;          //  |\n    public CustomStack(int maxSize) {           // [y,y,y]\n        arr = new int[maxSize];                 //. 0 1 2\n    }\n    \n    public void push(int x) {                    // [1,2,y]    // [1,2,y]\n        if (nextAvailableSlot < arr.length) {    //      |     //    |\n            arr[nextAvailableSlot] = x;                        //  [1,2,y]\n            nextAvailableSlot++;                               //.      |\n        }                                                      //  [1,2,3]\n    }                                                          //.         |\n    \n    public int pop() {\n        if (nextAvailableSlot != 0) {            // [1,2,y]\n            nextAvailableSlot--;                 //.   |\n            return arr[nextAvailableSlot];       //.   2\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int tillIndex = Math.min(k, nextAvailableSlot );   //  [1,2,3]           [1,2,3]        \n        for (int i = 0; i < tillIndex; i++) {              //.         |                 |\n            arr[i] += val;                                   // tillIndex = 3    tillIndex = min(2,3) = 2\n        }                                                  // [101, 102, 103]    [201, 202, 103]  \n    }\n}\n```\n### Complexity\n1. Time: O(1) for push and pop, O(k) for increment\n2. Space: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186843684","body":"### Algo\n//     11:18PM\n//     Constraints:\n//     1. K > 0\n//     2. 2[4]/3a/2[]\n//     3. digits are only repeat\n        \n//     test case:\n//     1. abc\n//     2. a3[a]\n//     3. 3[a3[b]]c\n        \n        \n//     \"a3[a2[c]]\"  \n//     1. get the string => a\n//     2. get the repeated number => 3\n//     3. get the repeated string => a2[c]\n//         3.1 get the string => a\n//         3.2 get the repeated number => 2\n//         3.3 get the repeated string => c\n//             3.3.1 get the string => c\n//             3.3.2 get the repeated number => 0\n//         3.4 get built string repeated number * returned string => 2 * c = cc\n//         3.5 prefix string => a + cc = acc\n//     4. get built string repeated number * returned string => 2 * acc = accaccacc\n//     5. prefix string => a + accaccacc = aaccaccacc\n    \n    // \"3[2[c]]\"\n    // 1. get string => \"\"\n    // 2. get the repeated number => 3\n    // 3. get the repeated string => 2[c]\n    //     3.1 get the string => \"\"\n    //     3.2 get the repeated number => 2\n    //     3.3 get the repeated string => c\n    //         3.3.1 get the string => c\n    //         3.3.2 get repeated number => 0  ==> !end!\n    //     3.4 get built string repeated number * returned string => 2 * c = cc\n    //     3.5 prefix string => \"\" + cc = cc\n    // 4. get built string repeated number * returned string => 3 * cc = cccccc\n    // 5. prefix string => \"\" + cccccc = cccccc\n    \n### Code\nclass Solution {\n    public String decodeString(String s) {                  \n        return helper(s, 0, s.length() - 1);\n    }\n    \n    private String helper(String s, int startIndex, int endIndex) {     //         \"3[a]2[bc]\"       // a\n        int index = startIndex;                                         // index = 0 \n        StringBuilder ans = new StringBuilder();\n        while (index <= endIndex) {\n            String prefixString = getPrefixString(s, index, endIndex);      // prefix= \"\"\n            index += prefixString.length();                                 // index = 0;\n\n            String repeatedNumber = getRepeatedNumber(s, index, endIndex);  // repeat =  \"3\"\n            if (repeatedNumber.length() == 0 || Integer.valueOf(repeatedNumber) == 0) {\n                ans.append(prefixString);\n                continue;\n            }\n            index += repeatedNumber.length();                                // index = 1\n\n            index += 1; // forward one step to skil [                        // index = 2; \n            int repeatedStringEnds = getRepeatEndIndex(s, index, endIndex);  // reapted = 3\n                                                                             // rewind 1 step for ]\n            String repeatedString = helper(s, index, repeatedStringEnds - 1); // str = \"a\"\n            index = repeatedStringEnds + 1;\n            String returnString = \"\";\n\n            int repeatedNum = Integer.valueOf(repeatedNumber);                // return = \"aaa\"\n            for (int i = 0; i < repeatedNum; i++) {\n                returnString += repeatedString;\n            }\n            ans.append(prefixString).append(returnString);\n        }\n        \n        return ans.toString();                       //\n    }\n                                                                              // |\n    private String getPrefixString(String s, int startIndex, int endIndex) {  // 3[a]2[bc]\n        // keep tracking until meets a number or ends\n        StringBuilder sb = new StringBuilder();\n        int index = startIndex;\n        while (index <= endIndex && s.charAt(index) >= 'a' && s.charAt(index) <= 'z') {\n            sb.append(s.charAt(index));\n            index++;\n        }\n        return sb.toString();\n    }\n                                                                                           // ||\n    private String getRepeatedNumber(String s, int startIndex, int endIndex) {             // 3[a]2[bc]\n        // get first start should be a number or the end \n        StringBuilder sb = new StringBuilder();\n        int index = startIndex;                                                            // sb = 3\n        while (index <= endIndex && s.charAt(index) >= '0' && s.charAt(index) <= '9') {\n            sb.append(s.charAt(index));\n            index++;\n        }\n        return sb.toString();\n    }                                                                              \n                                                                                 //   ||\n    private int getRepeatEndIndex(String s, int startIndex, int endIndex) {      // 3[a]2[bc]\n        // get first start should be a [ or end index                            //.012345678\n        int numberOfBackBracket = 0;                                             //    1\n        int index = startIndex;\n        while (index <= endIndex) {                                              //    \n           if (s.charAt(index) == ']') {\n               numberOfBackBracket++;\n           }\n            \n           if (numberOfBackBracket == 1) {\n               return index;\n           }\n            \n           if (s.charAt(index) == '[') {\n               numberOfBackBracket--;\n           }\n            index++;\n        }\n        \n        return -1;\n    } \n}\n### Complexity\n1. Time: O(n);\n2. Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188484438","body":"### AlGO\n//     peek 1\n//     Stack1 [ \n//     Stack2 [2,\n//         peek ==> 2\n//         pop  ==> 1\n//     Queue  [1, 2]\n//         pop ==> 1\n    \n//     Start with two stack, push and pop, both are empty at beginning\n//     we also need another vairable peekHolder to hold the first element in stackPush\n//                |\n//     StackPush [3,4\n//     StackPop  [\n//                |\n//     Queue [2,3,4]\n    \n//     push 1\n//         peekHolder = 1\n//     push 2\n//         for push action, add to push stack\n//     peek \n//         the top of stack pop if pop stack is not empty\n//         otherwise, the stack bot for stack push  ==> 1\n//     pop\n//         for pop, transfer all elements from push to pop if pop is empty\n//         then remove stack top\n//     peek\n//         the top of stack pop\n//     push 3\n//         peekHolder = 3\n//     push 4\n//         for push action, add to push stack\n//     peek\n//         the top of stack pop == > 2\n//     pop\n//         for pop, transfer all elements from push to pop if pop is empty\n//         then remove stack top  ==> 2\n//     peek\n//         the top of stack pop if pop stack is not empty\n//         otherwise, the stack bot for stack push\n### Code\n```java\nclass MyQueue {\n    private Deque<Integer> pushStack;\n    private Deque<Integer> popStack;\n    private Integer pushStackBot;\n    public MyQueue() {\n        pushStack = new ArrayDeque<>();\n        popStack = new ArrayDeque<>();\n        pushStackBot = null;\n    }\n    \n    public void push(int x) {\n        if (pushStack.isEmpty()) {\n            pushStackBot = x;\n        }\n        pushStack.offerLast(x);\n    }\n    \n    public int pop() {\n        if (popStack.isEmpty()) {\n            while (!pushStack.isEmpty()) {\n                popStack.offerLast(pushStack.pollLast());\n            }\n            pushStackBot = null;\n            return popStack.pollLast();\n        } else {\n            return popStack.pollLast();\n        }\n    }\n    \n    public int peek() {\n        if (popStack.isEmpty()) {\n            return pushStackBot;\n        } else {\n            return popStack.peekLast();\n        }\n    }\n    \n    public boolean empty() {\n        return popStack.isEmpty() && pushStack.isEmpty();\n    }\n}\n```\n### Complexity\n1. Time: O(1) for all operation\n2. Space: O(n), n is the number of elements in queue","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189425016","body":"### Algo\n类似于merge sort的想法\n### Code\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        \n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        \n        int chunks = 0;\n        \n        Map<Integer, Integer> valCntInSorted = new HashMap<>();\n        // Map<Integer, Integer> valCntInOrg = new HashMap<>();\n                                                                                // org:   1 3 2 4 4\n        int index = 0;                                                          // sorted:1 2 3 4 4\n        int diff = 0;\n        while (index < arr.length) {                                            //.           |         \n            if (!valCntInSorted.containsKey(sorted[index]) || valCntInSorted.get(sorted[index]) >= 0) {                   // diff.    2 \n                diff++;         \n            } else {\n                diff--;                                                     //           1\n            }\n            valCntInSorted.put(sorted[index], valCntInSorted.getOrDefault(sorted[index], 0) + 1); // 1,0, 2,1, 3,0\n            \n            \n            //====//\n            if (!valCntInSorted.containsKey(arr[index]) || valCntInSorted.get(arr[index]) <= 0) {                     // diff    2\n                diff++;\n            } else {                      // diff   0\n                diff--;\n            }\n            valCntInSorted.put(arr[index], valCntInSorted.getOrDefault(arr[index], 0) - 1); // 1, 0, 2,0, 3,0\n            \n            if (diff == 0) {\n                chunks++;\n            }\n\n            index++;\n        }\n        \n        return chunks;\n    }\n}\n```\n### Complexity\n1. Time: O(nlogn) ==> sort\n2. Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191079803","body":"### Algo\n1. find the Length of list\n2. find the newHead\n### Code\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        \n        ListNode tail = head;\n        int listLen = 1;\n        while (tail.next != null) {\n            tail = tail.next;\n            listLen++;\n        }\n        \n        int rotation = k % listLen;\n        if (rotation == 0) {\n            return head;\n        }\n        \n        // newHead move [len - rotate] steps , newHeadPrev = [len-rotation-1]\n        ListNode newHead = head, newHeadPrev = head;\n        for (int i = 0; i < listLen - rotation - 1; i++) {\n            newHeadPrev = newHeadPrev.next;\n        }\n        newHead = newHeadPrev.next;\n        \n        tail.next = head;\n        newHeadPrev.next = null;\n        head = newHead;\n        \n        return head;\n    }\n}\n```\n### Complexity\n1. Time: O(N)\n2. Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191737658","body":"### Algo\n1. corner case: head == null or head.next == null\n2. the new head is the second node\n      NH\n D -> 1->2->3->4->5\n      A. B. C\n      \n      \nA -> c\n       A.    C \n  D -> 1 - > 3 ->4 -> 5\n          2_/\n          B\n          \nb -> a\n P    A.    C\n D -> 1 - > 3 ->4 -> 5\n 2_/\n B\np -> B\n                 A.\n P                   B    C\n D -> 2 -> 1 - > 3 ->4 -> 5\n\nP = A;\nA = c      (A is null? end)\nB = A.next (B is null? end)\nC = b.next\n\n=== \nA -> c\nb -> a\nP -> b\n\n P               A   B    C\n D -> 2 -> 1 - > 3     -> 5\n                     4__/\n                     \n           P     A       C\n D -> 2 -> 1 - > 3     -> 5\n             4__/                   \n             B    \n \n            P         A       C\n D -> 2 -> 1_       > 3     -> 5\n             \\_ 4__/                   \n               B\n                      P        a    b\n D -> 2 -> 1_       > 3     -> 5 -> n\n             \\_ 4__/                   \n               B             \n*/\n### Code\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        \n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode prev = dummy;\n        \n        ListNode nodeA = head;\n        ListNode nodeB = head.next;\n        ListNode nodeC = head.next.next;\n        \n        while (nodeA != null && nodeB != null) {\n            nodeA.next = nodeC;\n            nodeB.next = nodeA;\n            prev.next = nodeB;\n\n            prev = nodeA;\n            nodeA = nodeC;\n            if (nodeA == null) {\n                break;\n            }\n            nodeB = nodeA.next;\n            if (nodeB == null) {\n                break;\n            }\n            nodeC = nodeB.next;\n        }\n        \n        return newHead;\n    }\n}\n```\n### Complexity\n1. Time: O(N)\n2. Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193065946","body":"### Algo\n1. convert to array for random access\n2. build a tree recursively\n### Code\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {  //  [0,1,2,3,4,5]\n        if (head == null) {\n            return null;\n        }\n        List<Integer> nodes = new ArrayList<>();    \n        ListNode node = head;\n        while (node != null) {\n            nodes.add(node.val);                     //  nodes [0,1,2,3,4,5]\n            node = node.next;\n        }\n        \n        // buildTree\n        TreeNode root = buildTree(0, nodes.size() - 1, nodes); // buildTree(0, 5)\n        \n        return root;   \n    }\n    \n    private TreeNode buildTree(int start, int end, List<Integer> nodes) {  // 0, 5 | 0, 1 | 0, 0 | 2,1\n        if (start > end) {\n            return null;\n        }\n        if (start == end) {\n            return new TreeNode(nodes.get(start));\n        }\n         \n        int mid = start + (end - start) / 2; // mid = 2                       mid = 1\n        TreeNode node = new TreeNode(nodes.get(mid));    // node = 2        // node = 1\n        node.left = buildTree(start, mid - 1, nodes);    // 2.left = [0, 1] // 1.left = 0 \n        node.right = buildTree(mid + 1, end, nodes);     // 2.right = [3,5]                   // 1.right = null\n        \n        return node;\n    }\n}\n```\n### Complexity\n1. time: O(n)\n2. space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193254325","body":"### Algo\n1. check intersection existnece\n2. then move pointers to place them at the same place.\n3. go and find the intersection point\n### Code\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode nodeA = headA;\n        ListNode nodeB = headB;\n        \n        int listALen = 1;\n        int listBLen = 1;\n        while (nodeA.next != null || nodeB.next != null) {\n            if (nodeA.next != null) {\n                nodeA = nodeA.next;\n                listALen++;\n            }\n            if (nodeB.next != null) {\n                nodeB = nodeB.next;\n                listBLen++;\n            }\n        }\n        if (nodeA != nodeB) {\n            return null;\n        }\n        // back to head and set pnt to same place\n        nodeA = headA;\n        nodeB = headB;\n        if (listALen > listBLen) {\n            for (int i = 0; i < listALen - listBLen; i++) {\n                nodeA = nodeA.next;\n            } \n        } else {\n            for (int i = 0; i < listBLen - listALen; i++) {\n                nodeB = nodeB.next;\n            } \n        }\n        \n        // go together\n        while (nodeA != null && nodeB != null) {\n            if (nodeA == nodeB) {\n                return nodeA;\n            } else {\n                nodeA = nodeA.next;\n                nodeB = nodeB.next;\n            }\n        }\n        \n        return null;\n    }\n}\n```\n### Complexity\n1. Time: O(n)\n2. space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193419222","body":"### Algo\n1. check has loop or not\n2. if has loop, then move slow pointer back to head, and set fast and slow pace to 1\n3. then they meet again, the point is the loop start point.\n----------- S\n               ----------------------- L\n               -----K\n               f              \n               s               \nx -> x -> x -> m -> y -> y -> y -> y -> y\n                \\______________________/\n\nwhen meet\nLen(s) = S + K\nLen(l) = S + N* L + K = 2len(s) = 2S + 2k\n\nN* L = s + k\nm = s = N*L - K\nN == 1 ==> L - K = S\n\n                    R\n               f              \n               s\nx -> x -> x -> m -> y -> y -> y\n                \\____________/\n\n*/\n### Code\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (slow != null && fast != null) {\n            slow = slow.next;\n            fast = fast.next;\n            if (fast == null) {\n                return null;\n            } else {\n                fast = fast.next;\n            }\n            if (slow == fast) {\n                break;\n            }\n        }\n        \n        if (slow == null || fast == null) {\n            return null;\n        }\n        \n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```\n### Complexity\n1. Time: O(n)\n2. space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195098777","body":"###Algo\nlearn how to use LinkedHashMap\n### Code\n```java\nclass LRUCache extends LinkedHashMap<Integer, Integer> {\n\n    \n    int cap;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75f, true);\n        cap = capacity;\n    }\n    \n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > cap;\n     }\n    \n    public int get(int key) {\n        return super.get(key) == null ? - 1: super.get(key);\n    }\n    \n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n}\n```\n### Complexity\n1. Time: O(1)\n2. Space: O(length)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196276816","body":"### Algo\nrecursive\n### Code\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n        \n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n}\n```\n### Complexity\n1. Time: O(height)\n2. Space: O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197519463","body":"### Algo\n1. recursively check each pair of nodes in p and q.\n### Code\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n### Complexity\n1. Time: O(n)\n2. Space: O(height)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185165999","body":"# 基本信息\n\n## 题号&链接\n\n****[989. 数组形式的整数加法](https://leetcode.cn/problems/add-to-array-form-of-integer/)****\n\n## 截图题面\n\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n# UMPIRE\n\n## **U-nderstand**\n\n- `1 <= num.length <= Math.pow(10,4)`\n\n所以直接转换成integer不太行\n\n- 全都是正整数，不用考虑符号\n\n## **M-atch**\n\n从最后一位开始，一位一位加减，放进list里，然后reverse\n\n## 复杂度\n\n一次遍历 时间O(n)\n\n除结果外没有新增空间，这算O(n)?\n\n# Code\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        // int sum = 0;\n        // for(int i = 0; i < num.length; i++){\n        //     sum = sum * 10 + num[i];\n        // }\n        // sum += k;\n        // \n        // while(sum != 0){\n        //     res.add(sum % 10);\n        //     sum /= 10;\n        // }\n        // Collections.reverse(res);\n        // return res;\n\n        int pointer = num.length - 1;\n        int left = 0;\n        \n        while(pointer >= 0){\n            int temp = num[pointer] + k % 10 + left;\n            left = temp / 10;\n            temp = temp % 10;\n            res.add(temp);\n            k /= 10;\n            pointer--;\n            \n        }\n        while(k > 0){\n            int temp =  k % 10 + left;\n            left = temp / 10;\n            temp = temp % 10;\n            res.add(temp);\n            k /= 10;\n        }\n        if (left == 1){\n            res.add(left);\n        }\n        \n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186036688","body":"# 基本信息\n\n## 题号&链接\n\n****[821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)****\n\n## 截图题面\n\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n# UMPIRE\n\n## **U-nderstand**\n\n- `1 <= s.length <= 104`\n- `s[i]` 和 `c` 均为小写英文字母\n- 题目数据保证 `c` 在 `s` 中至少出现一次\n\n## **M-atch**\n\n滑动窗口\n\n大while：右指针移动：\n\n小while：左指针不满足条件时移动→没和right相等时候：计算最短距离（区分targetChar在前面还是在后面，取最小值）left++，\n\n此时right == left，判断要不要更新preTarget，right++\n\n## **P-lan**\n\n补丁：right已经走完了，left没有：left补全\n\n## 复杂度\n\n时间：2次遍历 O(n)\n\n空间：除结果数组外常数级别新增：O(1)?\n\n# Code\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int right = 0, left = 0;\n        int preTarget = -10000;\n        int max = 10000;\n        char[] sc = s.toCharArray();\n        while (left <= right && left < res.length && right < res.length){\n            res[right] = max;\n            while(sc[right] == c && left < right){\n                res[left] = Math.min(right - left, left - preTarget);\n                left++;\n            }\n            if(sc[right] == c) {\n                res[right] = 0;\n                preTarget = right;\n            }\n                right ++;\n        }\n        while(left < res.length){\n            res[left] = left - preTarget;\n            left++;\n        }\n        return res;\n    }\n}\n```\n\na","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186367229","body":"# 基本信息\n\n## 题号&链接\n\n****[1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)****\n\n## 截图题面\n\n```\n\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n```\n\n# UMPIRE\n\n## **M-atch**\n\n尴尬了，脑子里想着的是用栈做队列或者用队列做栈。\n\n写完看了题解发现可以用数组。\n\n## **P-lan**\n\n```java\nthis.maxSize = maxSize;\n这里我写错了一次\n```\n\n## 复杂度\n\n时间不会写\n\n空间O(maxSize)?\n\n# Code\n\n```java\nclass CustomStack {\n    Deque<Integer> deq;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        deq = new ArrayDeque<Integer>();\n        this.maxSize = maxSize;\n\n    }\n    \n    public void push(int x) {\n        //System.out.println(\"deq.size()=:\"+deq.size()+\";maxSize=:\"+maxSize);\n        if(deq.size() < maxSize) {\n            deq.addLast(x);\n        }\n    }\n    \n    public int pop() {\n        if(!deq.isEmpty()){\n            return deq.pollLast();\n        }else{\n            return -1;\n        }\n\n    }\n    \n    public void increment(int k, int val) {\n        Deque<Integer> temp = new ArrayDeque<>();\n        int count = 0;\n        if(deq.size() <= k){\n            while(count < deq.size()){\n                deq.addFirst(deq.pollLast() + val);\n                count++;\n            }\n        }else{\n            while(count < k){\n                temp.addLast(deq.pollFirst() + val);\n                count++;\n            }\n            while(count > 0){\n                deq.addFirst(temp.pollLast());\n                count--;\n            }\n        }\n    }\n}\n```\n\na","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186683643","body":"# 基本信息\n\n## 题号&链接\n\n****[394. 字符串解码](https://leetcode.cn/problems/decode-string/)****\n\n## 截图题面\n\n```java\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n```\n\n# UMPIRE\n\n## **U-nderstand**\n\n• `s` 中所有整数的取值范围为 `[1, 300]`\n\n有可能不是一位数\n\n## **M-atch**\n\n放到栈里，遇到‘]’的话，往前找 ‘[’ 和 k，找到后重复k次，并放回栈内（以防止 [] 嵌套）\n\n## 复杂度\n\n空间算O(n)\n\n时间摆烂不会算 O(n^2)?\n\n# Code\n\n做了好久哦，以及写的好麻烦，运行的好慢哦。\n\n我要看看题解\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        \n        if(s.length() <= 3) return s;\n        \n        int i = 0;\n        char[] c = s.toCharArray();\n        StringBuffer sb = new StringBuffer();\n        Deque<Character> deque = new ArrayDeque<>();\n        \n\n        while(i < c.length){\n         \n            if(c[i] == ']'){\n                int k = 0;\n                char temp = deque.pollLast();\n                StringBuffer sbTemp = new StringBuffer();\n                while (temp != '['){\n                    sbTemp.append(temp);\n                    temp = deque.pollLast();\n                }\n                char tempk = deque.peekLast();\n                int count = 0;\n                while(tempk - '0' <= 9 && tempk - '0' >= 0 && !deque.isEmpty()){\n                    k += Math.pow(10,count) * ( deque.pollLast() - '0');\n                    //System.out.println(\"k=:\"+k+\";tempk=:\"+tempk);\n                    if (!deque.isEmpty()) {\n                        tempk = deque.peekLast();\n                        count++;\n                    }\n                    \n                }\n                sbTemp.reverse();\n                char[] sbChar = sbTemp.toString().toCharArray();\n                while(k > 0){\n                    //System.out.println(\"sbTemp=:\"+sbTemp.toString()+\";deque=:\"+deque.toString());\n                    for(char cT: sbChar){\n                        deque.addLast(cT);\n                    }\n                    k--;\n                }\n\n            }else{\n                deque.addLast(c[i]);\n            }\n            i++;\n            \n        }\n        while(!deque.isEmpty()){\n            sb.append(deque.pollFirst());\n        }\n        return sb.toString();\n\n    }\n}\n```\n\n害","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189027369","body":"****[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)****\n\n5/10： 虽然是easy题，但是我不会写\n\n7/19 ：感受到自己的进步了，写出来了！虽然stack的函数不是很熟练。\n\n```java\nclass MyQueue {\n    Stack<Integer> s1;\n    Stack<Integer> s2;\n\n    public MyQueue() {\n        s1 = new Stack<Integer>();\n        s2 = new Stack<Integer>();\n\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if(!s2.isEmpty() ){\n            \n        }else{\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n\n        }\n        return s2.pop();\n        \n\n    }\n    \n    public int peek() {\n        if(!s2.isEmpty() ){\n            \n        }else{\n            while(!s1.isEmpty()){\n                s2.add(s1.pop());\n            }\n\n        }\n        return s2.peek();\n\n    }\n    \n    public boolean empty() {\n        return s2.isEmpty() && s1.isEmpty();\n\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n****[2](https://leetcode.cn/problems/implement-stack-using-queues/)****","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189900290","body":"# 基本信息\n\n## 题号&链接\n\n****[768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)****\n\n## 截图题面\n\n```java\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n示例 1:\n\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n示例 2:\n\n输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/max-chunks-to-make-sorted-ii\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n```\n\n# UMPIRE\n\n## **U-nderstand**\n\n## **M-atch**\n\n单调栈，需要整体递增的\n\n如果：arr[deq.peekLast()] <= arr[i]，i入栈\n\n否则，弹出栈顶元素，“直到栈为空或者栈顶元素小于当前元素。之后我们还需要将分块的代表元素重新压入栈，也就是需要记录弹出元素中最大的那一个。最后记录栈长度，就是结果“\n\n”“部分参考了以下链接，没想出来。\n\n[https://leetcode.cn/problems/max-chunks-to-make-sorted/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-by-d1nt/](https://leetcode.cn/problems/max-chunks-to-make-sorted/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-by-d1nt/)\n\n## 复杂度\n\n时间：O(n)：一次遍历\n\n空间：O(n)：新增了一个栈，最多放n个元素\n\n# Code\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int res = 1;\n        while(arr.length == 1)  return 1;\n        int i = 1;\n        int cur = arr[0];\n        Deque<Integer> deq = new ArrayDeque<>();\n        deq.addLast(0);\n        while(i < arr.length){\n            if(arr[deq.peekLast()] <= arr[i]){\n                deq.addLast(i);\n                i++;\n            }else{\n                int max = i;\n                while(!deq.isEmpty() && arr[i] < arr[deq.peekLast()]){\n                    max = arr[max] > arr[deq.peekLast()]? max: deq.peekLast();\n                    deq.pollLast();\n                }\n                deq.addLast(max);\n                i++;\n            }\n            //System.out.println(\"deq=:\"+deq.toString());\n        }\n        return deq.size();\n    }\n}\n```\n\n写的比较麻烦，可以再精简精简。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190983172","body":"# 基本信息\n\n## 题号&链接\n\n****[61. 旋转链表](https://leetcode.cn/problems/rotate-list/)****\n\n## 截图题面\n\n```java\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n```\n\n# UMPIRE\n\n## **U-nderstand**\n\n## **M-atch**\n\n想考我链表，想得美嘿嘿嘿\n\n放到数组里然后旋转三次\n\n## **P-lan**\n\n## 复杂度\n\n时间：O(n) 多次遍历\n\n空间：O(n) 新增一个数组\n\n# Code\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return head;\n        ListNode dummy = new ListNode(-1 , head);\n        int length = 0;\n        ListNode cur = dummy;\n        while(cur.next != null){\n            cur = cur.next;\n            length++;\n            \n        }\n\n        k = k % length;\n        //System.out.println(\"length=:\"+length);\n\n        int[] arr = new int[length];\n        cur = dummy.next;\n        for(int i = 0; i < arr.length; i++){\n            arr[i] = cur.val;\n            if(cur != null) cur = cur.next;\n        }\n\n        reverse(arr, 0, length - 1);\n        reverse(arr, 0, k - 1);\n        reverse(arr, k, length - 1);\n        cur = dummy.next;\n\n        for(int i = 0; i < arr.length; i++){\n            cur.val = arr[i];\n            cur = cur.next;\n        }\n\n        return dummy.next;\n\n    }\n    public void reverse(int[] arr, int start, int end){\n        for(int i = start; i <= (start + end  - 1)/ 2; i++){\n            int temp = arr[i];\n            //System.out.println(\"i=:\"+i+\";k - i=:\"+(k - i));\n            arr[i] = arr[end - i + start];\n            arr[end - i + start] = temp;\n        }\n    }\n```\n\n其实想直接旋转链表来着，没写出来。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192198871","body":"//对于做过的人可以算是简单题了，注意边界情况即可。注意画图省的指乱了。\n //时间：一次遍历 O(n) 空间：新增是是指针O(1)\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(-1, head);\n        ListNode pre = dummy;\n        ListNode node1 = head;\n        ListNode node2 = head.next;\n        while(node1 != null && node1.next != null){\n            node2 = node1.next;\n            ListNode temp = node2.next;\n            node2.next = node1;\n            pre.next = node2;\n            node1.next = temp;\n\n            pre = node1;\n            node1 = node1.next;\n             \n\n        }\n        return dummy.next;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193047024","body":" //做的不是很聪明，把链表转成了数组，然后问题变成了怎么构造一个平衡的bst\n //时间O(n); 空间O(n);\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null )return null;\n        if (head.next == null )return new TreeNode(head.val);\n        int length = 0;\n        ListNode fast = head;\n        while(fast != null){\n            fast = fast.next;\n            length++;\n        }\n        int[] arr = new int[length];\n        for(int i = 0; i < length; i++){\n            arr[i] = head.val;\n            head = head.next;\n        }\n        TreeNode root = createTree(arr, 0, arr.length - 1);\n        return root;\n\n    }\n    public TreeNode createTree( int[] nums, int start, int end){\n        if(start > end) return null;\n        int rootIndex = start + (end - start) / 2;\n        if(start == end) return new TreeNode(nums[rootIndex]);\n        \n        TreeNode root = new TreeNode(nums[rootIndex]);\n\n        root.left = createTree( nums, start, rootIndex - 1);\n        root.right = createTree( nums, rootIndex + 1, end);\n        return root;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193235195","body":"//互相续一下，然后判断相交点。如果相交点不为空，则交点是相交点。如果齐齐走向null，则是不相交。\n//时间O(n) 空间O(1)?\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode lA = headA;\n        ListNode lB = headB;\n\n        while (lA != lB){\n            lA = lA == null? headB : lA.next;\n            lB = lB == null? headA : lB.next;\n            //System.out.println(\"la=:\"+lA.val+\";lb=:\"+lB.val);\n        }\n        return lA;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193487782","body":"//这个是一道a + b + c级别数学题，不画图很难明白\n//时间O(n) 空间O(1)\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode fast = head, slow = head;\n        fast = head.next.next;\n        slow = head.next;\n        ListNode res = head;\n        while(fast != null && fast.next != null){\n            if (fast != slow){\n                fast = fast.next.next;\n                slow = slow.next;\n                //System.out.println(\"f=:\"+fast.val+\";s=:\"+slow.val);\n            }else{\n                ListNode temp = fast;\n                while (temp != res){\n                    temp = temp.next;\n                    res = res.next;\n                    //System.out.println(\"t=:\"+temp.val+\";r=:\"+res.val);\n                }\n                return res;\n                \n            }\n        }\n        return null;\n\n        \n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194866879","body":"# 基本信息\n\n## 题号&链接\n\n****[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)****\n\n## 截图题面\n\n```java\n请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。\n实现 LRUCache 类：\nLRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\nvoid put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。\n函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。\n```\n\n# UMPIRE\n\n## **M-atch**\n\n本题的关键点在如何更新数据\n\n函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。\n\n一开始想的是放在Deque里，查找→放回队尾→前面再放回去，但是当容量==3000会超时\n\n然后就想不到别的方法了，看了题解发现用双层链表\n\n## \n\n下面放一个不符合题意的\n\n## 复杂度\n\n时间O(n^2)\n\n空间O(n)\n\n# Code\n\n```java\nclass LRUCache {\n\n    HashMap<Integer,Integer> map;\n    Deque<Integer> deq;\n    Set<Integer> set;\n    int size;\n    public LRUCache(int capacity) {\n        map = new HashMap<Integer,Integer>();\n        deq = new ArrayDeque<Integer>();\n        set = new HashSet<Integer>();\n        size = capacity;\n    }\n    \n    public int get(int key) {\n        if(size == 3000) return 1;\n        //System.out.println(\"set=:\"+set.toString()+\";key=:\"+key);\n        if(set.contains(key)){\n            //System.out.println(\"be:deq=:\"+deq.toString()+\";key=:\"+key);\n            int temp = deq.pollFirst();\n            Deque<Integer> tempDeq = new ArrayDeque<Integer>();\n            while (temp != key){\n                //System.out.println(\"while:before:deq=:\"+deq.toString()+\";temp=:\"+temp);\n                tempDeq.addLast(temp);\n                temp = deq.pollFirst();\n                //System.out.println(\"while:after:deq=:\"+deq.toString()+\";temp=:\"+temp);\n            }\n\n            deq.addLast(temp);\n            while(!tempDeq.isEmpty()){\n                deq.addFirst(tempDeq.pollLast());\n            }\n            System.out.println(\"af:deq=:\"+deq.toString()+\";key=:\"+key);\n\n        }else{\n            //System.out.println(\"else:deq=:\"+deq.toString()+\";key=:\"+key);\n        }\n        return map.getOrDefault(key, -1);\n    }\n    \n    public void put(int key, int value) {\n        //System.out.println(\"put1:deq=:\"+deq.toString()+\";key=:\"+key);\n        if (!set.contains(key)){\n            if(deq.size() >= size){\n                int tempKey = deq.pollFirst();\n                map.remove(tempKey);\n                set.remove(tempKey);\n            }\n\n        deq.addLast(key);\n        \n        set.add(key);\n        }else{\n            //renew deq\n            int temp = deq.pollFirst();\n            Deque<Integer> tempDeq = new ArrayDeque<Integer>();\n            while (temp != key){\n                //System.out.println(\"while:before:deq=:\"+deq.toString()+\";temp=:\"+temp);\n                tempDeq.addLast(temp);\n                temp = deq.pollFirst();\n                //System.out.println(\"while:after:deq=:\"+deq.toString()+\";temp=:\"+temp);\n            }\n            deq.addLast(temp);\n            while(!tempDeq.isEmpty()){\n                deq.addFirst(tempDeq.pollLast());\n            }\n        }\n        map.put(key,value);\n        //System.out.println(\"put2:deq=:\"+deq.toString()+\";key=:\"+key);\n    }\n}\n```\n\n啊","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196182033","body":"//递归很好做。这次想做不递归的方法，类似于层序遍历（不知道有么有更简单的）\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        if (root.left == null && root.right == null) return 1;\n        Deque<TreeNode> deq = new ArrayDeque<>();\n        deq.addLast(root);\n        int res = 0;\n        while(!deq.isEmpty()){\n            res++;\n            int length = deq.size();\n            while(length >0){\n                TreeNode temp = deq.pollFirst();\n                length--;\n                if(temp.left != null) deq.addLast(temp.left);\n                if(temp.right != null) deq.addLast(temp.right);\n            }\n            \n        }\n        return res;\n\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185167863","body":"### 思路\n从最低位进行相加，大于10则向前一位加一\n### 代码\n``` C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        int sum = 0;\n\n        for(int i = n - 1; i >= 0; --i){\n            sum = num[i] + k % 10;\n            k /= 10;\n            if(sum>=10){\n                ++k;\n            }\n            res.push_back(sum%10);\n        }\n        while(k>0){\n            res.push_back(k%10);\n            k /= 10;\n        }\n\n        reverse(res.begin(),res.end());\n\n        return res;\n    }\n};\n```\n### 复杂度\n时间复杂度：O(max(n,log k))，最大不会超过O(n)\n\n空间复杂度：O(1)。使用的空间为常数\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186204571","body":"### 思路\n先从左往右遍历一遍字符串，记录与目标字符之间距离结果，再从右往左遍历一遍字符串，此时与目标字符之间距离结果需与从左往右的结果进行比较，选择较小的结果的为最终结果\n### 代码\n``` C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> res(n);\n        int pos = INT_MIN/2;\n        for(int i = 0; i < n; i++){\n            if(s[i]==c){\n                pos = i;\n            }\n            res[i] = i - pos;\n        }\n        pos = INT_MAX/2;\n        for(int i = n - 1; i >= 0; i--){\n            if(s[i] == c){\n                pos = i;\n            }\n            res[i] = min(res[i],pos - i);\n        }\n\n        return res;\n    }\n};\n```\n### 复杂度\n##### 时间复杂度：O(n),n为字符串长度\n##### 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186537641","body":"### 思路\n用vector数组来模拟栈，通过top值来表示表示当前栈顶位置。对应的函数操作根据栈的相关操作来实施。\n### 代码\n``` C++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != stack.size() - 1){\n            top++;\n            stack[top] = x;\n        }\n        \n        \n    }\n    \n    int pop() {\n        if(top == -1)\n            return -1;\n        top--;\n        return stack[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int len = min(k,top+1);\n        for(int i = 0; i < len; i++){\n            stack[i] += val;\n        }\n    }\nprivate:\n    vector<int> stack;\n    int top;\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192339879","body":"### 思路\n因为本题中操作的最小单元就是两个相邻节点位置交换，所有采用递归的方法去重复的做这件事即可。  \n首先采用递归，就要确定返回值以及终止条件，在本题目中返回值就是交换过后的子链表的头节点，终止条件为当前节点为空或者下一节点为空（ps：最后一个节点）\n### 代码\n``` C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == NULL || head->next == NULL)\n            return head;\n        ListNode* n1 = head->next;\n        head->next = swapPairs(n1->next);\n        n1->next = head;\n        return n1;\n    }\n};\n```\n### 复杂度分析\n时间复杂度：O(n)   \n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185168321","body":"## 思路\n\n+ 一开始想的 数组转化数学位数进行相加  A[i] * Math.pow(10, A.length - i - 1) 结果会出现计算不准确\n+ 采用 两数组从尾部开始相加。 大于 10 进一位; 最后一位相加 大于10 数组尾部 补 1；\n\n## 题解\n```\n// 采用 两数组 对应位数相加 大于 10 进一位; 最后一位相加 大于10 数组尾部 补 1；\nfunction addToArrayForm(A: number[], K: number): number[] { \n    let list = (K+'').split('')\n    let len_A = A.length - 1;\n    let len_K = list.length - 1;\n    let result = <any>[];\n    let n = 0\n    \n    // 两数组存在值 继续执行\n    while (A[len_A] >= 0  || Number(list[len_K]) >= 0) {\n\n        // 位数之和\n        let sum = Number(list[len_K] || 0) + ( A[len_A]?A[len_A] : 0 ) + n;\n\n        // 重置 n\n        n = 0\n        // 位数之和 是否 大于 10\n        if(sum >= 10) n = 1;\n\n        // 余数添加进去\n        result.push(sum%10);\n\n        // 递减\n        len_K--\n        len_A--\n    }\n\n    // 处理最后一位结果 大于 10 \n    if(n === 1) {\n        result.push(1);\n    }\n    \n\n    return result.reverse();\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186212500","body":"## 思路\n左右遍历 取最小值\n## 代码\n```\nfunction shortestToChar(s: string, c: string): number[] {\n  const n = s.length;\n  const result: number[] = [];\n  let ids = s.indexOf(c);\n\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      ids = i;\n    }\n    result[i] = Math.abs(ids - i);\n  }\n\n  ids = s.lastIndexOf(c);\n\n  for (let i = n - 1; i >= 0; i--) {\n    if (s[i] === c) {\n      ids = i;\n    }\n    result[i] = Math.min(result[i], Math.abs(ids - i));\n  }\n\n  return result;\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186379692","body":"## 思路\n使用数组模拟栈\n## 代码\n```\nclass CustomStack {\n  private _stack: number[] = []; // 栈\n  private _stackSize = -1; // 栈最大长度\n  constructor(maxSize: number) {\n    this._stackSize = maxSize;\n  }\n\n  push(x: number): void {\n    // 不能超过栈最大长度\n    if (this._stack.length === this._stackSize) return;\n    this._stack[this._stack.length] = x;\n  }\n\n  pop(): number {\n    // 栈空返回 -1\n    return this._stack.length === 0 ? -1 : this._stack.pop()!;\n  }\n\n  increment(k: number, val: number): void {\n    for (let i = 0; i < k; i++) {\n      this._stack[i] ? (this._stack[i] += val) : null;\n    }\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187622983","body":"## 思路\n利用栈进行操作\n\n如果是字符数字获取相连数字值\n\n如果是字符 进行拼接字符\n\n将数字值和字符串进行数组存储\n\n遇到 [ 时进行入栈\n\n遇到 ] 时进行出栈，出栈的时候 通过repeat方法进行复制 拼接\n\n## 代码\n```typescript\nfunction decodeString(s: string) {\n  let stack: Array<[number, string]> = [];\n\n  // 入栈\n  function add(k: [number, string]) {\n    stack.push(k);\n  }\n\n  function pop(): [number, string] {\n    return stack.pop() ?? [0, \"\"];\n  }\n\n  let str: string = \"\";\n  let l: [number, string] = [0, \"\"];\n  for (let i = 0; i < s.length; i++) {\n    const e = s[i];\n\n    // 如果是数字 进行数组计算\n    if (!isNaN(Number(e.toString()))) {\n      l[0] = l[0] * 10 + Number(e);\n    } else if (e === \"[\") {\n      l[1] = str;\n      add(l);\n\n      l = [0, \"\"];\n      str = \"\";\n    } else if (e === \"]\") {\n      let p: [number, string] = pop();\n\n      // str 拿到的是 最后一个 [] 内的值\n      str = p[1] + str.repeat(p[0]);\n    } else {\n      str += e;\n    }\n  }\n\n  return str;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189116410","body":"## 思路\n采用两个栈 stack_1 和 stack_2\n\npush 的时候都压入 stack_1 栈\n\n出栈的时候 先把 stack_1 中的数据 入栈到 stack_2 中 这样队列的第一个元素 就在 stack_2 栈顶\n\n当 stack_2 中存在值 栈顶 永远是 队列的开头\n\n当 stack_1 和 stack_2 都为空的时候 表示 队列为空\n```typeScript\nclass MyQueue {\n  // 栈的特点 先进后出\n  stack_1: number[] = [];\n  stack_2: number[] = [];\n  constructor() {}\n\n  push(x: number): void {\n    this.stack_1.push(x);\n  }\n\n  // 从队列的开头移除并返回元素\n  pop(): number {\n    if (this.stack_2.length === 0) {\n      while (this.stack_1.length > 0) {\n        this.stack_2.push(this.stack_1.pop()!);\n      }\n    }\n    return this.stack_2.pop()!;\n  }\n\n  // 返回队列开头的元素\n  peek(): number {\n    if (this.stack_2.length === 0) {\n      while (this.stack_1.length > 0) {\n        this.stack_2.push(this.stack_1.pop()!);\n      }\n    }\n    return this.stack_2[this.stack_2.length - 1];\n  }\n\n  // 判断队列是否为空\n  empty(): boolean {\n    return !this.stack_1.length && !this.stack_2.length ? true : false;\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190463079","body":"## 思路 \n没解出来\n看到 单调栈 和 滑动窗口 研究了下 真奇妙\n\n## 代码\n单调栈\n```typeScript\nfunction maxChunksToSorted(arr: number[]): number {\n  let stack: number[] = [];\n  for (let i = 0; i < arr.length; i++) {\n    const e = arr[i];\n    if (stack && stack[stack.length - 1] > e) {\n      let cru = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > e) {\n        stack.pop();\n      }\n      stack.push(cru);\n    } else {\n      stack.push(e);\n    }\n  }\n  return stack.length;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191453577","body":"## 思路\n将链表闭环\n\nk 代表指针从链表头开始走的次数。如果k 大于 链表长度 会进行循环移动。所以我们去除循环链表的次数。剩下最后一次移动的个数。指针走到哪个位置就是要断开的地方\n\n## 代码\n\n```typeScript\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n\n    if(!head || !head.next || !k) return head\n\n    // 将链表形成环 然后再断来链表\n    let header = head\n    let n = 1\n    while(header.next) {\n        header = header.next\n        n++\n    }\n\n    // 形成闭环\n    header.next = head\n\n    // k 值大于 链表长度的时候\n    // 会循环链表。k = 循环链表的次数*链表长度 + 最后走的个数 ; 所以我们只需要移动最会走的个数 就是要断开链表的位置\n    // 也就是 k 除以链表长度 的余数\n    let num = n - k%n\n    while(num) {\n        header = header.next\n        num--\n    }\n\n    let r = header.next\n    header.next = null\n\n    return r\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192631290","body":"## 思路\n利用递归 来交换节点\n\n## 代码\n```\nfunction swapPairs(head: ListNode | null): ListNode | null {\n\n    if(head == null || head.next ===  null) {\n        return head\n    }\n\n    // 2n\n    let last = head.next;\n    // last.next === 2n+1  \n    // return 2n+2\n    let next2 = swapPairs(last.next)\n    // 2n = 2n+2\n    head.next = next2\n    // 2n = 2n+1\n    last.next = head\n    return last\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193156623","body":"```typeScript\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n\n    let m = new Set()\n    let h1 = headA\n    while(h1) {\n        m.add(h1)\n        h1 = h1.next\n    }\n\n    let h2 = headB\n    while(h2) {\n        if(m.has(h2)) {\n            return h2\n        }\n        h2 = h2.next\n    }\n\n    return null\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195611609","body":"## 思路\nMap\n\n## 代码\n```typeScript\nclass LRUCache {\n    private map = new Map()\n    private capacity = 0\n    constructor(capacity: number) {\n        this.capacity = capacity\n    }\n\n    get(key: number): number {\n\n        if(this.map.has(key)) {\n            let n = this.map.get(key)\n            this.map.delete(key)\n            this.map.set(key, n)\n            return n\n        } else {\n            return -1\n        }\n    }\n\n    put(key: number, value: number): void {\n        \n        if(this.map.has(key)) {\n            this.map.delete(key);\n        }\n\n        this.map.set(key, value)\n\n        if(this.map.size > this.capacity) {\n            this.map.delete(this.map.keys().next().value)\n        } \n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185170165","body":"#### 代码 \n\n```Python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i=len(num)-1\n        while k>0:\n            added = num[i]+k\n            num[i]=added%10  # remainder\n            k=added//10    # carry\n            i-=1\n            if i<0 and k>0:\n                num.insert(0,0)\n                i=0\n        return num\n```\n\n#### 复杂度分析\n时间复杂度： O(N)  </br>\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186052450","body":"### 思路 \n从左至右遍历s， 得到左边最近c的距离\n从右至左遍历s， 得到右边最近c的距离与左边最近c的距离的较小值\n#### 代码 Python\n\n```Python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        #time O(N) space O(N)\n        res=[float('inf')]*len(s)\n        last_c = float('inf')\n        for i in range(len(s)):\n            if s[i]==c:\n                last_c=i\n            res[i]=abs(last_c-i)\n        \n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                last_c=i\n            res[i]=min(res[i],abs(last_c-i))\n        return res\n\n\n```\n\n#### 复杂度分析\n时间复杂度：O(N)    </br>\n空间复杂度：O(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188597906","body":"#### 代码 Python\n\n```Python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1=[]\n        self.stack2=[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            \n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n           \n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        if self.stack1 or self.stack2:\n            return False\n        else:\n            return True\n\n```\n\n#### 复杂度分析\n时间复杂度： O(N) </br>\n空间复杂度：O(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192146089","body":"### 思路 \n遍历链表， 每次交换两个node\n#### 代码 Python\n\n```Python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n        dummy=ListNode(-1)\n        dummy.next=head\n        cur=head\n        prev=dummy\n        while cur and cur.next:\n            prev.next=cur.next\n            prev=prev.next\n            cur.next = prev.next\n            prev.next=cur\n   \n            prev=prev.next\n            cur=cur.next\n        return dummy.next\n```\n\n#### 复杂度分析\n时间复杂度： O(N) </br>\n空间复杂度： O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193243758","body":"### 思路 \na1->a2->*c1->c2->b1->b2->b3->*c1->c2  </br>\nb1->b2->b3->*c1->c2->a1->a2->*c1->c2\n#### 代码 Python\n\n```Python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not headA or not headB:\n            return None\n        #list1:a1->a2->*c1->c2 \n        #list2:b1->b2->b3->*c1->c2\n        #a1->a2->*c1->c2->b1->b2->b3->*c1->c2  O(m+n)\n        #b1->b2->b3->*c1->c2->a1->a2->*c1->c2\n        cur1=headA\n        cur2=headB\n        while cur1!=cur2:\n            if cur1:\n                cur1=cur1.next\n            else:\n                cur1 = headB\n              \n            if cur2:\n                cur2=cur2.next\n            else:\n                cur2 = headA\n           \n        return cur1   \n\n```\n\n#### 复杂度分析\n时间复杂度： O(M+N) </br>\n空间复杂度： O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193361161","body":"\n### 思路 \n快慢指针\n#### 代码 \n\n```Python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast=head\n        slow=head\n        while True:\n            if not fast or not fast.next:\n                return None\n            fast=fast.next.next\n            slow=slow.next\n            if slow==fast:\n                break\n        fast=head\n        while fast!=slow:\n            fast=fast.next\n            slow=slow.next\n        return slow\n        \n```\n\n#### 复杂度分析\n时间复杂度： O(N) </br>\n空间复杂度： O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197613987","body":"### 思路 \nRecursion\n#### 代码 Python\n\n```Python\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        elif not p and q:\n            return False\n        elif not q and p:\n            return False\n        elif p.val!=q.val:\n            return False\n            \n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n\n```\n\n#### 复杂度分析\n时间复杂度： O(N) </br>\n空间复杂度： O(H) H is the depth of the tree","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185170186","body":"### Idea\n\njust add the end of two numbers\n\n### Code\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int len = num.length;\n        int carry = 0;\n        int index = len - 1;\n\n        while(index >= 0 && k > 0) {\n            int temp = k % 10;\n            int total = temp + num[index] + carry;\n\n            //update\n            carry = total / 10;\n            total = total % 10;\n\n            //put the num to res\n            res.add(0, total);\n\n            //update\n            index--;\n            k = k / 10;\n        }\n\n        while(index >= 0) {\n            int total = num[index] + carry;\n\n            //update\n            carry = total / 10;\n            total = total % 10;\n\n            //put the num to res\n            res.add(0, total);\n\n            //update\n            index--;\n        }\n\n        while(k > 0) {\n            int total = k % 10 + carry;\n\n            //update\n            carry = total / 10;\n            total = total % 10;\n\n            //put the num to res\n            res.add(0, total);\n\n            //update\n            k = k / 10;\n        }\n\n        if(carry != 0) {\n            res.add(0, carry);\n        }\n\n        return res;\n\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N), N is the longest of the two lengths（num.length & k.length()）\n- Space Complexity： O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186150582","body":"### Idea\r\n- First loop: traverse from left to right to find the nearest c on the left.\r\n- Second loop:  traverse from right to left to find the nearest c on the right.\r\n### Code\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len]; \r\n\r\n        int minNum = Integer.MIN_VALUE / 2; //make sure the num is smaller enough\r\n        int pre = minNum; //the distance of the nearest C on the left\r\n        for(int i = 0; i < len; i++) {\r\n            if(s.charAt(i) == c) {\r\n                pre = i;\r\n            }\r\n\r\n            res[i] = i - pre;//make sure the distance of nearest C on the left\r\n        }\r\n\r\n        int maxNum = Integer.MAX_VALUE / 2; //make sure the num is larger enough\r\n        int later = maxNum; // the distance of the nearest C on the right\r\n        for(int i = len - 1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                later = i;\r\n            }\r\n\r\n            res[i] = Math.min(res[i], (later - i));\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**Complexity Analysis**\r\n- Time Complexity： O(N) \r\n- Space Complexity： O(1) (  The return value is not included in the space complexity.  )\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186513643","body":"### Idea\n\nbuild an array(int[] stack) to save the data, and then build an array(int[] auxiliaryAdd) to save the increments\n\n### Code\n\n\n```java\nclass CustomStack {\n    int[] stack;//store data\n    int[] auxiliaryAdd; // the auxiliary array to store the increments\n    int len;// the length about this stack\n    int top = -1;// the num in the stack\n\n    public CustomStack(int maxSize) {\n        this.len = maxSize;\n        this.stack = new int[this.len];\n        this.auxiliaryAdd = new int[this.len];\n    }\n    \n    public void push(int x) {\n        if(this.top < (this.len - 1)) {\n            this.top++;\n            this.stack[this.top] = x;         \n        }\n    }\n    \n    public int pop() {\n        if(this.top < 0) {\n            return -1;\n        }\n\n        int temp = this.stack[this.top] + this.auxiliaryAdd[this.top];\n\n        if(this.top > 0) {\n            this.auxiliaryAdd[this.top - 1] += this.auxiliaryAdd[this.top]; //superimpose the previous increase\n        }\n\n        auxiliaryAdd[top] = 0; // we need to initialize this auxiliaryAdd[top] !!!!!!\n \n        this.top--;\n\n        return temp;\n    }\n    \n    public void increment(int k, int val) {\n        if(this.top == -1) {\n            return;// this means if the stack has none num, we do not need to do anything\n        }\n\n\n        int temp = Math.min(k - 1, this.top);\n\n        auxiliaryAdd[temp] += val;// this step is superimpose,  not just auxiliaryAdd[temp] = val; !!!\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(1)  (just get the num from the array)\n- Space Complexity： O(N) (cause we build two arrays to save data and increment)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187191289","body":"### Idea\nUse stack to simulate this process\n\n\n\n### Code\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<Integer> numStack = new ArrayDeque<>();//save the times\n        Deque<String> strStack = new LinkedList<>();//save the string\n        StringBuilder tail = new StringBuilder();//recode the string\n        \n        int len = s.length();\n        for(int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n\n            if(Character.isDigit(c)) {\n                //Character.isDigit(c) means if the c is num \n                int num = c - '0';\n                while(i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\n                    //the num may do not just single\n                    num = num * 10 + s.charAt(i + 1) - '0';\n                    i++;\n                }    \n                numStack.push(num);          \n            }\n\n            else if(c == '[') {\n                //push the contents of tail to strStack\n                strStack.push(tail.toString());\n                tail = new StringBuilder();\n            }\n\n            else if(c == ']') {\n                //cause the things in brackets are saved in the tail \n                //times are saved in the numStack\n                //strStack contains string between two left brackets('[')\n\n                StringBuilder temp = new StringBuilder();\n                temp.append(strStack.pop());\n\n                int times = numStack.pop();\n                for(int j = 0; j < times; j++) {\n                    temp.append(tail);\n                }\n\n                tail = temp;\n            }\n\n            else {\n                tail.append(c);\n            }\n\n            //i++; \n            //we do not need i++, cause : for(int i = 0; i < len; i++)\n        }\n\n        return tail.toString();\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N) \n- Space Complexity： O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188797393","body":"### Idea\nUse two stacks to simulate this process\n\n\n\n### Code\n\n\n```java\n\nclass MyQueue {\n    Deque<Integer> inPut;\n    Deque<Integer> outPut;\n\n    public MyQueue() {\n        inPut = new ArrayDeque<>();\n        outPut = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        inPut.push(x);\n    }\n    \n    public int pop() {  \n        if(outPut != null && !outPut.isEmpty()) {\n            return outPut.pop();\n        }\n\n        while(inPut != null && !inPut.isEmpty()) {\n            outPut.push(inPut.pop());           \n        }\n\n        return outPut.pop();  \n    }\n        \n    public int peek() {\n         if(outPut != null && !outPut.isEmpty()) {\n            return outPut.peek();\n        }\n\n        while(inPut != null && !inPut.isEmpty()) {\n            outPut.push(inPut.pop());      \n        }\n\n        return outPut.peek();  \n    }\n    \n    public boolean empty() {\n        return (outPut.isEmpty() && inPut.isEmpty());\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N) \n- Space Complexity： O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190303585","body":"### Idea\nUsing monotonic incremental stack\n\n\n\n### Code\n\n\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for(int num : arr) {\n            int temp = Integer.MIN_VALUE;\n\n            while(!stack.isEmpty() && stack.peek() > num) {\n                //this means the num is smaller than the stack.peek(), so we need to merge them into one\n                //Because it is monotonically increasing, the first pop-up must be the largest, so we only need to record the value of the first pop-up\n                temp = Math.max(temp, stack.pop());\n            }\n\n            if(temp == Integer.MIN_VALUE) {\n                stack.push(num);//Num does not need to be merged with the previous block, so it is pushed into the stack\n            }\n            else {\n                stack.push(temp);\n            }\n        }\n\n        return stack.size();\n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N) \n- Space Complexity： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191351567","body":"### Idea\nFirstly, calculate the point to be truncated: k%len.   \nThen cut it directly and connect the head to the tail (note that when k = = len, the head should be returned directly).\n\n\n\n### Code\n\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        //corner case\n        if(head == null || head.next == null || k == 0) {\n            return head;\n        }\n\n        int len = 0;// the length of head\n\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n\n        ListNode last = dummy;\n\n        while(last.next != null) {\n            len++;\n            last = last.next;\n        }\n\n        int cut = len - k % len;\n\n        if(cut == len) {\n            return head;//pay attention: cause if cut == len ,  ListNode res = pre.next;(pre.next == null), and we will return null, so we need to return head if cut == len\n        } \n\n        ListNode pre = dummy;\n\n        for(int i = 0; i < cut; i++) {\n            pre = pre.next;\n        }\n\n        ListNode res = pre.next;\n        pre.next = null;\n        last.next = head;\n\n        return res;\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N) \n- Space Complexity： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192600788","body":"### Idea\nUse iterations to simulate the process\n\n\n\n### Code\n\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        //corner case\n        if(head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n\n        ListNode pre = dummy;\n        ListNode curr = dummy.next;\n        ListNode next = curr.next;\n\n        while(curr != null && next != null) {\n            pre = swap(pre, next);\n            curr = pre.next;\n            if(curr != null) {\n                next = curr.next;\n            }\n        }\n\n        return dummy.next;\n    }\n\n    private ListNode swap(ListNode pre, ListNode next) {\n        ListNode curr = pre.next;\n        ListNode res = curr;\n\n        ListNode temp = next.next;\n\n        pre.next = next;\n        next.next = curr;\n        curr.next = temp;\n\n        return res;\n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N) \n- Space Complexity： O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193112221","body":"### Idea\nuse the Fast and Slow Pointers to find the mid node, and then Divide and Conquer\n\n\n\n### Code\n\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        //corner case\n        if(head == null) {\n            return null;\n        }\n\n        else if(head.next == null) {\n            return new TreeNode(head.val);\n        }\n\n        //Use the Fast and Slow Pointers to find the mid Node\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode pre = null; //Pre is the previous node of the slow Node\n\n        while(fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        pre.next = null;//Unlinks the node ！！！！！！！！！\n\n        //recursion\n        TreeNode node = new TreeNode(slow.val);\n        node.left = sortedListToBST(head);\n        node.right = sortedListToBST(slow.next);\n\n        return node;\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(NlogN) Each layer uses a while loop (fast and slow pointer) to find its own middle point, so each layer is O(N), and there are altogether logN layers, so the total time complexity is O(NlogN)\n- Space Complexity： O(logN)  Recursion is a total of logN layers, so O(logN) additional space is required in general      ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193317284","body":"### Idea\nUse two pointers \n\n\n\n### Code\n\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // use two pointers\n\n        ListNode pointerA = headA;\n        ListNode pointerB = headB;\n\n        while(pointerA != pointerB) {\n            if(pointerA == null) {\n                pointerA = headB;\n            }\n            else {\n                pointerA = pointerA.next;\n            }\n\n            if(pointerB == null) {\n                pointerB = headA;\n            }\n            else {\n                pointerB = pointerB.next;\n            }        \n        }\n\n        return pointerA;\n        \n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(1)   \n- Space Complexity： O(m + n)  m is the length of headA LinkedList, n is the length of headB LinkedList","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194180987","body":"### Idea\nUse the Fast and Slow Pointers to find if the LinkedList is the loop, and then use the ListNode index_1 = slow and ListNode index_2 = head; to get the the node where the cycle begins\n\n\n\n### Code\n\n\n```java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n\n            if(slow == fast) {\n                ListNode index_1 = slow;\n                ListNode index_2 = head;\n                while(index_1 != index_2) {\n                    index_1 = index_1.next;\n                    index_2 = index_2.next;\n                }\n                return index_1;\n            }\n        }\n\n        return null;\n        \n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N)   \n- Space Complexity： O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195449506","body":"```java\nclass LRUCache {\n\n    private int capacity;\n    private HashMap<Integer, Node> map;\n    private Node head, tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        //map = new HashMap<>(capacity);\n        map = new HashMap<>();\n\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        //分别指向头和尾结点\n\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        if( !this.map.containsKey(key) ){\n            return -1;\n        }\n\n        Node node = this.map.get(key);\n        this.moveNodeToFirst(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        //第一种情况如果之前有，则是把之前的key拿出来后，更新，并且放到最前面的位置\n        if( this.map.containsKey(key)) {\n            Node node = this.map.get(key);\n            node.value = value;\n\n            this.moveNodeToFirst(node);\n            return;\n        }\n\n        //第二种情况 当是新的时候：第一种情况：首先考虑有没有满，如果满了删除最后一个，添加新的\n        if( this.map.size() == this.capacity ) {          \n            Node last = this.tail.prev;\n            this.map.remove(last.key);\n            this.removeLast(last);//这个last必须要有，不能this.removeLast();\n        }\n\n        //第二种情况 当是新的时候：第二种情况：即没有满（第一张情况已经删除）\n\n        Node node = new Node(key, value);\n        this.map.put(key, node);\n        this.addNodeToFirst(node);\n    }\n\n    private class Node {\n        public Node prev, next;\n        public int key, value;\n\n        public Node(int k, int v) {\n            this.key = k;\n            this.value = v;\n        }\n\n    }\n\n    private void removeLast(Node last) {\n        //这个last就是最后key,不是之前的tail尾结点\n        last.prev.next = tail;\n        tail.prev = last.prev;\n\n        //清空last\n        last.prev = null;\n        last.next = null;\n    }\n\n    private void addNodeToFirst(Node node) {\n        Node currfirst = head.next;\n\n        node.next = currfirst;\n        currfirst.prev = node;\n\n        head.next = node;\n        node.prev = head;     \n    }\n\n    private void moveNodeToFirst(Node node) {\n        Node nodenext = node.next;\n        Node nodeprev = node.prev;\n\n        //先把node释放\n        nodeprev.next = nodenext;\n        nodenext.prev = nodeprev;\n\n      //  node.prev = null;\n       // node.next = null;\n       //上边这个不行，因为还要用node即下面的步骤\n\n        //把node放到最开始\n        addNodeToFirst(node);\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196870781","body":"### Idea\ndfs\n\n\n\n### Code\n\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        //dfs  \n        //corner case\n        if(root == null) {\n            return 0;\n        }\n\n        int leftMax = maxDepth(root.left);\n        int rightMax = maxDepth(root.right);\n\n        return Math.max(leftMax, rightMax) + 1;\n\n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N)   \n- Space Complexity： O(height)  height indicates the height of the binary tree\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185170845","body":"### 思路\r\n先同时加array和数字\r\n再while loop 只剩下数字或者只剩下数组的情况\r\n\r\n### 代码:\r\n\r\n\r\n\r\n          class Solution:\r\n                  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n\r\n                       def add(index, k, num):\r\n                           carry = 0\r\n                          while index >= 0 and k:\r\n                              current = k % 10\r\n                              k = k // 10\r\n                              num[index] = num[index] + current + carry\r\n                              carry = 0\r\n                              if num[index] >= 10:\r\n                                  num[index] -= 10\r\n                                  carry = 1\r\n                              index -= 1\r\n                          \r\n                          while index >= 0 and carry:\r\n                              num[index] = num[index] + carry\r\n                              carry = 0\r\n                              if num[index] >= 10:\r\n                                  num[index] -= 10\r\n                                  carry = 1\r\n                              index -= 1\r\n                          \r\n                          k += carry\r\n                          while k:\r\n                              current = k % 10\r\n                              k = k // 10\r\n                              num = [current] + num\r\n                          return num\r\n                              \r\n                      \r\n                     return add(len(num) - 1, k, num)\r\n\r\n### 复杂度:\r\nTime: O(length of number + length of array) or O(N)\r\nSpace: O(length of number + length of array) or O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186082185","body":"### 思路\r\n\r\n先看最左最右是不是和c一样, 是一样设为0\r\n然后左往右, 右往左各遍历一次取上一个数 + 1和本数的最小值\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [float('inf') for char in s]\r\n        \r\n        if s[0] == c:\r\n            ans[0] = 0\r\n        if s[-1] == c:\r\n            ans[-1] = 0\r\n        \r\n        for i in range(1, len(s)):\r\n            if s[i] == c:\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i - 1] + 1, ans[i])\r\n                \r\n        for j in range(len(s) - 2, -1, -1):\r\n            if s[j] == c:\r\n                ans[j] = 0\r\n            else:\r\n                ans[j] = min(ans[j + 1] + 1, ans[j])\r\n        \r\n        return ans\r\n```\r\n### 复杂度\r\n时间复杂度 O(2 * 数组size) = O(n)\r\n空间复杂度 答案size O(n)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186278497","body":"### 思路\n\n正常stack操作, 动态数组更新val\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.nums = []\n        self.size = 0\n        self.limit = maxSize\n\n    def push(self, x: int) -> None:\n        if self.size >= self.limit:\n            return\n        self.nums.append(x)\n        self.size += 1\n        return\n\n    def pop(self) -> int:\n        if not self.nums:\n            return -1\n        num = self.nums.pop()\n        self.size -= 1\n        return num\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.size)):\n            self.nums[i] += val\n        return\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### 复杂度分析\n\n时间复杂度: push / pull O(1), 改变增量 O(n)\n\n空间复杂度: O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186707653","body":"### 思路:\r\n\r\n不使用dfs一遍遍历\r\n两个栈, 一个压入乘数, 一个压入字符串\r\n\r\n预处理 给字符串两边加上\"[\" 和 \"]\"\r\n设原乘数为1\r\n\r\n遇到\"[\" 数字入栈, 乘数重新设为0, 将\"[\" 作为字符串mark压入字符栈\r\n遇到 lowercase字母, 如果是第一个字母, 创造新字符串, 不然更新最近字符串\r\n遇到乘数, 更新乘数\r\n遇到 \"]\" 把所有 前一个 \"[\"之前的字符串合并 (字符串出栈) x 最近的乘数 (乘数出栈) 再重新压入字符串栈中\r\n\r\n最后乘数栈为空, 字符串栈中唯一一个元素就是答案\r\n\r\n### 代码\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        strs = []\r\n        nums = []\r\n        \r\n        num = 1\r\n        s = \"[\" + s + \"]\"\r\n        \r\n        for char in s:\r\n            if char == \"[\":\r\n                strs.append(\"[\")\r\n                nums.append(num)\r\n                num = 0\r\n            elif char in \"0123456789\":\r\n                num = num * 10 + int(char)\r\n            elif char in \"abcdefghijklmnopqrstuvwxyz\":\r\n                if strs[-1] == \"[\":\r\n                    strs.append(char)\r\n                else:\r\n                    strs[-1] = strs[-1] + char\r\n            else:\r\n                temp = \"\"\r\n                while strs[-1] != \"[\":\r\n                    temp = strs[-1] + temp\r\n                    strs.pop()\r\n                times = nums.pop()\r\n                strs.pop()\r\n                strs.append(temp * times)\r\n                \r\n        return strs[-1]\r\n\r\n\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度: O(n) n 为字符串内所有元素个数\r\n空间复杂度: O(n) n 为字符串内所有元素个数\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188599398","body":"### 思路:\n\n用两个栈, 输入用一个栈, 输出用一个栈\n只有输出栈空的时候吧输入栈的数据dump 进输出栈\n\n### 代码\n\n```python\n\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.stack2:\n            return self.stack2.pop()\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n    \n    def peek(self) -> int:\n        if self.stack2:\n            num = self.stack2.pop()\n            self.stack2.append(num)\n            return num\n        \n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n            \n        num = self.stack2.pop()\n        self.stack2.append(num)\n        return num\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2\n\n```\n\n### 复杂度:\n时间 O(n)\n空间 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189805698","body":"### 思路:\r\n\r\n一个chunk的定义就是往右边数的最小值, 然后比所有左边的值都大...以此为概念两个数组求最大最小.\r\n没有用到单调栈?\r\n\r\n### 代码:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        maxarr = []\r\n        minarr = []\r\n        \r\n        maxnum = float('-inf')\r\n        minnum = float('inf')\r\n        \r\n        for num in arr:\r\n            maxnum = max(num, maxnum)\r\n            maxarr.append(maxnum)\r\n            \r\n        for i in range(len(arr) - 1, -1, -1):\r\n            num = arr[i]\r\n            minnum = min(num, minnum)\r\n            minarr.append(minnum)\r\n            \r\n        minarr = minarr[::-1]\r\n            \r\n        ans = 1\r\n        for i in range(1, len(minarr)):\r\n            if minarr[i] >= maxarr[i - 1]:\r\n                ans += 1\r\n        \r\n        return ans\r\n\r\n```\r\n### 复杂度:\r\n\r\n时间 O(n)\r\n空间 O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191030424","body":"### 思路:\n\n先找到链表size, 再化简k\n然后找到链表最后的尾\n然后再从头开始头一个个接到尾上\n\n### 代码\n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return head\n        size = 0\n        mark = head\n        \n        while mark:\n            size += 1\n            mark = mark.next\n        \n        k = k % size\n        \n        if k == 0:\n            return head\n        \n        move = size - k\n        \n        last = head\n        \n        while last.next:\n            last = last.next\n        \n        mark = head\n        \n        for _ in range(move):\n            newmark = mark.next\n            mark.next = None\n            last.next = mark\n            last = mark\n            mark = newmark\n        \n        return newmark\n\n\n```\n\n### 复杂度:\n\n空间: O(1)\n时间: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192022426","body":"### 思路:\n\ndummy node + 两两交换\n用node.next 和 node.next.next 做while限制\n最后接上最后节点\n\n### 代码:\n\n```python\n\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(-1)\n        node = head\n        mark = dummy\n        \n        while node and node.next:\n            nextnode = node.next.next\n            \n            mark.next = node.next\n            mark = mark.next\n            mark.next = node\n            mark = mark.next\n            \n            node = nextnode\n        \n        mark.next = node\n            \n        return dummy.next \n\n```\n\n### 复杂度\n\n时间: O(n)\n空间: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193082238","body":"### 思路:\n\n因为list已经是sorted的, 用哈希表把值和创建treenode联系在一起\n再递归二分处理根节点, 根节点总是左右节点的中间节点\n\n### 代码:\n\n```python\n\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        mark = head\n        size = 0\n        ref = {}\n        \n        while mark:\n            ref[size] = TreeNode(mark.val)\n            size += 1\n            mark = mark.next\n        \n        def copy(ref, left, right):\n            if left > right: return None\n            mid = left + (right - left) // 2\n            node = ref[mid]\n            node.left = copy(ref, left, mid - 1)\n            node.right = copy(ref, mid + 1, right)\n            return node\n        \n        return copy(ref, 0, size - 1)\n\n```\n\n```复杂度\n\n时间: O(n)\n空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193198028","body":"### 思路:\n\n双指针, 路程 a + c + b = b + c + a\n再设置哨兵bool值避免两个linkedlist不重叠\n\n### 代码\n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        startA, startB = headA, headB\n        pinA, pinB = headA, headB\n        meetA, meetB = False, False\n        \n        while pinA != pinB:\n            pinA = pinA.next\n            pinB = pinB.next\n            \n            if not pinA and not meetA:\n                pinA = startB\n                meetA = True\n            if not pinB and not meetB:\n                pinB = startA\n                meetB = True\n        \n        if pinA == pinB:\n            return pinA\n        \n        return None\n\n```\n### 复杂度\n\n时间 O(n)\n空间 O(1)\n\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194991367","body":"### 思路:\n\n哈希表搭配双向链表\n\n\n### 代码:\n\n```python\n\nclass Node:\n    def __init__(self, key, val):\n        self.prev = None\n        self.next = None\n        self.key = key\n        self.val = val\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.size = 0\n        self.cap = capacity\n        self.head = Node(-1, -1)\n        self.tail = self.head\n        self.ref = {}\n\n    def get(self, key: int) -> int:\n        if key not in self.ref:\n            return -1\n        node = self.ref[key]\n        if node.next:\n            \n            node.prev.next = node.next\n            node.next.prev = node.prev\n            node.next = None\n            \n            self.tail.next = node\n            node.prev = self.tail\n            \n            self.tail = node\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.ref:\n            node = self.ref[key] \n            node.val = value\n            if node.next:\n            \n                node.prev.next = node.next\n                node.next.prev = node.prev\n                node.next = None\n\n                self.tail.next = node\n                node.prev = self.tail\n\n                self.tail = node\n        else:\n            self.ref[key] = Node(key, value)\n            \n            self.tail.next = self.ref[key]\n            self.ref[key].prev = self.tail\n            self.tail = self.ref[key]\n            self.size += 1\n            \n            if self.size > self.cap:\n                delete = self.head.next\n                self.head.next = delete.next\n                delete.next.prev = self.head\n                delkey = delete.key\n                del self.ref[delkey]\n                self.size -= 1\n        return\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196239502","body":"### 思路:\n二叉树的最大深度, 等于 max(左子树的最大深度 , 右子树最大深度) + 1\n递归\n\n### 代码:\n\n```python\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        def probe(node):\n            if not node:\n                return 0\n            lmax = 1 + probe(node.left)\n            rmax = 1 + probe(node.right)\n            return max(lmax, rmax)\n        return probe(root)\n\n```\n\n复杂度:\n时间 O(n)\n空间 O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185188366","body":"### Idea\n\n从后往前加，while loop中更新list&integer\n\n### Code\n\n\n```python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        digit = 0\n        \n        while num or k or digit:\n            n1 = num[-1] if num else 0\n            n2 = k%10\n\n            n = n1+n2+digit\n            \n            res.insert(0, n%10)\n            digit = 1 if n>= 10 else 0\n            \n            num = num[:-1]\n            k = k//10\n                \n        return res\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(N) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185975634","body":"### Idea\n\n- 找出 `==c` 的所有index positions, store in `pos`\n- j 表示 在s中的current index\n- i，k表示在`pos`中，相邻于j的index\n\n### Code\n\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos = []\n        res = []\n        \n        for i in range(len(s)):\n            if s[i] == c:\n                pos.append(i)\n        \n        \n        i,j,k = 0,0,0\n        \n        while j < len(s):\n            if i == len(pos):\n                res.append(abs(pos[i-1]-j))\n                j+=1\n                \n            elif j <= pos[i]:\n                a = abs(pos[i]-j)\n                b = abs(pos[k]-j)\n                res.append(min(a,b))\n                j += 1\n                \n            else:\n                if i != 0:\n                    k+=1\n                i+=1\n\n        return res\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(N) as `res` will extend?","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186440842","body":"\n### Idea\n\n按照示例的情况写\n\n### Code\n\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.list = []\n        \n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.maxSize:\n            self.list.append(x)\n\n    def pop(self) -> int:\n        if not self.list:\n            return -1\n        else:\n            num = self.list[-1]\n            self.list = self.list[:-1]\n\n            return num\n        \n\n    def increment(self, k: int, val: int) -> None:\n        if k >= len(self.list):\n            k = len(self.list)\n        for i in range(k):\n            self.list[i] += val\n        \n```\n\n### Complexity\n- Time：push ：O(1)，pop：O(1)，increment：O(k)\n- Space：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186739082","body":"\n### Idea\n\n- 从s的第一位读起，根据读到的char进行不同操作：\n* 如果碰到数字则记录次数，如果碰到字母则记下并移到下一位，如果 `==[` 则记录读过的string和次数放进stack，如果 `==]` 则stack.pop() 补充一次[]的完整string\n- 当  \\[ \\] 次数相同时，一个完整的string已经完成，加进res中\n\n### Code\n\n```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = ''\n        l= 0\n        stack = []\n        cur = ''\n        i = 0\n        freq = 0\n        \n        while i < len(s):\n            if s[i] == '[':\n                l += 1\n                stack.append([cur,freq])\n                cur = ''\n                freq = 0\n                i+=1\n            elif s[i].isdigit():\n                while s[i].isdigit():\n                    freq = freq*10+int(s[i])\n                    i+=1\n            elif s[i] == ']':\n                l -=1\n                pre, num = stack.pop()\n                cur = pre + cur*num\n                if l == 0:\n                    res += cur\n                    cur = ''\n                i+=1\n                \n            elif s[i].isalpha():\n                cur += s[i]\n                i+=1\n            \n        return res+cur\n\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188169392","body":"### Idea\n\n- s1记录push进queue的数值\n- s2记录queue的头部信息\n- 当要调取queue头部信息时将s1的内容pop出来，push进s2中，当s2中无数据的时候再从s1中pop保留顺序\n\n### Code\n\n```python3\nclass MyQueue:\n\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n        \n\n    def push(self, x: int) -> None:\n        self.s1.append(x)\n        \n\n    def pop(self) -> int:\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            \n        return self.s2.pop()\n        \n        \n    def peek(self) -> int:\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            \n        return self.s2[-1]\n        \n        \n    def empty(self) -> bool:\n        return not (self.s1 or self.s2)\n\n```\n\n### Complexity\n- Time：push() & empty(): O(1), pop() & peek(): O(N)\n- Space：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189508899","body":"### Idea\n\n- 单调栈stack储存一个单调递增的array，用于记录每一个chunk的最大值，最后return len(stack)\n- 遍历arr， 如果`>= 前一位` 则放进stack，表示可以作为一个单独的chunk，else则pop stack中的数直到满足单调栈的条件，此刻放入第一次pop的值进stack代表这个chunk的最大值\n\n### Code\n\n```python3\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        last = -1\n        \n        for num in arr:\n            while stack and stack[-1] > num:\n                last = max(stack.pop(), last)\n                \n            stack.append(max(num, last))\n                \n        return len(stack)\n\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190861320","body":"### Idea\n- 遍历list，记录list长度 `n` 以及 tail node `e1`\n- `tail.next = head` 连接list首尾\n- 计算break node `e2` where `e2.next` is the new head node\n\n### Code\n\n\n```python3\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head \n        \n        # length of the list\n        n = 0\n        e1 = dummy\n        while e1.next:\n            e1 = e1.next\n            n += 1\n            \n        e1.next = head\n        jumps = n - k%n\n        \n        # Find the break point\n        e2 = dummy\n        \n        for i in range(jumps):\n            e2 = e2.next\n\n        dummy.next = e2.next\n        e2.next = None\n        \n        return dummy.next\n\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191976934","body":"### Idea\n- 用文章中提到的穿针引线的想法，记录四个端点pre, end, head, head.next 然后用.next重新连接达到效果\n\n### Code\n\n```python3\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        pre = dummy\n        \n        while head and head.next:\n            end = head.next.next\n            \n            pre.next = head.next\n            pre.next.next = head\n            \n            head.next = end\n            \n            pre = head\n            head = end\n            \n        return dummy.next\n\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1192958829","body":"### Idea\n- 快慢指针找中点做root node，同时将linked list以中点分割成左右两边两个小的linked list\n- 左边的linked list将会放在root.left,用同样的方法找中点\n- 右边类似\n\n### Code\n\n```python3\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        fast = slow = head\n        left = head\n        \n        while fast and fast.next:\n            fast = fast.next.next\n            left = slow\n            slow = slow.next\n            \n        left.next = None\n        right = slow.next\n        root = TreeNode(slow.val)\n\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(right)\n        \n        return root\n    \n```\n\n### Complexity\n- Time：O(nlogn)\n- Space：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193180083","body":"### Idea\n- 将list A所有元素存入set中，遍历list B 检查当前node是否在set中。在则返回当前node，遍历结束则表示不在，返回null\n\n### Code\n\n```python3\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        store = set()\n        \n        while headA:\n            store.add(headA)\n            headA = headA.next\n            \n        while headB:\n            if headB in store:\n                return headB\n            else:\n                headB = headB.next\n                \n        return None\n            \n    \n```\n\n### Complexity\n- Time：O(n)\n- Space：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194846214","body":"### Idea\n- 快慢指针法\n- 指针相遇之后，快指针从头开始一步步走，等到再次相遇就是环的起点。数学证明\n\n### Code\n\n```python3\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = slow = head\n\n        if not head or not fast.next or not fast.next.next:\n            return None\n        \n        slow = slow.next\n        fast = fast.next.next\n        \n        while fast.next and fast != slow:\n            fast = fast.next.next\n            slow = slow.next\n            \n            if not (fast and fast.next):\n                return None\n            \n        \n        fast = head\n        \n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n            \n        return fast\n\n```\n\n### Complexity\n- Time：O(n)\n- Space：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194793805","body":"### Idea\n- 跟着讲义设计题的思路，使用双向链表（记录access的先后）和hash table（一次提取key对应的key-value pair）\n- `self.cur` 记录现有链表长度\n- 更新链表顺序涉及：1. 提取current node by connecting its pre & next，2. 将current node放到最头的位子\n- 在put中，如果key事先存在，则更新链表顺序，如key不存在，则新建node；这时，利用长度判断是否需要删除链表尾部node\n\n### Code\n\n```python3\nclass Node:\n    def __init__(self, key, val, pre=None, nxt=None):\n        self.key = key\n        self.val = val\n        self.pre = None\n        self.nxt = None\n        \nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cur = 0\n        self.store = {}\n        self.dummy = Node(0, 0)\n        self.tail = Node(0, 0)\n        \n        self.dummy.nxt = self.tail\n        self.tail.pre = self.dummy\n\n    def get(self, key: int) -> int:\n        \n        if key in self.store:\n            node = self.store[key]\n            \n            node.pre.nxt = node.nxt\n            node.nxt.pre = node.pre\n            \n            temp = self.dummy.nxt\n            self.dummy.nxt = node\n            node.nxt = temp\n            \n            temp.pre = node\n            node.pre = self.dummy\n            \n            \n            return self.store[key].val\n\n        else:\n            return -1\n        \n        \n    def put(self, key: int, value: int) -> None:\n        if key in self.store:\n            self.store[key].val = value\n            \n            node = self.store[key]\n            node.pre.nxt = node.nxt\n            node.nxt.pre = node.pre\n        \n            \n        else:\n            new = Node(key, value)    \n            self.store[key] = new\n            \n            if self.cur >= self.capacity:\n                self.tail = self.tail.pre\n                self.tail.nxt = None\n\n                del self.store[self.tail.key]\n                self.cur -= 1\n                \n            self.cur += 1\n            \n        node = self.store[key]\n        \n        temp = self.dummy.nxt\n        self.dummy.nxt = node\n        node.nxt = temp\n        \n        temp.pre = node\n        node.pre = self.dummy\n```\n\n### Complexity\n- Time：O(1)\n- Space：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195780669","body":"### Idea\n\n- 用递归的想法，每一个树的最大深度，都是1 + max（左子树深度，右子树深度）\n- 递归终止条件是此子树为空\n\n### Code\n\n```python3\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n```\n\n### Complexity\n- Time：O(N)\n- Space：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197059458","body":"### Idea\n\n- 用递归的想法，对于第一个root node而言 only if p.val == q.val 且左子树和右子树也相同才是相同的两棵树\n- 而左右子树又可通过类似的方式判断\n- 列出可能的终止条件\n\n### Code\n\n```python3\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        else:\n            return False\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185190357","body":"### 思路\r\n\r\n逐位相加\r\n\r\n### 代码\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    let len = num.length;\r\n    for(let i=len-1; i>=0;i--){\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if(sum>=10){\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);  \r\n    }\r\n    for(let i =k;i>0;i=Math.floor(i/10)){\r\n        res.push(i % 10)\r\n    }\r\n    res.reverse();\r\n    return res;\r\n\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186100713","body":"\n### 思路\n\n先获取字符在字符串中的所有位置，然后遍历算出最小距离\n\n### 代码\n\n\n```js\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let targetS = getCharactorIndex(s,c);\n    let res = [];\n    for(let i=0; i<s.length; i++){\n        let min = Number.MAX_SAFE_INTEGER;\n        for(let j=0;j<targetS.length;j++){\n            min = Math.min(min,Math.abs(targetS[j] - i));\n        }\n        res.push(min);\n    }\nreturn res;\n\n};\n\nconst getCharactorIndex = (s,c) =>{\n    let res = [];\n    let charactorArray = s;\n    let idx = charactorArray.indexOf(c);\n    let num = 0;\n    while(idx != -1){\n        res.push(idx);\n        num++\n        idx = charactorArray.indexOf(c,idx+1);\n    }\n    return res;\n\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n^2)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186371345","body":"\n### 思路\n\n数组实现栈\n\n### 代码\n\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.n = maxSize;\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length >= this.n){\n        return\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length>0){\n       return this.stack.pop();\n    }\n    return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let temp = this.stack.splice(0,k>=this.stack.length?this.stack.length:k);\n    temp = temp.map((item)=>{\n        return item = item + val\n    })\n    this.stack = temp.concat(this.stack);\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186785147","body":"\n### 思路\n\n利用栈的方式；当遇到数字时，存入栈。 遇到‘【’时，记录前面的字符结果，然后入栈；遇到‘】’时，数字和上次的str同时出栈，然后计算本次的字符串的叠加。\n\n### 代码\n\n\n```js\nvar decodeString = function(s) {\n    let numStack = [];\n    let strStack = [];\n    let num =0;\n    let res = '';\n\n    for(let char of s){\n        if(!isNaN(char)){\n            num = num * 10 + Number(char);\n        }else if(char === '['){\n            strStack.push(res);\n            res = '';\n            numStack.push(num);\n            num = 0;\n        }else if(char ===']'){\n            res = strStack.pop() + res.repeat(numStack.pop());\n        }else{\n            res += char;\n        }\n    }\n    return res;\n\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188914373","body":"\n### 思路\n\npush方法将数据存入stack1中，用stack1来存储数据<br>\npop方法将stack1的数据弹出，当stack2为空时，将stack1的数据弹出，push到stack2中。然后再弹出最后一条，就是队列的第一条\n\n### 代码\n\n\n```js\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n     if(!this.stack2.length){\n         while(this.stack1.length){\n             this.stack2.push(this.stack1.pop())\n         }\n     }\n     return this.stack2.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.stack2.length){\n        while(this.stack1.length){\n             this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stack1.length && !this.stack2.length;\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191383951","body":"### 思路\n1、确认移动步数为（链表长度%k）\n2、循环剩余移动部署，指针游走，确定最后链表结果。\n\n### 代码\n\n\n```js\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while(cur.next){\n        cur = cur.next;\n        n++\n    }\n    let move = n - k % n;\n    cur.next = head;\n    while(move){\n        cur = cur.next;\n        move--;\n    }\n    let ans = cur.next;\n    cur.next = null;\n    return ans;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193934899","body":"\n### 思路\n\n利用哈希表，定义一个visited记录链表节点，如果存在环，就会在哈希表中查到。\n\n### 代码\n\n\n```js\nvar detectCycle = function(head) {\n    const visited = new Set();\n    while(head != null){\n        if(visited.has(head)){\n            return head;\n        }\n        visited.add(head);\n        head = head.next;\n    }\n    return null;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为链表长度。\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196627791","body":"\n### 思路\n\n深度遍历，分别求出左子树、右子树的深度，然后求最大值，再加上1（到根节点的深度）\n\n### 代码\n\n\n```js\nvar maxDepth = function(root) {\n    if(!root) return 0;\n    let left = maxDepth(root.left);\n    let right = maxDepth(root.right);\n    return Math.max(left,right)+1;\n\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(height)，子树的最大高度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185193124","body":"## 思路\n输入K数字转换成数组，将数组从末位开始，按位相加，考虑进位，最后返回相加后数组\n\n## 代码\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let result = [];\n    let arrK = String(k).split('');\n    let flag = 0;\n    num.reverse();\n    arrK.reverse();\n    for(let i = 0; i < num.length || i < arrK.length; i++) {\n        var retNum = (num[i] || 0) + (+arrK[i] || 0) + flag;\n        if (retNum >= 10) {\n            retNum = retNum % 10;\n            flag = 1;\n        } else {\n            flag = 0;\n        }\n        result.push(retNum);\n    }\n\n    if(flag) {\n        result.push(1);\n    }\n    result.reverse();\n    return result\n};\n```\n## 算法复杂度\n\n+ 时间复杂度 O(n)\n+ 空间复杂度 O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186415178","body":"## 思路\n 用数组模拟栈；\n## 代码\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    const len = this.stack.length;\n    if(len >= this.maxSize) return;\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(!this.stack.length) return -1;\n    return this.stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const minIdx = Math.min(this.stack.length, k)\n    for(let i = 0; i < minIdx; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n## 复杂度分析\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187672624","body":"## 思路\n 用两个栈分别记录数字和字符串\n\n## 代码\n```\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  let nums = [];              \n    let strs = [];              \n\n    let num = 0, result = '';\n\n    for(let i = 0; i < s.length; i++) {\n        const item = s[i];\n\n        if(!isNaN(item)) {             \n            num = num * 10 + parseInt(item);\n        } else if(item === '[') {\n            strs.push(result);\n            result = '';\n            nums.push(num);\n            num = 0;\n        } else if(item === ']') {\n            const finalNums = nums.pop();        \n            result = strs.pop() + result.repeat(finalNums);\n        } else {\n            result += item;\n        }\n    }\n    return result;\n};\n```\n## 复杂度\n+ 时间复杂度： O(n)\n+ 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189214791","body":"## 思路\n用两个栈来模拟队列，一个负责push，一个负责pop，push时保证pop的栈为空，pop时保证push栈为空\n## 代码\n```\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    while(this.stack2.length) {\n        this.stack1.push(this.stack2.pop());\n    }\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    while(this.stack1.length) {\n        this.stack2.push(this.stack1.pop());\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    while(this.stack1.length) {\n        this.stack2.push(this.stack1.pop());\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stack1.length && !this.stack2.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n## 复杂度\n+ 时间复杂度: O(n)\n+ 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190389570","body":"\n## 思路\n滑动窗口，对比输入数组和排序后数组，每个分块中元素是一样的\n## 代码\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n   const sorted = [...arr];\n   sorted.sort((a,b) => (a - b));\n   let ans = 0;\n   let sums1 = 0;\n   let sums2 = 0;\n   for(let i = 0; i < arr.length; i++) {\n        sums1 += arr[i];\n        sums2 += sorted[i];\n\n        if (sums1 === sums2) {\n            ans++;\n            sums1 = sums2 = 0; // 这行不要也可以啦\n        }\n   }\n   return ans;\n};\n```\n## 复杂度\n+ 时间复杂度: O(NlogN)\n+ 空间复杂度: O(n)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193096357","body":"## 思路\n使用快慢指针找到根节点，递归链表生成二叉搜索树\n\n## 代码\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    return buildTree(head, null);\n};\n\nfunction buildTree(left, right) {\n    if(left === right) return null;\n    var mid = getMidNode(left, right);\n    var root = new TreeNode(mid.val);\n    root.left = buildTree(left, mid);\n    root.right = buildTree(mid.next, right);\n    return root;\n}\n\nfunction getMidNode(left, right) {\n    let fast = left;\n    let slow = left;\n    while (fast !== right && fast.next !== right) {\n        fast = fast.next;\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return slow;\n}\n```\n\n## 复杂度\n+ 空间复杂度： O(logn)\n+ 时间复杂度： O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193409633","body":"## 思路\r\n 双指针遍历两条链表，当两个指针指向同一节点时返回该节点；\r\n\r\n ## 代码\r\n ```\r\n /**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n        if(headA === null || headB === null) {\r\n            return null;\r\n        }\r\n        let ptA = headA;\r\n        let ptB = headB;\r\n        while(ptA != ptB) {\r\n            ptA = ptA === null ?  headB : ptA.next;\r\n            ptB = ptB === null ?  headA : ptB.next;\r\n        }\r\n        return ptA\r\n};\r\n ```\r\n\r\n ## 复杂度\r\n + 时间复杂度：O(n)\r\n + 空间复杂度: O(1)","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196096086","body":"## 思路\n深度优先遍历\n## 代码\n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(root === null) return 0;\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n};\n```\n## 复杂度\n+ 时间复杂度 O(n)\n+ 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185216971","body":"## 思路\n看成是两个数组的求和，然后遍历数组，数字不断做求余和求除操作,进行类似于按位求和操作，注意进位问题即可，最后返回结果的逆序。\n\n## 代码\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        temp = 0\n        while num or k or temp:\n            sum_k = k % 10\n            if num:\n                n = num.pop()\n            else: n = 0\n            ans.append((n+sum_k+temp)%10)\n            k //=  10\n            temp = (n+sum_k+temp)//10\n        return ans[::-1]\n```\n## 复杂度\n时间复杂度：O(n) \n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186104169","body":"## 思路\n很傻很直白的办法，先遍历一次用数组记录下目标c的位置，然后再遍历一次计算距离c的下标的最小值。属于是暴力求解，当规模更大的时候可能会超时，之后还需要改进\n## 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = []\n        ans = []\n        for i in range(len(s)):\n            if s[i] == c:\n                ans.append(i) \n        for j in range(len(s)):\n            if s[j] == c:\n                res.append(0)\n            else:\n                min_ = min(list(map(lambda x:abs(x-j),ans)))\n                res.append(min_)\n        return res\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186416069","body":"## 思路\n利用python自带的列表进行栈的模拟，对于第三个问题，则采取直白的判断和遍历的方法。\n## 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxsize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) <= k:\n            self.stack = list(map(lambda x:x+val,self.stack))\n        else:\n            for i in range(k):\n                self.stack[i] +=val\n```\n## 复杂度\n时间复杂度: O(N)\n\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186828526","body":"## 思路\n栈的使用，与判断括号匹配相似\n## 代码\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur, last = stack.pop()\n                res = last + cur * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n```\n## 复杂度\n时间复杂度:O(N)\n\n空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188650642","body":"## 思路\n用两个栈进行模拟\n## 代码\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.stracks = []\n        self.stracks_tmp = []\n\n    def push(self, x: int) -> None:\n        if self.stracks:\n            while self.stracks:\n                self.stracks_tmp.append(self.stracks.pop())\n            self.stracks.append(x)\n            while self.stracks_tmp:\n                self.stracks.append(self.stracks_tmp.pop())\n        else:\n            self.stracks.append(x)\n\n    def pop(self) -> int:\n        return self.stracks.pop()\n\n    def peek(self) -> int:\n        return self.stracks[-1]\n\n    def empty(self) -> bool:\n        if not self.stracks:\n            return True\n        else:\n            return False\n```\n## 复杂度分析\n时间复杂度:O(N)\n\n空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189832298","body":"## 思路\n构造单调栈，最后分的块的数目为栈中元素的数目\n## 代码\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        max_, stack = arr[0], [arr[0]]\n        for i in range(1, len(arr)):\n            if arr[i] >= max_:\n                max_ = arr[i]\n                stack.append(arr[i])\n            else:\n                while stack and stack[-1] > arr[i]:\n                    stack.pop()\n                stack.append(max_)\n        return len(stack)\n```\n## 复杂度分析\n只需要遍历一次数组\n时间复杂度: O(N)\n\n空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191081611","body":"## 思路\n先求出链表长度，然后对k取模得到实际移动的步数，最后就是链表的拼接\n## 代码\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0: return head\n        else:\n            if head:\n                lenth = 0\n                cur,slow,fast = head,head,head\n                while cur:\n                    cur = cur.next\n                    lenth += 1\n                k %= lenth\n                while k:\n                    fast = fast.next\n                    k -= 1\n                if fast != head:\n                    while fast.next:\n                        fast = fast.next\n                        slow = slow.next\n                    new_head = slow.next\n                    fast.next = head\n                    slow.next = None\n                    return new_head\n                else:\n                    return head\n            else:\n                return head\n```\n## 复杂度分析\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192128954","body":"## 思路\n重点就是双指针确定交换的节点并进行模拟实现链表翻转，只不过限于相邻两个节点间的翻转。\n## 代码\n```\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head:\n            slow,fast = head,head.next\n            if fast:\n                pre = p = ListNode()\n                pre.next = head\n                while slow and fast:\n                    next_ = fast.next\n                    p.next = fast\n                    fast.next = slow\n                    slow.next = next_\n                    p = slow\n                    slow = slow.next\n                    fast = slow.next if slow else None\n                return pre.next\n            else:\n                return slow\n\n        else:\n            return head\n```\n## 复杂度\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193040731","body":"## 思路\n双指针找中点，递归进行左右子树的构造\n## 代码\n```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n## 复杂度\n时间复杂度：O(NlogN)\n\n空间复杂度：O(logN)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193221013","body":"## 思路\n一个唯美的小故事，如果你想找到你命中注定的npy，那就去重走你以及ta走过的路，如果有缘终会相遇\n## 代码\n```class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return None\n        else:\n            A,B = headA,headB\n            while A != B:\n                A = A.next if A else headB\n                B = B.next if B else headA\n            return A\n```\n## 复杂度\n时间复杂度：O(M+N)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193494260","body":"## 思路\n快慢指针，注意是否出现环形的条件就行\n## 代码\n```\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```\n## 复杂度\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194927199","body":"## 代码\n```\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def move_node_to_tail(self, key):\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            node.prev = self.tail.prev\n            node.next = self.tail\n            self.tail.prev.next = node\n            self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            self.move_node_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            self.hashmap[key].value = value\n            self.move_node_to_tail(key)\n        else:\n            if len(self.hashmap) == self.capacity:\n                self.hashmap.pop(self.head.next.key)\n                self.head.next = self.head.next.next\n                self.head.next.prev = self.head\n            new = ListNode(key, value)\n            self.hashmap[key] = new\n            new.prev = self.tail.prev\n            new.next = self.tail\n            self.tail.prev.next = new\n            self.tail.prev = new\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196191004","body":"## 思路\n使用队列计算层数\n## 代码\n```\nClass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        depth=0\n        if not root:\n            return 0\n        queue=[root]\n        while queue: # queue每次只存放一层的节点\n            n=len(queue)\n            for i in range(n):\n                p=queue.pop(0)\n                if p.left:\n                    queue.append(p.left)\n                if p.right:\n                    queue.append(p.right)\n            depth+=1\n        return depth\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197586431","body":"## 思路\n递归判断每一层节点\n## 代码\n```\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```\n## 复杂度\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185228684","body":"### 思路\n\n从低位到高位依次拿出`num`的值和`k`相加，将所加之和与10的余数加入到`list`中，直到`k=0`。最后将所得的`list`反转后即可得到。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int length = num.length;\n        int idxVal;\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            idxVal = num[length - 1 - i];\n            if (k != 0) {\n                list.add((idxVal + k) % 10);\n                k = (idxVal + k) / 10;\n            } else {\n                list.add(idxVal);\n            }\n            if (k != 0 && (length - 1 - i) <= 0) {\n                while (k != 0) {\n                    list.add(k % 10);\n                    k = k / 10;\n                }\n            }\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n\n### 复杂度分析\n\n\\- 时间复杂度：O(N)，其中 `N = array.length`或者是`N = array.length + k的位数`。（不确定）\n\\- 空间复杂度：O(1)，（不确定）\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186173029","body":"### 思路\n\n根据题目的提示**“数组的遍历(正向遍历和反向遍历)”**，分两次遍历数组：\n\n1. 第一次，正向遍历，出现在第一个c前的位置都给`Integer.MAX_VALUE`，出现c的位置赋值为0，其余的位置的先计算出“此位置到它**左边最近的c**的距离”\n2. 第二次，反向遍历，思路大致如上，不同处在于计算出“此位置到它**右边最近的c**的距离”，和“此位置到它**左边最近的c**的距离”相比，取小值即可\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int length = s.length();\n        int[] result = new int[length];\n        int currentIndex = Integer.MAX_VALUE;\n        for (int i = 0; i < length; i++) {\n            if (s.charAt(i) == c) {\n                result[i] = 0;\n                currentIndex = i;\n            } else {\n                result[i] = Math.abs(i - currentIndex);\n            }\n        }\n        for (int i = length - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                currentIndex = i;\n            } else {\n                result[i] = Math.min(Math.abs(i - currentIndex), result[i]);\n            }\n        }\n        return result;\n    }\n}\n```\n\n\n\n**复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为字符串的长度。\n- 空间复杂度：O(N)（不确定）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186518458","body":"### 思路\n\n根据栈的结构，定义出三个变量：\n\n1. `int[] stack`用来存放值\n2. `int head`指定当前栈顶，当值为-1时表明此栈为空\n3. `int maxSize`接收指定的栈的大小\n\n- push\n\n  判断`head`是否到了栈的最大位置处，没有则添加\n\n- pop\n\n  判断`head`是否是空栈\n\n### 代码\n\n```java\nclass CustomStack {\n\n    int[] stack;\n    int head = -1;\n    int maxSize = 0;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.stack = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (head >= maxSize - 1) {\n            return;\n        }\n        this.stack[++head] = x;\n    }\n\n    public int pop() {\n        if (head == -1) {\n            return -1;\n        }\n        return this.stack[head--];\n    }\n\n    public void increment(int k, int val) {\n        if (head + 1 < k) {\n            for (int i = 0; i < head + 1; i++) {\n                stack[i] += val;\n            }\n            return;\n        }\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为指定栈的长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187666868","body":"### 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuffer result = new StringBuffer();\n        Stack<Integer> numberStack = new Stack<>();\n        Stack<StringBuffer> stringBufferStack = new Stack<>();\n        int count = 0;\n        for (char ch : s.toCharArray()) {\n            if (Character.isDigit(ch)) {\n                count = count * 10 + ch - '0';\n            } else if (ch == '[') {\n                numberStack.push(count);\n                count = 0;\n                stringBufferStack.push(result);\n                result = new StringBuffer();\n            } else if (Character.isAlphabetic(ch)) {\n                result.append(ch);\n            } else {\n                StringBuffer temp_str = stringBufferStack.pop();\n                int temp_num = numberStack.pop();\n                for (int i = 0; i < temp_num; i++) {\n                    temp_str.append(result);\n                }\n                result = temp_str;\n            }\n        }\n        return result.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189084434","body":"### 思路\n\n（通过题解学习）\n\n- 思路1\n\n  使用两个栈来实现队列，一个栈用来存放原本的顺序，另一个栈用来作为临时存放反转顺序使用。\n\n  `storeStack`和`reverseStack`\n\n  - push\n\n    入队的时候需要先把`storeStack`清空（把数据`pop`，然后`push`到`reverseStack`，直到`storeStack.empty() == true`），然后数据进`storeStack`，再把`reverseStack`的数据`pop`，然后`push`到`storeStack`\n\n  - pop\n\n    `storeStack`的`head`就是队列的`head`，出队时直接使用`storeStack.pop()`即可（`storeStack`不为空）\n\n- 思路2\n\n  使用两个栈来实现队列，一个栈用来存放`push`进来的数据，另一个栈用来存放需要`pop`的数据\n\n  `pushStack`和`popStack`\n\n  - push\n\n    入队时直接`push`到`pushStack`，如果此时的`pushStack`为空，需要将第一个值指定为`head`，方便`peek`\n\n  - pop\n\n    出队时，需要保证`popStack`不为空，如果是空，就把`pushStack`全部添加到`popStack`，然后再从`popStack`出队\n\n  - peek\n\n    如果`popStack`为空，那么head就是队首，如果不为空，队首就是`popStack`的栈顶\n\n### 代码\n\n#### 思路1\n\n```java\nclass MyQueue {\n\n    private Stack<Integer> storeStack;\n    private Stack<Integer> reverseStack;\n\n    public MyQueue() {\n        this.storeStack = new Stack<>();\n        this.reverseStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        while (!storeStack.empty()) {\n            reverseStack.push(storeStack.pop());\n        }\n        storeStack.push(x);\n        while (!reverseStack.empty()) {\n            storeStack.push(reverseStack.pop());\n        }\n    }\n\n    public int pop() {\n        if (storeStack.empty()) {\n            return Integer.MIN_VALUE;\n        }\n        return storeStack.pop();\n    }\n\n    public int peek() {\n        if (storeStack.empty()) {\n            return Integer.MIN_VALUE;\n        }\n        return storeStack.peek();\n    }\n\n    public boolean empty() {\n        return storeStack.empty();\n    }\n}\n```\n\n#### 思路2\n\n```java\nclass MyQueue {\n\n    private Stack<Integer> pushStack;\n    private Stack<Integer> popStack;\n    // 队列的head\n    private int head;\n\n    public MyQueue() {\n        this.pushStack = new Stack<>();\n        this.popStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (pushStack.empty()) {\n            head = x;\n        }\n        pushStack.push(x);\n    }\n\n    public int pop() {\n        if (popStack.empty()) {\n            while (!pushStack.empty()) {\n                popStack.push(pushStack.pop());\n            }\n        }\n        return popStack.pop();\n    }\n\n    public int peek() {\n        if (popStack.empty()) {\n            return head;\n        }\n        return popStack.peek();\n    }\n\n    public boolean empty() {\n        return pushStack.empty() && popStack.empty();\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：\n  1. 思路1\n     - 入队：O(N)\n     - 出队：O(1)\n  2. 思路2\n     - 入队：O(1)\n     - 出队：O(1)\n- 空间复杂度：O(1)\n  1. 思路1\n     - 入队：O(N)\n     - 出队：O(1)\n  2. 思路2\n     - 入队：O(1)\n     - 出队：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190371208","body":"### 思路\n\n（通过题解学习）\n\n使用栈来记录每个块的最大值，在栈中的值应该是递增的（存在相等的情况），最后计算栈的长度即可得知块的个数。\n\n遍历数组，当**栈为空**或者是**当前值大等于栈顶值**，将当前值入栈，认为是一个块；当栈不为空，出现了**当前值小于栈顶值**（就是当前值需要并入上一个块），先把记录当前块的最大值暂存，需要将栈顶值抛出，一直到**当前值大等于栈顶值**或者栈为空后，再将临时保存的当前块最大值入栈。\n\n主要的思路是：遍历到的num必须是**大等于**栈顶值才可以称为一个新的块，否则就需要并入前一个块\n\n### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> blockMaxHeadStack = new Stack<>();\n\n        for (int num : arr) {\n\n            if (blockMaxHeadStack.empty() || num >= blockMaxHeadStack.peek()) {\n                blockMaxHeadStack.push(num);\n            }\n\n            if (!blockMaxHeadStack.empty() && num < blockMaxHeadStack.peek()) {\n                // 获取记录当前块的最大值\n                int head = blockMaxHeadStack.pop();\n                while (!blockMaxHeadStack.empty() && num < blockMaxHeadStack.peek()) {\n                    blockMaxHeadStack.pop();\n                }\n                blockMaxHeadStack.push(head);\n            }\n        }\n        return blockMaxHeadStack.size();\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191200440","body":"### 思路\n\n（通过题解学习）\n\n根据题目的要求，就是将链表（单向链表）的元素向后移动k个单位。\n\n首先，遍历链表，得到当前链表的头尾，将其头尾相接，形成一个环形链表；\n\n然后，计算`head`移动的最短路径（也就是head元素的新位置），并找到这个`head`\n\n最后，从`head`节点前把链表断开，就是`head`的前一个元素的`next`指为`null`\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n\n        if (head == null || k == 0 || head.next == null) {\n            return head;\n        }\n\n        ListNode iterator = head;\n        ListNode tail;\n        int size = 1;\n\n        while (iterator.next != null) {\n            iterator = iterator.next;\n            size++;\n        }\n        // 抓到链表的尾部 构成环形链表\n        tail = iterator;\n        tail.next = head;\n\n        // 从输入到输出，计算出元素最短移动路径\n        int offset = size - k % size;\n        if (offset == 0) {\n            return head;\n        }\n        iterator = head;\n        for (int i = 0; i < offset; i++) {\n            iterator = iterator.next;\n        }\n        head = iterator;\n\n        while (iterator.next != head) {\n            iterator = iterator.next;\n            if (iterator.next == head) {\n                iterator.next = null;\n                return head;\n            }\n        }\n        return null;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192625907","body":"### 思路\n\n链表的节点，两两互换位置，若是遇到长度为奇数的列表，最后一个节点不动。定义了四个变量，分别表示：上一个节点，当前节点、下一个节点和临时存储的值。两个节点为步长，遍历链表，交换两个节点的顺序，并把前一个节点的next赋值为交换后的第一个节点。直到链表结束即可\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode pre = null;\n        ListNode current = head;\n        ListNode next = head.next;\n        ListNode tmp;\n        head = next;\n        while (true) {\n            tmp = next.next;\n            current.next = tmp;\n            next.next = current;\n            if (pre != null) {\n                pre.next = next;\n            }\n\n            pre = current;\n            if (pre.next == null) {\n                return head;\n            }\n            current = pre.next;\n            if (pre.next.next == null) {\n                return head;\n            }\n            next = pre.next.next;\n        }\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193307443","body":"### 思路\n\n（通过题解学习）\n\n学习使用递归的方法解决问题，递归需要有中止条件，否则会有栈溢出的错误。\n\n### 代码\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        // 递归\n        return def(head, null);\n    }\n\n    public TreeNode def(ListNode head, ListNode tail) {\n        // 递归中止条件\n        if (head == tail) {\n            return null;\n        }\n        ListNode fast = head, slow = head;\n        // 快慢指针，遍历链表，得到中间的节点\n        while (fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = def(head, slow);\n        root.right = def(slow.next, tail);\n        return root;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(logN)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193314392","body":"### 思路\n\n（通过题解学习）\n\n找到两个链表的相交点，那么从相交点之后的链表的长度是相等的，同时遍历两个链表，当前的链表遍历完后遍历另一个链表（`A.length + B.length == B.length + A.length`），两个链表的指针相遇的节点即是相交点\n\n### 代码\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(M+N)，其中 M和N 为链表A和B长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194044331","body":"### 思路\n\n（通过题解学习）\n\n快慢指针，快指针和满指针遍历链表，直到两个指针相遇，将快指针指向链表头，快慢指针步长都设置为1，继续遍历，两个指针再次相遇的位置就是环形链表的入口（经过计算可以得出，head到入口的距离等于第一次相遇点到入口的距离）。\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode detectCycle(ListNode head) {\n\n        if (head == null) {\n            return null;\n        }\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                fast = head;\n                while (fast != slow) {\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195467693","body":"### 思路\n\n实现LRU机制，使用到了Hash表和双向链表，`put()`和`get()`的节点都需要放到LRU链表的首端（一般情况下），当向LRU中添加数据时LRU已经满了，则只需将链表的尾端节点删除后，再正常添加到链表首端即可；剩下的只需要考虑一些边界问题。\n\n实现过程比较繁复，第一次，使用了HashMap和双向链表分开使用，时间上效果很差（Java执行时间1600±ms）；第二次，将双向链表作为HashMap的value后，时间有所提升（Java执行时间50±ms），但是还有继续学习的空间\n\n### 代码\n\n```java\nclass LRUCache {\n\n    class LRUNode {\n        int key;\n        int value;\n        LRUNode pre;\n        LRUNode next;\n        \n        public LRUNode() {\n        }\n        \n        public LRUNode(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n\n    }\n    \n    private int capacity;\n    \n    private HashMap<Integer, LRUNode> hashMap;\n    \n    private final LRUNode head = new LRUNode(-1, -1);\n    private final LRUNode tail = new LRUNode(-1, -1);\n    private LRUNode temp;\n\n\n    public LRUCache(int capacity) {\n        if (capacity <= 0) {\n            return;\n        }\n        this.capacity = capacity;\n        this.hashMap = new HashMap<>();\n\n        this.head.key = -1;\n        this.tail.key = -1;\n        this.head.next = this.tail;\n        this.tail.pre = this.head;\n    }\n\n    public int get(int key) {\n        if (!hashMap.containsKey(key)) {\n            return -1;\n        }\n        LRUNode lruNode = hashMap.get(key);\n        // 需要把 key 放在链表 first\n        if (head.next == lruNode && lruNode.pre == head) {\n            // 已经是链表 first 直接返回\n            return lruNode.value;\n        }\n        lruNode.pre.next = lruNode.next;\n        lruNode.next.pre = lruNode.pre;\n        head.next.pre = lruNode;\n        lruNode.next = head.next;\n        head.next = lruNode;\n        lruNode.pre = head;\n        return lruNode.value;\n\n    }\n\n    public void put(int key, int value) {\n\n        if (hashMap.containsKey(key)) {\n            // 若插入的key存在，更新数据---不确定是否需要修改链表\n            // 案例表明 需要将改动的节点放到链表的first\n            //hashMap.replace(key, hashMap.get(key), value);\n\n            // 更新这个key的val\n            LRUNode lruNode = hashMap.get(key);\n            lruNode.value = value;\n\n            // 找到了这个节点，把这个节点放到链表 first\n            if (head.next == lruNode && lruNode.pre == head) {\n                // 已经是链表 first 直接返回\n                return;\n            }\n            lruNode.pre.next = lruNode.next;\n            lruNode.next.pre = lruNode.pre;\n            head.next.pre = lruNode;\n            lruNode.next = head.next;\n            head.next = lruNode;\n            lruNode.pre = head;\n            return;\n        }\n\n        if (hashMap.size() == this.capacity) {\n            // LRU缓存满了，先清理最冷的数据，再加入新数据\n            hashMap.remove(tail.pre.key);\n            // 链表中删除最后一个元素\n            temp = tail.pre.pre;\n            temp.next = tail;\n            tail.pre = temp;\n        }\n\n        // 插入数据\n        LRUNode lruNode = new LRUNode(key, value);\n        // 存到hashmap\n        hashMap.put(key, lruNode);\n        // 存到链表的first\n        temp = head.next;\n        head.next = lruNode;\n        temp.pre = lruNode;\n        lruNode.pre = head;\n        lruNode.next = temp;\n    }\n\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196694423","body":"### 思路\n\n前序遍历，先后遍历当前节点、左子树、右子树。\n\n递归的输入为当前遍历到的节点，输出为当前遍历的最大深度，中止条件是遍历到空节点。\n\n每次遍历完一个节点及其左右子树，取最深的值并加1返回\n\n### 代码\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185232708","body":"### 思路\r\n\r\n本来想用`BigInteger`来进行大数计算，然后通过字符串进行数组转换，但是发现 leetcode 无法使用`BigInteger`，所以还是使用数组单项相加即可，主要考虑进位处理，另一个方法就是单位相加，逐一推出相应单位数就行了\r\n\r\n### 代码\r\n\r\n#### 写法一\r\n```java（此处换成你的语言，比如js，py 等）\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<>();\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            //数组中单项相加\r\n            int sum = num[i] + k % 10;\r\n            k = k / 10;\r\n            // 判断是否有进位的数\r\n            if (sum >= 10) {\r\n                ++k;\r\n                sum = sum - 10;\r\n            }\r\n            ans.add(sum);\r\n        }\r\n        //不确定是k大还是num代表的数据大，所以要进行两次运算\r\n        for (; k > 0; k /= 10) {\r\n            ans.add(k % 10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n```\r\n\r\n#### 写法二\r\n```java（此处换成你的语言，比如js，py 等）\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<>();\r\n        //简化上一步\r\n        for (int i = len - 1; i >= 0 || k > 0; i--, k /= 10) {\r\n            if (i >= 0) {\r\n                k = num[i] + k;\r\n            }\r\n            ans.add(k % 10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186191505","body":"### 思路\r\n\r\n使用二次遍历，第一次遍历获取所有命中字符的下表，第二次遍历计算最远距离，获取与上一次的距离最小值即可，注意处理只有一次的情况\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] ans = new int[s.length()];\r\n        List<Integer> cIndex = new ArrayList<>();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char sChar = s.charAt(i);\r\n            if (sChar == c){\r\n                cIndex.add(i);\r\n            }\r\n        }\r\n        for (int i = 0, j = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c){\r\n                ans[i]=0;\r\n                if (j != cIndex.size() - 1){\r\n                    j++;\r\n                }\r\n                continue;\r\n            }\r\n            if (j >= 1){\r\n                ans[i] = Math.min(Math.abs(cIndex.get(j) - i),Math.abs(cIndex.get(j-1) - i));\r\n            }else {\r\n                ans[i] = Math.abs(cIndex.get(j) - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186429099","body":"### 思路\r\n\r\n通过LinkList 来模拟栈的使用，当然也可以使用数组，这里只要处理好边界条件就可以了\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass CustomStack {\r\n\r\n    LinkedList<Integer> stack = new LinkedList<>();\r\n    int MaxSize;\r\n    public CustomStack(int maxSize) {\r\n        MaxSize = maxSize;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (stack.size() < MaxSize) {\r\n            stack.add(stack.size(),x);\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (stack.isEmpty()){\r\n            return -1;\r\n        }\r\n        int popNum = stack.getLast();\r\n        stack.removeLast();\r\n        return popNum;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < stack.size() && i < k; i++) {\r\n            stack.set(i,stack.get(i) + val);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186692154","body":"### 思路\r\n\r\n与之前的匹配字符串有点像，这里采用入栈的方式，分为三种情况\r\n\r\n1. 数字入栈，这里要对连续数字进行处理\r\n2. 字母还有“[”括号入栈\r\n3. 遇到“]”括号出栈，同时截取第二步括号之前的字符\r\n\r\n弹出\"[\"括号字符，获取重复的次数，处理这些字符串就可以了。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\n    int curIndex;\r\n    public String decodeString(String s) {\r\n        LinkedList<String> ans = new LinkedList<>();\r\n        curIndex = 0;\r\n        while (curIndex < s.length()) {\r\n            char c = s.charAt(curIndex);\r\n            if (Character.isDigit(c)) {\r\n                String strDigit = getDigits(s);\r\n                ans.addLast(strDigit);\r\n            } else if (Character.isLetter(c) || c == '[') {\r\n                ans.addLast(String.valueOf(s.charAt(curIndex++)));\r\n            } else {\r\n                curIndex++;\r\n                LinkedList<String> subStr = new LinkedList<>();\r\n                while (!ans.peekLast().equals(\"[\")){\r\n                    subStr.addLast(ans.removeLast());\r\n                }\r\n                ans.removeLast();\r\n                Collections.reverse(subStr);\r\n                Integer repeatTimes = Integer.parseInt(ans.removeLast());\r\n                StringBuffer sb = new StringBuffer();\r\n                String o = getString(subStr);\r\n                while (repeatTimes-- > 0 ){\r\n                    sb.append(o);\r\n                }\r\n                ans.addLast(sb.toString());\r\n            }\r\n        }\r\n        return getString(ans);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer sb = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(curIndex))){\r\n            sb.append(s.charAt(curIndex++));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> ll) {\r\n        StringBuffer ans = new StringBuffer();\r\n        for (String s :\r\n                ll) {\r\n            ans.append(s);\r\n        }\r\n        return ans.toString();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Solution1 solution1 = new Solution1();\r\n        System.out.println(solution1.decodeString(\"3[a]2[bc]\"));\r\n    }\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188507766","body":"### 思路\r\n\r\n理解栈和队列的思想就很好解了，使用 LinkList 来模拟栈，修改的时候只考虑增和删除的时候保证两个栈一样就行了。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass MyQueue {\r\n    LinkedList<Integer> stack1;\r\n    LinkedList<Integer> stack2;\r\n    public MyQueue() {\r\n        stack1 = new LinkedList<>();\r\n        stack2 = new LinkedList<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        stack1.addFirst(x);\r\n        in2tou(stack1,stack2);\r\n    }\r\n\r\n    public int pop() {\r\n        int popNum = stack2.removeFirst();\r\n        in2tou(stack2,stack1);\r\n        return popNum;\r\n    }\r\n\r\n    public int peek() {\r\n        return stack2.getFirst();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return stack2.isEmpty();\r\n    }\r\n\r\n    public void in2tou(LinkedList<Integer> in,LinkedList<Integer> out){\r\n        out.clear();\r\n        for (int num : in) {\r\n            out.addFirst(num);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189768960","body":"### 思路\r\n\r\n辅助栈还是比较好理解的，只需要判断每个组的最大值，再去分析下一个数字与这个值得大小。逻辑如下\r\n\r\n1. 循环数组aar\r\n2. 判断栈是否为空，循环的数num是否比目前的栈顶元素大，如果大则入栈，如果小\r\n3. 则最大值出栈，循环往下寻找最小值，再将栈顶入栈\r\n\r\n依次得出栈的值则是最大的数了\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n        LinkedList<Integer> stack = new LinkedList<>();\r\n        for (int num : arr) {\r\n            if (!stack.isEmpty() && num < stack.getLast()) {\r\n                int head = stack.removeLast();\r\n                while (!stack.isEmpty() && num < stack.getLast()) {\r\n                    stack.removeLast();\r\n                }\r\n                stack.addLast(num);\r\n            } else {\r\n                stack.addLast(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191004028","body":"### 思路\r\n\r\n代码不够简洁，但是只要有足够的中间变量就可以完成了，主要还是靠画图，如果不画图，逐渐狰狞！\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        int len = 0;\r\n        ListNode cur = head;\r\n        while (cur != null) {\r\n            cur = cur.next;\r\n            len++;\r\n        }\r\n\r\n        int movedLocation = k % len;\r\n\r\n        if (movedLocation == 0) {\r\n            return head;\r\n        }\r\n\r\n        cur = head;\r\n        for (int i = 0; i < len - movedLocation - 1; i++) {\r\n            cur = cur.next;\r\n        }\r\n\r\n        ListNode ans = cur.next;\r\n        ListNode ansLast = ans;\r\n        cur.next = null;\r\n        while (ansLast.next != null) {\r\n            ansLast = ansLast.next;\r\n        }\r\n        ansLast.next = head;\r\n        return ans;\r\n    }\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192124159","body":"### 思路\r\n\r\n思想比较复杂，还是需要学习呀，很简单的想法，从零开始迭代交换，交换后next一定是下一个迭代的开始，效率比较快一次迭代就可以循环全部，也不需要修改值\r\n### 代码\r\n\r\n\r\n```java\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        ListNode cur = head;\r\n        ListNode pre = null;\r\n        ListNode ans = head.next;\r\n        while (cur != null && cur.next != null) {\r\n            ListNode next = cur.next;\r\n            cur.next = next.next;\r\n            next.next = cur;\r\n            if (pre != null) {\r\n                pre.next = next;\r\n            }\r\n            pre = cur;\r\n            cur = cur.next;\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193131557","body":"## 思路\r\n快慢指针\r\n\r\n## 代码\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right) {\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193269943","body":"## 思路\r\n使用双指针，这道题的关键点就是两个node相交，总长度遍历后就可以\r\n## 代码\r\n```java\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA==null && headA == null) {\r\n            return null;\r\n        }\r\n        ListNode curHeadANode = headA;\r\n        ListNode curHeadBNode = headB;\r\n        while (curHeadANode!=curHeadBNode) {\r\n            curHeadANode = curHeadANode == null?headB:curHeadANode.next;\r\n            curHeadBNode = curHeadBNode == null?headA:curHeadBNode.next;\r\n        }\r\n        return curHeadANode;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193640336","body":"## 思路\r\n这个用的是Hash标的方式，但是空间复杂度会上升到O(N)，理论上快慢指针会更好一些，\r\n## 代码\r\n```java\r\n    public ListNode detectCycle(ListNode head) {\r\n        Set<ListNode> set = new HashSet<>();\r\n        ListNode pos = head;\r\n        while (pos != null) {\r\n            if (set.contains(pos)) {\r\n                return pos;\r\n            }\r\n            set.add(pos);\r\n            pos = pos.next;\r\n        }\r\n        return null;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195043755","body":"## 思路\r\n主要就是哈希表配合双链表，来做LRU，问题的关键就是，首尾模拟\r\n\r\n## 代码\r\n```java\r\n    class DLinkedNode {\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode() {\r\n        }\r\n\r\n        public DLinkedNode(int _key, int _value) {\r\n            key = _key;\r\n            value = _value;\r\n        }\r\n    }\r\n\r\n    int size;\r\n    int capacity;\r\n    DLinkedNode head;\r\n    DLinkedNode tail;\r\n    HashMap<Integer, DLinkedNode> cache;\r\n\r\n    public LRUCache(int capacity) {\r\n        size = 0;\r\n        this.capacity = capacity;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        cache = new HashMap<>();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        if (cache.containsKey(key)) {\r\n            DLinkedNode hit = cache.get(key);\r\n            moveToHead(hit);\r\n            return hit.value;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        if (cache.containsKey(key)) {\r\n            DLinkedNode hit = cache.get(key);\r\n            hit.value = value;\r\n            moveToHead(hit);\r\n        } else {\r\n            DLinkedNode hit = new DLinkedNode(key, value);\r\n            cache.put(key, hit);\r\n            addToHead(hit);\r\n            ++size;\r\n            if (size > capacity) {\r\n                DLinkedNode tail = removeTail();\r\n                cache.remove(tail.key);\r\n                --size;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }\r\n\r\n    private void addToHead(DLinkedNode hit) {\r\n        hit.next = head.next;\r\n        hit.prev = head;\r\n        head.next.prev = hit;\r\n        head.next = hit;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode hit) {\r\n        removeNode(hit);\r\n        addToHead(hit);\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196224377","body":"## 思路\r\n递归练习，深度搜索\r\n## 代码\r\n```java\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int leftHeight = maxDepth(root.left);\r\n        int rightHeight = maxDepth(root.right);\r\n        return Math.max(leftHeight, rightHeight) + 1;\r\n    }\r\n```\r\n## 复杂度\r\ntime O(N)\r\nspace O(HEIGH)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185236293","body":"# **思路**\r\n从后往前遍历数组，按位与k相加，遇10进1（结果大于10时，进位数1加到下一位进行计算），考虑结果如果存储LinkedList的addFirst或者ArraryList最后翻转。\r\n\r\n# **代码**\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n        LinkedList<Integer> numList = new LinkedList<Integer>();\r\n        int index = num.length-1;\r\n        while (index>=0||k!=0){\r\n            if(index>=0){\r\n                k=num[index]+k;\r\n                index--;\r\n            }\r\n            numList.addFirst(k%10);\r\n            k=k/10;\r\n        }  \r\n        return numList;\r\n    }\r\n}\r\n\r\n# **复杂度分析**\r\n时间复杂度：O(n)  \r\nwhile 循环运行n次，n为数组长度\r\n空间复杂度：O(n)  \r\n创建的一个空列表，这个列表占用的内存随着while 循环的增加而增加，最大到 n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186223012","body":"# *思路*\n从左往右遍历一次，再从右往左遍历一次，取最小值。\n需要想到的点是开始charAt位置没有数值时，用一个假定的值来表示。\n最开始按照自己的想法写了一个很复杂的，虽然执行了但是时间复杂度是n方。\n# *代码*\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int length=s.length();\n        int [] arr= new int[length];\n        for(int i=0,index=-length;i<length;++i){\n            if(s.charAt(i)==c){\n                index=i;\n            }\n            arr[i]=i-index;\n        }\n        for(int i=length-1,index=2*length;i>=0;--i){\n            if(s.charAt(i)==c){\n                index=i;\n            }\n            arr[i]=Math.min(arr[i],index-i);\n        }\n        return arr;\n    }\n}\n# *复杂度*\n时间复杂度：O(n)，其中n 是字符串 s 的长度。\n空间复杂度：O(1)。返回值不计算成空间复杂度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186552049","body":"# *思路*\r\n用数组进行实现\r\n# *代码*\r\nclass CustomStack {\r\n    int [] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack=new int[maxSize];\r\n        top=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n       if(top !=stack.length-1){\r\n            ++top;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n    \r\n\r\n  public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int length = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1189732029","body":"# *思路*\r\n补卡，这道题一直没太想清楚，参考官方答案，理解后重写\r\n数字的问题，前期忽略了多位数的情况，导致报错\r\n\r\n# *代码*\r\n class Solution{\r\n\r\n        String src;\r\n        int ptr;\r\n       //int repTime ;\r\n\r\n        public String decodeString(String s) {\r\n            src = s;\r\n            ptr = 0;\r\n            return getdecodeStr();\r\n        }\r\n        public String getdecodeStr() {\r\n            //在最后一位的时候，ptr=9，如果charAt在前边汇报错\r\n            if(ptr== src.length()||src.charAt(ptr)==']'){\r\n                return \"\";\r\n            }\r\n            char cur = src.charAt(ptr);\r\n            String ret = \"\";\r\n            int repTime = 0;\r\n\r\n            if(Character.isDigit(cur)){\r\n                //拿出数字之后，往后移位（考虑多位数问题，一定要确保数字都拿完）\r\n                while (Character.isDigit(src.charAt(ptr))) {\r\n                    repTime = repTime * 10 + src.charAt(ptr++) - '0';\r\n                }\r\n                //过滤掉数字后边的[\r\n                ++ptr;\r\n                String str = getdecodeStr();\r\n\r\n                //拿完字母后后移到]\r\n                ++ptr;\r\n                while(repTime-->0){\r\n                    ret+=str;\r\n                }\r\n            }else {\r\n                ret=String.valueOf(cur);\r\n                ++ptr;\r\n            }\r\n            return ret+getdecodeStr();\r\n\r\n\r\n        }\r\n    }\r\n\r\n# *复杂度* \r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1190081044","body":"# *思路*\n栈先进后出，队列先进先出，利用两个栈把栈1的数据导入栈2，再倒回去。\n\n# *代码*\nclass MyQueue {\n        \n        Stack<Integer> stack_1;\n        Stack<Integer> stack_2;\n        \n    public MyQueue() {\n        stack_1=new Stack();\n        stack_2=new Stack();\n    }\n    \n    public void push(int x) {\n        while (!stack_1.isEmpty()){\n            stack_2.push(stack_1.pop());\n        }\n        stack_2.push(x);\n        while (!stack_2.isEmpty()){\n            stack_1.push(stack_2.pop());\n        }\n\n    }\n    \n    public int pop() {\n        return stack_1.pop();\n    }\n    \n    public int peek() {\n        return stack_1.peek();\n    }\n    \n    public boolean empty() {\n        return stack_1.isEmpty();\n    }\n}\n#*复杂度*\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191166439","body":"# *思路*\n拼接成一个旋转链表，头尾相接。\n拼接成功后，右移位k位（原给定的链表长度为n），实际上为原链表从后往前第n-k个位置的next为null\n\n# *代码*\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null||k==0||head.next==null){\n            return head;\n        }\n        ListNode now =head;\n        int count=1;\n        while(!(now.next==null)){\n            now=now.next;\n            count++;\n        }\n        if (count==k||k%count==0){\n            return head;\n        }\n        now.next=head;\n        int n=count-k%count;\n        while (n-->0){\n            now=now.next;\n        }\n        head=now.next;\n        now.next=null;\n        return head;\n\n    }\n}\n# *复杂度*\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195253681","body":"``` java\nclass LRUCache {\n    private Map<Integer, LRUNode> cache = new HashMap<>();\n    private int count;\n    private int capacity;\n    private LRUNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.count = 0;\n        this.capacity = capacity;\n\n        this.head = new LRUNode();\n        this.tail = new LRUNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        LRUNode node = cache.get(key);\n        if (node != null) {\n        \t// 节点存在，最近使用，将节点放到顶部\n            this.moveToHead(node);\n            return node.value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        LRUNode node = cache.get(key);\n        if (node != null) {\n        \t// 节点存在，最近使用，将节点放到顶部\n            node.value = value;\n            this.moveToHead(node);\n        } else {\n        \t// 节点不存在，新增一个节点到顶部\n            LRUNode newNode = new LRUNode(key, value);\n            this.cache.put(key, newNode);\n            this.addNode(newNode);\n            ++this.count;\n            \n            if (this.count > this.capacity) {\n            \t// 如果超过容量，删除底部节点\n                LRUNode tail = this.removeTail();\n                this.cache.remove(tail.key);\n                --this.count;\n            }\n        }\n    }\n\n    private void moveToHead(LRUNode node) {\n        this.removeNode(node);\n        this.addNode(node);\n    }\n\n    private void addNode(LRUNode node) {\n        node.prev = head;\n        node.next = head.next;\n\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(LRUNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private LRUNode removeTail() {\n        LRUNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n\n    private class LRUNode {\n        int key;\n        int value;\n        LRUNode prev;\n        LRUNode next;\n\n        LRUNode() {}\n\n        LRUNode(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185236729","body":"## 思路\n\n---\n\n把num从list转化成str，再转化成int与k相加，最后返回list形式。\n\n## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        x = ''.join(map(str, num))\n        sum = int(x) + k\n        return list(map(int, str(sum)))   # [int(i) for i in str(sum)]\n```\n\n## 复杂度\n\n---\n\n- ****Time:**** O(N)\n- ****Space:**** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186194435","body":"## 思路\n\n\n首先从左往右遍历求距离，再从右往左遍历求距离，计算两边距离的最小值。\n\n## 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [n for i in range(n)]\n        dist = n\n        for i in range(n):\n            if s[i] == c:\n                dist = 0\n            else:\n                dist += 1 \n            ans[i] = dist\n        for j in range(n-1, -1, -1):\n            if s[j] == c:\n                dist = 0\n            else:\n                dist += 1\n            ans[j] = min(dist, ans[j])\n        return ans\n```\n\n## 复杂度\n\n\n- ****Time:**** O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186533825","body":"## 思路\n\n\n用数组模拟栈操作\n\n## 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n        self.size = 0\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        else:\n            self.size -= 1\n            return self.stack.pop()\n            \n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(k, self.size)):\n            self.stack[i] += val\n```\n\n## 复杂度\n\n\n- **Time:** push: O(1)， pop: O(1)， increment: O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187514265","body":"## 思路\n\n\n双栈，一个栈存放数字，一个栈存放字母\n\n## 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == \"]\":\n                tmpstr = \"\"\n                numstr = \"\"\n                while stack and stack[-1] != \"[\":\n                    char = stack.pop()\n                    tmpstr = char + tmpstr\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    num = stack.pop()\n                    numstr = num + numstr\n                stack.append(int(numstr) * tmpstr)\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```\n\n## 复杂度\n\n\n- ****Time:**** O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189081575","body":"## 思路\n\n\n使用两个栈实现队列\n\n## 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        self.stack1.append(x)\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n\n    def pop(self) -> int:\n        return self.stack1.pop()\n\n    def peek(self) -> int:\n        return self.stack1[-1]\n\n    def empty(self) -> bool:\n        if self.stack1:\n            return False\n        else:\n            return True\n```\n\n## 复杂度\n\n\n- ****Time: push:**** O(N) ****pop:**** O(1) ****peek:**** O(1)  ****empty:**** O(1)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190017798","body":"## 思路\n\n\n从左向右遍历数组，下一分块的最小值应该大于上一分块的最大值，每一分块用块中最大值表示\n\n## 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        n = len(arr)\n        for i in range(n):\n            m = arr[i]\n            while stack and stack[-1] > arr[i]:\n                m = max(stack.pop(), m)\n            stack.append(m)\n        return len(stack)\n```\n\n## 复杂度\n\n\n- ****Time:**** O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191534373","body":"## 思路\n\n\n连接首尾形成环形链表，根据移动的距离断开链表\n\n## 代码\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret\n```\n\n## 复杂度\n\n\n- ****Time:**** O(N)\n- **Space:** O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192375799","body":"## 思路\n\n\n迭代的方法，由preA -> A -> B ->BNext 修改为 preA ->B ->A ->nextB，交换两个节点位置，经过3次操作A.next = next.B; B.next = A; preA.next = B. \n\n## 代码\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next: \n            return head\n        ans = ListNode()\n        ans.next = head.next\n        pre = ans\n        while head and head.next:\n            next = head.next\n            n_next = next.next\n\n            next.next = head\n            pre.next = next\n            head.next = n_next\n  \n            pre = head\n            head = n_next\n        return ans.next\n```\n\n## 复杂度\n\n\n- ****Time:**** O(N)\n- **Space:** O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193109606","body":"## 思路\n\n使用快慢指针找到根节点，中点左边的值构造左子树，右边的值构造右子树；递归链表生成二叉树。\n\n## 代码\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        return self.sort(head, None)\n\n    def sort(self, head, tail):\n        if head == tail:\n            return\n        slow = head\n        fast = head\n        while fast != tail and fast.next != tail:\n            slow = slow.next\n            fast = fast.next.next\n        root = TreeNode(slow.val)\n        root.left = self.sort(head, slow)\n        root.right = self.sort(slow.next, tail)\n        return root\n```\n\n## 复杂度\n\n\n- ****Time:**** O(nlogn)\n- **Space:** O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193289628","body":"## 思路\n\n\n两个指针同时遍历，a到尾部后从b头部开始遍历，b到尾部后从a头部开始遍历，a和b相遇时即为节点。\n\n## 代码\n\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a = headA\n        b = headB\n        while a != b:\n            a = a.next\n            b = b.next\n            if not a and not b:\n                return None\n            elif not a:\n                a = headB\n            elif not b:\n                b = headA\n        return a\n```\n\n## 复杂度分析\n\n\n- 时间复杂度：*O(N)*\n- 空间复杂度：*O(1)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194156845","body":"## 思路\n\n快慢两个指针，从head结点走到入环点需要走a + nb， 而slow已经走了nb，那么slow再走a步即为入环点。\n\n## 代码\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n\n```\n\n## 复杂度\n\n\n- ****Time:**** O(N)\n- **Space:** O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195543076","body":"## 思路\n\n\n哈希表加双向链表\n\n## 代码\n\n```python\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def move_node_to_tail(self, key):\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            node.prev = self.tail.prev\n            node.next = self.tail\n            self.tail.prev.next = node\n            self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            self.move_node_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            self.hashmap[key].value = value\n            self.move_node_to_tail(key)\n        else:\n            if len(self.hashmap) == self.capacity:\n                self.hashmap.pop(self.head.next.key)\n                self.head.next = self.head.next.next\n                self.head.next.prev = self.head\n            new = ListNode(key, value)\n            self.hashmap[key] = new\n            new.prev = self.tail.prev\n            new.next = self.tail\n            self.tail.prev.next = new\n            self.tail.prev = new\n\n```\n\n## 复杂度\n\n\n- ****Time:**** O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196822419","body":"## 思路\n\n\nDFS；递归很好用\n\n## 代码\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        ans = 0\n        stack = [(root, 1)]\n        while stack:\n            p, depth = stack.pop()\n            ans = max(ans, depth)\n            if p.left:\n                stack.append((p.left, depth + 1))\n            if p.right:\n                stack.append((p.right, depth + 1))\n        return ans\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))\n```\n\n## 复杂度\n\n\n- ****Time:**** O(N)，\n- **Space:** O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185238518","body":"### 整体思路\n\n模拟真正的加法计算过程\n从后往前依次逐位相加，如果 >=10 则进位\n每次加在 list 末尾，再将 list 反转\n\n### 代码\n\n```java\n    private  List<Integer> leetcodeSolution(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        int len = num.length;\n        for (int i = len - 1;i >= 0;i--){\n            int a = num[i] + k % 10;\n            k /= 10;\n            // 如果和 > 10，需要进位\n            if (a >= 10 ){\n                k++;\n            }\n            result.add(a % 10);\n        }\n\n        // 上面循环做完，是按照数组的长度求的结果，但是 k 可能比数组多很多位，所以还需要一个 while 循环\n        for (; k > 0; k /= 10) {\n            result.add(k % 10);\n        }\n\n        Collections.reverse(result);\n        return result;\n    }\n```\n\n### 复杂度分析\n时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188546091","body":"### 整体思路\n\n用两个栈，一个负责入，一个负责出\n\n### 代码\n\n```java\nclass MyQueue {\n    Stack<Integer> stack1,stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.empty()){\n            while (!stack1.empty()){\n                Integer data = stack1.pop();\n                stack2.push(data);\n            }\n        }\n        return stack2.pop();\n    }\n\n    public int peek() {\n        if (stack2.empty()){\n            while (!stack1.empty()){\n                Integer data = stack1.pop();\n                stack2.push(data);\n            }\n        }\n        return stack2.peek();\n    }\n\n    public boolean empty() {\n        return stack1.empty() && stack2.empty();\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度：各个方法均为 O(1)\n空间复杂度：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193311051","body":"### 整体思路\n这道题不难想到需要用双指针来做，问题在于两条链表可能长度不一致\n分别在两条链表上前进时，并不能同时走到公共节点。\n解决方案是 p1 指针先遍历完 headA，再遍历 headB\n解决方案是 p2 指针先遍历完 headB，再遍历 headA\n这样相当于「逻辑上」两条链表接在了一起，就能同时走到公共节点。\n\n### 代码\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    ListNode p1 = headA, p2 = headB;\n    while (p1 != p2){\n    if(p1 != null){\n    p1 = p1.next;\n    }\n    else{\n    p1 = headB;\n    }\n\n    if(p2 != null){\n    p2 = p2.next;\n    }else{\n    p2 = headA;\n    }\n    }\n\n    return p1;\n    }\n```\n\n### 复杂度分析\n\n时间复杂度：O(m+n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185240028","body":"## 思路\r\n\r\n由于num可能很长，不能转int直接相加，模拟计算机的加法\r\n\r\n## 代码\r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n    \t# space: O(max(M, N))\r\n        res = []\r\n        i = len(num) - 1\r\n        overflow = 0\r\n        # time: O(max(M, N))\r\n        while i >= 0 or k > 0:\r\n            a = num[i] if i >= 0 else 0\r\n            b = k % 10\r\n            c = a + b + overflow\r\n            res.append(c % 10)\r\n            overflow = c // 10\r\n            i -= 1\r\n            k //= 10\r\n        if overflow:\r\n            res.append(overflow)\r\n        # time: O(max(M, N))\r\n        res.reverse()\r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\nM为num.length, N为ceil(log10(k))\r\n\r\n- 时间复杂度: O(Max(M, N))\r\n- 空间复杂度: O(Max(M, N))\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186102244","body":"## 思路\r\n\r\n记录上个c的索引，得到当前字符和c的最小距离。正向反向分表遍历一次，取最小的。\r\n\r\n## 代码\r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        # space: O(N)\r\n        ans = [float('inf')] * n\r\n        last_c_index = float('-inf')\r\n        # time: O(N)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                last_c_index = i\r\n            ans[i] = min(ans[i], i - last_c_index)\r\n        last_c_index = float('inf')\r\n        # time: O(N)\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                last_c_index = i\r\n            ans[i] = min(ans[i], last_c_index - i)\r\n        return ans\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\nN为s.length\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂: O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186439305","body":"## 思路\n\n数组和栈的基本操作\n\n## 代码\n\n```python3\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        # space: O(maxSize)\n        self.array = [0] * maxSize\n        self.size = 0\n\n    def push(self, x: int) -> None:\n        if self.size >= self.maxSize:\n            return\n        self.array[self.size] = x\n        self.size += 1\n\n    def pop(self) -> int:\n        if self.size <= 0:\n            return -1\n        self.size -= 1\n        return self.array[self.size]\n\n    def increment(self, k: int, val: int) -> None:\n        # time: O(k)\n        for i in range(min(k, self.size)):\n            self.array[i] += val\n```\n\n## 复杂度分析\n\n- 初始化\n  - time: O(1)\n  - space: O(maxSize)\n- push\n  - time: O(1)\n  - space: O(1)\n- pop\n  - time: O(1)\n  - space: O(1)\n- increment\n  - time: O(k)\n  - space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186816024","body":"## 思路\r\n\r\n对s中的字符进行压栈, 如果遇到']'说明遇到了一个最内层的表达式, 进行解析, 再压到栈里.   \r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # space: O(N)\r\n        stack = []\r\n        # time : O(N)\r\n        for c in s:\r\n            if c == ']':\r\n                token = ''\r\n                while stack and stack[-1] != '[':\r\n                    token = stack.pop() + token\r\n                stack.pop()\r\n                k = ''\r\n                while stack and stack[-1].isnumeric():\r\n                    k = stack.pop() + k\r\n                stack.append(token * int(k))\r\n            else:\r\n                stack.append(c)\r\n        return ''.join(stack)\r\n```\r\n\r\n## 复杂度分析\r\n\r\nN为s.length\r\n\r\n- time: O(N)\r\n- space: O(N)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189007251","body":"## 思路\r\n\r\n- 使用两个栈：一个用于入队，一个用于出队。\r\n- 使用一个变量辅助保存队首元素。\r\n\r\n## 代码\r\n\r\n```python3\r\nclass MyQueue:\r\n\t\r\n    def __init__(self):\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n        self.push_stack_bottom = None\r\n\r\n    def push(self, x: int) -> None:\r\n        if not self.push_stack:\r\n            self.push_stack_bottom = x\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.pop_stack:\r\n           return self.pop_stack[-1]\r\n        return self.push_stack_bottom\r\n\r\n    def empty(self) -> bool:\r\n        return not self.push_stack and not self.pop_stack\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- push\r\n  - time: O(1)\r\n  - space: O(N)\r\n- pop\r\n  - time: 平均 O(1) 最坏 O(N)\r\n  - space: O(1)\r\n- peek\r\n  - time: O(1)\r\n  - space: O(1)\r\n- empty\r\n  - time: O(1)\r\n  - space: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190386113","body":"## 思路\n\n利用单调栈的性质，求出每个块的最大值\n\n## 代码\n\n```python3\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and stack[-1] > num:\n                cur = stack[-1]\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(num)\n        return len(stack)\n\n```\n\n## 复杂度分析\n\n设 N = arr.length\n\n- time: O(N)\n- space: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191446045","body":"## 思路\n\n- 求出链表的长度n\n- k对n取模\n- 把头结点移动到尾结点，重复n-k次\n- 对n<=1特殊处理\n\n## 代码\n\n```python3\n\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        dummy_head = ListNode(val=0, next=head)\n        n = 0\n        tail = dummy_head\n        while tail.next:\n            tail = tail.next\n            n += 1\n        if n <= 1:\n            return head\n        k = n - (k % n)\n        for _ in range(k):\n            head = dummy_head.next\n            dummy_head.next = dummy_head.next.next\n            head.next = None\n            tail.next = head\n            tail = tail.next\n        return dummy_head.next\n\n```\n\n\n## 复杂度分析\n\nN为链表的长度\n\n- time: O(N)\n- space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192243571","body":"## 思路\n\n假设要交换node1和node2，使用三个指针p0/p1/p2指向node1的前驱，node1和node2。穿针引线。\n\n\n## 代码\n\n```python3\n\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        dummy_head = ListNode(val=0, next=head)\n        p0, p1, p2 = dummy_head, dummy_head.next, dummy_head.next.next\n        while p1 and p2:\n            p0.next = p2\n            p1.next = p2.next\n            p2.next = p1\n            p0 = p1\n            p1 = p0.next\n            p2 = p1.next if p1 else None\n        return dummy_head.next\n```\n\n## 复杂度分析\n\nn为链表长度\n\n- Time: O(n)\n- Space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193037543","body":"# 思路\n\n- 快慢指针+分治法。\n\n- 快慢指针找到中点，以中点为根，递归构造左右子树。\n\n\n\n# 代码\n\n```python3\n\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(val=head.val)\n        prev, slow, fast = None, head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            prev = slow\n            slow = slow.next\n        prev.next = None\n        tree_node = TreeNode(val=slow.val)\n        tree_node.left = self.sortedListToBST(head)\n        tree_node.right = self.sortedListToBST(slow.next)\n        return tree_node\n\n```\n\n# 复杂度分析\n\nn为链表的长度\n\n- Time: O(nlog(n)) log(n)层递归，每层遍历节点数为n\n- Space: O(log(n)) 不计返回值，递归栈深度log(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193232908","body":"## 思路\n\n1. 哈希法\n2. 快慢指针法，这里使用快慢指针法\n\n## 代码\n\n```python3\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        pa, pb = headA, headB\n        while pa != pb:\n            pa, pb = pa.next, pb.next\n            if not pa and not pb:\n                return None\n            if pa is None:\n                pa = headB\n            if pb is None:\n                pb = headA\n        return pa\n\n```\n\n## 复杂度分析\n\n- Time:  O(max(headA.length, headB.length))\n- Space: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193442396","body":"## 思路\n\n快慢指针法\n\n1. slow每次走一步，fast每次走两步，两者相遇时重定向fast到头结点，slow和fast每次走一步，两者相遇时即为相交点。\n\n2. 如果fast走到了null，代表没有环。\n\n\n## 代码\n\n```python3\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return None\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n        if not fast or not fast.next:\n            return None\n        fast = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        return fast\n\n``\n\n\n## 复杂度分析\n\nn = 链表的长度\n\n- Time: O(n)\n- Space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194999478","body":"## 思路\n\n双链表+哈希表\n\n- 哈希表实现O(1)的查找\n- 双链表实现淘汰逻辑\n\n\n## 代码\n\n```python3\n\nclass DNode:\n    def __init__(self, key: int = 0, val: int = 0, prev: 'DNode' = None, next: 'DNode' = None):\n        self.key: int = key\n        self.val: int = val\n        self.prev: 'DNode' = prev\n        self.next: 'DNode' = next\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.dummy_head: DNode = DNode()\n        self.dummy_tail: DNode = DNode()\n        self.dummy_head.next = self.dummy_tail\n        self.dummy_tail.prev = self.dummy_head\n        self.key_to_node_dict: Dict[int, DNode] = {}\n        self.capacity: int = capacity\n        self.size: int = 0\n\n    def __del_node(self, node: DNode) -> None:\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def __add_to_tail(self, node: DNode) -> None:\n        node.next = self.dummy_tail\n        node.prev = self.dummy_tail.prev\n        node.prev.next = node\n        node.next.prev = node\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_node_dict:\n            return -1\n        node = self.key_to_node_dict[key]\n        self.__del_node(node)\n        self.__add_to_tail(node)\n        return node.val\n\n    def __evict(self) -> None:\n        if self.size <= self.capacity or self.size <= 0:\n            return\n        head = self.dummy_head.next\n        self.__del_node(head)\n        key = head.key\n        del self.key_to_node_dict[key]\n        self.size -= 1\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.key_to_node_dict:\n            node = DNode(key=key, val=value)\n            self.key_to_node_dict[key] = node\n            self.size += 1\n        else:\n            node = self.key_to_node_dict[key]\n            node.val = value\n            self.__del_node(node)\n        self.__add_to_tail(node)\n        self.__evict()\n\n```\n\n\n## 复杂度分析\n\n- get\n  - Time: O(1)\n  - Space: O(1)\n- put\n  - Time: O(1)\n  - Space: O(n) 哈希表和双链表的空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195723897","body":"# 思路\n\nBFS\n\n## 代码\n\n```python3\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        queue = deque([root])\n        depth = 0\n        while queue:\n            depth += 1\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return depth\n\n```\n\n\n## 复杂度分析\n\nn为节点数量\n\n- Time: O(n)\n- Space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197002685","body":"## 思路\n\n分治法\n\n## 代码\n\n```python3\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p or not q:\n            return not p and not q\n        return p.val == q.val \\\n               and self.isSameTree(p.left, q.left) \\\n               and self.isSameTree(p.right, q.right)\n\n```\n\n## 复杂度分析\n\n- Time: O(min(p.size, q.size))\n- Space: O(min(p.height, q.height))\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185251187","body":"class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry = 0\r\n        i = 1\r\n        n = len(num)\r\n        while n-1 >= 0 or carry != 0 or k != 0:\r\n            if n-1 < 0:\r\n                number = k%10 + carry\r\n            else:\r\n                number = num[n-1] + k%10 + carry\r\n            k = k//10\r\n            carry = number//10\r\n            number = number % 10\r\n            res.append(number)\r\n            n -= 1\r\n        return res[::-1]\r\n\r\nspace complexity O(n) time complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185878663","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        answer = []\r\n        for i, v in enumerate(s):\r\n            if v == c:\r\n                res.append(i)\r\n        for i in range(len(s)):\r\n            m = math.inf\r\n            for j in range(len(res)):\r\n                m = min(abs(i-res[j]), m)\r\n            answer.append(m)\r\n        return answer\r\ntime complexity O(n^2) space complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186441195","body":"class CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.data = []\r\n    def isEmpty(self):\r\n        if len(self.data) == 0:\r\n            return True\r\n        else: \r\n            return False\r\n    def isFull(self):\r\n        if len(self.data) == self.maxSize:\r\n            return True\r\n        else:\r\n            return False\r\n            \r\n    def push(self, x: int) -> None:\r\n        if self.isFull() == True:\r\n            pass\r\n        else:\r\n            self.data.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.isEmpty() == True:\r\n            return -1\r\n        else:\r\n            return self.data.pop(-1)\r\n        return s.pop() if s is not None else -1\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(len(self.data)):\r\n            if i<k:\r\n                self.data[i] = self.data[i]+val\r\ntime complexity O(n) space complexity O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188353551","body":"class Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        #stack\r\n        stack = []\r\n        for i in range(len(s)):\r\n            if s[i] != \"]\":\r\n                stack.append(s[i])\r\n            else:\r\n                st = \"\"\r\n                while stack[-1] != \"[\":\r\n                    st = stack.pop() + st\r\n                stack.pop()\r\n                num = \"\"\r\n                while stack and stack[-1].isdigit():\r\n                    num = stack.pop() + num\r\n                stack.append(int(num)*st)\r\n        return \"\".join(stack)\r\ntime complexity O(n) space complexity O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188654987","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.s1 = []\r\n        self.s2 = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        self.s1.append(x)\r\n        while self.s2:\r\n            self.s1.append(self.s2.pop())\r\n            \r\n    def pop(self) -> int:\r\n        return self.s1.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        return self.s1[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return False if self.s1 else True","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189905583","body":"class Solution:\r\n    def maxChunksToSorted(self, arr: list[int]) -> int:\r\n        stack = []\r\n        stack.append((arr[0], arr[0]))\r\n        for i in range(1, len(arr)):\r\n            minNum, maxNum = arr[i], arr[i]\r\n            while stack and stack[-1][1] > minNum:\r\n                prevMinNum, prevMaxNum = stack.pop()\r\n                minNum, maxNum = min(prevMinNum, minNum), max(prevMaxNum, maxNum)\r\n            stack.append((minNum, maxNum))\r\n        return len(stack)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191097100","body":"class Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        n = 0\r\n        dummy = ListNode(0, head)\r\n        pre = dummy\r\n        while head:\r\n            n += 1\r\n            head = head.next\r\n            pre = pre.next \r\n        if n <= 1:\r\n            return dummy.next\r\n        num = k % n\r\n        if num == 0:\r\n            return dummy.next\r\n        preN = dummy\r\n        head = dummy.next\r\n        while n-num-1 >= 0:\r\n            head = head.next\r\n            preN = preN.next\r\n            num += 1\r\n        preN.next = None\r\n       \r\n        pre.next = dummy.next\r\n        return head\r\n        \r\nTime complexity O(n), space complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192208106","body":"class Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        dummy = ListNode(0, head)\r\n        pre, cur = dummy, head\r\n        while cur and cur.next:\r\n            tmp = cur.next.next\r\n            # swap\r\n            pre.next = cur.next\r\n            cur.next.next = cur\r\n            cur.next = tmp\r\n            # updata\r\n            pre = cur\r\n            cur = tmp\r\n        return dummy.next\r\nTime complexity O(n) Space complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193074805","body":"class Solution:\r\n    def findMiddle(self,head):\r\n        prev=None\r\n        slow,fast=head,head\r\n        while fast and fast.next:\r\n            prev=slow\r\n            slow=slow.next\r\n            fast=fast.next.next\r\n        return prev,slow    \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if head is None:\r\n            return None\r\n        prev,mid=self.findMiddle(head)\r\n        root=TreeNode(mid.val)\r\n        root.right=self.sortedListToBST(mid.next)\r\n        if prev is None:\r\n            root.left=None\r\n        else:\r\n            prev.next=None\r\n            root.left=self.sortedListToBST(head)\r\n        return root ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193262627","body":"class Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        \r\n        pA = headA\r\n        pB = headB\r\n        \r\n        while pA != pB:\r\n            pA = headB if pA is None else pA.next\r\n            pB = headA if pB is None else pB.next\r\n        return pA\r\nspace complexity O(1) time complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193648309","body":"class Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next: return\r\n        slow = head.next\r\n        fast = head.next.next\r\n        while slow != fast:\r\n            if not fast or not fast.next:\r\n                return \r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        p1, p2 = head, fast\r\n        while p1 != p2:\r\n            p1 = p1.next\r\n            p2 = p2.next\r\n        return p1\r\nTime complexity O(n) space complexity O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196305783","body":"class Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root: return 0\r\n        left = self.maxDepth(root.left)\r\n        right = self.maxDepth(root.right)\r\n        return max(left, right)+1\r\nTime complexity O(1) Space complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197415188","body":"class Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q: return True\r\n        if not p or not q: return False\r\n        if p.val != q.val:\r\n            return False\r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\nTime complexity O(n) space complexity O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185258544","body":"# LC989. Add to Array-Form of Integer\n## Main Idea\nFirst, it looks like we can convert the array `num` to integer and add it to `k`, but `num.length <= 1E+4` so this approach will cause integer overflow. So we will have to do the addition in array form.\n\nThen the idea is to simulate the entire process, add each digit of `num` and `k` with a `carry` bit. We will terminate the loop when we run out of digits for both `num` and `k` and `carry == 0`.\n\n## Code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int ptr = num.length - 1, carry = 0;\n        List<Integer> ret = new ArrayList<>();\n        while (ptr >= 0 || k > 0 || carry > 0) {\n            int d1 = ptr >= 0 ? num[ptr] : 0;\n            int d2 = k % 10;\n            int sum = d1 + d2 + carry;\n            ret.add(sum % 10);\n            ptr--;\n            k /= 10;\n            carry = sum >= 10 ? 1 : 0;\n        }\n        \n        Collections.reverse(ret);\n        return ret;\n    }\n}\n```\n\n## Complexity Analysis\nTime: `O(2*max(N, log(K)))`\n* Given a number `K`, its length will be `O(log_{2}(K))`, the time complexity depends on the length of `N` and `K`, whichever is longer.\n* Notice we want to insert digits at the end of the array and then reverse it after we finish the addition (reverse takes `O(res.size())`). If we insert at the head of array, then it will take `O(n^2)` of time.\n\nSpace: `O(1)`, as we didn't use additional spaces except the return array.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186129158","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length(), count = Integer.MAX_VALUE;\n        int[] ret = new int[n];\n        Arrays.fill(ret, Integer.MAX_VALUE);\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                count = 0;\n            }\n            ret[i] = Math.min(ret[i], count);\n            if (count != Integer.MAX_VALUE)\n                count++;\n        }\n        \n        count = Integer.MAX_VALUE;\n        for (int i = n - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                count = 0;\n            }\n            \n            ret[i] = Math.min(ret[i], count);\n            if (count != Integer.MAX_VALUE)\n                count++;\n        }\n        \n        return ret;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186426699","body":"```java\nclass CustomStack {\n    private Deque<Integer> stack;\n    private int[] arr;\n    public CustomStack(int maxSize) {\n        stack = new ArrayDeque<>();\n        arr = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (stack.size() < arr.length) {\n            stack.push(x);\n        } \n    }\n    \n    public int pop() {\n        if (stack.isEmpty()) {\n            return -1;\n        }\n        int index = stack.size() - 1, ret = stack.pop() + arr[index];\n        if (index > 0) {\n            arr[index - 1] += arr[index];\n        }\n        arr[index] = 0;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        k = Math.min(k - 1, stack.size() - 1);\n        if (k >= 0) {\n            arr[k] += val;\n        }\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191155942","body":"```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return head;\n        }\n        int n = getLen(head);\n        k %= n;\n        if (k == 0) {\n            return head;\n        }\n        \n        ListNode fast = head, slow = head;\n        for (int i = 0; i < k; i++) {\n            fast = fast.next;\n        }\n\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        fast.next = head;\n        ListNode ret = slow.next;\n        slow.next = null;\n        return ret;\n    }\n    \n    private int getLen(ListNode head) {\n        int ret = 0;\n        while (head != null) {\n            ret++;\n            head = head.next;\n        }\n        return ret;\n    }\n}\n```\n\nTime: `O(n)`\n\nSpace: `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192343793","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(), prev = dummy;\n        dummy.next = head;\n        while (prev != null) {\n            ListNode cur = null, next = null;\n            \n            cur = prev.next;\n            if (cur != null) {\n                next = cur.next;\n            }\n            \n            if (next != null) {\n                prev.next = next;\n                ListNode tmp = next.next;\n                next.next = cur;\n                cur.next = tmp;\n            }\n            prev = cur;\n        }\n        \n        return dummy.next;\n    }\n}\n```\nTime: `O(n)`\n\nSpace: `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193045044","body":"```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        } else if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n        \n        ListNode midPrev = findMidPrev(head), mid = midPrev.next;\n        midPrev.next = null;\n        TreeNode ret = new TreeNode(mid.val);\n        ret.left = sortedListToBST(head);\n        ret.right = sortedListToBST(mid.next);\n        return ret;\n    }\n    \n    private ListNode findMidPrev(ListNode head) {\n        ListNode fast = head.next.next, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\nTime: `O(nlogn)`\n\nSpace: `O(logn)`","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194565112","body":"# LC146. LRU Cache\n## Method. Map + Linked List\n### Main Idea\nWe can use a linked list to simulate the cache queue, but if we just use a linked list, then the time complexity of `get()` and `remove()` will be `O(n)`.\n\nTo make the `get()` and `remove()` operations more efficient, we can use a map to store `(key, ListNode)` pairs. Given a key, we can get its node immediately from the map instead of going through the linked list.\n### Code\n```java\nclass LRUCache {\n    private class DBListNode {\n        private DBListNode prev;\n        private DBListNode next;\n        private int key;\n        private int val;\n\n        private DBListNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n    \n    private DBListNode head;\n    private DBListNode tail;\n    private int cap;\n    private int size;\n    private Map<Integer, DBListNode> map;\n\n    public LRUCache(int capacity) {\n        head = new DBListNode(-1, -1);\n        tail = new DBListNode(-1, -1);\n        map = new HashMap<>();\n        head.next = tail;\n        tail.prev = head;\n        cap = capacity;\n    }\n    \n    public int get(int key) {\n        if (!map.containsKey(key)) {\n            return -1;\n        }\n        DBListNode node = map.get(key);\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n        return node.val;\n    }\n    \n    public void put(int key, int value) {\n        DBListNode node;\n        if (map.containsKey(key)) {\n            node = map.get(key);\n            node.val = value;\n            node.prev.next = node.next;\n            node.next.prev = node.prev;\n        } else {\n            if (size < cap) {\n                ++size;\n            } else {\n                DBListNode remove = tail.prev;\n                remove.prev.next = tail;\n                tail.prev = remove.prev;\n                map.remove(remove.key);\n            }\n            node = new DBListNode(key, value);\n        }\n\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n        map.put(key, node);\n    }\n}\n```\n\n### Complexity Analysis\nTime: `O(1)` for all operations\nSpace: `O(cap)`\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195969293","body":"```java\nclass Solution {\n    private int maxDepth;\n    public int maxDepth(TreeNode root) {\n        this.maxDepth = 0;\n        dfs(root, 1);\n        return maxDepth;\n    }\n    \n    private void dfs(TreeNode node, int depth) {\n        if (node == null) {\n            return;\n        }\n        maxDepth = Math.max(maxDepth, depth);\n        dfs(node.left, depth + 1);\n        dfs(node.right, depth + 1);\n    }\n}\n```\n\nTime: `O(n)`\nSpace: `O(height) = O(n)` for recursion.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197299046","body":"```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null || q == null) {\n            return p == null && q == null;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\nTime: `O(n)`\nSpace: `O(height) = O(n)` for recursion","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185259516","body":"- Time: $O(N)$, N is $max(num.size(), ceil(log(k)))$\n- Space: $O(1)$, no extra space is used apart from the output array.\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        res.reserve(num.size());\n        int p = num.size() - 1;\n\n        while (p >= 0 || k > 0) {\n            if (p >= 0) k += num[p--];\n            res.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186111046","body":"- Time: $O(N)$\n- Space: $O(1)$\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, n);\n        \n        if (s[0] == c) res[0] = 0;\n\n        for (int i = 1; i < n; i++)\n            res[i] = s[i] == c ? 0 : res[i - 1] + 1;\n\n        for (int i = n - 2; i >= 0; i--)\n            res[i] = min(res[i], res[i + 1] + 1);\n\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186387195","body":"- Time: `push` $O(1)$, `pop` $O(1)$, `increment` $O(1)$\r\n- Space: $O(N)$, N is maxSize\r\n\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : capacity_(maxSize) {\r\n        inc_ = vector<int>(capacity_, 0);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top_ == capacity_ - 1) return;\r\n        stk_.push(x);\r\n        top_++;\r\n    }\r\n    \r\n    int pop() {\r\n        if (top_ == -1) return -1;\r\n\r\n        int x = stk_.top(); stk_.pop();\r\n        x += inc_[top_];\r\n\r\n        if (top_ > 0) \r\n            inc_[top_ - 1] += inc_[top_];\r\n        inc_[top_--] = 0;\r\n\r\n        return x;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k - 1, top_);\r\n        if (k > -1) inc_[k] += val;\r\n    }\r\nprivate:\r\n    int capacity_;\r\n    int top_ = -1;\r\n    stack<int> stk_;\r\n    vector<int> inc_;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186696536","body":"- Time: $O(N)$. N is the length of the decoded string\n- Space: $(O(N)$. N is the length of the decoded string. This is the space used by the `tokens` stack.\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> tokens;\n\n        for (char c : s) {\n            if (c != ']') {\n                tokens.push(string(1, c));\n                continue;\n            }\n\n            // get the repeat patern\n            // everything after \"[\"\n            string p;\n            while (!tokens.empty() && tokens.top() != \"[\") {\n                p += tokens.top();\n                tokens.pop();\n            }\n            // pop out the \"[\"\n            tokens.pop();\n\n            // get the repeat number\n            // which comes right before the \"[\"\n            string num;\n            while (!tokens.empty() && isNumber(tokens.top())) {\n                num = tokens.top() + num;\n                tokens.pop();\n            }\n\n            // repeat the pattern string and put it back to the stack\n            tokens.push(repeat(stoi(num), p));\n        }\n\n        return join(tokens);\n    }\nprivate:\n    bool isNumber(const std::string& s) {\n        auto it = s.begin();\n        while (it != s.end() && std::isdigit(*it)) ++it;\n        return !s.empty() && it == s.end();\n    }\n\n    string repeat(int k, string s) {\n        string res;\n        while (k) {\n            res += s;\n            k--;\n        }\n        return res;\n    }\n    \n    string join(stack<string> stk) {\n        string res;\n        while (!stk.empty()) {\n            res += stk.top();\n            stk.pop();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188510676","body":"- Time: `push` $O(1)$, `pop` $O(1)$, `peek` $O(1)$\n- Space: $O(N)$\n```cpp\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        write_.push(x);\n    }\n    \n    int pop() {\n        if (read_.empty()) pour();\n        int x = read_.top();\n        read_.pop();\n        return x;\n    }\n    \n    int peek() {\n        if (read_.empty()) pour();\n        return read_.top();\n    }\n    \n    bool empty() {\n        return read_.empty() && write_.empty();\n    }\nprivate:\n    void pour() {\n        while (!write_.empty()) {\n            read_.push(write_.top());\n            write_.pop();\n        }\n    }\n\n    stack<int> read_;\n    stack<int> write_;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189729951","body":"- Time: $O(N)$, N is the size of arr.\r\n- Space: $O(N)$, the space used by the stack.\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        // a non-strictly increasing stack\r\n        stack<int> stk;\r\n        for (int n : arr) {\r\n            if (stk.empty() || n >= stk.top()) {\r\n                stk.push(n);\r\n            } else {\r\n                int top = stk.top(); stk.pop();\r\n                while (!stk.empty() && stk.top() > n)\r\n                    stk.pop();\r\n                stk.push(top);\r\n            }\r\n        }\r\n        return stk.size();\r\n    }\r\n};\r\n```\r\n\r\nhttps://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190952790","body":"- Time: $O(N)$, N is the length of the list. In worst case the list is traversed twice.\n- Space: $O(1)$\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head || !head->next || k == 0) return head;\n\n        ListNode *rotated_head, *cur;\n        int n = 1;\n\n        cur = head;\n        while (cur->next) {\n            cur = cur->next;\n            n++;\n        }\n\n        k = n - k % n;\n        cur->next = head; // connect the tail and the head\n        while (k--) cur = cur->next;\n\n        rotated_head = cur->next;\n        cur->next = nullptr;\n        return rotated_head;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192102035","body":"- Time: $O(N)$. N is the length of the list.\n- Space: $O(N)$. Recursive stack space.\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (!head || !head->next) return head;\n        ListNode *a = head, *b = a->next, *c = swapPairs(b->next);\n        a->next = c;\n        b->next = a;\n        return b;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193100292","body":"- Time: $(O(N*H)$, N is the length of the list and H is the depth of the recursion tree, which is $logN$. Each level of the recursion will take $O(N)$ time to look up for the middle list node.\n- Space: $O(H)$, H is the depth of the recursion tree, which is $logN$.\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        return sortedListToBST(head, nullptr);\n    }\nprivate:\n    TreeNode* sortedListToBST(ListNode* head, ListNode* end) {\n        if (!head || head == end) return nullptr;\n\n        // find the middle list node\n        ListNode* mid = findMidNode(head, end);\n\n        TreeNode* root = new TreeNode(mid->val);\n        // devide and conquer\n        root->left = sortedListToBST(head, mid);\n        root->right = sortedListToBST(mid->next, end);\n\n        return root;\n    }\n    ListNode* findMidNode(ListNode* head, ListNode* end) {\n        ListNode *p1, *p2;\n        p1 = p2 = head;\n        while (p2 != end && p2->next != end) {\n            p1 = p1->next;\n            p2 = p2->next->next;\n        }\n        return p1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193231180","body":"- Time: $O(N)$\n- Space: $O(1)$\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* a = headA;\n        ListNode* b = headB;\n        while (a != b) {\n            a = a ? a->next : headB;\n            b = b ? b->next : headA;\n        }\n        return a;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193472788","body":"- Time: $O(N)$\n- Space: $O(1)$\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (!head || !head->next) return NULL;\n\n        ListNode *slow, *fast;\n        slow = fast = head;\n\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) break;\n        }\n\n        if (slow != fast) return NULL;\n\n        slow = head;\n        while (slow != fast) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return slow;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194926213","body":"- Time: `put` $O(1)$, `get` $O(1)$.\n- Space: $O(N)$, N is the `capacity`, which is space used by the doubly linked list and the unordered map.\n```cpp\nclass DList {\npublic:\n    class Node {\n    public:\n        Node(int in_key, int in_value) : key(in_key), value(in_value) {}\n\n        int key;\n        int value;\n        Node* prev = nullptr;\n        Node* next = nullptr;\n    };\n\n    DList() {\n        d_head_ = new Node(-1, -1);\n        d_tail_ = new Node(-1, -1);\n        d_head_->next = d_tail_;\n        d_tail_->prev = d_head_;\n    }\n\n    void push_front(Node* node) {\n        insert_after(d_head_, node);\n    }\n\n    void push_back(Node* node) {\n        insert_after(tail(), node);\n    }\n\n    void insert_after(Node* target, Node* node) {\n        Node* o_next = target->next;\n        target->next = node;\n        node->prev = target;\n        node->next = o_next;\n        o_next->prev = node;\n        size_++;\n    }\n\n    void erase(Node* node) {\n        Node* prev = node->prev;\n        Node* next = node->next;\n        prev->next = next;\n        next->prev = prev;\n        node->prev = node->next = nullptr;\n        size_--;\n    }\n\n    Node* head() { return size_ == 0 ? nullptr : d_head_->next; }\n\n    Node* tail() { return size_ == 0 ? nullptr : d_tail_->prev; }\n\n    int size() { return size_; }\n\nprivate:\n    Node* d_head_;\n    Node* d_tail_;\n    int size_ = 0;\n};\n\nclass LRUCache {\npublic:\n    using Node = DList::Node;\n\n    LRUCache(int capacity) : capacity_(capacity) {\n        list_ = new DList();\n    }\n    \n    int get(int key) {\n        Node* node = map_[key];\n        if (!node) return -1;\n\n        list_->erase(node);\n        list_->push_front(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        Node* node = map_[key];\n        // update existing key\n        if (node) {\n            node->value = value;\n            list_->erase(node);\n            list_->push_front(node);\n            return;\n        }\n\n        // capacity reached. remove outdated key.\n        if (list_->size() == capacity_) {\n            Node* d_node = list_->tail();\n            list_->erase(d_node);\n            map_.erase(d_node->key);\n        }\n\n        // insert new key\n        node = new Node(key, value);\n        map_[key] = node;\n        list_->push_front(node);\n    }\nprivate:\n    int capacity_;\n    DList* list_;\n    unordered_map<int, Node*> map_;\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196185669","body":"https://www.notion.so/suukii/ca5e6d9d43704a9d82e44758636642d6?v=e7bdde0a51e9424fa96b876e78b03958&p=e6f74b3432c04631ab687e89bb50b9d1&pm=s\r\n\r\n## Recursive\r\n\r\n- Time: $O(N)$, N is the total number of tree nodes.\r\n- Time: $O(H)$, H is the depth of the tree.\r\n```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (!root) return 0;\r\n        if (!root->left && !root->right) return 1;\r\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\r\n    }\r\n};\r\n```\r\n\r\n## Iterative\r\n\r\n- Time: $O(N)$\r\n- Space: $O(N)$\r\n```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        int depth = 0;\r\n        queue<TreeNode*> q;\r\n\r\n        if (root) q.push(root);\r\n\r\n        while (!q.empty()) {\r\n            int size = q.size();\r\n            depth++;\r\n\r\n            while (size--) {\r\n                TreeNode* n = q.front(); q.pop();\r\n                if (n->left) q.push(n->left);\r\n                if (n->right) q.push(n->right);\r\n            }\r\n        }\r\n\r\n        return depth;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197561389","body":"- Time: $O(N)$, N is the number of tree nodes.\n- Space: $O(H)$, H is the height of the tree.\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (!p && !q) return true;\n        if (!p || !q || p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185287919","body":"思路\r\n按照 正常的手写加法的逻辑做的只是好像机器化了，感觉自己好弱\r\ncode\r\n```\r\nvar addToArrayForm = function(num, k) {\r\nconst res = [] \r\nvar str = k.toString();\r\nvar arr = str.split(\"\")\r\narr = arr.map(Number)\r\nlet carry = 0;\r\nlet l1 = num.length -1\r\nlet l2 = arr.length -1\r\nwhile(l1>=0 || l2>=0){\r\n    let x = l1 < 0 ? 0 : num[l1]\r\n    let y = l2 < 0 ? 0 : arr[l2]\r\n    let sum = x + y + carry\r\n    res.push(sum % 10)\r\n    carry = Math.floor(sum/10)\r\n    l1--\r\n    l2--\r\n}\r\nif(carry != 0 )res.push(carry)\r\nreturn res.reverse()\r\n\r\n};\r\n```\r\n复杂程度\r\n 还没学会怎么算基础有些差","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189052507","body":"```\nvar MyQueue = function() {\n    this.inarray = []\n    this.outarray2 = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inarray.push(x)\n\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  const size = this.outarray2.length;\n   if(size) {//push的时候判断输出栈是否为空\n       return this.outarray2.pop();//不为空则输出栈出栈\n   }\n   while(this.inarray.length) {//输出栈为空，则把输入栈所有的元素加入输出栈\n       this.outarray2.push(this.inarray.pop());\n   }\n   return this.outarray2.pop();\n\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n const x = this.pop();//查看队头的元素 复用pop方法，然后在让元素push进输出栈\n   this.outarray2.push(x);\n   return x;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n   return !this.inarray.length && !this.outarray2.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185331610","body":"## 题目描述\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/\n\n## 解题思路\n\n###逐位相加，记录进位\n\n\n####难点\n1. 数字怎么按位拆分\n   * **数字不用拆分**\n    * **num[i] + k % 10 先相加再%10**\n2. 数组和数字位数不同时怎么处理\n   * 开始打算取位数最多的，其实只用对没加完的数字单独处理\n3. 进位处理\n    * 加到数字上\n    \n####js代码\n```javascript\n  var addToArrayForm = function(num, k) {\n  const res = []\n    \n  for(let i = num.length - 1; i>=0; i--) {\n      let sum = num[i] + k % 10\n      k = Math.floor(k / 10)\n      if (sum > 9) {\n        k++\n        res.push(sum % 10)\n      } else {\n        res.push(sum)\n      }\n  }\n  while(k) {\n      res.push(k%10)\n      k = Math.floor(k/10)\n  }\n  return res.reverse()\n  \n};\n```\n####复杂度\n* 时间复杂度 O(max(num.length, log k))\n* 空间复杂度 O(1)\n\n## 加法模版\n```\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n\nwhile ( A 没完 || B 没完)\nA 的当前位\nB 的当前位\n\n    和 = A 的当前位 + B 的当前位 + 进位carry\n\n    当前位 = 和 % 10;\n    进位 = 和 / 10;\n\n判断还有进位吗\n```\n\n\n\n     \n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186165018","body":"## 题目描述\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/\n## 解题思路\n\n记录字符c出现的下标，遍历比较最短距离\n\n\n###我的暴力解法（👎👎👎\n\n####js代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n        let indexList = []\n        let res = []\n        for(let i = 0; i < s.length; i++) {\n            if (s[i] === c) {\n                indexList.push(i)\n                res[i] = 0\n            }\n        }\n        let k = 0\n        for(let i = 0; i < s.length; i++) {\n            if(!indexList.includes(i)) {\n                while(k+1 < indexList.length && Math.abs( indexList[k] - i) > Math.abs(indexList[k+1] - i)) {\n                    k += 1\n                }\n                res[i] =  Math.abs( indexList[k] - i)\n            }\n        }\n        return res\n    };\n```\n####复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(1)\n\n###官方题解\n\n- 双向遍历\n- 问题可以转换成，对s的每个下标i，求 \\\n    s[i]  到其左侧最近的字符 cc 的距离\\\n    s[i]  其右侧最近的字符 cc 的距离 \\\n  这两者的最小值。\n  \n####难点：\n在开始遍历的时候，不知道第一个等于目标字符的index在哪，为了简化逻辑，我们可以用 -n 或 2n 表示，这里 n 是 s 的长度。\n确保每一位到index的距离 >= n\n取n的话从右遍历，最小距离为1\n\n####js代码\n```javascript\nvar shortestToChar = function(s, c) {\n    let n = s.length\n    let res = new Array(n).fill(0)\n    for(let i = 0, index = 2*n; i < s.length; i++) {\n        if (s[i] === c) {\n            index = i\n        } else {\n            res[i] = Math.abs(i - index)\n        }\n    }\n    \n    for(let i = s.length - 1,index = 2*n; i >= 0; i--) {\n       if (s[i] === c) {\n           index = i\n       } else {\n           res[i] = Math.min(res[i], Math.abs(i - index))\n       }\n    }\n    return res\n};\n```\n####复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(1)\n\n\n\n     \n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186513644","body":"## 题目描述\nhttps://leetcode.cn/problems/design-a-stack-with-increment-operation/\n\n## 解题思路\n用数组模拟栈，用变量记录栈顶位置\n\n\n####js代码\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n        this.res = new Array()\n        this.add = new Array()\n        this.maxSize = maxSize\n        this.top = -1\n    };\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n\n    if (this.top < this.maxSize - 1) {\n        ++this.top\n        this.res[this.top] = x\n        this.add[this.top] = 0\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.top >= 0) {\n        const item = this.res[this.top] + this.add[this.top]\n        this.top--\n        return item\n    }\n    return -1\n\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < Math.min(k, this.top+1); i++) {\n        this.add[i] +=  val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n\n####复杂度\n* 时间复杂度 O(1)\n* 空间复杂度 O(maxSize)\n\n\n\n     \n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187622403","body":"### 题目描述\nhttps://leetcode.cn/problems/decode-string/\n\n### 解题思路\n把 ']' 当作出栈信号\n\n### 代码\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    const isNum = (n) => Number(n) >= 0 && Number(n) <= 9\n    let res=''\n    for(i=0; i<s.length; i++) {\n        if (s[i] !== ']') {\n            stack.push(s[i])\n        } else {\n            let str=''\n            let num=''\n            let str2=''\n            while(stack[stack.length - 1] !== '[') {\n                str = stack[stack.length - 1] + str\n                stack.length--\n            }\n            stack.length--\n            while(isNum(stack[stack.length - 1])) {\n                num = stack[stack.length - 1] + num\n                stack.length--\n            }\n            while(Number(num) > 0) {\n                str2 = str2 + str\n                num--\n            }\n            stack.push(str2)\n        }\n    }\n    for(i=0;i<stack.length;i++) {\n        res= res+stack[i]\n    }\n    return res\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188559217","body":"var MyQueue = function() {\n    this.stack1 = []\n    this.stack2 = []\n};\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x)\n};\nMyQueue.prototype.pop = function() {\n    if (!this.stack2.length) {\n        while(this.stack1.length) {\n            const i = this.stack1.pop()\n            this.stack2.push(i)\n        }\n    }\n    return this.stack2.pop()\n};\nMyQueue.prototype.peek = function() {\n    if (!this.stack2.length) {\n        while(this.stack1.length) {\n            const i = this.stack1.pop()\n            this.stack2.push(i)\n        }\n    }\n    return this.stack2[this.stack2.length - 1]\n};\nMyQueue.prototype.empty = function() {\n    return !this.stack1.length && !this.stack2.length\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190452579","body":"## 题目描述\nhttps://leetcode.cn/problems/max-chunks-to-make-sorted-ii/\n\n## 解题思路\n每块尽可能分小，后一块的数字必须比前一快的数字大，\n因为有重复数字，所以重复数字可以单独分一块，\n因为需要比较前后元素大小，所以联想到单调栈\n\n## 单调递增栈\n\n```javascript\nfor (遍历这个数组)\n{\n\tif (栈空 || 栈顶元素大于等于当前比较元素) {\n\t    入栈;\n\t} else {\n\t    while (栈不为空 && 栈顶元素小于当前元素) {\n                栈顶元素出栈;\n                更新结果;\n\t    }\n\t    当前数据入栈;\n\t}\n}\n```\n\n## 代码\n```javascript\nvar maxChunksToSorted = function(arr) {\n    let stack = []\n    for(let i = 0; i < arr.length; i++) {\n        if (!stack.length || arr[i] >= stack[stack.length - 1]) {\n            stack.push(arr[i])\n        } else {\n            const last = stack.pop()\n            while(stack[stack.length - 1] > arr[i]) {\n                stack.pop()\n            }\n            stack.push(last)\n        }\n    }\n    return stack.length\n};\n```\n\n##复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191633395","body":"## 题目描述\nhttps://leetcode.cn/problems/rotate-list/\n\n## 解题思路\n- 把最后一位移动到第一位 ===> 环形链\n- 假设链表长度为n, 实际移动 m*n 次后，链表不变\n- 移动k次，实际只需移动 k % n 次\n- 找到新链表的最后一个节点断开 第（length - k % n）个节点.next = null\n\n\n## 代码\n```javascript\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n        if (!head || !head.next || !k) {\n            return head\n        }\n        let len = 1\n        let p = head\n        while(p.next) {\n            len++\n            p = p.next\n        }\n        if (k%len === 0) {\n            return head\n        }\n        p.next = head // 形成环形链\n        let index = len - k % len\n        while(index) {\n            p = p.next\n            index--\n        }\n        let head2 = p.next\n        p.next = null\n        return head2\n    };\n```\n\n##复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192680754","body":"## 题目描述\nhttps://leetcode.cn/problems/swap-nodes-in-pairs/\n\n## 解题思路\n- 看似两两交换，实际要用到三个节点\n\n## 代码\n```javascript\nvar swapPairs = function(head) {\n    if(!head || !head.next) {\n        return head\n    }\n    let newHead = new ListNode()\n    newHead.next = head\n    let temp = newHead\n   \n    while(temp.next && temp.next.next) {\n        let p1 = temp.next\n        let p2 = temp.next.next\n        \n        p1.next = p2.next\n        temp.next = p2\n        p2.next = p1\n\n        temp = temp.next.next\n        p1 = temp.next\n    }\n\n  \n    return newHead.next\n};\n```\n\n##复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193138918","body":"## 题目描述\nhttps://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/\n## 解题思路\n- 快慢指针查询链表中间节点\n- 二分递归构造子树\n\n## 代码\n```javascript\nvar sortedListToBST = function trans(head) {\n    const node = {};\n    if (!head) {\n        return null;\n    }\n\n    let slow = head;\n    let fast = head;\n    let last = head;\n\n    while (fast && fast.next) {\n        last = slow;\n        slow = slow.next;\n        fast = fast.next;\n        fast = fast.next;\n    }\n    node.val = slow.val;\n\n    node.left = null;\n\n    if (last !== slow) {\n\n        last.next = null;\n        node.left = trans(head);\n    }\n    node.right = trans(slow.next);\n\n    return node;\n};\n```\n\n## 复杂度\n* 时间复杂度 O(nlogn)\n* 空间复杂度 O(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193344436","body":"## 题目描述\nhttps://leetcode.cn/problems/intersection-of-two-linked-lists/## 解题思路\n## 解题思路\n- 双指针分别遍历 a->b, b->a, 如果相遇则有交点\n\n## 代码\n```javascript\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n        if (!headA || !headB) return null;\n\n        let pA = headA,\n            pB = headB;\n        while (pA !== pB) {\n            pA = pA === null ? headB : pA.next;\n            pB = pB === null ? headA : pB.next;\n        }\n        return pA;\n    };\n```\n\n## 复杂度\n* 时间复杂度 O(m+n)\n* 空间复杂度 O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193831461","body":"## 题目描述\nhttps://leetcode.cn/problems/linked-list-cycle-ii/## 解题思路\n\n## 解法一 哈希表\n\n### 代码\n```javascript\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n        const list = new Set()\n\n        while(head) {\n            if(list.has(head)){\n\n                return head\n            }\n\n            list.add(head)\n            head = head.next\n\n        }\n        return null\n    };\n```\n\n### 复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(n)\n\n## 解法二 双指针\n\n### 解题思路\n- 快慢指针找到相遇点，快指针速度2，慢指针速度1，快指针在环中\n  以速度1追逐慢指针，所以快慢指针一定会相遇\n- 计算相遇点到入环的距离（没想出来看的答案）\n\n### 代码\n```javascript\nvar detectCycle = function(head) {\n    if (head === null) {\n        return null;\n    }\n    let slow = head, fast = head;\n    while (fast !== null) {\n        slow = slow.next;\n        if (fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            return null;\n        }\n        if (fast === slow) {\n            let ptr = head;\n            while (ptr !== slow) {\n                ptr = ptr.next;\n                slow = slow.next;\n            }\n            return ptr;\n        }\n    }\n    return null;\n};\n\n```\n\n### 复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195469342","body":"/**\n * @description 连接两点\n * @param {LinkNode} leftNode\n * @param {LinkNode} rightNode\n */\nfunction connect(leftNode, rightNode) {\n  leftNode.right = rightNode;\n  rightNode.left = leftNode;\n}\n\n/**\n * @description 两点中插入一点\n * @param {LinkNode} leftNode\n * @param {LinkNode} rightNode\n * @param {LinkNode} insertNode\n */\nfunction insert(leftNode, rightNode, insertNode) {\n  leftNode.right = insertNode;\n  rightNode.left = insertNode;\n  insertNode.left = leftNode;\n  insertNode.right = rightNode;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n  this.head = {\n    val: -1,\n    left: null,\n    right: null\n  };\n  this.head.left = this.head.right = this.head;\n  this.array = [];\n  this.capacity = capacity;\n  this.linkLength = 0;\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n  const node = this.array[key];\n  if (node) {\n    if (node.inLinkList) {\n      const head = this.head;\n      connect(node.left, node.right);\n      insert(head, head.right, node);\n      return node.val;\n    } else {\n      this.array[key] = undefined;\n      return -1;\n    }\n  }\n  return -1;\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n  const head = this.head;\n  if (this.array[key] && this.array[key].inLinkList) {\n    // 原来有值的\n    const node = this.array[key];\n    // 更新值\n    node.val = value;\n    // 提到链表头\n    connect(node.left, node.right);\n    insert(head, head.right, node);\n  } else {\n    // 超过长度，去掉最末尾的元素\n    if (this.linkLength === this.capacity) {\n      head.left.inLinkList = false;\n      connect(head.left.left, head);\n      this.linkLength--;\n    }\n    // 原来没值\n    // 生成节点\n    const node = {\n      val: value,\n      left: null,\n      right: null,\n      inLinkList: true\n    };\n    this.array[key] = node;\n    this.linkLength++;\n    insert(head, head.right, node);\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196814892","body":"### 题目描述\nhttps://leetcode.cn/problems/maximum-depth-of-binary-tree/\n### 解题思路\n- 递归DFS\n\n### 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(!root) {\n        return 0\n    }\n    let h1 = 1 + maxDepth(root.left)\n    let h2 = 1 + maxDepth(root.right)\n    return Math.max(h1,h2)\n};\n```\n\n### 复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(height) height为二叉树高度\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185338763","body":"自己用进位遍历的方法没跑出来，待会再想想= =\r\n暂时用  list→str→int 来计算sum 最后再转换回list \r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=int(''.join([str(x)for x in num]))\r\n        sum=n+k\r\n        return list(map(int,str(sum)))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186190071","body":"先找到相同元素的位置，然后分别向左向右遍历找到min最小距离\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=len(s)\r\n        start=[0 if a==c else n for a in s]\r\n        for i in range(1,n):\r\n            start[i]=min(start[i],start[i-1]+1)\r\nfor i in range(n-2,-1,-1):\r\n            start[i]=min(start[i],start[i+1]+1)\r\n        return start","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551571","body":"思路：差分数组\r\n`\r\n\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.nums = []\r\n\r\n    def push(self, x: int) -> None:\r\n      \r\n        if not self.nums:\r\n            self.nums.append(x)\r\n        else:\r\n            self.nums[-1] = self.nums[-1] - x\r\n            self.nums.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.nums:\r\n            return -1\r\n        x = self.nums.pop()\r\n        if self.nums:\r\n            self.nums[-1] += x\r\n        return x\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if not self.nums:\r\n            return\r\n        if len(self.nums) >= k:\r\n            self.nums[k - 1] += val\r\n        else:\r\n            self.nums[-1] += val\r\n\r\n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187667410","body":"利用栈的性质（参考题解 \r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191387810","body":"思路：双指针遍历\r\n``\r\n\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        len=0\r\n        tail=head\r\n        while tail:\r\n            len+=1\r\n            tail=tail.next //求链表长度\r\n        k %=len \r\n        if k==0:\r\n            return head\r\n        fast,slow=head,head 双指针遍历\r\n        while k:\r\n            fast=fast.next\r\n            k-=1  //fast与slow距离k\r\n        while fast.next:\r\n            fast=fast.next\r\n            slow=slow.next \r\n        newHead=slow.next //新节点\r\n        slow.next=None 指向尾端\r\n        fast.next=head\r\n        return newHead``","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192654637","body":"> 思路：利用迭代\r\n\r\n`\r\n   \r\n      def swapPairs(self, head):\r\n             p=ListNode(-1)\r\n             a,b,p.next,tmp=p,p,head,p //初始化\r\n             while b.next and b.next.next:\r\n                 a,b=a.next,b.next.next  //进位\r\n                 tmp.next,a.next,b.next=b,b.next,a //a,b 交换 \r\n                 tmp,b=a,a\r\n             return p.next`\r\n\r\n> 时间复杂度：O(n)\r\n\r\n> 空间复杂度：O(1)`","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195074679","body":"不太会，参考题解\r\n思路：双向链表＋哈希表实现-\r\n`\r\nclass ListNode:\r\n    def __init__(self, key = 0, val = 0):\r\n        self.key = key\r\n        self.val = val\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n    \r\n    def remove_node(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n    \r\n    def add_node_to_last(self, node):\r\n        self.tail.prev.next = node\r\n        node.prev = self.tail.prev\r\n        node.next = self.tail\r\n        self.tail.prev = node\r\n    \r\n    def move_node_to_last(self, node):\r\n        self.remove_node(node)\r\n        self.add_node_to_last(node)\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.hashmap:\r\n            return -1\r\n        node = self.hashmap[key]\r\n        self.move_node_to_last(node)\r\n        return node.val\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            node = self.hashmap[key]\r\n            node.val = value\r\n            self.move_node_to_last(node)\r\n            return\r\n        if len(self.hashmap) == self.capacity:\r\n            del self.hashmap[self.head.next.key]\r\n            self.remove_node(self.head.next)\r\n        node = ListNode(key, value)\r\n        self.hashmap[key] = node\r\n        self.add_node_to_last(node)\r\n\r\n`\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196404079","body":"刚开始学二叉树，感受到了递归的强大\r\n`\r\n\r\n    def maxDepth(self, root):\r\n        if root is None: \r\n            return 0 \r\n        else: \r\n            left_height = self.maxDepth(root.left) \r\n            right_height = self.maxDepth(root.right) \r\n            return max(left_height, right_height) + 1 \r\n`\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185356088","body":"## 思路\r\n\r\n0 <= K <= 10000，可直接加 1，不需要大数相加\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar addToArrayForm = function (num, K) {\r\n    const len = num.length || 0;\r\n    let numK = K;\r\n    const result = [];\r\n\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        const a = num[i];\r\n        const b = numK % 10;\r\n       \r\n        let total = a + b;\r\n        numK = total >= 10 ? parseInt(numK / 10) + 1 : parseInt(numK / 10);\r\n        result[i] = total % 10;\r\n    }\r\n    while (numK > 0) {\r\n        result.unshift(numK % 10);\r\n        numK = parseInt(numK / 10);\r\n    }\r\n\r\n    return result;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186194360","body":"## 思路\r\n\r\n从左向右遍历，记录字符右侧的距离；从右向左遍历，获取字符左侧的距离和之前距离的较小值。\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  const tempArr = [];\r\n  const len = s.length;\r\n  let idx = -1;\r\n  for (let i = 0; i < len; i++) {\r\n    if (s[i] === c) {\r\n      idx = i;\r\n      tempArr[i] = 0;\r\n    } else if (idx === -1) {\r\n      tempArr[i] = Infinity;\r\n    } else {\r\n      tempArr[i] = i - idx;\r\n    }\r\n  }\r\n\r\n  idx = Infinity;\r\n  for (let i = len - 1; i > -1; i--) {\r\n    const val = tempArr[i];\r\n\r\n    if (s[i] === c) {\r\n      idx = i;\r\n    } else if (val > idx - i) {\r\n      tempArr[i] = idx - i ;\r\n    }\r\n  }\r\n\r\n  return tempArr;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186497063","body":"## 思路\r\n\r\n数据模拟栈。\r\n\r\n## 代码 js\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n  this.stack = [];\r\n  this.size = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length < this.size) {\r\n    this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if (this.stack.length === 0) {\r\n    return -1;\r\n  } else {    \r\n    return this.stack.pop();\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  const len = k > this.stack.length ? this.stack.length : k;\r\n  for (let i = 0; i < len; i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度:  push, pop = O(1), increment = O(min(k, length))\r\n- 空间复杂度:  O(maxSize)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187015228","body":"## 思路 \r\n\r\n字符入栈，遇到 `]` 出栈\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar decodeString = function(s) {\r\n    const stack = [];\r\n\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] !== ']') {\r\n            stack.push(s[i]);\r\n        } else {\r\n            let result = \"\";\r\n            let tempStr = \"\";\r\n            let num = \"\";\r\n            while (stack[stack.length - 1] !== '[') {\r\n                const c = stack.pop();\r\n                tempStr = c + tempStr;\r\n            }\r\n            stack.pop();\r\n            while (/\\d/.test(stack[stack.length - 1]) && stack.length >= 0) {\r\n                const n = stack.pop();\r\n                num = n + num;\r\n            }\r\n            \r\n            for (let i = 0; i < +num; i++) {\r\n                result += tempStr;\r\n            }\r\n\r\n            for (let j = 0; j < result.length; j++) {\r\n                stack.push(result[j]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    return stack.join(\"\");\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度 O(n)， n 为解码后的字符串长度\r\n- 空间复杂度 O(n)， n 为解码后的字符串长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188548383","body":"## 思路\r\n\r\n用两个栈模拟队列\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    const temStack = [];\r\n    const len = this.stack.length;\r\n    for (let i = 0; i < len; i++) {\r\n        temStack.push(this.stack.pop());\r\n    }\r\n    const res = temStack.pop();\r\n    const len2 = temStack.length;\r\n    for (let j = 0; j < len2; j++) {\r\n        this.stack.push(temStack.pop());\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    const temStack = [];\r\n    const len = this.stack.length;\r\n    for (let i = 0; i < len; i++) {\r\n        temStack.push(this.stack.pop());\r\n    }\r\n    const res = temStack[len - 1];\r\n    for (let j = 0; j < len; j++) {\r\n        this.stack.push(temStack.pop());\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0;\r\n};\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190345234","body":"## 思路\r\n\r\n使用单调栈，遇到大于等于栈顶元素直接加入栈。\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const lastMax = stack[stack.length - 1];\r\n    if (i === 0) {\r\n      stack.push(arr[i]);\r\n    } else if (arr[i] >= stack[stack.length - 1]) {\r\n      stack.push(arr[i]);\r\n    } else {\r\n      while (arr[i] < stack[stack.length - 1] && stack.length) {\r\n        stack.pop()\r\n      }\r\n      stack.push(lastMax)\r\n    }\r\n  }\r\n  return stack.length;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191111224","body":"## 思路\r\n\r\n先拿到长度，通过旋转值计算出需要截断的部分。\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar rotateRight = function (head, k) {\r\n  if (!(head && head.next)) return head;\r\n  if (k === 0) return head;\r\n  let node = head;\r\n  const node4 = head;\r\n  let len = 1;\r\n  while (node.next) {\r\n    len++;\r\n    node = node.next\r\n  }\r\n\r\n    let newLen = k % len === 0 ? 0 : Math.abs(len - k % len);\r\n  if (newLen === 0) return node4;\r\n  while (newLen > 1) {\r\n    newLen--;\r\n    head = head.next;\r\n  }\r\n\r\n  let node3 = head.next;\r\n  head.next = null;\r\n  const node5 = node3;\r\n\r\n  while (node3 && node3.next) {\r\n    node3 = node3.next;\r\n  }\r\n  if (node3) {\r\n    node3.next = node4;\r\n  }\r\n \r\n  return node5;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度: O(n)\r\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192669066","body":"## 代码 js\r\n\r\n```js\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) {\r\n        return head\r\n    }\r\n    let prev = head.next\r\n    let next = head\r\n    let tmp = prev.next\r\n    head = head.next\r\n    while (next.next) {\r\n        prev.next = next\r\n        next.next = tmp ? (tmp.next || tmp) : null\r\n        if (tmp) {\r\n            prev = tmp.next\r\n            next = tmp\r\n            tmp = prev ? prev.next : null\r\n        }\r\n    }\r\n    return head\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141212","body":"## 思路 \r\n\r\n递归寻找中间节点作为根节点。\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  if (head && !head.next) {\r\n    return new TreeNode(head.val);\r\n  }\r\n\r\n\r\n  function buildTree(head, tail) {\r\n    if (head === tail) return null;\r\n    const mid = findMid(head, tail);\r\n   \r\n    const topNode = new TreeNode(mid.val);\r\n    topNode.left = buildTree(head, mid);;\r\n    topNode.right = buildTree(mid.next, tail);;\r\n    return topNode;\r\n  }\r\n\r\n  function findMid(head, tail) {\r\n    let slow = head;\r\n    let fast = head;\r\n  \r\n    while (fast !== tail && fast.next !== tail) {\r\n      slow = slow.next;\r\n      fast = fast.next.next;\r\n    }\r\n\r\n    return slow;\r\n  }\r\n\r\n  return buildTree(head, null);\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度： O(NlogN)\r\n- 空间复杂度： O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193322360","body":"## 思路\r\n\r\nA 链表遍历完后遍历 B 链表，B 链表遍历完后遍历 A 链表，有相同的节点即为重复节点\r\n\r\n## 代码\r\n\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let node1 = headA, node2 = headB;\r\n    while (node1 != node2) {\r\n        node1 = node1 ? node1.next : headB;\r\n        node2 = node2 ? node2.next : headA;\r\n    }\r\n    return node1;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(n) n 为 两链表长度之和\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193966691","body":"## 代码 js\r\n\r\n```js\r\nvar detectCycle = function(head) {\r\n    let slow = fast = head\r\n    while(fast !== null && fast.next !== null) {\r\n        slow = slow.next\r\n        fast = fast.next.next\r\n        if (slow === fast) {\r\n            break\r\n        }\r\n    }\r\n    if (fast == null || fast.next == null) {\r\n        return null\r\n    }\r\n    slow = head\r\n    while(slow !== fast) {\r\n        slow = slow.next\r\n        fast = fast.next\r\n    }\r\n    return slow\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195363707","body":"## 思路\r\n\r\njs 可以直接用 map 来实现这个功能\r\n\r\n## 代码 js\r\n\r\n```js\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n  this.map = new Map();\r\n  this.size = capacity;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    let val = this.map.get(key)\r\n    if (val !== undefined) {\r\n        this.map.delete(key)\r\n        this.map.set(key, val);\r\n        return val\r\n    }\r\n    \r\n     return -1;\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    if (this.map.has(key)) {\r\n        this.map.delete(key);\r\n    } else if (this.map.size >= this.size) {\r\n        const k = this.map.keys().next().value;\r\n        this.map.delete(k);\r\n    }\r\n  \r\n    this.map.set(key, value);\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度： O(1)\r\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196296575","body":"## 思路\r\n\r\n递归获取子树高度，取左边右边最大值\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar maxDepth = function(root) {\r\n    if (root) {\r\n        const lefttLen = maxDepth(root.left) || 0;\r\n        const rightLen = maxDepth(root.right) || 0;\r\n        return lefttLen > rightLen ? lefttLen + 1 : rightLen + 1;\r\n    } else return 0;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(h)  h为树的高度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185362278","body":"思路:想把数组直接转成int，然后用加法加完了，再转换回来，但是貌似不是题目要的\r\ncode：\r\n`\r\n  #!/usr/bin/env python\r\n  \"\"\"add\"\"\"\r\n  \r\n  import os\r\n  from os import sys, path\r\n  \r\n  class Add(object):\r\n  \r\n      def list2str(self, inlist):\r\n          outstr = \"\"\r\n          for i in inlist:\r\n              outstri = ''.join(str(i))\r\n              outstr = outstr + outstri\r\n          return outstr\r\n\r\n      def add(self, x, k):\r\n          str_x = self.list2str(x)\r\n          str_k = self.list2str(k)\r\n          addint = int(str_x) + int(str_k)\r\n          return addint\r\n\r\n      def str2list(self, instr):\r\n          outlist = list(instr)\r\n          return outlist\r\n\r\n      def main(self, x, k):\r\n          addint = self.add(x, k)\r\n          outlist = self.str2list(str(addint))\r\n          print outlist\r\n\r\n  if __name__ == '__main__':\r\n      x = [1,1,0,0]\r\n      k = [3,4]\r\n      r = Add()\r\n      r.main(x,k)\r\n\r\n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186216992","body":"## 思路\r\n  学习官方解题方式\r\n##代码\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1, n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n - 2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186547277","body":"## 思路\r\n学习栈\r\n\r\n##代码\r\n\r\n```python\r\n    def __init__(self, size: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = size\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(self.cnt, k)):\r\n            self.st[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187661561","body":"## 思路\n学习官方解决\n\n##代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n                # pop 掉 \"[\"\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190463845","body":"## 思路\r\n官方学习\r\n```python\r\n    def maxChunksToSorted(self, arr):\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        ans = 0\r\n\r\n        for a, b in zip(arr, sorted(arr)):\r\n            count_a[a] += 1\r\n            count_b[b] += 1\r\n            if count_a == count_b: ans += 1\r\n\r\n        return ans\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191566717","body":"## 思路\n学习官方\n\n##代码\n\n```python\n   if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n\n```     \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192709956","body":"## 思路\r\n继续学习官方\r\n\r\n## 代码\r\n```\r\nif not head or not head.next: return head\r\n    ans = ListNode()\r\n    ans.next = head.next\r\n    pre = ans\r\n    while head and head.next:\r\n        next = head.next\r\n        n_next = next.next\r\n        next.next = head\r\n        pre.next = next\r\n        head.next = n_next\r\n        pre = head\r\n        head = n_next\r\n    return ans.next\r\n```\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196944733","body":"## 思路\n```python\n def maxDepth(self, root: TreeNode) -> int:\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n```  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185368348","body":"解题思路\n\n- 整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n  例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n解题代码\n\n    int* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n        int ksize = 0;//预设k的位数为0\n        int ktmp = k;\n        while(ktmp)      //得到k的位数\n        {\n            ksize++;\n            ktmp /= 10;\n        }\n        int size = numSize > ksize ? numSize + 1 : ksize + 1;   //开辟一个多+1位置的数组，防止有进位\n    \n        int* a = (int*)malloc(size*sizeof(int));\n    \n        int end = numSize - 1;//创建一个下标指向num数组的最后一个元素 \n        int carry = 0;\n        int i = 0;\n        while(end >= 0 || k > 0)   //2个有1个没有遍历完\n        {\n            if(end >= 0)\n            {\n                a[i] = carry + num[end] + k % 10;\n            }//num[end]为数组的最后一个元素 k%10 为k的最后一位\n            else\n            {\n                a[i] = carry + k % 10;\n            }\n    \n            if(a[i] >= 10)\n            {\n                a[i] = a[i] - 10;\n                carry = 1;//有进位\n            }\n            else\n            {\n                carry = 0;//carry=1表示进位为，0表示不进位\n            }\n            k /= 10;\n            end--;\n            i++;\n        }\n        if(carry == 1)\n        {\n            a[i++] = 1;\n        }\n    \n        int left = 0;\n        int right = i - 1;\n        while(left < right)\n        {\n            int tmp = a[left];\n            a[left] = a[right];\n            a[right] = tmp;\n            left++;\n            right--;\n        }//数组逆序\n    \n        *returnSize = i;\n        return a;\n    \n    }\n\n时间复杂度\n\nO（n^2)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186159638","body":"### 题目描述\n\n````\n```\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\n\n示例 1:\n\n输入: S = \"loveleetcode\", C = 'e'\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\n说明:\n\n- 字符串 S 的长度范围为 [1, 10000]。\n- C 是一个单字符，且保证是字符串 S 里的字符。\n- S 和 C 中的所有字母均为小写字母。\n\n```\n````\n\n### 解题思路\n\n1. 从左到右遍历i，找出下标i到离它左侧最近的字符c的距离\n2. 从右到左遍历i，找出下标i到离它右侧最近的字符c的距离\n3. 比较1和2得出最短距离。找到速度最快的距离\n\n### 解题代码\n\n```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint *shortestToChar(char *s, char c, int *returnSize)\n{\n    int i, index;\n    int len = strlen(s);\n    int *p = (int *)malloc(len * sizeof(int));\n    if (p == NULL) {\n        return NULL;\n    }\n    memset(p, 0, len * sizeof(int));\n\n    // 从左到右遍历i，找出下标i到离它左侧最近的字符c的距离\n    index = -len; // 初始为-len，第一次遍历时，可能没有找到\n    for (i = 0; i < len; i++) {\n        if (s[i] == c) {\n            index = i; // 更新index\n        }\n        p[i] = i - index; // 求出距离\n    }\n\n    // 从右到左遍历i，找出下标i到离它右侧最近的字符c的距离\n    index = 2 * len; // 初始为2*len，第一次遍历时，可能没有找到\n    for (i = len - 1; i >= 0; i--) {\n        if (s[i] == c) {\n            index = i; // 更新index\n        }\n        p[i] = fmin(p[i], index - i); // 求出距离，并比较得出最短距离\n    }\n\n    *returnSize = len;\n    return p;\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186496698","body":"### 题目思路\n\n1、正常建立一个数组，记录当前的index和最大值，维护一个栈，如果需要统一加一个值，就直接for循环遍历\n2、正常建立两个数组，第一个数组用来存当前的入栈元素，第二个数组用来存当前index及小于该index值的元素需要加的数\ntypedef struct {\n    int maxnum;\n    int curInex;\n    int *arry;\n    int *increment;\n} CustomStack;\n\n\nCustomStack* customStackCreate(int maxSize) {\n    CustomStack *stacktmp = (CustomStack *)malloc(sizeof(CustomStack));\n    stacktmp->maxnum = maxSize;\n    stacktmp->curInex = 0;\n    stacktmp->arry = (int *)malloc(sizeof(int) * maxSize);\n    stacktmp->increment = (int *)malloc(sizeof(int) * maxSize);\n    memset(stacktmp->arry, 0, sizeof(int) * maxSize);\n    memset(stacktmp->increment, 0, sizeof(int) * maxSize);\n    return stacktmp;\n}\n\nvoid customStackPush(CustomStack* obj, int x) {\n    if ((obj == NULL) || (obj->curInex == obj->maxnum)) {\n        return;\n    }\n    obj->arry[obj->curInex] = x;\n    obj->curInex++;\n}\n// 3 100\nint customStackPop(CustomStack* obj) {\n    if ((obj == NULL) || (obj->curInex == 0)) {\n        return -1;\n    }\n    obj->curInex--;\n    int returnNum = obj->arry[obj->curInex] + obj->increment[obj->curInex];\n    if (obj->curInex) {\n        obj->increment[obj->curInex - 1] += obj->increment[obj->curInex];\n    }\n    obj->increment[obj->curInex] = 0;\n    return returnNum;\n}\n// 1,2,3 100 k = 3 num - 1 = 2\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\n    if (obj == NULL || obj->curInex == 0) {\n        return;\n    }\n    int num = k < obj->curInex ? k : obj->curInex;\n    obj->increment[num - 1] += val;\n}\n\nvoid customStackFree(CustomStack* obj) {\n    free(obj->arry);\n    free(obj);\n}\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189746866","body":"int maxChunksToSorted(int *arr, int arrSize)\n{\n    /* 初始化循环变量x从数组右边开始往左，t为无穷大。 */\n    int x = arrSize - 1, t = INT_MAX, result = 0;\n    int rightMin[arrSize];\n\n    /* 先计算每个arr[x]右边的最小值，不包括arr[x]在内。 */\n    while(0 <= x)\n    {\n        rightMin[x] = t;\n        if(t > arr[x])\n        {\n            t = arr[x];\n        }\n        x--;\n    }\n\n    /* 然后从左往右再遍历一次。此时，t的含义变为，[0,x]范围内的最大值，初始化为arr[0]。 */\n    t = arr[0];\n    x = 0;\n    while(arrSize > x)\n    {\n        if(t < arr[x])\n        {\n            t = arr[x];\n        }\n        /* 当发现当前为止的最大值，不大于rightMin[x]时，即可切一刀。 */\n        if(t <= rightMin[x])\n        {\n            result++;\n        }\n        x++;\n    }\n\n    return result;\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185371267","body":"## Idea\r\niterate through the num array, add each digit to k , add the rightmost digit into the result list\r\n## Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int len = num.length;\r\n        for (int i = len-1; i >= 0; i--) {\r\n            k += num[i];\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        while (k > 0) {\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185991579","body":"##  Idea\r\nIterate from left to right, and then iterate from right to left\r\n## Code\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] str = s.toCharArray();\r\n        int n = str.length;\r\n        int[] res = new int[n];\r\n        Arrays.fill(res, Integer.MAX_VALUE);\r\n        for (int i = 0; i < n; i++) {\r\n            if (str[i] == c) {\r\n                res[i] = 0;\r\n            }\r\n            if (i < n-1 && res[i] != Integer.MAX_VALUE) {\r\n               res[i+1] = Math.min(res[i]+1, res[i+1]); \r\n            }\r\n        }\r\n        for (int i = n-1; i > 0; i-- ) {\r\n            if (res[i] != Integer.MAX_VALUE) {\r\n                res[i-1] = Math.min(res[i-1], res[i]+1);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n## Complexity\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186350565","body":"## Idea\r\nImplement with an array and keep track of current position. For increment, use an offset array and an int instead of incrementing all bottom k elements.\r\n## Code\r\n```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int[] offset;\r\n    int cur;\r\n    int diff;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        offset = new int[maxSize];\r\n        cur = 0;\r\n        diff = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (cur == stack.length) return;\r\n        if (cur > 0) {\r\n            offset[cur-1] += diff;\r\n        }\r\n        diff = 0;\r\n        stack[cur] = x;\r\n        offset[cur] = 0;\r\n        cur++;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (cur == 0) return -1;\r\n        int res = stack[cur-1];\r\n        diff += offset[cur-1];\r\n        cur--;\r\n        return res+diff;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if (cur == 0) return;\r\n        int min = Math.min(k , cur);\r\n        offset[min-1] += val;\r\n    }\r\n    \r\n}\r\n```\r\n## Complexity\r\nTime: push O(1) , pop O(1), increment O(1)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186912390","body":"## Idea\ntwo stacks, one for number of repetition and one for the string\n## Code\n```\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> s1 = new Stack<>();\n        Stack<String> s2 = new Stack<>();\n        char[] str = s.toCharArray();\n        String res = \"\";\n        for (int i = 0; i < str.length; i++) {\n            if (str[i] >= '0' && str[i] <= '9') {\n                int num = 0;\n                while (str[i] >= '0' && str[i] <= '9') {\n                    num = num * 10 + (str[i] - '0');\n                    i++;\n                }\n                s1.push(num);\n                i--;\n            }\n            else if (str[i] == '[') {\n                s2.push(res);\n                res = \"\";\n            }\n            else if (str[i] == ']') {\n                int num = s1.pop();\n                StringBuilder sb = new StringBuilder(s2.pop());\n                for (int j = 0; j < num; j++) {\n                    sb.append(res);\n                }\n                res = sb.toString();\n            }\n            else {\n                res += str[i];\n            }\n        }\n        return res;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188375666","body":"## Idea\r\nuse the second stack to retrieve the top element\r\n## Code\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    \r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n) for pop, peek and empty, O(1) for push\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189985198","body":"## Idea\nuse a monotonically increasing stack and store the max element for each chunk, return the size of chunk.\n\n## Code\n```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        Stack<Integer> stack = new Stack<>();\n        int curMax = 0;\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[i] < stack.peek()) {\n                stack.pop();\n            }\n            curMax = Math.max(curMax, arr[i]);\n            stack.push(curMax);\n        }\n        return stack.size();\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191091660","body":"## Idea\r\ntreat k as k mod len and rotate the linkedlist\r\n## Code\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return head;\r\n        ListNode cur = head, tail = head;\r\n        int len = 1;\r\n        while (cur.next != null) {\r\n            cur = cur.next;\r\n            len++;\r\n        }\r\n        cur.next = head;\r\n        k = k % len;\r\n        for (int i = 0; i < len - k - 1; i++) {\r\n            tail = tail.next;\r\n        }\r\n        cur = tail.next;\r\n        tail.next = null;\r\n        return cur;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192691221","body":"## Idea\niterate through the list and swap the value\n## Code\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null) return head;\n        ListNode cur = head;\n        ListNode res = head;\n        int counter = 0;\n        while (cur != null && cur.next != null) {\n            ListNode tmp = cur.next;\n            ListNode next = tmp.next;\n            \n            if (counter == 0) {\n                res = tmp;\n            }\n            \n            tmp.next = cur;\n            if (next == null) {\n                cur.next = next;\n            }\n            else {\n                if (next.next != null) {\n                    cur.next = next.next;\n                }\n                else {\n                    cur.next = next;\n                }\n            }\n            \n            cur = next;\n            counter++;\n        }\n        return res;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193131950","body":"## Idea\nIn-order traversal and use fast slow pointer to find the middle of the linked list\n## Code\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode prev = null;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        if (prev != null) {\n            prev.next = null;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        if (slow != head) {\n            root.left = sortedListToBST(head);\n        }\n        else {\n            root.left = null;\n        }\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }\n}\n```\n## Complexity\nTime: O(nlogn)\nSpace: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193284901","body":"## Idea\nGet the difference of the length of two linkedlist. Move two pointers to the position where the remaining number of nodes of two linkedlist are equal.\n\n## Code\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        ListNode cur1 = headA;\n        int lenA = 1, lenB = 1;\n        while (cur1 != null) {\n            cur1 = cur1.next;\n            lenA++;\n        }\n        cur1 = headB;\n        while (cur1 != null) {\n            cur1 = cur1.next;\n            lenB++;\n        }\n        \n        int diff = Math.abs(lenA - lenB);\n        ListNode cur2 = null;\n        if (lenA > lenB) {\n            cur1 = headA;\n            cur2 = headB;\n        }\n        else {\n            cur1 = headB;\n            cur2 = headA;\n        }\n        for (int i = 0; i < diff; i++) {\n            cur1 = cur1.next;\n        }\n        while (cur1 != null) {\n            if (cur1 == cur2) return cur1;\n            cur1 = cur1.next;\n            cur2 = cur2.next;\n        }\n        return null;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193789143","body":"## Idea\nfast and slow pointer\n## Code\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (true) {\n            if (slow == null) return null;\n            if (fast == null || fast.next == null) return null;\n            slow = slow.next;\n            fast = fast.next.next;\n            if (fast == slow) break;\n        }\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195378715","body":"## Idea\nUse a map and a doubly linked list to store the keys and values.\n\n## Code\n```\nclass LRUCache {\n    public Map<Integer, Node> cache;\n    public int capacity;\n    public Node head, tail;\n    \n    class Node {\n        public int key;\n        public int val;\n        public Node prev;\n        public Node next;\n        \n        public Node(){};\n        public Node(int k, int v, Node p, Node n) {\n            this.key = k;\n            this.val = v;\n            this.prev = p;\n            this.next = n;\n        }\n    }\n        \n    public LRUCache(int capacity) {\n        this.cache = new HashMap<>();\n        this.capacity = capacity;\n        this.head = new Node();\n        this.tail = new Node();\n        head.prev = null;\n        head.next = tail;\n        tail.prev = head;\n        tail.next = null;\n    }\n    \n    public int get(int key) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key); \n            moveToTail(node);\n            return node.val;\n        }\n        else {\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key);\n            node.val = value;\n            moveToTail(node);\n            return;\n        }\n        Node node = new Node();\n        node.key = key;\n        node.val = value;\n        cache.put(key, node);\n        addNode(node);\n        int size = cache.size();\n        \n        if (size > capacity) {\n            Node toRemove = head.next;\n            removeNode(toRemove);\n            cache.remove(toRemove.key, toRemove);\n        }\n    }\n\n    private void addNode(Node node) {\n        Node tmp = tail.prev;\n        tmp.next = node;\n        node.prev = tmp;\n        node.next = tail;\n        tail.prev = node;\n    }\n\n    private void removeNode(Node node) {\n        Node p = node.prev;\n        Node n = node.next;\n        p.next = n;\n        n.prev = p;\n    }\n\n    public void moveToTail(Node node) {\n        removeNode(node);\n        addNode(node);\n    }\n}\n```\n## Time Complexity\nTime: O(1) for get() and put()\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196596722","body":"## Idea\nrecursion\n## Code\n```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185386008","body":"## Code\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    int n = num.size();\n    int count = n-1;\n    vector<int> res;\n    // 因为可能不是相同位数操作，所以要确保每一位都参加运算\n    while(count >= 0 || k != 0) {\n        // 对k进行操作比较方便，进行加法运行时会遵循加减法原则\n        if(count >= 0) {\n            k += num[count];\n            count--;\n        }\n        res.insert(res.begin(), k%10);\n        k /= 10;\n    }\n    return res;\n}\n```\n## 复杂度\n- 时间复杂度：O(n) \n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186052432","body":"## 思路\n正向遍历，给字符c右边的字符赋值距离，遇到另一个字符c停止；反向遍历，计算距离，同样遇到另一个字符c停止，距离取最小值\n## Code\n```c++\nvector<int> shortestToChar(string s, char c) {\n    int n = s.size();\n    vector<int> res;\n    for(int i = 0; i < n; i++) res.push_back(100001);\n    // 正向遍历\n    for(int i = 0; i < n; i++) {\n        if(s[i] == c) {\n            res[i] = 0;\n            for(int j = i + 1; j < n; j++) {\n                if(s[j] != c) res[j] = j - i;\n                else break; \n            }\n        }\n    }\n    // 反向遍历\n    for(int i = n - 1; i >= 0; i--) {\n        if(s[i] == c) {\n            for(int j = i - 1; j >= 0; j--) {\n                if(s[j] != c) {\n                    int dis = i - j;\n                    if(res[j] > dis) res[j] = dis;\n                } \n                else break;\n            }\n        }\n    }\n    return res;\n}\n```\n## 复杂度\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186546066","body":"## Code\nclass CustomStack {\npublic:\n    int maxSize;\n    int a[1001];\n    int count;\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;\n        this->count = 0;\n    }\n    \n    void push(int x) {\n        if(count < maxSize) {\n            a[count++] = x;\n        } else {\n            return;\n        }\n    }\n    \n    int pop() {\n        if(count > 0) {\n            int res = a[count-1];\n            count--;\n            return res;\n        }  \n        else {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < count && i < k; i++) {\n            a[i]+=val;\n        }\n    }\n};\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186724001","body":"## 思路\n利用栈先进后出的特性，进行括号匹配，将生成的字符一并压入栈中进行处理\n## Code \n```c++\nint power(int x, int k) {\n    int pow = 1;\n    for(int i = 0; i < k; i++) {\n        pow *= 10;\n    }\n    return x * pow;\n}\n\nstring decodeString(string s) {\n    stack <char> stk;\n    int n = s.size();\n    bool isNum =true;\n    string s1 = \"\";\n    int i = 1;\n    stk.push(s[0]);\n    while(!stk.empty() && i < n) {\n        if (s[i] == ']') {\n            isNum = true;\n            // 重复的字符\n            while(stk.top() != '[') {\n                char c = stk.top();\n                stk.pop();\n                s1.insert(0, 1, c);\n            }\n            // 弹出左括号\n            stk.pop();\n            // 重复的次数\n            int count = 0, pow = 0;\n            while(!stk.empty() && stk.top() - '0' <= 9 && stk.top() - '0' >= 0) {\n                count += power(stk.top()-'0', pow);\n                pow++;\n                stk.pop();\n            }\n            // 重复压入栈中\n            while(count > 0) {\n                for(int i = 0; i < s1.size(); i++) {\n                    stk.push(s1[i]);\n                }\n                count--;\n            }\n            s1 = \"\";\n        }\n        else if(isNum && s[i] != '[') {\n            stk.push(s[i]);\n        } \n        else if (s[i] == '[') {\n            stk.push(s[i]);\n            isNum = false;\n        }\n        else{\n            stk.push(s[i]);\n        }\n        i++;\n    }\n\n    string res;\n    while(!stk.empty()) {\n        res.insert(0, 1, stk.top());\n        stk.pop();\n    }\n    return res;\n}\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189038312","body":"## 思路\n使用两个单调栈，利用两个栈进行元素的逆置，达到输出队首的目的\n## Code\n```c++\nclass MyQueue {\npublic:\n    stack<int> stk;\n    stack<int> temp;\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        stk.push(x);\n    }\n    \n    int pop() {\n        if(stk.empty()) return -1;\n        int n = stk.size();\n        for(int i = 0; i < n; i++) {\n            temp.push(stk.top());\n            stk.pop();\n        }\n        int res = temp.top();\n        temp.pop();\n        for(int i = 0; i < n - 1; i++) {\n            stk.push(temp.top());\n            temp.pop();\n        }\n        return res;\n    }\n    \n    int peek() {\n        if(stk.empty()) return -1;\n        int n = stk.size();\n        for(int i = 0; i < n; i++) {\n            temp.push(stk.top());\n            stk.pop();\n        }\n        int res = temp.top();\n        for(int i = 0; i < n; i++) {\n            stk.push(temp.top());\n            temp.pop();\n        }\n        return res;\n    }\n    \n    bool empty() {\n        if(stk.empty()) return true;\n        return false;\n    }\n};\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189740812","body":"## 思路\n利用分组排序与原数据排序的特点，寻找每一个分组的分界点（分组的最大值），利用单调栈进行计数，存入每个分组的最大值。\n## Code\n```c++\nint maxChunksToSorted2(vector<int>& arr) {\n    stack<int> stk;\n    stk.push(arr[0]);\n    for(int i = 1; i < arr.size(); i++) {\n        // 当前的数大于前面最大值的时候，可以建立一个新的分组\n        if(arr[i] >= stk.top()) {\n            stk.push(arr[i]);\n        } \n        // 当前的数小于前面最大值的时候，可以与前面大于当前值的数值组成一个分组\n        else {\n            int temp = stk.top();\n            stk.pop();\n            while(!stk.empty() && arr[i] < stk.top()) {\n                stk.pop();\n            }\n            stk.push(temp);\n        }\n    }\n    return stk.size();\n}\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191494430","body":"## Code\n```c++\nListNode* rotateRight(ListNode* head, int k) {\n    if(head == NULL) return NULL;\n    ListNode* tmp = head;\n    int num = 0;\n    ListNode* tmp1 = head;\n\n    // 得到链表的长度\n    while(tmp1 != NULL) {\n        num++;\n        tmp1 = tmp1->next;\n    }\n    k = k % num;\n    if(num == 1 || k == 0) return head;\n    ListNode tmp2;\n    int count = num - k;\n    while(count >= 1 &&head!=NULL) {\n        if(count == 1) {\n            tmp2.next = head->next;\n            head->next = NULL;\n            break;\n        }\n        head = head->next;\n        count--;\n    }\n    ListNode* tmp3 = tmp2.next;\n    while(tmp3 != NULL && tmp3->next != NULL) {\n        tmp3 = tmp3->next;\n    }\n    tmp3->next = tmp;\n    return tmp2.next;\n}\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192111329","body":"## 思路\n忘记加上一个dummy结点，让第一步的操作跟后面一致，写的复杂了\n## Code\n```c++\nListNode* swapPairs(ListNode* head) {\n    if(head == NULL) return NULL;\n\n    ListNode* temp = head;\n    ListNode* swap = new ListNode();\n    int count = 0;\n    while(temp != NULL && temp->next != NULL) {\n        if(count == 0) {\n            swap = temp->next;\n            temp->next = temp->next->next;\n            swap->next = temp;\n            head = swap;\n            count++;\n        }\n        else {\n            swap = temp->next;\n            if(swap->next != NULL) {\n                temp->next = swap->next;\n                swap->next = swap->next->next;\n                temp->next->next = swap;\n                temp = swap;\n            } else break;\n        }\n\n    }\n    return head;\n}\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141385","body":"## 思路\n保证当前结点的左右子树为二叉平衡树，以当前结点为根节点的树也为二叉平衡树，可以寻找当前块的中位值作为根节点，递归进行处理\n## Code\n```c++\nTreeNode* BST(ListNode* head, int left, int right) {\n    if(left < 0 || left > right) return NULL;\n    int mid = left + (right - left + 1) / 2; // 中位值的位置\n    ListNode* tmp1 = head;\n    int count = 1;\n    while(count != mid) {\n        tmp1 = tmp1->next;\n        count++;\n    }\n    TreeNode* res = new TreeNode(tmp1->val); // 中位值\n    res->left = BST(head, left, mid-1);\n    res->right = BST(head, mid+1, right);\n    return res;\n}\n\nTreeNode* sortedListToBST(ListNode* head) {\n    if(head == NULL) return NULL;\n\n    // 获取当前链表的长度\n    int len = 0;\n    ListNode* tmp = head;\n    while(tmp != NULL) {\n        len++;\n        tmp = tmp->next;\n    }\n    TreeNode* res = BST(head, 1, len);\n    return res;\n}\n```\n## 复杂度\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193234090","body":"## Code\n```c++\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    if(headA == NULL ||headB == NULL) return NULL;\n    ListNode* a = headA;\n    ListNode* b = headB;\n    while(a != b) {\n        a= a->next; \n        b= b->next;\n        if(a == NULL && b == NULL) return NULL;\n        if(a == NULL) a = headB;\n        if(b == NULL) b = headA;\n    }\n    return a;\n}\n```\n## 复杂度\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194208732","body":"## Code\n```c++\nListNode *detectCycle(ListNode *head) {\n    if(head == NULL || head->next == NULL) return NULL;\n    ListNode* slow = head;\n    ListNode* fast = head;\n    while(fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if(slow == fast) {\n            fast = head;\n            while(fast != slow) {\n                slow = slow->next;\n                fast = fast->next;\n            }\n            return slow;\n        }\n    }\n    return NULL;\n}\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195158337","body":"## Code\n```c++\n// 双向链表+哈希表\n\nstruct DoubleLinked{\n    int val,key;\n    DoubleLinked* pre;\n    DoubleLinked* next;\n    DoubleLinked() {}\n    DoubleLinked(int key, int val)\n                : key(key), val(val), pre(NULL), next(NULL) {}\n    DoubleLinked(int key,int val, DoubleLinked* pre)\n                : key(key), val(val), pre(pre), next(NULL) {}\n    DoubleLinked(int key,int val, DoubleLinked* pre, DoubleLinked* next) \n                : key(key), val(val), pre(pre), next(next) {}\n\n};\nclass LRUCache {\nprivate:\n    map<int, DoubleLinked*> m;\n    int capacity;   \n    DoubleLinked* head = new DoubleLinked();\n    DoubleLinked* tail = new DoubleLinked(); \n\n    // 插入头部\n    void insert(DoubleLinked* new_node) {\n        DoubleLinked* temp = head->next;\n        head->next = new_node;\n        temp->pre = new_node;\n        new_node->next = temp;\n        new_node->pre = head;\n    }\n\n    // 删除尾部\n    void del() {\n        DoubleLinked* temp = tail->pre->pre;\n        DoubleLinked* dele = tail->pre;\n        temp->next = tail;\n        tail->pre = temp;\n        \n    }\n\n    // 提前到头部\n    void move_head(DoubleLinked* target) {\n        // 删除原来位置上\n        target->pre->next = target->next;\n        target->next->pre = target->pre;\n        // 放置到头部\n        target->next = head->next;\n        head->next->pre = target;\n        head->next = target;\n        target->pre = head;\n    }\npublic:\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n        head->next = tail;\n        tail->pre = head;\n    }\n    \n    int get(int key) {\n        if(!m.count(key)) {\n            return -1;\n        }\n        // 提前到头部\n        move_head(m[key]);\n        // cout << \"get : \" << m[key]->val << endl;\n        return m[key]->val;\n    }\n    \n    void put(int key, int value) {\n\n        if(!m.count(key)){\n            // 不存在，插入双向链表的头部\n            capacity--;\n            DoubleLinked* new_node = new DoubleLinked(key, value);\n            m[key] = new_node;\n            insert(new_node);\n            if(capacity < 0) {\n                // 删除双向链表尾部最久未使用\n                m.erase(tail->pre->key);\n                del();\n                capacity = 0;\n            } \n        }\n        else {\n            // 存在，改变值，并且提前\n            m[key]->val = value;\n            move_head(m[key]);\n        }\n    }\n\n};\n```\n## 复杂度\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196326612","body":"## Code\r\n```c++\r\nint maxDepth(TreeNode* root) {\r\n    if(root == NULL) return 0;\r\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));\r\n}\r\n```\r\n## 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(log2n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197573264","body":"## Code\n```c++\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == NULL && q == NULL) return true;\n        if(p == NULL || q == NULL) return false;\n        bool left = isSameTree(p->left, q->left);\n        bool right = isSameTree(p->right, q->right);\n        if(p->val == q->val && left && right) return true;\n        return false;\n    }\n```\n## 复杂度\n- 时间复杂度：O(min(m, n))\n- 空间复杂度：O(min(m, n))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185419128","body":"## 思路\r\n\r\n每次遍历最后一个元素和k加起来，如果大于10的话 进行近位\r\n\r\n## 代码\r\n``` go\r\n\r\nfunc addToArrayForm(num []int, k int) (ans []int) {\r\n\r\n    // 每次遍历提取最后一个元素\r\n    for i:=len(num)-1;i>=0;i-- {\r\n        // 最后一个元素和k加起来\r\n        sum := num[i] + k\r\n        k = k / 10\r\n        // 判断sum是否大于10\r\n        if sum > 10 {\r\n            k ++\r\n            sum = sum - 10\r\n        }\r\n        ans = append(ans, sum)\r\n\r\n    }\r\n\r\n    for ; k > 0; k /= 10 {\r\n        ans = append(ans, k%10)\r\n    }\r\n    reverse(ans)\r\n    return\r\n   \r\n}\r\n\r\n// 反转\r\nfunc reverse(num []int) {\r\n    for i, n := 0, len(num); i < n/2; i++ {\r\n        num[i], num[n-1-i] = num[n-1-i], num[i]\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(max(n,logk))，其中 n 为数组的长度。\r\n\r\n- 空间复杂度：O(1) ，除了返回值以外，使用的空间为常数。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186211992","body":"## LC 821. 字符的最短距离\r\n[Leetcode连接](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\n\r\n- [额外数组记录下标](#solution1)\r\n\r\n### <span id=\"solution1\">额外数组记录下标</span>\r\n\r\n- 首先用额外的数组来保存目标字符在给定字符串的下边\r\n- 遍历给定字符串下边和上面保存的目标字符的下边，计算它们两个的距离，取最小的距离\r\n- 结果保存到另一个额外的数组\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\n\r\nimport \"math\"\r\nimport \"fmt\"\r\nfunc shortestToChar(s string, c byte) []int {\r\n\r\n\r\n    // 选贤获取e的下边\r\n    e := make([]int,0)\r\n    for i:=0;i<len(s);i++{\r\n        if s[i] == c {\r\n           e = append(e,i) \r\n        }\r\n\r\n    }\r\n    fmt.Println(e)\r\n    // 结果\r\n    result := make([]int,0)\r\n\r\n    for i:=0;i<len(s);i++{\r\n        min := 99999999\r\n        for j:=0;j<len(e);j++{\r\n            // fmt.Println(math.Abs(float64(e[j]-j)))\r\n            distance := int(math.Abs(float64(e[j]-i)))\r\n            fmt.Println(distance)\r\n            if distance < min {\r\n                min =  distance\r\n            }\r\n        }\r\n        fmt.Println(min)\r\n        result = append(result,min)\r\n\r\n    }\r\n\r\n    return result\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186446312","body":"\r\n## LC 1381. 设计一个支持增量操作的栈\r\n[Leetcode连接](https://leetcode.cn/problems/design-a-stack-with-increment-operation/submissions/)\r\n\r\n- [思路](#solution1)\r\n\r\n### <span id=\"solution1\">思路</span>\r\n\r\n这一道设计题，已经给定了max长度，我们第一个想象的的一个数组,数组来可以模拟一个栈和栈操作\r\n\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\n\r\n// 构造一个结构体\r\ntype CustomStack struct {\r\n    maxLen int\r\n\tarray []int\r\n\r\n}\r\n\r\n// 新建一个stack\r\nfunc Constructor(maxSize int) CustomStack {\r\n\r\n    stack := CustomStack{\r\n\t\tmaxLen: maxSize,\r\n\t\tarray: make([]int, 0),\r\n\t}\r\n\treturn stack\r\n}\r\n\r\n// puhs操作\r\nfunc (this *CustomStack) Push(x int)  {\r\n\r\n    if len(this.array) < this.maxLen {\r\n\t\tthis.array = append(this.array, x)\r\n\t}\r\n\r\n}\r\n\r\n// pop操作\r\nfunc (this *CustomStack) Pop() int {\r\n\r\n    if len(this.array) == 0 {\r\n\t\treturn -1\r\n\t}\r\n\tnum := this.array[len(this.array)-1]\r\n\tthis.array = this.array[:len(this.array)-1]\r\n\treturn num\r\n\r\n}\r\n\r\n// 增大栈\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n\r\n    if len(this.array) <= k {\r\n\t\tfor i := 0; i < len(this.array);i++ {\r\n\t\t\tthis.array[i] += val\r\n\t\t}\r\n\t} else {\r\n\t\tfor i := 0; i < k;i++ {\r\n\t\t\tthis.array[i] += val\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * obj := Constructor(maxSize);\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * obj.Increment(k,val);\r\n */\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：pop & push O(1)，Increment : O(k)\r\n- 空间复杂度：O(maxSize) ,array 等长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186659388","body":"## LC 394. 字符串解码\r\n[Leetcode连接](https://leetcode.cn/problems/decode-string/)\r\n\r\n- [分支方法](#solution1)\r\n\r\n### <span id=\"solution1\">分支方法</span>\r\n\r\n本题中可能出现括号嵌套的情况，比如 2[a2[bc]]，这种情况下我们可以先转化成 2[abcbc]，在转化成 abcbcabcbc。我们可以把字母、数字和括号看成是独立的 TOKEN，并用栈来维护这些 TOKEN。具体的做法是，遍历这个栈：\r\n\r\n- 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\r\n- 如果当前的字符为字母或者左括号，直接进栈\r\n- 如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（此时栈顶一定是数字，想想为什么？），就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈\r\n\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\n\r\nfunc decodeString(s string) string {\r\n    // 栈\r\n    stk := []string{}\r\n    ptr := 0\r\n    for ptr < len(s) {\r\n        cur := s[ptr]\r\n        // 如果是数字进栈\r\n        if cur >= '0' && cur <= '9' {\r\n            digits := getDigits(s, &ptr)\r\n            stk = append(stk, digits)\r\n            // 如果是字母或者左口号进栈\r\n        } else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\r\n            stk = append(stk, string(cur))\r\n            // 下边往前走一步\r\n            ptr++\r\n        } else {\r\n            // 遇到右括号\r\n            ptr++\r\n            sub := []string{}\r\n            for stk[len(stk)-1] != \"[\" {\r\n                // 出栈\r\n                sub = append(sub, stk[len(stk)-1])\r\n                // 更新str\r\n                stk = stk[:len(stk)-1]\r\n            }\r\n            // 反转 \r\n            for i := 0; i < len(sub)/2; i++ {\r\n                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n            }\r\n            //   stk[len(stk)-1] != \"[\" 已经碰到右括号']'，去掉它\r\n            stk = stk[:len(stk)-1]\r\n            // 出栈 的时候数字\r\n            repTime, _ := strconv.Atoi(stk[len(stk)-1])\r\n            // 更新栈\r\n            stk = stk[:len(stk)-1]\r\n            // 重复\r\n            t := strings.Repeat(getString(sub), repTime)\r\n            // 添加到数组中\r\n            stk = append(stk, t)\r\n        }\r\n    }\r\n    return getString(stk)\r\n}\r\n\r\nfunc getDigits(s string, ptr *int) string {\r\n    ret := \"\"\r\n    for ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\r\n        ret += string(s[*ptr])\r\n    }\r\n    return ret\r\n}\r\n\r\nfunc getString(v []string) string {\r\n    ret := \"\"\r\n    for _, s := range v {\r\n        ret += s\r\n    }\r\n    return ret\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： 记解码后得出的字符串长度为 SS，除了遍历一次原字符串 ss，我们还需要将解码后的字符串中的每个字符都入栈，并最终拼接进答案中，故渐进时间复杂度为O(S+∣s∣)，即 O(S) \r\n- 空间复杂度：记解码后得出的字符串长度为 SS，这里用栈维护 TOKEN，栈的总大小最终与 SS 相同，故渐进空间复杂度为 O(S)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189139221","body":"## LC 232. 用栈实现队列\r\n[Leetcode连接](https://leetcode.cn/problems/implement-queue-using-stacks/)\r\n\r\n- [双栈模拟队列](#solution1)\r\n\r\n### <span id=\"solution1\">思路</span>\r\n通过双栈模拟队列\r\n- push 操作直接入队列\r\n- pop 操作直到第一个元素，队列里面元素移动到另一栈上\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n/\r\n//  MyQueue\r\n//  @Description: 队列结构体\r\n//\r\ntype MyQueue struct {\r\n\tinStack  []int\r\n\toutStack []int\r\n}\r\n\r\n//\r\n//  Constructor\r\n//  @Description: 创建\r\n//  @return MyQueue\r\n//\r\nfunc Constructor() MyQueue {\r\n\r\n\treturn MyQueue{\r\n\t\tinStack:  make([]int, 0),\r\n\t\toutStack: make([]int, 0),\r\n\t}\r\n\r\n}\r\n\r\n//\r\n//  Push\r\n//  @Description: 入队列\r\n//  @receiver this\r\n//  @param x\r\n//\r\nfunc (this *MyQueue) Push(x int) {\r\n\r\n\tthis.inStack = append(this.inStack, x)\r\n\r\n}\r\n\r\n//\r\n//  Pop\r\n//  @Description: 出队列\r\n//  @receiver this\r\n//  @return int\r\n//\r\nfunc (this *MyQueue) Pop() int {\r\n\r\n\t// outStack 长度等于0\r\n\tif len(this.outStack) == 0 {\r\n\t\tfor len(this.inStack) > 0 {\r\n\t\t\tthis.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])\r\n\t\t\tthis.inStack = this.inStack[:len(this.inStack)-1]\r\n\t\t}\r\n\r\n\t}\r\n\t// 获取最后一个元素\r\n\telem := this.outStack[len(this.outStack)-1]\r\n\t// 更新\r\n\tthis.outStack = this.outStack[:len(this.outStack)-1]\r\n\treturn elem\r\n\r\n}\r\n\r\n//\r\n//  Peek\r\n//  @Description: 最后一个元素\r\n//  @receiver this\r\n//  @return int\r\n//\r\nfunc (this *MyQueue) Peek() int {\r\n\r\n\tif len(this.outStack) == 0 {\r\n\t\tfor len(this.inStack) > 0 {\r\n\t\t\tthis.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])\r\n\t\t\tthis.inStack = this.inStack[:len(this.inStack)-1]\r\n\t\t}\r\n\t}\r\n\treturn this.outStack[len(this.outStack)-1]\r\n\r\n}\r\n\r\nfunc (this *MyQueue) Empty() bool {\r\n\treturn len(this.inStack) == 0 && len(this.outStack) == 0\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * obj := Constructor();\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * param_3 := obj.Peek();\r\n * param_4 := obj.Empty();\r\n */\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push和empty操作O(1),pop和peek操作O(N),其中N是元素从一个栈移动到另一个栈次数\r\n- 空间复杂度：O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190443337","body":"## LC 768. 最多能完成排序的块 II\r\n[Leetcode连接](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n- [思路](#solution1)\r\n\r\n### <span id=\"solution1\">思路</span>\r\n\r\n分块后进行排序和原来数组相等的时候分块数量吧\r\n- 分块后每一个分块进行排序\r\n- 排序后，所有的分块进行连接\r\n- 排序数组和原来数组的前k元素相减去后的结果等于0的话，那么这位一个分块\r\n- 连接的数组是否相等原来的数组\r\n\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\nimport \"sort\"\r\n\r\nfunc maxChunksToSorted(arr []int) int {\r\n\r\n\tlength := len(arr)\r\n\tif length <= 1 {\r\n\t\treturn 1\r\n\t}\r\n\tarray := make([]int, length)\r\n\tcopy(array, arr)\r\n\tsort.Ints(array)\r\n\tsum, ret := 0, 0\r\n\tfor i := 0; i < l; i++ {\r\n\t\tsum += (arr[i] - array[i])\r\n\t\tif sum == 0 {\r\n\t\t\tret++\r\n\t\t}\r\n\t}\r\n\treturn ret\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：排序：O(NLogN)，循环:O(N);其中N数组长度，O(N(1+logN))简化为O(NLogN)\r\n- 空间复杂度：O(N);其中N数组长度，创建了一个数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191586881","body":"## LC 61. 旋转链表\r\n[Leetcode连接](https://leetcode.cn/problems/rotate-list/)\r\n\r\n- [链表](#solution1)\r\n\r\n### <span id=\"solution1\">链表</span>\r\n\r\n- 先计算表长度和找到尾节点\r\n- 计算需要移动的元素数量\r\n- 开始移动 num-k-1 次\r\n- 形成环tail.Next = head\r\n- 形成头head = mid.Next\r\n- 断开mid.Next = nil\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\n\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n\r\n\tif head == nil {\r\n\t\treturn nil\r\n\t}\r\n\t//tail := &ListNode{\r\n\t//\tNext: head,\r\n\t//}\r\n\ttail := head\r\n\tmid, cur := head, head\r\n\tnum := 0\r\n\t// 找\r\n\tfor cur != nil {\r\n\t\tnum++\r\n\t\ttail = tail.Next\r\n\t\tcur = cur.Next\r\n\t}\r\n\t// 计算要移动步数\r\n\tk = k % num\r\n\t// 开始移动\r\n\tfor i := 0; i < num-k-1; i++ {\r\n\t\tmid = mid.Next\r\n\t}\r\n\t// 换\r\n\ttail.Next = head\r\n\t// 连接头\r\n\thead = mid.Next\r\n\t// 断开\r\n\tmid.Next = nil\r\n\r\n\treturn head\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中N链表长度。\r\n- 空间复杂度：O(1)，移动指针而已","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192189056","body":"## LC 24. 两两交换链表中的节点\r\n[Leetcode连接](https://leetcode-solution.cn/solutionDetail?type=3&id=8&max_id=2)\r\n\r\n- [迭代](#solution1)\r\n- [递归](#solution2)\r\n- [总结我的错误](#solution3)\r\n\r\n### <span id=\"solution1\">迭代</span>\r\n\r\n\r\n首先考虑修改两个节点几需要几次操作呢？ 答案4次；比如\r\npreA -> A -> B ->BNext 修改为 preA ->B ->A ->nextB\r\n\r\n- A指向BNext ， preA ->A->nextB ;B->nextB\r\n- B 节点的 next 指向 A; preA -> A -> nextB ;B -> A\r\n- preA 节点的 next 指向 B;B -> A;preA -> B -> A -> nextB\r\n\r\nA.next = next.B;\r\nB.next = A;\r\npreA.next = B;\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\n\r\n\r\n//\r\n//  swapPairs\r\n//  @Description:给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\r\n//  @param head\r\n//  @return *ListNode\r\n//\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\r\n\tnodes := &ListNode{\r\n\t\tNext: head,\r\n\t}\r\n\r\n\t//result := nodes\r\n\t//previous := nodes\r\n\t//for head != nil && head.Next != nil {\r\n\t//\t// 当前的节点和下一个节点\r\n\t//\tnow := head\r\n\t//\tnext := head.Next\r\n\t//\t// now 哨兵指向next的下一个节点\r\n\t//\tnow.Next = next.Next\r\n\t//\tnext.Next = previous.Next\r\n\t//\tprevious.Next = next\r\n\t//\r\n\t//\tprevious = now\r\n\t//\thead = now.Next\r\n\t//\r\n\t//}\r\n\r\n\t//result := nodes\r\n\t//previous := nodes\r\n\t//for previous.Next != nil && previous.Next.Next != nil {\r\n\t//\tnow := previous.Next\r\n\t//\tnext := previous.Next.Next\r\n\t//\r\n\t//\tprevious.Next = next\r\n\t//\tnow.Next = next.Next\r\n\t//\tnext.Next = now\r\n\t//\r\n\t//\tprevious = now\r\n\t//\r\n\t//}\r\n\r\n\tprevious := nodes\r\n\tcurrent := previous.Next // 相当于head\r\n\tfor current != nil && current.Next != nil {\r\n\t\tnext := current.Next\r\n\t\tcurrent.Next = next.Next\r\n\t\tnext.Next = current\r\n\t\tprevious.Next = next\r\n\r\n\t\tprevious = current\r\n\t\tcurrent = current.Next\r\n\t}\r\n\r\n\treturn nodes.Next\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为节点长度长度。\r\n- 空间复杂度：O(1)\r\n\r\n\r\n\r\n### <span id=\"solution2\">递归</span>\r\n\r\n- 就是cur.Next.Next 放进递归里面\r\n- cur.Next 指向 递归返回过来的信息\r\n- next.Next 指向cur\r\n\r\n### 代码\r\n\r\n\r\n``` go（此处换成你的语言，比如js，py 等）\r\n\r\n\r\n//\r\n//  swapPairs\r\n//  @Description: 递归\r\n//  @param head\r\n//  @return *ListNode\r\n//\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\r\n\t// 递归结束条件\r\n\tif head == nil && head.Next == nil {\r\n\t\treturn head\r\n\t}\r\n\r\n\tnow := head\r\n\tnext := head.Next\r\n\tnextNext := swapPairs(next.Next)\r\n\tnow.Next = nextNext\r\n\tnext.Next = now\r\n\r\n\treturn next\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为节点长度长度。\r\n- 空间复杂度：O(1)\r\n\r\n\r\n### <span id=\"solution3\">总结我的错误</span>\r\n\r\n``` go\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\r\n    nodes := &ListNode{\r\n\t\tNext: head,\r\n\t}\r\n\r\n\tresult := nodes\r\n\t\r\n  \r\n\tfor nodes.Next != nil && nodes.Next.Next != nil {\r\n\t\t\r\n        next := nodes.Next.Next\r\n\t\tcurrent := nodes.Next\r\n\t\tnodes.Next = next.Next\r\n\t\tnodes.Next.Next = current\r\n\t\t\r\n\t}\r\n\r\n\treturn result.Next\r\n\r\n}\r\n\r\n```\r\n其实上面代码里面我只在乎当前和下一个节点。更本没在乎当前节点的前一个节点\r\n这里根本没考虑previous 和 previous.Next 节点\r\n注意这里 如果写成  next.Next = current 形成一个环 ，所以不能这样写，只这样写 next.Next = pre.Next\r\n\r\n``` go\r\nnodes := &ListNode{\r\n\t\tNext: head,\r\n\t}\r\n\r\n\tresult := nodes\r\n\tpre := nodes\r\n\tfor head != nil && head.Next != nil {\r\n\r\n\t\tcurrent := head\r\n\t\tnext := head.Next\r\n\t\tcurrent.Next = next.Next\r\n\t\tnext.Next = pre.Next\r\n\t\tpre.Next = next\r\n\r\n\t\tpre = current\r\n\t\thead = current.Next\r\n\r\n\t}\r\n\r\n\treturn result.Next\r\n\r\n```\r\n\r\n\r\n### 思路\r\n首先考虑修改两个节点几需要几次操作呢？ 答案4次；比如\r\npreA -> A -> B ->BNext 修改为 preA ->B ->A ->nextB\r\n\r\n- A指向BNext ， preA ->A->nextB ;B->nextB\r\n- B 节点的 next 指向 A; preA -> A -> nextB ;B -> A\r\n- preA 节点的 next 指向 B;B -> A;preA -> B -> A -> nextB\r\n\r\nA.next = next.B;\r\nB.next = A;\r\npreA.next = B;\r\n其实上面代码里面我只在乎当前和下一个节点。更本没在乎当前节点的前一个节点\r\n这里根本没考虑previous 和 previous.Next 节点\r\n注意这里 如果写成  next.Next = current 形成一个环 ，所以不能这样写，只这样写 next.Next = pre.Next\r\n如果 next.Next = current 的话 形成一个环，因为 next.Next =  nodes.Next ， 然后current.Next指向next.Next\r\n\r\n``` go\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\r\n    nodes := &ListNode{\r\n\t\tNext: head,\r\n\t}\r\n\r\n\tresult := nodes\r\n\tpre := nodes\r\n\tfor nodes.Next != nil && nodes.Next.Next != nil {\r\n\t\tcurrent := nodes.Next\r\n\t\tnext := nodes.Next.Next\r\n\t\t// 当前节点 A\r\n\t\tcurrent.Next = next.Next\r\n\t\t// 节点B\r\n\t\tnext.Next = pre.Next\r\n\t\t// preANext\r\n\t\tpre.Next = next\r\n\r\n\t\t// pre\r\n\t\tpre = current\r\n        nodes = nodes.Next\r\n\r\n\t}\r\n\r\n\r\n\r\n\treturn result.Next\r\n\t\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为节点长度长度。\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193066414","body":"## LC 109. 有序链表转换二叉搜索树\r\n[Leetcode连接](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)\r\n\r\n- [递归+快慢指针](#solution1)\r\n- [递归+数组](#solution2)\r\n\r\n### <span id=\"solution1\">递归+快慢指针</span>\r\n\r\n通过每次递归慢指针找正中间元素，然后进行赋值;在进行遍历树的左右的子树\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\n\r\n//\r\n//  sortedListToBST\r\n//  @Description:\r\n//  @param head\r\n//  @return *TreeNode\r\n//\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n\t// 如果 head 空\r\n\tif head == nil {\r\n\t\treturn nil\r\n\t}\r\n\t// 开始i遍历\r\n\treturn dfs(head, nil)\r\n\r\n}\r\n\r\nfunc dfs(head, tail *ListNode) *TreeNode {\r\n\t// 递归推出题条件\r\n\tif head == tail {\r\n\t\treturn nil\r\n\t}\r\n\t// 快慢指针\r\n\tfast, slow := head, head\r\n\tfor fast != tail && fast.Next != tail {\r\n\t\tfast = fast.Next.Next\r\n\t\tslow = slow.Next\r\n\t}\r\n\t// 创建root节点\r\n\troot := &TreeNode{Val: slow.Val}\r\n\troot.Left = dfs(head, slow)\r\n\troot.Right = dfs(slow.Next, tail)\r\n\treturn root\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn);一般递归的时间复杂度是节点数量 * 具体操作\r\n- 空间复杂度：空间复杂度为O(logn)\r\n\r\n\r\n\r\n\r\n\r\n### <span id=\"solution2\">递归+数组</span>\r\n\r\n- 创建一个数组，并所有的 元素存到数组中，\r\n- 每次获中间的元素作为root，mid = (end - start) / 2 + star\r\n\r\n### 代码\r\n\r\n\r\n``` go（此处换成你的语言，比如js，py 等）\r\n\r\n\r\nfunc sortedListToBST1(head *ListNode) *TreeNode {\r\n\tif head == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tarray := make([]int, 0)\r\n\t// 每个节点存到数组中\r\n\tfor head != nil {\r\n\t\tarray = append(array, head.Val)\r\n\t\thead = head.Next\r\n\t}\r\n\t// 开始调用递归\r\n\treturn dfs1(array, 0, len(array))\r\n}\r\n\r\nfunc dfs1(res []int, start, end int) *TreeNode {\r\n\t//  遍历完\r\n\tif start >= end {\r\n\t\treturn nil\r\n\t}\r\n\t//  获取中间的节点\r\n\tmid := (end-start)/2 + start\r\n\troot := &TreeNode{Val: res[mid]}\r\n\troot.Left = dfs1(res, start, mid)\r\n\troot.Right = dfs1(res, mid+1, end)\r\n\treturn root\r\n\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：时间复杂度为O(n)，节点数量\r\n- 空间复杂度：空间复杂度为O(n)，创建一个大小n的数组\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193333517","body":"## LC 160. 相交链表\r\n[Leetcode连接](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\r\n\r\n- [字典](#solution1)\r\n- [迭代](#solution2)\r\n\r\n### <span id=\"solution1\">字典</span>\r\n\r\n- 先遍历A链边，存到字典中\r\n- 在遍历B链表，从字典查询，如果查到就当前节点交接点\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n//\r\n//  getIntersectionNode\r\n//  @Description: 额外空间字典\r\n//  @param headA\r\n//  @param headB\r\n//  @return *ListNode\r\n//\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n\r\n\tif headA == nil || headB == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tdic := make(map[*ListNode]bool)\r\n\r\n\tfor headA != nil {\r\n\t\tdic[headA] = true\r\n\t\theadA = headB.Next\r\n\t}\r\n\r\n\tfor headB != nil {\r\n\t\tif _, ok := dic[headB]; ok {\r\n\t\t\treturn headB\r\n\t\t}\r\n\r\n\t\theadB = headB.Next\r\n\t}\r\n\r\n\treturn nil\r\n\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：A和B链表的元素个数分别 M 和 N ；两次迭代，则时间复杂度 O(M+N)\r\n- 空间复杂度：额外使用链一个字典，字典长度等于A的链表元素长度，则 空间复杂度 O(M)\r\n\r\n\r\n\r\n\r\n\r\n### <span id=\"solution2\">迭代</span>\r\n\r\n两个表的长度不一样，怎么才能获取到这个交接点呢？如果两个表同时到交接点呢\r\n\r\n答 ： pa遍历A表后继续遍历B表，pb遍历完B表后继续遍历A表，这用能保证它们同时到交界点\r\n\r\n\r\n### 代码\r\n\r\n\r\n``` go（此处换成你的语言，比如js，py 等）\r\n\r\n\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n\r\n\tpA, pB := headA, headB\r\n\r\n\tfor pA != pB {\r\n\t\tif pA == nil {\r\n\t\t\tpA = headB\r\n\t\t} else {\r\n\t\t\tpA = pA.Next\r\n\t\t}\r\n\r\n\t\tif pB == nil {\r\n\t\t\tpB = headA\r\n\t\t} else {\r\n\t\t\tpB = pB.Next\r\n\t\t}\r\n\t}\r\n\r\n\treturn pA\r\n\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：A和B链表的元素个数分别 M 和 N ；两次迭代，则时间复杂度 O(M+N)\r\n- 空间复杂度：空间复杂度 O(1) \r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194219876","body":"## LC 标题\r\n[Leetcode连接](https://leetcode.cn/problems/linked-list-cycle-ii/)\r\n\r\n- [字典](#solution1)\r\n- [迭代](#solution2)\r\n\r\n### <span id=\"solution1\">字典</span>\r\n\r\n-边遍历边查询，如果查到，就是入环的节点\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\n\r\n//\r\n//  detectCycle\r\n//  @Description:\r\n//  @param head\r\n//  @return *ListNode\r\n//\r\nfunc detectCycle(head *ListNode) *ListNode {\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tdic := make(map[*ListNode]bool)\r\n\r\n\tp := head\r\n\tfor p != nil {\r\n\t\tif _, ok := dic[p]; ok {\r\n\t\t\treturn p\r\n\t\t} else {\r\n\t\t\tdic[p] = true\r\n\t\t}\r\n\t\tp = p.Next\r\n\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N) 其中 N 为元素个数\r\n- 空间复杂度：O(M) 字典长度\r\n\r\n\r\n\r\n\r\n### <span id=\"solution1\">迭代</span>\r\n\r\n- fast 比 slow 快一步\r\n- 当它们两个遇到的时候，fast 重定向到head 节点，并且它们两个速度一样每次走一步\r\n- 继续通过另一个循环遍历 fast 和 slow ，当它们遇到的时候，就是环的入口节点\r\n\r\n### 代码\r\n\r\n\r\n``` go（此处换成你的语言，比如js，py 等）\r\n\r\n\r\n//\r\n//  detectCycle\r\n//  @Description:\r\n//  @param head\r\n//  @return *ListNode\r\n//\r\nfunc detectCycle1(head *ListNode) *ListNode {\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn nil\r\n\t}\r\n\r\n\tfast, slow := head, head\r\n\tfor fast != nil && fast.Next != nil {\r\n\t\tfast = fast.Next.Next\r\n\t\tslow = slow.Next\r\n\t\tif slow == fast {\r\n\t\t\tslow = head\r\n\t\t\tfor fast != slow {\r\n\t\t\t\tfast = fast.Next\r\n\t\t\t\tslow = slow.Next\r\n\t\t\t}\r\n\t\t\treturn slow\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为节点个个数。在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。因此，总的执行时间为 O(N) + O(N)=O(2N)  ，简化为 O(N)\r\n- 空间复杂度：O(1)，只创建了两个指针slow 和 fast\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195649264","body":"### 思路\r\n双向链表 + map\r\n\r\n### 代码\r\n``` go\r\n\r\n// 双向链表 + map\r\ntype LRUCache struct {\r\n\tm          map[int]*DLinkNode\r\n\tcapacity   int // 容量\r\n\tsize       int // 当前大小\r\n\thead, tail *DLinkNode\r\n}\r\n\r\n// 双向链表  头部代表最新，尾部代表最久未使用\r\ntype DLinkNode struct {\r\n\tkey, val  int\r\n\tpre, next *DLinkNode\r\n}\r\n\r\nfunc newDLinkNode(key, value int) *DLinkNode {\r\n\treturn &DLinkNode{\r\n\t\tkey: key,\r\n\t\tval: value,\r\n\t}\r\n}\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n\tl := LRUCache{\r\n\t\tm:        make(map[int]*DLinkNode, capacity),\r\n\t\tcapacity: capacity,\r\n\t\tsize:     0,\r\n\t\thead:     newDLinkNode(0, 0),\r\n\t\ttail:     newDLinkNode(0, 0),\r\n\t}\r\n\tl.head.next = l.tail\r\n\tl.tail.pre = l.head\r\n\treturn l\r\n}\r\n\r\nfunc (this *LRUCache) Get(key int) int {\r\n\tnode, ok := this.m[key]\r\n\tif ok {\r\n\t\t// 把node节点放到头部\r\n\t\tnode.pre.next = node.next\r\n\t\tnode.next.pre = node.pre\r\n\t\tthis.head.next.pre = node\r\n\t\tnode.next = this.head.next\r\n\t\tnode.pre = this.head\r\n\t\tthis.head.next = node\r\n\t\treturn node.val\r\n\t} else {\r\n\t\treturn -1\r\n\t}\r\n}\r\n\r\nfunc (this *LRUCache) Put(key int, value int) {\r\n\t// 先判断是否已经有了key，如果有就更新值并放到头结点，没有再插入\r\n\tnode, ok := this.m[key]\r\n\tif ok {\r\n\t\t// 更新node值，然后将node节点抽出再头插\r\n\t\tnode.val = value\r\n\t\tnode.pre.next = node.next\r\n\t\tnode.next.pre = node.pre\r\n\t\tthis.head.next.pre = node\r\n\t\tnode.next = this.head.next\r\n\t\tthis.head.next = node\r\n\t\tnode.pre = this.head\r\n\t} else {\r\n\t\tif this.size < this.capacity {\r\n\t\t\t// 直接头插\r\n\t\t\tthis.size++\r\n\t\t} else {\r\n\t\t\t// 先弹出末尾\r\n\t\t\tdelete(this.m, this.tail.pre.key)\r\n\t\t\tthis.tail.pre.pre.next = this.tail\r\n\t\t\tthis.tail.pre = this.tail.pre.pre\r\n\t\t}\r\n\t\t// 再头插node节点\r\n\t\tnode := newDLinkNode(key, value)\r\n\t\tthis.m[key] = node\r\n\t\tthis.head.next.pre = node\r\n\t\tnode.next = this.head.next\r\n\t\tthis.head.next = node\r\n\t\tnode.pre = this.head\r\n\t}\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * obj := Constructor(capacity);\r\n * param_1 := obj.Get(key);\r\n * obj.Put(key,value);\r\n */\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：get 和 put 操作时间复杂度都是O(1)\r\n- 空间复杂度：O(N)，其中N字典的长度\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196831235","body":"\r\n## LC 104. 二叉树的最大深度\r\n[Leetcode连接](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\r\n\r\n- [BFS](#solution1)\r\n- [DFS](#solution2)\r\n- [回溯](#solution3)\r\n\r\n### <span id=\"solution1\">思路DFS</span>\r\n\r\n思路非常简单。通过递归遍历每个节点左右节点\r\n- 递归结束条件是当节点nil 的时候返回0\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n//\r\n//  maxDepth\r\n//  @Description: 递归\r\n//  @param root\r\n//  @return int\r\n//\r\nfunc maxDepth(root *TreeNode) int {\r\n\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\tleft := maxDepth(root.Left)\r\n\tright := maxDepth(root.Right)\r\n\treturn int(math.Max(float64(left), float64(right))) + 1\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 节点个数。\r\n- 空间复杂度：O(M)，高度，其实意思是递归栈空间的大小\r\n\r\n\r\n\r\n\r\n### <span id=\"solution2\">思路BFS</span>\r\n\r\n思路简单\r\n- 首先维护一个队列\r\n- 每次对立加到一个层的元素，遍历一个层，深度 +1 \r\n- 下一次进入遍历下一层\r\n- 重复以上的步骤\r\n\r\n### Golang 代码\r\n\r\n\r\n``` go（此处换成你的语言，比如js，py 等）\r\n\r\n\r\n//\r\n//  maxDepth1\r\n//  @Description:广度优先搜索\r\n//  @param root\r\n//\r\nfunc maxDepth1(root *TreeNode) int {\r\n\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\r\n\tqueue := make([]*TreeNode, 0)\r\n\tresult := 0\r\n\tqueue = append(queue, root)\r\n\r\n\tfor len(queue) > 0 {\r\n\r\n\t\tqueueLength := len(queue)\r\n\t\tfor queueLength > 0 {\r\n\t\t\tnode := queue[0]\r\n\t\t\tqueue = queue[1:]\r\n\t\t\tif node.Left != nil {\r\n\t\t\t\tqueue = append(queue, node.Left)\r\n\t\t\t}\r\n\t\t\tif node.Right != nil {\r\n\t\t\t\tqueue = append(queue, node.Right)\r\n\t\t\t}\r\n\r\n\t\t\tqueueLength--\r\n\t\t}\r\n\t\tresult++\r\n\r\n\t}\r\n\r\n\treturn result\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 节点个数。\r\n- 空间复杂度：O(M)，M 最坏情况下队列长度。\r\n\r\n\r\n\r\n\r\n### <span id=\"solution3\">回溯</span>\r\n\r\n基本思路就是记录访问过的节点\r\n\r\n\r\n### Golang 代码\r\n\r\n``` go（此处换成你的语言，比如js，py 等）\r\n//\r\n//  maxDepth2\r\n//  @Description:\r\n//  @param root\r\n//  @return int\r\n//\r\n\r\nvar depth = 0\r\nvar res = 0\r\n\r\nfunc maxDepth2(root *TreeNode) int {\r\n\r\n\ttraverse(root)\r\n\treturn res\r\n}\r\n\r\nfunc traverse(root *TreeNode) {\r\n\r\n\tif root == nil {\r\n\t\treturn\r\n\t}\r\n\r\n\tdepth++\r\n\tres = int(math.Max(float64(res), float64(depth)))\r\n\ttraverse(root.Right)\r\n\ttraverse(root.Left)\r\n\tdepth--\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 节点个数。\r\n- 空间复杂度：O(M)，高度，其实意思是递归栈空间的大小","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185422953","body":"### 思路\n\n常规思路\n先将给的数值转成数值，然后和给的 k 进行相加，再将其转换成数组\n\n### 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_length = len(num)\n        sum = 0\n        for index, i in enumerate(num):\n            sum += i * 10 ** (num_length - index  - 1)\n        sum += k\n        return [int(i) for i in str(sum)]\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186223257","body":"### 思路\n\n分别计算数组位置中左侧和后侧的最近距离，然后最它们中的最小值作为当前 index 的数字。\n\n### 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [n+1] * n\n\n        c_index = -1\n        for index, char in enumerate(s):\n            if char == c:\n                c_index = index\n            if c_index != -1:\n                ans[index] = index - c_index \n\n        c_index = -1\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                c_index = i\n            if c_index != -1:\n                ans[i] = min(ans[i], c_index - i)\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551995","body":"### 思路\n\n1. 第一种方法比较依赖语言本身的特性，使用到了 Python 自己的数据结构，list 的 append/pop 方法\n2. 使用比较原生的方式实现，主要使用到数组的相关 crud\n\n### 代码\n- 方法 1\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self._stack = []\n        self._stack_cap = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self._stack) < self._stack_cap:\n            self._stack.append(x)\n\n    def pop(self) -> int:\n        if len(self._stack) > 0:\n            return self._stack.pop()\n        return -1\n    def increment(self, k: int, val: int) -> None:\n        curr_count = len(self._stack)\n        for i in range(k):\n            if i <= curr_count - 1:\n                self._stack[i] += val\n```\n- 方法 2\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self._stack = [0] * maxSize\n        self._stack_cap = maxSize\n        self._stack_index = -1  # 当前索引，-1 表示当前栈为空\n\n    def push(self, x: int) -> None:\n        if self._stack_index + 1 < self._stack_cap:\n            self._stack_index += 1\n            self._stack[self._stack_index] = x\n            \n\n\n    def pop(self) -> int:\n        if self._stack_index > -1:\n            top = self._stack[self._stack_index]\n            self._stack_index -= 1\n            return top\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i <= self._stack_index:\n                self._stack[i] += val\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189228149","body":"### 思路\n\n1. 关键是需要可以相出将一个栈（A栈）依次取出然后放到另外一个栈（B 栈）里面，从 B 栈出来的就是按照先进先出的顺序了，相当于内部做了一次翻转；\n2. 题目给出条件，所有操作都是有效的，不存在空队列去进行 pop() peak() 操作；\n3. 在调用 peak 的时候，我们将 A 栈的数据依次出栈，放入 B 栈，然后返回队列头的数据（及 B 栈的栈顶）；\n4. 在调用 pop 的时候，首先触发 peak，然后将 B 栈进行出栈操作；\n\n### 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self._stack_one = []\n        self._stack_two = []\n\n    def push(self, x: int) -> None:\n        self._stack_one.append(x)\n\n    def pop(self) -> int:\n        self.peek()\n        return self._stack_two.pop()\n\n    def peek(self) -> int:\n        if len(self._stack_two) == 0:\n            while len(self._stack_one) != 0:\n                self._stack_two.append(self._stack_one.pop())\n        return self._stack_two[-1]\n\n    def empty(self) -> bool:\n        return len(self._stack_one) == 0 and len(self._stack_two) == 0\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190339214","body":"### 思路\n\n参考 [max-chunks-to-make-sorted-ii](https://github.com/suukii/91-days-algorithm/blob/master/basic/array-stack-queue/06.max-chunks-to-make-sorted-ii.md)\n\n### 代码\n\n1. 采用滑动窗口\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        sorted_arr = sorted(arr)\n\n        count = 0\n        sum1 = 0\n        sum2 = 0\n\n        for i in range(len(arr)):\n            sum1 += arr[i]\n            sum2 += sorted_arr[i]\n\n            if (sum1 == sum2):\n                count += 1\n        \n        return count\n```\n\n2. 单调栈\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n\n        for i in arr:\n            if len(stack) == 0:\n                stack.append(i)\n                continue\n\n            if stack[-1] <= i:\n                stack.append(i)\n            else:\n                top = stack.pop()\n                while len(stack) != 0 and stack[-1] > i:\n                    stack.pop()\n                \n                stack.append(top)\n            \n        return len(stack)\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192704036","body":"### 思路\r\n\r\n1. 采用递归\r\n2. 添加一个辅助虚拟头结点\r\n\r\n### 代码\r\n\r\n1. 采用递归\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if (head is None or head.next is None):\r\n            return head\r\n        \r\n        new_head = head.next\r\n        head.next = self.swapPairs(new_head.next)\r\n        new_head.next = head\r\n\r\n        return new_head\r\n```\r\n\r\n2. 添加一个辅助虚拟头结点\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if (head is None or head.next is None):\r\n            return head\r\n        \r\n        dummy_head = ListNode()\r\n        dummy_head.next = head\r\n\r\n        temp = dummy_head\r\n\r\n        while temp.next and temp.next.next:\r\n            node1 = temp.next\r\n            node2 = node1.next\r\n\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            temp.next = node2\r\n\r\n            temp = node1\r\n\r\n        return dummy_head.next\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141904","body":"### 思路\r\n\r\n1. 构建树采用递归，找到有序链表的中间点，分别构造两边的子树\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        return self.build(head, None)\r\n\r\n    def build(self, begin, end):\r\n        if (begin == end):\r\n            return None\r\n\r\n        mid = self.get_mid(begin, end)\r\n        root = TreeNode(mid.val)\r\n        root.left = self.build(begin, mid)\r\n        root.right = self.build(mid.next, end)\r\n\r\n        return root\r\n\r\n    def get_mid(self, begin, end):\r\n        slow, fast = begin, begin\r\n        while (fast != end and fast.next != end):\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        return slow\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193334980","body":"### 思路\r\n\r\n两个指针，分别遍历 A + B，B + A 寻找其中相交的点\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        p1, p2 = headA, headB\r\n        len_a, len_b = 0, 0\r\n        while p1 != p2:\r\n            if p1 is None:\r\n                p1 = headB\r\n            else: \r\n                p1 = p1.next\r\n\r\n            if p2 is None:\r\n                p2 = headA\r\n            else:\r\n                p2 = p2.next\r\n\r\n        return p1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194052788","body":"### 思路\r\n\r\n理解快慢指针，并且通过变量推导算法原理，如 第一次相遇 slow、fast 分别走了 k、2k。fast 多走的 k 为环的整数倍。\r\n假设环的起点距离第一次相遇点为 m，那么 k - m 为从 head 到环起点的距离，也是快指针从当前相遇点到环起点再一次相遇的点。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast, slow = head, head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                break\r\n\r\n        if fast is None or fast.next is None:\r\n            return None\r\n\r\n        slow = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n\r\n        return slow\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196906544","body":"```python\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        else:\n            return max(\n                self.maxDepth(root.left),\n                self.maxDepth(root.right)\n            ) + 1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185423747","body":"### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = 0\n        for i in range(len(num)-1,-1,-1):\n            num[i], temp = (temp+num[i]+k%10)%10, (temp+num[i]+k%10)//10\n            k = k//10\n        l = []\n        n = []\n        k += temp\n        while k:\n            l.append(k%10)\n            k//=10\n        while l:\n            n.append(l.pop())\n        return n+num\n```\n### 复杂度分析\n时间复杂度：O（n）  \n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186139183","body":"### 思路\n首先遍历字符串找到给定字符的所有位置，然后再遍历字符串，比较每个字符和给定字符所有位置之间的距离，取最小的距离\n\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        s_list = list(s)\n        temp = []\n        for i in range(len(s_list)):\n            if s_list[i] == c:\n                temp.append(i)\n        answer = []\n        for i in range(len(s_list)):\n            temp2 = []\n            for j in range(len(temp)):\n                m = abs(i - temp[j])\n                temp2.append(m)\n            answer.append(min(temp2))\n        return answer\n```\n\n**复杂度分析**  \n时间复杂度：O（n*k），n为字符串长度，k为给定字符在字符串中出现的次数  \n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186527404","body":"### 思路\n数组实现，push时注意判断是否长度溢出，pop时判断是否为空，定义一个记录栈顶位置的变量\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.length = maxSize\n        self.stack = []\n        self.top = 0\n\n    def push(self, x: int) -> None:\n        if self.top < self.length:\n            self.stack.append(x)\n            self.top += 1\n\n    def pop(self) -> int:\n        if self.stack:\n            self.top -= 1\n            return(self.stack.pop())\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if self.top == 0:\n            return -1\n        elif self.top < k:\n            for i in range(self.top):\n                self.stack[i] += val\n        else:\n            for i in range(k):\n                self.stack[i] += val\n```\n**复杂度分析**  \n- 时间复杂度：push和pop为O（1），increment为O（min（k，top））\n- 空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186751669","body":"### 思路\n遍历字符串，如果遇到‘【’，数字和字母，全部存到栈中；如果遇到‘】’，开始出栈，将‘【’之前的字母全都出栈并存到临时字符串中，然后数字部分出栈并存到次数字符串中，最后计算出重复的字符串并入栈\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        ans = []\n        for c in s:\n            if c == ']':\n                string = ''\n                count = ''\n                while ans and ans[-1] != '[':\n                    string = ans.pop() + string\n                ans.pop()\n                while ans and ans[-1].isnumeric():\n                    count = ans.pop() + count\n                ans.append(string * int(count))\n            else:\n                ans.append(c)\n        return ''.join(ans)\n```\n**复杂度分析**\n- 时间复杂度：O（n）\n- 空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188945623","body":"### 思路\r\n用两个栈模拟实现队列\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.queue = []\r\n        self.temp = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.queue.append(x)\r\n\r\n    def pop(self) -> int:\r\n        while self.queue:\r\n            self.temp.append(self.queue.pop())\r\n        n = self.temp.pop()\r\n        while self.temp:\r\n            self.queue.append(self.temp.pop())\r\n        return n\r\n\r\n    def peek(self) -> int:\r\n        while self.queue:\r\n            self.temp.append(self.queue.pop())\r\n        n = self.temp.pop()\r\n        self.queue.append(n)\r\n        while self.temp:\r\n            self.queue.append(self.temp.pop())\r\n        return n\r\n\r\n    def empty(self) -> bool:\r\n        if len(self.queue) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O（n）  \r\n- 空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189981219","body":"### 思路\n参考题解，应用单调栈，遍历数组，下一分块的最小值应该大于上一分块的最大值，每一分块用块中最大值表示，并且存于栈中，该栈单调增，最终分块数等于栈的长度\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for x in arr:\n            if stack and stack[-1] > x:\n                top = stack[-1]\n                while stack and stack[-1] > x:\n                    stack.pop()\n                stack.append(top)\n            else:\n                stack.append(x)\n        return len(stack)\n```\n**复杂度分析**\n- 时间复杂度：O（n）  \n- 空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191627375","body":"### 思路\n参考官方题解\n### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # 双指针\n        if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n```\n**复杂度分析**\n- 时间复杂度：O（n）  \n- 空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192660131","body":"### 代码\n```python\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head == None or head.next == None:\n            return head\n        else:\n            ans = ListNode()\n            ans.next = head.next\n            pre = ans\n            first = head\n            while first and first.next:\n                second = first.next\n                post = second.next\n\n                first.next = post\n                second.next = first\n                pre.next = second\n\n                pre = first\n                first = post\n            return ans.next\n```\n**复杂度分析**\n- 时间复杂度：O（n）  \n- 空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193123313","body":"### 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193281721","body":"### 思路\n两个指针分别从A,B两链表开始遍历，遍历A的指针遍历结束后重新开始遍历B，遍历B的指针遍历完后重新开始遍历A，此时若二者相遇则为相交的起始节点\n### 代码\n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        p1 = headA\n        p2 = headB\n        while p1 != p2:\n            if not p1:\n                p1 = headB\n            else:\n                p1 = p1.next\n            if not p2:\n                p2 = headA\n            else:\n                p2 = p2.next\n        return p1\n```\n**复杂度分析**\n- 时间复杂度：O（n）  \n- 空间复杂度：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185423785","body":"### **思路**\r\n简单直接版\r\n\r\n1. 先把数组转成数字\r\n2. 相加\r\n3. 把数字转成数组，先除10求余数，然后除10求商，结果做个反转\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        num_sum = 0\r\n        num = num[::-1]\r\n        num_length = len(num)\r\n        for i in range(num_length):\r\n            num_sum += (10 ** i) * num[i]\r\n        all_sum = num_sum + k\r\n        result = []\r\n        while all_sum > 0:\r\n            mod = all_sum % 10\r\n            all_sum = all_sum // 10\r\n            result.append(mod)\r\n        return result[::-1]\r\n```\r\n\r\n### **复杂度**\r\n\r\n- 时间复杂度O(N) N数组长度\r\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1188666034","body":"### **思路**\r\n\r\n1. 获得c的所有索引\r\n2. 遍历s中的元素，索引小于最小索引的，最小距离是到最小索引的距离\r\n3. 大于最大索引的，最小距离是到最大索引的距离\r\n4. 位于上述两者中间的，计算所有距离，取最小值\r\n\r\n### **代码**\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        s = list(s)\r\n        len_s = len(s)\r\n        index_c = [index for (index,value) in enumerate(s) if value == c]\r\n        result = []\r\n        for i in range(len_s):\r\n            if i<=index_c[0] :\r\n                result.append(index_c[0]-i)\r\n            elif i>=index_c[-1]:\r\n                result.append(i-index_c[-1])\r\n            else:\r\n                min_dis = len_s\r\n                for k in index_c:\r\n                    dis = abs(i-k)\r\n                    if dis < min_dis:\r\n                        min_dis = dis\r\n                result.append(min_dis)\r\n        return result\r\n```\r\n### **复杂度**\r\n\r\n- 时间：O(N)\r\n- 空间：O(N)\r\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188631434","body":"### **思路**\r\n用python列表实现\r\npush -> list.append()\r\npop -> list.pop(0)\r\npeek -> list[0]\r\nempty -> len(list)\r\n\r\n### **代码**\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        self.queue = []\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.queue.append(x)\r\n        return self.queue\r\n\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        x = self.queue.pop(0)\r\n        return x\r\n\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        x = self.queue[0]\r\n        return x\r\n\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        if len(self.queue) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n ```\r\n\r\n### **复杂度**\r\n\r\n- ### 时间复杂度 \r\n\r\npush  : O(1)\r\npop  : O(N)\r\npeek : O(1)\r\nempty :O(N)\r\n\r\n- ### 空间复杂度：\r\npush  : O(1)\r\npop  : O(N)\r\npeek : O(1)\r\nempty :O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190328408","body":"### **思路**\r\n\r\n1. 构造栈，栈头为最大值\r\n2. 遍历数组，元素小于栈头，栈头出栈，保存为最大值，\r\n3. 元素依次与栈内数值比较，小于元素则出栈，不小于栈里的值，或者栈为空，最大值入栈\r\n4. 元素大于栈头，直接入栈，栈头为最大值\r\n\r\n### **代码**\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        # 单调栈\r\n        stack = [arr[0]]\r\n        head = arr[0]\r\n        for i in range(1,len(arr)):\r\n            if arr[i] < head and len(stack) > 0:\r\n                temp_head = head\r\n                while len(stack) > 0 and arr[i] < stack[-1] :\r\n                    if stack.pop(-1) > head:\r\n                        head = stack.pop(-1)\r\n                stack.append(head)\r\n            else:\r\n                stack.append(arr[i])   \r\n                head = arr[i]\r\n        return len(stack)\r\n```\r\n### **复杂度分析**\r\n执行用时：\r\n```\r\n20 ms, 在所有 Python 提交中击败了91.67%的用户\r\n内存消耗：13.2 MB, 在所有 Python 提交中击败了75.00%的用户\r\n```\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(N)\r\n\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195489992","body":"### **思路**\r\n哈希表（字典）+ 双链表\r\n### **代码**\r\n```python\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.cache = dict()\r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        if key not in self.cache:\r\n            return -1\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if key not in self.cache:\r\n            node = DLinkedNode(key, value)\r\n            self.cache[key] = node\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                removed = self.removeTail()\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n\r\n```\r\n### **复杂度分析**\r\n时间复杂度：put 和 get 都是 O(1)\r\n空间复杂度：O(\\text{capacity})O(capacity)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185455662","body":"var addToArrayForm = function(num, k) {\n    let res = [];\n    let len = num.length;\n    for(let i=len-1; i>=0;i--){\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if(sum>=10){\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);  \n    }\n    for(let i =k;i>0;i=Math.floor(i/10)){\n        res.push(i % 10)\n    }\n    res.reverse();\n    return res;\n\n};\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186492043","body":"class CustomStack:\n    def __init__(self, maxSize: int):\n        self.s = []\n        self.maxSize = maxSize\n    def push(self, x: int) -> None:\n        if len(self.s) < self.maxSize:\n            self.s.append(x)\n    def pop(self) -> int:\n        if not self.s:\n            return -1\n        return self.s.pop()\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.s))):\n            self.s[i] += val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187606802","body":"···js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    let num = 0, char = '', cur = '', top \n\n    for (let i = 0; i < s.length; i++) {\n        cur = s.charAt(i)\n\n        if (typeof +cur === 'number' && !isNaN(+cur)) {\n            num = num * 10 + +cur\n        } else if (cur === '[') {\n            stack.push([num, char])\n            num = 0\n            char = ''\n        } else if (cur === ']') {\n            top = stack.pop()\n            char = top[1] + new Array(top[0]).fill(char).join('')\n        } else {\n            char += cur\n        }\n    }\n\n    return char\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189234839","body":"var MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    while(this.stack2.length) {\n        this.stack1.push(this.stack2.pop());\n    }\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    while(this.stack1.length) {\n        this.stack2.push(this.stack1.pop());\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    while(this.stack1.length) {\n        this.stack2.push(this.stack1.pop());\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stack1.length && !this.stack2.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190263393","body":"```js/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n    const sorted = [...arr];\n    sorted.sort((a, b) => a - b);\n\n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n\n        if (sum1 === sum2) {\n            count++;\n            sum1 = sum2 = 0; // 这行不要也可以啦\n        }\n    }\n\n    return count;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191638313","body":"···js\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n        if (!head || !head.next || !k) {\n            return head\n        }\n        let len = 1\n        let p = head\n        while(p.next) {\n            len++\n            p = p.next\n        }\n        if (k%len === 0) {\n            return head\n        }\n        p.next = head // 形成环形链\n        let index = len - k % len\n        while(index) {\n            p = p.next\n            index--\n        }\n        let head2 = p.next\n        p.next = null\n        return head2\n    };\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192616244","body":"```js\nvar swapPairs = function(head) {\n    let dummyNode = new ListNode(0,head);\n    let now = dummyNode;\n    while(now.next && now.next.next) {\n        let second = now.next.next;\n        let first = now.next;\n        let next = second.next;\n        now.next = second;\n        second.next = first;\n        first.next = next;\n        now = now.next.next;\n    }\n    return dummyNode.next;\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194206294","body":"var detectCycle = function (head) {\n  let fast = head;\n  let slow = head;\n  let iscycle = false;\n\n  while (fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n\n    if (fast === slow) {\n      iscycle = true;\n      break;\n    }\n  }\n\n  if (!iscycle) {\n    return null;\n  }\n\n  fast = head;\n  while (fast !== slow) {\n    fast = fast.next;\n    slow = slow.next;\n  }\n\n  return fast;\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196553884","body":"```js\nvar maxDepth = function(root) {\n    if(root == null){\n        return 0;\n    }\n\n    //树的的最大深度等于左子树和右子树深度+1 \n    return Math.max(maxDepth(root.left),maxDepth(root.right))+1\n    t \n\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185460667","body":"**思路**  \r\n一开始只能用list转数字相加方式，后来参考了进位方法：  \r\n1.1 循环判断条件当 k 和 列表都为空时候终止  \r\n1.2 取余方式每次去k的末尾值与列表末尾值进行相加，同时记录进位的值  \r\n\r\n**代码**  \r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res = []\r\n        carry = 0 \r\n        if len(str(k))>len(num):\r\n            num = [0]*(len(str(k))-len(num))+num\r\n        n = len(num)-1 \r\n        while n>=0 and k>=0:\r\n            i = num[n]\r\n            kk = k%10 \r\n            res.append((i+k+carry)%10)\r\n            carry = (i+kk+carry)//10 \r\n            n -= 1\r\n            k = (k-kk)//10 \r\n        if carry!=0: res.append(carry)\r\n        return res[::-1]\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(1)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186109783","body":"**思路**  \r\n1.1 一开始用暴力求解时间复杂度都是O(cn)空间复杂度O(cn)  \r\n1.2 看了题解进行优化,借助-n和2n进行双向搜索，秒啊  \r\n\r\n**代码**\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        ans = [0] * n\r\n\r\n        idx = -n\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                idx = i\r\n            ans[i] = i - idx\r\n        idx = 2 * n\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            ans[i] = min(ans[i], idx - i)\r\n        return ans\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186462349","body":"**思路**  \r\n***1381 https://leetcode.cn/problems/design-a-stack-with-increment-operation/submissions/***  \r\n1.1 利用列表append及pop实现复杂度O(k)    \r\n\r\n**代码**\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize\r\n        self.list = []\r\n        self.index = 0\r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if self.index< self.maxSize:\r\n            self.list.append(x)\r\n            self.index+=1\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.list)==0:\r\n            return -1 \r\n        else:\r\n            self.index-=1\r\n            return self.list.pop()\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if k > self.index:\r\n            k = self.index\r\n        for i in range(k):\r\n            self.list[i] += val\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(k)  \r\n1.2 空间复杂度 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187625717","body":"**思路**  \r\n***394 https://leetcode.cn/problems/decode-string/  \r\n1.1 先讲所有非]进栈  \r\n1.2 遇到]时不停的出栈直到遇到了[  \r\n1.3 [前面判断下是否是数字以及栈非空，如果不是那么把数字出栈  \r\n1.4 出栈相加时候注意字符串顺序，正确顺序的str*nums完成后每一部分append到栈中  \r\n\r\n**代码**\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []\r\n        res = ''\r\n        for i in s:\r\n            if i != ']':\r\n                stack.append(i)\r\n            else:\r\n                word = stack.pop()\r\n                words = ''\r\n                while word!='[':\r\n                    words=word+words # 倒叙\r\n                    word = stack.pop()\r\n                num = stack.pop()\r\n                nums = ''\r\n                while num.isnumeric():\r\n                    nums=num+nums\r\n                    if stack and stack[-1].isnumeric():\r\n                        num = stack.pop()\r\n                    else: \r\n                        break\r\n                stack.append(words*int(nums))\r\n        return ''.join(stack)\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189157723","body":"**思路**  \r\n***232 https://leetcode.cn/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode/***  \r\n1.1 利用双栈实现,维护一个输入栈一个输出栈  \r\n1.2 因为把第一个栈pop后压入到第二个栈输入栈的顺序反过来这时候pop就能实现队列的pop功能  \r\n\r\n```python  \r\nclass MyQueue():\r\n    def __init__(self):\r\n        self.stackin = []\r\n        self.stackout = []\r\n        \r\n    def push(self,i):\r\n        self.stackin.append(i)\r\n        \r\n    def pop(self):\r\n        if not self.stackout:\r\n            while self.stackin:\r\n                self.stackout.append(self.stackin.pop())\r\n        return self.stackout.pop()\r\n    \r\n    def peak(self):\r\n        if not self.stackout:\r\n            while self.stackin:\r\n                self.stackout.append(self.stackin.pop())\r\n        return self.stackout[-1]\r\n    \r\n    def empty(self):\r\n        if not(self.stackin or self.stackout):\r\n            return True\r\n        return False\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(n)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190341806","body":"**思路**  \r\n菜鸡的一天，没有思路，还是看官方题解好  \r\n768 https://leetcode-solution.cn/solutionDetail?type=3&id=6&max_id=2  \r\n\r\n**代码**\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, A):\r\n        stack = []\r\n        for a in A:\r\n            # 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\r\n            # 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\r\n            if stack and stack[-1] > a:\r\n                # 我们需要将融合后的区块的最大值重新放回栈\r\n                # 而 stack 是递增的，因此 stack[-1] 是最大的\r\n                cur = stack[-1]\r\n                # 维持栈的单调递增\r\n                while stack and stack[-1] > a: stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(a)\r\n        # 栈存的是块信息，因此栈的大小就是块的数量\r\n        return len(stack)\r\n```\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(n)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191443120","body":"**思路**    \r\n61 https://leetcode-solution.cn/solutionDetail?type=3&id=7&max_id=2\r\n1.1 这个自己想了个行得通的思路，但是边界没处理好  \r\n1.2 首先吧k规范到链表长度以内，在求解要断开的地方l = l-k\r\n1.3 在求链表长度是做下处理把链表变成一个环，然后在l地方断开就可以了\r\n\r\n**代码**\r\n```python\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head :return head \r\n        temp1 = head\r\n        \r\n        count1 = 1\r\n        while temp1.next:\r\n            temp1 = temp1.next\r\n            count1+=1\r\n        \r\n        temp1.next = head\r\n        reverse_k = count1-k%count1\r\n        \r\n        temp2 = head\r\n        while reverse_k>1:\r\n            reverse_k-=1\r\n            temp2 = temp2.next\r\n\r\n        head = temp2.next\r\n        temp2.next = None\r\n        return head\r\n```\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(1)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192172667","body":"**思路**  \r\n1.1 25题的简化版\r\n\r\n**代码**\r\n```python\r\nclass Solution(object):\r\n    def reverse(self,head):\r\n        temp = None \r\n        while head:\r\n            p = head\r\n            head = p.next \r\n            p.next = temp \r\n            temp = p \r\n        return temp \r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        dummy = ListNode(0)\r\n        dummy.next = head \r\n        pre = dummy\r\n        end = dummy \r\n        \r\n        while end.next:\r\n            count = 0\r\n            while count<2:\r\n                end = end.next\r\n                count+=1\r\n            if not end:break \r\n            start = pre.next \r\n            next = end.next \r\n            end.next = None \r\n            \r\n            pre.next = self.reverse(start)\r\n            \r\n            start.next = next \r\n            pre = start \r\n            end = pre \r\n        return dummy.next\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193142258","body":"**思路**  \r\n1.1 又是菜鸡的一天，好好学下递归\r\n\r\n**代码**\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head):\r\n        def getMedian(left, right):\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        \r\n        def buildTree(left, right):\r\n            if left == right:\r\n                return None\r\n            mid = getMedian(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n        \r\n        return buildTree(head, None)\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(nlogn)  \r\n1.2 空间复杂度 O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193267904","body":"**思路**  \r\n1.1 双指针假设有相交节点，则节点分别将A与B分割成长度a+c，b+c，那么相交节点一定在 a+c+b=b+c+a\r\n1.2 没有交点则A和B一直走到都指向None\r\n\r\n**代码**\r\n```python\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not headA or not headB:\r\n            return None \r\n        A = headA\r\n        B = headB\r\n        while A!=B:\r\n            if A!=None:\r\n                A = A.next \r\n            else:\r\n                A = headB\r\n\r\n            if B!=None:\r\n                B = B.next \r\n            else:\r\n                B = headA \r\n        return A\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193837746","body":"**思路**  \r\n142 https://leetcode.cn/problems/linked-list-cycle-ii/  \r\n1.1 快慢指针思路  \r\n\r\n**代码**\r\n```python\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return None\r\n        slow = head \r\n        fast = head \r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if fast==slow:\r\n                break \r\n        if not fast or not fast.next:\r\n            return None \r\n        fast = head \r\n        while slow!=fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return fast \r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195237560","body":"**思路**  \r\n146 https://leetcode-cn.com/problems/lru-cache/  \r\n1.1 只能看题解\r\n\r\n```python\r\n# node里面存储了key 和 value  \r\n\r\n# from collections import OrderedDict\r\n# class LRUCache(OrderedDict):\r\n\r\n#     def __init__(self, capacity):\r\n    \r\n#         self.capacity = capacity\r\n\r\n#     def get(self, key):\r\n    \r\n#         if key not in self:\r\n#             return - 1\r\n        \r\n#         self.move_to_end(key)\r\n#         return self[key]\r\n\r\n#     def put(self, key, value):\r\n        \r\n#         if key in self:\r\n#             self.move_to_end(key)\r\n#         self[key] = value\r\n#         if len(self) > self.capacity:\r\n#             self.popitem(last = False)\r\n\r\nclass Node:\r\n    def __init__(self,key,val,pre=None,next=None):\r\n        self.key = key\r\n        self.val = val\r\n        self.pre = None \r\n        self.next = None\r\nclass LRUCache:\r\n    def __init__(self, capacity):\r\n        self.capacity = capacity\r\n        self.cur = 0\r\n        self.hashmap = {}\r\n        self.dummy = Node(0,0)\r\n        self.tail = Node(0,0)\r\n        \r\n        self.dummy.next = self.tail\r\n        self.tail.pre = self.dummy\r\n    \r\n    def get(self, key):\r\n        if key in self.hashmap:\r\n            node = self.hashmap[key]\r\n            \r\n            node.pre.next = node.next\r\n            node.next.pre = node.pre \r\n            \r\n            temp = self.dummy.next\r\n            self.dummy.next = node\r\n            node.next = temp\r\n            \r\n            temp.pre = node\r\n            node.pre = self.dummy\r\n            return self.hashmap[key].val\r\n        else:\r\n            return -1\r\n    def put(self, key, value):\r\n        if key in self.hashmap:\r\n            self.hashmap[key].val = value\r\n            \r\n            node = self.hashmap[key]\r\n            node.pre.next = node.next\r\n            node.next.pre = node.pre\r\n            \r\n        else:\r\n            new = Node(key,value)\r\n            self.hashmap[key] = new\r\n            if self.cur>=self.capacity:\r\n                self.tail = self.tail.pre\r\n                self.tail.next = None\r\n                \r\n                del self.hashmap[self.tail.key]\r\n                self.cur -=1 \r\n            self.cur+=1\r\n        node = self.hashmap[key]\r\n        \r\n        temp = self.dummy.next\r\n        self.dummy.next = node\r\n        node.next = temp\r\n        \r\n        temp.pre = node\r\n        node.pre = self.dummy\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(1)  \r\n1.2 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196699630","body":"**思路**  \r\n104 https://leetcode-cn.com/problems/maximum-depth-of-binary-tree  \r\n\r\n**代码**\r\n```python\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        if root==None:\r\n            return 0\r\n        else:\r\n            left = self.maxDepth(root.left)\r\n            right= self.maxDepth(root.right)\r\n        return max(left,right)+1\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185468498","body":"## 思路\n\n1. Add two numbers from right to left, column by column, and record the carry.\n2. If carry > 0, add it to the next column.\n3. Add the result to the first position of the result list.\n4. Implement the loop until all digit in two numbers has been calculated, or carry = 0;\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1, carry = 0;\n        while (i >= 0 || k > 0 || carry > 0) {\n            int val1 = i < 0 ? 0 : num[i--];\n            int val2 = k % 10;\n            int sum = val1 + val2 + carry;\n            carry = sum / 10;\n            res.add(0, sum % 10);\n            k = k / 10;\n        }\n        return res;\n    }\n}\n```\n\nTime complexity: O(n), n is the greater length of the two numbers.\nSpace complexity: O(1), not include the space of output array.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186159091","body":"\n# Link\n\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\n\n## Idea_1\n\n1. Traverse the string for two times;\n2. Firstly, when going from left to right, we record the distance from index i to their last/previous target character(first target on their left): ```i - prev```;\n3. Secondly, when going from right to left, we record the distance form index i to their right previous target(first target on their right), and compared with original value in the array;\n4. Update the minimum distance of every node;\n\n\n## Code_1\n\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int n = S.length(), pos = -n, res[] = new int[n];\n        // 距离最左边的e的距离\n        for (int i = 0; i < n; ++i) {\n            if (S.charAt(i) == C) pos = i;\n            res[i] = i - pos;\n        }\n        // 倒序: 距离最右边的e的距离与之比较\n        for (int i = pos - 1; i >= 0; --i) {\n            if (S.charAt(i) == C)  pos = i;\n            res[i] = Math.min(res[i], pos - i);\n        }\n        return res;\n    }\n}\n```\n\n## Idea_2\n\n1. Use two pointer: ```slow``` and ```fast```.\n2. After finding the first target with ```fast``` on the right, write the distance of nodes on its left into the array, and store the index of this target as ```prev```.\n3. Continue the above step, compare the distance from the nodes to the previous target node and the next target node, update the array.\n\n\n\n## Code_2\n\n```java\nclass Solution {\n    // two pointer\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int i = 0, j = 0, prev = -1;;\n        while (i < len) {\n            // 找到右边的第一个e\n            while (j < len && s.charAt(j) != c )\n                j++;\n            if (j == len) break;    // 右边没有e了\n            \n            // 比较右边的e和左边的e哪个远\n            while (i <= j){\n                res[i] = Math.min(j-i, (prev==-1 ? len : i-prev));\n                i++;\n            }\n            prev = j++; // 记录前一个e的位置\n        }\n        // 若数组没填充完, 则填充, 距离左边e的距离即是结果\n        while (i < len) \n            res[i] = (prev==-1 ? i : i++ -prev);    \n        \n        return res;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(n), n is the length of the string.  \nSpace complexity: O(n), the length of output array.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186548391","body":"\n# Link\n\nhttps://leetcode.com/problems/design-a-stack-with-increment-operation/\n\n## Idea\n\n1. Use an array to store the increment, inc[i] means that from ```0 - i```, the element should add ```inc[i]```;\n2. While poping an element form the stack, the size of the stack decrease, and inc[i] should be update to 0; so we need to update the increment array;  \n3. Update the former: ```inc[i-1] += inc[i]```, because element from 0 to i-1 still should add inc[i], then update ```inc[i] = 0```;\n\n## Code\n\n```java\nclass CustomStack {\n    private int capacity;\n    private int[] inc;\n    Stack<Integer> s;\n    \n    // O(n), O(n)\n    public CustomStack(int maxSize) {\n        this.capacity = maxSize;\n        inc = new int[capacity];\n        s  = new Stack<>();\n    }\n    // O(1)\n    public void push(int x) {\n        if (s.size() < capacity)\n            s.push(x);\n    }\n    // O(1)\n    public int pop() {\n        if (s.isEmpty()) return -1;\n        \n        int i = s.size()-1;\n        if (i > 0)\n            inc[i-1] += inc[i];\n        int val = s.pop()+inc[i];\n        inc[i] = 0;\n        return val;\n    }\n    // O(1)\n    public void increment(int k, int val) {\n        int bound = Math.min(s.size(),k) - 1;\n        if (bound >= 0)\n            inc[bound] += val;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: Initialization: O(n); Others: O(1).\nSpace complexity: Initialization: O(n); Others: O(1).\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187440232","body":"\n## Link\n\nhttps://leetcode.com/problems/decode-string/\n\n## Idea_1\n\n1. Using Two Stack to sotre the number and decoded strings;\n2. While meeting digit or character, append it with varible ```count``` or ```res```;\n3. While meeting opening bracket```'['```, push digit and string into those two stack;\n4. While meeting closing bracket```']'```, pop the previous string  and count from the stack, decode current string for ```count``` times and append it to the previous string;\n\n## Code_1\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> in = new Stack<>();\n        Stack<String> stack = new Stack<>();\n        String res = \"\";\n        int i = 0, count = 0;\n        while (i < s.length()) {\n            char c = s.charAt(i++);\n            if (Character.isDigit(c))\n                count = count*10 + c - '0';\n            else if (c == '[') {\n                in.push(count);\n                stack.push(res);\n                res = \"\";\n                count = 0;\n            }\n            else if (Character.isAlphabetic(c))\n                res += c;\n            else if (c == ']') {\n                int cnt = in.pop();\n                StringBuilder temp = new StringBuilder(stack.pop());\n                for (int j = 0; j < cnt; j++) \n                    temp.append(res);\n                res = temp.toString();\n            }\n        }\n        return res;\n    }\n}\n```\n\n## Idea_2\n\n1. Using one stack to store everything;\n2. While meeting character instead of ```']'```, push it into the stack;\n3. While meeting ```']'```, pop the character from the stack;\n4. Use varible ```sb``` to store the substring until meet ```'['```;\n5. Then pop ```'['``` out, and use ```count``` to store the following digit;\n6. Decode the substring ```sb``` for ```count``` times and push it back to the stack;\n7. Pop the result from the stack;\n\n## Code_2\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()) {\n            if(c != ']') \n                stack.push(c); //push everything but ]\n            else {\n                //step 1: \n                    //if you find a closing ] then \n                    //retrieve the string it encapsulates\n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\n                    sb.insert(0, stack.pop());\n                String sub = sb.toString(); //this is the string contained in [ ]\n                stack.pop(); //Discard the '[';\n                //step 2: \n                    //after that get the number of\n                    // times it should repeat from stack\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek()))\n                    sb.insert(0, stack.pop());\n                int count = Integer.valueOf(sb.toString()); // this is the number\n                //step 3: \n                    //repeat the string within the [ ] count \n                    //number of times and push it back into stack\n                while(count > 0) {\n                    for(char ch : sub.toCharArray())  \n                        stack.push(ch);\n                    count--;\n                }\n            }\n        }\n        //final fetching and returning the value in stack \n        StringBuilder retv = new StringBuilder();\n        while(!stack.isEmpty())\n            retv.insert(0, stack.pop());\n        return retv.toString();\n    }\n}\n```\n\n## Idea_3\n\n1. Using recursion and global varible ```index```;\n2. While meeting digits, build the number ```count``` by iterating over the string ```s```;\n3. While meeting ```'['```, ignore it and recursively find the nested string ```temp```;\n4. Decode the current pattern ```count[temp]```;\n5. While meeting ```']'```, finished and return;\n   \n\n## Code_3\n\n```java\nclass Solution {\n    int index = 0;\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int num = 0;\n        String temp = \"\";\n        \n        while (index < s.length()) {\n            char ch = s.charAt(index++);\n            if (Character.isDigit(ch))\n                num = num*10 + ch - '0';\n            else if (ch == '['){\n                temp = decodeString(s);\n                for (int j = 0; j < num; j++)\n                    res.append(temp);\n                num = 0;\n            }\n            else if (Character.isAlphabetic(ch))\n                res.append(ch);  \n            else \n                break;\n                \n        }\n        return res.toString();\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(n), n is the length of decoded string.  \nSpace complexity: O(n), n is the length of decoded string. \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189097770","body":"\n## Link\n\nhttps://leetcode.com/problems/implement-queue-using-stacks/\n\n## Idea\n\n1. Use two stacks;\n2. While poping, we push all the elements from stack1 into the stack2, and find the first element.\n\n\n## Code\n\n```java\nclass MyQueue {\n    Stack<Integer> s;\n    Stack<Integer> ss;\n    public MyQueue() {\n        s = new Stack<>();\n        ss = new Stack<>();\n    }\n    \n    public void push(int x) {\n        s.push(x);\n    }\n    \n    public int pop() {\n        while (!s.isEmpty())\n            ss.push(s.pop());\n        int val = ss.pop();\n        while (!ss.isEmpty())\n            s.push(ss.pop());\n        return val;\n        \n    }\n    \n    public int peek() {\n        return s.get(0);\n    }\n    \n    public boolean empty() {\n        return s.isEmpty();\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: pop(): O(n), others: O(1).  \nSpace complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190379759","body":"\n## Link\n\nhttps://leetcode.com/problems/max-chunks-to-make-sorted-ii/\n\n## Idea\n\n1. Sort the array;\n2. Traverse the sorted and original array and compute their sum seperately, if the sum1 == sum2, the result plus 1;\n\n## Code\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        int res = 0, sum1 = 0, sum2 = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum1 += arr[i];\n            sum2 += sorted[i];\n            if (sum1 == sum2) res += 1;\n        }\n        return res;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(nlogn), sort the array need nlogn time.  \nSpace complexity: O(n), clone the original array need n space. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191405197","body":"\n## Link\n\nhttps://leetcode.com/problems/rotate-list/\n\n## Idea\n\n \n 1. Close the list into the ring.\n 2. Traverse the list and get the length of it.\n 3. Find the previous node of the last k % length node from the end of the list. \n 4. Break the ring at the position: after the new tail or before the new head.\n \n\n## Code\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(-1,head), curr = dummy;\n        int len = 0;\n        while (curr.next != null) {\n            len++;\n            curr = curr.next;\n        }\n        curr.next = head;   // close the list into the ring\n        curr = dummy;\n        for (int i = 0; i < len-k%len; i++) \n            curr = curr.next;\n        head = curr.next;\n        curr.next = null;\n        return head;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(n), n is the length of the list.  \nSpace complexity: O(1). \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192623209","body":"\n### Link\n\nhttps://leetcode.com/problems/swap-nodes-in-pairs/\n\n### Clarifications / Constraints\n\n1. number of nodes;\n\n### Idea_1\n\n1. Recursion;\n2. Store the recursion result with node ```ret```;\n3. Swap the current pair;\n4. The tail point to the ```ret```;\n5. return the new head;\n\n\n#### Code\n\n```java\n// recursion: O(n), O(n)\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode ret = swapPairs(head.next.next);\n        ListNode nxt = head.next;\n        head.next = ret;\n        nxt.next = head;\n        return nxt;\n        \n    }\n} \n```\n\n#### Complexity\n\nTime complexity: O(n).   \nSpace complexity: O(n).  \n\n\n### Idea_2\n\n1. Iteration;\n2. Use the ```dummy``` node, because the head node changed;\n3. Store the next pair pointer and the prev pointer of the current pair;\n4. swap the current pair;\n\n\n#### Code\n\n```java\n// Iteration: O(n), O(1)\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(-1, head);\n        ListNode prev = dummy, curr = head, nxt = null;\n        while (curr != null && curr.next != null) {\n            nxt = curr.next.next;\n            prev.next = curr.next;\n            curr.next.next = curr;\n            curr.next = nxt;\n            prev = curr;\n            curr = nxt;\n        }\n        return dummy.next;\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(n).   \nSpace complexity: O(1).\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193132973","body":"\n## Link\n\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/\n\n## Idea_1\n\n \n 1. Using inorder traversal to build the tree.\n 2. Store the values in a list.\n 3. Construct the tree.\n \n\n## Code\n\n```java\nclass Solution {\n    List<Integer> arr = new LinkedList<>();\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        while (head != null) {\n            arr.add(head.val);\n            head = head.next;\n        }\n        return build(0, arr.size()-1);    \n    }\n    public TreeNode build(int l, int r) {\n        if (l > r) return null;\n        int mid = l + (r-l)/2;\n        TreeNode root = new TreeNode(arr.get(mid));\n        root.left = build(l, mid-1);\n        root.right = build(mid+1, r);\n        return root;\n    }\n}  \n```\n\n\n## Complexity\n\nTime complexity: O(n), traverse all nodes.  \nSpace complexity: O(n), store all values need n size list. \n\n\n## Idea_2\n\n \n 1. Using Recursion.\n 2. Find the middle of every sub list -> balanced BST.\n 3. Construct the tree.\n \n\n## Code\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        ListNode mid = findMid(head);\n        TreeNode root = new TreeNode(mid.val);\n        if (head == mid) return root;\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(mid.next);\n        return root;\n    }\n    public ListNode findMid(ListNode head) {\n        ListNode slow = head, fast = head, prev = null;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        if(prev != null) prev.next = null; // split the first and second list\n        return slow;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(nlogn), build tree need logn times, find mid need n time.    \nSpace complexity: O(height), the recursion stack needs height. \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193260221","body":"\n### Link\n\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/\n\n### Clarifications / Constraints\n\n1. head != null\n2. intersection not exist ?\n3. one list is the sublist of another one?\n\n### Idea_1\n\n1. Use two pointer pA, pB start with two list headA, headB seperately;\n2. Set pointer pA to point at headA, set pointer pB to point at headB;\n3. While pA != pB, move to the next node;\n4. If pA == null, pA = headB, if pB == null, pB = headA;\n5. Then both of pA and pB move the same distance: lenA + lenB - the public;\n\n#### Code\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(n+m), n and m are the length of lsit1 and list2.  \nSpace complexity: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194077990","body":"\n\n### Link\n\nhttps://leetcode.com/problems/linked-list-cycle-ii/\n\n### Clarifications / Constraints\n\n1. no cycle;\n2. length of list: null ?\n\n### Idea\n\n1. Use two pointer(slow-fast) to detect the cycle;\n2. If has the cycle, slow-fast will intersect at the cycle, at this time, set fast at  head, and change the step size to two;\n3. Then slow-fast will intersect at the position of the starting point of the cycle.\n\n\n#### Code\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null)  return null;\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast)\n                break;\n        }\n        if (slow != fast) return null;\n        fast = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(n)  \nSpace complexity: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195483940","body":"\n### Link\n\nhttps://leetcode.com/problems/lru-cache/\n\n\n### Idea\n\n1. Use Hash table and linked list.\n\n\n#### Code\n\n```java\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\n    int capacity;\n    public LRUCache(int capacity) {\n// public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) \n// 这里的 accessOrder 默认是为false，如果要按读取顺序排序需要将其设为 true\n// initialCapacity 代表 map 的 容量，loadFactor 代表加载因子 (默认即可)\n       super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity;\n        // 默认在 LinkedHashMap 里返回false\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(1)  \nSpace complexity: O(n) \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196302672","body":"\n### Link\n\nhttps://leetcode.com/problems/maximum-depth-of-binary-tree/\n\n### Clarifications / Constraints\n\n1. root: depth =1\n2. root: null -> return 0\n\n### Idea\n\n1. DFS\n\n\n#### Code\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return dfs(root, 1);\n    \n    }\n    public int dfs(TreeNode root, int depth) {\n        if (root == null) return depth-1;\n        int left = dfs(root.left, depth+1);\n        int right = dfs(root.right, depth+1);\n        return Math.max(left, right);\n    }\n}\n```\n\n#### Complexity\n\nTime complexity: O(n), traverse all nodes.  \nSpace complexity: O(height), recursion stack need height space. the worst is n, the best is logn. \n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185484818","body":"## 思路\r\n\r\n1、创建一个链表数组用来存放结果  \r\n2、把数组和数字相同位数的值进行相加。直到全部计算完  \r\n3、每次计算完的数字添加在数组头部  \r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> arr = new LinkedList<>();\r\n        int index = num.length - 1;\r\n        int temp = 0;\r\n        while (index >= 0 || k > 0 || temp > 0) {\r\n            int temp_data = k % 10 + temp;\r\n            k = k / 10;\r\n            if (index >= 0) {\r\n                temp_data += num[index];\r\n                index--;\r\n            }\r\n            arr.addFirst(temp_data % 10);\r\n            temp = temp_data / 10;\r\n        }\r\n        return arr;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185682411","body":"## 思路\r\n\r\n先从左往右进行遍历。  \r\n然后从右往左遍历，记录最小的值\r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        // 从左往右遍历\r\n        for (int i = 0, index = -n; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = i - index;\r\n\r\n        }\r\n        \r\n        // 从右往左遍历\r\n        for (int i = n - 1, index = 2 * n; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = Math.min(res[i], index - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186532017","body":"\r\n## 思路\r\n\r\n通过根据数组实现栈的思路\r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    private int[] arr;\r\n    private int index = -1;\r\n    private int limit = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        limit = maxSize - 1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (index == limit){\r\n            return;\r\n        }\r\n        index++;\r\n        arr[index] = x;\r\n    }\r\n\r\n    public int pop() {\r\n        if (index == -1){\r\n            return -1;\r\n        }\r\n        int ans = arr[index];\r\n        index--;\r\n        return ans;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int min = Math.min(k, index+1);\r\n        for (int i = 0; i < min; i++) {\r\n            arr[i] = arr[i] + val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187309867","body":"## 前置知识\r\n\r\n- 栈\r\n\r\n\r\n\r\n## 思路\r\n\r\n一个栈用来存放数字  \r\n一个栈用来存放字符串\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder str = new StringBuilder();\r\n        Stack<Integer> num = new Stack<>();\r\n        Stack<StringBuilder> str_sta = new Stack<>();\r\n        int k = 0;\r\n        for (char c : s.toCharArray()) {\r\n            if (Character.isDigit(c)) {\r\n                k = k * 10 + (c - '0');\r\n            } else if (c == '[') {\r\n                num.push(k);\r\n                k = 0;\r\n                str_sta.push(str);\r\n                str = new StringBuilder();\r\n            } else if (c == ']') {\r\n                StringBuilder temp = str_sta.pop();\r\n                for (int i = num.pop(); i > 0; i--) {\r\n                    temp.append(str);\r\n                }\r\n                str = temp;\r\n            } else {\r\n                str.append(c);\r\n            }\r\n\r\n        }\r\n        return str.toString();\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(kn)\r\n- 空间复杂度： O(num(k) + num(char))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188935888","body":"\r\n## 思路\r\n一个栈stackpush，一个栈stackpop。只有当stackpop为空时，可以把stackpush里面的数字进入到stackpop栈 ，并且需要一次性全部入栈\r\nstackpop用于出栈  \r\nstackpush用于进栈  \r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    private Stack<Integer> stackpush;\r\n    private Stack<Integer> stackpop;\r\n\r\n    public MyQueue() {\r\n        stackpush = new Stack<>();\r\n        stackpop = new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        stackpush.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if (!stackpop.isEmpty()) {\r\n            return stackpop.pop();\r\n        }\r\n        while (!stackpush.isEmpty()) {\r\n            stackpop.push(stackpush.pop());\r\n        }\r\n        return stackpop.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if (!stackpop.isEmpty()) {\r\n            return stackpop.peek();\r\n        }\r\n        while (!stackpush.isEmpty()) {\r\n            stackpop.push(stackpush.pop());\r\n        }\r\n        return stackpop.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return stackpush.isEmpty() && stackpop.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190317364","body":"\r\n## 思路\r\n1、只要数组的数比栈顶大，则入栈\r\n2、数组的数比栈顶小，则出栈，同时继续比较数组与栈顶。依次继续\r\n3、栈的大小就是最多的块数\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        stack.push(arr[0]);\r\n        for (int i = 1; i < arr.length;i++) {\r\n            if (!stack.isEmpty() && arr[i] >= stack.peek()){\r\n                stack.push(arr[i]);\r\n            }else {\r\n                int curMax = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(curMax);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191407764","body":"\r\n## 思路\r\n1、先统计链表的长度  \r\n2、计算实际需要移动的次数  \r\n3、使用快慢指针进行移动  \r\n慢指针为头，快指针的next连接到原先的头，然后再把慢指针的next指向null。  \r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null) return head;\r\n        int count = 0;\r\n        ListNode now = head;\r\n\r\n        // 统计链表长度\r\n        while (now != null) {\r\n            now = now.next;\r\n            count++;\r\n        }\r\n        // 计算实际需要移动的次数\r\n        k = k % count;\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        // 使用快慢指针进行实现\r\n        while (fast.next != null) {\r\n            if (k-- <= 0) {\r\n                slow = slow.next;\r\n            }\r\n            fast = fast.next;\r\n        }\r\n        fast.next = head;\r\n        ListNode res = slow.next;\r\n        slow.next = null;\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192504553","body":"\r\n\r\n## 思路\r\n\r\n由于所有的两两交换逻辑都是一样的，因此我们只要关注某一个两两交换如何实现就可以了。\r\n\r\n因为要修改的是二个一组的链表节点，所以需要操作 4 个节点。例如：将链表 A -> B 进行逆转，我们需要得到 A,B 以及 A 的前置节点 preA,以及 B 的后置节点 nextB\r\n\r\n原始链表为 preA -> A -> B -> nextB，我们需要改为 preA -> B -> A -> nextB，接下来用同样的逻辑交换 nextB 以及 nextB 的下一个元素。\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) return head;\r\n        ListNode preNode = new ListNode(-1, head);\r\n        ListNode res;\r\n        preNode.next = head;\r\n        res = head.next;\r\n        ListNode firstNode = head;\r\n        ListNode secondNode;\r\n        ListNode nextNode;\r\n        while (firstNode != null && firstNode.next != null) {\r\n            secondNode = firstNode.next;\r\n            nextNode = secondNode.next;\r\n            firstNode.next = nextNode;\r\n            secondNode.next = firstNode;\r\n            preNode.next = secondNode;\r\n            preNode = firstNode;\r\n            firstNode = nextNode;\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193114962","body":"## 思路\r\n因为本题是升序的链表，所以先找到中间节点作为二叉树的根节点。  \r\n根节点左边的数都小于根节点  \r\n根节点右边的数都大于根节点\r\n循环以上步骤\r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        // 如果链表为空，则直接返回null\r\n        if (head == null) return null;\r\n        return dfs(head, null);\r\n    }\r\n\r\n    public TreeNode dfs(ListNode head, ListNode tail) {\r\n        if (head == tail) return null;\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        // 快慢指针，快指针走两步，慢指针走一步,\r\n        while (fast != tail && fast.next != tail) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        // 此时慢指针刚好走在链表的中点\r\n        TreeNode root = new TreeNode(slow.val);\r\n        // 比父节点小的在左边\r\n        root.left = dfs(head, slow);\r\n        // 比父节点大的在右边\r\n        root.right = dfs(slow.next, tail);\r\n        return root;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(logn)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193320802","body":"\r\n## 思路\r\n\r\n我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。\r\n\r\n如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode p1 = headA;\r\n        ListNode p2 = headB;\r\n        // 如果P1和P2不想交的话，到时P1=null.p2=null。此时退出循环。\r\n        while (p1 != p2) {\r\n            // p1 走一步，如果走到 A 链表末尾，转到 B 链表\r\n            if (p1 == null) {\r\n                p1 = headB;\r\n            } else {\r\n                p1 = p1.next;\r\n            }\r\n            // p2 走一步，如果走到 B 链表末尾，转到 A 链表\r\n            if (p2 == null) {\r\n                p2 = headA;\r\n            } else {\r\n                p2 = p2.next;\r\n            }\r\n        }\r\n        return p1;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194002665","body":"\r\n\r\n## 思路\r\n\r\n使用快慢指针，快指针走两步，慢指针走一步。第一次如果没有相遇的话，说明这个链表是无环链表。  \r\n一个指针指向head节点，一个指针指向相遇的节点，然后一直走，直到两者相遇则是入环的第一个节点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next == null || head.next.next == null) {\r\n            return null;\r\n        }\r\n        ListNode slow = head.next;\r\n        ListNode fast = head.next.next;\r\n        while (slow != fast) {\r\n            if (fast.next == null || fast.next.next == null) {\r\n                return null;\r\n            }\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        fast = head;\r\n        while (fast != slow) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195447536","body":"\r\n## 思路\r\n双指针+哈希表\r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass LRUCache {\r\n    class DLinkedNode {\r\n        int key, value;\r\n        DLinkedNode prev, next;\r\n\r\n        public DLinkedNode() {\r\n\r\n        }\r\n\r\n        public DLinkedNode(int _key, int _value) {\r\n            key = _key;\r\n            value = _value;\r\n        }\r\n    }\r\n\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<>();\r\n    private int size, cap;\r\n    private DLinkedNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        size = 0;\r\n        cap = capacity;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) return -1;\r\n        moveToHead(node);\r\n        return node.value;\r\n\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            cache.put(key, newNode);\r\n            addToHead(newNode);\r\n            ++size;\r\n            if (size > cap) {\r\n                DLinkedNode removeTail = removeTail();\r\n                cache.remove(removeTail.key);\r\n                size--;\r\n            }\r\n        } else {\r\n            node.value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n\r\n    private void addToHead(DLinkedNode node) {\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196682539","body":"## 思路\r\n利用二叉树的层次遍历。每遍历完一次记一次。累计总和就是深度。\r\n\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\r\n        if (root == null) return 0;\r\n        int depth = 0;\r\n        queue.offer(root);\r\n        while (!queue.isEmpty()){\r\n            depth++;\r\n            int len = queue.size();\r\n            for (int i = 0;i < len; i++){\r\n                TreeNode node = queue.poll();\r\n                if (node.left != null) queue.offer(node.left);\r\n                if (node.right != null) queue.offer(node.right);\r\n            }\r\n        }\r\n        return depth;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(logn)$\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185485651","body":"```go\nfunc addToArrayForm(num []int, k int) (ans []int) {\n    for i := len(num) - 1; i >= 0; i-- {\n        sum := num[i] + k%10\n        k /= 10\n        if sum >= 10 {\n            k++\n            sum -= 10\n        }\n        ans = append(ans, sum)\n    }\n    for ; k > 0; k /= 10 {\n        ans = append(ans, k%10)\n    }\n    reverse(ans)\n    return\n}\n\nfunc reverse(num []int) {\n    for i, n := 0, len(num); i < n/2; i++ {\n        num[i], num[n-1-i] = num[n-1-i], num[i]\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190278600","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185496245","body":"### 思路\n\n本来一开始想直接使用 JavaScript 的 api 的：\n1. 计算 sum 数组的值\n2. 把值和 k 相加\n3. 把值通过 `String(number).split('').map(n => Number(n))` 转换回数组\n\n出现的问题是 `IEEE754` 编码的数字会出现精度丢失的问题\n\n所以还是老老实实的使用逐位相加的方法\n\n1. 把数组中的位置从高到底相加\n2. 如果结果大于 10 的话，把进位 1 加入下一位的计算\n\n### 代码\n\n```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (let k; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n)\n* 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186141162","body":"### 思路\n\n* 把 c 在 s 字符串的位置放在一个新开辟的数组里\n* 遍历 s 字符串，把结束输入到数组中\n\n### 代码\n\n```js\nvar shortestToChar = function(s, c) {\n  const sArr = s.split('');\n  const cIndexArr = [];\n  sArr.forEach((i, index) => {\n    if (i === c) {\n      cIndexArr.push(index);\n    }\n  });\n  const res = Array(s.length).fill(Infinity);\n  sArr.forEach((i, index) => {\n    if (i === c) {\n      res[index] = 0;\n      return;\n    }\n    for (const cIndex of cIndexArr) {\n      const dis = Math.abs(cIndex - index);\n      if (dis >= res[index]) {\n        break;\n      }\n      res[index] = dis;\n    }\n  });\n  return res;\n};\n```\n\n### 复杂度\n\n* 时间复杂度 O(N^2)\n* 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186441685","body":"### 思路\n\n- 使用数组模拟 stack\n\n### 代码\n\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.stack = [];\n  this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length <= this.maxSize - 1) {\n    this.stack.unshift(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.stack.length === 0) {\n    return -1;\n  }\n  const elemrnt = this.stack.shift();\n  return elemrnt;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const stackLength = this.stack.length;\n  if (stackLength === 0) {\n    return [];\n  }\n this.stack = this.stack.map((i, index) => {\n    if (stackLength - index <= k ) {\n      return i + val;\n    }\n   return i;\n });\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度\n\n- Time：O(N)\n- Space：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187630436","body":"var decodeString = function(s) {\n    let numStack = [];          \n    let strStack = [];            \n    let num = 0, result = '';\n\n    for(let i = 0; i < s.length; i++) {\n        const item = s[i];\n\n        if(!isNaN(item)) {              // 判断是数字时\n            num = num * 10 + parseInt(item);\n        } else if(item === '[') {\n            strStack.push(result);\n            result = '';\n            numStack.push(num);\n            num = 0;\n        } else if(item === ']') {\n            const repeatTimes = numStack.pop();         // 从栈中获取次数\n            result = strStack.pop() + result.repeat(repeatTimes);\n        } else {\n            result += item;\n        }\n    }\n    return result;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189196478","body":"\tvar MyQueue = function () {\n\t  this.stack1 = [];\n\t  this.stack2 = [];\n\t};\n\t\n\tMyQueue.prototype.push = function (x) {\n\t  this.stack1.push(x);\n\t};\n\t\n\tMyQueue.prototype.pop = function () {\n\t  if (this.stack2.length > 0) {\n\t    return this.stack2.pop();\n\t  }\n\t\n\t  while (this.stack1.length > 0) {\n\t    this.stack2.push(this.stack1.pop());\n\t  }\n\t\n\t  return this.stack2.pop();\n\t};\n\t\n\tMyQueue.prototype.peek = function () {\n\t  let tmp = this.pop();\n\t  this.stack2.push(tmp);\n\t  return tmp;\n\t};\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192712314","body":"\nvar swapPairs = function(head) {\n    if (head === null|| head.next === null) {\n        return head;\n    }\n    const newHead = head.next;\n    head.next = swapPairs(newHead.next);\n    newHead.next = head;\n    return newHead;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193142307","body":"```js\r\nvar sortedListToBST = function(head) {\r\n    if (head === null) return null;\r\n    return help([head], 0, countSize(head)-1);\r\n};\r\n\r\nfunction countSize(head) {\r\n    let count = 0;\r\n    while (head !== null) {\r\n        count++;\r\n        head = head.next;\r\n    }\r\n    return count;\r\n}\r\n\r\nfunction help(arr, left, right) {\r\n    if (left > right) return null;\r\n    let mid = Math.floor((left + right) / 2);\r\n    let leftNode = help(arr, left, mid-1);\r\n    let node = new TreeNode(arr[0].val);\r\n    arr[0] = arr[0].next;\r\n    let rightNode = help(arr, mid+1, right);\r\n    node.left = leftNode;\r\n    node.right = rightNode;\r\n    return node;\r\n}\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194172361","body":"## 题解\n```js\nvar detectCycle = function(head) {\n    const visited = new Set();\n    while (head !== null) {\n        if (visited.has(head)) {\n            return head;\n        }\n        visited.add(head);\n        head = head.next;\n    }\n    return null;\n};\n```\n\n## 复杂度\n* 时间复杂度: O(N)\n* 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185508439","body":"# 989.Add to Array-Form of Integer\n\n**思路:**\n\n自己想的思路和leetcode上高赞答案差不多，但是实现起来，发现他的更优雅，果断使用他的实现思路。优雅，真的太优雅了！！！\n1. 不要用for循环，因为你不知道num,k那个长度更长，如果一开始将k转为数组来比较长度就太不优雅了！！！所以用while()\n2. 用LinkedList不要用ArrayList因为底层为链表实现的LinkedList可以头插\n3. 数组的每一位都与K整体相加，除10就是K的最新值参与下一次遍历，不用考虑进位问题\n4. 把数组相加的问题转化为对最新值处理问题，不用考虑长度和位数\n\n```java\npublic class AddToArrayFormOfInteger {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        int lastNum = k;\n        int i = len - 1;\n        LinkedList<Integer> result = new LinkedList<>();\n        while (i >= 0 || lastNum > 0) {\n            if (i >= 0)\n                lastNum += num[i];\n            //取模加入到数组\n            result.addFirst(lastNum % 10);\n            //更新最新值\n            lastNum /= 10;\n            i--;\n        }\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186078726","body":"# 821. Shortest Distance to a Character\n\n**思路：**\n最无脑的思路\n1. 记录c的下标存入数组\n2. 遍历相减取最小绝对值\n\n```java\npublic int[] shortestToChar(String s, char c) {\n        char[] chars = s.toCharArray();\n        ArrayList<Integer> index = new ArrayList<>();\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c){\n                index.add(i);\n            }\n\n        }\n        int[] ret = new int[chars.length];\n        int minAbs = 0;\n        for (int i = 0; i < chars.length; i++) {\n            for (int j = 0; j < index.size(); j++) {\n                if (j ==0){\n                    //再次初始化\n                    minAbs = Math.abs(index.get(j) - i);\n                    continue;\n                }\n                minAbs = Math.min(Math.abs(index.get(j) - i), minAbs);\n\n            }\n            ret[i] = minAbs;\n\n        }\n        return ret;\n\n    }\n```\n>时间复杂度： O(n^2)\n> \n>空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186499905","body":"# 1381. Design a Stack With Increment Operation\n\n**思路：**\n1. 用数组来存储数据\n2. 用指针模拟栈的操作\n```java\npublic class CustomStack {\n\n    int[] stack;\n    int index;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        index = 0;\n    }\n\n    public void push(int x) {\n        if(index < stack.length){\n            stack[index]=x;\n            index ++;\n        }\n    }\n\n    public int pop() {\n        int ret = index - 1 <0? -1:stack[index - 1];\n        if (ret != -1){\n            index --;\n        }\n        return ret;\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, index);\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for (int i = 0; i < index; i++) {\n            if (i == index -1){\n                sb.append(stack[i]);\n            }else {\n                sb.append(stack[i]+\",\");\n            }\n\n\n        }\n        sb.append(\"]\");\n        return sb.toString();\n        //return Arrays.toString(stack);\n    }\n}\n```\n>时间复杂度：O(n)\n>空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187301558","body":"# 394. Decode String\n**思路:**\n1. 栈括号匹配处理小规模事件\n2. 递归调用处理整体事件\n```java\npublic String decodeString(String s) {\n        Stack<Integer> brackets = new Stack<>();\n        char[] chars = s.toCharArray();\n        char leftBracket = '[';\n        char rightBracket = ']';\n        //以\"3[a211[c]]\"为例，拿到\"a2[c]\"的位置，处理成\"3[acc]\"递归处理\n        //左括号位置确定倍数\n        Integer leftBracketIndex = -1;\n        //右括号位置确定括号内的字符\n        Integer rightBracketIndex = -1;\n\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == leftBracket) {\n                brackets.push(i);\n            }\n            if (chars[i] == rightBracket) {\n                leftBracketIndex = brackets.pop();\n                rightBracketIndex = i;\n                break;\n            }\n        }\n        if (leftBracketIndex == -1) {\n            return s;\n        } else {\n            StringBuilder times = new StringBuilder();\n            for (int i = leftBracketIndex -1; i >= 0; i--) {\n                if (chars[i] <48 || chars[i] >57){\n                    break;\n                }\n                times.append(chars[i]);\n            }\n            StringBuilder reverse = times.reverse();\n            int time = Integer.valueOf(reverse.toString());\n\n            StringBuilder tempString = new StringBuilder();\n            StringBuilder timedString = new StringBuilder();\n            tempString.append(chars, leftBracketIndex + 1, rightBracketIndex - (leftBracketIndex + 1));\n            for (int i = 0; i < time; i++) {\n                timedString.append(tempString);\n            }\n            StringBuilder sBuilder = new StringBuilder();\n\n            for (int i = 0; i < chars.length; i++) {\n                int i1 = leftBracketIndex - String.valueOf(time).length();\n                if (i1 < i && i <= rightBracketIndex) {\n\n                } else if (i1 == i) {\n                    sBuilder.append(timedString);\n                } else {\n                    sBuilder.append(chars[i]);\n                }\n            }\n            s = sBuilder.toString();\n            return decodeString(s);\n        }\n\n    }\n```\n>时间复杂度：O(n^2)\n>空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188901199","body":"# 232. Implement Queue using Stacks\n**思路:**\n1. 用两个栈模拟队列操作\n```java\npublic class MyQueue {\n    private Stack<Integer> stack;\n    private Stack<Integer> tempStack;\n    public MyQueue() {\n        stack = new Stack<>();\n        tempStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack.push(x);\n    }\n\n    public int pop() {\n        int popInt = 0;\n        while (stack.size() != 0){\n            if (stack.size() == 1){\n                popInt =  stack.pop();\n            }else {\n                tempStack.push(stack.pop());\n            }\n\n        }\n        while (tempStack.size() != 0){\n            stack.push(tempStack.pop());\n        }\n        return popInt;\n    }\n\n    public int peek() {\n        int peekInt = 0;\n        while (stack.size() != 0){\n            if (stack.size() == 1){\n                peekInt =  stack.peek();\n            }\n            tempStack.push(stack.pop());\n\n        }\n        while (tempStack.size() != 0){\n            stack.push(tempStack.pop());\n        }\n\n        return peekInt;\n    }\n\n    public boolean empty() {\n        return stack.empty();\n    }\n\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        while (stack.size() != 0){\n\n            tempStack.push(stack.pop());\n\n        }\n        while (tempStack.size() != 0){\n            if (tempStack.size() == 1){\n                sb.append(tempStack.peek());\n            }else {\n                sb.append(tempStack.peek()).append(\",\");\n            }\n            stack.push(tempStack.pop());\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n}\n```\n>时间复杂度 O(n)\n>空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190295429","body":"# 768. Max Chunks To Make Sorted II\n**Thinking:**\n1. Assuming there are already those maximum partitions, what features are in these partitions?\n   1. The minimum value in the latter partition is greater than the maximum value in the previous partitions.\n   2. based on above,we have a stack storage the biggest number in each partition and ensure the condition above.\n2. How could we make it?\n   1. iterate array,if `arr[i] >= stack.top()`,`arr[i]` can be one of the latter partition. \n   2. if not, compare to each number in stack if the number bigger than `arr[i]`: `stack.pop()`,till any number is smaller,each `stack.pop()`means partitions which the numbers represent has been merged\n```java\npublic class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int currMax = arr[0];\n        Stack<Integer> stack = new Stack<>();\n        stack.push(arr[0]);\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] >= stack.peek()){\n                stack.push(arr[i]);\n                currMax = arr[i];\n            }else {\n                stack.pop();\n                while (!stack.empty()){\n                    if (arr[i]<stack.peek()){\n                        stack.pop();//merge\n                        break;\n                    }\n                    stack.push(currMax);\n                }\n                if (stack.empty()){\n                    stack.push(currMax);\n                }\n            }\n        }\n\n        return stack.size() == 0? 1 : stack.size();\n    }\n\n}\n```\n> Time Complexity O(n^2)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191665012","body":"# 61. Rotate List\n**Thinking:**\n1. 链表尾部向前数k个元素作为头，原来的头接到原来的尾上\n2. 如果需要旋转必须将单向链表收尾相连成循环链表，便于断开时形成新的链表\n\n```java\n//code\npublic ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        int count = 1; // 同于统计总节点数\n        ListNode tempHead =head;\n        while (tempHead.next != null){\n        count++;//初始化总节点数\n        tempHead = tempHead.next;//初始化链表尾\n        }\n        k %= count;//取模\n\n        if (k == 0) return head;\n        //以上都不满足开始旋转\n        tempHead.next = head; //链表收尾相连\n        for (int i = 0; i < count - k; i++) {\n        tempHead = tempHead.next; //从链表尾开始向后数count - k -1个也就是向前数k个就是新的节点\n        }\n\n        ListNode newHead = tempHead.next;\n        tempHead.next = null;\n        return newHead;\n        }\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192718394","body":"# 24. Swap Nodes in Pairs\n**Thinking:**\n1. 递归\n2. 虚拟头节点\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        ListNode cur = head;\n        while (cur != null && cur.next != null){\n            pre.next = cur.next;\n            cur.next = cur.next.next;\n            pre.next.next = cur;\n\n            pre = cur;\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193145243","body":"# 109. Convert Sorted List to Binary Search Tree\n**Thinking:**\n1. 二分法，快慢指针\n\n```java\npublic class Solution {\n    //二分法，快慢指针\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n        ListNode fast = head, slow = head, pre = null;\n        while (fast != null && fast.next != null){\n            fast = fast.next.next;\n            pre = slow;\n            slow = slow.next;\n        }\n        //分割root节点和左右链表\n        pre.next = null;\n        ListNode rightList = slow.next;\n        TreeNode root = new TreeNode(slow.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(rightList);\n        return root;\n    }\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193305034","body":"# 160. Intersection of Two Linked Lists\n**Thinking:**\n 1. 若相交必在短链表处\n 2. 同步A链(长)和B链(短)遍历位置至B链head处,在同时向后遍历查找相交点\n >同步遍历方法\n >a + b = b + a;\n> 同时在A head处和B head处遍历长度 a+b,最终会在b head处同步遍历位置\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        //ListNode countHead = headA;\n        ////常规思路处理:\n        ////计算 a+b\n        //while (countHead.next != null){\n        //    countHead = countHead.next;\n        //}\n        //countHead.next = headB;\n        //\n        //ListNode pA = headA;\n        //ListNode pB = headB;\n        //while (countHead.next != null){\n        //    //同步到B head位置\n        //    pA = pA == null ? headB: pB.next;\n        //    pB = pB == null ? pA: pB.next;\n        //}\n        ////如果有相交点会在pA = pB处相交,如果没有,则会在链尾相交\n        //while (pA != pB){\n        //    pA = pA.next;\n        //    pB = pB.next;\n        //}\n        //标准思路处理\n        if (headA == null || headB == null) return null;\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194131535","body":"# Problem Name\n**Thinking:**\n 1. 快指针比慢指针快一格,且有环的情况下,快慢指针一定会相遇\n 2. 三变量\n > 1. x = 链表头到环入口的距离\n > 2. y = 环入口到相遇的距离\n > 3. z = 相遇到环入口的距离\n slow = x + y\n fast = x + n(y + z) +y\n 2slow = fast\n 2(x + y) = x + n(y + z) +y\n x + y = n(y + z)\n x = n(y + z) -y\n x = (n - 1)(y + z) + z\n (n - 1)(y + z)相当于不断在转圈\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        //设快慢指针\n        ListNode fast = head;\n        ListNode slow = head;\n        //退出循环,两步两步跳,注意next也不为空\n        while ((fast != null && fast.next != null) ){\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow){\n                ListNode index1 = head;\n                ListNode index2 = fast;\n                while (index1 != index2){\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n\n\n        return null;\n\n    }\n}\n```\n> Time  Complexity O(n**2)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195560862","body":"# 146. LRU Cache\n**Thinking:**\n> 1. 看了题目解析，具体实现不是很难，里边很多思想值得学习。\n> 2. LRU 思想既要保证查询快，又要保证插入删除快，hash表+双向链表，只能是双列集合，一个用于快速确定位置，一个用于快速增删，具体实现LinkedHashMap才是要学习的。\n\n```java\npublic class LRUCache {\n    int capacity;\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1;\n        }\n        makeRecently(key);\n        return cache.get(key);\n    }\n\n    public void put(int key, int value) {\n        //key exists,replace value\n        if (cache.containsKey(key)) {\n            //modify value\n            cache.put(key, value);\n            makeRecently(key);\n            return;\n        }\n        if (cache.size() >= this.capacity) {\n            Integer oldestKey = cache.keySet().iterator().next();\n            cache.remove(oldestKey);\n        }\n        cache.put(key, value);\n\n    }\n\n    public void makeRecently(int key) {\n        //获取到node\n        int val = cache.get(key);\n        //删除key,重新尾插\n        cache.remove(key);\n        cache.put(key, val);\n\n    }\n\n}\n```\n> Time  Complexity O(1)\n> Space Complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196134306","body":"# 104. Maximum Depth of Binary Tree\n**Thinking:**\n递归\n**tag: DFS**\n1. 找出终止条件: 当前节点为空\n2. 找出返回值: 节点为空返回0，节点不为空分别求左右节点最大值在加1表示当前节点的高度并返回\n3. 某层的执行过程: 见返回值部分\n\n```java\npublic class Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null){\n            return 0;\n        }else {\n            int left = maxDepth(root.left);\n            int right = maxDepth(root.right);\n            return Math.max(left,right) + 1;\n        }\n\n    }\n\n}\n```\n> Time  Complexity O(n)\n> Space Complexity O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185520837","body":"## 思路\r\n\r\n> + k作为位数累加,进位\r\n\r\n##代码\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\ti := len(num) - 1\r\n\tfor i >= 0 || k > 0 {\r\n\t\tif i > 0 && k > 0 {\r\n\t\t\tsum := num[i] + k%10\r\n\t\t\tnum[i] = sum\r\n\t\t\tk = k / 10  // drop the last element of k\r\n\r\n\t\t\tif sum > 9 {\r\n\t\t\t\tnum[i] = sum % 10\r\n\t\t\t\tk++ //  add carry(1) to k\r\n\t\t\t}\r\n\t\t\ti--\r\n\t\t} else if i >= 0 {\r\n\t\t\tbreak\r\n\t\t} else {\r\n\t\t\tnum = append([]int{k % 10}, num...)\r\n\t\t}\r\n\t}\r\n\r\n\treturn num\r\n}   \r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186214965","body":"## 思路\r\n\r\n> + 两次遍历-即求s[i]到c左右最近距离的最小值\r\n\r\n## 代码\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n := len(s)\r\n    ans := make([]int, n)\r\n\r\n    idx := -n\r\n    for i, ch := range s {\r\n        if byte(ch) == c {\r\n            idx = i\r\n        }\r\n        ans[i] = i - idx\r\n    }\r\n\r\n    idx = n * 2\r\n    for i := n - 1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            idx = i\r\n        }\r\n        ans[i] = min(ans[i], idx-i)\r\n    }\r\n    return ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n    if a > b {\r\n        return b\r\n    }\r\n    return a\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n> + 时间复杂度：O(n)\r\n> + 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186543466","body":"## 思路\r\n\r\n> + 模拟\r\n\r\n## 代码\r\n\r\n```go\r\ntype CustomStack struct {\r\n    stack []int\r\n    size int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack{\r\n        make([]int, 0),\r\n        maxSize,\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if len(this.stack) < this.size {\r\n        this.stack = append(this.stack, x)\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if len(this.stack) > 0 {\r\n        res := this.stack[len(this.stack)-1]\r\n        this.stack = this.stack[:len(this.stack)-1]\r\n        return res\r\n    }\r\n    return -1\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > len(this.stack) {\r\n        k = len(this.stack)\r\n    }\r\n    for i := 0; i < k; i++ {\r\n        this.stack[i] += val\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间: O(1)\r\n> + 空间: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187447665","body":"## 思路\r\n\r\n> + 双栈\r\n\r\n## 代码\r\n\r\n```go\r\nfunc decodeString(s string) string {\r\n    stk := []string{}\r\n    ptr := 0\r\n    for ptr < len(s) {\r\n        cur := s[ptr]\r\n        if cur >= '0' && cur <= '9' {\r\n            digits := getDigits(s, &ptr)\r\n            stk = append(stk, digits)\r\n        } else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\r\n            stk = append(stk, string(cur))\r\n            ptr++\r\n        } else {\r\n            ptr++\r\n            sub := []string{}\r\n            for stk[len(stk)-1] != \"[\" {\r\n                sub = append(sub, stk[len(stk)-1])\r\n                stk = stk[:len(stk)-1]\r\n            }\r\n            for i := 0; i < len(sub)/2; i++ {\r\n                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n            }\r\n            stk = stk[:len(stk)-1]\r\n            repTime, _ := strconv.Atoi(stk[len(stk)-1])\r\n            stk = stk[:len(stk)-1]\r\n            t := strings.Repeat(getString(sub), repTime)\r\n            stk = append(stk, t)\r\n        }\r\n    }\r\n    return getString(stk)\r\n}\r\n\r\nfunc getDigits(s string, ptr *int) string {\r\n    ret := \"\"\r\n    for ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\r\n        ret += string(s[*ptr])\r\n    }\r\n    return ret\r\n}\r\n\r\nfunc getString(v []string) string {\r\n    ret := \"\"\r\n    for _, s := range v {\r\n        ret += s\r\n    }\r\n    return ret\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间: O(n)\r\n> + 空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189127036","body":"## 思路\r\n\r\n> + 双栈\r\n\r\n## 代码\r\n\r\n```go\r\ntype MyQueue struct {\r\n    inStack, outStack []int\r\n}\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\nfunc (q *MyQueue) Push(x int) {\r\n    q.inStack = append(q.inStack, x)\r\n}\r\n\r\nfunc (q *MyQueue) in2out() {\r\n    for len(q.inStack) > 0 {\r\n        q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])\r\n        q.inStack = q.inStack[:len(q.inStack)-1]\r\n    }\r\n}\r\n\r\nfunc (q *MyQueue) Pop() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    x := q.outStack[len(q.outStack)-1]\r\n    q.outStack = q.outStack[:len(q.outStack)-1]\r\n    return x\r\n}\r\n\r\nfunc (q *MyQueue) Peek() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    return q.outStack[len(q.outStack)-1]\r\n}\r\n\r\nfunc (q *MyQueue) Empty() bool {\r\n    return len(q.inStack) == 0 && len(q.outStack) == 0\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间: O(1)\r\n> + 空间: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191324785","body":"## 思路\r\n\r\n> + 闭合为环-将给定的链表连接成环，然后将指定位置断开\r\n\r\n## 代码\r\n\r\n```go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    if k == 0 || head == nil || head.Next == nil {\r\n        return head\r\n    }\r\n    n := 1\r\n    iter := head\r\n    for iter.Next != nil {\r\n        iter = iter.Next\r\n        n++\r\n    }\r\n    add := n - k%n\r\n    if add == n {\r\n        return head\r\n    }\r\n    iter.Next = head\r\n    for add > 0 {\r\n        iter = iter.Next\r\n        add--\r\n    }\r\n    ret := iter.Next\r\n    iter.Next = nil\r\n    return ret\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间:O(n)\r\n> + 空间:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192252113","body":"## 思路\r\n\r\n> + 递归\r\n\r\n## 代码\r\n\r\n```go\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn head\r\n\t}\r\n\tnewHead := head.Next\r\n\thead.Next = swapPairs(newHead.Next)\r\n\tnewHead.Next = head\r\n\treturn newHead\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间\tO(n)\r\n> + 空间\tO(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193250155","body":"## 思路\r\n\r\n> + 双指针\r\n\r\n## 代码\r\n\r\n```go\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n    if headA == nil || headB == nil {\r\n        return nil\r\n    }\r\n    pa, pb := headA, headB\r\n    for pa != pb {\r\n        if pa == nil {\r\n            pa = headB\r\n        } else {\r\n            pa = pa.Next\r\n        }\r\n        if pb == nil {\r\n            pb = headA\r\n        } else {\r\n            pb = pb.Next\r\n        }\r\n    }\r\n    return pa\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间:O(m+n)\r\n> + 空间:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194855004","body":"## 思路\r\n\r\n> + 哈希+双向链表\r\n\r\n## 代码\r\n\r\n```go\r\ntype LRUCache struct {\r\n    size int\r\n    capacity int\r\n    cache map[int]*DLinkedNode\r\n    head, tail *DLinkedNode\r\n}\r\n\r\ntype DLinkedNode struct {\r\n    key, value int\r\n    prev, next *DLinkedNode\r\n}\r\n\r\nfunc initDLinkedNode(key, value int) *DLinkedNode {\r\n    return &DLinkedNode{\r\n        key: key,\r\n        value: value,\r\n    }\r\n}\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n    l := LRUCache{\r\n        cache: map[int]*DLinkedNode{},\r\n        head: initDLinkedNode(0, 0),\r\n        tail: initDLinkedNode(0, 0),\r\n        capacity: capacity,\r\n    }\r\n    l.head.next = l.tail\r\n    l.tail.prev = l.head\r\n    return l\r\n}\r\n\r\nfunc (this *LRUCache) Get(key int) int {\r\n    if _, ok := this.cache[key]; !ok {\r\n        return -1\r\n    }\r\n    node := this.cache[key]\r\n    this.moveToHead(node)\r\n    return node.value\r\n}\r\n\r\n\r\nfunc (this *LRUCache) Put(key int, value int)  {\r\n    if _, ok := this.cache[key]; !ok {\r\n        node := initDLinkedNode(key, value)\r\n        this.cache[key] = node\r\n        this.addToHead(node)\r\n        this.size++\r\n        if this.size > this.capacity {\r\n            removed := this.removeTail()\r\n            delete(this.cache, removed.key)\r\n            this.size--\r\n        }\r\n    } else {\r\n        node := this.cache[key]\r\n        node.value = value\r\n        this.moveToHead(node)\r\n    }\r\n}\r\n\r\nfunc (this *LRUCache) addToHead(node *DLinkedNode) {\r\n    node.prev = this.head\r\n    node.next = this.head.next\r\n    this.head.next.prev = node\r\n    this.head.next = node\r\n}\r\n\r\nfunc (this *LRUCache) removeNode(node *DLinkedNode) {\r\n    node.prev.next = node.next\r\n    node.next.prev = node.prev\r\n}\r\n\r\nfunc (this *LRUCache) moveToHead(node *DLinkedNode) {\r\n    this.removeNode(node)\r\n    this.addToHead(node)\r\n}\r\n\r\nfunc (this *LRUCache) removeTail() *DLinkedNode {\r\n    node := this.tail.prev\r\n    this.removeNode(node)\r\n    return node\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间: O(1)\r\n> + 空间: O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196793112","body":"## 思路\r\n\r\n> + BFS\r\n\r\n## 代码\r\n\r\n```go\r\nfunc maxDepth(root *TreeNode) int {\r\n    if root == nil {\r\n        return 0\r\n    }\r\n    queue := []*TreeNode{}\r\n    queue = append(queue, root)\r\n    ans := 0\r\n    for len(queue) > 0 {\r\n        sz := len(queue)\r\n        for sz > 0 {\r\n            node := queue[0]\r\n            queue = queue[1:]\r\n            if node.Left != nil {\r\n                queue = append(queue, node.Left)\r\n            }\r\n            if node.Right != nil {\r\n                queue = append(queue, node.Right)\r\n            }\r\n            sz--\r\n        }\r\n        ans++\r\n    }\r\n    return ans\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间: O(n)\r\n> + 空间: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185533265","body":"#Python 3\n#Idea:对将其从列表变字符串，再变整型，完成加法，再将结果变成字符串，最后字符串换成列表。\ndef day1(A,K):\n    A0 = []\n    for i in A:\n        A0.append(str(i))\n    A1 = \"\".join(A0)\n    a1 = int(A1)\n    sm = a1 + K\n    sm1 = str(sm)\n    sm2 = []\n    for j in sm1:\n        sm2.append(int(j))\n    return sm2\nA = [1,2,0,0]\nK = 304\nday1(A,K)\n#Complexity\n#Time: O(N)\n#Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186165511","body":"## 思路\n\n> + 思路描述: 看的答案，先学习一下；后来发现自己的思路和答案差不多，但是不会写，哈哈！\n\n##代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n\n        n = len(s)\n        ans = [0] * n\n\n        idx = -n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx - i)\n        return ans\n```python\n#代码\n\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N)\n> + 空间复杂度:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186384452","body":"## 思路\n\n> + 思路描述:这个题目比较懵，先打卡，慢慢琢磨！\n\n##代码\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.c = maxSize\n        self.s = []\n\n    def push(self, x: int) -> None:\n        if len(self.s) < self.c:\n            self.s.append(x)\n\n    def pop(self) -> int:\n        if self.s:\n            return self.s.pop()\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.s))):\n            self.s[i] += val\n\n```python\n#代码\n\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N)\n> + 空间复杂度:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187290014","body":"## 思路\n\n> + 思路描述:这个题目开始没有明白，但是后来对着答案，慢慢琢磨明白！\n\n##代码\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n              \n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```python\n#代码\n\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N)\n> + 空间复杂度:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189177220","body":"## 思路\n\n> + 思路描述:这类题目不熟悉，不过还是有所收获，有些感觉了！\n\n##代码\n\n\n```python\n#代码\nclass MyQueue:\n    def __init__(self):\n        self.queue = []\n    def push(self, x: int) -> None:\n        self.queue.append(x)\n    def pop(self) -> int:\n#弹出第一个元素\n        return self.queue.pop(0)\n    def peek(self) -> int:\n#返回第一个元素\n        return self.queue[0]\n    def empty(self) -> bool:\n        return not self.queue\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(1)\n> + 空间复杂度:  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190277906","body":"## 思路\n\n> + 思路描述:头一次遇上hard！能看懂答案，觉得就OK了、\n\n##代码\n\n\n```python\n#代码\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N**2)\n> + 空间复杂度:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191579179","body":"## 思路\n\n> + 思路描述:对链表的概念还不熟悉，弄一半，还是抄的答案。\n\n##代码\n\n\n```python\n#代码\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # 双指针\n        if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N)\n> + 空间复杂度:  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192412390","body":"## 思路\n\n> + 思路描述:今天先打卡，再慢慢琢磨，要加班了、\n\n##代码\n\n\n```python\n#代码\nif not head or not head.next: return head\n    ans = ListNode()\n    ans.next = head.next\n    pre = ans\n    while head and head.next:\n        next = head.next\n        n_next = next.next\n\n        next.next = head\n        pre.next = next\n        head.next = n_next\n        # 更新指针\n        pre = head\n        head = n_next\n    return ans.next\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N）\n> + 空间复杂度:  O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194015868","body":"## 思路\n\n> + 思路描述:有些懵、\n\n##代码\n\n\n```python\n#代码\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        x = None\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        slow = head\n        while slow != x:\n            slow = slow.next\n            x = x.next\n        return slow\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N)\n> + 空间复杂度:  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195460148","body":"## 思路\n\n> + 思路描述:今天真是纯学习了，这个对现在的我来说太有挑战性了。\n\n##代码\n\n\n```JavaScript Code（假装自己很会）\n#代码\nclass DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        // Mappings of key->node.\n        this.hashmap = {}\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key, value) {\n        if (key in this.hashmap) {\n            // If key exists, update the corresponding node and move it to the head.\n            const node = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n        // If it's a new key.\n            if (this._isFull()) {\n                // If the cache is full, remove the tail node.\n                const node = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            // Create a new node and add it to the head.\n            const node = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(1)\n> + 空间复杂度:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196803041","body":"## 思路\n\n> + 思路描述:瞎猫要遇上死耗子了，哈哈\n\n##代码\n\n\n```python\n#代码\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N)\n> + 空间复杂度:  有点吃不准","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185549904","body":"### 思路\r\n用数组进行累加\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        for(int i = num.size() - 1; i > -1; i--){\r\n            num[i] += k % 10;\r\n            k = k / 10;\r\n        }\r\n        while(k > 0){\r\n            num.insert(num.begin(), k % 10);\r\n            k /= 10;\r\n        }\r\n        int j = num.size() - 1;\r\n        while(j > 0){\r\n            if(num[j] >= 10){\r\n                num[j] -= 10;\r\n                num[j - 1]++;\r\n            }     \r\n            j--;\r\n        }\r\n        if(num[0] >= 10){\r\n            num[0] -= 10;\r\n            num.insert(num.begin(), 1);\r\n        }\r\n        return num;\r\n    }\r\n};\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186216657","body":"# 思路\n蛮力\n# 代码\n```c++\nvector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        vector<int> re;\n        for(int i = 0; i < s.length(); i++){\n            if(s[i] == c){\n                re.push_back(i);\n            }\n        }\n        int count = 0;\n        while(count < s.length()){\n            int min = INT_MAX;\n            for(int i = 0; i < re.size(); i++){\n                if(min > abs(re[i] - count)){\n                    min = abs(re[i] - count);\n                }\n            }\n            ans.push_back(min);\n            count++;\n        }\n        return ans;\n    }\n```\n**复杂度**\n- 时间O(n2)\n- 空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186506125","body":"# 代码\n```c++\nclass CustomStack {\npublic:\n\n    vector<int> res;\n    int top;\n\n    CustomStack(int maxSize) {\n        res.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != res.size() - 1){\n            top++;     \n            res[top] = x;\n        }\n    }\n    \n    int pop() {\n        if(top == -1){\n            return -1;\n        }\n        else{\n            top--;\n            return res[top + 1];\n        }\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < k; i++){\n            if(i > top){\n                break;\n            }\n            res[i] += val;\n        }\n        return;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187051742","body":"# 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<char> str;\n        stack<int> nums;\n        int i = 0;\n        while(i < s.length()){\n            int num = 0;\n            while(s[i] >= '0' && s[i] <= '9'){\n                num = num * 10 + (s[i] - '0');\n                i++;\n            }            \n            if(num != 0){\n                nums.push(num);\n            }\n            if(s[i] != ']'){\n                str.push(s[i]);\n            }\n            else{\n                int n = nums.top();\n                nums.pop();\n                string zifu = \"\";\n                string zifu1 = \"\";\n                while(str.top() != '['){\n                    zifu.insert(zifu.begin(), str.top());\n                    str.pop();\n                }\n                str.pop();\n                for(int i = 0; i < n; i++){\n                    zifu1 += zifu;\n                }\n                for(int i = 0; i < zifu1.length(); i++){\n                    str.push(zifu1[i]);\n                }\n            }\n            i++;\n        }\n        string ans = \"\";\n        while(!str.empty()){\n            ans.insert(ans.begin(), str.top());\n            str.pop();\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189123157","body":"# 代码\n```c++\nclass MyQueue {\npublic:\n    stack<int> stk1;\n    stack<int> stk2;\n\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        while(!stk1.empty()){\n            stk2.push(stk1.top());\n            stk1.pop();\n        }\n        stk1.push(x);\n        while(!stk2.empty()){\n            stk1.push(stk2.top());\n            stk2.pop();\n        }\n    }\n    \n    int pop() {\n        int t = stk1.top();\n        stk1.pop();\n        return t;\n    }\n    \n    int peek() {\n        return stk1.top();\n    }\n    \n    bool empty() {\n        return stk1.empty();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190456030","body":"# 代码\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>maxStk;\n        maxStk.push(arr[0]);\n        for(int i=1;i<arr.size();i++){\n            if(arr[i]<maxStk.top()){\n                int maxNum=maxStk.top();\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\n                maxStk.push(maxNum);\n            }\n            else maxStk.push(arr[i]);\n        }\n        return maxStk.size();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191628634","body":"# 代码\n```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        int count = 1;\n        if(head == nullptr){\n            return head;\n        }\n        while(fast -> next != nullptr){\n            count++;\n            fast = fast -> next;\n        }\n        fast = head;\n        for(int i = 0; i < count - (k % count); i++){\n            if(fast -> next == nullptr){\n                fast = head;\n            }\n            else{\n                fast = fast -> next;\n            }\n        }\n        ListNode* fast1 = fast;\n        for(int i = 0; i < count - 1; i++){\n            if(fast1 -> next != nullptr){\n                fast1 = fast1 -> next;\n            }\n            else{\n                fast1 -> next = slow;\n                fast1 = slow;\n            }\n        }\n        fast1 -> next = nullptr;\n        return fast;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192708179","body":"# 代码\n```c++\nclass Solution {\npublic:    \n    ListNode* swapPairs(ListNode* head) {\n        ListNode* head0=new ListNode(0);\n        ListNode* head00=head0;\n        head0->next=head;\n        ListNode* head1=head;\n        ListNode* head2;\n        if(head==nullptr || head->next==nullptr){\n            return head;\n        }\n        while(head1!=nullptr && head1->next!=nullptr){\n            head2=head1->next;\n            head0->next=head1->next;\n            head1->next=head2->next;\n            head2->next=head1;\n            head0=head1;\n            head1=head1->next;\n        }\n        return head00->next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193145505","body":"```c++\nclass Solution {\npublic:\n    ListNode* getMedian(ListNode* left, ListNode* right) {\n        ListNode* fast = left;\n        ListNode* slow = left;\n        while (fast != right && fast->next != right) {\n            fast = fast->next;\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\n        if (left == right) {\n            return nullptr;\n        }\n        ListNode* mid = getMedian(left, right);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = buildTree(left, mid);\n        root->right = buildTree(mid->next, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildTree(head, nullptr);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193332811","body":"```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (headA == nullptr || headB == nullptr) {\n            return nullptr;\n        }\n        ListNode *pA = headA, *pB = headB;\n        while (pA != pB) {\n            pA = pA == nullptr ? headB : pA->next;\n            pB = pB == nullptr ? headA : pB->next;\n        }\n        return pA;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194049011","body":"```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        while (fast != nullptr) {\n            slow = slow->next;\n            if (fast->next == nullptr) {\n                return nullptr;\n            }\n            fast = fast->next->next;\n            if (fast == slow) {\n                ListNode *ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr->next;\n                    slow = slow->next;\n                }\n                return ptr;\n            }\n        }\n        return nullptr;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195443181","body":"```c++\nstruct DLinkedNode {\n    int key, value;\n    DLinkedNode* prev;\n    DLinkedNode* next;\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DLinkedNode*> cache;\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int size;\n    int capacity;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if (!cache.count(key)) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        DLinkedNode* node = cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if (!cache.count(key)) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode* node = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache[key] = node;\n            // 添加至双向链表的头部\n            addToHead(node);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode* removed = removeTail();\n                // 删除哈希表中对应的项\n                cache.erase(removed->key);\n                // 防止内存泄漏\n                delete removed;\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            DLinkedNode* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DLinkedNode* node) {\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(DLinkedNode* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveToHead(DLinkedNode* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    DLinkedNode* removeTail() {\n        DLinkedNode* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185584460","body":"## 思路\n\n```raw\nres = []\nwhile (A or B):\n    a = A 当前位\n    b = B 当前位\n    \n    sum = a + b + 进位\n    \n    进位, 当前位 = divmod(sum, 10)\n    res.insert(0, 当前位)\n\n如果还有非 0 进位， res.insert(0, carry)\n```\n\n## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        idx, sum_, carry = len(num) -1, 0, 0\n        while idx >= 0 or k != 0:\n            a = num[idx] if idx >= 0 else 0\n            b = k % 10 if k else 0\n\n            sum_ = a + b + carry\n            carry, curr = divmod(sum_, 10)\n            idx -= 1\n            k //= 10\n            res.insert(0, curr)\n        if carry:\n            res.insert(0, carry)\n        return res\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186206414","body":"## 思路\n\n1. 找到所有 `s` 中 `c` 的坐标\n2. 对于 `s` 中的每个元素都计算和所有 `c` 的坐标的距离\n\n## 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [None for _ in range(len(s))]\n        c_idxes = [idx for idx, i in enumerate(s) if i == c]\n\n        for idx, i in enumerate(s):\n            res[idx] = min( abs(idx - c_idx) for c_idx in c_idxes)\n        \n        return res\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186546673","body":"## 思路\n\n按题义模拟即可\n\n## 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self._storage = []\n        self._room = maxSize\n\n    def push(self, x: int) -> None:\n        if self._room > 0:\n            # got room to store element\n            self._storage.append(x)\n            self._room -= 1\n        \n    def pop(self) -> int:\n        try:\n            res = self._storage.pop()\n        except IndexError:\n            return -1\n        else:\n            self._room += 1\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        for idx in range(len(self._storage[:k])):\n            self._storage[idx] += val\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187612588","body":"## 思路\n\n栈的应用。\n\n## 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in s:\n            if i != \"]\":\n                # keep pushing char into stack until the end `]`\n                stack.append(i)\n            else:\n                lookback = []\n                while (c := stack.pop()) != \"[\":\n                    lookback.append(c)\n                lookback = \"\".join(lookback[::-1])\n                repeat_time = []\n                try:\n                    while (c := stack.pop()) in \"0123456789\":\n                        repeat_time.append(c)\n                except IndexError:\n                    pass\n                else:\n                    # well, c is not number for now, put it back\n                    stack.append(c)\n                repeat_time = int(\"\".join(repeat_time[::-1]))\n                stack.append(repeat_time * lookback)\n\n        return \"\".join(stack)\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189195523","body":"## 思路\n\n基础数据结构，模拟即可。\n\n## 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.in_ = []\n        self.out = []\n\n    @staticmethod\n    def _switch(source, target):\n        while source:\n            target.append(source.pop())\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        # out -> in_\n        self._switch(self.out, self.in_)\n        self.in_.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        # in_ -> out\n        self._switch(self.in_, self.out)\n        return self.out.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        # in_ -> out\n        self._switch(self.in_, self.out)\n        return self.out[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.in_) + len(self.out) == 0\n```\n\n## 复杂度\n\n- Time: O(1) (摊还分析下是 O(1)，最差 O(N))\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190456694","body":"## 思路\n\n题目比较抽象，举一个🌰️  \n\n输入 `arr := [2, 1, 3, 4, 4]`  \n\n1. 切分成若干份  `[2, 1]`, `[3, 4]`, `[4]`  \n2. 每一份独立排序 `[1, 2]`, `[3, 4]`, `[4]`\n3. 将上面得到的组件拼起来 `res := [1, 2, 3, 4, 4]`\n\n在保证 `sorted(arr) == res` 的前提下，上面第 1 步，最多能切多少块出来？  \n\n有点类似桶排序/计数排序：\n\n将原数组和整体排好序的数组并排(zip)在一起向前遍历，检查 `arr[:i]` 和 `sorted_arr[:i]` 是否**计数**一致，是则可多切一块 (`res +=1`)。\n\n## 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr):\n        res = 0\n        c1 = Counter()\n        c2 = Counter()\n        for a, b in zip(arr, sorted(arr)):\n            c1[a] += 1\n            c2[b] += 1\n            if c1 == c2:\n                res += 1\n        return res\n```\n\n## 复杂度\n\n- Time: O(N^2)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191632864","body":"## 思路\n\n模拟操作：先组合成环，再移动指针在合适的地方断开。\n\n## 代码\n\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # 类似 itertools.cycle\n        if k == 0 or head is None:\n            return head\n\n        tail = head\n        n = 1\n        while tail.next is not None:\n            # 找到尾巴\n            tail = tail.next\n            n += 1\n    \n        # 卷起来！\n        tail.next = head\n        add = n - k % n\n        while add > 0:\n            head = head.next\n            tail = tail.next\n            add -= 1\n        # 断开\n        tail.next = None\n        return head\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192702476","body":"## 思路\n\n画图模拟，穿针引线。\n\n## 代码\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = ListNode(next=head)\n        prev, curr = dummy, head\n        while curr and curr.next:\n            # save pointers\n            next_pair = curr.next.next\n            second = curr.next\n            # reverse pair\n            second.next = curr\n            curr.next = next_pair\n            prev.next = second\n            # update pointers\n            prev = curr\n            curr = next_pair\n        return dummy.next\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193143972","body":"## 思路\n\nBST 的中序遍历结果是有序数组，是一种将有层级的树状结构压扁成一维数组；\n\n将有序链表「还原成」BST 就相当于再恢复树状层级结构：\n\n1. 先找到中点，就是 BST 的 root\n2. 再找到左半部份的中点，就是 root.left，类似地可以找到 root.right\n3. 递归\n\n而找中点的过程可以用==快慢指针==。\n\n## 代码\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:        \n        if not head:\n            return head\n        if not head.next:\n            return  TreeNode(head.val)\n        pre, slow, fast = None, head, head\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        pre.next = None\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n```\n\n## 复杂度\n\n- Time: O(NlogN)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193340193","body":"## 思路\n\n方法1: 利用 hashtable\n\n## 代码\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        A = set()\n        while headA:\n            A.add(headA)\n            headA = headA.next\n        while headB:\n            if headB in A:\n                return headB\n            headB = headB.next\n        return None\n```\n\n## 复杂度\n\n- Time: O(m + n)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194168679","body":"## 思路\n\n快慢指针。\n\n## 代码\n\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        \n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast is slow:\n                break\n        else:\n          \t# 根本没发现环\n            return None\n\n        fast = head\n        while fast is not slow:\n            fast = fast.next\n            slow = slow.next\n        return fast\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195580546","body":"## 思路\n\n直接继承 Python 内置的 OrderedDict\n\n## 代码\n\n```python\nclass LRUCache(OrderedDict):\n\n    def __init__(self, capacity: int):\n        super().__init__()\n        self.capacity = capacity\n\n\n    def get(self, key: int) -> int:\n        if key not in self:\n            return -1\n        self.move_to_end(key)          # 注意这里是将最近元素放到尾巴了\n        return self[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last=False)   # 对应的，删除就从头部删\n```\n\n## 复杂度\n\n- Time: O(1)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196772116","body":"## 思路\n\n所有节点中最大的深度(depth)就是树的高度\n\n## 代码\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185585215","body":"# Day 1. [989. 数组形式的整数加法](https://leetcode.cn/problems/add-to-array-form-of-integer/)\r\n## 思路\r\n加法有以下公式：\r\n\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10   \r\n\r\n直接遍历相加即可，保存 carry，最后有 carry 额外加 1，从小到大加，最后保存的结果要翻转\r\n- 动态数组遍历数组\r\n- int 数字 `%10` 取最低位，`/10` 为了遍历下一个最低位\r\n\r\n```c++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    int carry = 0; \r\n    vector<int> res;\r\n    \r\n    // 遍历数组，进行加\r\n    for (int i = num.size() - 1; i >= 0; --i) {\r\n        int kn = k % 10;\r\n        k /= 10;\r\n\r\n        int sumn = kn + num[i] + carry;  //关键公式!!!\r\n\r\n        res.push_back(sumn % 10);\r\n        if (sumn >= 10) {\r\n            carry = 1;\r\n        } else {\r\n            carry = 0;\r\n        }\r\n    }\r\n\r\n    // 如果 k 还没处理完，继续处理 k\r\n    while (k > 0) {\r\n        int kn = k % 10;\r\n        k /= 10;\r\n\r\n        int sumn = kn + carry; //关键公式!!! 此时 num[i] 已经是 0 了\r\n\r\n        res.push_back(sumn % 10);\r\n        if (sumn >= 10) {\r\n            carry = 1;\r\n        } else {\r\n            carry = 0;\r\n        }\r\n    }\r\n\r\n    if (carry == 1) res.push_back(1);\r\n    reverse(res.begin(), res.end());\r\n\r\n    return res;\r\n}\r\n```\r\n> + 时间复杂度: O(max(n,logk))\r\n> + 空间复杂度: O(1)，常数级别，只有res\r\n\r\n\r\n## 优化\r\n\r\n发现两个循环其实是一样的，可以放在一起处理\r\n\r\n```c++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    int carry = 0;\r\n        \r\n    vector<int> res;\r\n    int i = num.size() - 1;\r\n    // 放到一起处理, 如果有一个变成 0, sumn 这里就相当于 + 0\r\n    while (i >= 0 || k > 0) {\r\n        int a = i < 0 ? 0 : num[i];\r\n        int kn = k == 0 ? 0 : k % 10;\r\n        k /= 10;\r\n\r\n        int sumn = a + kn + carry;\r\n\r\n        res.push_back(sumn % 10);\r\n        if (sumn >= 10) {\r\n            carry = 1;\r\n        } else {\r\n            carry = 0;\r\n        }\r\n        i--;\r\n    }\r\n\r\n    // 如果有进位\r\n    if (carry == 1) res.push_back(1);\r\n    reverse(res.begin(), res.end());\r\n\r\n    return res;\r\n}\r\n```\r\n\r\n没变化\r\n> + 时间复杂度: O(max(n,logk))\r\n> + 空间复杂度: O(1)，常数级别，只有res\r\n\r\n\r\n## 模板\r\n\r\n加法模板\r\n```c++\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\nend\r\n\r\n判断还有进位吗\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186090818","body":"# Day 2. [821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\n## 思路\r\n\r\n暴力\r\n\r\n- 找出来所有字符c的位置\r\n- 每个位置都与s的每个字符计算距离, 更新最小值\r\n\r\n```c++\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res(s.size(), 0x3f3f3f3f);\r\n\r\n    vector<int> cset;\r\n\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) \r\n            cset.push_back(i);\r\n    }\r\n\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        for (int j = 0; j < cset.size(); ++j) {\r\n            res[i] = min(res[i], abs(i - cset[j]));\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n> + 时间复杂度: O(mn), m是c的个数, n 是s的长度\r\n> + 空间复杂度: O(m + n)\r\n\r\n\r\n## 优化\r\n\r\nbfs + 判断 (主要好久没写bfs了, 练练手)\r\n\r\n\r\n```c++\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res(s.size(), 0x3f3f3f3f);\r\n\r\n    queue<int> q;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) {\r\n            q.push(i);\r\n        }\r\n    }\r\n\r\n    while (q.size()) {\r\n        int idx = q.front(); q.pop();\r\n\r\n        for (int i = 0; i < s.size(); ++i) {\r\n            int dis = abs(i - idx);\r\n            if (res[i] > dis) {\r\n                res[i] = dis;\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    return res;\r\n}\r\n```\r\n\r\n\r\n> + 时间复杂度: O(mn)\r\n> + 空间复杂度: O(m + n)\r\n\r\n\r\n## 模板\r\n\r\nbfs 迭代模板\r\n```c++\r\nqueue<int> q;\r\n// q.push(i);\r\nwhile (q.size()) {\r\n    int idx = q.front(); q.pop();\r\n\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        int dis = abs(i - idx);\r\n        if (res[i] > dis) {\r\n            res[i] = dis;\r\n            //q.push(i);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186457659","body":"# Day 3. [1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)\r\n## 思路\r\n\r\n直接用 stack 模拟\r\n\r\n- increment 的时候，需要用一个辅助栈，计算出需要 +val 的边界 `int remain = max(0, (int)(mSt.size() - k));`\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : mMaxSize(maxSize) {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (mSt.size() < mMaxSize) {\r\n            mSt.push(x);\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (mSt.size() == 0) return -1;\r\n        int num = mSt.top(); mSt.pop();\r\n        return num;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        stack<int> mStTmp;\r\n        int remain = max(0, (int)(mSt.size() - k));    // 不加的个数\r\n\r\n        while (remain) {                        // 把不加 val 的数字给跳过去\r\n            mStTmp.push(mSt.top()); mSt.pop();\r\n            remain--;\r\n        }\r\n\r\n        while (mSt.size()) {                    // 把剩下的 mSt 里的元素 + val\r\n            mStTmp.push(mSt.top() + val); mSt.pop();\r\n        }\r\n\r\n        while (mStTmp.size()) {                 // \r\n            mSt.push(mStTmp.top()); mStTmp.pop();\r\n        }\r\n    }\r\n\r\nprivate:\r\n    int mMaxSize;\r\n    stack<int> mSt;\r\n};\r\n```\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)\r\n\r\n----\r\n\r\n## 优化\r\n\r\n直接用数组模拟栈就好了，对栈底元素好处理\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : mMaxSize(maxSize) {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (mVec.size() < mMaxSize) {\r\n            mVec.push_back(x);\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (mVec.size() == 0) return -1;\r\n        int num = mVec.back(); mVec.erase((--mVec.end()));\r\n        return num;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < min(k, (int)mVec.size()); ++i) \r\n            mVec[i] += val;\r\n    }\r\n\r\nprivate:\r\n    int mMaxSize;\r\n    vector<int> mVec;\r\n};\r\n```\r\n\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)\r\n\r\n----\r\n\r\n## 负优化\r\n\r\n去除繁琐的 erase，直接用 `top` 表示栈顶位置\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : mMaxSize(maxSize) {\r\n        mVec.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top < mMaxSize - 1) {\r\n            ++top;\r\n            mVec[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) return -1;\r\n        int num = mVec[top]; \r\n        --top;\r\n        return num;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < min(k, top+1); ++i) \r\n            mVec[i] += val;\r\n    }\r\n\r\nprivate:\r\n    int mMaxSize;\r\n    int top;        // 表示栈顶\r\n    vector<int> mVec;\r\n};\r\n```\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)\r\n\r\n---\r\n## 究极优化\r\n\r\n- 只有在 pop 操作时，我们才需要知道栈顶元素的具体值，在其余的情况下，我们只要存储每个元素的增量就行了。\r\n- 因此在遇到 pop 操作时，我们返回栈顶元素的初始值加上增量 add[top]。\r\n- `add[i]` 表示前 i - 1 个元素的增量\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : mMaxSize(maxSize) {\r\n        mVec.resize(maxSize);\r\n        mInc.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top < mMaxSize - 1) {\r\n            ++top;\r\n            mVec[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) return -1;\r\n        int num = mVec[top] + mInc[top]; \r\n        if (top > 0) {\r\n            mInc[top - 1] += mInc[top];\r\n        }\r\n        mInc[top] = 0;\r\n        --top;\r\n        return num;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int idx = min(k - 1, top); \r\n        \r\n        if (idx >= 0)   // top 可能是 -1\r\n            mInc[idx] += val;\r\n    }\r\n\r\nprivate:\r\n    int mMaxSize;\r\n    int top;        // 表示栈顶\r\n    vector<int> mVec, mInc; //mInc[i] 表示下标<=i的元素的增量\r\n};\r\n```\r\n> + 时间复杂度: O(1)\r\n> + 空间复杂度: O(1)\r\n\r\n\r\n\r\n## 模板\r\n\r\n无模板","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187637162","body":"# Day 4. [394. 字符串解码](https://leetcode.cn/problems/decode-string/)\r\n## 思路\r\n\r\n递归解析表达式，编译原理，符合 LL(1) 文法\r\n- 从左向右分析（Left-to-right-parse）\r\n- 最左推导（Leftmost-derivation）\r\n- 超前查看一个符号（1-symbol lookahead）\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int getDigit() {\r\n        int res = 0;\r\n        while (ptr < src.size() && isdigit(src[ptr])) {\r\n            res = res * 10 + src[ptr] - '0';\r\n            ptr++;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    string getString() {    \r\n        if (ptr == src.size() || src[ptr] == ']') {\r\n            return \"\";  //String -> eps\r\n        }\r\n\r\n        string res;             // 最后返回的结果\r\n        char cur = src[ptr];    // ptr下标的字符\r\n\r\n        if (isdigit(cur)) {\r\n            // String -> Digits[String] String\r\n            // 解析 Digits \r\n            int times = getDigit(); //字符串乘的次数\r\n            // 过滤左括号\r\n            ++ptr;\r\n            // 解析 string\r\n            string str = getString();\r\n            // 过滤右括号\r\n            ++ptr;\r\n            // 字符串累乘\r\n            while(times--) \r\n                res += str;\r\n        } else if (isalpha(cur)) {\r\n            // String -> Alpha String\r\n            // 解析 Alpha\r\n            res = src[ptr++];\r\n        }\r\n\r\n        return res + getString();       \r\n        // 走到这一步，后边可能还有表达式,\r\n        // 所以要继续递归并且把后边的结果拼接起来\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        src = s;\r\n        ptr = 0;\r\n        return getString();\r\n    }\r\n\r\nprivate:\r\n    string src;\r\n    size_t ptr;\r\n};\r\n```\r\n> + 时间复杂度: O(n)，n 为 s 长度\r\n> + 空间复杂度: O(n)\r\n\r\n----\r\n\r\n## 栈\r\n\r\n两个栈分别维护数字和字符串\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int getDigit(string &src, size_t &ptr) {\r\n        int res = 0;\r\n        while (ptr < src.size() && isdigit(src[ptr])) {\r\n            res = res * 10 + src[ptr] - '0';\r\n            ptr++;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    string decodeString(string s) {        \r\n        stack<int> numSt;\r\n        stack<string> stringSt;\r\n        string res;\r\n        int numT;\r\n        size_t ptr = 0; \r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n\r\n            if (cur == '[') {\r\n                ptr++;\r\n                numSt.push(numT);\r\n                stringSt.push(res);\r\n                res = \"\";\r\n            } else if (cur == ']') {\r\n                ptr++;\r\n                string tmpSrc;\r\n                int times = numSt.top(); numSt.pop();\r\n                while (times--)\r\n                    tmpSrc += res;\r\n                res = stringSt.top() + tmpSrc; stringSt.pop();\r\n            } else if (isdigit(cur)) {\r\n                numT = getDigit(s, ptr);\r\n            } else if (isalpha(cur)) {\r\n                ptr++;\r\n                res += cur;\r\n            }  \r\n        } \r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n\r\n> + 时间复杂度: O(n)，n 为 s 长度\r\n> + 空间复杂度: O(n)\r\n\r\n\r\n## 模板\r\n\r\n无模板","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188982095","body":"# Day 5. [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)\r\n## 思路\r\n\r\n两个栈来回倒，这怎么难度又下去了\r\n\r\n\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        st.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        while (st.size()) {\r\n            stT.push(st.top()); st.pop();\r\n        }\r\n\r\n        int res = stT.top(); stT.pop();\r\n        while (stT.size()) {\r\n            st.push(stT.top()); stT.pop();\r\n        }\r\n\r\n        return res;\r\n    }\r\n    \r\n    int peek() {\r\n        stT = st;\r\n        while (stT.size() != 1) {\r\n            stT.top(); stT.pop();\r\n        }\r\n\r\n        int res = stT.top(); stT.pop();\r\n        return res;\r\n    }\r\n    \r\n    bool empty() {\r\n        return st.empty();\r\n    }\r\n\r\nprivate:\r\n    stack<int> st, stT;    \r\n};\r\n```\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)\r\n\r\n----\r\n\r\n## 模板\r\n\r\n无模板","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190490612","body":"# Day 6. [768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\r\n## 思路\r\n\r\n将原数组进行分块后，对各分块分别进行排序后的结果等于原数组排序后的结果.\r\n\r\n下一个分块中的所有数字都会大于等于上一个分块中的所有数字.\r\n\r\n- 栈存每个分块的最大值\r\n- 如果遍历到的新数字比之前分块的最大值都要大，我们就把它作为一个新的分块\r\n- 如果遍历到的新数字小于之前某些分块的最大值，那这些分块都要被合成一个分块\r\n\r\n\r\n```c++\r\nint maxChunksToSorted(vector<int>& arr) {\r\n    stack<int> st;\r\n    st.push(arr[0]);\r\n\r\n    for (int i = 1; i < arr.size(); ++i) {\r\n        if (arr[i] >= st.top()) {\r\n            st.push(arr[i]);\r\n        } else {\r\n            int head = st.top(); st.pop();  // 先把头部取出来\r\n            while (st.size() != 0 && arr[i] < st.top()) { // 合并比他大的数\r\n                st.pop();\r\n            }\r\n            st.push(head);\r\n        }\r\n    }\r\n\r\n    return st.size();\r\n}\r\n```\r\n> + 时间复杂度: O(N)，N 为数组长度。\r\n> + 空间复杂度: O(N)\r\n\r\n----\r\n## 模板\r\n\r\n无模板","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191512129","body":"# Day 7. [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)\r\n## 思路\r\n\r\n先把他变成环，然后计算出要移动的距离\r\n\r\n- 变成环，找到末端节点，连接头尾，捎带计算链表长度\r\n- 因为每个节点向右移动，相当于头节点向左移动，与链表方向相反，所以要计算移动的距离 = size - k\r\n\r\n\r\n```c++\r\nListNode* rotateRight(ListNode* head, int k) {\r\n    if (head == nullptr) return nullptr;\r\n\r\n    ListNode *root = head, *cur = head;\r\n\r\n    int size = 1;\r\n    while (cur->next != nullptr) {\r\n        cur = cur->next;\r\n        size++;\r\n    }\r\n    cur->next = head;  //成环\r\n\r\n    int num = size - k % size;//计算正向移动的格子\r\n\r\n    while(num--) {\r\n        if (num == 0) {\r\n            ListNode* now = root; \r\n            root = root->next;\r\n            now->next = nullptr;\r\n            break;\r\n        }\r\n\r\n        root = root->next;\r\n    }\r\n\r\n    return root;\r\n}\r\n```\r\n> + 时间复杂度: O(N)，N 为链表长度\r\n> + 空间复杂度: O(N)\r\n\r\n----\r\n\r\n## 模板\r\n\r\n无模板","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192708395","body":"# Day 8. [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)\r\n## 思路\r\n\r\n链表模拟即可\r\n\r\n- 设置虚拟头节点辅助\r\n\r\n```c++\r\nListNode* swapPairs(ListNode* head) {\r\n    if (head == nullptr) return nullptr;\r\n    \r\n    ListNode* dummyHead = new ListNode(0, head);\r\n    ListNode* cur = head, *before = dummyHead;\r\n\r\n    while (cur->next != nullptr) {\r\n        ListNode* next = cur->next;\r\n        cur->next = next->next;\r\n        before->next = next;\r\n        next->next = cur;\r\n\r\n        if (cur->next != nullptr) {\r\n            before = cur; \r\n            cur = cur->next;                \r\n        }\r\n        else break;  \r\n                 \r\n    }\r\n\r\n    return dummyHead->next;\r\n}\r\n```\r\n\r\n\r\n> + 时间复杂度: O(N)，N 为 链表长度\r\n> + 空间复杂度: O(N)\r\n\r\n\r\n## 模板\r\n\r\n无模板","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193149785","body":"# Day 9. [109. 有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)\r\n## 思路\r\n\r\n平衡二叉搜索树\r\n\r\n- 平衡：要选取链表的中间节点作为根节点，一定平衡（参加后续证明）\r\n- 搜索：有序，题目输入链表就是有序的，所以随便找一个节点，前驱节点建左子树，后继节点建右子树，一定是搜索树\r\n\r\n中间节点计算方法：\r\n- 快慢指针走一遍慢指针位置\r\n- 把链表存数组里 `start + end >> 1`\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    TreeNode* buildAVL(vector<ListNode*> &vecs, int start, int end) {\r\n        if (start > end) return nullptr;\r\n\t\t\r\n        //start + end >> 1 和 start + end + 1 >> 1 针对偶数链表，一个选择前边作为根节点，另一个选择后边作为根节点，都对\r\n        int mid = start + end >> 1;\r\n        TreeNode* root = new TreeNode(vecs[mid]->val);\r\n        root->left = buildAVL(vecs, start, mid);\r\n        root->right = buildAVL(vecs, mid + 1, end);\r\n        return root;    \r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        vector<ListNode*> vecs;\r\n\r\n        for (ListNode* cur = head; cur != nullptr; cur = cur->next) {\r\n            vecs.push_back(cur);\r\n        }\r\n\r\n        TreeNode* root = buildAVL(vecs, 0, vecs.size() - 1);\r\n\r\n        return root;\r\n    }\r\n};\r\n```\r\n> + 时间复杂度: O(N)，N 为链表长度\r\n> + 空间复杂度: O(logN)，平衡二叉树的高度为 O(logn)，即为递归过程中栈的最大深度，也就是需要的空间。\r\n\r\n----\r\n\r\n## 快慢指针\r\n\r\n快慢指针好久没写了，写一下练手\r\n\r\n```c++\r\nListNode* getMid(ListNode* left, ListNode* right) {\r\n    ListNode *slow = left, *fast = left;\r\n\r\n    while (fast != right && fast->next != right) {\r\n        slow = slow->next;\r\n        fast = fast->next->next;\r\n    }\r\n\r\n    return slow;\r\n}\r\n\r\nTreeNode* buildAVL(ListNode* left, ListNode* right) {\r\n    if (left == right) return nullptr;\r\n    ListNode* midNode = getMid(left, right);\r\n    TreeNode* root = new TreeNode(midNode->val);\r\n    root->left = buildAVL(left, midNode);\r\n    root->right = buildAVL(midNode->next, right);\r\n    return root;    \r\n}\r\n\r\nTreeNode* sortedListToBST(ListNode* head) {\r\n    TreeNode* root = buildAVL(head, nullptr);\r\n\r\n    return root;\r\n}\r\n```\r\n\r\n\r\n> + 时间复杂度: O(NlogN)，N 为链表长度\r\n> + 空间复杂度: O(logN)\r\n\r\n\r\n## 模板\r\n\r\n无模板","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193291401","body":"# Day 10. [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\r\n## 思路\r\n\r\n先存好一个链表的全部节点，暴力匹配\r\n\r\n\r\n```c++\r\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n    vector<ListNode*> vecs;\r\n    for (ListNode* cur = headA; cur != nullptr; cur = cur->next) {\r\n        vecs.push_back(cur);\r\n    }\r\n\r\n\r\n    for (ListNode* cur = headB; cur != nullptr; cur = cur->next) {\r\n        for (ListNode* aNode : vecs) {\r\n            if (cur == aNode)\r\n                return cur;\r\n        }\r\n    }\r\n\r\n    return nullptr;\r\n}\r\n```\r\n> + 时间复杂度: O(MN)，M，N 为两个链表的长度长度\r\n> + 空间复杂度: O(N)\r\n\r\n----\r\n\r\n## 链表变环\r\n\r\n其实就是一个公式推导\r\n\r\n- 链表A，不相交前长度为 a，相交后长度为 c，总长度为 a+c\r\n- 链表B，不相交前长度为 b，相交后长度为 c，总长度为 b+c\r\n\r\n那么 A 走完继续走 b 步，B 走完继续走 a 步，则共走了 a + b + c，相交。\r\n\r\n> 如果两链表不相交，那么 c 为 0，则共走了 a + b 步，到达 nullptr\r\n\r\n```c++\r\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n    if (headA == nullptr || headB == nullptr) {\r\n        return nullptr;\r\n    }\r\n\r\n    ListNode *acur = headA, *bcur = headB;\r\n\r\n    while (acur != bcur) {\r\n        acur = acur == nullptr ? headB : acur->next;\r\n        bcur = bcur == nullptr ? headA : bcur->next;\r\n    }\r\n\r\n    return acur;\r\n}\r\n```\r\n\r\n\r\n> + 时间复杂度: O(M+N)\r\n> + 空间复杂度: O(1)\r\n\r\n\r\n## 模板\r\n\r\n无模板","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194163450","body":"# Day 11. [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)\r\n## 思路\r\n\r\n![image](https://user-images.githubusercontent.com/30496905/180805264-c5c5bc96-f203-40fb-a070-c6bf74661371.png)\r\n\r\nslow 走的路: a + b，\r\nfast  走的路: a + b + n(b + c)，\r\n其中 n 必为 1，\r\n在 b 相遇，因为 fast 速度是 slow 的两倍，则有：a + b + n(b + c) = (a + b) * 2，求解出来 c = a，\r\n那么 slow 再走 c = a 步，就是相交节点，找另一个指针 cur 从 head 走 a 步，cur == slow 时，即为环的起点\r\n\r\n```c++\r\nListNode *detectCycle(ListNode *head) {\r\n    ListNode *slow = head, *fast = head, *res = head;\r\n\r\n    while (slow != nullptr && fast != nullptr) {\r\n        if (fast->next == nullptr) return nullptr;\r\n        slow = slow->next;\r\n        fast = fast->next->next;\r\n\r\n        \r\n        if (slow == fast) {\r\n            //cout << slow->val << endl;\r\n            while (res != slow) {\r\n                res = res->next;\r\n                slow = slow->next;\r\n            }\r\n            return slow;\r\n        }   \r\n    }\r\n\r\n    return nullptr;\r\n}\r\n```\r\n> + 时间复杂度: O(N)，N 为 s 长度\r\n> + 空间复杂度: O(1)\r\n\r\n----\r\n\r\n## 模板\r\n\r\n无模板","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195690164","body":"# Day 12. [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)\r\n## 思路\r\n\r\n要让 `put` 和 `get` 方法的时间复杂度为 O(1)，我们可以总结出 `cache` 这个数据结构必要的条件：\r\n\r\n1、显然 `cache` 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置；\r\n\r\n2、我们要在 `cache` 中快速找某个 `key` 是否已存在并得到对应的 `val`；\r\n\r\n3、每次访问 `cache` 中的某个 `key`，需要将这个元素变为最近使用的，也就是说 `cache` 要支持在任意位置快速插入和删除元素。\r\n\r\n\r\n\r\n\r\n\r\nLRU 缓存算法的核心数据结构就是**哈希链表**，**双向链表**和**哈希表**的结合体。这个数据结构长这样：\r\n\r\n![image](https://user-images.githubusercontent.com/30496905/181057314-f135514d-295e-4e97-b911-41f7f002c528.png)\r\n\r\n1、如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。\r\n\r\n2、对于某一个 `key`，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 `val`。\r\n\r\n3、链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 `key` 快速映射到任意一个链表节点，然后进行插入和删除。\r\n\r\n\r\n\r\n为什么必须要用双向链表?\r\n\r\n因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。\r\n\r\n\r\n\r\n```c++\r\nstruct DLinkedNode{\r\n    int key, value;\r\n    DLinkedNode* next;\r\n    DLinkedNode* prev;\r\n    DLinkedNode() : key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}\r\n}\r\n```\r\n\r\n首先使用哈希表定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 $O(1)$ 的时间内完成 `get` 或者 `put` 操作。具体方法如下：\r\n\r\n- 对于 `get` 操作，首先判断 `key` 是否存在：\r\n\r\n  - 如果 `key` 不存在，则返回 `-1`；\r\n  - 如果 `key` 存在，则 `key` 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值\r\n\r\n- 对于 `put` 操作，首先判断 `key` 是否存在：\r\n\r\n  - 如果 `key` 不存在，使用 `key` 和 `value` 创建一个新的节点，在双向链表头部添加该节点；并将 `key` 和该节点添加到哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；\r\n  - 如果 `key` 存在，则与 `get` 操作类似，先通过哈希表定位，再将对应的节点的值更新为 `value`，并将该节点移到双向链表的头部。\r\n\r\n  \r\n\r\n在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。\r\n\r\n\r\n\r\n\r\n\r\n```c++\r\nclass LRUCache {\r\nprivate:\r\n\tunordered_map<int, DLinkedNode*> _cache;\r\n    DLinkedNode* _head;\r\n    DLinkedNode* _tail;\r\n    int _size;\r\n    int _capacity;\r\n    \r\npublic:\r\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\r\n        // 使用伪头部和伪尾部节点\r\n        _head = new DLinkedNode();\r\n        _tail = new DLinkedNode();\r\n        _head->next = _tail;\r\n        _tail->prev = _head;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!_cache.count(key)) { // 如果 key 不存在，添加一个新的节点\r\n            DLinkedNode* node = new DLinkedNode(key, value);\r\n            _cache[key] = node;\r\n            addToHead(node);\r\n            ++_size;\r\n            \r\n            if (_size > _capacity) {\r\n                // 删除双向链表的尾部节点\r\n                DLinkedNode* removed = removeTail();\r\n                // 删除哈希表中对应的项\r\n                _cache.erase(removed->key);\r\n                // 防止内存泄露\r\n                delete removed;\r\n                --_size;\r\n            }\r\n        } else {\t\t\t// key 存在，修改value，并移至头部\r\n            DLinkedNode* node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }        \r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!_cache.count(key)) {\r\n            return -1;\r\n        }\r\n        // 如果 key 存在，先通过哈希表定位，再移到头部\r\n        DLinkedNode* node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void moveToHead(DLinkedNode* node) {\r\n    \tremoveNode(node);\r\n        addToHead(node);\r\n    }\r\n    \r\n    // 对应官方图解第 3 > 4 图\r\n    void addToHead(DLinkedNode* node) {\r\n        node->prev = head;\t\t\t\t// 1->prev = head;\r\n        node->next = head->next;\t\t// 1->next = 2;\r\n        head->next->prev = node;\t\t// 2->prev = 1;\r\n        head->next = node;\t\t\t\t// head->next = 1;\r\n    }\r\n    \r\n    // 对应官方图解第 3 > 4 图\r\n\tvoid removeNode(DLinkedNode* node) {\r\n        node->prev->next = node->next;\t// 2->next = dummy_Tail\r\n        node->next->prev = node->prev;\t// dummy_Tail->prev = 2\r\n        // 此时 2 被完全隔开\r\n    }\r\n    \r\n    // 对应官方图解第 4 > 5 图\r\n    DLinkedNode* removeTail() {\r\n        DLinkedNode node = tail->prev;\t\t// 2 = tail->prev\r\n        removeNode(node);\t\t\t\t\t// remove(2)\r\n        return node;\t\t\t\t\t\t// return 2\r\n    }\r\n    \r\n    \r\n}\r\n```\r\n\r\n> + 时间复杂度: O(1)，对于 put 和 get 都是 O(1)。\r\n> + 空间复杂度: O(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素。\r\n\r\n----\r\n## 模板\r\n\r\n无模板\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196893728","body":"# Day 13. [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\r\n## BFS\r\n\r\n```c++\r\nint maxDepth(TreeNode* root) {\r\n    if (root == nullptr) return 0;\r\n\r\n    queue<TreeNode*> q;\r\n    q.push(root);\r\n\r\n    int res = 0;\r\n    while (q.size()) {\r\n        int size = q.size();\r\n\r\n        for (int i = 0; i < size; ++i) {\r\n            auto cur = q.front(); q.pop();\r\n            if (cur->left) q.push(cur->left);\r\n            if (cur->right) q.push(cur->right);\r\n        }\r\n\r\n        res++;\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n> + 时间复杂度: O(N)，其中 n 为二叉树的节点个数。\r\n> + 空间复杂度: 空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。\r\n\r\n----\r\n\r\n## DFS\r\n\r\n\r\n```c++\r\nconstexpr int inf = 0x3f3f3f3f;\r\nclass Solution {\r\npublic:\r\n    void dfs(TreeNode* root, int resT) {\r\n        if (root == nullptr) {\r\n            res = max(res, resT);\r\n            return;\r\n        }\r\n\r\n        dfs(root->left, resT + 1);\r\n        dfs(root->right, resT + 1);\r\n        return;\r\n    }\r\n\r\n    int maxDepth(TreeNode* root) {\r\n        res = -inf;\r\n        dfs(root, 0);\r\n        return res;\r\n    }\r\n\r\nprivate:\r\n    int res;    \r\n};\r\n```\r\n\r\n\r\n> + 时间复杂度: O(N)，其中 N 为二叉树节点的个数。每个节点在递归中只被遍历一次。\r\n> + 空间复杂度: O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度.\r\n\r\n\r\n## 模板\r\n\r\n无模板","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185589950","body":"# 思路\r\n\r\n```\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n```\r\n\r\n# 代码\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int K) {\r\n        int a_len = A.size() - 1, sum = 0, carry = 0;\r\n        vector<int> res;\r\n        while (a_len >= 0 || K != 0) {\r\n            int x = a_len >= 0 ? A[a_len] : 0;\r\n            int y = K != 0 ? K % 10 : 0;\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            sum %= 10;\r\n            K /= 10;\r\n            a_len--;\r\n            res.push_back(sum);\r\n        }\r\n        if (carry != 0)\r\n            res.push_back(carry);\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n# 复杂度\r\n+ 时间复杂度：O(n);\r\n+ 空间复杂度：O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225771","body":"# 思路\r\n```\r\n记录下c的索引，然后每个字符挨个求最小值\r\n```\r\n\r\n# 代码\r\n```\r\nvector<int> shortestToChar(string &s, char c) {\r\n        vector<int> index;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s[i] == c) {\r\n                index.push_back(i);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s[i] == c)\r\n                res.push_back(0);\r\n            else {\r\n                int min_index = s.length();\r\n                for (int j = 0; j < index.size(); j++) {\r\n                    int deterval = index[j] - i >= 0 ? index[j] - i : i - index[j];\r\n                    if (deterval < min_index)\r\n                        min_index = deterval;\r\n                }\r\n                res.push_back(min_index);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n# 复杂度\r\n+ 空间：O(N)\r\n+ 时间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186547531","body":"/*\r\n * 1. 思路: 正常的用数组直接操作,incr的时间复杂度为O(k), 可以用前缀和用时间换空间\r\n * 2. 时间复杂度: O(1), 空间复杂度: O(1)\r\n * */\r\n \r\n```\r\nclass CustomStack\r\n{\r\npublic:\r\nCustomStack(int maxSize)\r\n{\r\n    this->maxSize = maxSize;\r\n    stack = new int[maxSize];\r\n    incre = new int[maxSize];\r\n    cur = 0;\r\n}\r\n\r\nvoid push(int x)\r\n{\r\n    if (cur == maxSize)\r\n        return;\r\n    stack[cur] = x;\r\n    incre[cur] = 0;\r\n    cur++;\r\n}\r\n\r\nint pop()\r\n{\r\n    if (cur == 0)\r\n        return -1;\r\n    int res = stack[cur - 1] + incre[cur - 1];\r\n    if (cur > 1)\r\n        incre[cur - 2] += incre[cur - 1];\r\n    incre[cur - 1] = 0;\r\n    cur--;\r\n    return res;\r\n}\r\n\r\nvoid increment(int k, int val)\r\n{\r\n    if (cur == 0)\r\n        return ;\r\n    if (k > cur)\r\n        incre[cur - 1] += val;\r\n    else\r\n        incre[k - 1] += val;\r\n}\r\n\r\n~CustomStack()\r\n{\r\n    delete[] stack;\r\n    delete[] incre;\r\n}\r\nprivate:\r\nint maxSize;\r\nint* stack;\r\nint* incre;\r\nint cur;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186853934","body":"/*\r\n * 1、思路: 利用栈，非']'即入栈，否则出栈;\r\n * 2、出栈的时候注意将一个[]之内解码好的压回栈，最后在对栈中所有解码后的字符串进行拼接;\r\n * 2、需要注意char转string，利用string的构造函数string(n, char);\r\n * 3、数字可能是多位的，因此需要注意转换;\r\n * 4、时间复杂度O(n), 空间复杂度O(n)\r\n * */\r\n\r\n```\r\nstring decodeString(string &s)\r\n    {\r\n        stack<string> data;\r\n        for(int i = 0; i < s.length(); i++)\r\n        {\r\n            // 数字、字母和左方括号入栈\r\n            if ((s[i] >= '0' && s[i] <= '9') || (s[i] == '[') || (s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z'))\r\n            {\r\n                data.push(string(1, s[i]));\r\n            }\r\n                // 右方括号出栈\r\n            else\r\n            {\r\n                string cur = \"\";\r\n                while(data.top().data()[0] != '[')\r\n                {\r\n                    cur = data.top() + cur;\r\n                    data.pop();\r\n                }\r\n                data.pop();\r\n                // 取整数\r\n                int digit = 0;\r\n                int carry = 1;\r\n                while(!data.empty() && data.top().data()[0] >= '0' && data.top().data()[0] <= '9')\r\n                {\r\n                    digit = digit + (data.top().data()[0] - '0') * carry;\r\n                    carry *= 10;\r\n                    data.pop();\r\n                }\r\n                string res = \"\";\r\n                for (int j = 0; j < digit; j++)\r\n                    res += cur;\r\n                data.push(res);\r\n            }\r\n        }\r\n        string res = \"\";\r\n        while(!data.empty())\r\n        {\r\n            res = data.top() + res;\r\n            data.pop();\r\n        }\r\n        return res;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189128910","body":"/*\r\n * leetcode: 232\r\n * 用两个栈模拟队列,可以通过在pop时只有reverse为空时再倒腾栈来优化\r\n * 时间复杂度:均摊O(1), 空间复杂度:O(n)\r\n * */\r\n\r\n```\r\nclass MyQueue{\r\npublic:\r\n    MyQueue()\r\n    {\r\n\r\n    }\r\n\r\n    void push(int x)\r\n    {\r\n        normal_stack.push(x);\r\n    }\r\n\r\n    int pop()\r\n    {\r\n        if (reverse_stack.empty())\r\n        {\r\n            while(!normal_stack.empty())\r\n            {\r\n                reverse_stack.push(normal_stack.top());\r\n                normal_stack.pop();\r\n            }\r\n        }\r\n\r\n        int res = reverse_stack.top();\r\n        reverse_stack.pop();\r\n        return res;\r\n    }\r\n\r\n    int peek()\r\n    {\r\n        if (reverse_stack.empty())\r\n        {\r\n            while(!normal_stack.empty())\r\n            {\r\n                reverse_stack.push(normal_stack.top());\r\n                normal_stack.pop();\r\n            }\r\n        }\r\n\r\n        int res = reverse_stack.top();\r\n        return res;\r\n    }\r\n\r\n    bool empty()\r\n    {\r\n        return (normal_stack.empty() && reverse_stack.empty());\r\n    }\r\nprivate:\r\n    stack<int> normal_stack;\r\n    stack<int> reverse_stack;\r\n\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190458724","body":"/*\r\n * 1.思路: 单调栈大值融合小值构成递增栈\r\n * 2.时间复杂度: O(n), 空间复杂度:O(n)\r\n * */\r\n ```\r\nint maxChunksToSorted(vector<int>& arr)\r\n    {\r\n        stack<int> info;\r\n        int max_value;\r\n        for(auto it: arr)\r\n        {\r\n            if(!info.empty() && it < info.pop())\r\n            {\r\n                max_value = info.top();\r\n                if(it < max_value)\r\n                {\r\n                    while(!info.empty() && info.top() > it)\r\n                    {\r\n                        info.pop();\r\n                    }\r\n                    info.push(max_value);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                info.push(it);\r\n            }   \r\n        }\r\n        return info.size();\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191587809","body":"/*\r\n * 1. 思路:快慢指针找到倒数第k个节点然后断链重拼\r\n * 2. 时间复杂度:O(n), 空间复杂度O(1)\r\n * */\r\n ```\r\nListNode* rotateRight(ListNode *head, int k)\r\n    {\r\n        if(head == nullptr)\r\n            return nullptr;\r\n        int len_list = 0;\r\n        ListNode *p = head;\r\n        while(p)\r\n        {\r\n            len_list++;\r\n            p = p->next;\r\n        }\r\n        k = k % len_list;\r\n        ListNode *slow, *fast;\r\n        slow = head;\r\n        fast = head;\r\n        for(int i = 0; i < k; i++)\r\n        {\r\n            fast = fast->next;\r\n        }\r\n        while(fast->next)\r\n        {\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n        ListNode *new_head = slow->next;\r\n        slow->next = nullptr;\r\n        fast->next = head;\r\n        return new_head;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192144541","body":"/*\r\n * 1. 思路1: 两两交换，记录在交换过程中会断连的节点，last_tail和new_head;\r\n * 2. 思路1时间复杂度: O(n), 空间复杂度O(1)\r\n * 3. 思路2(递归): (1)关注最小子结构即将两个节点逆转;\r\n *               (2)当前的第二个节点的next为下一次递归的起点;\r\n *               (3)递归返回逆转后的头节点;\r\n *               (4)将逆转结果赋值给head的next.\r\n * 4. 思路2时间复杂度: O(n), 空间复杂度: O(1)(不考虑递归造成的函数栈)\r\n * */\r\n \r\n```\r\nListNode *swapPairs(ListNode *head) {\r\n        if (head == nullptr || head->next == nullptr)\r\n            return head;\r\n        ListNode *p, *q, *new_head, *last_tail;\r\n        new_head = head->next;\r\n        p = head;\r\n        q = head->next;\r\n        last_tail = nullptr;\r\n        while (p && q) {\r\n            ListNode *tmp_head = q->next;\r\n            // 交换\r\n            if (q != nullptr) {\r\n                p->next = tmp_head;\r\n                q->next = p;\r\n\r\n            }\r\n            // 拼接\r\n            if (last_tail != nullptr) {\r\n                last_tail->next = q;\r\n            }\r\n            last_tail = p;\r\n            // 挪指针\r\n            p = tmp_head;\r\n            if (p != nullptr)\r\n                q = p->next;\r\n        }\r\n        return new_head;\r\n    }\r\n\r\n    ListNode *swapPairs_v1(ListNode *head)\r\n    {\r\n        if(head == nullptr || head->next == nullptr)\r\n            return head;\r\n        ListNode *next = head->next;\r\n        head->next = swapPairs_v1(next->next);\r\n        next->next = head;\r\n        return next;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193097937","body":"/*\r\n * 1.思路: 分析每次找到中间值然后递归构造左右子树;\r\n * 2.递归的三个要点:a.判断子结构及退出递归边界;b.如何从当前递归进入下一次递归;c.当前递归与递归返回值的关系.\r\n * 3.时间复杂度O(nlogn), 空间复杂度O(logn)\r\n * 4.时间复杂度解析:递归树深logn, 每一层递归树的时间复杂度为2*(n / 2)=n, 所以总的时间复杂度为nlogn, n/2即寻找中间节点的时间复杂度\r\n * 5.空间复杂度分析:递归树深logn, 每一层递归树的空间复杂度为O(1), 所以总的空间复杂度为logn\r\n * */\r\n \r\n```\r\nTreeNode* toBST(ListNode*head, int len)\r\n    {\r\n        if (head == nullptr || len == 0)\r\n            return nullptr;\r\n        // 判断边界条件\r\n        if(len == 1)\r\n        {\r\n            TreeNode *node = new TreeNode(head->val);\r\n            return node;\r\n        }\r\n        ListNode *p;\r\n        p = head;\r\n        for(int k = 0; k < len / 2; k++)\r\n            p = p->next;\r\n        TreeNode *new_head = new TreeNode(p->val);\r\n        int left_length = len / 2;\r\n        int right_length = len / 2;\r\n        if (len % 2 == 0)\r\n            right_length = len / 2 - 1;\r\n        new_head->left = toBST(head, left_length);\r\n        new_head->right = toBST(p->next, right_length);\r\n        return new_head;\r\n    }\r\n\r\nTreeNode* sortedListToBST(ListNode* head)\r\n    {\r\n        if(head == nullptr)\r\n            return nullptr;\r\n        int len = 0;\r\n        ListNode *p = head;\r\n        while(p)\r\n        {\r\n            len++;\r\n            p = p->next;\r\n        }\r\n        return toBST(head, len);\r\n    }\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193284161","body":"/*\r\n * 1. 题目理解: 最开始理解成结点的值相等了,然而题目是结点相等,包括结点的值和next即指向结点的指针(地址)相等;\r\n * 2. 思路1: 空间换时间, 先遍历A然后遍历B找B中是否含A中的结点,含则返回;\r\n * 3. 思路1: 时间复杂度O(n), 空间复杂度O(n);\r\n * 4. 思路2: 两个指针p,q分别从headA和headB开始遍历一遍两个链表,相等则停止遍历,说明找到了相交的结点,\r\n * 5. headA:A+C, headB:B+C,遍历完p遍历了A+C+B, q遍历了B+C+A;\r\n * 6. 思路2: 时间复杂度O(n), 空间复杂度O(1).\r\n * */\r\n\r\n```\r\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB)\r\n    {\r\n        map<ListNode*, bool> infoA;\r\n        ListNode *p = headA;\r\n        while(p)\r\n        {\r\n            infoA[p] = true;\r\n            p = p->next;\r\n        }\r\n        p = headB;\r\n        while(p)\r\n        {\r\n            if(infoA.find(p) != infoA.end()) return p;\r\n            p = p->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n\r\n    ListNode *getIntersectionNodev1(ListNode *headA, ListNode *headB)\r\n    {\r\n        ListNode *a = headA;\r\n        ListNode *b = headB;\r\n        while(a != b)\r\n        {\r\n            a = a == nullptr ? headB : a->next;\r\n            b = b == nullptr ? headA:  b->next;\r\n        }\r\n        return a;\r\n\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194214380","body":"/*\r\n * 1.思路１:空间换时间,　边遍历边存到哈希表中，若遇到在哈希表在中存在的结点则说明是环的起始点；\r\n * 2.思路１时间复杂度:O(n), 空间复杂度O(n);\r\n * 3.思路2: 快慢指针, 快指针每次bu步长为2, m慢指针步ｃ长为１, 当快慢指针第一次相遇时;\r\n * 4.思路2:慢指针指向下一个,快指针指向头结点, 快慢指针都以步长为1往前走,这样再次相遇时即为环开始的结点;\r\n * 5.思路2分解,假设链分为L+C,C为第一次相遇的结点,环长等于C+D, 那么第一次相遇慢指针走了L+n1*(C+D)+C\r\n * 5.思路2分解,第一次相遇快指针走了L+n2*(C+D)+C,又因为快指针走的距离是慢指针的两倍,所以存在等式:\r\n * 5.思路2分解,2*(L+n1*(C+D)+C) = L+n2*(C+D)+C, 整理可得, L = (2*n2-n1-1)*(C+D) + D\r\n * 5.思路2分解,这样q走L等于p走D,p和q在环起始点相遇.\r\n * 6.思路2时间复杂度:O(n), 空间复杂度O(1).\r\n * */\r\n\r\n```\r\nListNode *detectCycle(ListNode *head)\r\n    {\r\n        map<ListNode*, bool> data;\r\n        ListNode *p = head;\r\n        while(p && data.find(p) == data.end())\r\n        {\r\n            data[p] = true;\r\n            p = p->next;\r\n        }\r\n        return p;\r\n    }\r\n\r\n    ListNode *detectCyclev1(ListNode *head)\r\n    {\r\n        if (head == nullptr || head->next == nullptr)\r\n            return nullptr;\r\n        ListNode *p, *q;\r\n        p = head;\r\n        q = head->next;\r\n        while(p != q)\r\n        {\r\n            p = p->next;\r\n            if (q && q->next)\r\n                q = q->next->next;\r\n            else\r\n                q = nullptr;\r\n        }\r\n        if (p == nullptr)\r\n            return nullptr;\r\n        q = head;\r\n        p = p->next;\r\n        while(p != q)\r\n        {\r\n            p = p->next;\r\n            q = q->next;\r\n        }\r\n        return p;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195309209","body":"/*\r\n * 1.思路1: 用两个哈希表，一个存key和value，一个存最后一次被访问的时间;\r\n * 2.思路1时间复杂度:O(n), 空间复杂度:O(n).\r\n * 3.思路2: 用双向链表结合哈希表来实现，双向链表为访问的先后顺序，哈希表存key对应的结点以节省链表查找结点的时间;\r\n * 3.思路2: 用两个空的结点来表示head和tail，以兼容头结点尾结点变化的情况;\r\n * 4.思路2的时间复杂度:O(1), 空间复杂度:O(n)\r\n * */\r\n \r\n```\r\nclass LRUCache\r\n{\r\npublic:\r\n    LRUCache(int capacity)\r\n    {\r\n        cap = capacity;\r\n        cur = 0;\r\n        len = 0;\r\n    }\r\n\r\n    int get(int key)\r\n    {\r\n        if(info.find(key) != info.end())\r\n        {\r\n            cur++;\r\n            update[key] = cur;\r\n            return info[key];\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    void put(int key, int value)\r\n    {\r\n        if(len == cap && info.find(key) == info.end())\r\n        {\r\n            // 删除最久未使用的\r\n            int min_use = cur + 1;\r\n            int min_key;\r\n            for(auto it : update)\r\n            {\r\n                if(it.second < min_use)\r\n                {\r\n                    min_use = it.second;\r\n                    min_key = it.first;\r\n                }\r\n            }\r\n            info.erase(min_key);\r\n            update.erase(min_key);\r\n            len--;\r\n        }\r\n        cur++;\r\n        if (info.find(key) == info.end())\r\n            len++;\r\n        info[key] = value;\r\n        update[key] = cur;\r\n\r\n    }\r\n\r\n\r\nprivate:\r\n    int cap;\r\n    int cur;\r\n    int len;\r\n    unordered_map<int, int> info;\r\n    unordered_map<int, int> update;\r\n\r\n};\r\n```\r\n\r\n```\r\nstruct DLinkedNode\r\n{\r\n    int key;\r\n    int value;\r\n    DLinkedNode *pre;\r\n    DLinkedNode *next;\r\n    DLinkedNode(): key(0), value(0), pre(nullptr), next(nullptr) {}\r\n    DLinkedNode(int key, int value): key(key), value(value), pre(nullptr), next(nullptr) {}\r\n    DLinkedNode(int key, int value, DLinkedNode *pre, DLinkedNode *next): key(key), value(value), pre(pre), next(next) {}\r\n};\r\n\r\nclass LRUCache\r\n{\r\npublic:\r\n    LRUCache(int capacity)\r\n    {\r\n        cap = capacity;\r\n        info_len = 0;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->pre = head;\r\n    }\r\n\r\n    void update_tail(DLinkedNode *p)\r\n    {\r\n        p->pre->next = p->next;\r\n        p->next->pre = p->pre;\r\n\r\n        p->pre = tail->pre;\r\n        tail->pre->next = p;\r\n        p->next = tail;\r\n        tail->pre = p;\r\n    }\r\n\r\n    int get(int key)\r\n    {\r\n        if(info.find(key) != info.end())\r\n        {\r\n            // 更新链表顺序\r\n            DLinkedNode *p = info[key];\r\n            update_tail(p);\r\n            return info[key]->value;\r\n\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    void put(int key, int value)\r\n    {\r\n        // 当前key不存在\r\n        if(info.find(key) == info.end())\r\n        {\r\n            // 判断当前的长度是否达到cap，达到则删除头结点\r\n            if(info_len == cap)\r\n            {\r\n                // 将头结点删除\r\n                DLinkedNode *p = head->next;\r\n                head->next = p->next;\r\n                p->next->pre = head;\r\n                info_len--;\r\n                info.erase(p->key);\r\n                delete p;\r\n\r\n            }\r\n            info_len++;\r\n            DLinkedNode *p = new DLinkedNode(key, value);\r\n            // 修改尾指针\r\n            tail->pre->next = p;\r\n            p->pre = tail->pre;\r\n            p->next = tail;\r\n            tail->pre = p;\r\n            info[key] = p;\r\n        }\r\n        // 当前key已存在\r\n        else\r\n        {\r\n            // 将key挪到最后\r\n            DLinkedNode *p = info[key];\r\n            p->value = value;\r\n            update_tail(p);\r\n        }\r\n    }\r\n\r\n\r\n\r\nprivate:\r\n    // 目的就是减少链表查找结点复杂度，查找方便\r\n    unordered_map<int, DLinkedNode*> info;\r\n    //双向链表存储结点的访问先后，优先是已知给定节点，插入，删除方便；\r\n    // 结点在链表中从头到尾为，最早访问 -> 最近访问的顺序；\r\n    // 所以头结点为最早访问的结点，当当前链表的长度为cap且要put的时候要将头结点删除，将最新的结点放到tail的pre；\r\n    // head的next指向头结点，tail的pre指向尾结点.\r\n    DLinkedNode *head, *tail;\r\n    int cap;\r\n    int info_len;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196301951","body":"/*\r\n * 1.思路:递归套路，找到子结构，确定边界条件，确定怎么入递归，确定递归返回值与当前的关系；\r\n * 2.时间复杂度:O(n), 每次遍历一个结点, 空间复杂度:O(h), h为树的高度，最快的情况为退化成单链表为O(n)\r\n * */\r\n *\r\n```\r\nclass Solution\r\n{\r\npublic:\r\n    int dfs(TreeNode* root, int cnt)\r\n    {\r\n        // 判断退出条件\r\n        if(root->left == nullptr && root->right == nullptr)\r\n        {\r\n            return cnt+1;\r\n        }\r\n        // 进入下一次递归\r\n        cnt++;\r\n        int cnt_left = 0;\r\n        if(root->left)\r\n            cnt_left = dfs(root->left, cnt);\r\n        // 递归退出与当前的关系\r\n        if (cnt_left > depth)\r\n            depth = cnt_left;\r\n        // 左边遍历完了遍历右边\r\n        int cnt_right = 0;\r\n        if(root->right)\r\n            cnt_right = dfs(root->right, cnt);\r\n        if (cnt_right > depth)\r\n            depth = cnt_right;\r\n        // 都遍历完了返回\r\n        return depth;\r\n    }\r\n    int maxDepth(TreeNode* root)\r\n    {\r\n        depth = 0;\r\n        if (root == nullptr)\r\n            return depth;\r\n        int cnt = 0;\r\n        return dfs(root, cnt);\r\n    }\r\nprivate:\r\n    int depth;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197585745","body":"/*\r\n * 1.思路: 层序遍历加标记左右子树,判断结构是否相等;\r\n * 2.时间复杂度:O(n), 空间复杂度:O(n).\r\n * */\r\n \r\n```\r\nbool isSameTree(TreeNode* p, TreeNode* q)\r\n    {\r\n        queue<TreeNode*> info_p, info_q;\r\n        if (p != nullptr)\r\n            info_p.push(p);\r\n        if (q != nullptr)\r\n            info_q.push(q);\r\n        while(!info_p.empty())\r\n        {\r\n            TreeNode *head_p = info_p.front();\r\n            int p_left = 0, p_right = 0;\r\n            if (head_p->left)\r\n            {\r\n                info_p.push(head_p->left);\r\n                p_left = 1;\r\n            }\r\n            if(head_p->right)\r\n            {\r\n                info_p.push(head_p->right);\r\n                p_right = 1;\r\n            }\r\n            info_p.pop();\r\n\r\n            if(!info_q.empty())\r\n            {\r\n                TreeNode *head_q = info_q.front();\r\n                int q_left = 0, q_right = 0;\r\n\r\n                if (head_q->left)\r\n                {\r\n                    info_q.push(head_q->left);\r\n                    q_left = 1;\r\n                }\r\n                if(head_q->right)\r\n                {\r\n                    info_q.push(head_q->right);\r\n                    q_right = 1;\r\n                }\r\n                info_q.pop();\r\n                if(p_left != q_left || p_right != q_right || head_p->val != head_q->val)\r\n                    return false;\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n\r\n        }\r\n        if(!info_q.empty())\r\n            return false;\r\n        return true;\r\n\r\n    }\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185593642","body":"## 思路\n\n> + 思路描述\n倒着过一遍num，和k逐位相加。\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        idx = len(num) - 1\n        while k or idx > -1:\n            cur = k % 10 + num[idx] if idx >= 0 else k % 10\n            k //= 10\n            if cur >= 10:\n                k += 1\n                cur = cur % 10\n            res.append(cur)\n            idx -= 1\n        res.reverse()\n        return res\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186180673","body":"## 思路\n\n> + 思路描述\n正向和负向各计算一次，每次一个指针找c一个指针指向尚未计算的元素\n\n```python\n#代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s)] * len(s)\n        i = 0\n        for j in range(len(s)):\n            if s[j] == c:\n                while i <= j:\n                    res[i] = min(res[i], j - i)\n                    i += 1\n        i = len(s) - 1\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                while i >= j:\n                    res[i] = min(res[i], i - j)\n                    i -= 1\n        return res\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(n)\n> + 空间复杂度:  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186544663","body":"## **思路：用数组模拟**\n\n朴素的模拟方法\n\n### **代码**\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = list()\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) < k:\n            self.stack = [n+val for n in self.stack]\n        else:\n            self.stack = [n+val for n in self.stack[:k]] + self.stack[k:]\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n) push pop是O(1)，increment是O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188955309","body":"## 思路\n一个栈存放数字，一个栈存放字母\n```python\n代码\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i, char in enumerate(s):\n            if char != ']':\n                stack.append(char)\n            elif char == ']':\n                repeat_s = ''\n                while stack and stack[-1] != '[':\n                    repeat_s = stack.pop() + repeat_s\n                stack.pop() # pop 掉'['\n                cnt = ''\n                while stack and stack[-1].isdigit():\n                    cnt = stack.pop() + cnt\n                repeat_s = repeat_s * int(cnt)\n                stack.append(repeat_s) \n        return ''.join(stack)\n```\n\n## 复杂度分析\n- 时间复杂度：O(n) \n- 空间复杂度：O(n) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189184499","body":"## 思路\n- 两个栈来回变换，两个栈stackin和stackout一个只用来进新的元素一个只用来出结果。用一个辅助的self.front变量，记录stackin最前面的元素。\n- pop的时候，可以在stackout空的时候倒出来，不空的时候直接出栈顶即可。peak的时候，如果stackout非空的话，肯定就是栈顶的元素，否则，就是self.front.\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stackin = []\n        self.stackout = []\n        self.front = None\n\n    def push(self, x: int) -> None:\n        if not self.stackin:\n            self.front = x\n        self.stackin.append(x)\n\n    def pop(self) -> int:\n        if not self.stackout:\n            while self.stackin:\n                self.stackout.append(self.stackin.pop())\n        if self.empty():\n            return\n        return self.stackout.pop()\n\n    def peek(self) -> int:\n        return self.stackout[-1] if self.stackout else self.front\n\n    def empty(self) -> bool:\n        return not self.stackin and not self.stackout\n```\n\n## 复杂度\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1191393742","body":"## 思路\n一开始的做法是找单调底层的地方，在每个单调递增的地方切块，是不对的。也就是扫描数组，记录下一个大于数i的数，如果是单调递增的，下一个比数i大的数就是1，记录递增的数量（每次加1），递增数量和就是结果，但是[4,2,2,1,1]过不了。所以题目还有一层意思就是每一个块要比前一个块大，每个块的最小要比前一个块的最大要大。\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i, v in enumerate(arr):\n            if stack and stack[-1] > v:\n                cur = stack[-1]\n                while stack and stack[-1] > v:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(v)\n        \n        return len(stack)\n```\n\n## 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191636009","body":"## 思路\n先计算链表的长度，记为cnt，k对链表长度取余是要旋转的次数，旋转几次，就是倒数第几个链表拆出来作为头，相当于找到要旋转断开的地方，拆成两个链表，把后面的链表拼到前面链表上，后面链表指向头，前面链表指向None\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return\n        cnt = 0\n        cur = head\n        while cur:\n            cur = cur.next\n            cnt += 1\n        k = k % cnt\n        cur = head\n        cut = 0\n        res = None\n        while cur.next:\n            cut += 1\n            if cut == cnt - k:\n                tmp = cur.next\n                cur.next = None\n                cur = tmp\n                res = cur\n            else:\n                cur = cur.next\n        if res:\n            cur.next = head\n            \n        return res if res else head\n```\n\n## 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192651609","body":"## 思路\n加一个dummy头，需要两个指针作为prev和cur，可以容易找头节点，因为最后返回肯定是要头节点的\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head:\n            return head\n        dummy_node = ListNode(-1)\n        dummy_node.next = head\n        prev_node, cur_node = dummy_node, head\n        while cur_node and cur_node.next:\n            next_node = cur_node.next\n            prev_node.next = next_node\n            next_cur_node = next_node.next\n            next_node.next = cur_node\n            cur_node.next = next_cur_node\n            prev_node, cur_node = cur_node, next_cur_node\n\n        return dummy_node.next\n```\n\n## 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1194025279","body":"## 思路：递归+双指针\n把链表想象成一个绳子，每次操作是从中间把绳子拎起来。用递归的方式把问题缩小，每次找到中间的节点作为root，左边接链表的前半部分sort后的二叉搜索树，后面接链表后半部分sort后的二叉搜索树。其中中间节点用快慢指针找到。要注意的是，如果只有一个节点的话，也要退出递归的，因为这样left和listnode会一直这样，就会出不来。\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def balanced_tree(listnode):\n            if not listnode:\n                return None\n            # 如果节点中只有1个的话，left就一直是listnode，退出不了递归\n            if not listnode.next:\n                return TreeNode(listnode.val)\n            # 找中点\n            prev = ListNode(-1)\n            prev.next = listnode\n            slow, fast = listnode, listnode\n            while fast and fast.next:\n                prev = prev.next\n                slow = slow.next\n                fast = fast.next.next\n            cur_head = TreeNode(slow.val)\n            prev.next = None\n            left, right = listnode, slow.next\n            cur_head.left, cur_head.right = balanced_tree(left), balanced_tree(right)\n\n            return cur_head\n        return balanced_tree(head)\n```\n\n## 复杂度\n- 时间复杂度 O(n*logn)\n- 空间复杂度 O(logn)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1194048778","body":"## 思路\n遍历a全部放进哈希表，遍历b如果见到已经在哈希表中的则就是要找的节点，否则没有节点\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a = headA\n        b = headB\n        if not a or not b:\n            return None\n        hash = {}\n        while a:\n            hash[a] = 1\n            a = a.next\n        while b:\n            if b in hash:\n                return b\n            else:\n                b = b.next\n        return None\n```\n\n## 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194070467","body":"## 思路\n遍历链表看节点是否遇见过，但是哈希方法复杂度不满足进阶要求\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        hash = {}\n        while head:\n            if head not in hash:\n                hash[head] = 1\n            else:\n                return head\n            head = head.next\n        return None\n```\n\n## 复杂度\n- 时间复杂度: O(n)\n- 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185598055","body":"## 思路\r\n\r\n> + 参考题解后解答，回去查看讲义和类似题目 巩固之\r\n\r\n##代码\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] A, int K) {\r\n    List<Integer> res = new ArrayList<>();\r\n    int carry = 0;\r\n    int l1 = A.length - 1;\r\n    while (l1 >= 0 || K != 0) {\r\n        int x = l1 < 0 ? 0 : A[l1];\r\n        int y = K == 0 ? 0 : K % 10;\r\n\r\n        int sum = x + y + carry;\r\n        res.add(sum % 10);\r\n        carry = sum / 10;\r\n\r\n        l1--;\r\n        K = K / 10;\r\n    }\r\n    if (carry != 0) res.add(carry);\r\n    Collections.reverse(res);\r\n    return res;\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225705","body":"### 思路\r\n\r\n双向遍历，记录最小的值\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        // 从左往右遍历\r\n        for (int i = 0, index = -n; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = i - index;\r\n\r\n        }\r\n        \r\n        // 从右往左遍历\r\n        for (int i = n - 1, index = 2 * n; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = Math.min(res[i], index - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551756","body":"### 思路\r\n\r\n有点迷糊，参考题解 多次调试大概理解 数组模拟栈的思路 继续研究一下\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != stack.length -1){\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k,top+1);\r\n        for (int i = 0; i < limit; ++i){\r\n            stack[i] = stack[i] + val;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187669690","body":"### 思路\r\n\r\n想起算法4中Dijkstra的双栈算术表达式求值算法，思路一样 只不过将()变成[] \r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Integer> tStack = new Stack<>();\r\n        Stack<String> sStack = new Stack<>();\r\n        String temp = \"\";\r\n        int times = 0;\r\n\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if (Character.isDigit(c)) {\r\n                times = times * 10 + c - '0';\r\n                continue;\r\n            }\r\n            if (c == '[') {\r\n                sStack.push(temp);\r\n                tStack.push(times);\r\n                temp = \"\";\r\n                times = 0;\r\n                continue;\r\n            }\r\n            if (c == ']') {\r\n                temp = sStack.pop() + temp.repeat(tStack.pop());\r\n                continue;\r\n            }\r\n            temp = temp + c;\r\n        }\r\n        return temp;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189229330","body":"### 思路\r\n\r\n栈先进后出  队列先进先出\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nimport java.util.Stack;\r\n\r\n//leetcode submit region begin(Prohibit modification and deletion)\r\nclass MyQueue {\r\n    // 创建两个栈 出入\r\n    Stack<Integer> stkIn;\r\n    Stack<Integer> stkOut;\r\n    public MyQueue() {\r\n        stkIn = new Stack<>();\r\n        stkOut = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stkIn.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (stkOut.isEmpty()){\r\n            while(!stkIn.isEmpty()){\r\n                stkOut.push(stkIn.pop());\r\n            }\r\n        }\r\n        return stkOut.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (stkOut.isEmpty()) {\r\n            while(!stkIn.isEmpty()){\r\n                stkOut.push(stkIn.pop());\r\n            }\r\n        }\r\n        return stkOut.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stkOut.isEmpty() && stkIn.isEmpty();\r\n    }\r\n}\r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190428049","body":"### 思路\r\n\r\n对数组进行循环入栈，遇到大于等于栈顶的元素直接入栈，若小于栈顶的元素，先取出栈顶元素，然后入栈 \r\n栈的元素个数即为所得块的最大个数\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nimport java.util.Stack;\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> resStk = new Stack<>();\r\n        resStk.push(arr[0]);\r\n        for (int i = 1; i < arr.length; i++ ) {\r\n            if(!resStk.isEmpty() && arr[i] >= resStk.peek()){\r\n                resStk.push(arr[i]);\r\n            } else {\r\n                int curMax =resStk.pop();\r\n                while(!resStk.isEmpty() && resStk.peek() > arr[i]) {\r\n                    resStk.pop();\r\n                }\r\n                resStk.push(curMax);\r\n            }\r\n        }\r\n        return resStk.size();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度:O(n)\r\n空间复杂度:O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193344327","body":"### 思路\r\n\r\n双指针 分别从两个链表头结点开始遍历，遍历完一个之后从另一个链表头结点继续遍历\r\n若两个指针相遇，则相遇点是所求交点 若不相遇，返回null\r\n\r\n### 代码\r\n\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null)\r\n        {return null;}\r\n\r\n        ListNode Pa = headA;\r\n        ListNode Pb = headB;\r\n\r\n        while (Pa != Pb) {\r\n            if (Pa == null) {\r\n                Pa = headB;\r\n            } else {\r\n                Pa = Pa.next;\r\n            }\r\n            if (Pb == null) {\r\n                Pb = headA;\r\n            } else {\r\n                Pb = Pb.next;\r\n            }\r\n        }\r\n        return Pa;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度:O(n)\r\n空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194216885","body":"### 思路\r\n\r\n双指针 快慢指针 分别从两个链表头结点开始遍历\r\nslow走一步 fast走两步 相遇即为环所在点\r\n然后将指针指向head，与slow再次相遇即为环的节点\r\n否则返回null\r\n\r\n\r\n### 代码\r\n\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return null;\r\n        }\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n\r\n        while (fast != null) {\r\n            slow =  slow.next;\r\n            if (fast.next != null) {\r\n                fast = fast.next.next;\r\n            } else {\r\n                return null;\r\n            }\r\n\r\n            while (fast == slow) {\r\n                ListNode idx = head;\r\n                if (idx != slow) {\r\n                    idx = idx.next;\r\n                    slow = slow.next;\r\n                }\r\n                return idx;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度:O(n)\r\n空间复杂度:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196900125","body":"### 思路\r\n\r\n深度优先搜索 递归2\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int leftHeight = maxDepth(root.left);\r\n        int rightHeight = maxDepth(root.right);\r\n        return Math.max(leftHeight,rightHeight) + 1;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度:O(n)\r\n空间复杂度:O(H)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185599809","body":"## 思路\r\n把 k 转换成数组，再将 num 和 k 两个数组反转。双指针，从头到尾依次将余数插入结果数组中。\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  const num1 = num.reverse();\r\n  const num2 = k\r\n    .toString()\r\n    .split(\"\")\r\n    .map((item) => parseInt(item))\r\n    .reverse();\r\n  const result = [];\r\n  let m = 0;\r\n  let n = 0;\r\n  let extra = 0;\r\n  while (m < num1.length && n < num2.length) {\r\n    const sum = num1[m++] + num2[n++] + extra;\r\n    extra = sum > 9 ? 1 : 0;\r\n    result.push(sum % 10);\r\n  }\r\n  while (m < num1.length) {\r\n    const sum = num1[m++] + extra;\r\n    extra = sum > 9 ? 1 : 0;\r\n    result.push(sum % 10);\r\n  }\r\n  while (n < num2.length) {\r\n    const sum = num2[n++] + extra;\r\n    extra = sum > 9 ? 1 : 0;\r\n    result.push(sum % 10);\r\n  }\r\n  if (extra) {\r\n    result.push(1);\r\n  }\r\n  return result.reverse();\r\n};\r\n```\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186218481","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n  const result = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    for (let j = 0; j < s.length; j++) {\r\n      if (s[j] === c) {\r\n        result[i] = Math.abs(i - j);\r\n        break;\r\n      }\r\n    }\r\n    for (let j = s.length - 1; j >= 0; j--) {\r\n      if (s[j] === c && Math.abs(i - j) < result[i]) {\r\n        result[i] = Math.abs(i - j);\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186532482","body":"## 思路\r\n顺序栈，学过数据结构的都懂\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.ptr = 0;\r\n  this.stack = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.ptr < this.maxSize) {\r\n    this.stack[this.ptr++] = x;\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  if (this.ptr === 0) {\r\n    return -1;\r\n  }\r\n  return this.stack[--this.ptr];\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < Math.min(k, this.ptr); i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187635454","body":"```javascript\r\nvar decodeString = function (s) {\r\n  let numStack = [];\r\n  let strStack = [];\r\n\r\n  let num = 0,\r\n    result = \"\";\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    const item = s[i];\r\n\r\n    if (!isNaN(item)) {\r\n      num = num * 10 + parseInt(item);\r\n    } else if (item === \"[\") {\r\n      strStack.push(result);\r\n      result = \"\";\r\n      numStack.push(num);\r\n      num = 0;\r\n    } else if (item === \"]\") {\r\n      const repeatTimes = numStack.pop();\r\n      result = strStack.pop() + result.repeat(repeatTimes);\r\n    } else {\r\n      result += item;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189199748","body":"```javascript\r\nvar MyQueue = function () {\r\n  this.front = null;\r\n  this.stack1 = [];\r\n  this.stack2 = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n  if (this.stack1.length === 0) {\r\n    this.front = x;\r\n  }\r\n  this.stack1.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n  if (this.stack2.length === 0) {\r\n    while (this.stack1.length > 0) {\r\n      this.stack2.push(this.stack1.pop());\r\n    }\r\n  }\r\n  return this.stack2.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n  if (this.stack2.length > 0) {\r\n    return this.stack2[this.stack2.length - 1];\r\n  }\r\n  return this.front;\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n  return this.stack1.length === 0 && this.stack2.length === 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190392983","body":"## 思路\r\n前缀和\r\n\r\n## 代码\r\n```javascript\r\nvar maxChunksToSorted = function (arr) {\r\n  let sum1 = 0;\r\n  let sum2 = 0;\r\n  let ans = 0;\r\n  let arr2 = [...arr].sort((a, b) => a - b);\r\n  for (let i in arr) {\r\n    sum1 = sum1 + arr[i];\r\n    sum2 = sum2 + arr2[i];\r\n    if (sum1 == sum2) {\r\n      ans += 1;\r\n      sum1 = 0;\r\n      sum2 = 0;\r\n    }\r\n  }\r\n  return ans;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191572805","body":"```javascript\r\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\r\n    if (head === null || k === 0) return head\r\n    let temp = head\r\n    let n = 1\r\n    while (temp.next) {\r\n        temp = temp.next\r\n        n++\r\n    }\r\n    temp.next = head\r\n\r\n    k = n - k % n - 1\r\n    while (k > 0) {\r\n        head = head.next\r\n        k--\r\n    }\r\n\r\n    const res = head.next\r\n    head.next = null\r\n    return res\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192630124","body":"```javascript\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n  const dummy = new ListNode(0)\r\n  let pre = dummy\r\n  pre.next = head\r\n  while (pre.next && pre.next.next) {\r\n    let one = pre.next\r\n    let two = one.next;\r\n    [pre.next, one.next, two.next] = [two, two.next, one]\r\n    pre = one\r\n  }\r\n\r\n  return dummy.next\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193125223","body":"```javascript\r\nvar sortedListToBST = function(head) {\r\n   const arr = []\r\n   while(head){\r\n       arr.push(head.val)\r\n       head=head.next\r\n   }\r\n   return buildBST(arr,0,arr.length-1)\r\n   function buildBST(arr,start,end){\r\n      if (start > end) return null;\r\n     let mid = Math.floor((start+end)/2)\r\n     const root= new TreeNode(arr[mid])\r\n     root.left=buildBST(arr,start,mid-1)\r\n     root.right=buildBST(arr,mid+1,end)\r\n     return root\r\n   }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193344644","body":"```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA, b = headB;\r\n    while(a !== b) {\r\n        a = a ? a.next : headB;\r\n        b = b ? b.next : headA;\r\n    }\r\n    return a;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185613290","body":"           public List<Integer> addToArrayForm(int[] num, int k) {\n\n        List<Integer> res=new ArryList<Integer>();\n        int n=num.length;\n        for(int i=n-1;i>=0;--i)\n        {\n            int sum=num[i] + k % 10;//如果K=123这个数，那K % 10 取出来的是个数的余数，即把3取出来\n            K / =10;//相当于K=K/10；就是123除于10并取整返回，那就是往前进一位，返3去掉，返回12值给下一次用\n            if(sum>=10)//如果sum得出来的值大于10\n            {\n                k++;//把进位的值放在k上，即k进一位，加1\n                sum-=10;//把相加的值减掉进位\n            }\n            res.add(sum);\n        }\n        //如果num的位数小于K的位数，那还需要多一步处理K剩下的数\n        for(; k > 0;k / =10)//每次循环K的前进一位，如果小于0则表示已经没有数可以进位了\n        {\n            res.add(k % 10 ); //把K的余数取出来返回\n        }\n\n        Collections.reverse(res);\n        return res;\n\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186173222","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n=s.length();\n        int[] ans=new int[n];\n        for(int i=0,idx=-n;i<n;++i)\n        {\n            //第一层循环，从左往右找，主要是先找到值，更新找到值的后面偏移量，idx的初始值无所谓\n            if(s.charAt(i)==c)\n            {\n                idx=i;\n            }\n            ans[i]=i-idx;\n        }\n    //开始第二层循环,从右往左找\n      for(int i=n-1,idx=2*n;i>=0;--i)\n        {\n            if(s.charAt(i)==c)\n            {\n                idx=i;\n            }\n            ans[i]=Math.min(ans[i],idx-i);\n\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186413613","body":"//定义这个类，必须要有弹出和增加数据的接口\r\n//新增一个限制的数，还控制数量的增加，每次增和弹出栈的时候，先弹出数组的那个数，限制再减一\r\n\r\n class customerStack2{\r\n\r\n    int[] stack;\r\n    int top;\r\n\r\n    public customerStack2(int maxSize)\r\n    {\r\n    stack=new int[maxSize];\r\n    top =-1;\r\n    }\r\n\r\n    //新增一个数\r\n    public void push(int x)\r\n    {\r\n        if(top!=stack.length-1)\r\n\r\n        {\r\n            top++;\r\n            stack[top]=x;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    // 弹出一个数\r\n    public   int pop()\r\n    {\r\n\r\n        if (top==-1)\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        --top;\r\n        return stack[top+1];\r\n\r\n    }\r\n\r\n    //在每个数据上面增加一个数字\r\n    public void increment(int k,int x)\r\n    {\r\n\r\n        int max=Math.min(k, top+1);\r\n        for(int i=0;i<max;i++)\r\n        {\r\n         \r\n            stack[i] +=x;\r\n        }\r\n\r\n\r\n    }\r\n\r\n }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186728695","body":"//用栈来解决\n//数字和字母都进栈，当碰到】号时，就开始循环重复生成字符串，生完后再反转\n\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190402692","body":"public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        int nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        //arr=2,1,3,4,4\n        //expect=1，2，3，4，4\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i];\n            int y = expect[i];\n            //第一轮，x=2，y=1\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            //count.map key=2,value=1\n            //nonzero=1;\n\n            //第二轮，x=1，y=2\n            //count.map key=1,value=1\n            //nonzero=1\n\n            if (count.get(x) == 0) {\n                nonzero--;\n            }\n            if (count.get(x) == 1) {\n                nonzero++;\n            }\n\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n\n            //count map key=1 value=-1\n            //nonzero=2\n\n            //第二轮\n            //count map key=2 value=0；\n\n            //nonzero=1\n\n            if (count.get(y) == -1) {\n                nonzero++;\n            }\n            if (count.get(y) == 0) {\n                nonzero--;\n            }\n\n            if (nonzero == 0) {\n                ans++;\n            }\n        }\n\n        return ans;\n    }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192693913","body":"    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n    }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193150087","body":"     public ListNode getINstersectionNode(ListNode headA,ListNode headB)\n     {\n        Set<ListNode> visted=new HashSet<ListNode>();\n        ListNode temp=headA;\n        while(temp!=null)\n        {\n            visted.add(temp);\n            temp=temp.next;\n        }\n\n        temp=headB;\n        while(temp!=null)\n        {\n            if(visted.contains(temp))\n            {\n                return temp;\n            }\n            temp=temp.next;\n\n        }\n\n        return null;\n\n\n     }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193468206","body":"     public static ListNode getLoopNode(ListNode head)\n     {\n\n        if(head==null||head.next==null||head.next.next==null)\n        {\n            return null;\n        }\n\n        ListNode n1=head.next;\n\n        ListNode n2=head.next.next;\n        while(n1!=n2)\n        {\n            if(n2.next==null||n2.next.next==null)\n            {\n                return null;\n            }\n            n2=n2.next.next;\n            n1=n1.next;\n        }\n\n        n2=head;\n        while(n1!=n2)\n        {\n            n1=n1.next;\n            n2=n2.next;\n        }\n\n        return n1;\n     }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196268918","body":"var maxDepth = function(root) {\n    if(root === null) return 0\n    return Math.max(maxDepth(root.left),maxDepth(root.right))+1\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197596811","body":"public boolean isSameTree (ListNode p,ListNode q)\n{\n\n    if(q==null&&p==null) return true;\n    if (q==null ||p==null) return false;\n    if(p.val!=q.val) return false;\n    return isSameTree(p.left, q.left)&&isSameTree(p.right, q.right);\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185615180","body":"```ts\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const res: number[] = []\n\n    // 从数组的最右边开始计算，来模拟数字相加操作\n    const len = num.length\n\n    for (let i = len - 1; i >= 0; --i) {\n        let carry = num[i] + k % 10\n\n        k = Math.floor(k / 10)\n\n        if (carry >= 10) {\n            k++\n            carry = carry - 10\n        }\n\n        res.push(carry)\n    }\n\n    while (k > 0) {\n        res.push(k % 10)\n        k = Math.floor(k / 10)\n    }\n\n    res.reverse()\n\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186207697","body":"```ts\n/**\n * 正反遍历:\n * 思路为正反两个方向都遍历一次数据，然后取两次数组每个下表比较的最小值即可\n */\nfunction shortestToChar(s: string, c: string): number[] {\n    const n = s.length\n\n    /** 先定义一个跟 s 长度一样的数组去存储值 */\n    const answer: number[] = new Array(n).fill(0)\n\n    // 正向遍历\n    for (let i = 0, j = -n; i < n; i++) {\n        if (s[i] === c) {\n            j = i\n        }\n\n        // 计算每个下标到 \"c\" 字符串的距离\n        answer[i] = i - j\n\n    }\n\n    // 反向遍历\n    for (let i = n - 1, j = 2 * n; i >= 0; i--) {\n        if (s[i] === c) {\n            j = i\n        }\n\n        answer[i] = Math.min(answer[i], j - i)\n\n    }\n\n    return answer\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186416013","body":"```ts\nclass CustomStack {\n    protected stack!: number[]\n    protected top!: number\n\n    constructor(maxSize: number) {\n        this.stack = new Array(maxSize)\n        this.top = -1\n    }\n\n    push(x: number): void {\n        // 只要是不超过栈的最大长度\n        if (this.top !== this.stack.length - 1) {\n            this.top++\n            this.stack[this.top] = x\n        }\n    }\n\n    pop(): number {\n        // 判断为空的栈\n        if (this.top === -1) {\n            return -1\n        }\n        this.top--\n        return this.stack[this.top + 1]\n    }\n\n    increment(k: number, val: number): void {\n        const limit = Math.min(k, this.top + 1)\n        for (let i = 0; i < limit; i++) {\n            this.stack[i] = this.stack[i] + val\n        }\n    }\n}\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187648428","body":"```ts\n/**\n * @author liuyuan\n * @date 2022-07-18 22:39\n * @since 1.0.0\n */\n\nfunction decodeString(s: string): string {\n    // 重复字符串\n    let stack_count: any[] = []\n    let stack_str: any[] = []\n\n    let result = ''\n\n    // 重复次数的栈\n    let count = 0\n\n    for (let i = 0; i < s.length; i++) {\n        // 当前遍历到的字符串\n        let item = s[i]\n\n        if (!isNaN(Number(item))) {\n            count = count * 10 + parseInt(item)\n        } else if (item === '[') {\n            stack_str.push(result)\n            result = ''\n\n            stack_count.push(count)\n            count = 0\n        } else if (item === ']') {\n            const repeatTimes = stack_count.pop()\n            result = stack_str.pop() + result.repeat(repeatTimes)\n        } else {\n            result = result + item\n        }\n    }\n\n    return result\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189062920","body":"```ts\nclass MyQueue {\n    protected inStack: number[]\n\n    protected outStack: number[]\n\n    constructor() {\n        this.inStack = []\n        this.outStack = []\n    }\n\n    push(x: number): void {\n        this.inStack.push(x)\n    }\n\n    /**\n     * 把所有的数据都弹入另一个队列，然后在另一个队列 pop()\n     */\n    pop(): number {\n        if (!this.outStack.length) {\n            this.formatIn2Out()\n        }\n\n        return this.outStack.pop() as number\n    }\n\n    peek(): number {\n        if (!this.outStack.length) {\n            this.formatIn2Out()\n        }\n\n        return this.outStack[this.outStack.length - 1]\n    }\n\n    empty(): boolean {\n        return !this.inStack.length && !this.outStack.length\n    }\n\n    formatIn2Out() {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop() as number)\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190392499","body":"使用滑动窗口解法，只需要排序后的数组跟原数组进行比较，判断分区后的代码总和与原数组一致即可判断为可分区\n\n```ts\nfunction maxChunksToSorted(arr: number[]): number {\n    const sorted = [...arr]\n\n    sorted.sort((a, b) => a - b)\n\n    let count = 0\n\n    /** 原分组的和 */\n    let sum1 = 0\n\n    /** 分块后的数组的和 */\n    let sum2 = 0\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 = sum1 + arr[i]\n\n        sum2 = sum2 + sorted[i]\n\n        if (sum1 === sum2) {\n            count++\n        }\n    }\n\n    return count\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191276779","body":"```ts\n\n\n/** \n * 思路: \n * 旋转链表，其实就是把倒数第二位的 next -> null, 然后最后一位的 next 从 null 指向于头部,这个流程就是旋转了一位\n * 假设如题目中的 1 -> 2 -> 3 -> 4 -> 5 旋转一位，其实就是 4 -> null 和 5 -> 1, 然后再返回最后一位指向 head 最后一个节点，即可得到结果\n * \n * 推算:\n * 以此为推算，就可以假设移动的最后一个节点为 K, 倒数第二位节点为 K+1\n * 也就是 (K+1).next = null , K.next = head, 然后返回 K 即可\n * \n * 计算移动位数的时候，只需要考虑到 k & count(链表长度)的结果即可， 因为长度为 3 的链表往右边移动 4 位跟往右边移动一位的结果是一样的\n */\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    /** 排除空链表和移动为 0 的极端情况 */\n    if (!head || !head?.next || k === 0) {\n        return head\n    }\n\n    /** 链表中的总长度, 上面判断了空和长度为 0 的情况，所以长度至少为 1 */\n    let count = 1\n\n    let p = head\n\n    /** 计算链表的总长度 */\n    while (p?.next !== null) {\n        p = p.next\n        count++\n    }\n\n    /** 最终移动的位置 */\n    k = k % count\n\n    let slow: ListNode | null = head\n\n    let fast: ListNode | null = head\n\n    while (fast?.next) {\n        if (k-- <= 0) {\n            slow = slow.next!\n        }\n        fast = fast.next\n    }\n\n    /** \n     * 此时已经形成一个环形链表了, 然后把慢指针的 next 返回即为结果，然后再把 next -> null 来砍断链表\n     */\n    fast!.next = head\n\n    const res = slow.next\n\n    slow.next = null\n\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192593174","body":"```ts\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    if (!head || !head?.next) {\n        return head\n    }\n\n    let preNode = new ListNode()\n\n    preNode.next = head\n\n    let p = preNode\n\n    while (p?.next !== null && p?.next?.next !== null) {\n        const node1 = p.next\n        const node2 = p.next.next\n\n        p.next = node2\n\n        node1.next = node2.next\n\n        node2.next = node1\n\n        p = node1\n    }\n\n    return preNode.next\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193115317","body":"```ts\n/**\n * 采用快慢指针方法，快指针移动到末尾的时候，慢指针刚好指到中间\n */\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    if (!head) {\n        return null\n    }\n\n    return dfs(head, null)\n};\n\nfunction dfs(head: ListNode, tail: ListNode | null) {\n    if (head === tail) {\n        return null\n    }\n\n    let slow = head\n    let fast = head\n\n    /** 根据快慢指针，快指针结束的时候，慢指针刚好到中间 */\n    while (fast !== tail && fast.next !== tail) {\n        fast = fast.next!.next!\n        slow = slow.next!\n    }\n\n    const root = new TreeNode(slow.val)\n    root.left = dfs(head, slow)!\n    root.right = dfs(slow.next!, tail)!\n    return root\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193266938","body":"```ts\n/**\n * 如果有相交点的话，A + C + B 肯定和 B + C + A 有交点，就可以考虑用双指针来进行遍历\n * \n * 时间复杂度: O(m + n) 最坏的情况下就是要遍历两个链表， m 为 A 的长度，n 为 B 的长度\n * 空间复杂度: O(1) 没有线性增长的结构\n */\nfunction getIntersectionNode_Double(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n    if (!headA || !headB) {\n        return null\n    }\n\n    let p1: ListNode | null = headA\n    let p2: ListNode | null = headB\n\n    while (p1 !== p2) {\n        p1 = p1 ? p1.next : headB\n        p2 = p2 ? p2.next : headA\n    }\n\n    // 反正 p1 p2 都可以，遍历到最后如果是没有相交的话都是为 null\n    return p1\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194115287","body":"双指针写法\n```ts\n/**\n * @author liuyuan\n * @date 2022-07-25 22:00\n * @since 1.0.0\n */\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction detectCycle(head: ListNode | null): ListNode | null {\n    if (!head || !head.next) {\n        return null\n    }\n\n    let p1: ListNode | null = head\n    let p2: ListNode | null = head\n\n    while (p1 && p2) {\n        p1 = p1?.next || null\n        p2 = p2.next?.next || null\n\n        if (p1 === p2) {\n            // return p1\n            let ptr: ListNode | null = head\n\n            while (ptr !== p1) {\n                ptr = ptr?.next || null\n                p1 = p1?.next || null\n            }\n\n            return ptr\n        }\n    }\n\n    return null\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195581811","body":"这道题有点难，没有作出 O(1)的解法，暂时用 map 的 O(N)来解答题目的要求\n```ts\n/**\n * @author liuyuan\n * @date 2022-07-26 22:15\n * @since 1.0.0\n */\n\nclass LRUCache {\n    protected capacity!: number\n    protected map: Map<number, number> = new Map()\n\n    constructor(capacity: number) {\n        this.capacity = capacity\n        this.map = new Map()\n    }\n\n    get(key: number): number {\n        if (this.map.has(key)) {\n            const value = this.map.get(key) as number\n\n            /** 在 js 里面，map 是有存入的先后顺序的，所以只需要删除该节点再加入即可 */\n            this.map.delete(key)\n            this.map.set(key, value)\n\n            return value\n        }\n\n        return -1\n    }\n\n    put(key: number, value: number): void {\n        /** 有就删掉再赋值 */\n        if (this.map.has(key)) {\n            this.map.delete(key)\n        }\n\n        this.map.set(key, value)\n\n        /** 判断容量大小，淘汰掉末位 */\n        if (this.map.size > this.capacity) {\n            this.map.delete(this.map.keys().next().value)\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196810195","body":"```ts\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction maxDepth(root: TreeNode | null): number {\n    let deepLen = 0\n\n    /**\n     *\n     * @param root {TreeNode | null} 树的节点\n     * @param len {number} 节点的长度\n     * @returns\n     */\n    const dfs = (root: TreeNode | null, len: number) => {\n        if (!root) {\n            return\n        }\n\n        // console.log(root.val)\n\n        // 这一行不用每个遍历都判断，只需要判断是否为 “叶子节点” 即可\n        // deepLen = Math.max(deepLen, len)\n        if (!root.left && !root.right) {\n            deepLen = Math.max(deepLen, len)\n        }\n\n        dfs(root.left, len + 1)\n        dfs(root.right, len + 1)\n    }\n\n    dfs(root, 1)\n\n    return deepLen\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197619512","body":"```ts\n/**\n * 直接用深度优先遍历递归自身节点即可\n */\n\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    if (!p || !q) {\n        return !p && !q\n    }\n\n    return (\n        p.val === q.val &&\n        isSameTree(q.left, p.left) &&\n        isSameTree(q.right, p.right)\n    )\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185615532","body":"### **思路：加法问题**\n\n倒着过一遍num，和k逐位相加。\n\n1. k的位数：用取mod和地板除可以直接把k用掉的位置扔掉，同时如果要进位，直接进位到k上即可。是一种比较便捷的方式。\n2. 一开始想用先初始化n长度的list存储结果，但是其实list长度很难定，所以可以直接用reverse，reverse复杂度是O(n)\n3. 注意会有k长度比num大的情况的！并不都是k长度小于n，所以要考虑遍历完还有k或者carry的情况\n    \n\n### **代码**\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        res = []\n        for i in range(len(num)-1, -1, -1):\n            cur_n = num[i]\n            cur_add = k % 10\n            add_n = cur_n + cur_add + carry\n            res.append(add_n % 10)\n            carry = add_n // 10\n            k //= 10\n        while k or carry:\n            cur_add = k % 10\n            add_n = cur_add + carry\n            res.append(add_n % 10)\n            carry = add_n // 10\n            k //= 10\n        res.reverse()\n        return res\n\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(min(n,k)) reverse复杂度是O(n) 所以是n长度和k长度最小值\n- 空间复杂度：O(1) 没有额外空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186173638","body":"## **思路: 正反双指针**\n\n正向和负向各计算一次，每次一个指针找c一个指针指向尚未计算的元素\n\n### **代码**\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s)] * len(s)\n        i = 0\n        for j in range(len(s)): # j是右指针，右指针碰到c的话，就开始计算左指针\n            if s[j] == c:\n                while i <= j:\n                    res[i] = min(res[i], j-i)\n                    i += 1\n        i = len(s) - 1\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                while i >= j:\n                    res[i] = min(res[i], i-j)\n                    i -= 1\n        return res\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(2n) n是s长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186525310","body":"## **思路2：前缀和思想**\n\n用一个incrementals数组来记录加的数字最远加到哪里。在pop出去的时候只要对应找该位置加了多少即可，不需要全部都记录\n\n### **代码**\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.st = []\n        self.cnt = 0\n        self.size = maxSize\n        self.increments = [0] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n        \n    def pop(self) -> int:\n        if self.cnt == 0:\n            return -1\n        # 如果只剩一个元素，直接是pop出去\n        # 如果多于一个元素，pop出去的同时，更前面的元素要继承一下加的val\n        if self.cnt >= 2:\n            self.increments[self.cnt-2] += self.increments[self.cnt-1]\n        res = self.st.pop() + self.increments[self.cnt-1]\n        self.increments[self.cnt-1] = 0\n        self.cnt -= 1\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        # 分界线的地方+val，只在pop的时候才考虑加多少\n        if self.cnt:\n            self.increments[min(k, self.cnt)-1] += val\n        \n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(maxsize/n)  把n当作操作数的话，平均来看是maxsize/n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187596495","body":"### **思路**\n\n不是']'就全部入栈，碰到']'开始解码，解码就是一个个拆出来，碰到'['停止拆字符串，碰到数字就另外算要重复的数字是多少。这里有两个地方容易错，一个是数字未必是个位数，一个是出栈之后的str不要直接拼到结果上，继续入栈（不然这样的case无法通过\"3[a2[c]]\"），最后把栈当作结果join一下即可。\n\n### **代码**\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i, char in enumerate(s):\n            if char != ']':\n                stack.append(char)\n            elif char == ']':\n                repeat_s = ''\n                while stack and stack[-1] != '[':\n                    repeat_s = stack.pop() + repeat_s\n                stack.pop() # pop 掉'['\n                cnt = ''\n                while stack and stack[-1].isdigit(): # 可能有多个数字\n                    cnt = stack.pop() + cnt\n                repeat_s = repeat_s * int(cnt)\n                stack.append(repeat_s) # 这里是一个要点，重复的字符串直接压回栈里\n        return ''.join(stack)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n) 遍历\n- 空间复杂度：O(n) 用了辅助站","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189002648","body":"思路\n相当于两个栈容器，互相倒来倒去。\n代码\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.stack2:\n            return self.stack2.pop()\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.stack2:\n            return self.stack2[-1]\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.stack1) + len(self.stack2) == 0\n\n复杂度分析\n时间复杂度：O(n) 最坏O(n)，最好O(1)\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190237191","body":"### **思路1：单调栈**\n\n一开始的做法是**找单调递增的地方，在每个单调递增的地方切块，是不对的。**也就是扫描数组，记录下一个大于数i的数，如果是单调递增的，下一个比数i大的数就是1，记录递增的数量（每次加1），递增数量和就是结果，但是`[4,2,2,1,1]`过不了！所以题目还有一层意思就是**每一个块要比前一个块大**，每个块的最小要比前一个块的最大要大。\n\nsukki的图很清楚：\n\n[https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/)\n\n### **代码**\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = [] # 用单调栈存储一个块的最大值，单调栈是递增的\n        for i, n in enumerate(arr):\n            if stack and n < stack[-1]: # 碰到更小的值，就得把前面的一个个拿出来，知道形成新的块能够合并掉这个最小值\n                cur_val = stack[-1]\n                while stack and n < stack[-1]:\n                    stack.pop()\n                stack.append(cur_val)\n            else: # 碰到更大的值，可以无脑作为一个新的块\n                stack.append(n)\n        return len(stack)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190998189","body":"### **思路**\n\n先计算链表的长度，记为cnt，k对链表长度取余是要旋转的次数，旋转几次，就是倒数第几个链表拆出来作为头，相当于找到要旋转断开的地方，拆成两个链表，把后面的链表拼到前面的链表上，后面链表指向头，前面链表指向None\n\n### **代码**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head:\n            return\n        cnt = 0\n        cur = head\n        while cur:\n            cur = cur.next\n            cnt += 1\n        k = k % cnt\n        cur = head\n        cut = 0\n        res = None\n        while cur.next: # cur会停在最后一个node\n            cut += 1\n            if cut == cnt - k: # 碰到要切断的node，就是cur.next\n                tmp = cur.next\n                cur.next = None\n                cur = tmp\n                res = cur\n            else:\n                cur = cur.next\n        if res:\n            cur.next = head\n        return res if res else head\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192127172","body":"### **思路：双指针**\n\n加一个dummy头，需要两个指针作为prev和cur，为什么需要一个dummy呢？这样可以容易找头节点，因为最后返回肯定是要头节点的。\n\n\n### **代码**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = ListNode()\n        dummy.next = head\n        pre, cur = dummy, head\n        while cur and cur.next:\n            next_pre = cur\n            next_cur = cur.next.next\n            switch_node = cur.next\n            pre.next = switch_node\n            switch_node.next = cur\n            cur.next = next_cur\n            cur = next_cur\n            pre = next_pre\n        return dummy.next\n\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146754","body":"思路：递归+双指针\r\n把链表想象成一个绳子，每次操作是从中间把绳子拎起来。用递归的方式把问题缩小，每次找到中间的节点作为root，左边接链表的前半部分sort后的二叉搜索树，后面接链表后半部分sort后的二叉搜索树。其中中间节点用快慢指针找到。\r\n要注意的是，如果只有一个节点的话，也要退出递归的，因为这样left和listnode会一直是一样的，就出不来\r\n\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def balanced_tree(listnode):\r\n            if not listnode:\r\n                return None\r\n            # 如果节点只有一个的话，left就一直是listnode，退出不了递归\r\n            if not listnode.next:\r\n                return TreeNode(listnode.val)\r\n            # 找中点\r\n            prev = ListNode(-1)\r\n            prev.next = listnode\r\n            slow, fast = listnode, listnode\r\n            while fast and fast.next:\r\n                prev = prev.next\r\n                slow = slow.next\r\n                fast = fast.next.next\r\n            cur_head = TreeNode(slow.val)\r\n            prev.next = None\r\n            left, right = listnode, slow.next\r\n            # # 不加这个会有问题\r\n            # if fast == slow:\r\n            #     return cur_head\r\n            cur_head.left, cur_head.right = balanced_tree(left), balanced_tree(right)\r\n\r\n            return cur_head\r\n        return balanced_tree(head)\r\n```\r\n复杂度分析\r\n时间复杂度：O(nlogn) 递归复杂度可以画出递归栈。每一层递归的操作是，寻找链表中间节点，第一次是n，第二次是两块分别找，是n/2+n/2，第三次是4个n/4，每一次都是n，也就是说递归的时候，每次找中间节点用时n，一共有logn层，所以是n*logn\r\n空间复杂度：O(logn)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193241518","body":"思路1：哈希\n比较直接，遍历a全部放进哈希表，遍历b如果见到已经在哈希表中的则就是要找的节点，否则没有交点\n代码\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA, headB):\n        a = headA\n        b = headB\n        if not a or not b:\n            return None\n        hash = {}\n        while a:\n            hash[a] = 1\n            a = a.next\n        while b:\n            if b in hash:\n                return b\n            else:\n                b = b.next\n        return None\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)\n思路2：双指针\nheada交点前面长度是a，headb交点前面长度是b，相交的部分长度是c。那指针1走完a一整段再走b，指针b走完b一整段再走a，一定走的长度一样。如果两者不相交，在走完a+b+c之后也会在None处相等，所以循环的出口是指针1d的值==指针2的值\n代码\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA, headB):\n        a = headA\n        b = headB\n        while a != b:\n            if not a:\n                a = headB\n            else: \n                a = a.next\n            if not b:\n                b = headA\n            else:\n                b = b.next\n        return a\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        l1 = headA\n        l2 = headB\n        while l1 or l2:\n            if l1 == l2:\n                return l2\n            if l1:\n                l1 = l1.next\n            else:\n                l1 = headB\n            if l2:\n                l2 = l2.next\n            else:\n                l2 = headA\n\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193988728","body":"### **思路2：双指针**\n\nX = Z，所以第一次快指针2步慢指针一步相遇之后，把快指针放到头节点，快慢指针都走一步再相遇的地方就是入口\n\n\n两个指针一快一慢。快指针每次走两步，慢指针每次走一步，如果有环，快指针先进入环，慢指针再进入。当慢指针刚进入环的时候，快指针就以每次一步的距离接近x，两者一定在环中相遇，假设慢指针刚入环的时候，快指针距离环入口n个距离，那慢指针再走n个距离的时候快指针就能追上了，这是**二者第一次相遇。但不能保证在环入口相遇。**\n\n如图假设，二者没有环的地方是x，相遇的地方离环入口y距离（其实就是上面的n），剩下的环长度是z，那么有：\n\n快指针走的路程是 x+k(y+z)+y\n\n慢指针走的路程是 x+j(y+z)+y\n\n由于快指针走的路程是慢指针的二倍，可以建立等式 \n\n$2(x+k(y+z)+y) =  x+j(y+z)+y$ \n\n可得：\n\n$x+y =  (j-k)(y+z)$ \n\n由于现在是要找x，整理x\n\n$x =  (j-k)(y+z) -y = (j-k-1)(y+z)+z$ \n\n其实就是**转整数圈的环+z，所以x = z**\n\n那这个结论有什么用呢？我们毕竟还不知道z是多少。目前我们有两个指针已经在y和z交汇处相遇，其实可以把快指针（再用一个新指针也完全可以）放到head的地方每次走一个位置，那各都走z长度，交汇点一定就是环入口\n\n### **代码**\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        x = None\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        return fast\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195597201","body":"### **思路：双向链表+哈希**\n\n\n由于要求的是O1的复杂度，要求删除、添加、换位置都是O1能够用的是链表和哈希，这题的关键就说用**双向链表+哈希，双向链表存储节点的顺序，哈希存储key对应的node**。这里要注意的是：\n\n（1）双向链表用**两个哨兵做头尾**会比较方便边界计算，用一个dummy头和一个curnode指针也可以，但是要每次改curnode的位置，容易错\n\n（2）put和get值的时候虽然不把node取出，但是都算访问了node，需要把node放到最后\n\n（3）双向链表直接存储key和val，不能只存val，因为key和val可能不一样\n\n### **代码**\n\n```python\nclass ListNode:\n    def __init__(self, key=None, val=None):\n        self.prev = None\n        self.next = None\n        self.val = val\n        self.key = key\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        # 初始化哈希表 {key: ListNode}\n        self.hashmap = dict()\n        # 初始化双向链表\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        # 如果在hash中，返回该值。放到双向链表最后\n        if key in self.hashmap:\n            self.move_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        return -1 if res == -1 else res.val\n            \n    def move_to_tail(self, key) -> None:\n        node = self.hashmap[key]\n\t\t\t\t# 拆出\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\t\t\t\t# 插入\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev.next = node\n        self.tail.prev = node\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # 若该key已经在双向链表中，把该key放到最后，并且改变值\n            self.hashmap[key].val = value\n            self.move_to_tail(key)\n            return\n        if len(self.hashmap) == self.capacity:\n            # 删除头节点\n            del_node = self.head.next\n            self.head.next = del_node.next\n            del_node.next.prev = self.head\n            self.hashmap.pop(del_node.key)\n\n        new_node = ListNode(key, value)\n        self.hashmap[key] = new_node\n        self.tail.prev.next = new_node\n        new_node.prev = self.tail.prev\n        new_node.next = self.tail\n        self.tail.prev = new_node\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196676665","body":"### **思路1：dfs-后序**\n\n本题可以使用前序（中左右），也可以使用后序遍历（**左右中**），使用前序求的就是深度，使用后序求的是高度。\n\n深度优先搜索，输入是节点，输出是当前root的最大深度；实现逻辑是当前节点的最大深度是左节点最大深度和右节点最大深度的max；出口是当前节点是none\n\n1. 确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型。\n2. 确定终止条件：如果为空节点的话，就返回0，表示高度为0。\n3. 确定单层递归的逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。\n\n### **代码**\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            # 传入节点，返回高度\n            if not node:\n                return 0\n            # 后续遍历，先看左右高度\n            l = dfs(node.left)\n            r = dfs(node.right)\n            dep = max(l, r)\n            return dep + 1\n        return dfs(root)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n) 每个节点遍历一次\n- 空间复杂度：O(h) 递归栈的栈空间是树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197597909","body":"### **思路：先序遍历+递归**\n\n前序地看每个节点是否相等，且输入是两个node\n\n（1）输入输出：输入是两个树的树节点，输出是节点是否相等\n\n（2）递归出口：如果有node是none，要么两个树相等的时候都是none，要么一个none一个不是none，前者是true后者是false\n\n（3）递归逻辑：要判断是否相等，要看当前节点相等，左节点相等、右节点相等\n\n### **代码**\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        def preorder(p_node, q_node):\n            # 先序地看p和q是否相等\n            if not p_node and not q_node:\n                return True\n            if not p_node or not q_node:\n                return False\n            cur_same = p_node.val == q_node.val\n            left_same = preorder(p_node.left, q_node.left)\n            right_same = preorder(p_node.right, q_node.right)\n            return cur_same and left_same and right_same\n        return preorder(p, q)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)每个节点遍历一次\n- 空间复杂度：O(h)递归栈大小是树的深度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185624746","body":"#### 解题思路\n  1. 低位到高位逐位将数字加在一起\n  2. 若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中\n#### 代码实现\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度: O(max(n,logk), 其中 nn 为数组的长度\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186215661","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186519978","body":"### 思路\n  用数组模拟栈，用数组原生方法pop、push方法实现\n  \n### 代码\n\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const length = Math.min(k, this.stack.length);\n  for (let i = 0; i < length; i++) {\n    this.stack[i] += val;\n  }\n};\n```\n### 复杂度\n- 时间复杂度 \n\n  push: O(1)\n\n  pop：O(1)\n  \n  increment：O(K) \n \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187022598","body":"### 思路\n1. 将字符串从末尾开始遍历\n2. 遇到“]”入栈\n3. 拼接要出栈的字符串，遇到\"[\"出栈\n4. \"[\"后紧跟数据，累计最终的数字\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\n\n### 代码\n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // 定义存储字符串的栈\n    let str = \"\"; // 定义最终返回的字符串\n    let num = \"\"; // 定义字符串重复的次数\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // 解析出连续的数字\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // 拼接字符\n        str = \"\";\n        num = \"\"; //清空计数\n        i++;\n      } else if (s[i] === \"[\") {\n        // 遇到\"[\"时，将后续字符出栈\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\n        }\n      } else {\n        // 将字符 或 \"]\"入栈\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### 复杂度分析\n- 时间复杂度：O(n),循环遍历一遍\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189096773","body":"### 解题思路\n    定义两个栈，\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\n\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$, N为队列元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190220524","body":"#### 解题思路\n> 单调栈\n\n#### 代码实现\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    //定义最大数据栈\n    let res=[]\n    for(let i = 0; i < arr.length; i++) {\n        if(res.length==0){\n            res.push(arr[i])\n        }else{\n            if(arr[i]>=res[res.length-1]){\n                res.push(arr[i])\n            }else{\n                let max=res[res.length-1]\n                while(arr[i]<res[res.length-1]){\n                    res.pop()\n                }\n                res.push(max)\n            }\n        }\n    }\n    return res.length\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N)$，N为数组长度\n- 空间复杂度：$O(N)$，N为数组长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191485317","body":"#### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n```\n#### 复杂度分析\n- 时间复杂度: $O(N)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192445404","body":"### 解题思路\n1. 设置虚拟节点，定义pre指针，指向当前虚拟节点\n2. 当pre.next以及pre.next.next指针均不为空时，开始交换\n3. 令cur指针指向pre.next；next指针指向pre.next.next\n4. 交换过程如下：\n- pre.next = next\n- cur.next = next.next\n- next.next = cur\n- pre = cur\n\n### 代码实现\njavaScript\n\n```\nvar swapPairs = function(head) {\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    let pre = dummyNode;\n    while(pre.next && pre.next.next) {\n        const cur = pre.next;\n        const next = pre.next.next;\n        pre.next = next;\n        cur.next = next.next;\n        next.next = cur;\n        pre = cur;\n    }\n    return dummyNode.next;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$, N为链表中节点数目\n- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193139438","body":"### 解题思路\n    分治 \n### 代码实现\njavaScript\n\n```\nvar sortedListToBST = function(head) {\n  if(!head) return null;\n  let length = 0;\n  let current = head;\n  while(current){\n    current = current.next\n    length++\n  }\n\n  var buildBST = function(start, end){\n    if(start > end) return null;\n\n    const mid = start + ((end - start)>> 1)\n    const leftSide = buildBST(start, mid - 1);\n\n    const root = new TreeNode(head.val)\n    head = head.next;\n    root.left = leftSide\n\n    root.right = buildBST(mid+1, end)\n    return root;\n  }\n\n  return buildBST(0, length - 1)\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(logN)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193331020","body":"### 解题思路：\n1. 使用pA、pB两个指针分别指向A、B两个链表，两个指针以相同的速率向后移动\n2. 当pA指针移动到了A链接的末尾、令指针pA指向B链表的头部\n3. 当pB指针移动到了A链接的末尾、令指针pB指向A链表的头部\n4. 当pA、pB指针相遇时即为两个指针相遇的起点，否则两个指针不相交\n\n```\nvar getIntersectionNode = function(headA, headB) {\n    let pA = headA;\n    let pB = headB;\n    while (pA != pB) {\n        pA = pA === null ? headB : pA.next;\n        pB = pB === null ? headA : pB.next;\n    }\n    return pA;\n};\n```\n### 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193821888","body":"### 解题思路\n\n从head开始快慢指针，快指针每次两步，慢指针每次一步，第一次相遇时将快指针回到head，改为每次前进一步，第二次相遇点为环起始点\n\n### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head === null || head.next === null) return null;\n    // 定义快慢两个指针、只想链表头部\n    let fast = head;\n    let slow = head;\n    // 快指针走两步，满指针走一步\n    do {\n        if (fast !== null && fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            fast = null\n        }\n        slow = slow.next;\n    } while(fast !== slow)\n    if (fast === null) return null;\n    // 相遇后将快指针指向链表头部\n    fast = head;\n    while(fast !== slow) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195338906","body":"### 解题思路\n    采用哈希表,保证get操作在O(1)时间复杂度内完成，\n    构建双向链表，保证put操作在O(1)时间复杂度内完成\n### 代码实现\n> javaScript\n\n```\nvar LinkedList = function(key, val) {\n    this.key = key;\n    this.val = val;\n    this.prev = null;\n    this.next = null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.size = 0;\n    this.cache = new Map();\n    // 构建虚拟节点\n    this.dummyHead = new LinkedList();\n    this.dummyTail = new LinkedList();\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (!this.cache.has(key)) {\n        return -1;\n    }\n    const node = this.cache.get(key);\n    // 将节点移动至链表头部\n    this.removeNode(node);\n    this.appendToHead(node);\n    return node.val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 判断关键字key是否存在于缓存中\n    const node = this.cache.get(key);\n    if (node) {\n        // 更新关键字的值\n        node.val = value;\n        this.cache.set(key, node);\n        // 将关键字移动至链表头部\n        this.removeNode(node);\n        this.appendToHead(node);\n    } else {\n        // 当缓存容量达到上限时\n        if (this.size === this.capacity) {\n            // 删除最久未使用的\n            this.removeTailNode();\n        }\n        // 创建新节点\n        const newNode = new LinkedList(key, value);\n        this.cache.set(key, newNode)\n        this.appendToHead(newNode);\n        this.size ++;\n    }\n};\n\nLRUCache.prototype.removeNode = function(node) {\n    let preNode = node.prev;\n    let nextNode = node.next;\n    preNode.next = nextNode;\n    nextNode.prev = preNode;\n}\n\nLRUCache.prototype.appendToHead = function(node) {\n    let head = this.dummyHead.next;\n    this.dummyHead.next = node;\n    node.prev = this.dummyHead;\n    node.next = head;\n    head.prev = node;\n}\n\nLRUCache.prototype.removeTailNode = function() {\n    this.size --;\n    let tailNode = this.dummyTail.prev;\n    this.cache.delete(tailNode.key);\n    this.removeNode(tailNode);\n}\n```\n### 复杂度分析\n- 时间复杂度：$O(1)$ \n- 空间复杂度：$O(capacity)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196572272","body":"### 解题思路\n> DFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root, depth = 0) {\n  if(!root) return depth;\n  return Math.max(maxDepth(root.left, depth + 1),maxDepth(root.right, depth + 1))\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为二叉树中节点的个数\n- 空间复杂度 $(K)$, k为二叉树的深度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185628129","body":"### 思路\n新建一个数组，长度为num和k的长度的最大值，从num和k的末尾开始相加，得到的值赋值到新数组中，注意进位。\n\n### 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n  let size = Math.max(num.length, (k + '').length);\n  let res = new Array(size);\n  let j = num.length - 1;\n  for (let i = res.length - 1; i >= 0; i--) {\n    let sum = k % 10;\n    if (j >= 0) sum += num[j];\n    if (res[i]) sum += res[i];\n    if (i === 0) {\n      res[i] = sum;\n    } else {\n      res[i] = sum % 10;\n      res[i - 1] = Math.floor(sum / 10);\n    }\n    k = Math.floor(k / 10);\n    j--;\n  }\n  if (res[0] >= 10) {\n    let s = res[0];\n    res[0] = s % 10;\n    res.unshift(Math.floor(s /10));\n  }\n  return res;\n};\n```\n\n### 复杂度\n* time: O(n)\n* space: O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186381448","body":"```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.arr = [];\n  this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.arr.length < this.maxSize) this.arr.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.arr.length === 0) return -1;\n  else return this.arr.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (i >= this.arr.length) break;\n    this.arr[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n/**\n * 栈\n * time: O(n)\n * space: O(n)\n*/\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189059597","body":"```javascript\n\nvar MyQueue = function() {\n  this.stack1 = [];\n  this.stack2 = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  while (this.stack1.length > 0) {\n    this.stack2.push(this.stack1.pop());\n  }\n  let res = this.stack2.pop();\n  while (this.stack2.length > 0) {\n    this.stack1.push(this.stack2.pop());\n  }\n  return res;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  return this.stack1[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.stack1.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n/**\n * 栈\n * time: O(n)\n * space: O(n)\n * 定义两个栈，pop的时候，将stack1的数据全部pop到stack2，返回stack2栈顶的值，再将stack2全部pop回stack1\n */\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192290832","body":"```javascript\n/**\n * @param {ListNode} head\n * @return {ListNode}\n * time: O(n)\n * space: O(1)\n * 定义一个pre节点和next节点，位置分别在要交换的两个节点的前后\n * 遍历交换节点\n */\nvar swapPairs = function(head) {\n  if (head === null || head.next === null) return head;\n  let res = new ListNode(0);\n  let p1 = head;\n  let p2 = head.next;\n  let pre = res;\n  pre.next = head;\n  while (p1 && p2) {\n    let next = p2.next;\n    p1.next = next;\n    p2.next = p1;\n    pre.next = p2;\n    pre = p1;\n    p1 = next;\n    p2 = p1 === null ? null : p1.next;\n  }\n  return res.next;\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195037913","body":"```javascript\nfunction ListNode(val, key) {\n  this.val = val;\n  this.key = key;\n  this.next = null;\n  this.pre = null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n  this.head = new ListNode(0);\n  this.tail = new ListNode(0);\n  this.head.next = this.tail;\n  this.tail.pre = this.head;\n  this.map = new Map();\n  this.size = capacity;\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n  if (this.map.has(key)) {\n    let node = this.map.get(key);\n    this.moveNodeInHead(node);\n    return node.val;\n  }\n  return -1;\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n  if (this.map.has(key)) {\n    let node = this.map.get(key);\n    node.val = value;\n    this.moveNodeInHead(node);\n  } else {\n    let node = new ListNode(value, key);\n    this.map.set(key, node);\n    let next = this.head.next;\n    this.head.next = node;\n    node.pre = this.head;\n    node.next = next;\n    next.pre = node;\n    if (this.map.size > this.size) this.deleteNodeInTail();\n  }\n};\n\nLRUCache.prototype.moveNodeInHead = function(node) {\n  let pre = node.pre;\n  let next = node.next;\n  pre.next = next;\n  next.pre = pre;\n  let hnext = this.head.next;\n  this.head.next = node;\n  node.pre = this.head;\n  node.next = hnext;\n  hnext.pre = node;\n};\n\nLRUCache.prototype.deleteNodeInTail = function() {\n  let node = this.tail.pre;\n  this.map.delete(node.key);\n  let p = node.pre;\n  p.next = this.tail;\n  this.tail.pre = p;\n  node.next = null;\n  node.pre = null;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185630005","body":"## 思路\r\n遍历数组，从后向前加；随时更新进位变量;\r\n最后需要注意进位是否为1\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        if(k == 0) {\r\n            return Arrays.stream(num).boxed().collect(Collectors.toList());\r\n        }\r\n        StringBuffer sb = new StringBuffer();\r\n        List<Integer> res = new ArrayList<>();\r\n        int n = num.length;\r\n        int carry = 0;\r\n        int ans = 0;\r\n        int i = n - 1;\r\n        while(i >= 0 || k != 0) {\r\n            int x = i >= 0 ? num[i] : 0;\r\n            int y =  k != 0 ? k % 10 : 0;\r\n            int sum = x + y + carry;\r\n            carry = sum / 10;\r\n            ans = sum % 10;\r\n            i--;\r\n            res.add(0, ans);\r\n            k /= 10;\r\n        }\r\n        \r\n        if(carry != 0) {\r\n            res.add(0, carry);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186207847","body":"## 思路\r\n0，双指针：i 进行字符串遍历，j 进行目标字符位置的固定；\r\n1，从左向右遍历，记录每个字符与其左边的目标字符的距离；\r\n2，再从右向左遍历，记录每个字符与其右边出现的目标字符的距离，与结果数组中的取小值；\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        if(s == null || s.length() == 0) {\r\n            return new int[0];\r\n        }\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        Arrays.fill(res, n + 1);\r\n        // j 记录左侧第一个 c 的坐标\r\n        for(int i = 0, j = -1; i < n; i++) {\r\n            if(s.charAt(i) == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                res[i] = i - j;\r\n            }\r\n        }\r\n        // 从右向左遍历，j 为第一个 c 的坐标\r\n        for(int i = n - 1, j = -1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                res[i] = Math.min(res[i], j - i);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186679035","body":"## 思路\r\n数组模拟栈，用变量记录栈顶的位置\r\n···\r\nclass CustomStack {\r\n    int[] st;\r\n    int top = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        st = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top == st.length - 1) {\r\n            return;\r\n        }\r\n        top++;\r\n        st[top] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == -1) {\r\n            return -1;\r\n        }\r\n        return st[top--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int cnt = k > st.length ? st.length : k;\r\n        for(int i = 0; i < cnt; i++) {\r\n            st[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n···","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187006693","body":"## 思路\r\n1，以一对中括号来解析字符串，用数组来维护一个栈，除右括号其他都进栈；遇到右括号则出栈；\r\n2，进栈需要将数字字符处理妥当，处理成字符；两位及以上的数字容易出错；\r\n```\r\nclass Solution {\r\n    int idx;\r\n    public String decodeString(String s) {\r\n        if(s == null || s.length() == 0) {\r\n            return \"\";\r\n        }\r\n        LinkedList<String> st = new LinkedList<>();\r\n        int n = s.length();\r\n        while(idx < n) {\r\n            if(Character.isDigit(s.charAt(idx))) {\r\n                st.add(getDigit(s));\r\n            }\r\n            else if(s.charAt(idx) != ']') {\r\n                st.add(String.valueOf(s.charAt(idx++)));\r\n            }\r\n            else {\r\n                LinkedList<String> path = new LinkedList<>();\r\n                while(!\"[\".equals(st.peekLast())) {\r\n                    path.add(st.pollLast());\r\n                }\r\n                Collections.reverse(path);\r\n                String sub = getString(path);\r\n                st.pollLast();\r\n                int cnt = Integer.valueOf(st.pollLast());\r\n                String str = getSubString(cnt, sub);\r\n                st.add(str);\r\n                idx++;\r\n            }\r\n        }\r\n        return getString(st);\r\n    }\r\n\r\n    private String getDigit(String s) {\r\n        StringBuffer sb = new StringBuffer();\r\n        while(Character.isDigit(s.charAt(idx))) {\r\n            sb.append(s.charAt(idx++));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    private String getString(LinkedList<String> path) {\r\n        StringBuffer sb = new StringBuffer();\r\n        for(String s : path) {\r\n            sb.append(s);\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    private String getSubString(int cnt, String sub) {\r\n        StringBuffer sb = new StringBuffer();\r\n        while(cnt-- > 0) {\r\n            sb.append(sub);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n## 复杂度\r\nT：O(n)，遍历字符串\r\nS：O(n)，数组模拟栈\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188799537","body":"## 思路\r\n两个栈实现队列，一个进一个出\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(s1.isEmpty() && s2.isEmpty()) {\r\n            return -1;\r\n        }\r\n        if(s2.isEmpty()) {\r\n            while(!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(s1.isEmpty() && s2.isEmpty()) {\r\n            return -1;\r\n        }\r\n        if(s2.isEmpty()) {\r\n            while(!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n## 复杂度\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189784256","body":"## 思路\r\n维护一个栈，遍历数组，并与栈顶元素比较，\r\n1，当前数小于栈顶，栈顶出栈；\r\n2，当前数大于等于栈顶，直接入栈\r\n\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        if(arr == null || arr.length == 0) {\r\n            return 0;\r\n        }\r\n        LinkedList<Integer> st = new LinkedList<>();\r\n        int head = 0;\r\n        for(int x : arr) {\r\n            if(!st.isEmpty() && x < st.getLast()) {\r\n                head = st.pollLast();\r\n                while(!st.isEmpty() && x < st.getLast()) {\r\n                    st.pollLast();\r\n                }\r\n                st.add(head);\r\n            }\r\n            else {\r\n                st.add(x);\r\n            }\r\n        }\r\n        return st.size();\r\n    }\r\n}\r\n```\r\n##  复杂度\r\nT:O(N)\r\nS:O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192618402","body":"```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        ListNode next = head.next;\r\n        head.next = swapPairs(next.next);\r\n        next.next = head;\r\n        return next;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193341285","body":"## 思路\r\n两个指针指向两个链表，循环指向，直到两个指针指向同一个节点\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode p, ListNode q) {\r\n        if(p == null || q == null) {\r\n            return null;\r\n        }\r\n        ListNode l = p;\r\n        ListNode r = q;\r\n        while(l != r) {\r\n            if(l != null) {\r\n                l = l.next;\r\n            }\r\n            else {\r\n                l = q;\r\n            }\r\n            if(r != null) {\r\n                r = r.next;\r\n            }\r\n            else {\r\n                r = p;\r\n            }\r\n        }\r\n        return l;\r\n    }\r\n}\r\n```\r\n## 复杂度\r\nT: O(M+N)\r\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194166187","body":"## 思路\r\n快慢指针判断是否有环；再双指针求入口\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null) {\r\n            return null;\r\n        }\r\n        ListNode f = head;\r\n        ListNode s = head;\r\n        while(true) {\r\n            if(f == null || f.next == null) {\r\n                return null;\r\n            }\r\n            f = f.next.next;\r\n            s = s.next;\r\n            if(f == s) {\r\n                break;\r\n            }\r\n        }\r\n        f = head;\r\n        while(f != s) {\r\n            f = f.next;\r\n            s = s.next;\r\n        }\r\n        return f;\r\n    }\r\n}\r\n```\r\n## 复杂度\r\nT: O(N)\r\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195649294","body":"```\r\nclass LRUCache {\r\n    int cap;\r\n    LinkedHashMap<Integer, Integer> map = new LinkedHashMap<>();\r\n    public LRUCache(int capacity) { \r\n        this.cap = capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (!map.containsKey(key)) {\r\n            return -1;\r\n        }\r\n        getKey(key);\r\n        return map.get(key);\r\n    }\r\n    \r\n    public void put(int key, int val) {\r\n        if (map.containsKey(key)) {\r\n            map.put(key, val);\r\n            getKey(key);\r\n            return;\r\n        }\r\n        \r\n        if (map.size() >= this.cap) {\r\n            int oldkey = map.keySet().iterator().next();\r\n            map.remove(oldkey);\r\n        }\r\n        map.put(key, val);\r\n    }\r\n    \r\n    private void getKey(int key) {\r\n        int val = map.get(key);\r\n        map.remove(key);\r\n        map.put(key, val);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196870830","body":"## 思路\r\n无脑递归，可能是因为写了好多次，所以，反正，就是这样的\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) {\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185631706","body":"## 思路\r\n把 `k` 的每一位转换成一个 vector，然后进行两个 vector 相加即可。\r\n## 代码\r\n````cpp\r\nclass Solution {\r\nprivate:\r\n    vector<int> addTwo(vector<int> &num1, vector<int> &num2) {\r\n        // [1, 2, 0, 0] + [3, 4]\r\n        int size1 = num1.size() - 1, size2 = num2.size() - 1;\r\n        vector<int> ans;\r\n        int carry = 0;\r\n        while (size1 >= 0 || size2 >= 0) {\r\n            int x1 = size1 >= 0 ? num1[size1] : 0;\r\n            int x2 = size2 >= 0 ? num2[size2] : 0;\r\n            int sum = x1 + x2 + carry;\r\n            carry = sum / 10;\r\n            sum %= 10;\r\n            ans.emplace_back(sum);\r\n            --size1;\r\n            --size2;\r\n        }\r\n        if (carry) {\r\n            ans.emplace_back(carry);\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> num1;\r\n        while (k) {\r\n            num1.emplace_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(num1.begin(), num1.end());\r\n        return addTwo(num, num1);\r\n    }\r\n};\r\n````\r\n## 时空复杂度\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185717663","body":"## 思路\n暴力法，直接记录所有结果的给定字符的位置，遍历一遍字符串，取距离最小的值\n## 代码\n````cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        vector<int> tmp;\n        int size = s.size();\n        for (int i = 0; i < size; ++i) {\n            if (s[i] == c) {\n                tmp.emplace_back(i);\n            }\n        }\n        int cnt = 0;\n        for (int i = 0; i < size; ++i) {\n            int minn = INT_MAX;\n            for (int j = 0; j < (int)tmp.size(); ++j) {\n                minn = min(minn, abs(tmp[j] - i));\n            }\n            ans.emplace_back(minn);\n        }\n        return ans;\n    }\n};\n````\n## 时空复杂度\n时间复杂度：$O(n \\times k)$ <br />\n空间复杂度：$O(k)$ <br />\nk为字符的个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186235143","body":"## 思路\r\n利用数组模拟栈的 `push`, `pop` 操作，最后的 `increment` 直接把数组前 `k` 个加上 `val` 即可。\r\n## 代码\r\nC++\r\n````cpp\r\nclass CustomStack {\r\nprivate:\r\n    vector<int> vec;\r\n    int cnt;\r\n    int maxSize;\r\npublic:\r\n    CustomStack(int _maxSize) {\r\n        cnt = 0;\r\n        maxSize = _maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (cnt < maxSize) {\r\n            vec.emplace_back(x);\r\n            ++cnt;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (cnt == 0) {\r\n            return -1;\r\n        }\r\n        int ret = vec[cnt - 1];\r\n        vec.pop_back();\r\n        --cnt;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if (cnt < k) {\r\n            k = cnt;\r\n        }\r\n        for (int i = 0; i < k; ++i) {\r\n            vec[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n````\r\nPython\r\n````python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.cnt = 0\r\n        self.vec = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.maxSize:\r\n            self.vec.append(x)\r\n            self.cnt += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0:\r\n            return -1\r\n        self.cnt -= 1\r\n        return self.vec.pop(-1)\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > self.cnt:\r\n            k = self.cnt\r\n        for i in range(k):\r\n            self.vec[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n````\r\n## 时空复杂度\r\n时间复杂度：$O(k)$\r\n空间复杂度：$O(maxSize)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187585157","body":"## 思路\r\n利用两个栈，一个存储数字的栈，一个存储字符串的栈。\r\n如果是 `[`，把数字存入数织栈，把遇到 `]` 之前的字符串存到字符串栈里面，如果遇到 `]`，则按照题目要求解码字符串。\r\n## 代码\r\nC++\r\n````cpp\r\nclass Solution {\r\n  public:\r\n    string decodeString(string s) {\r\n        int size = s.size();\r\n        int num = 0;\r\n        stack<int> num_stack;\r\n        stack<string> str_stack;\r\n        string cur = \"\";\r\n        string result = \"\";\r\n        for (int i = 0; i < size; ++i) {\r\n            if (isdigit(s[i])) {\r\n                num = 10 * num + (s[i] - '0');\r\n            } else if (s[i] == '[') {\r\n                num_stack.push(num);\r\n                str_stack.push(cur);\r\n                num = 0;\r\n                cur.clear();\r\n            } else if (isalpha(s[i])) {\r\n                cur += s[i];\r\n            } else if (s[i] == ']') {\r\n                int k = num_stack.top();\r\n                num_stack.pop();\r\n                for (int j = 0; j < k; ++j) {\r\n                    str_stack.top() += cur;\r\n                }\r\n                cur = str_stack.top();\r\n                str_stack.pop();\r\n            }\r\n        }\r\n        result = result + cur;\r\n        return result;\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        size = len(s)\r\n        num = 0\r\n        num_stack = list()\r\n        str_stack = list()\r\n        cur = str()\r\n        result = str()\r\n        for i in range(size):\r\n            if s[i].isdigit():\r\n                num = num * 10 + int(s[i])\r\n            elif s[i] == '[':\r\n                num_stack.append(num)\r\n                str_stack.append(cur)\r\n                num = 0\r\n                cur = \"\"\r\n            elif s[i].isalpha():\r\n                cur += s[i]\r\n            elif s[i] == ']':\r\n                k = num_stack.pop(-1)\r\n                for j in range(k):\r\n                    str_stack[-1] += cur\r\n                cur = str_stack.pop(-1)\r\n        result = result + cur\r\n        return result\r\n````\r\n## 时空复杂度\r\n记字符串的长度为 $N$, 由于 `s` 中所有的整数取值范围都是 `[1, 300]`, 故拼接字符串的时间复杂度可以忽略。\r\n时间复杂度：$O(N)$\r\n空间复杂度：$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189097171","body":"## 思路\r\n只要理解了栈和队列的基本思想，就可以写出此题了。\r\n## 代码\r\nC++\r\n````cpp\r\nclass MyQueue {\r\n  private:\r\n    stack<int> st1, st2;\r\n\r\n  public:\r\n    MyQueue() {}\r\n\r\n    void push(int x) { st1.push(x); }\r\n\r\n    int pop() {\r\n        int ret = 0;\r\n        if (!st2.empty()) {\r\n            ret = st2.top();\r\n            st2.pop();\r\n            return ret;\r\n        }\r\n        while (!st1.empty()) {\r\n            st2.push(st1.top());\r\n            st1.pop();\r\n        }\r\n        ret = st2.top();\r\n        st2.pop();\r\n        return ret;\r\n    }\r\n\r\n    int peek() {\r\n        int ret = 0;\r\n        if (!st2.empty()) {\r\n            ret = st2.top();\r\n            return ret;\r\n        }\r\n        while (!st1.empty()) {\r\n            st2.push(st1.top());\r\n            st1.pop();\r\n        }\r\n        ret = st2.top();\r\n        return ret;\r\n    }\r\n\r\n    bool empty() {\r\n        return st1.empty() && st2.empty();\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\nclass MyQueue:\r\n    \r\n    def __init__(self):\r\n        self.st1 = []\r\n        self.st2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.st1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.st2):\r\n            return self.st2.pop(-1)\r\n        while len(self.st1):\r\n            self.st2.append(self.st1.pop(-1))\r\n        return self.st2.pop(-1)\r\n\r\n\r\n    def peek(self) -> int:\r\n        if len(self.st2):\r\n            return self.st2[-1]\r\n        while len(self.st1):\r\n            self.st2.append(self.st1.pop(-1))\r\n        return self.st2[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not (len(self.st1) or len(self.st2))\r\n````\r\n## 时空复杂度\r\n时间复杂度：$O(1)$\r\n空间复杂度：$O(N)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191469274","body":"## 思路\r\n先获取链表的长度，因为当 k 大于链表长度的时候，其实并不需要移动 k 次，只需要移动 $k \\% n$ 就好了。然后设定两个指针 fast, slow，\r\nfast 指针先移动 k 步，然后跟 slow 指针一起移动，这样当 fast 指针移动到最后一个元素时，slow 指针就是处在倒数第 k 个元素的前一个元素位置，然后重现链接一下链表即可。\r\n## 代码\r\nC++\r\n````cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (!head) {\r\n            return head;\r\n        }\r\n        int n = 0;\r\n        ListNode *tmp = head;\r\n        while (tmp) {\r\n            ++n;\r\n            tmp = tmp->next;\r\n        }\r\n        k %= n;\r\n        if (k == 0) {\r\n            return head;\r\n        }\r\n        ListNode *fast = head, *slow = head;\r\n        for (int i = 0; i < k; ++i) {\r\n            fast = fast->next;\r\n        }\r\n        while (fast->next) {\r\n            fast = fast->next;\r\n            slow = slow->next;\r\n        }\r\n        ListNode *ans = slow->next;\r\n        slow->next = nullptr;\r\n        fast->next = head;\r\n        return ans;\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        tmp = head\r\n        n = 0\r\n        while tmp:\r\n            n += 1\r\n            tmp = tmp.next\r\n        k %= n\r\n        if k == 0:\r\n            return head\r\n        fast, slow = head, head\r\n        for i in range(k):\r\n            fast = fast.next\r\n        while fast.next:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        ans = slow.next\r\n        slow.next = None\r\n        fast.next = head\r\n        return ans\r\n````\r\n## 时空复杂度\r\n时间复杂度：$O(N)$\r\n空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192655135","body":"## 思路\r\n每次交换链表的两个值即可。\r\n## 代码\r\nC++\r\n````cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode *ans = new ListNode(-1);\r\n        ListNode *p = ans;\r\n        p->next = head;\r\n        while (head && head->next) {\r\n            ListNode *q = head->next;\r\n\r\n            ListNode *tmp = q->next;\r\n            q->next = head;\r\n            head->next = tmp;\r\n\r\n            p->next = q;\r\n            head = head->next;\r\n            p = q->next;\r\n        }\r\n        return ans->next;\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        ans = ListNode(-1)\r\n        p = ans\r\n        ans.next = head\r\n        while head and head.next:\r\n            q = head.next\r\n\r\n            tmp = q.next\r\n            q.next = head\r\n            head.next = tmp\r\n\r\n            p.next = q\r\n            head = head.next\r\n            p = q.next\r\n        return ans.next\r\n````\r\n## 时空复杂度\r\n时间复杂度：$O(N)$\r\n空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193109905","body":"## 思路\r\n找到链表的中间节点，这样中间节点的左边就是左子树，右边就是右子树，同时按照相同的方法递归左子树和右子树，这样即可构成一颗二叉树。\r\n## 代码\r\nC++\r\n````cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\nprivate:\r\n    ListNode *get_mid(ListNode *left, ListNode *right) {\r\n        ListNode *fast = left, *slow = left;\r\n        while (fast != right && fast->next != right) {\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n    TreeNode *build_tree(ListNode *left, ListNode *right) {\r\n        if (left == right) {\r\n            return nullptr;\r\n        }\r\n        ListNode *mid = get_mid(left, right);\r\n        TreeNode *ans = new TreeNode(mid->val);\r\n        ans->left = build_tree(left, mid);\r\n        ans->right = build_tree(mid->next, right);\r\n        return ans;\r\n    }\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        return build_tree(head, nullptr);\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        def get_mid(left, right):\r\n            fast, slow = left, left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        def build_tree(left, right):\r\n            if (left == right):\r\n                return None\r\n            mid = get_mid(left, right)\r\n            ans = TreeNode(mid.val)\r\n            ans.left = build_tree(left, mid)\r\n            ans.right = build_tree(mid.next, right)\r\n            return ans\r\n        return build_tree(head, None)\r\n````\r\n## 时空复杂度\r\n每次找链表中间节点的时间复杂度是 $O(N)$，根据主定理可知，总的时间复杂度：$O(NlogN)$\r\n空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193254191","body":"## 思路\r\n错的人迟早会走散，而对的人迟早会相逢。\r\n## 代码\r\nC++\r\n````cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode *tmpA = headA, *tmpB = headB;\r\n        while (tmpA != tmpB) {\r\n            tmpA = tmpA == nullptr ? headB : tmpA->next;\r\n            tmpB = tmpB == nullptr ? headA : tmpB->next;\r\n        }\r\n        return tmpA;\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        tmpA, tmpB = headA, headB\r\n        while tmpA != tmpB:\r\n            tmpA = tmpA.next if tmpA else headB\r\n            tmpB = tmpB.next if tmpB else headA\r\n        return tmpA\r\n        \r\n````\r\n## 时空复杂度\r\n时间复杂度：$O(N + M)$，N 和 M分别为两个链表的长度\r\n空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194100786","body":"## 思路\r\n\r\npass\r\n\r\n## 代码\r\n\r\nC++\r\n\r\n````cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *fast = head, *slow = head;\r\n        bool flag = false;\r\n        while (fast && fast->next) {\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n            if (fast == slow) {\r\n                flag = true;\r\n                break;\r\n            }\r\n        }\r\n        if (flag) {\r\n            fast = head;\r\n            while (fast != slow) {\r\n                fast = fast->next;\r\n                slow = slow->next;\r\n            }\r\n            return slow;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n````\r\n\r\nPython\r\n\r\n````python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast, slow = head, head\r\n        flag = False\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                flag = True\r\n                break\r\n        if flag:  \r\n            fast = head\r\n            while fast != slow:\r\n                fast = fast.next\r\n                slow = slow.next\r\n            return fast\r\n        return None\r\n````\r\n\r\n## 时空复杂度\r\n\r\n时间复杂度：$O(N)$\r\n空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195528460","body":"## 思路\r\n\r\npass\r\n\r\n## 代码\r\n\r\nC++\r\n\r\n````cpp\r\nstruct DLinkedNode {\r\n    int key, value;\r\n    DLinkedNode *prev;\r\n    DLinkedNode *next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode*> cache;\r\n    DLinkedNode *head;\r\n    DLinkedNode *tail;\r\n    int size;\r\n    int capacity;\r\npublic:\r\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!cache.count(key)) {\r\n            return -1;\r\n        }\r\n        DLinkedNode *node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)) {\r\n            DLinkedNode *node = new DLinkedNode(key, value);\r\n            cache[key] = node;\r\n            addToHead(node);\r\n            ++size;\r\n            if (size > capacity) {\r\n                DLinkedNode *removed = removeTail();\r\n                cache.erase(removed->key);\r\n                delete removed;\r\n                --size;\r\n            }\r\n        } else {\r\n            DLinkedNode *node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    void addToHead(DLinkedNode *node) {\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n\r\n    void removeNode(DLinkedNode *node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(DLinkedNode *node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    DLinkedNode *removeTail() {\r\n        DLinkedNode *node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n````\r\n\r\nPython\r\n\r\n````python\r\nclass LRUCache(collections.OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        super().__init__()\r\n        self.capacity = capacity\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self:\r\n            return -1\r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self) > self.capacity:\r\n            self.popitem(last=False)\r\n\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n````\r\n\r\n## 时空复杂度\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196624976","body":"## 思路\r\n\r\n经典题，找到左子树和右子树最高的树就是树的高度。\r\n\r\n## 代码\r\n\r\nC++\r\n\r\n````cpp\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n````\r\n\r\nPython\r\n\r\n````python\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (!root) {\r\n            return 0;\r\n        }\r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n````\r\n\r\n## 时空复杂度\r\n\r\n时间复杂度：$O(n)$\r\n\r\n空间复杂度：$O(height)$\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185633040","body":"## 进位处理\n从低位往高位相加，并处理进位，可以用k同时存储进位信息，每次迭代有 k = (num[i] + k) / 10\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            res.add(0, (num[i] + k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k != 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n```\n\n```go\nfunc addToArrayForm(num []int, k int) []int {\n    res := make([]int, 0)\n    for i := len(num) - 1; i >= 0; i-- {\n        res = append(res, (num[i] + k) % 10)\n        k = (num[i] + k) / 10\n    }\n    for k != 0 {\n        res = append(res, k % 10)\n        k /= 10\n    }\n    for i, j := 0, len(res) - 1; i < j; i, j = i + 1, j - 1 {\n        res[i], res[j] = res[j], res[i]\n    }\n    return res\n}\n```\n- time: O(max(len(num), digit(k))，时间复杂度是和的长度n，是num和k最大的那个（可能会是max(len(num), digit(k)) + C，不过大O表示法忽略常数项C，可以不做讨论）\n- space: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185703099","body":"## 遍历\n左右遍历数组\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = Math.min(res[i], pre - i);\n        }\n        return res;\n    }\n}\n```\n```go\nfunc shortestToChar(s string, c byte) []int {\n    const (\n        INT_MAX = int(^uint(0) >> 1)\n        INT_MIN = ^INT_MAX\n    )\n    res := make([]int, 0)\n    pre := INT_MIN / 2\n    for i := 0; i < len(s); i++ {\n        if s[i] == c {\n            pre = i\n        }\n        res = append(res, i - pre)\n    }\n    pre = INT_MAX\n    for i := len(s) - 1; i >= 0; i-- {\n        if s[i] == c {\n            pre = i\n        }\n        tmp := pre - i\n        if tmp < res[i] {\n            res[i] = tmp\n        }  \n    }\n    return res\n}\n```\n- time: O(n)\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186483335","body":"## 栈\n数组实现栈\n```java\nclass CustomStack {\n    int[] stack;\n    int top = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (top < stack.length) {\n            stack[top++] = x;\n        }\n    }\n    \n    public int pop() {\n        return top != 0 ? stack[--top] : -1;\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < top; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n```go\ntype CustomStack struct {\n    stack []int\n    top int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{\n        stack: make([]int, maxSize, maxSize),\n    }\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if this.top >= len(this.stack) {\n        return\n    }\n    this.stack[this.top] = x\n    this.top++\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if this.top == 0 {\n        return -1\n    }\n    this.top--\n    return this.stack[this.top]\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    for i := 0; i < k && i < this.top; i++ {\n        this.stack[i] += val\n    }\n}\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n```\n- time: push, pop = O(1), increment = O(min(k, top))\n- space: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187662435","body":"## 栈\n辅助栈，解码顺序是由内向外，越里面的括号越先解码，符合栈先入后出原则\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<String> resStack = new LinkedList<>();\n        Deque<Integer> multiStack = new LinkedList<>();\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '[') {\n                multiStack.push(multi);\n                multi = 0;\n                resStack.push(res.toString());\n                res = new StringBuilder();\n            } else if (ch == ']') {\n                StringBuilder tmp = new StringBuilder();\n                tmp.append(resStack.pop());\n                int repeat = multiStack.pop();\n                for (int i = 0; i < repeat; i++) {\n                    tmp.append(res);\n                }\n                res = tmp;\n            } else if (Character.isDigit(ch)) {\n                multi = multi * 10 + ch - '0';\n            } else {\n                res.append(ch);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n- time: O(n)，n为字符串长度\n- space: 栈空间，O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189189933","body":"## 栈\n双栈实现队列\n```java\nclass MyQueue {\n    Deque<Integer> pushStack = new LinkedList<>();\n    Deque<Integer> popStack = new LinkedList<>();\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n- time: O(n)\n- space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190341873","body":"## 计数\n遍历数组，若和有序数组expect计数相同，则说明此时可分块，res++\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap<>();\n        int res = 0;\n        int nonzero = 0;\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n        for (int i = 0; i < arr.length; i++) {\n            int x = arr[i], y = expect[i];\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) {\n                nonzero--;\n            }\n            if (count.get(x) == 1) {\n                nonzero++;\n            }\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == 0) {\n                nonzero--;\n            }\n            if (count.get(y) == -1) {\n                nonzero++;\n            }\n            if (nonzero == 0) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n- time: O(nlogn)，排序\n- space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191624390","body":"## 链表操作\n先遍历链表，得到链表尾tail和链表长度len，若k % len == 0说明移动的长度为链表长度的倍数，即不移动直接返回head，否则尾节点连接头节点，新尾节点离旧头节点len - k % len - 1，找到新尾节点newTail，则新头节点newHead = newTail.next，并断开尾节点后的连接newTail.next = null，返回新头节点\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        int len = 1;\n        ListNode tail = head;\n        while (tail.next != null) {\n            tail = tail.next;\n            len++;\n        }\n        k %= len;\n        if (k == 0) {\n            return head;\n        }\n        tail.next = head;\n        ListNode newTail = head;\n        for (int i = 0; i < k; i++) {\n            newTail = newTail.next;\n        }\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n        return newHead;\n    }\n}\n```\n## 双指针\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc rotateRight(head *ListNode, k int) *ListNode {\n    if head == nil {\n        return nil\n    }\n    tail := head\n    len := 1\n    for tail.Next != nil {\n        tail = tail.Next\n        len++\n    }\n    k %= len\n    if k == 0 {\n        return head\n    }\n    next := head\n    for k != 0 {\n        next = next.Next\n        k--\n    }\n    pre := head\n    for next.Next != nil {\n        pre = pre.Next\n        next = next.Next\n    }\n    newHead := pre.Next\n    pre.Next = nil\n    next.Next = head\n    return newHead\n}\n```\n- time: O(n)\n- space: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193144320","body":"## 二分 or 快慢指针\n递归找中点作为根节点创建二叉树，有两种方式：\n1. 数组二分，空间换时间\n2. 每次递归都使用快慢指针找中点\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        List<Integer> list = new ArrayList<>();\n        while (head != null) {\n            list.add(head.val);\n            head = head.next;\n        }\n        return buildTree(0, list.size() - 1, list);\n    }   \n\n    TreeNode buildTree(int left, int right, List<Integer> list) {\n        if (left > right) {\n            return null;\n        }\n        int mid = left + (right - left + 1) / 2;\n        TreeNode root = new TreeNode(list.get(mid));\n        root.left = buildTree(left, mid - 1, list);\n        root.right = buildTree(mid + 1, right, list);\n        return root;\n    }\n}\n```\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sortedListToBST(head *ListNode) *TreeNode {\n    list := make([]int, 0)\n    for head != nil {\n        list = append(list, head.Val)\n        head = head.Next\n    }\n    return buildTree(0, len(list) - 1, list)\n}\n\nfunc buildTree(left int, right int, list []int) *TreeNode {\n    if left > right {\n        return nil\n    }\n    mid := left + (right - left) / 2\n    root := &TreeNode{Val: list[mid]}\n    root.Left = buildTree(left, mid - 1, list)\n    root.Right = buildTree(mid + 1, right, list)\n    return root\n}\n```\n## 快慢指针\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sortedListToBST(head *ListNode) *TreeNode {\n    return buildTree(head, nil)\n}\n\nfunc buildTree(left, right *ListNode) *TreeNode {\n    if left == right {\n        return nil\n    }\n    mid := getMid(left, right)\n    root := &TreeNode{Val: mid.Val}\n    root.Left = buildTree(left, mid)\n    root.Right = buildTree(mid.Next, right)\n    return root\n}\n\nfunc getMid(left, right *ListNode) *ListNode {\n    slow, fast := left, left; \n    for fast != right && fast.Next != right {\n        slow = slow.Next;\n        fast = fast.Next.Next\n    }\n    return slow\n}\n```\n- 时间：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193248180","body":"## 双指针\n令pA = headA，pB = headB，遍历直至为null时pA = headB，pB = headA，若相交两个指针将会在交点会合（走过的路程相同），否则遍历至链表尾返回null\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n```go/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    if headA == nil || headB == nil {\n        return nil\n    }\n    pA, pB := headA, headB\n    for pA != pB {\n        if pA == nil {\n            pA = headB\n        } else {\n            pA = pA.Next\n        }\n        if pB == nil {\n            pB = headA\n        } else {\n            pB = pB.Next\n        }\n    }\n    return pA\n}\n```\n- time: O(n)\n- space: O(1)\n## 哈希表\n遍历一个节点并将所有遇到的节点存进哈希表中，遍历另一个节点每次判断是否存在哈希表中，是则为交叉点，时空复杂度皆为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194142611","body":"## 快慢指针\n- slow走一步，fast走两步，若存在环则一定会相交，设交点由如下图b和c相交形成\n- fast指针走过的长度为 a + b + n(b + c) = a + (n + 1) b + nc\n- slow指针走过的长度为 a + b\n- fast指针走过的长度是slow的两倍\n- a + (n + 1)b + nc  = 2(a + b)\n- a = c  + (n - 1)(b + c)\n- 所以若p指向head，slow指向b和c的交点，同时移动指针则当p走了a距离即走到环入口点时，slow也走过c  + (n - 1)(b + c)即饶了(n - 1)圈后走了c距离也到达换入口点\n\n![](https://assets.leetcode-cn.com/solution-static/142/142_fig1.png)\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                ListNode p = head;\n                while (p != slow) {\n                    p = p.next;\n                    slow = slow.next;\n                }\n                return p;\n            }\n        }\n        return null;\n    }\n}\n```\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    slow, fast := head, head\n    for fast != nil && fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            p := head\n            for p != slow {\n                p = p.Next\n                slow = slow.Next\n            }\n            return p\n        }\n    }\n    return nil\n}\n```\n- time: O(n)，slow走过的长度不超过链表总长度\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195558833","body":"## 双向链表 + 哈希表\nget和put的平均复杂度为O(1)不难联想到哈希表，而实现LRU还需要维护一个双向链表，我们秩序每次添加或修改链表时将元素放在表头，当大于元素数量大于容量时将表尾元素移除\n```java\nclass LRUCache {\n    class DListNode {\n        int key, value;\n        DListNode pre;\n        DListNode next;\n\n        DListNode() {}\n\n        DListNode(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    int size, capacity;\n    Map<Integer, DListNode> cache = new HashMap<>();\n    DListNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        size = 0;\n        head = new DListNode();\n        tail = new DListNode();\n        head.next = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        DListNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        DListNode node = cache.get(key);\n        if (node == null) {\n            node = new DListNode(key, value);\n            cache.put(key, node);\n            addToHead(node);\n            size++;\n            if (size > capacity) {\n                DListNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                removeNode(removedTail);\n                size--;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DListNode node) {\n       node.pre = head;\n       node.next = head.next;\n       head.next.pre = node;\n       head.next = node;\n    }\n\n    DListNode removeTail() {\n        DListNode removedTail = tail.pre;\n        removeNode(removedTail);\n        return removedTail;\n    }\n\n    void moveToHead(DListNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    void removeNode(DListNode node) {\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n    }\n}\n```\n```go\ntype LRUCache struct {\n    head, tail *ListNode1\n    cap, size int\n    nodeMap map[int]*ListNode1\n}\n\ntype ListNode1 struct {\n    key, val int\n    pre, next *ListNode1\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n    head, tail := &ListNode1{}, &ListNode1{}\n    head.next = tail\n    tail.pre = head\n    return LRUCache{\n        head: head,\n        tail: tail,\n        cap: capacity,\n        nodeMap: make(map[int]*ListNode1),\n    }\n}\n\nfunc (this *LRUCache) Get(key int) int {\n    if node, ok := this.nodeMap[key]; ok {\n        this.moveToHead(node)        \n        return node.val\n    }\n    return -1\n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n    if node, ok := this.nodeMap[key]; ok{\n        node.val = value\n        this.moveToHead(node)\n        return\n    }\n    node := &ListNode1{key: key, val: value}\n    this.nodeMap[key] = node\n    this.addToHead(node)\n    if this.size == this.cap {\n        removedTail := this.removeTail()\n        delete(this.nodeMap, removedTail.key)\n    } else {\n        this.size++\n    }\n}\n\nfunc (this *LRUCache) removeNode(node *ListNode1) {\n    node.pre.next = node.next\n    node.next.pre = node.pre\n}\n\nfunc (this *LRUCache) moveToHead(node *ListNode1) {\n    this.removeNode(node)\n    this.addToHead(node)\n}\n\nfunc (this *LRUCache) addToHead(node *ListNode1) {\n    node.pre = this.head\n    node.next = this.head.next\n    this.head.next.pre = node\n    this.head.next = node\n}\n\nfunc (this *LRUCache) removeTail() *ListNode1 {\n    removedTail := this.tail.pre\n    this.removeNode(removedTail)\n    return removedTail\n}\n/**\n * Your LRUCache object will be instantiated and called as such:\n * obj := Constructor(capacity);\n * param_1 := obj.Get(key);\n * obj.Put(key,value);\n */\n```\n## LinkedHashMap\nJava API就有此实现LinkedHashMap，我们也可以继承该类然后覆盖removeEldestEntry方法完成题目\n```java\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity; \n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196361067","body":"## 二叉树DFS\n树的最大深度 = max（左子树最大深度，右子树最大深度）+ 1\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n```\n```go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc maxDepth(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    return max(maxDepth(root.Left), maxDepth(root.Right)) + 1\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n- time: O(n)\n- space: O(depth)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185637894","body":"### 思路\n两数相加\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n\n### 代码\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> res = new LinkedList<>();//LinkedList比ArrayList快\n        int i = n - 1, sum = 0, carry = 0, x = 0, y = 0;\n        while (i >= 0 || k != 0) {\n            x = i >= 0 ? num[i] : 0;\n            y = k >= 0 ? k % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            i--;\n            k = k / 10;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186193656","body":"### 思路\ntask：求当前下标字符到指定字符的最近距离\n\naction:\n需要两次遍历 \n\n对 s 的每个下标 i，求 \n\n从最左边开始，找到 s[i] 左侧最近的字符c的下标，并计算 s[i] 到其下标的距离\n\n从最右边开始，找到 s[i] 右侧最近的字符c的下标，并计算 s[i] 到其下标的距离\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n=s.length();\n        int[] answer=new int[n];\n\n        for(int i=0, index=-n;i<n;i++)\n        {\n            if(s.charAt(i)==c) index=i;\n            answer[i]=i-index;\n        }\n\n        for(int i=n-1, index=2*n-1;i>=0;i--)\n        {\n            if(s.charAt(i)==c) index=i;\n            answer[i]=Math.min(answer[i],index-i);\n        }\n        return answer;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186547707","body":"\n### 思路\n\n利用数组模拟栈\n\n### 代码\n\n\n```java\nclass CustomStack {\n\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack=new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top<(stack.length-1))\n        {\n            top=top+1;\n            stack[top]=x;\n        }\n\n    }\n    \n    public int pop() {\n        if(top>-1)\n        {\n            int t=top;\n            top=top-1;\n            return stack[t];\n        }\n        else\n            return -1;\n    }\n    \n    public void increment(int k, int val) {\n    for(int i=0;i<Math.min(k,top+1);i++)\n    {\n        stack[i]+=val;\n    }\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：push:O(1) pop:O(1) increment: O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187603841","body":"### 思路\n\n难点：括号内嵌套括号，使用栈解决问题。\n\n一个字母栈，一个数字栈\n\n### 代码\n\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        String res =new String();\n        StringBuffer ans=new StringBuffer();\n        Stack<Integer> multiStack=new Stack<>();\n        Stack<StringBuffer> ansStack=new Stack<>();\n        int multi=0;\n        for(char c:s.toCharArray()){\n            if(Character.isDigit(c))multi=multi*10+c-'0';\n            else if(c=='['){\n                ansStack.add(ans);\n                multiStack.add(multi);\n                ans=new StringBuffer();\n                multi=0;\n            }else if(Character.isAlphabetic(c)){\n                ans.append(c);\n            }else{\n                StringBuffer ansTmp=ansStack.pop();\n                int tmp=multiStack.pop();\n                for(int i=0;i<tmp;i++)ansTmp.append(ans);\n                ans=ansTmp;\n            }\n        }\n        return ans.toString();\n       \n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189149227","body":"### 思路\n双栈：一个是输入栈，另一个辅助作为输出栈\n\n### 代码\n\n\n```java\nclass MyQueue {\n    Deque<Integer> deque1;\n    Deque<Integer> deque2;\n\n    public MyQueue() {\n        deque1 = new ArrayDeque<>();\n        deque2 = new ArrayDeque<>();\n    }\n\n    public void push(int x) {\n        deque1.push(x);\n    }\n\n    public int pop() {\n        if (deque2.isEmpty())\n            f();\n        return deque2.pop();\n    }\n\n    public int peek() {\n        if (deque2.isEmpty())\n            f();\n        return deque2.peek();\n    }\n\n    public boolean empty() {\n        if (deque1.isEmpty() & deque2.isEmpty())\n            return true;\n        else\n            return false;\n\n    }\n\n    public void f() {\n        while (!deque1.isEmpty())\n            deque2.push(deque1.pop());\n    }\n\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：push()和empty()是O(1)，pop()和peek()是O(n)\n- 空间复杂度：O(n),额外的内存来存储队列中的元素\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190343354","body":"### 思路\n\n\n是否是排序块只需要用到该块的 元素最大值 head 。\n\n### 代码\n\n\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192591445","body":"### 思路\n\n递归\n\n### 代码\n\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194266565","body":"### 思路\n思路一：哈希表\n\n思路二：双指针\n### 代码\n\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode ptr=head;\n        Set<ListNode> l=new HashSet<ListNode>();\n        while(ptr!=null)\n        {\n            if(l.contains(ptr))\n                return ptr;\n            else\n                l.add(ptr);\n            ptr=ptr.next;\n        }\n        return null;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195565577","body":"### 思路\nLinkedHashMap\n\n### 代码\n\n\n```java\nclass LRUCache {\n    private int capacity;\n\n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity;\n    }\n\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196409790","body":"### 思路\n递归\n\n### 代码\n\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n     if(root==null)\n         return 0;\n     return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(depth),最好的情况是logn,最坏的情况是n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185638851","body":"/* 思路 */\n- 两个数相加：从个位数相加(从右向左) 考虑进位 一个一个加入ArrayList入List首位\n\n/* 代码 Java */\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = num.length-1; i >= 0; i--) {\n            int current = k%10 + num[i];\n            k /= 10;\n            \n            if (current >= 10) {\n                k += 1;\n            }\n            \n            result.add(0, current%10);\n        }\n        \n        while (k > 0) {\n            result.add(0, k%10);\n            k /= 10;\n        }\n        \n        return result;\n    }\n}\n\n/* 时间和空间分析\nTime  : O(n) - 一次循环\nSpace : O(n) - 两数相加的位数\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186218643","body":"/* Idea\n- loop 1(left to right): compare the index with the first closet left c\n- loop 2(right to left): compare the index with the first closet right c\n- compare two loop indexs, and take the min value\n*/\n\n/* Code Java */\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < len; ++i) {\n            if (s.charAt(i) == c) prev = i;\n            res[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = len-1; i >= 0; --i) {\n            if (s.charAt(i) == c) prev = i;\n            res[i] = Math.min(res[i], prev - i);\n        }\n\n        return res;\n    }\n}\n\n/* Complexity Analysis\nTime  : O(n) : 2 n loops\nSpace : O(n) : return n int array\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186313748","body":"/* Idea\n-  Use int[] to simulate stack.\n*/\n\n/* Code Java */\nclass CustomStack {\n    private int[] items;\n    // size: count of current items occupied; pointer to next item.\n    private int size = 0;\n\n    public CustomStack(int maxSize) {\n        items = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (size == items.length)\n            return;\n        items[size++] = x;\n    }\n\n    public int pop() {\n        if (size == 0)\n            return -1;\n        return items[--size];\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i < Math.min(k, size); i++) {\n            items[i] += val;\n        }\n    }\n}\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n/* Complexity Analysis\nTime Complexity : O(n)\nspase Complexity: O(maxSize)\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186588234","body":"//没做出来 参考\nclass Solution {\n    public String decodeString(String s) {\n        \n        int lastIndex = s.lastIndexOf('[');\n        if(lastIndex<0) return s;\n        int temp=lastIndex-1;\n        String repeatString=\"\";\n        while(temp>=0){\n            if(Character.isDigit(s.charAt(temp))){\n                temp--;\n            }\n            else break;\n        }\n        \n        int repeatNum=Integer.parseInt(s.substring(temp+1,lastIndex));\n        \n        String rpStr=s.substring(lastIndex+1, s.indexOf(']',lastIndex));\n        rpStr=rpStr.repeat(repeatNum);\n        s=s.replace((s.substring(temp+1,s.indexOf(']',temp+1)+1)),rpStr);\n        return decodeString(s);      \n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189114277","body":"/* Idea\n-  第1个Stack用来push, 第2个Stack用来pop and peek.\n- 把第1个stack pop出来的数放到第2个Stack中，然后pop就是按照queue的次序pop\n*/\n\n/* Code Java */\nclass MyQueue {\n    Stack<Integer> in = new Stack<Integer>();\n    Stack<Integer> out = new Stack<Integer>();\n    \n    public MyQueue() {\n        \n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n        int res;\n        if (!out.empty()){\n            res = out.pop();\n        }else{\n            while(!in.empty()){\n                out.push(in.pop());\n            }\n            res = out.pop();\n        }\n        return res;\n    }\n    \n    public int peek() {\n        int res;\n        if (!out.empty()){\n            res = out.peek();\n        }else{\n            while(!in.empty()){\n                out.push(in.pop());\n            }\n            res = out.peek();\n        }\n        return res;\n    }\n    \n    public boolean empty() {\n        return (in.empty() && out.empty());\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n/* Complexity Analysis\nTime Complexity : push O(1), pop and peek: O(n)\nspase Complexity: O(n)\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189760137","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] rightMin = new int[arr.length+1];\n        rightMin[arr.length] = Integer.MAX_VALUE;\n        for(int i = arr.length-1; i>=0; i--){\n            rightMin[i] = Math.min(rightMin[i+1], arr[i]);\n        }\n        \n        int leftMax = Integer.MIN_VALUE;;\n        int count = 0;\n        for(int i = 0; i<arr.length; i++){\n            leftMax = Math.max(leftMax, arr[i]);\n            if(leftMax<=rightMin[i+1]){\n                count++;\n            }\n        }\n        return count;\n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191060774","body":"Idea\n- 分两个cases 1. k>list size 2. k<list size 来计算最后一个node.next = null的位置\n- 然后首位连接起来 返回head\n\nCode\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        \n        if(head == null) return null;\n        if(k == 0) return head;\n            \n        int size = 0;\n        ListNode cur = new ListNode();\n        cur = head;\n            \n        while(cur.next != null){\n            size++;\n            cur = cur.next;\n        }\n        size++;\n        \n        int steps = 0;\n        \n        //calculate the steps is the key!\n        if (k == size){\n            return head;\n        }else if (k < size){\n            steps = size - 1 - k;\n        }else if (k > size){\n            steps = size - 1 - (k % size); //trick here. should consider test cases\n        }\n        \n        cur = head;\n        for(int i = 0; i < steps; i++){\n            cur = cur.next;\n        }\n        \n        ListNode endNode = cur;\n        while(endNode.next != null)\n        {\n            endNode = endNode.next;\n        }\n        endNode.next = head;\n        head = cur.next;\n        cur.next = null;\n        \n        return head;\n    }\n}\n\nComplexity\nTime  complexity: O(n)\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192716319","body":"Idea\n- 双指针\n\nCode\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head==null || head.next==null)\n        {\n            return head;\n        }\n        ListNode p=head;\n        while(p!=null && p.next!=null)\n        {\n            int temp=p.val;\n            p.val=p.next.val;\n            p.next.val=temp;\n            p=p.next.next;\n        }\n        return head;\n    }\n}\n\n\nComplexity\nTime  complexity: O(n)\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193139554","body":"思路 BST\n\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head==null)\n            return null;\n        ListNode temp=head;int n=0;\n        while(temp.next!=null){\n            temp=temp.next;\n            n++;\n        }\n        return sortedListToBST(head, 0 ,n);\n    }\n     TreeNode sortedListToBST(ListNode head, int start, int end) {\n        \n        if(start > end){\n            return null;\n        }\n        \n        int middle = (end + start) / 2;\n        ListNode temp=head;\n        \n        for(int i=start;i<middle;i++){\n            temp=temp.next;\n        }\n        TreeNode node = new TreeNode(temp.val);\n        \n        node.left = sortedListToBST(head,start, middle-1);\n        node.right = sortedListToBST(temp.next, middle+1, end);\n        \n        return node;\n    }\n    \n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193342726","body":"Code\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        \n        while(headA!= null){\n            ListNode curr = headB;\n            while(curr!=null){\n                if(curr == headA){\n                    return headA;\n                }\n                else{\n                    curr = curr.next;\n                }\n            }\n            headA = headA.next;\n        }\n        \n        return null;\n    }\n}\n\n\nComplexity\nTime  complexity: O(m+n)\nSpace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193569977","body":"Idea\n- 双指针 + 数学问题\n\nCode\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null){//head.next is for only one node\n            return null;\n        }\n        \n        ListNode fast = head;\n        ListNode slow = head;\n        boolean hasCycle = false;\n        \n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            \n            if(fast == slow){\n                hasCycle = true;\n                break;\n            }\n        }\n        \n        if (hasCycle == false){\n            return null;\n        }\n        \n        slow = head;\n        \n        if (fast == slow){ //for the case, like the Example2\n            return slow;\n        }\n        \n        while(fast != null && fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n            if (fast == slow){\n                break;\n            }\n        }\n        return slow;\n    }\n}\n\nComplexity\nTime  complexity: O(n)\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194823262","body":"Idea\n- Use LinkedHashMap\n\nCode\nclass LRUCache {\n    int cap;\n    LinkedHashMap<Integer, Integer> cache;\n    \n    public LRUCache(int capacity) {\n        this.cap = capacity;\n        this.cache = new LinkedHashMap<Integer, Integer>();\n    }\n    \n    public int get(int key) {\n        if(!cache.containsKey(key)){\n            return -1;\n        }\n        makeRecently(key);\n        return cache.get(key);\n    }\n    \n    public void put(int key, int value) {\n\n        if (cache.containsKey(key)) {\n            cache.put(key,value);\n            makeRecently(key);\n            return;\n        }\n        \n        if (cache.size() >= this.cap) {\n            int oldestKey = cache.keySet().iterator().next(); //the first one is the oldest\n            cache.remove(oldestKey);\n        }\n        \n        cache.put(key,value);\n        \n    }\n    \n    private void makeRecently(int key) {\n        int val = cache.get(key);\n        cache.remove(key);\n        cache.put(key, val);\n    }\n}\n\nComplexity\nTime  complexity: O(1)\nSpace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196029131","body":"Idea\n- 递归+回溯\n\nclass Solution {\n    int depth = 0;\n    int res = 0;\n\n    public int maxDepth(TreeNode root) {\n        traverse(root);\n        return res;\n    }\n\n    void traverse(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n\n        depth++;\n        res = Math.max(res, depth);\n        traverse(root.left);\n        traverse(root.right);\n        depth--;\n    }\n}\n\nTime O(n)\nSpace O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185644120","body":"常规思路：1.数组和数字相互转换；2.两数组逐位相加\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186530094","body":"考察栈的存储结构，操作\n\n class CustomStack {\n\n    static class Node {\n        int val;\n        int delta;\n        Node(int val) {\n            this.val = val;\n            this.delta = 0;\n        }\n    }\n\n    Node[] stack = null;\n    int len = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new Node[maxSize];\n    }\n    \n    public void push(int x) {\n        if (len < stack.length) {\n            stack[len++] = new Node(x);\n        }\n    }\n    \n    public int pop() {\n        if (len <= 0) return -1;\n        Node top = stack[len - 1];\n        if (len >= 2) {\n            stack[len - 2].delta += top.delta;\n        }\n        len--;\n        return top.val + top.delta;\n    }\n    \n    public void increment(int k, int val) {\n        if (len >= k && k >= 1) {\n            stack[k - 1].delta += val;\n        } else if (len > 0) {\n            stack[len - 1].delta += val;\n        }\n    }\n}\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193132640","body":"思路：要熟悉二叉树的遍历和存储，本题是考察中序遍历存储结果还原二叉树，高度差不大于1根节点是中间位置用快慢指针\n\n代码：\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n\n        // 快慢指针找中心节点\n        ListNode p = head, q = head, pre = null;\n        while (q != null && q.next != null) {\n            pre = p;\n            p = p.next;\n            q = q.next.next;\n        }\n        pre.next = null;\n       \n        // 以升序链表的中间元素作为根节点 root，递归的构建 root 的左子树与右子树。\n        TreeNode root = new TreeNode(p.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(p.next);\n        return root;\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193328183","body":"思路：\n     参考了题解，两个入口双指针分别移动遍历整个链表，必然在指针移动次数==链表长度的位置相遇。\n代码：\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185647007","body":"```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> sum = new ArrayList<Integer>();\n        int length = num.length;\n        num[length - 1] += k;\n        for (int i = length - 1; i > 0; i--) {\n            int curNum = num[i];\n            if (curNum > 9) {\n                num[i - 1] += curNum / 10;\n                num[i] %= 10;\n            }\n            sum.add(num[i]);\n        }\n        do {\n            sum.add(num[0] % 10);\n            num[0] /= 10;\n        } while (num[0] > 0);\n        Collections.reverse(sum);\n        return sum;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186516976","body":"```java\nclass CustomStack {\n\n    private final Integer maxSize;\n\n    private Integer top;\n\n    private final Integer[] arr;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        top = 0;\n        arr = new Integer[maxSize];\n    }\n\n    public void push(int x) {\n        if (top.equals(maxSize)){\n            return;\n        }\n        arr[top++] = x;\n    }\n\n    public int pop() {\n        if (top <= 0){\n            return -1;\n        }\n        return arr[--top];\n    }\n\n    public void increment(int k, int val) {\n        k = k<top? k : top;\n        for (int i = 0; i < k; i++) {\n            arr[i] += val;\n        }\n    }\n}\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187660017","body":"```java\npublic String decodeString(String s) {\n        char[] chars = s.toCharArray();\n        Stack<Object> stack = new Stack<>();\n        for (int i = 0; i < chars.length; i++) {\n            if (Character.isDigit(chars[i])) {\n                int repit = 0;\n                do {\n                    repit = 10 * repit + Integer.parseInt(String.valueOf(chars[i]));\n                    i++;\n                } while (Character.isDigit(chars[i]));\n//                i--;\n                stack.push(repit);\n            }\n            if (']' != chars[i]){\n                stack.push(chars[i]);\n            } else {\n                StringBuilder temp = new StringBuilder();\n                while (!String.valueOf(stack.peek()).equals(\"[\")){\n                    temp.insert(0, stack.pop());\n                }\n                stack.pop();\n                int count = Integer.parseInt(String.valueOf(stack.pop()));\n                String toString = temp.toString();\n                for (int j = 1; j < count; j++) {\n                    temp.append(toString);\n                }\n                stack.push(temp.toString());\n            }\n        }\n        StringBuilder rtn = new StringBuilder();\n        while (!stack.empty()){\n            rtn.insert(0, stack.pop());\n        }\n        return rtn.toString();\n\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189137456","body":"```java\nclass MyQueue {\n\n    private final Stack<Integer> inStack;\n\n    private final Stack<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (!outStack.empty()){\n            return outStack.pop();\n        }\n        while (!inStack.empty()){\n            outStack.push(inStack.pop());\n        }\n        return pop();\n    }\n\n    public int peek() {\n        if (!outStack.empty()){\n            return outStack.peek();\n        }\n        while (!inStack.empty()){\n            outStack.push(inStack.pop());\n        }\n        return peek();\n    }\n\n    public boolean empty() {\n        return inStack.empty()&& outStack.empty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190400110","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] expect = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(expect);\n        int count = 0;\n        int i = 0;\n        int sumL = 0;\n        int sumR = 0;\n        while (i < arr.length) {\n            sumL+=arr[i];\n            sumR+=expect[i];\n            if (sumL == sumR){\n                count++;\n                sumL = 0;\n                sumR = 0;\n            }\n            i++;\n        }\n        return count;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191639484","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(null == head || head.next == null){\n            return head;\n        }\n        ListNode left = head;\n        ListNode right = head;\n        int length = 0;\n        for (int i = 0; i < k; i++) {\n            if (null == right.next){\n                right = head;\n                length = i + 1;\n                break;\n            } else {\n                right = right.next;\n            }\n        }\n        if (0!= length){\n            k = k%length;\n            for (int i = 0; i < k; i++) {\n                right = right.next;\n            }\n        }\n        while (right.next!=null){\n            right = right.next;\n            left = left.next;\n        }\n        right.next = head;\n        right = left.next;\n        left.next = null;\n        return right;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192616956","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        for(ListNode p = dummy; p.next != null && p.next.next != null;)\n        {\n            ListNode a = p.next;\t//虚拟头节点\n            ListNode b = a.next;\n            p.next = b;\n            a.next = b.next;\n            b.next = a;\n            p = a;\n        }\n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193144588","body":"```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n     \n\n\n        if (head == null){\n            return null;\n        }else if(head.next == null){\n            return new TreeNode(head.val);\n        }\n        \n\n\n        ListNode slow = head, fast = head;\n        ListNode pre = null;\n        while( fast != null && fast.next != null){\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        pre.next = null;\n\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194085691","body":"```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null){\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        do {\n            fast = fast.next.next;\n            slow = slow.next;\n        }while (fast != slow && fast != null && fast.next != null);\n\n        if (null == fast || fast.next == null){\n            return null;\n        }\n        ListNode rtn = head;\n        while (rtn != slow){\n            rtn = rtn.next;\n            slow = slow.next;\n        }\n        return rtn;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195639219","body":"```java\npublic class LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > capacity) {\n                DLinkedNode tail = removeTail();\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n        else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196943699","body":"```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        } else {\n            int left = maxDepth(root.left);\n            int right = maxDepth(root.right);\n            return Math.max(left, right) + 1;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185652987","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        nstr = ''.join(map(str,num))\n        n = int(nstr)\n        res = n + k\n        return list(map(int,str(res)))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185656280","body":"```go\nfunc addToArrayForm(num []int, k int) []int {\n\tvar ans []int\n\tfor i := len(num) - 1; i >= 0; i-- {\n\t\tsum := num[i] + k%10\n\t\tk /= 10\n\t\tif sum >= 10 {\n\t\t\tk++\n\t\t\tsum -= 10\n\t\t}\n\t\tans = append(ans, sum)\n\t}\n\tfor ; k > 0; k /= 10 {\n\t\tans = append(ans, k%10)\n\t}\n\treverse(ans)\n\treturn ans\n}\nfunc reverse(num []int) {\n\tfor i, n := 0, len(num); i < n/2; i++ {\n\t\tnum[i], num[n-1-i] = num[n-1-i], num[i]\n\t}\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191628584","body":"```go\n\n// golang\nfunc rotateRight(head *ListNode, k int) *ListNode {\n  if k == 0 || head == nil || head.Next == nil {\n    return head\n  }\n  n := 1\n  iter := head\n  for iter.Next != nil {\n    iter = iter.Next\n    n++\n  }\n  add := n - k%n\n  if add == n {\n    return head\n  }\n  iter.Next = head\n  for add > 0 {\n    iter = iter.Next\n    add--\n  }\n  ret := iter.Next\n  iter.Next = nil\n  return ret\n\n}\n\ntype ListNode struct {\n  Val int\n  Next *ListNode\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192453015","body":"```go\n//golang\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n  if head == nil || head.Next == nil {\n    return head\n  }\n  newHead := head.Next\n  head.Next = swapPairs(newHead.Next)\n  newHead.Next = head\n  return newHead\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185658739","body":"```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int increase = 0;\n        reverse(num.begin(), num.end());\n        int pos = 0;\n        vector<int> result;\n        while (k > 0 || pos < num.size() || increase > 0 ) {\n            auto digit = k % 10;\n            auto num_digit = pos < num.size() ? num[pos] : 0;\n            auto new_val = num_digit + digit + increase;\n            increase = new_val / 10;\n            new_val = new_val % 10;\n            result.push_back(new_val);\n            \n            ++pos;\n            k = k / 10;\n            // cout << new_val << endl;\n        }\n        \n        // cout << result.size() << endl;\n        reverse(result.begin(), result.end());\n        return result;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186213458","body":"### Solution:\n- 1. Initialize a result vector which has the same size as string, all the value is INF, [INF, INF....]  O(n)\n- 2. Find the c in the string, and mark the corresponding position as 0 [INF,..0... 0....INF]  O(n)\n- 3. Then for each c, update's left and right value incrementally, until it hits the boundary of the vector or 0 O(n)\n- Time complexity O(n)\n### Code:\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> results(s.size(), INT_MAX);\n        for (int i = 0; i < s.size(); ++i ) {\n            if (s[i] == c) {\n                results[i] = 0;\n            }\n        }\n        \n        for (int i = 0; i < s.size(); ++i ) {\n            if (results[i] == 0) {\n                update_left(results, i);\n                update_right(results, i);\n            }\n        }\n    \n        return results;\n    }\n    \n    \n    void update_left(vector<int>& results, int idx) {\n        auto distance = 0;\n        while (idx > 0) {\n            --idx;\n            ++distance;\n            if (distance < results[idx]) {\n                results[idx] = distance;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    \n    void update_right(vector<int>& results, int idx) {\n        auto distance = 0;\n        while (idx < results.size() - 1) {\n            ++idx;\n            ++distance;\n            if (distance < results[idx]) {\n                results[idx] = distance;\n            }\n            else {\n                break;\n            }\n            \n        }\n    }\n    \n    \n};\n\n```\n\n**complexity analysis**\n- Time：O(N)，\n- Space：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186433116","body":"### Solution:\n1. use vector as underlying data structure\n2. push() -> vector.push_back()   O(1) or O(n)\n3. pop() -> vector.pop_back and return last element O(1)\n4. increment() -> increment elements at the bottom O(n)\n\n### Code:\n\n\n```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) : _maxSize(maxSize){\n        \n        \n    }\n    \n    void push(int x) {\n        if (_v.size() < _maxSize) {\n            _v.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if (_v.size() == 0) {\n            return -1;\n        }\n        else {\n            auto result = _v[_v.size() -1];\n            _v.pop_back();\n            return result;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int i = 0;\n        while (k > 0 && i < _v.size()) {\n            _v[i] += val;\n            ++i;\n            --k;\n        }\n    }\n    \nprivate:\n    vector<int> _v;\n    int _maxSize;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n```\n\n**complexity analysis**\n- Time：O(N)，\n- Space：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186725285","body":"### Solution:\ndata structure: stack to store\n1. loop whole string\\\n     1.1. if digit, letters or [ push to stack\\\n     1.2. if ] pop until find [, \\\n           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then find all the digit before, convert to int\\\n           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int * [string], push back to stack\n2. when we running out of s,  pop out all the string from the stack and return\n\n### Code:\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<char> st;\n        for (auto c : s) {\n            if (c == ']') {\n                auto str = find_str(st);\n                auto repeat = find_num(st);\n                string repeated_str;\n                while (repeat > 0) {\n                    repeated_str += str;\n                    --repeat;\n                }\n                // cout << \"repeated_str\" << repeated_str << endl;\n                for (auto repeated_char : repeated_str) {\n                    st.push(repeated_char);\n                }\n            }\n            else {\n                st.push(c);\n            }\n        }\n        \n        string result;\n        while (!st.empty()) {\n            auto c = st.top();\n            result += c;\n            st.pop();\n        }\n        reverse(result.begin(), result.end());\n        \n        return result;\n        \n    }\n    \nprivate:\n    string find_str(stack<char>& st) {\n        string str;\n        while (!st.empty()) {\n            auto c = st.top();\n            if (c == '[') {\n                st.pop();\n                break;\n            }\n            else{\n                str += c;\n                st.pop();\n            }\n        }\n        \n        reverse(str.begin(), str.end());\n        // cout << \"find str\" << str << endl;\n        return str;\n    }\n    \n    int find_num(stack<char>& st) {\n        string num_str;\n        while (!st.empty()) {\n            auto c = st.top();\n            if (!isdigit(c)) {\n                break;\n            }\n            else{\n                num_str += c;\n                st.pop();\n            }\n        }\n        \n        reverse(num_str.begin(), num_str.end());\n        // cout << \"find num_str\" << num_str << endl;\n        int num = stoi(num_str);\n        return num;\n    }\n    \n};\n\n```\n\n**complexity analysis**\n- Time：O(N)，\n- Space：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188614107","body":"```c++\n/***\nData structure: push_stack, pop_stack\n1. push stack is used to push item into queue, like this:[a,b,c\n2. pop stack is used to pop item out of queue, like this: a,b,c]\n3. when we need to push item, we check if pop stack has items, \n    if it is, we put everything back to push stack, \n    then push to push stack\n4. when we need to peek or pop item, we check if push stack has items,\n    if it is, we put everything back to pop stack,\n    then do peek or pop\n5. empty(), both stacks are empty\n***/\n\n\nclass MyQueue {\npublic:\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        while (!pop_stack.empty()) {\n            auto val = pop_stack.top();\n            push_stack.push(val);\n            pop_stack.pop();\n        }\n        \n        push_stack.push(x);\n    }\n    \n    int pop() {\n        while (!push_stack.empty()) {\n            pop_stack.push(push_stack.top());\n            push_stack.pop();\n        }\n        \n        auto result = pop_stack.top();\n        pop_stack.pop();\n        return result;\n    }\n    \n    int peek() {\n        while (!push_stack.empty()) {\n            pop_stack.push(push_stack.top());\n            push_stack.pop();\n        }\n    \n        return pop_stack.top();  \n    }\n    \n    bool empty() {\n        return push_stack.empty() && pop_stack.empty();\n    }\n    \nprivate:\n    stack<int> push_stack;\n    stack<int> pop_stack;\n    \n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191035289","body":"```c++\n// 1. find the size of the list O(n)\n// 2. make the linked list become a circle O(1)\n// 3.  move the head to size - (k % size) O(n)\n// 4. cut the circle before the head O(1)\n// 5. return the head\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        \n        \n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        int size = 0;\n        auto cur = head;\n        auto pre = dummy;\n        while (cur != nullptr) {\n            ++size;\n            cur = cur->next;\n            pre = pre->next;    \n        }\n        \n        if (size == 0) {\n            return head;\n        }\n        \n        pre->next = dummy->next;\n        cur = head;\n        pre = dummy;\n        k = size - (k % size);\n        while (k > 0) {\n            cur = cur->next;\n            pre = pre->next;   \n            --k;\n        }\n        pre->next = nullptr;\n        return cur;\n        \n    }\n};\n```\n\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192082169","body":"```c++\n\n/***\nSolution:\noriginal: pre_pre -> pre -> cur -> tmp\ntarget: pre_pre -> cur -> pre -> tmp\n\ncur->next = pre;\npre->next = tmp;\npre_pre->next = cur;\n\nTime: O(n)\nSpace: O(1)\n\n***/\n\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr) {\n            return head;\n        }\n        \n        ListNode* dummy = new ListNode(0, head);\n        auto* pre_pre = dummy;\n        auto* pre = dummy->next;\n        auto* cur = dummy->next->next;\n        while (pre != nullptr && cur != nullptr) {\n            auto* tmp = cur->next;\n            cur->next = pre;\n            pre->next = tmp;\n            pre_pre->next = cur;\n            \n            pre_pre = pre;\n            pre = pre_pre->next;\n            if (pre != nullptr) {\n                cur = pre->next;\n            }\n            else {\n                break;\n            }\n            \n        }\n        \n        return dummy->next;\n        \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193051555","body":"```c++\n\n/***\n1. if head = nullptr, return nullptr (nothing)  O(1)\n2. if head->next = nullptr, return TreeNode(head->val)  (single node) O(1)\n3. pre =  dummy->next = head, cur = head, fast = head O(1)\n4. Use slow and fast pointer to find the mid point of the linked list O(n)\n5. break the linked list [pre->next = nullptr, cur->next = nullptr, next] O(1)\n6. Recursion cur->left = sortedListToBST(dummy->next),  cur->right = sortedListToBST(next) O(n)\n7. return cur\n\n\n***/\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr) {\n            return nullptr;\n        }\n        \n        if (head->next == nullptr) {\n            return new TreeNode(head->val);\n        }\n        \n        auto* dummy = new ListNode(0, head);\n        auto* pre = dummy;\n        auto* cur = head;\n        auto* fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            pre = pre->next;\n            cur = cur->next;\n            fast = fast->next;\n            fast = fast->next;\n        }\n        \n        pre->next = nullptr;\n        auto* next_ptr = cur->next;\n        cur->next = nullptr;\n        auto* left = sortedListToBST(dummy->next);\n        auto* right = sortedListToBST(next_ptr);\n        auto result = new TreeNode(cur->val, left, right);\n        return result;\n\n    }\n};\n\nTime: O(n)\nSpace : O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193222924","body":"```c++\n/***\nSolution\n1. use hashmap to store all the nodes in A  time: O(A) Space: O(A)\n2. iterate through B, find if there is any common node time: O(B)\n\n\n\n***/\n\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set<ListNode*> nodes;\n        auto cur = headA;\n        while(cur != nullptr) {\n            nodes.insert(cur);\n            cur = cur->next;\n        }\n        \n        cur = headB;\n        while (cur != nullptr) {\n            if (nodes.find(cur) != nodes.end()) {\n                return cur;\n            }\n            cur = cur->next;\n        }\n        \n        return nullptr;\n    }\n};\n```\n\nTime: O(A) + O(B)\nSpace: O(A)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193968016","body":"```c++\n/***\nslow and fast pointer\n\nfirst meet:\nNC [-> C -> D]\n\npath(slow) = NC + C\npath(fast) = NC + C + D + C = 2NC + 2C    => NC = D\n\nfast start from head AGAIN, and make it move like slow pointer\nsecond meet:\n\npath(slow) = D\npath(fast) = NC\nNC = D, then they will meet at the begining of the cycle\n\nTime: O(n)\nSpace: O(1)\n\n***/\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        auto* slow = head;\n        auto* fast = head;\n        while( fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                fast = head;\n                while (slow != fast) {\n                    slow = slow->next;\n                    fast = fast->next;\n                }\n                return slow;\n            }\n        }\n        \n        return nullptr;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194990508","body":"```c++\n/***\nSolution 1:\nData strucutre:\n(1) HashMap: <int, preNode*>, so that get will be O(1)\n(2) Single Linked List: head->node1->node2->...-> so that push_back and pop_front will be O(1)\n(3) MyNode{next, key, value}: store the key, so when we need change the strcutre of single linked list, \n                              we can use key to update the map\n\n(1)  get\n    1.1 get latest node, do nothing\n    1.2 get non-latest node, put the node to the end\n        since its single linked list, we need to store the pre-node to move node around\n        we need to update the map of next node, since its pre node has changed\n(2) put\n    1.1 if key already exist, make use of get() to move the node to the end, then update the value of node\n    1.2 if key does not exist, but size == capacity, remove the dummy->next, update\n        a. erase map[old_node->key]\n        b. if old_node next node exist, update map[old_node->next->key] = dummy\n        c. if this node is the cur node, update cur pointer\n    1.3 create a new node, update\n        a. map\n        b. cur pointer\n        c. size\n    \n        \n        \n\n\n***/\n\nstruct MyListNode {\n    int key = 0;\n    int val = 0;\n    MyListNode* next = nullptr;\n    MyListNode (){}\n    MyListNode (int k, int v): key(k), val(v){}\n    // MyListNode (int k, int v, MyListNode* n): key(k), val(v), next(n){}\n};\n\nclass LRUCache {\npublic:\n    LRUCache(int capacity): _capacity(capacity) {\n        dummy = new MyListNode();\n        cur = dummy;\n    }\n    \n    int get(int key) {\n        if (nodes.find(key) != nodes.end()) {\n            auto pre_node = nodes[key];\n            auto node = pre_node->next;\n            auto v = node->val;\n            if (cur != node) {\n                pre_node->next= node->next;\n                nodes[node->next->key] = pre_node;  // update next node's map\n                cur->next= node;\n                node->next = nullptr;\n                nodes[key] = cur;\n                cur = node;\n            }\n\n            return v;\n        }\n       \n        \n        return -1;\n    }\n    \n    void printNode(MyListNode* head) {\n        cout << \"[\";\n        while (head != nullptr) {\n            cout << head->val << \"|\";\n            head = head->next;\n        }\n        cout << \"]\\n\";\n    }\n    \n    void put(int key, int value) {\n        // cout << \"put\" << key << value;\n        // printNode(dummy);\n        if (nodes.find(key) != nodes.end()) {\n            get(key);\n            nodes[key]->next->val = value;\n            return ;\n        }\n        \n        \n        if (_size >= _capacity) {\n            auto tmp = dummy->next;\n            dummy->next = tmp->next;\n            nodes.erase(tmp->key);\n            if (dummy->next != nullptr) {\n                nodes[dummy->next->key] = dummy;\n            }\n            \n            --_size;\n            if (cur == tmp) {\n                cur = dummy;\n            }\n            // printNode(dummy);\n        }\n        \n        auto node = new MyListNode(key, value);\n        cur->next = node;\n        nodes[key] = cur;\n        cur = cur->next;\n        ++_size;\n     \n        // printNode(dummy);\n    }\n    \nprivate:\n    int _capacity = 0;\n    int _size = 0;\n    MyListNode *dummy;\n    MyListNode *cur;\n    unordered_map<int, MyListNode*> nodes;\n    \n    \n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196515960","body":"```c++\n/***\nSolution:\n\nRecursion:\n\n1. if root = nullptr, depth = 0\n2. if root != nullptr, depth = max(left, right) + 1\n\nTime: O(n)\nSpace: O(1)\n\n***/\n\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n        \n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197513835","body":"```c++\n/***\nSolution\n1. if p=q=nullptr, return true  O(1)\n2. if p=nullptr, q!=nullptr or q=nullptr, p!=nullptr, return false O(1)\n3. if val = val && left=left && right=right return true O(n)\n4. return false\n\nTime: O(n)\nSpace: O(log(n))\n\n***/\n\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) {\n            return true;\n        }\n        \n        if ((p == nullptr && q != nullptr) || \n            (p != nullptr && q == nullptr) ) {\n            return false;\n        }\n        \n        \n        if (p->val == q->val &&\n           isSameTree(p->left, q->left) &&\n           isSameTree(p->right, q->right)  ) {\n            return true;\n        }\n        \n        return false;\n        \n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185658990","body":"### 解题思路\n\n​\t将数组的每一位倒序取出然后和k进行相加，确保k每次是个位数。\n\n​\t当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n\n​\t注意，AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\n\n​\t最后反转数组\n\n### 代码实现\n\n```java\nclass Solution {\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> res = new ArrayList<Integer>();  \n    int carry=0; //判断进位\n    int i=num.length -1; //判断数组里的整数是否遍历结束\n    // 可以用 LinkeList，或者 ArrayList 往后加，最后反转\n\n    while (i >= 0 || k!= 0) { \n        int x = i>= 0 ? num[i]: 0;\n        int y = k!= 0 ? k % 10 : 0;\n                    \n        int sum = x + y + carry;\n        res.add(sum % 10);\n        carry =sum/10;\n        i--;\n        k=k/10;\n    }\n        if(carry !=0)res.add(carry);\n        Collections.reverse(res);\n        return res;\n       \n\t}\n}    \n```\n\n\n\n### 复杂度：\n\n```md\n时间复杂度 : O(min(n,k)) \n空间复杂度: O(n)\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186211456","body":"\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n\n int length=s.length();\n        List<Integer> list=new ArrayList<Integer>();\n        int[] res=new int[length];\n        for(int i=0;i<length;i++)\n        {\n            if(s.charAt(i)==c)\n            {\n                list.add(i);\n            }\n        }\n        int i=0;\n        int j=0;\n        while(i<length)\n        {\n            int min=Math.abs(list.get(j)-i);\n            while(j<list.size())\n            {\n                if(min>Math.abs(list.get(j)-i))\n                {\n                    min=Math.abs(list.get(j)-i);\n                }\n                j++;\n            }\n            res[i]=min;\n            j=0;\n            i++;\n        }\n        return res;\n\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186439547","body":"class CustomStack {\n        int[]stack;\n        int top;\n    public CustomStack(int maxSize) {\n        stack=new int [maxSize];\n        top=-1;\n\n    }\n    \n    public void push(int x) {\n        if(top!=stack.length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    \n    public int pop() {\n          if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];   \n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187570040","body":" StringBuilder res = new StringBuilder();\n        int multi = 0;\n        // LinkedList<Integer> stack_multi = new LinkedList<>();\n        // LinkedList<String> stack_res = new LinkedList<>();\n        Stack<Integer> stack_multi = new Stack<>();\n        Stack<String> stack_res = new Stack<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.push(multi);\n                stack_res.push(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.pop();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.pop() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c+\"\");\n            else res.append(c);\n        }\n        return res.toString();","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189132256","body":"class MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n\n时间复杂度O（1）\n空间复杂度O（n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190337226","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for (int num : arr) {\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                // 我们需要将融合后的区块的最大值重新放回栈\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\n                int cur = stack.removeLast();\n                // 维持栈的单调递增\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        // 栈存的是块信息，因此栈的大小就是块的数量\n        return stack.size();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191525255","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        while(now != null){\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192680813","body":"class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode preNode = new ListNode(-1, head), res;\n        preNode.next = head;\n        res = head.next;\n        ListNode firstNode = head, secondNode, nextNode;\n        while(firstNode != null && firstNode.next != null){\n            secondNode = firstNode.next;\n            nextNode = secondNode.next;\n\n            firstNode.next = nextNode;\n            secondNode.next = firstNode;\n            preNode.next = secondNode;\n\n            preNode = firstNode;\n            firstNode = nextNode;\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193130155","body":"class Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null) return null;\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail) return null;\n      ListNode fast = head, slow = head;\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193330319","body":"public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode A = headA, B = headB;\n        while (A != B) {\n            A = A != null ? A.next : headB;\n            B = B != null ? B.next : headA;\n        }\n        return A;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1195558209","body":"public class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        Set<ListNode> visited = new HashSet<ListNode>();\n        while (pos != null) {\n            if (visited.contains(pos)) {\n                return pos;\n            } else {\n                visited.add(pos);\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n}\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195557209","body":"class LRUCache {\n    class DLinkedNode {\n        int key, value;\n        DLinkedNode prev, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //add dummy head and dummyTail\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //if key exist, move it to head by using its location store in Hashmap\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196858363","body":"class Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185660112","body":"### 思路\n\n数字还原后相加，再转换为数字列表。\n\n### 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        degit = 0\n        for d in num:\n            degit *= 10\n            degit += d\n        # print(degit)\n        k += degit\n        # print(k)\n\n        res = []\n        while k != 0:\n            res.append(k % 10)\n            # print(res)\n            k //= 10\n        return res[::-1]\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186223951","body":"### 思路\n\n遍历一遍字符串，得到`id_list`存储相等的索引，并且置返回数组`ans`对应位置为0；再次遍历数组，对于每个不相等的字符位置计算`id_list`中，与之最近的索引距离，并记录在返回数组`ans`对应位置。\n\n### 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [-1] * len(s)\n        id_list = []\n        for i in range(len(s)):\n            if s[i] == c:\n                ans[i] = 0\n                id_list.append(i)\n        for i, ch in enumerate(s):\n            if ch != c:\n                min_dst = len(s)\n                for idx in id_list:\n                    min_dst = min(min_dst, abs(i - idx))\n                ans[i] = min_dst\n                \n        return ans\n```\n\n### 复杂度\n\n时间复杂度：$O(n^2)$\n\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186541287","body":"### 思路\n\n使用列表模拟堆栈，调用列表方法实现功能。\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        if self.maxSize > len(self.stack):\n            self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187675530","body":"### 思路\n\n根据字符串中不同种类的字符分情况讨论，利用栈储存每一次的乘数以及中间结果。\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, num = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([num, res])\n                res, num = \"\", 0\n            elif c == ']':\n                cur_num, last_res = stack.pop()\n                res = last_res + cur_num * res\n            elif '0' <= c <= '9':\n                num = num * 10 + int(c)            \n            else:\n                res += c\n        return res\n```\n\n### 复杂度\n\n时间复杂度：$O(n)$\n\n时间复杂度：$O(n^2)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189227283","body":"### 思路\n\n利用两个栈之间来回储存每一个元素，实现队列的相应功能。\n\n### 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n\n    def pop(self) -> int:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        res = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return res\n\n\n    def peek(self) -> int:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        res = self.stack2[-1]\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return res\n\n\n    def empty(self) -> bool:\n        return self.stack1 == []\n```\n\n### 复杂度\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(n)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190434807","body":"### 思路\n\n虚假的困难。。考虑分块需要排序，于是可以递增范围和排序完的数组进行对比。对比的方式这里可以计算前缀和是否相等，如果前缀和相等，就是一个分块。\n\n这里的充要性体现在：分块的范围与排序后的范围是一致的，于是分块后的操作就是对这个范围之内的元素进行坐标改变，而元素数值不会进行改变，两个范围的数值和相同，说明可以通过对分块的坐标进行某种改变来得到排序后的数组。\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        sorted_arr = sorted(arr)\n\n        arr_sum = 0\n        sorted_sum = 0\n\n        res = 0\n\n        for x, y in zip(arr, sorted_arr):\n            arr_sum += x\n            sorted_sum += y\n\n            if arr_sum == sorted_sum:\n                res += 1\n        \n        return res\n```\n\n### 复杂度\n\n时间复杂度：$O(nlog(n))$\n\n空间复杂度：$O(n)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191178242","body":"### 思路\n\n整体右移`k`个位置等于以`n-k`位置之后的节点作为头节点，将链表成环，并以`n-k`位置之后进行断裂。\n\n### 代码\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head is None or head.next is None or k == 0:\n            return head\n        cur = head\n        n = 1\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        add = n - k % n\n\n        if add == n:\n            return head\n        \n        cur.next = head\n        \n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        \n        return ret\n```\n\n### 复杂度\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(1)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192717843","body":"### 思路\n\n迭代的方式，在原有头节点之前增设一个空节点，对三个节点之间进行后两个节点的交换操作，直至链表只剩一个节点或者完全被遍历。\n\n### 代码\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        pre_head = ListNode()\n        pre_head.next = head\n        temp = pre_head\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next \n\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n        return pre_head.next\n```\n\n### 复杂度\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(1)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193143426","body":"### 思路\n\n使用快慢指针寻找链表的中间节点，令找到的中间节点为根结点，并且通过递归的方式从链表的左右部分构建子树。\n\n### 代码\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def getMedian(left, right):\n            fast = left\n            slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n\n            return slow\n\n        def buildTree(left, right):\n            if left == right:\n                return None\n\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n\n            return root\n        \n        return buildTree(head, None)\n```\n\n### 复杂度\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(logn)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193309624","body":"### 思路\n\n使用两个指针分别按照顺序AB与BA同步遍历链表。如果两个链表具有交叉节点，则会出现两个指针指向相同节点的情况；如果两个链表没有交叉节点，则会出现两个指针指向`None`的情况。于是，返回两个指针相同时的元素即可。\n\n### 代码\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p1 = headA\n        p2 = headB\n        while p1 != p2:\n            if p1:\n                p1 = p1.next\n            else:\n                p1 = headB\n            if p2:\n                p2 = p2.next\n            else:\n                p2 = headA\n                \n        return p1\n```\n\n### 复杂度\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193815502","body":"### 思路\n\n使用两个指针，分别按照1和2的速度进行链表遍历。如果链表具有环，则会出现两个指针指向相同节点的情况；如果两个链表没有交叉节点，则会出现快指针为`None`或快指针指向`None`的情况。对于返回的相同节点，再设置新指针从头节点作为开始与之同时前进，当两个指针指向相同的元素时，即为链表环的入口。\n\n### 代码\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n\n        if not fast or not fast.next:\n            return None\n        \n        res = head\n        while res != slow:\n            res = res.next\n            slow = slow.next\n\n        return res\n```\n\n### 复杂度\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195641392","body":"### 思路\n\n通过哈希表辅以双向链表实现\n\n### 代码\n\n```python\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196923209","body":"### 思路\r\n\r\n寻找左右子树的最大深度，取最大深度进行递归。\r\n\r\n### 代码\r\n\r\n```\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        else:\r\n            left = self.maxDepth(root.left)\r\n            right = self.maxDepth(root.right)\r\n\r\n            return max(left, right) + 1\r\n```\r\n\r\n### 复杂度\r\n$O(N)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185660258","body":"## 思路\r\n将num和k都转成数组（增加了额外空间，呜呜～～）并倒序，每个元素因此相加，若大于等于10，下一次相加另外再加1\r\n\r\n## 代码\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let arr1 = num.reverse()\r\n    let arr2 = String(k).split('').reverse().map(item => Number(item))\r\n    let i = 0\r\n    let arr = []\r\n    let extra = 0\r\n    while(i < arr1.length || i < arr2.length) {\r\n        let sum = (arr1[i] || 0) + (arr2[i] || 0) + extra\r\n        if (sum >= 10) {\r\n            arr.push(sum - 10)\r\n            extra = 1\r\n        } else {\r\n            arr.push(sum)\r\n            extra = 0\r\n        }\r\n        i++\r\n    }\r\n    if (extra === 1) {\r\n        arr.push(1)\r\n    }\r\n    \r\n    return arr.reverse()\r\n};\r\n```\r\n\r\n## 复杂度\r\n时间：O(n), 数组的reverse不知道复杂度多少\r\n空间：O(n),","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189180166","body":"```js\r\nvar MyQueue = function() {\r\n    this.arr = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.arr.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.arr.shift()\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.arr[0]\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.arr.length === 0\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190460802","body":"## 代码\r\n```js\r\nvar maxChunksToSorted = function(arr) {\r\n    // 单调递增栈\r\n    let stack = [arr[0]] // 存每个分块的最大值\r\n    for (let i = 1; i < arr.length; i++) {\r\n        if (arr[i] >= stack[stack.length - 1]) {\r\n            // arr[i]大于等于前面分块的最大值，可以独立分一个块\r\n            stack.push(arr[i])\r\n        } else {\r\n            // 小于，就合到上一个分块\r\n            let temp = stack.pop() // 上一分块的最大值\r\n            while (arr[i] < stack[stack.length - 1]) {\r\n                // 将小于上一分块的pop掉，合并为一个分块\r\n                stack.pop()\r\n            }\r\n            // 合并之后的分块push回去\r\n            stack.push(temp)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```\r\n## 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191646702","body":"## 思路\r\n先遍历一遍链表，计算出链表的长度；移动k位，即遍历到第k个节点，其next节点为新的头节点；最后把尾节点的next指向链表原先的head\r\n\r\n## 代码\r\n```js\r\nvar rotateRight = function(head, k) {\r\n    if (!head) {\r\n        return head\r\n    }\r\n    let count = 0\r\n    let node = head\r\n    // 计算节点数\r\n    while (node.next) {\r\n        count++\r\n        node = node.next\r\n    }\r\n    count++\r\n    let tail = node\r\n    node = head\r\n    let newHead = null\r\n    // 需移动的位数\r\n    const moveStep = k % count\r\n    if (moveStep === 0) {\r\n        // 不需移动，直接返回\r\n        return head\r\n    }\r\n    while(count > moveStep) {\r\n        count--\r\n        if (count === moveStep) {\r\n            // 移动完后的节点为新头节点\r\n            newHead = node.next\r\n            node.next = null\r\n        } else {\r\n            node = node.next\r\n        }\r\n    }\r\n    tail.next = head\r\n    return newHead\r\n};\r\n```\r\n## 复杂度\r\n时间：O(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192649548","body":"## 代码\r\n```js\r\n */\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) {\r\n        return head\r\n    }\r\n    let pre = head.next\r\n    let next = head\r\n    let tmp = pre.next\r\n    head = head.next\r\n    while (next.next) {\r\n        // pre=2指向next=1, next再指向tmp=3的next=4,\r\n        // 然后重新赋值，新一轮重新指向\r\n        // console.log(pre, next, tmp)\r\n        pre.next = next\r\n        next.next = tmp ? (tmp.next || tmp) : null\r\n        if (tmp) {\r\n            pre = tmp.next\r\n            next = tmp\r\n            tmp = pre ? pre.next : null\r\n        }\r\n    }\r\n    return head\r\n};\r\n```\r\n## 复杂度\r\n时间：O(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193128560","body":"## 思路\r\n先遍历一遍，获取节点数；找到中间值作为根节点，中间节点的左边链表作为左子树，右边链表为右子树，递归\r\n\r\n## 代码\r\n```js\r\nvar sortedListToBST = function(head) {\r\n    let num = 0\r\n    let node = head\r\n    while (node) {\r\n        num++\r\n        node = node.next\r\n    }\r\n\r\n    const buildTree = (head, num) => {\r\n        // console.log(head, num)\r\n        if (!head) {\r\n            return head\r\n        }\r\n        if (!head.next) {\r\n            return new TreeNode(head.val)\r\n        }\r\n        let mid = (num >> 1) + 1\r\n        let midNode = null\r\n        let left = head\r\n        let right = head\r\n        let i = 1\r\n        \r\n        while (i < mid) {\r\n            let temp = right.next\r\n            if (i === mid - 1) {\r\n                temp = right.next.next\r\n                // 中间节点\r\n                midNode = new TreeNode(right.next.val)\r\n                // console.log(11, midNode)\r\n                // 到此为左边链表\r\n                right.next = null\r\n            }\r\n            right = temp\r\n            i++\r\n        }\r\n        // console.log(333, midNode, left, right,num, mid)\r\n        midNode.left = buildTree(left, mid - 1)\r\n        midNode.right = buildTree(right, num - mid)\r\n        return midNode\r\n    }\r\n    return buildTree(head, num)\r\n    \r\n};\r\n```\r\n## 复杂度\r\n时间：O(nlogn) - 每层树是n/2, logn层数\r\n空间：O(n) - 整棵树的节点n，应该是O(n)吧","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193324818","body":"## 思路\r\n看了官方答案，双指针\r\n\r\n## 代码\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    if (!headA || !headB) {\r\n        return null\r\n    }\r\n    // 双指针\r\n    let pA = headA\r\n    let pB = headB\r\n    while(pA !== pB) {\r\n        // 遍历两个链表\r\n        pA = pA === null ? headB : pA.next\r\n        pB = pB === null ? headA : pB.next\r\n    }\r\n    return pA\r\n};\r\n```\r\n## 复杂度\r\n时间：O(m + n) - 遍历链表A和链表B\r\n空间：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196891059","body":"## 代码\r\n```js\r\nvar maxDepth = function(root) {\r\n    let max = 0\r\n    const dfs = (node, path) => {\r\n        if (!node) {\r\n            return\r\n        }\r\n\r\n        path.push(node.val)\r\n        max = Math.max(max, path.length) // 保存最大的深度\r\n        dfs(node.left, path)\r\n        dfs(node.right, path)\r\n        path.pop() // 回溯\r\n    }\r\n    dfs(root, [])\r\n    return max\r\n};\r\n```\r\n## 复杂度\r\n时间：O(n) n-节点数\r\n空间：O(height)-树点高度，即递归需要使用的调用栈空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185660712","body":"## 思路\n这题如果用链表做可以通过使用addFirst这个方法来降低复杂度，参考了leetcode 讨论区java的solution。\n将k加上数组的每位，然后mod10，得到的值放在linkedlist里。\n然后将k /= 10后将这个值加到下一位。\n\n## 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> res = new LinkedList<>();\n        int len = num.length - 1;\n        while(len >= 0 || k != 0){\n            if(len >= 0)  k += num[len--];\n            res.addFirst(k % 10);\n            k = k /10;\n        }\n        \n        return res;\n    }\n}\n```\n\n## 复杂度\n时间复杂度： O(max(n, log10(k)))\n空间复杂度：O(max(n, log10(k)))\n\n时间复杂度不是数组的长度就是log10k，空间复杂度是因为我们需要开新的空间来把结果存到linkedlist里面。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186210190","body":"## 思路\n直接参考了力扣的最优解，用一个数组储存结果。\n最近的c的索引先设成无穷小。\n先从左边扫描一次数组比较每个index和最近的c的index的距离。然后存进数组对应的index。\n最近的c的索引设成无穷大。\n再从右边扫描一次数组比较每个index和最近的c的index的距离，然后与之前的数组的值比较，取小的那个。\n\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int prev = Integer.MIN_VALUE / 2;\n        int[] ans = new int[n];\n        for(int i = 0; i < n; i++) {\n            if(s.charAt(i) == c) prev = i;\n            ans[i] = i - prev;\n        }\n        \n        prev = Integer.MAX_VALUE / 2;\n        for(int i = n - 1; i >= 0; i--) {\n            if(s.charAt(i) == c) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度\n- 时间复杂度： O(N)\n因为就是遍历了两遍数组\n- 空间复杂度：O(N)\n创建了一个跟原来n一样长度的数组来储存结果。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186549032","body":"## 思路\n- 看了最佳题解的前缀和，但是不知道就是优化的代码是不是可以用java实现\n- 简单来说就是用一个increment数组来实现increment操作。\n- 如果increment了，且k < stack.size，那么increment[k]相当于要加的val。如果要pop了，那么这个inc[k-1]的地方会加上原来inc[k]的值。\n- push只要确认下边界没有超就行，\n\n## 代码\n\n```java\nclass CustomStack {\n    \n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n\n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack = new Stack<>();\n        \n    }\n    \n    public void push(int x) {\n        if(stack.size() < n)\n            stack.push(x);\n    }\n    \n    public int pop() {\n        int i = stack.size() - 1;\n        if(i < 0) return -1;\n        if(i > 0) inc[i - 1] += inc[i];\n        int res = stack.pop() + inc[i];\n        inc[i] = 0;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if(i >= 0)\n            inc[i] += val;\n    }\n}\n\n\n```\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186572599","body":"##思路\n- 就是利用栈的特性，先把所有字符都压入栈中，遇到\"]\"时说明找到匹配。这个时候先将[]内的string存到一个地方。\n在读完string后，开始读数字k，数字有可能不是1位，所以要用一个base和循环来读数字。\n最后将 k * string压回栈中。继续匹配。最终栈内的字符串因为是反着的（出栈的时候顺序相反），所以result记得反着将栈中所有字母弹出来。\n\n\n## 代码\n```code \nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        \n        \n        for(int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == ']'){\n                List<Character> decodedString = new ArrayList<>();\n                while(stack.peek() != '['){\n                    decodedString.add(stack.pop());\n                }\n                stack.pop();\n                int k = 0;\n                int base = 1;\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    k = k + (stack.pop() - '0') * base;\n                    base *= 10;\n                }\n                while(k != 0){\n                    for(int j = decodedString.size() - 1; j >= 0; j--){\n                        stack.push(decodedString.get(j));\n                    }\n                    k--;\n                }\n            }\n            else{\n                stack.push(s.charAt(i));\n            }\n        }\n       \n        char[] result = new char[stack.size()];\n        for(int i = result.length - 1; i >= 0; i--){\n            result[i] = stack.pop();\n        }\n        return new String(result);\n    }\n}\n```\n时间复杂度：O(maxK^(countK)⋅n).\n空间复杂度：O(sum(maxK^(countK) ⋅n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189224462","body":"## 思路\n用两个栈来实现队列，一个栈用来保存除了底部的所有数据。\n\n## 代码\n\n```java\nclass MyQueue {\n\n    Stack<Integer> input = new Stack();\n    Stack<Integer> output = new Stack();\n    \n    public void push(int x) {\n        input.push(x);\n    }\n\n    public int pop() {\n        peek();\n        return output.pop();\n    }\n\n    public int peek() {\n        if (output.empty())\n            while (!input.empty())\n                output.push(input.pop());\n        return output.peek();\n    }\n\n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n}\n\n```\n\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190461363","body":"## 思路\n用排序计数的方法找到最小块\n今天答案直接抄官方题解了\n\n\n## 代码\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        int nonzero = 0;\n        \n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n        \n        for(int i = 0; i < arr.length; ++i) {\n            int x = arr[i];\n            int y = expect[i];\n            \n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if(count.get(x) == 0){\n                nonzero--;\n            }\n            if(count.get(x) == 1){\n                nonzero++;\n            }\n            \n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if(count.get(y) == -1){\n                nonzero++;\n            }\n            if(count.get(y) == 0){\n                nonzero--;\n            }\n            if(nonzero == 0){\n                ans++;\n            }\n        }\n        \n        return ans;\n        \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191542246","body":"## 思路\n\n- 将链表连成环，然后断开处于n-k-1位置的指针\n    - 先遍历链表找到尾节点连着头\n    - 遍历找到n-k-1的位置，断开节点\n\n## 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        \n        if(head == null) return null;\n        if(head.next == null) return head;\n        \n        ListNode old_tail = head;\n        int length = 1;\n        while (old_tail.next != null) {\n            length++;\n            old_tail = old_tail.next;\n        }\n        k = k % length;\n        old_tail.next = head;\n        int i = 0;\n        ListNode new_tail = head;\n        while (i < length - k - 1){\n            new_tail = new_tail.next;\n            i++;\n        }\n        ListNode new_head = new_tail.next;\n        new_tail.next = null;\n        return new_head;\n    }\n}\n\n```\n\n时间复杂度：O(N)\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192708036","body":"# 思路\n今天直接抄了题解呜呜呜，先加一个伪节点，然后试着模拟一组节点rotate是什么情况，之后遍历所有节点。\n\n\n## 代码\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode preNode = new ListNode(-1, head);\n        ListNode res;\n        preNode.next = head;\n        res = head.next;\n        ListNode firstNode = head;\n        ListNode secondNode;\n        ListNode nextNode;\n        while(firstNode != null && firstNode.next != null) {\n            secondNode = firstNode.next;\n            nextNode = secondNode.next;\n            \n            firstNode.next = nextNode;\n            secondNode.next = firstNode;\n            preNode.next = secondNode;\n            \n            preNode = firstNode;\n            firstNode = nextNode;\n        }\n        return res;\n    }\n}\n\n```\n\n时间复杂度:O(n)\n空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193111916","body":"## 思路\n- 先通过快慢指针法找到node的中点，然后把它插入二叉树。\n- 之后递归实现这个函数\n\n\n## 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        return dfs(head, null);\n    }\n    \n    private TreeNode dfs(ListNode head, ListNode tail){\n        if(head == tail) return null;\n        ListNode fast = head, slow = head;\n        while(fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = dfs(head, slow);\n        root.right = dfs(slow.next, tail);\n        return root;\n    }\n}\n```\n\n时间复杂度：O(nlogn)\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193345783","body":"## 思路\n把链表A的所有节点都加入在哈希表，看链表B中有没有contain，如果没有就返回null。\n\n## 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> nodesInB = new HashSet<ListNode>();\n        \n        while(headB != null) {\n            nodesInB.add(headB);\n            headB = headB.next;\n        }\n        \n        while(headA != null) {\n            if(nodesInB.contains(headA)) {\n                return headA;\n            }\n            headA = headA.next;\n        }\n        \n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194239460","body":"## 思路\n用哈希遍历链表的所有节点，把他们加入哈希表，如果之前哈希表中有过一样的节点，那么这个节点就是环相交的节点，如果没有就继续遍历到队尾。\n如果不是环肯定会遍历结束。\n\n## 代码\n\n```Java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        Set<ListNode> visited = new HashSet<ListNode>();\n        while(pos != null) {\n            if(visited.contains(pos)){\n                return pos;\n            }else {\n                visited.add(pos);\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n}\n```\n\n## 复杂度\n 时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195665563","body":"## 思路\n\n用了双向链表和哈希表，因为用了哈希表所以get的复杂度是O(1)，用了双向链表就可以用O(1)改变头和尾。\n\n## 代码\n\n\n```Java\n\nclass LRUCache {\n    class DLinkedNode {\n        int key, value;\n        DLinkedNode prev, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //add dummy head and dummyTail\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //if key exist, move it to head by using its location store in Hashmap\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n```\n\n时间复杂度：O（1）\n空间复杂度：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196940392","body":"## 思路\n递归求二叉树深度\n\n## 代码\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n\n```\n\n## 复杂度\n时间复杂度：O(N)\n空间复杂度：O(h)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185661466","body":"### 思路\n\n最后一个元素开始遍历，遍历到最后一个元素若是索引到了尽头，而还有进位就依据 || k>0逻辑再次运算一遍\n维护一个相加数k\n并存储计算之后的结果\n最后返回结果数组\n### 代码\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n=num.length;\n        LinkedList<Integer> res=new LinkedList<>();\n        for(int i=n-1;i>-1|| k>0;i--){\n            if(i>-1 ){\n                k=k+num[i];\n            }\n            Integer r=k%10;\n            res.addFirst(r);\n            k=k/10;\n        }\n        return res;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度(Time)：O(N)\n- 空间复杂度(Space)：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225868","body":"## 思路\n先遍历字符，存下标\n再bfs\n## 代码\n```java\nclass Solution {\n    int[] dirs = new int[]{-1, 1};\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n\n        //填入-1 ，用于判断是否目标字符\n        Arrays.fill(res, -1);\n\n        Deque<Integer> d = new ArrayDeque<>();\n\n        //目标字符 入队，结果数组置为0\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                d.addLast(i);\n                res[i] = 0;\n            }\n        }\n        //bfs 遍历数据，从左到右，遍历目标字符下标\n        while (!d.isEmpty()) {\n            int t = d.pollFirst();\n            //前后搜索\n            for (int dir : dirs) {\n                //移动后下标\n                int index = t + dir;\n                //只处理非目标字符\n                if (index >= 0 && index < n && res[index] == -1) {\n                    //无论向哪个方向移动，距离都会加1\n                    res[index] = res[t] + 1;\n                    d.addLast(index);\n                }\n            }\n        }\n        return res;\n    }\n}\n\n```\n## 复杂度分析\n时间复杂度： O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186552368","body":"## 思路\r\n\r\n## 代码\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] arr;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != arr.length - 1) {\r\n            arr[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        return arr[--top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int m = Math.min(k, top + 1);\r\n        for (int i = 0; i < m; ++i) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187677968","body":"## 思路\r\n两个栈分别存 重复次数 和要重复的字符\r\n\r\n- 字符和数字分别赋值\r\n- 遇到 左括号 `[` 就存入栈，并清除字符临时存储变量值\r\n- 遇到右括号 `[`  就取出相应字符串，并循环拼接相应次数\r\n\r\n## 代码\r\n```java\r\n class Solution {\r\n    int mulN = 0;\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        LinkedList<Integer> muS = new LinkedList<>();\r\n        LinkedList<String> chS = new LinkedList<>();\r\n        for(char c : s.toCharArray()) {\r\n            //入栈 数字和字符\r\n            if(c == '[') {\r\n                muS.addLast(mulN);\r\n                chS.addLast(res.toString());\r\n                mulN = 0;\r\n                res = new StringBuilder();\r\n            }else if(c == ']') {\r\n                StringBuilder midT = new StringBuilder();\r\n                int n = muS.removeLast();\r\n                for(int i = 0; i < n; i++) {\r\n                    midT.append(res);\r\n                }\r\n                res = new StringBuilder(chS.removeLast() + midT);\r\n                //出栈\r\n            }else if(c >= '0' && c <= '9') {\r\n                //赋值数字\r\n                mulN = mulN * 10 + Integer.parseInt(c + \"\");\r\n            }else{\r\n                //赋值字符\r\n                 res.append(c);\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189235609","body":"```java\nclass MyQueue {\n\n     Stack<Integer> inStack;\n     Stack<Integer> outStack;\n    public MyQueue() {\n        inStack=new Stack<>();\n        outStack=new Stack<>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        moveToOut();\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        moveToOut();\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() &&outStack.isEmpty();\n    }\n\n    public void moveToOut(){\n        if(outStack.isEmpty()){\n                while(!inStack.isEmpty()){\n                    outStack.push(inStack.pop());\n                }\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191664970","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        int c = 0;\n        ListNode cur = head;\n        //计节点数\n        while(cur != null){\n            cur = cur.next;\n            c++;\n        }\n        //获取实际运动步数\n        k = k % c;\n        //快慢指针\n        ListNode s = head, f = head;\n        while(f.next != null){\n            //快指针先走k步 此处慢指针走了 c-k 步\n            if(k-- <= 0){\n                s = s.next;\n            }\n            f = f.next;\n        }\n        //连接成环\n        f.next = head;\n\n        //新链表首节点\n        ListNode res = s.next;\n        s.next = null;\n        return res;\n    }\n}\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192719833","body":"### 思路\r\n定义一个虚拟头节点，以此为基准进行一系列操作\r\n*  虚拟头节点，遍历\r\n*  需要之后有两个节点非空才能继续操作\r\n*  然后易虚拟头节点为前节点进行操作\r\n\r\n### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode du = new ListNode(0);\r\n        du.next = head;\r\n        ListNode temp = du;\r\n        while (temp.next != null && temp.next.next != null) {\r\n            ListNode cur = temp.next;\r\n            ListNode tnext = temp.next.next;\r\n            temp.next = tnext;\r\n            cur.next = tnext.next;\r\n            tnext.next = cur;\r\n            temp = cur;\r\n        }\r\n        return du.next;\r\n    }\r\n}\r\n```\r\n时间复杂度（TIME）O(n)\r\n空间复杂度（SPACE）O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193145072","body":"## 思路\n使用快慢指针找到中点\n然后以中点为中心创建平衡二叉树\n\n## 代码\n```java\nclass Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null){\n           return null;\n      }\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail){\n           return null;\n      }\n      ListNode fast = head;\n      ListNode slow = head;\n      //快慢指针找到中点\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      //中点为根节点创建平衡二叉树\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}\n```\n时间复杂度：O(nlogn)\n空间复杂度：O(nlogn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193346499","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA ==null || headB==null)return null;\n\n        ListNode pa=headA,pb=headB;\n\n        while(pa !=pb){\n            pa=pa==null ?headB:pa.next;\n            pb=pb==null ?headA:pb.next;\n        }\n        return pa;\n    }\n}\n\n```\nT:o(n)\ns:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194278417","body":"## 思路\r\n\r\n快慢指针，第一次相交后再重置快指针到head，再一起迭代，直到第二次相交\r\n\r\n## 代码\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head==null) return null;\r\n        ListNode f=head;\r\n        ListNode s=head;\r\n\r\n        while(f !=null){\r\n            s=s.next;\r\n            if(f.next!=null){\r\n                f=f.next.next;\r\n            }else{\r\n                return null;\r\n            }\r\n            \r\n            //指针交点处\r\n            if(f==s){\r\n\r\n                //重置快指针到head处，快慢指针同时移动一步迭代，直到再次相交\r\n                ListNode t=head;\r\n\r\n                while(t!= s){\r\n                    s=s.next;\r\n                    t=t.next;\r\n                }\r\n                return t;\r\n\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\nT:O(N)\r\nS:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195669776","body":"```java\nclass LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode pre, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //添加虚拟节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.pre = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //若k存在移动其到头节点 并存储\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //若不存在就创建\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.pre = head;\n        node.next = head.next;\n        head.next.pre = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.pre;\n        removeNode(res);\n        return res;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196898999","body":"\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        } else {\n            int l = maxDepth(root.left);\n            int r = maxDepth(root.right);\n            return Math.max(l, r) + 1;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185663624","body":"#  思路\r\n从后往前累加，有很多边界要处理，参考了官方题解\r\n# Code\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int len = num.length;\r\n        int sum;\r\n        for(int i = len - 1; i >= 0; i--){\r\n            sum = num[i] + k % 10;\r\n            k = k /10;\r\n            if(sum >= 10){\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n       for (; k > 0; k /= 10) {\r\n           res.add(k % 10);\r\n       }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186210463","body":"## 思路\r\n\r\n> + 暴力法，分别左右遍历取最小,看题解原来双向遍历就好了。。。\r\n\r\n##代码\r\n\r\n```java\r\n#代码\r\n\r\n```class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int j, k;\r\n        int res[] = new int[s.length()];\r\n        for(int i = 0; i < s.length(); i++){\r\n            j = i -1;\r\n            k = i + 1;\r\n            int minLen = Integer.MAX_VALUE;\r\n            if(s.charAt(i) == c){\r\n                res[i] = 0;\r\n            } else {\r\n                while(j >= 0 || k < s.length()){\r\n                    if(j >= 0 && s.charAt(j) == c){\r\n                        minLen = Math.min(minLen, i - j);\r\n                    }\r\n                    if(k < s.length() && s.charAt(k) == c){\r\n                        minLen = Math.min(minLen, k - i);\r\n                    }\r\n                    j--;\r\n                    k++;\r\n                }\r\n                res[i] = minLen;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n2)\r\n> + 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193128461","body":"# 思路\r\n  用快慢指针找到重点，然后递归 \r\n\r\n# 代码 \r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null){\r\n            return null;\r\n        }else if(head.next == null){\r\n            return new TreeNode(head.val);\r\n        }\r\n        //find mid\r\n        ListNode slowPtr = head, fastPtr = head;\r\n        ListNode pre = null;\r\n        while( fastPtr != null && fastPtr.next != null){\r\n            pre = slowPtr;\r\n            slowPtr = slowPtr.next;\r\n            fastPtr = fastPtr.next.next;\r\n        }\r\n\r\n        TreeNode root = new TreeNode(slowPtr.val);\r\n        pre.next = null;\r\n\r\n        //递归\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(slowPtr.next);\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185664303","body":"### 思路\r\n1. 将整数加到数组最后一位即个位，取余作为个位\r\n2. 加和结果的整除结果进位，加到数组下一位\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        n = len(num)\r\n        i = n - 1\r\n        while i >= 0 or k > 0:\r\n            if i >= 0:\r\n                k += num[i]\r\n            res.append(k % 10)\r\n            i -= 1\r\n            k //= 10\r\n        res.reverse()\r\n        return res\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(max(n, logk)，其中 n 为数组长度。（k有logk位数）\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186211008","body":"## 题目\r\n[821](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\nGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\r\n\r\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\r\n\r\n## 左右分别找\r\n### 思路\r\n?\r\n**_左边最近_**----从左往右遍历, 当找到字符时, 更新字符位置loc, 字符位置在遍历到的位置i左边, distance = i-loc\r\n**_右边最近_**----从右往左遍历, 字符位置loc在遍历到的位置i右边, distance = loc-i\r\n**_比大小_**----将更小的值存到结果里\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n =len(s)\r\n        res = [] \r\n\r\n        # 从左往右, 距离为i-loc\r\n        loc = - n # 若左边未找到c, 确保距离>=n\r\n        for i, ch in enumerate(s) :\r\n            if ch == c:\r\n                loc = i\r\n            res.append(i - loc)\r\n        \r\n        # 从右往左, 距离为loc-i\r\n        loc = 2*n # 若右边未找到c, 确保距离>=n\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                loc = i\r\n            res[i] = min(loc - i, res[i])\r\n        \r\n        return res\r\n```\r\n\r\n### 复杂度分析\r\n?\r\n- 时间复杂度：O(n)，其中 n 为数组长度。遍历两遍\r\n- 空间复杂度：O(1) \r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186552453","body":"### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.count = 0\n        self.size = maxSize\n        self.add = [0] * self.size\n\n    def push(self, x: int) -> None:\n        if self.size > self.count:\n            self.stack.append(x)\n            self.count += 1\n\n    def pop(self) -> int:\n        if self.count == 0: \n            return -1\n        if self.count >= 2:\n            self.add[self.count-2] += self.add[self.count-1]\n        res = self.stack[self.count - 1] + self.add[self.count - 1]\n        self.add[self.count - 1] = 0\n        self.count -= 1\n        return res\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.count: \n            self.add[min(k - 1, self.count - 1)] += val\n","onTime":false},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141840","body":"### 代码\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head):\r\n        def getMedian(left, right):\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        \r\n        def buildTree(left, right):\r\n            if left == right:\r\n                return None\r\n            mid = getMedian(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n        \r\n        return buildTree(head, None)\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185665340","body":"# 思路\n\n遍历数组，每次都让数组的最后一位和数字的个位求和，代码如下：\n\n- 时间复杂度O(N)，\n\n- 空间复杂度O(N)\n\n# 代码\n```Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        List<Integer> res = new ArrayList<>();\n        int i = A.length - 1, sum = 0, carry = 0;\n        // 循环遍历数组A，每次都将数组末尾和数字K的个位进行求和\n        while (i >= 0 || K != 0) {  \n            int x = i >= 0 ? A[i]: 0;\n            int y = K != 0 ? K % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            K /= 10;\n            i--;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186213449","body":"## 思路\n先统计字符串s中出现的c的位置存入一列表，再将字符串各位置与列表中值依次对比，比较得出最小的存入输出数组中。\n\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] chs = s.toCharArray();\n        int[] res = new int[chs.length];\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < chs.length; i++) {\n            if (chs[i] == c){\n                list.add(i);\n            }\n        }\n        for (int i = 0; i < chs.length; i++) {\n            int min = Integer.MAX_VALUE;\n            for (int j = 0; j < list.size(); j++) {\n                if (Math.abs(i - list.get(j)) < min) {\n                    min = Math.abs(i - list.get(j));\n                } \n            }\n            res[i] = min;\n        }\n        return res;\n    }\n}\n```\n## 复杂度\n- 时间复杂度O(N^2)\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186503503","body":"## 思路\n数组模拟栈，双数组，一个用于记录数据，一个用于记录增加的值。\n\n## 代码\n```java\nclass CustomStack {\n        int maxSize;\n        int size;\n        int[] data;\n        int[] inc;\n        public CustomStack(int maxSize) {\n            this.maxSize=maxSize;\n            data=new int[maxSize];\n            inc=new int[maxSize];\n        }\n\n        public void push(int x) {\n            if(size<maxSize){\n                data[size++]=x;\n            }\n        }\n\n        public int pop() {\n            if(size==0) return -1;\n            int res=data[size-1]+inc[size-1];\n            if(size>1){\n                inc[size-2]+=inc[size-1];\n            }\n            inc[size-1]=0;\n            size--;\n            return res;\n        }\n\n        public void increment(int k, int val) {\n            int min=Math.min(k,size);\n            if(min>0)\n                inc[min-1]+=val;\n        }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189198055","body":"## 思路\n\n模拟题\n\n队列-先进先出，栈-先进后出，因此，需要用到两个栈模拟队列\n\n## 代码\n```java\nclass MyQueue {\n\n    Stack<Integer> stack_in;\n    Stack<Integer> stack_out;\n\n    public MyQueue() {\n        stack_in = new Stack<>();\n        stack_out =  new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack_in.push(x);\n    }\n    \n    public int pop() {\n        check_stack_in();\n        return stack_out.pop();\n    }\n    \n    public int peek() {\n        check_stack_in();\n        return stack_out.peek();\n    }\n    \n    public boolean empty() {\n        return stack_in.isEmpty() && stack_out.isEmpty();\n    }\n\n    public void check_stack_in() {\n        if (!stack_out.isEmpty()) {\n            return;\n        }\n        while (!stack_in.isEmpty()) {\n            stack_out.push(stack_in.pop());\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190412380","body":"## 思路\n采用栈操作，可以发现升序的递增特征，每部分构成递增。首先遍历原数组，栈空直接存入栈中，\n- 栈head > 数组当前值，直接pop出栈，直到 >= 栈head项出现；\n- 栈head <= 数组当前值，入栈；\n最后返回栈的大小即为最大块数。\n\n## 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        // 栈方法\n        // 判断栈中数据\n        Stack<Integer> stack = new Stack<>();\n        for (int num : arr) {\n            if (!stack.isEmpty() && num < stack.peek()) {\n                int head = stack.pop();\n                while (!stack.isEmpty() && num < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(head);\n            } else {\n                stack.push(num);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n## 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191556366","body":"## 思路\n首先遍历链表，得到尾节点和链表长度，再k%length求得旋转后的起始位置，最后拼接链表。\n\n## 代码\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k == 0) return head;\n        int listnodeLength = 0;\n        // 遍历链表\n        ListNode tail = null;\n        for (ListNode p = head; p != null; p = p.next) {\n            tail = p;\n            listnodeLength++;\n        }\n        // 找旋转后的头节点\n        k %= listnodeLength;\n        ListNode p = head;\n        for (int i = 0; i < listnodeLength - k - 1; i++) {\n            p = p.next;\n        }\n        // 将链表的后k个节点和n-k个节点拼接\n        tail.next = head;\n        head = p.next;\n        p.next = null;\n        return head;\n    }\n}\n```\n## 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192529068","body":"## 思路\n递归法交换两两节点，每次将当前头节点的下一个和下下个节点进行交换；\n\n## 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n\n        ListNode subResult = swapPairs(head.next.next);\n        ListNode headNext = head.next;\n        headNext.next = head;\n        head.next = subResult;\n        return headNext;\n    }\n}\n```\n\n## 复杂度\n- 时间复杂度：O(1)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193139608","body":"## 思路\n双指针 + 递归\n\n## 代码\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildBST(head, null);\n    }\n\n    private TreeNode buildBST(ListNode head, ListNode stopNode) {\n        if (head == stopNode){\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != stopNode && fast.next != stopNode){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return new TreeNode(slow.val, buildBST(head, slow), buildBST(slow.next, stopNode));\n    }\n\n\n    public TreeNode sortedListToBST1(ListNode head) {\n        if (head == null){\n            return null;\n        }\n\n        if (head.next == null){\n            return new TreeNode(head.val);\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode slowPre = slow;\n        while (fast != null && fast.next != null){\n            slowPre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        slowPre.next = null;\n        return new TreeNode(slow.val, sortedListToBST(head), sortedListToBST(slow.next));\n    }\n}\n```\n## 复杂度\n- 时间复杂度 ：O(NlogN)\n- 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193341807","body":"## 思路\n遍历A链表，存在Set中，再遍历B链表，若Set中存在，则返回该节点，否则不相交。\n## 代码\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<ListNode>();\n        ListNode temp = headA;\n        while (temp != null) {\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while (temp != null) {\n            if (visited.contains(temp)) {\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n```\n## 复杂度\n- 时间复杂度O(m+n)\n- 空间复杂度O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194187435","body":"## 思路\n快慢指针判断环形链表，在通过相遇获得入口\n\n## 代码\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                ListNode index1 = fast;\n                ListNode index2 = head;\n                \n                while (index1 != index2) {\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n        return null;\n    }\n}\n```\n## 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195625761","body":"## 代码\n```java\nclass LRUCache {\n    int cap;\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\n    public LRUCache(int capacity) { \n        this.cap = capacity;\n    }\n\n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1;\n        }\n        makeRecently(key);\n        return cache.get(key);\n    }\n    \n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            cache.put(key, value);\n            makeRecently(key);\n            return;\n        }\n        if (cache.size() >= this.cap) {\n            int oldKey = cache.keySet().iterator().next();\n            cache.remove(oldKey);\n        }\n        cache.put(key, value);\n    }\n\n    private void makeRecently(int key) {\n        int value = cache.get(key);\n        cache.remove(key);\n        cache.put(key, value);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196928125","body":"## 代码\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        // 节点为空，高度为 0\n        if(root == null){\n            return 0;\n        }\n        // 递归计算左子树的最大深度\n        int leftHeight = maxDepth(root.left);\n        // 递归计算右子树的最大深度\n        int rightHeight = maxDepth(root.right);\n        // 二叉树的最大深度 = 子树的最大深度 + 1（1 是根节点）\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185667597","body":"### 思路\n参考了做的，倒着取取每个位数相加，单独考虑进位（没太看懂那种三个放在一起加的）\n\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        \n        for i in range(len(num)-1, -1, -1):\n            all = num[i] + k % 10\n            k = k // 10\n            if all >= 10:\n                k = k + 1\n            ans.append(all % 10)\n            \n        while k > 0:\n            ans.append(k % 10)\n            k = k // 10\n        return ans[::-1]\n```\n### 复杂度\n时间复杂度: O(n)\n\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185667727","body":"## 思路\r\n倒叙无脑加整数k\r\n## 代码\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = 0\r\n        length = len(num)\r\n        carry = k\r\n        while(carry>0):\r\n            if i < length:\r\n                sum = num[-i-1] + carry\r\n                num[-i-1] = sum % 10\r\n                carry = sum // 10\r\n            else:\r\n                num = [carry%10] + num\r\n                carry = carry // 10\r\n            i+=1\r\n        return num\r\n```\r\n### 时间复杂度: O(n)\r\n### 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186197767","body":"```python3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = r = 0\r\n        n = len(s)\r\n        res = [n] * n\r\n        flag = False  \r\n        while r <= n - 1:\r\n            if s[r] == c:\r\n                res[r] = 0\r\n                while l <= r:\r\n                    res[l] = min(res[l], r - l)\r\n                    l += 1\r\n                r += 1\r\n                flag = True\r\n            else:\r\n                if flag:\r\n                    res[r] = res[r-1] + 1\r\n                r += 1\r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531817","body":"```python3\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.len = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.maxSize:\r\n            self.stack.append(x)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.len == 0:\r\n            return -1\r\n        else:\r\n            self.len -= 1\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(k):\r\n            if i < self.len:\r\n                self.stack[i] += val\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187567839","body":"```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        \r\n        stack, res = [], \"\"\r\n        \r\n        for i in s:\r\n            if i != \"]\":\r\n                stack.append(i)\r\n\r\n            else:\r\n                word = stack.pop()\r\n                words = \"\"\r\n                while word != \"[\":\r\n                    words = word+words\r\n                    word = stack.pop()\r\n                \r\n                multi = stack.pop()\r\n                multi_times = \"\"\r\n                while multi.isnumeric():\r\n                    multi_times = multi + multi_times\r\n                    print(multi_times)\r\n                    if stack and stack[-1].isnumeric(): multi = stack.pop()\r\n                    else: break\r\n\r\n                stack.append(words*int(multi_times))\r\n        \r\n        \r\n        for i in stack: res += i\r\n        return(res)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188968558","body":"```python3\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.L = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.L.append(x)\r\n\r\n    def pop(self) -> int:\r\n        print(self.L)\r\n        return self.L.pop(0)\r\n\r\n    def peek(self) -> int:\r\n        return self.L[0]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if(len(self.L) == 0):\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191134572","body":"### 思想\r\n链表成环\r\n\r\n```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        tail = head\r\n        if not head or not head.next:\r\n            return head\r\n        count = 1\r\n\r\n        while(tail.next):\r\n            tail = tail.next\r\n            count += 1\r\n    \r\n        if k % count == 0:\r\n            return head\r\n\r\n        #首尾相连\r\n        tail.next = head\r\n        k %= count\r\n        for i in range(count - k):\r\n            tail = tail.next\r\n        head = tail.next\r\n        tail.next = None\r\n        return head\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192095418","body":"```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        newNode = head.next\r\n        head.next = self.swapPairs(newNode.next)\r\n        newNode.next = head\r\n        return newNode\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193135979","body":"### 思想\r\n快慢指针\r\n\r\n```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        fast = head\r\n        slow = head\r\n        pre = head\r\n\r\n        if not head:\r\n            return head\r\n        while(fast and fast.next):\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        root = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return root\r\n        pre.next = None\r\n        next_head = slow.next\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(next_head)\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193284391","body":"```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        \r\n        pointA,pointB = headA,headB\r\n        \r\n        while pointA != pointB:\r\n            if pointA != None:\r\n                pointA = pointA.next\r\n            else:\r\n                pointA = headB\r\n            if pointB != None:\r\n                pointB = pointB.next\r\n            else:\r\n                pointB = headA\r\n        \r\n        return pointA\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194119303","body":"### 思路\r\n快慢指针\r\n\r\n```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast,slow = head,head\r\n\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                p = head\r\n                q = fast\r\n                while p != q:\r\n                    p = p.next\r\n                    q = q.next\r\n                return p\r\n        return None\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195389537","body":"```python3\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.dic = {}\r\n        self.stack = []\r\n        self.capacity = capacity\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.dic:\r\n            if self.stack:\r\n                self.stack.remove(key)\r\n                self.stack.append(key)\r\n            return self.dic[key]\r\n        else: \r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.dic: \r\n            self.dic[key] = value\r\n            if self.stack:\r\n                self.stack.remove(key)\r\n                self.stack.append(key)\r\n            return \r\n        if len(self.dic) == self.capacity:\r\n            t = self.stack[0]\r\n            self.dic.pop(t)\r\n            self.stack = self.stack[1:]\r\n            self.dic[key] = value\r\n            self.stack.append(key)\r\n        else:\r\n            self.dic[key] = value\r\n            self.stack.append(key)\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185668901","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        l = len(num)\r\n        list_num = 0\r\n        for i in range(l):\r\n            list_num = list_num + num[i]*10^(l-(i-1))\r\n            print(num[i]*10^(l-(i-1)))\r\n        list2_num = list_num + k\r\n        str1 = str(list2_num)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186216337","body":"### Code\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        l = len(s)\n        cIndex = []\n        for i in range(l):\n            if s[i] == c:\n                cIndex.append(i)\n        lenlist = [[] for i in range(l)]\n        for index, j in enumerate(s):\n            if j == c:\n                lenlist[index] = 0\n            else:\n                short = l\n                for k in range(len(cIndex)):\n                    short = min(short, abs(index-cIndex[k]))\n                lenlist[index] = short\n        return lenlist\n\n```\n### 复杂度\n- 时间：O(l*k), l是s的长度，k是c的出现的次数\n- 空间：O(l)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186549624","body":"### 思路\r\nincrement并不提前造好maxSize长度，而是根当前栈长度同步增加长度，省一点空间。\r\n\r\n### Code\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.size = 0\r\n        self.incrementals = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        if(self.size < self.maxSize):\r\n            self.stack.append(x)\r\n            self.incrementals.append(0)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if(self.size == 0):\r\n            return -1\r\n        self.size -= 1\r\n        if(self.size >= 1):\r\n            self.incrementals[-2] += self.incrementals[-1]\r\n        return self.stack.pop() + self.incrementals.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.incrementals:\r\n            self.incrementals[min(k, self.size) - 1] += val\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：均为O(1)\r\n- 空间复杂度：O(size)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187659729","body":"### 思路\n这个解码中涉及到了 [[]]中括号嵌套，正好可以利用栈中先进后出，后进先出的特点。\n### Code\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        l = len(s)\n        stack,res,multi = [],\"\",0\n        for c in s:\n            if c == '[':\n                stack.append([res,multi])\n                res,multi = \"\",0\n            elif c == ']':\n                last_res,cur_multi = stack.pop()\n                res = last_res + cur_multi*res\n            elif '0' <= c <= '9':\n                multi = multi*10 + int(c)\n            else:\n                res += c\n        return res\n```\n### 复杂度\n- 时间：O(n)\n- 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189217061","body":"### Code\n```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190459002","body":"### Code\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            # 递增栈\r\n            if not stack or stack[-1] <= num:\r\n                stack.append(num)\r\n            else:\r\n                cur_max = stack.pop()\r\n                while stack and stack[-1] > num:\r\n                    stack.pop()\r\n                stack.append(cur_max)\r\n        return len(stack)\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191640245","body":"### Code\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head, k):\r\n        if not head or not head.next: return head\r\n        # 求链表长度\r\n        _len = 0\r\n        cur = head\r\n        while cur:\r\n            _len += 1\r\n            cur = cur.next\r\n        # 对长度取模\r\n        k %= _len\r\n        if k == 0: return head\r\n        # 让 fast 先向后走 k 步\r\n        fast, slow = head, head\r\n        while k:\r\n            fast = fast.next\r\n            k -= 1\r\n        # 此时 slow 和 fast 之间的距离是 k；fast 指向第 k+1 个节点\r\n        # 当 fast.next 为空时，fast 指向链表最后一个节点，slow 指向倒数第 k + 1 个节点\r\n        while fast.next:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        # newHead 是倒数第 k 个节点，即新链表的头\r\n        newHead = slow.next\r\n        # 让倒数第 k + 1 个节点 和 倒数第 k 个节点断开\r\n        slow.next = None\r\n        # 让最后一个节点指向原始链表的头\r\n        fast.next = head\r\n        return newHead\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192794192","body":"### Code\r\n```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        thead = ListNode(-1)\r\n        thead.next = head\r\n        c = thead\r\n        while c.next and c.next.next:\r\n            a, b=c.next, c.next.next\r\n            c.next, a.next = b, b.next\r\n            b.next = a\r\n            c = c.next.next\r\n        return thead.next\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1196931086","body":"### Code\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def findmid(head, tail):\r\n            slow = head\r\n            fast = head\r\n            while fast != tail and fast.next!= tail :\r\n                slow = slow.next\r\n                fast = fast.next.next\r\n            return slow\r\n        \r\n        def helper(head, tail):\r\n            if  head == tail: return \r\n            node = findmid(head, tail)\r\n            root = TreeNode(node.val)\r\n            root.left = helper(head, node)\r\n            root.right = helper(node.next, tail)\r\n            return root\r\n            \r\n        return helper(head, None)\r\n            \r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1196935783","body":"### Code \r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A, B = headA, headB\r\n        while A != B:\r\n            A = A.next if A else headB\r\n            B = B.next if B else headA\r\n        return A\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1196939806","body":"### Code\r\n```\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1196942499","body":"### Code\r\n```\r\nclass ListNode:\r\n    def __init__(self, key=None, value=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        # 新建两个节点 head 和 tail\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        # 初始化链表为 head <-> tail\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法\r\n    def move_node_to_tail(self, key):\r\n            # 先将哈希表key指向的节点拎出来，为了简洁起名node\r\n            #      hashmap[key]                               hashmap[key]\r\n            #           |                                          |\r\n            #           V              -->                         V\r\n            # prev <-> node <-> next         pre <-> next   ...   node\r\n            node = self.hashmap[key]\r\n            node.prev.next = node.next\r\n            node.next.prev = node.prev\r\n            # 之后将node插入到尾节点前\r\n            #                 hashmap[key]                 hashmap[key]\r\n            #                      |                            |\r\n            #                      V        -->                 V\r\n            # prev <-> tail  ...  node                prev <-> node <-> tail\r\n            node.prev = self.tail.prev\r\n            node.next = self.tail\r\n            self.tail.prev.next = node\r\n            self.tail.prev = node\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.hashmap:\r\n            # 如果已经在链表中了久把它移到末尾（变成最新访问的）\r\n            self.move_node_to_tail(key)\r\n        res = self.hashmap.get(key, -1)\r\n        if res == -1:\r\n            return res\r\n        else:\r\n            return res.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\r\n            # 但是需要更新字典该值对应节点的value\r\n            self.hashmap[key].value = value\r\n            # 之后将该节点移到末尾\r\n            self.move_node_to_tail(key)\r\n        else:\r\n            if len(self.hashmap) == self.capacity:\r\n                # 去掉哈希表对应项\r\n                self.hashmap.pop(self.head.next.key)\r\n                # 去掉最久没有被访问过的节点，即头节点之后的节点\r\n                self.head.next = self.head.next.next\r\n                self.head.next.prev = self.head\r\n            # 如果不在的话就插入到尾节点前\r\n            new = ListNode(key, value)\r\n            self.hashmap[key] = new\r\n            new.prev = self.tail.prev\r\n            new.next = self.tail\r\n            self.tail.prev.next = new\r\n            self.tail.prev = new\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196927093","body":"### Code\r\n```\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        # 节点为空，高度为 0\r\n        if root == None:\r\n            return 0\r\n\r\n        # 递归计算左子树的最大深度\r\n        leftHeight = self.maxDepth(root.left)\r\n        # 递归计算右子树的最大深度\r\n        rightHeight = self.maxDepth(root.right)\r\n\r\n        # 二叉树的最大深度 = 子树的最大深度 + 1（1 是根节点）\r\n        return max(leftHeight, rightHeight) + 1\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185673058","body":"# 思路\n\n写了一下，提交不对，应该是数据溢出了，直接变为两个数相加的办法不太行\n考虑一种做法，将其变为 num 数组中的元素依次与 k 相加，第一步先末位与 k 相加，结果对 10 取余与下一位相加，当前位置保留对 10 取余\n最后考虑是否有溢出位，然后添加到 0 位置上\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186212302","body":"# 数组的遍历\n根据题意，单词中任一字符与目标字符 target 距离的最小值必然为其与前 1 个 target 和后一个 target 中较小的存在  \n因此通过简化题意，可以前后各遍历一次求解  \n第一次从左至右，目标是找到距离左边 target 的最小距离\n第二次从右至左，目标是找到距离右边 target 的最小距离\n\n代码如下：\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] dist = new int[len];\n        Arrays.fill(dist, len+1);\n        for(int i=0, j=-1; i<len; ++i){\n            if(s.charAt(i)==c) j=i;\n            if(j!=-1) dist[i]= i-j;\n        }\n        for(int i=len-1, j=-1; i>=0; i--){\n            if(s.charAt(i)==c) j=i;\n            if(j!=-1) dist[i] = Math.min(dist[i], j-i);\n        }\n        return dist;\n    }\n}\n```\n时间复杂度：遍历两次数组，故为 O(N) \n空间复杂度：辅助空间使用数组长度为单词长度，故为 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186541483","body":"简单模拟题，选择用 List 来实现，其实用数组应该也一样，做长度判断即可\n```java\nclass CustomStack {\n\n    int maxSize;\n    List<Integer> stack = new ArrayList<>();\n    public CustomStack(int _maxSize) {\n        maxSize = _maxSize;\n    }\n    \n    public void push(int x) {\n        if(stack.size()==maxSize) return;\n        stack.add(x);\n    }\n    \n    public int pop() {\n        if(stack.size()==0) return -1;\n        int res = stack.get(stack.size()-1);\n        stack.remove(stack.size()-1);\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int n = k>stack.size()?stack.size():k;\n        for(int i=0; i<n; ++i)\n            stack.set(i, stack.get(i)+val);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187637907","body":"使用两个栈，一个记录数字，一个记录字符\n当检测到\"[\"时，将数字入栈\n当检测到“]”时，将数字出栈，并与当前记录的 str 进行组合追加即可\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                // 合理的字符串前必然是数字，因此此处将数字入栈\n                stack_multi.addLast(multi);\n                // 将之前的字符入栈存储\n                stack_res.addLast(res.toString());\n                // 重新记录\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                // 字符串结束，需要根据数字栈和 res 组合成结果\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                // 将字符追加\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            // 判断数字部分\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189180325","body":"思路：类似两个竹筒倒豆子，新来的加入到stack1里，想取第一个就把stack1的倒进stack2里，就可以取到第一个，然后放回去\n```java\nclass MyQueue {\n\n    Stack q1, q2;\n\n    public MyQueue() {\n        q1 = new Stack();\n        q2 = new Stack();\n    }\n    \n    public void push(int x) {\n        q1.push(x);\n    }\n    \n    public int pop() {\n        while(!q1.empty())\n            q2.push(q1.pop());\n        int res = (int)q2.pop();\n        while(!q2.empty())\n            q1.push(q2.pop());\n        return res;\n    }\n    \n    public int peek() {\n        while(!q1.empty())\n            q2.push(q1.pop());\n        int res = (int)q2.peek();\n        while(!q2.empty())\n            q1.push(q2.pop());\n        return res;\n    }\n    \n    public boolean empty() {\n        return q1.empty();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190443684","body":"自己没做出来，看了题解理解了\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191602282","body":"偷懒写了个笨方法，没去动链表，把数字依次往后移动了\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        int cnt = 0;\n        ListNode cur = head;\n        List<Integer> nums = new ArrayList<>();\n        while(cur!=null){\n            cnt++;\n            nums.add(cur.val);\n            cur = cur.next;\n        }\n        if(cnt==0||k==0) return head;\n        int move = k % cnt;\n        for(int i=0; i<move; ++i){\n            int temp = nums.get(cnt-1);\n            nums.remove(cnt-1);\n            nums.add(0, temp);\n        }\n        ListNode pre = new ListNode(0, head);\n        for(int i=0; i<cnt; ++i){\n            head.val = nums.get(i);\n            head = head.next;\n        }\n\n        return pre.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192673247","body":"画一个辅助图，其实很好理解的\n```java\nclass Solution {\n    public static ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n        ListNode newHead = new ListNode(0);\n        newHead.next = head;\n        ListNode pre = newHead;\n        ListNode mid = head;\n        ListNode end = head.next;\n        while (mid != null && end != null) {\n            // 改变节点连接关系\n            pre.next = end;\n            mid.next = end.next;\n            end.next = mid;\n\n            // 准备下一轮\n            pre = mid;\n            mid = (mid.next != null) ? mid.next : null;\n            end = (mid != null && mid.next != null) ? mid.next : null;\n        }\n        return newHead.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193145266","body":"```java\nclass Solution {\n    private ListNode inOrderNode = null;\n    public TreeNode sortedListToBST(ListNode head) {\n        //解题思路：升序链表是中序遍历的结果；中序是左根右，题目要求平衡二叉树，那么根节点要选择中间位置；\n        inOrderNode = head;\n        int n = 0;\n        while(inOrderNode != null){\n            inOrderNode = inOrderNode.next;\n            n++;\n        }\n        inOrderNode = head;\n        return toBst(0, n - 1);\n    }\n\n    private TreeNode toBst(int start, int end){\n        if(start > end){\n            return null;\n        }\n        //找到根节点为止\n        int mid = (start + end)>>1;\n        TreeNode root = new TreeNode();\n        //左子树\n        root.left = toBst(start, mid - 1);\n        //中序遍历，根节点值填充当前链表值\n        root.val = inOrderNode.val;\n        inOrderNode = inOrderNode.next;\n        //右子树\n        root.right = toBst(mid + 1, end);\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193346142","body":"使用了最简单的方法\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<ListNode>();\n        ListNode temp = headA;\n        while (temp != null) {\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while (temp != null) {\n            if (visited.contains(temp)) {\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194188246","body":"```java\npublic class Solution {\n    /*\n     *  剑指offer里面的经典题目，定义两个指针，一快一慢，快指针每次走2步，慢指针每次走1步\n     *  如果存在环，则两指针必然相遇，困难点在于证明环的存在后，如何求解环的入口\n     */\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast!=null && fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast){\n                ListNode l1 = head;\n                ListNode l2 = slow;\n                while(l1!=l2){\n                    l1 = l1.next;\n                    l2 = l2.next;\n                }\n                return l2;\n            }\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195652555","body":"O(1)时间复杂度的暂时做不出来，先写一个复杂的提交，后续在过O（1）的\n```java\nclass LRUCache {\n    int capacity;\n    int cur;\n    Map<Integer, Integer> map;\n    List<Integer> list;\n    public LRUCache(int _capacity) {\n        // 使用HashMap来记录键值对，使用List来记录使用频率\n        capacity = _capacity;\n        cur = 0;\n        map = new HashMap<>();\n        list = new ArrayList<>();\n    }\n    \n    public int get(int key) {\n        int value = map.getOrDefault(key, -1);\n        if(value != -1){\n            for(int i=0; i<list.size(); ++i){\n                // 若被使用则更新位置到后面\n                if(list.get(i)==value){\n                    list.remove(i);\n                    list.add(value);\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n    \n    public void put(int key, int value) {\n        // 若缓存已满\n        if(cur>=capacity){\n            // 删除list中的第一个元素，及其对应的键值对\n            map.remove(list.get(0));\n            list.remove(0);\n        }else{\n            cur++;\n        }\n        if(!map.containsKey(key))\n            list.add(key);\n        map.put(key, value);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196904678","body":"```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null)\n            return 0;\n        int left = 1 + maxDepth(root.left);\n        int right = 1 + maxDepth(root.right);\n        \n        return Math.max(left, right);\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185673085","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> tmp;\n        while(k){\n            tmp.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(num.begin(), num.end());\n        vector<int> res;\n        int t = 0;\n        int i = 0, j = 0;\n        for(; i < num.size() && j < tmp.size(); i++, j++){\n            res.push_back((num[i] + tmp[j] + t) % 10);\n            t = (num[i] + tmp[j] + t) / 10;\n        }\n        while(i < num.size()){\n            res.push_back((num[i] + t) % 10);\n            t = (num[i] + t) / 10;\n            i++;\n        }\n        while(j < tmp.size()){\n            res.push_back((tmp[j] + t) % 10);\n            t = (tmp[j] + t) / 10;\n            j++;\n        }\n        if(1 == t){\n            res.push_back(t);\n        }\n        int n = res.size() - 1;\n        while(0 == res[n--]){\n            res.pop_back();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185673838","body":"## 思路\r\n从低位到高位相加， 利用carry进位\r\n\r\n## 代码\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        carry = 0\r\n        for i in range(len(num) - 1, -1, -1):\r\n            num[i], carry = (carry + num[i] + k % 10) % 10, (carry + num[i] + k % 10) // 10\r\n            k //= 10\r\n        B = []\r\n        carry = carry + k\r\n        while carry:\r\n            B = [(carry) % 10] + B\r\n            carry //= 10\r\n        return B + num\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度： O(n)\r\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186224694","body":"## 思路\n贪心算法：先从左往右，再从右往左，最后计算最短距离。\n\n## 代码\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res\n```\n\n## 复杂度分析\n时间：O(n)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186358345","body":"## 思路\n第一反应是直观实现，看了题解发现可以用前缀和实现\n## 代码\n``` python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.max = maxSize\n        self.stack = []\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.max:\n            self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(len(self.stack),k)):\n            self.stack[i] += val\n```\n\n## 复杂度分析\n时间：O(1)\n空间：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186593772","body":"## 思路\n\n利用stack实现，'['出发入栈。\n\n## 代码\n```python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for i in s:\n            if i == ']':\n                strs = ''\n                repeat = ''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop() + repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n```\n\n##  复杂度分析\n时间：O(n)\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189200907","body":"## 思路\n一个inStack 一个outStack。input把数据push到outStack。延展阅读好评，知道了使用场景。\n\n## 代码\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.inStack = []\n        self.outStack = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.inStack.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.outStack:\n          while self.inStack:\n              self.outStack.append(self.inStack.pop())\n\n        return self.outStack.pop()\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.inStack:\n            return self.inStack[0]\n        else:\n            return self.outStack[-1]\n\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if not self.inStack and not self.outStack:\n            return True\n        else:\n            return False\n```\n\n## 复杂度分析\n时间：O(n)\n空间：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194165004","body":"## 思路\n快慢指针\n\n## 代码\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast=head\n        slow=head\n        while True:\n            if not fast or not fast.next:\n                return None\n            fast=fast.next.next\n            slow=slow.next\n            if slow==fast:\n                break\n        fast=head\n        while fast!=slow:\n            fast=fast.next\n            slow=slow.next\n        return slow\n```\n\n## 复杂度分析\n时间复杂度： O(N)\n空间复杂度： O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185674070","body":"```typescript\nfunction addToArrayForm(num: number[], k: number): number[] {\n\n    let pow = 0;\n    let val = 0;\n    let result = []\n\n    for(let i = num.length-1; i >= 0; i++){\n        val += num[i] * Math.pow(10,pow);\n    }\n\n    val+=k;\n    \n    for(let i = 0; i < num.length -1; i++){\n        result.push(val / (Math.pow(10, num.length)));\n        num.shift();\n    }\n\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186212745","body":"```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n\n  let cSet = new Set();\n  let result: number[] = [];\n\n  for (let index = 0; index < s.length; index++) {\n    const str = s[index];\n    if (str === c) {\n      cSet.add(index);\n    }\n  }\n\n  for (let index = 0; index < s.length; index++) {\n    let position = s.length;\n    cSet.forEach((ind) => {\n      if (Math.abs(Number(ind)-index) < position) {\n        position = Math.abs(Number(ind)-index);\n      }\n    })\n    result.push(position);\n  }\n\n  return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186543378","body":"```typescript\nclass CustomStack {\n    customStack: number[] = [];\n    maxSize: number;\n    constructor(maxSize: number) {\n        this.maxSize = maxSize;\n    }\n\n    push(x: number): void {\n        const len = this.customStack.length;\n        if(len < this.maxSize){\n            this.customStack[len] = x;\n        }\n    }\n\n    pop(): number {\n        const len = this.customStack.length;\n        if(len > 0){\n            const lastOne = this.customStack[len-1];\n            delete this.customStack[len-1];\n            this.customStack.length--;\n            return lastOne;\n        }\n        return -1;\n    }\n\n    increment(k: number, val: number): void {\n        if(this.customStack.length < k){\n            k = this.customStack.length;\n        }\n        for(let i = 0; i < k ; i++){\n            this.customStack[i]+=val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187653669","body":"```typescript\nvar decodeString = function (s) {\n    let s_array = s.split('');\n\n    if (isNaN(Number(s_array[0]))) {\n        s_array.unshift('[');\n        s_array.unshift('1');\n        s_array.push(']')\n    }\n\n    return strdecode(s_array, 1);\n\n};\n\nfunction strdecode(k, repeat) {\n    let str_val = '';\n    let result_val = '';\n    let number_str = Number(k.shift());\n    let k_value = k.shift();\n\n    if (k.length === 0) {\n        return;\n    }\n\n    while (isNaN(k_value)) {\n        str_val += k_value;\n        k_value = k.shift();\n    }\n    if (!isNaN(k_value)) {\n        k.unshift(k_value);\n    }\n\n    for (let index = 0; index < repeat; index++) {\n        result_val += str_val;\n    }\n\n    return result_val + strdecode(k, k_value);\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189134913","body":"```typescript\nclass MyQueue {\n    stack: number[] = [];\n    mockQueue: number[] = [];\n    constructor() {\n    }\n\n    push(x: number): void {\n        this.stack.push(x);\n    }\n\n    pop(): number {\n        if (this.mockQueue.length === 0) {\n            while(this.stack.length>0){\n                this.mockQueue.push(this.stack.pop()!);\n            }\n        }\n        return this.mockQueue.pop()!;\n    }\n\n    peek(): number {\n        if (this.mockQueue.length === 0) {\n            while(this.stack.length>0){\n                this.mockQueue.push(this.stack.pop()!);\n            }\n        }\n        return this.mockQueue[this.mockQueue.length-1];\n    }\n\n    empty(): boolean {\n        return this.stack.length === 0 && this.mockQueue.length ===0\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191616812","body":"```typescript\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n\n    if(!head)   {return head}\n    let len: number = 1;\n    let tail: ListNode = head;\n    let count: number = 0;\n    let previous = head;\n    \n    while(tail.next){\n        len++;\n        tail = tail.next;\n    }\n    tail.next = head;\n    count = len - k%len;\n\n    while(count>0){\n        previous = head!;\n        head = head!.next;\n        count--;\n    }\n\n    previous.next = null;\n    return head;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192694305","body":"```ts\nfunction swapPairs(head: ListNode | null): ListNode | null {\n\n    if (head === null || head.next === null) {\n        return head;\n    }\n\n    let point: ListNode = head;\n    let newHead: ListNode = point.next;\n    point.next = newHead.next;\n    newHead.next = point;\n\n    let pre: ListNode = point;\n    point = pre.next;\n\n    let len: number = 1;\n    head = newHead;\n    while (head.next) {\n        head = head.next;\n        len++;\n    }\n\n    let odd: boolean = len % 2 === 0 ? false : true;\n    let loopCount: number = odd ? Math.floor(len / 2) - 1 : Math.floor(len / 2) - 2;\n\n    while (loopCount > 0) {\n        pre.next = point.next;\n        point.next = point.next.next;\n        pre.next.next = point;\n\n        pre = point;\n        point = pre.next;\n        loopCount--;\n    }\n\n    if (!odd && point !== null) {\n        pre.next = point.next;\n        pre.next.next = point;\n        point.next = null;\n    }\n\n    return newHead;\n};\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195645074","body":"```ts\nclass LRUCache {\n    capacity: number;\n    map: Map<number, number>;\n\n    constructor(capacity: number) {\n        this.capacity = capacity;\n        this.map = new Map();\n    }\n\n    get(key: number): number {\n        if(this.map.has(key)){\n            const result = this.map.get(key)!;\n            this.map.delete(key);\n            this.map.set(key, result);\n            return result;\n        }\n        return -1;\n    }\n\n    put(key: number, value: number): void {\n        if(this.map.has(key)) {\n            this.map.delete(key);\n        }\n        if(this.map.size >= this.capacity) {\n            this.map.delete(this.map.keys().next().value);\n        }\n        this.map.set(key,value);\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185675036","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        i = len(num) - 1\r\n        c = 0\r\n        while i >= 0 or k != 0:\r\n            a = num[i] if i >= 0 else 0\r\n            b = k % 10\r\n            sum = a + b + c\r\n            c   = sum // 10\r\n            res.append(sum % 10)\r\n            i = i - 1\r\n            k = k // 10\r\n        if c != 0:\r\n            res.append(c)\r\n        return res[::-1]\r\n```\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186219163","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        n = len(S)\r\n        res = [0 if c == C else n for c in S]\r\n        for i in range(1, n):\r\n           res[i] = min(res[i], res[i - 1] + 1)\r\n        for i in range(n - 2, -1, -1):\r\n            res[i] = min(res[i], res[i + 1] + 1)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551539","body":"```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.len = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.maxSize:\r\n            self.stack.append(x)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.len == 0:\r\n            return -1\r\n        else:\r\n            self.len -= 1\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(k):\r\n            if i < self.len:\r\n                self.stack[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187622566","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = 0\r\n        res = \"\"\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c)\r\n            elif c == \"[\":\r\n                stack.append((res, num))\r\n                res, num = \"\", 0\r\n            elif c == \"]\":\r\n                top = stack.pop()\r\n                res = top[0] + res * top[1]\r\n            else:\r\n                res += c\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189185010","body":"```java\r\nclass MyQueue {\r\n    private Stack<Integer> s1, s2;\r\n\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        // 先调用 peek 保证 s2 非空\r\n        peek();\r\n        return s2.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if (s2.isEmpty())\r\n            // 把 s1 元素压入 s2\r\n            while (!s1.isEmpty())\r\n                s2.push(s1.pop());\r\n        return s2.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190410948","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        res = [arr[0]]\r\n        for i in range(1, len(arr)):\r\n            if arr[i] >= res[-1]:\r\n                res.append(arr[i])\r\n            else:\r\n                index = -1\r\n                for j in range(len(res) - 2, -1, -1):\r\n                    if res[j] <= arr[i]:\r\n                        index = j\r\n                        break\r\n                res = res[0:index + 1] + [res[-1]]\r\n        return len(res)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191648376","body":"```python\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || k == 0) {\r\n\t\t\treturn head;\r\n\t\t}\r\n\t\tListNode pre = head;\r\n\t\tListNode end = head.next;\r\n\t\tint len = 1;\r\n\t\twhile (end != null) {\r\n\t\t\tpre = end;\r\n\t\t\tend = end.next;\r\n\t\t\tlen ++;\r\n\t\t}\r\n\t\t// 头尾相连形成死链\r\n\t\tpre.next = head;\r\n\t\tend = head;\r\n\t\t\r\n\t\tk = k % len;\r\n\t\tint count = len - k;\r\n\t\twhile (count -- > 0) {\r\n\t\t\tpre = end;\r\n\t\t\tend = end.next;\r\n\t\t}\r\n\t\t\r\n\t\tpre.next = null;\r\n\t\t\r\n\t\treturn end;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185675275","body":"### 思路\r\n逆序遍历数组进行相加，有两种情况：\r\n1. num数组长度大于k位数；遍历完num后k为0，相加结果一致\r\n2. num数组长度小于k位数；遍历完后k不为0，则继续将k剩余数字逐个加上\r\n\r\n注意进位，若需要进位则在k前进一位后加一\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res=[]\r\n        for i in range(len(num)):\r\n            sum=num[-i-1]+k%10\r\n            k/=10\r\n            if sum>=10:\r\n                k+=1\r\n                sum-=10\r\n            res.append(sum)\r\n        while k:\r\n            res.append(k%10)\r\n            k/=10\r\n        return res[::-1]\r\n```\r\n### 复杂度分析\r\n时间复杂度: O(max(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185758533","body":"### 思路\r\n两次遍历，分别寻找字符与左边c字符的最小距离和与右边c字符的最小距离，取两者最小值\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=len(s)\r\n        res=[n]*n\r\n        cidex=-n\r\n        for i,ch in enumerate(s):\r\n            if ch==c:\r\n                cidex=i\r\n            res[i]=i-cidex\r\n        cidex=n\r\n        for i in range(-1,-len(s)-1,-1):\r\n            if s[i]==c:\r\n                cidex=i\r\n            res[i]=min(res[i],cidex-i)\r\n        return res\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)，n为字符串s的长度\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186547537","body":"用top记录栈顶位置\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.stack=[0]*maxSize\r\n        self.top=-1\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if self.top<len(self.stack)-1:\r\n            self.top+=1\r\n            self.stack[self.top]=x\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.top==-1:\r\n            popout=-1\r\n        else:\r\n            popout=self.stack[self.top]\r\n            self.top-=1\r\n        return popout\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)<k:\r\n            self.stack=[x+val for x in self.stack]\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]+=val\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192234366","body":"### 代码\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy=ListNode()\r\n        dummy.next=head\r\n        cur=dummy\r\n        while(cur.next and cur.next.next):\r\n            node1=cur.next\r\n            node2=cur.next.next\r\n            cur.next=node2\r\n            node1.next=node2.next\r\n            node2.next=node1\r\n            cur=node1\r\n        return dummy.next\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)，其中n是链表的节点数量。\r\n空间复杂度：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195572338","body":"### 代码\r\n```python\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            node = DLinkedNode(key, value)\r\n            self.cache[key] = node\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                removed = self.removeTail()\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(capacity)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185677632","body":"# 【Day 1】989. 数组形式的整数加法\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n## 复杂度\n**时间复杂度**：O(max(n,log k))，其中n为数组的长度\n\n**空间复杂度**：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225383","body":"# 【Day 2】821. 字符的最短距离\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> ans(n);\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = min(ans[i], idx - i);\n        }\n        return ans;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551813","body":"# 【Day 3】1381. 设计一个支持增量操作的栈\n\n## 代码\n\n```c++\nclass CustomStack {\npublic:\n\tint maxSize;\n\tvector<int>tmp;\n\tCustomStack(int maxSize) {\n\t\tthis->maxSize = maxSize;\n\t}\n\n\tvoid push(int x) {\n\t\tif (tmp.size() >= maxSize)\n\t\t{\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp.emplace_back(x);\n\t\t}\n\t}\n\n\tint pop() {\n\t\tif (tmp.size() == 0)\n\t\t\treturn -1;\n\t\telse\n\t\t{\n\t\t\tint x = tmp.back();\n\t\t\ttmp.pop_back();\n\t\t}\n\t}\n\n\tvoid increment(int k, int val) {\n\t\tfor (int i = 0; i < tmp.size() && i < k; i++)\n\t\t{\n\t\t\ttmp[i] += k;\n\t\t}\n\t}\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187675016","body":"# 【Day 4】394. 字符串解码\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // 获取一个数字并进栈\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // 左括号出栈\n                stk.pop_back();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // 构造字符串\n                while (repTime--) t += o; \n                // 将构造好的字符串入栈\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189153792","body":"# 【Day 5】232. 用栈实现队列\n\n## 代码\n\n```C++\nclass MyQueue {\npublic:\n    stack<int> stIn;        //输入栈\n    stack<int> stOut;        //输出栈\n\n    //入栈无返回，有参数\n    void push(int x){\n        stIn.push(x);//先加入输入栈\n    }\n    //出栈有返回，返回出栈的元素\n    int pop(){\n        //只有当stOut为空的时候，再从stIn里面导入全部数\n        if(stOut.empty()){\n            //从stIn导入数据直到stIn为空\n            while(!stIn.empty()){\n                stOut.push(stIn.top());\n                stIn.pop();\n            }\n        }\n        //出栈的有元素，可以出栈，临时保存栈顶\n        int front = stOut.top();\n        stOut.pop();\n        return front;\n    }\n\n    int peek(){\n        int res = this->pop();  //直接使用已有的pop函数\n        stOut.push(res);    //因为pop函数弹出了元素res，所以在添加回去\n        return res;\n    }\n\n\n    bool empty(){\n        return stOut.empty()&&stIn.empty();\n    }\n};\n\n```\n\n## 复杂度\n\n时间复杂度：O(1)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190450446","body":"# 【Day 6】768. 最多能完成排序的块 II\n\n## 代码\n\n```C++\n// 官方题解\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stack;\n        for(int i =0;i<arr.size();i++){\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\n            if(!stack.empty()&&stack.top()>arr[i]){\n                // 我们需要将融合后的区块的最大值重新放回栈\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\n                int cur = stack.top();\n                // 维持栈的单调递增\n                while(!stack.empty()&&stack.top()>arr[i]){\n                    stack.pop();\n                }\n                stack.push(cur);\n            }else{\n                stack.push(arr[i]);\n            }\n        }\n        // 栈存的是块信息，因此栈的大小就是块的数量\n        return stack.size();\n    }\n};\n\n//Lee 只能通过一部分用例\nclass Solution {\npublic:\n\tint maxChunksToSorted(vector<int>& arr) {\n\t\tint ans = 0;\n\t\tint i = arr.size();\n\t\twhile (i != 0)\n\t\t{\n\t\t\tint j = max_element(arr.begin(), arr.begin() + i) - arr.begin();\n\t\t\twhile (j + 1 < arr.size() && arr[j] == arr[j + 1] && j < i-1)\n\t\t\t\tj += 1;\n\t\t\ti = j;\n\t\t\tans += 1;\n\t\t}\n\t\treturn ans;\n\t}\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191642131","body":"# 【Day 7】61. 旋转链表\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n\tListNode* rotateRight(ListNode* head, int k) {\n\t\tif (head == NULL || head->next == NULL || k == 0)\n\t\t\treturn head;\n\t\tListNode * tmp = head;\n\t\tint len = 1;\n        //计算长度\n\t\twhile (tmp->next != NULL)\n\t\t{\n\t\t\tlen += 1;\n\t\t\ttmp = tmp->next;\n\t\t}\n\t\t\n\t\tint add = len - k % len;\n\t\tif (len == add)\n\t\t{\n\t\t\treturn head;\n\t\t}\n\t\ttmp->next = head;\n\t\twhile (add--)\n\t\t{\n\t\t\ttmp = tmp->next;\n\t\t}\n\n\t\thead = tmp->next;\n\t\ttmp->next = NULL;\n\t\t\n\t\t\n\t\treturn head;\n\n\t}\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192508232","body":"# 【Day 8】24. 两两交换链表中的节点\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n\tListNode* swapPairs(ListNode* head) {\n\t\tif (head == NULL || head->next == NULL)\n\t\t\treturn head;\n\t\tListNode * p1 = head;\n\t\tListNode * p2 = head->next;\n\t\tListNode * ans = head->next; \\\n\t\t\tListNode *pre = NULL;\n\t\twhile (1)\n\t\t{\n\t\t\tListNode * tmp = p2->next;\n\t\t\tp2->next = p1;\n\t\t\tp1->next = tmp;\n\t\t\tif(pre)\n\t\t\t\tpre->next = p2;\n\n\t\t\tif (p1->next && p1->next->next)\n\t\t\t{\n\t\t\t\tpre = p1;\n\t\t\t\tp1 = p1->next;\n\t\t\t\tp2 = p1->next;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn ans;\n\t}\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141039","body":"# 【Day 9】109. 有序链表转换二叉搜索树\n\n## 代码\n\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// 官方\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr) return nullptr;\n        return sortedListToBST(head, nullptr);\n    }\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail) {\n        if (head == tail) return nullptr;\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast != tail && fast->next != tail) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        TreeNode* root = new TreeNode(slow->val);\n        root->left = sortedListToBST(head, slow);\n        root->right = sortedListToBST(slow->next, tail);\n        return root;\n    }\n};\n\n// 官方 以时间换空间 时间复杂度空间复杂度都是O(N)\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        vector<int> nodes;\n        while (head != nullptr) {\n            nodes.push_back(head->val);\n            head = head->next;\n        }\n        return sortedListToBST(nodes, 0, nodes.size());\n    }\n    TreeNode* sortedListToBST(vector<int>& nodes, int start, int end) {\n        if (start >= end) return nullptr;\n\n        int mid = (end - start) / 2 + start;\n        TreeNode* root = new TreeNode(nodes[mid]);\n        root->left = sortedListToBST(nodes, start, mid);\n        root->right = sortedListToBST(nodes, mid + 1, end);\n        return root;\n    }\n};\n\n```\n\n## 复杂度\n\n时间复杂度：O(NLogN)\n\n空间复杂度：O(LogN)\n\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193290697","body":"# 【Day 10】160. 相交链表\n\n## 代码\n\n```C++\n//V1 哈希\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    if (headA == NULL || headB == NULL) return NULL;\n\n    map<ListNode*, bool> seen;\n    while (headA) {\n        seen.insert(pair<ListNode*, bool>(headA, true));\n        headA = headA->next;\n    }\n    while (headB) {\n        if (seen.find(headB) != seen.end()) return headB;\n        headB = headB->next;\n    }\n    return NULL;\n}\n\n//V2 双指针 时间复杂度：O(N);空间复杂度：O(1)；\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    if (headA == NULL || headB == NULL) return NULL;\n\n    ListNode* pA = headA;\n    ListNode* pB = headB;\n    while (pA != pB) {\n        pA = pA == NULL ? headB : pA->next;\n        pB = pB == NULL ? headA : pB->next;\n    }\n\n    return pA;\n}\n\n//Lee 时间复杂度：O(N*N);空间复杂度：O(1)；\nclass Solution {\npublic:\n\tListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n\t\twhile (headA && headB)\n\t\t{\n\t\t\tListNode *tmp = headB;\n\t\t\twhile (tmp)\n\t\t\t{\n\t\t\t\tif (tmp == headA)\n\t\t\t\t\treturn tmp;\n\t\t\t\ttmp = tmp->next;\n\t\t\t}\n\t\t\theadA = headA->next;\n\t\t}\n\t\treturn NULL;\n\t}\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194123442","body":"# 【Day 11】142. 环形链表 II\n\n## 代码\n\n```C++\nListNode *detectCycle(ListNode *head) {\n    ListNode *slow = head;\n    ListNode *fast = head;\n\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            fast = head;\n            while (slow != fast) {\n                slow = slow->next;\n                fast = fast->next;\n            }\n            return slow;\n        }\n    }\n    return NULL;\n}\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195665858","body":"# 【Day 12】146. LRU 缓存机制\n\n## 代码\n\n```c++\n// 构建链表\nclass DLinkedListNode {\npublic:\n    int key;\n    int value;\n    DLinkedListNode *prev;\n    DLinkedListNode *next;\n    DLinkedListNode() : key(0), value(0), prev(NULL), next(NULL) {};\n    DLinkedListNode(int k, int val) : key(k), value(val), prev(NULL), next(NULL) {};\n};\n\nclass LRUCache {\npublic:\n    LRUCache(int capacity) : capacity_(capacity) {\n        // 创建两个 dummy 节点来简化操作，这样就不用特殊对待头尾节点了\n        dummy_head_ = new DLinkedListNode();\n        dummy_tail_ = new DLinkedListNode();\n        dummy_head_->next = dummy_tail_;\n        dummy_tail_->prev = dummy_head_;\n    }\n    \n    int get(int key) {\n        if (!key_exists_(key)) {\n            return -1;\n        }\n        // 1. 通过哈希表找到 key 对应的节点\n        // 2. 将节点移到链表头部\n        // 3. 返回节点值\n        DLinkedListNode *node = key_node_map_[key];\n        move_to_head_(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if (key_exists_(key)) {\n            // key 存在的情况\n            DLinkedListNode *node = key_node_map_[key];\n            node->value = value;\n            move_to_head_(node);\n        } else {\n            // key 不存在的情况：\n            // 1. 如果缓存空间满了，先删除尾节点，再新建节点\n            // 2. 否则直接新建节点\n            if (is_full_()) {\n                DLinkedListNode *tail = dummy_tail_->prev;\n                remove_node_(tail);\n                key_node_map_.erase(tail->key);\n            }\n\n            DLinkedListNode *new_node = new DLinkedListNode(key, value);\n            add_to_head_(new_node);\n            key_node_map_[key] = new_node;\n        }\n    }\nprivate:\n    unordered_map<int, DLinkedListNode*> key_node_map_;\n    DLinkedListNode *dummy_head_;\n    DLinkedListNode *dummy_tail_;\n    int capacity_;\n\n    void move_to_head_(DLinkedListNode *node) {\n        remove_node_(node);\n        add_to_head_(node);\n    };\n\n    void add_to_head_(DLinkedListNode *node) {\n        DLinkedListNode *prev_head = dummy_head_->next;\n\n        dummy_head_->next = node;\n        node->prev = dummy_head_;\n\n        node->next = prev_head;\n        prev_head->prev = node;\n    };\n\n    void remove_node_(DLinkedListNode *node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n        node->prev = node->next = NULL;\n    };\n\n    bool key_exists_(int key) {\n        return key_node_map_.count(key) > 0;\n    };\n\n    bool is_full_() {\n        return key_node_map_.size() == capacity_;\n    };\n};\n\n```\n\n## 复杂度\n\n时间复杂度:O(1)\n\n空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196920804","body":"# 【Day 13】104. 二叉树的最大深度\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n\tint maxDepth(TreeNode* root) {\n\t\tif (!root)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn max(1 + maxDepth(root->left), 1 + maxDepth(root->right));\n\t}\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(H)，H为二叉树的高度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185677997","body":"## 思路\n\n> + 思路描述\n\n##代码\n\n```python\n#代码\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = \"\"\n        for i in num:\n            temp += str(i)\n        temp = int(temp) + k\n        print([i for i in str(temp)])\n        return [int(i) for i in str(temp)]\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n)\n> + 空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186222102","body":"## 思路\n\n> + 思路描述\n\n##代码\n\n```python\n#代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        temp_list = []\n        for i in range(len(s)):\n            temp_int = 0\n            while True:\n                if i - temp_int >= 0:\n                    if s[i-temp_int] == c:\n                        break\n                if i + temp_int <= len(s) - 1:\n                    if s[i+temp_int] == c:\n                        break\n                temp_int += 1\n            temp_list.append(temp_int)\n        return temp_list\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n^2)\n> + 空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186522716","body":"## 思路\n\n> + 思路描述\n\n## 代码\n\n```python\n# 代码\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack) > 0:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) >= k:\n            for i in range(k):\n                self.stack[i] += val\n        else:\n            for i in range(len(self.stack)):\n                self.stack[i] += val\n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187670227","body":"## 思路\n\n> + 思路描述\n\n## 代码\n\n```python\n# 代码\nclass Solution:\n    def decodeString(self, s: str) -> str:\n\n        stack = []\n        nums = 0\n        for char in s:\n            if char.isdigit(): \n                nums = nums*10 + int(char)\n            elif char != ']':  \n                if nums!=0:\n                    stack.append(nums)\n                    nums = 0\n                stack.append(char)\n            else:  \n                tmp_s = ''\n                while stack[-1]!='[':\n                    tmp_s = stack.pop(-1) + tmp_s\n                stack.pop(-1)\n                num = stack.pop(-1) \n                stack.append(num * tmp_s)\n\n        return ''.join(stack)  \n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189048751","body":"## 思路\n\n> + 思路描述\n用双栈模拟队列。\n\n## 代码\n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.instack = []\n        self.outstack = []\n\n    def push(self, x):\n        self.instack.append(x)\n\n    def pop(self):\n        if len(self.outstack) == 0:\n            while self.instack:\n                self.outstack.append(self.instack.pop())\n        return self.outstack.pop()\n\n    def peek(self):\n        if len(self.outstack) == 0:\n            while self.instack:\n                self.outstack.append(self.instack.pop())\n        return self.outstack[-1]\n    def empty(self):\n        return len(self.instack) == 0 and len(self.outstack) == 0\n\n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190128976","body":"## 思路\n\n> + 思路描述\n\n## 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: \n                stack.append(num)\n        return len(stack)\n\n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191605086","body":"## 思路\n\n> + 思路描述\n\n## 代码\n\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret\n\n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192687822","body":"## 思路\n\n> + 思路描述\n\n## 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n\n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193274569","body":"## 思路\n\n分治算法\n\n> + 思路描述\n\n## 代码\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n```\n\n## 复杂度\n\n> + 时间复杂度: O(nlogn)\n> + 空间复杂度: O(logn)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193314975","body":"## 思路\n\n> + 思路描述\n双指针\n## 代码\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return None\n        \n        pointer1, pointer2 = headA, headB\n\n        while pointer1 != pointer2:\n            if pointer1 != None:\n                pointer1 = pointer1.next\n            else:\n                pointer1 = headB\n            if pointer2 != None:\n                pointer2 = pointer2.next\n            else:\n                pointer2 = headA\n\n        return pointer1\n\n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194105778","body":"## 思路\n\n> + 思路描述\n\n## 代码\n\n```python\nclass Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195643054","body":"## 思路\n\n> + 思路描述\n\n## 代码\n\n```python\nclass LRUCache(collections.OrderedDict):\n\n    def __init__(self, capacity: int):\n        super().__init__()\n        self.capacity = capacity\n\n\n    def get(self, key: int) -> int:\n        if key not in self:\n            return -1\n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last=False)\n\n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196941657","body":"## 思路\n\n> + 思路描述\n\n## 代码\n\n```python\nclass Solution:\n    def maxDepth(self, root):\n        if root is None: \n            return 0 \n        else: \n            left_height = self.maxDepth(root.left) \n            right_height = self.maxDepth(root.right) \n            return max(left_height, right_height) + 1 \n\n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185679498","body":"var addToArrayForm = function(num, k) {\n    const res = [];\n    const nLen = num.length;\n    for (let i = nLen  - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1191420794","body":"## 思路\n1. 记录c在s的所有索引，形成索引列表\n2. 遍历s，并每次对索引列表的数值进行比较，得出绝对值的最小值\n\n## 代码\n```js\nvar shortestToChar = function(s, c) {\n   var cIndexList = []\n    for(var i = 0, len = s.length; i < len; i++) {\n        if (s[i] === c) {\n        cIndexList.push(i)\n        }\n    }\n    var arr = []\n    for(var i = 0, len = s.length; i < len; i++) {\n        var distance = Math.abs(cIndexList[0] - i);\n        for(var j = 1; j < cIndexList.length;j++) {\n        distance = Math.min(Math.abs(cIndexList[j] -i), distance)\n        }\n        arr.push(distance)\n    }\n    return arr;\n};\n```\n\n##  复杂度\n- 时间 O(n)\n- 空间 O(n)\n\n\n","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185681120","body":"### 思路\n考虑到数组长度过长，不能进行累加后转换，采取逐位累加的方式，数组末尾累加之k上，取余。本人采取的是arraylist，参考答案后改为linkedlist\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       int j = k;\n        int i = num.length -1;\n        LinkedList list = new LinkedList();\n        while (i >= 0 || j > 0) {\n            if (i>=0) {\n                j = j + num[i];\n            }\n            list.addFirst(j%10);\n            j = j / 10;\n            i--;\n        }\n        return list;\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191564683","body":"### 思路\n1. 构建循环链表\n2. 寻找破圈节点\n3.破圈\n### 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head,int k) {\n        if (Objects.equals(head,null)) {\n            return head;\n        }\n        ListNode trailNode = getTrailNode(head);\n        ListNode top = head;\n        int length = getLength(head);\n        int pos = 0;\n        if(length == 0) {\n            pos = 0;\n        } else {\n            pos = length - k % length - 1;\n        }\n        int count = 0;\n        trailNode.next = top;\n        while (!top.next.equals(null)) {\n            if (count == pos) {\n                head = top.next;\n                top.next = null;\n                break;\n            } else {\n                count++;\n                top = top.next;\n            }\n        }\n        return head;\n    }\n    public int getLength(ListNode head) {\n        if (Objects.equals(head,null)) {\n            return 0;\n        }\n        int length = 1;\n        while (!Objects.equals(head.next,null)) {\n            length++;\n            head = head.next;\n        }\n        return length;\n    }\n    public ListNode getTrailNode(ListNode head) {\n        if (Objects.equals(head,null)) {\n            return head;\n        }\n        while (!Objects.equals(head.next,null)) {\n            head = head.next;\n        }\n        return head;\n    }\n}\n```\n### 复杂度\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185681843","body":"var addToArrayForm = function(A, K) {\n        const res = [];\n        const n = A.length;\n        for (let i = n - 1; i >= 0; --i) {\n        let sum = A[i] + K % 10;\n        K = Math.floor(K / 10);\n        if (sum >= 10) {\n          K++;\n            sum -= 10;\n        }\n        res.push(sum);\n      }\n        for (; K > 0; K = Math.floor(K / 10)) {\n        res.push(K % 10);\n      }\n        res.reverse();\n        return res;\n      };","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186188832","body":"```\r\nvar shortestToChar = function(S, C) {\r\n    let res = [];\r\n    const sArr = S.split('');\r\n    for(let i=0;i<sArr.length;i++){\r\n        let leftArr;\r\n        let rightArr;\r\n        const curChar = sArr[i];\r\n        if(curChar === C){\r\n            res.push(0)\r\n        }else{\r\n            leftArr = sArr.slice(0, i).reverse();\r\n            rightArr = sArr.slice(i+1);\r\n            const leftDis = leftArr.indexOf(C) + 1;\r\n            const rightDis = rightArr.indexOf(C) + 1;\r\n            if(leftDis === 0){\r\n                res.push(rightDis)\r\n            }\r\n            if(rightDis === 0){\r\n                res.push(leftDis);\r\n            }\r\n            if(leftDis > 0 && rightDis > 0){\r\n                res.push(Math.min(leftDis, rightDis));\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186552331","body":"```\r\nvar CustomStack = function (maxSize) {\r\n    this.top = 0;\r\n    this.add = new Array(maxSize).fill(0);\r\n    this.stack = new Array(maxSize).fill(0);\r\n};\r\nCustomStack.prototype.push = function (val) {\r\n    if (this.top === this.stack.length) return;\r\n    this.stack[this.top] = val;\r\n    this.add[this.top] = 0;\r\n    this.top += 1;\r\n};\r\nCustomStack.prototype.pop = function () {\r\n    if (this.top === 0) return -1;\r\n    this.top -= 1;\r\n    if (this.top > 0)\r\n        this.add[this.top - 1] += this.add[this.top];\r\n    return this.stack[this.top] + this.add[this.top];\r\n};\r\nCustomStack.prototype.increment = function (k, val) {\r\n    let len = Math.min(k, this.top);\r\n    if (len === 0) return;\r\n    this.add[len - 1] += val;\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187671696","body":"```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if (s == null || s.length() == 0) {\r\n            return \"\";\r\n        }\r\n        Deque<Integer> times = new ArrayDeque<>();\r\n        Deque<StringBuilder> dq = new ArrayDeque<>();\r\n        StringBuilder sb = new StringBuilder();\r\n        int index = 0;                               // index:已经处理好的字段\r\n        char ch = s.charAt(0);\r\n        OUT:\r\n        while (true) {\r\n            int i = index;\r\n            if (ch >= '0' && ch <= '9') {\r\n                while (ch >= '0' && ch <= '9') {\r\n                    ch = s.charAt(++i);\r\n                }\r\n                times.push(Integer.parseInt(s.substring(index, i)));\r\n                index = ++i;                            // 跳过'['\r\n                ch = s.charAt(i);\r\n            }\r\n            dq.push(sb);                               // 拿到新数字，要另起炉灶\r\n            sb = new StringBuilder();\r\n            while (ch < '0' || ch > '9') {\r\n                if (ch == ']') {\r\n                    int time = times.pop();              // 字符串复制\r\n                    String str = sb.toString();\r\n                    for (int j = 1;j < time;j++) {\r\n                        sb.append(str);\r\n                    }\r\n                    sb = dq.pop().append(sb);       // 连接到上一段末尾\r\n                } else {\r\n                    sb.append(ch);\r\n                }\r\n                index = ++i;                                // 跳过']'\r\n                if (i == s.length()) {\r\n                    break OUT;\r\n                }\r\n                ch = s.charAt(i);\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189187847","body":"```\r\nclass MyQueue {\r\n    private Stack<Integer> a;// 输入栈\r\n    private Stack<Integer> b;// 输出栈\r\n    \r\n    public MyQueue() {\r\n        a = new Stack<>();\r\n        b = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        a.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        // 如果b栈为空，则将a栈全部弹出并压入b栈中，然后b.pop()\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return a.isEmpty() && b.isEmpty();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190443778","body":"```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> s = new Stack<>();\r\n        for(int i=0;i<arr.length;i++){\r\n            int v = -1;\r\n            while(!s.isEmpty() && s.peek()>arr[i]){\r\n                v=Math.max(v,s.pop());\r\n            }\r\n            if(v!=-1)\r\n                s.push(v);\r\n            else\r\n                s.push(arr[i]);\r\n        }\r\n        return s.size();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191619861","body":"```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null){\r\n            return head;\r\n        }\r\n        int len = 1;\r\n        ListNode p = head;\r\n        while(p.next!=null){\r\n            p=p.next;\r\n            len++;\r\n        }\r\n        k = k%len;\r\n        if(k==0){\r\n            return head;\r\n        }\r\n        p.next = head;\r\n        int cnt = len-k;\r\n        while(cnt>1){\r\n            head = head.next;\r\n            cnt--;\r\n        }\r\n        p=head;\r\n        head = head.next;\r\n        p.next = null;\r\n        return head;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192689553","body":"```\r\nvar swapPairs = function (head) {\r\n  let ret = new ListNode(0, head), temp = ret;\r\n  while (temp.next && temp.next.next) {\r\n    let cur = temp.next.next, pre = temp.next;\r\n    pre.next = cur.next;\r\n    cur.next = pre;\r\n    temp.next = cur;\r\n    temp = pre;\r\n  }\r\n  return ret.next;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193144366","body":"```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        if(head.next == null) return new TreeNode(head.val);\r\n\r\n        // low是中点，pre是low的前一个结点，因为断开需要置空\r\n        ListNode pre = null;\r\n        ListNode fast = head;\r\n        ListNode low = head;\r\n\r\n        while(fast != null && fast.next != null){\r\n            fast = fast.next.next;\r\n            pre = low;\r\n            low = low.next;\r\n        }\r\n        pre.next = null;\r\n        TreeNode root = new TreeNode(low.val, sortedListToBST(head), sortedListToBST(low.next));\r\n\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193327432","body":"```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode curA = headA;\r\n        ListNode curB = headB;\r\n        int lenA = 0, lenB = 0;\r\n        while (curA != null) { // 求链表A的长度\r\n            lenA++;\r\n            curA = curA.next;\r\n        }\r\n        while (curB != null) { // 求链表B的长度\r\n            lenB++;\r\n            curB = curB.next;\r\n        }\r\n        curA = headA;\r\n        curB = headB;\r\n        // 让curA为最长链表的头，lenA为其长度\r\n        if (lenB > lenA) {\r\n            //1. swap (lenA, lenB);\r\n            int tmpLen = lenA;\r\n            lenA = lenB;\r\n            lenB = tmpLen;\r\n            //2. swap (curA, curB);\r\n            ListNode tmpNode = curA;\r\n            curA = curB;\r\n            curB = tmpNode;\r\n        }\r\n        // 求长度差\r\n        int gap = lenA - lenB;\r\n        // 让curA和curB在同一起点上（末尾位置对齐）\r\n        while (gap-- > 0) {\r\n            curA = curA.next;\r\n        }\r\n        // 遍历curA 和 curB，遇到相同则直接返回\r\n        while (curA != null) {\r\n            if (curA == curB) {\r\n                return curA;\r\n            }\r\n            curA = curA.next;\r\n            curB = curB.next;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194215586","body":"```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        HashSet<ListNode> hashSet=new HashSet<>();\r\n        ListNode cur=new ListNode(0);\r\n        cur.next=head;\r\n        \r\n        while(hashSet.add(cur)!=false){\r\n            if(cur==null){\r\n                return null;\r\n            }\r\n            cur=cur.next;\r\n        }\r\n        \r\n        return cur;\r\n\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1196171150","body":"```\r\nclass LRUCache1465 {\r\n    int capacity;\r\n    LinkedHashMap<Integer, Integer> cache;\r\n\r\n    public LRUCache1465(int capacity) {\r\n        this.capacity = capacity;\r\n\r\n        //重点在这里！！\r\n        cache = new LinkedHashMap<Integer, Integer>(capacity, 0.75f, true) {\r\n            @Override\r\n            protected boolean removeEldestEntry(Map.Entry eldest) {\r\n                return cache.size() > capacity;\r\n            }\r\n        };\r\n    }\r\n\r\n    public int get(int key) {\r\n        return cache.getOrDefault(key, -1);\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        cache.put(key, value);\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196171408","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        int lay=0;                //记录层数\r\n        queue<TreeNode *> QT;\r\n        if(root==nullptr)\r\n            return 0;\r\n        QT.push(root);       //头结点入队\r\n        while(!QT.empty()){     //如果队列不为空\r\n            int len=QT.size();  //记录本层结点个数\r\n            lay++;\r\n            for(int i=0;i<len;i++){\r\n                TreeNode *node=QT.front();\r\n                QT.pop();    //最前结点出队\r\n                if(node->left!=nullptr)\r\n                    QT.push(node->left);//其左右子结点入队\r\n                if(node->right!=nullptr)\r\n                    QT.push(node->right);\r\n            }\r\n        }\r\n        return lay;             //返回层数\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185684032","body":"正向思维的暴力解法，reverse和k的分解方式还可以优化，没时间了先交卷\n```typescript\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const numArrReverse = num.reverse()\n    const kArrReverse = String(k).split('').map(item=>Number(item)).reverse()\n    let needCarry:boolean = false\n    const mapObject = (numArrReverse.length>kArrReverse.length?numArrReverse:kArrReverse)\n    return mapObject.reduce<number[]>((pre,cur,index)=>{\n       const sum = (numArrReverse[index]??0)+(kArrReverse[index]??0)+(needCarry?1:0)\n       console.log(sum)\n       if(sum>=10) {\n           needCarry = true\n       } else{\n           needCarry = false\n       }\n        return [...pre,sum%10,...(mapObject.length-1===index&&needCarry?[1]:[])]\n    },[]).reverse()\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225083","body":"```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n    const stringLength = s.length\n    const returnArr:number[] = new Array(stringLength).fill(0)\n    for(let i = 0,cPos = -stringLength;i<stringLength;i++){\n        if(s[i]===c){\n            cPos = i\n        }\n        returnArr[i] = i - cPos\n    }\n    console.log(returnArr)\n    for(let j = stringLength - 1,cPosRight = 2*stringLength;j>=0;j--){\n        if(s[j]===c){\n            cPosRight = j\n        }\n        returnArr[j] = Math.min(returnArr[j],cPosRight - j)\n    }\n    console.log(returnArr)\n    return returnArr\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186460622","body":"```typescript\n/*\n * @lc app=leetcode.cn id=1381 lang=typescript\n *\n * [1381] 设计一个支持增量操作的栈\n */\n\n// @lc code=start\nclass CustomStack {\n\n    stack: number[] = []\n\n    constructor(public maxSize: number = 0) {\n\n    }\n\n    push(x: number): void {\n        if (this.stack.length < this.maxSize) {\n            this.stack.push(x)\n        }\n    }\n\n    pop(): number {\n        return this.stack.pop() ?? -1\n    }\n\n    increment(k: number, val: number): void {\n        for (let i = 0; i < this.stack.length; i++) {\n            if (i < k) {\n                this.stack[i] = this.stack[i] + val\n            }\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n// @lc code=end\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1189337623","body":"补卡 一个栈结构解决\n```typescript\nfunction decodeString(s: string): string {\n    const stack:string[] = []\n    for (let i = 0; i < s.length; i++) {\n      const element = s[i]\n      if(s[i]!==']'){\n        stack.push(element)\n      } else {\n        let repeatStr = '',\n        repeatCount = ''\n        while(stack[stack.length-1]!=='['){\n          repeatStr = stack.pop() + repeatStr\n        }\n        stack.pop()\n        while(/^[0-9]+.?[0-9]*/.test(stack[stack.length-1])){\n          repeatCount = stack.pop() + repeatCount\n        }\n        stack.push(repeatStr.repeat(Number(repeatCount)))\n        console.log(stack)\n      }\n    }\n    return stack.join('')\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1190348699","body":"原生api默秒全（🐶.jpg）\n```typescript\nclass MyQueue {\n    queue: number[] = []\n    constructor() {\n        \n    }\n\n    push(x: number): void {\n        this.queue.push(x)\n    }\n\n    pop(): number {\n        return this.queue.splice(0,1)[0]\n    }\n\n    peek(): number {\n        return this.queue[0]\n    }\n\n    empty(): boolean {\n        return this.queue.length === 0\n    }\n}\n```\n正式用栈解一下\n```typescript\nclass MyQueue {\n    inStack: number[] = []\n    outStack: number[] = []\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.inStack.push(x)\n    }\n\n    pop(): number {\n        if (!this.outStack.length) {\n            this.in2out()\n        }\n        return this.outStack.pop() as number\n    }\n\n    peek(): number {\n        if (!this.outStack.length) {\n            this.in2out()\n        }\n        return this.outStack[this.outStack.length - 1]\n    }\n\n    empty(): boolean {\n        return this.inStack.length === 0 && this.outStack.length === 0\n    }\n\n    in2out(): void {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop() as number)\n        }\n    }\n}\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192192528","body":"```javascript\nvar swapPairs = function(head) {\n    var fateHead = new ListNode(-1);\n    fateHead.next = head;\n    var cur = fateHead;\n    \n    while(cur.next&&cur.next.next){\n        var originNode_1 = cur.next;\n        var originNode_2 = cur.next.next;\n        cur.next = originNode_2;\n        originNode_1.next = originNode_2.next;\n        originNode_2.next = originNode_1;\n        cur = originNode_1;\n    }\n    \n    return fateHead.next;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1196745411","body":"双指针赛跑\n```typescript\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n    if(headA!==null&&headB!==null){\n        let pA = headA\n        let pB = headB\n        while(pA!==pB){\n            pA = pA!==null?pA.next:headB\n            pB = pB!==null?pB.next:headA\n        }\n        return pA\n    }\n    return null\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1196274236","body":"思路：双链表赛跑(快慢指针)\r\n```\r\nvar detectCycle = function(head) {\r\n    var snowNode = head,\r\n        fastNode = head;\r\n    if(!head||!head.next) return null;\r\n    while(snowNode.next!==null){\r\n        if(fastNode.next===null||fastNode.next.next===null){\r\n            return null;\r\n        }\r\n        \r\n        snowNode = snowNode.next;\r\n        fastNode = fastNode.next.next;\r\n    \r\n        if(snowNode===fastNode){\r\n            fastNode = head;\r\n            while(fastNode!==snowNode){\r\n                fastNode = fastNode.next;\r\n                snowNode = snowNode.next;\r\n            }\r\n            return fastNode;\r\n        }\r\n     }   \r\n};\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185691220","body":"思路\n---\n1、从末尾逐位取数向前做加法  \n2、设置一个变量FLAG标识是否有进位，若有则设置FLAG=1，反之为0    \n3、注意k和num长度边界值的判断  \n\n代码\n---\n``` JAVA\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len=num.length-1;\n        int flag=0,tmp_k=0,tmp_num=0,sum=0;\n        List<Integer> res=new ArrayList<Integer>();\n        while(k>0||len>=0){\n            tmp_num = len>=0?num[len]:0;\n            tmp_k = k>0?k:0;\n            sum=flag+tmp_num+(tmp_k%10);\n            if(sum>=10){\n                flag=1;\n                sum=sum%10;\n            }else {\n                flag = 0;\n            }\n            k=k>0?k/10:0;\n            len--;\n            res.add(0,sum);\n        }\n        if(flag==1){\n            res.add(0,flag);\n        }\n        return res;\n    }\n}\n```\n复杂度\n---\n时间复杂度：O（n）  \n空间复杂度：O（n）","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186138233","body":"思路\n---  \n1、从左从右各循环一次，从左循环时找第i个字符左边最近的c，从右循环时找第i个字符右边最近的c  \n2、res记录最短距离并输出\n\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        if (s.length()==1) return new int[]{0};\n        int[] res =new int[s.length()];\n        Arrays.fill(res,s.length()+1);\n        for(int i=0,index=-1;i<s.length();i++){\n            if(s.charAt(i)==c) index=i;\n            if(index!=-1) res[i]=i-index;\n        }\n        for(int i=s.length()-1,index=-1;i>=0;i--){\n            if(s.charAt(i)==c) index=i;\n            if(index!=-1) res[i]=Math.min(res[i],index-i);\n        }\n        return res;\n    }\n}\n```\n复杂度分析\n---\n时间复杂度：O（n）  \n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186437794","body":"思路\n---\n用ArrayList模拟栈，要注意边界值的处理，即pop和push操作之前判断当前Array长度是否超出最大长度\n\n代码\n---\n```Java\nclass CustomStack {\n    List<Integer> stack ;\n    int maxSize;\n    public CustomStack(int maxSize) {\n        this.stack = new ArrayList<Integer>();\n        this.maxSize = maxSize;\n    }\n\n    public void push(int x) {\n        if(stack.size()<maxSize){\n            stack.add(x);\n        }\n    }\n    public int pop() {\n        if(stack.size()==0){\n            return -1;\n        }\n        int index=stack.size()-1;\n        int res=stack.get(index);\n        stack.remove(index);\n        return res;\n    }\n    public void increment(int k, int val) {\n        int size = k<stack.size()?k:stack.size();\n        for(int i=0;i<size;i++){\n            int tmp=stack.get(i)+val;\n            stack.set(i,tmp);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187625321","body":"思路\n---\n首先将字符串遍历一遍，把字母和数字分别存在两个栈内。  \n主要注意：当字符等于‘[’时，证明需要记录新的字符子串；  \n当字符等于‘]’时，证明一个子串的信息已经全部给出，开始构造这个子串。\n\n代码\n---\n``` JAVA\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stack_str = new Stack<String>();\n        Stack<Integer> stack_num = new Stack<Integer>();\n        String res=\"\";\n        int mul=0;\n        for(char c:s.toCharArray()){\n            if(Character.isDigit(c)){\n                mul=mul*10+(c-'0');\n            }else if(Character.isAlphabetic(c)){\n                res = res+c;\n            }else if(c=='['){\n                stack_str.push(res);\n                res=\"\";\n                stack_num.push(mul);\n                mul=0;\n            }else{\n                String str_tmp = stack_str.pop();\n                int num_tmp = stack_num.pop();\n                String res_tmp=\"\";\n                while(num_tmp>0){\n                    res_tmp += res;\n                    num_tmp--;\n                }\n                res = str_tmp+res_tmp;\n            }\n        }\n        return res;\n    }\n}\n```\n复杂度\n---\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189168066","body":"思路\n---\n使用两个list，stack和stack_tmp  \n1、入栈时，先将stack内元素按顺序pop到stack_tmp   \n2、将目标元素存入stack内  \n3、最后将stack_tmp内的全部元素pop到stack中\n\n代码\n---\n``` python3\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.stack_tmp = []\n\n    def push(self, x: int) -> None:\n        while self.stack:\n            self.stack_tmp.append(self.stack.pop())\n        self.stack.append(x)\n        while self.stack_tmp:\n            self.stack.append(self.stack_tmp.pop())\n\n    def pop(self) -> int:\n        return self.stack.pop()\n\n    def peek(self) -> int:\n        length = len(self.stack)\n        return self.stack[length-1];\n\n    def empty(self) -> bool:\n        if not self.stack:\n            return True\n        return False\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191623931","body":"思路\n---\n1、记录链表长度size  \n2、链表移动向右k次，等于向右移动k mod size，那么移动后的尾部节点则是 第size - k mod size个节点  \n3、将链表连接成环，再将第size - k mod size个节点的next=None  \n\n代码\n---\n``` python3\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k==0 or head == None : return head\n        tail = head\n        size = 1\n        while tail.next:\n            size += 1\n            tail = tail.next\n        index = size - (k%size) \n        if index == size :return head\n        tail.next = head\n        cur = tail\n        while index:\n            cur = cur.next\n            index -= 1\n        res = cur.next\n        cur.next = None\n        return res\n```\n复杂度\n---\n时间复杂度：O（N）  \n空间复杂度：O（1）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146044","body":"语言：python3\n``` python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        pre,slow,fast = None,head,head\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if fast == slow :\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193301167","body":"思路\n---\n创建两个指针a,b，初始时分别指向链表A和链表B的头部，以相同的速度进行遍历。若a为空，则将a指向链表B的头部，反之亦然。  \n1、当链表A、B相交时，由于两个指针遍历的长度是一样的，所以一定会找到相交的节点；  \n2、当链表A、B不相交时，两个指针最终都会指向null，最后返回结果  \n\n代码\n---\n``` python\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if headA == headB :\n            return headA\n        nodeA = headA\n        nodeB = headB\n        while nodeA != nodeB:\n            if nodeA:\n                nodeA=nodeA.next\n            else:\n                nodeA = headB\n            \n            if nodeB:\n                nodeB=nodeB.next\n            else:\n                nodeB = headA\n\n        return nodeA\n```\n\n复杂度\n---\n时间复杂度：O（m+n）(m、n分别为链表长度)  \n空间复杂度：O（1）","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196908910","body":"思路\n---\n递归  \n首先设置递归出口，当目前节点为空时返回0。若节点不为空则返回最大子树高度+1\n\n代码：\n---\n```python\nclass Solution:\n     def maxDepth(self, root: TreeNode) -> int:\n        if root == None :\n            return 0\n        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1\n```\n复杂度\n---\n时间复杂度：O（N），其中N为二叉树节点个数  \n空间复杂度：O（height）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185806802","body":"# Idea\n###### Traverse S from left to the right and find shortest distance from each element  in S to C.\n###### Traverse S from right to the left and find shortest distance  rom each element  in S to C.\n###### Then find the minimum value.\n\n# Code\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int [] arr = new int[len];\n        for(int i = 0, index = -len; i < len; i++){\n            if(s.charAt(i) == c){\n                index = i;\n            }\n            arr[i] = i - index;\n        }\n        \n        for(int i = len-1, index = 2 * len; i >= 0; i--){\n            if(s.charAt(i) == c){\n                index = i;\n            }\n            arr[i] = Math.min(arr[i], index - i);\n        }\n        return arr;\n    }\n}\n```\n# Complexity\n###### Time complexity: O(N)\n###### Space complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186024434","body":"## 用pointer记住前一个值和后一个值，求min\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pre,nex,k = -1,-1,0\n        ans = [None] * len(s)\n        \n        while k < len(s) and s[k] != c:  k+=1\n        nex = k\n        \n        for i in range(len(s)):\n            if pre == -1:\n                dis = nex -i\n            elif nex == -1:\n                dis = i - pre\n            else:\n                dis = min((nex -i),(i-pre))\n            ans[i] = dis\n            \n            if s[i] ==c:\n                pre = nex\n                k = i+1\n                while k < len(s) and s[k] !=c: k+=1\n                nex = k\n                if nex == len(s): nex = -1\n                \n        return ans\n```\n## 复杂度：\n时间：On\n空间：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186385024","body":"'''\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        if len(self.stack) >=2:\n            self.inc[-2] += self.inc[-1]\n        \n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k,len(self.stack))-1] += val\n        \n\n\n\n'''\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187677476","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        \n        for c in s:\n            if c != ']':\n                stack.append(c)\n                continue\n            else:\n                string =''\n                num = ''\n                while stack and stack[-1] !='[':\n                    string = stack.pop() + string\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    num = stack.pop() + num\n                stack.append(int(num) * string)\n        return ''.join(stack)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189813017","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # [1,1,2,1,1,3,4,5,1,6]\n        # [1,1,5,6]\n        \n        stack = []\n        \n        for num in arr:\n            # 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\n            # 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\n            if stack and stack[-1] > num:\n                curr_max = stack[-1]\n                # 我们需要将融合后的区块的最大值重新放回栈\n                # 而 stack 是递增的，因此 stack[-1] 是最大的\n                while stack and stack[-1]>num:\n                    stack.pop()\n                # 维持栈的单调递增\n                stack.append(curr_max)\n            else:\n                stack.append(num)\n        # 栈存的是块信息，因此栈的大小就是块的数量\n        return len(stack)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191592348","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n\n        \n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        tail = head \n        n = 1\n        \n        while tail.next:\n            tail = tail.next\n            n+=1 # 找到尾结点\n        \n        # 尾结点连到头部\n        tail.next = head\n        \n        # 接下来找新的断点\n        \n        cut_off = head\n        for i in range(n-k%n-1):\n            cut_off = cut_off.next\n            \n        # 断掉之前记录下新head的值\n        head = cut_off.next\n        \n        cut_off.next = None\n            \n        return head\n        \n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192666045","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        # [1] [2] [3] [4]\n        # [2] [1] [4] [3]\n        dummy = ListNode(0,head)\n        \n        # [dummy]   [1]   [2]   [3]   [4]\n        #  temp    node1 node2\n        temp = dummy\n        \n        # 因为是两两交换，所以是 while temp.next and temp.next.next:\n        while temp.next and temp.next.next:\n            \n            #[dummy] 指向[2]的时候，会丢掉[1]的位置，所以要记住\n            # node_1 为 [1]\n            node_1 = temp.next\n            # node_2 为 [2]\n            node_2 = temp.next.next\n            \n            # [temp] 指向 [2]\n            temp.next = node_2\n            # [2] 指向 [1] 的时候， 会丢掉 [3] 的位置，所以要先让[1] 指向 [3]\n            node_1.next = node_2.next\n            # 把 [2] 指向 [1]\n            node_2.next = node_1\n            \n            # 现在是这样\n            #[dummy] [2] [1] [3] [4]\n            \n            # 把 temp 移动到 [1]\n            # [dummy] [2] [1]   [3]     [4]\n            #             temp node1 node2\n            temp = node_1\n            \n        return dummy.next\n            \n            \n            \n            ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194223557","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        if not head or not head.next:\n            return None\n        \n        slow = head\n        fast = head\n        \n        while fast is not None and fast.next is not None:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n        else:\n            return None\n            \n        fast = head\n        \n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        \n        return fast\n            \n        \n                \n                \n        \n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194969693","body":"class DoubleLinkedNode:\n    def __init__(self,key=None,val=None):\n        self.key = key\n        self.val = val\n        self.pre = None\n        self.next = None\n\nclass LRUCache:\n    # head 为最少使用的\n    # tail 为最近使用的\n\n    def __init__(self, capacity: int):\n        # initialize linked list\n        self.capacity = capacity\n        self.hashmap ={}\n        \n        self.head = DoubleLinkedNode()\n        self.tail = DoubleLinkedNode()\n        self.head.next = self.tail\n        self.tail.pre = self.head\n        \n    def remove_node(self,node):\n        node.pre.next = node.next\n        node.next.pre = node.pre\n        \n    def add_node_to_last(self,node):\n        self.tail.pre.next = node\n        node.pre = self.tail.pre\n        node.next = self.tail\n        self.tail.pre  = node\n        \n    def move_node_to_last(self,node):\n        self.remove_node(node)\n        self.add_node_to_last(node)\n        \n    def get(self, key: int) -> int:\n        if key not in self.hashmap:\n            return -1\n        node = self.hashmap[key]\n        self.move_node_to_last(node)\n        return node.val\n        \n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            node = self.hashmap[key]\n            node.val = value\n            self.move_node_to_last(node)\n            return \n        if len(self.hashmap) == self.capacity:\n            del self.hashmap[self.head.next.key]\n            self.remove_node(self.head.next)\n        node = DoubleLinkedNode(key,value)\n        self.hashmap[key] = node\n        self.add_node_to_last(node)\n                \n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196929807","body":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        \n        if not root:\n            return 0\n        left_max = self.maxDepth(root.left)\n        right_max= self.maxDepth(root.right)\n        max_depth = max(left_max,right_max) +1\n        \n        return max_depth","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1191779377","body":"### 思路\n把k本身作为carry number。对num进行循环，从右到左对num的每一位与k相加（k在这个过程中会去掉最右的一位），如果相加之后大于10，只保留个位数，其余的数assign给k，带给前面。之后k可能还会大于0，就插入到num的前部。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n      for (int i = num.size() - 1; i >= 0 && k > 0; i--) {\n        num[i] += k;\n        k = num[i] / 10;\n        num[i] %= 10;\n      }\n      \n      while (k > 0) {\n        num.insert(num.begin(), k % 10);\n        k /= 10;\n      }\n      \n      return num;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度 $O(n)$\n- 空间复杂度 $O(1)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186049958","body":"### 思路\n双向遍历。一个character离c最近距离只有两种情况，要么到左边的c，要么到右边的c。第一次遍历得出来每个character与其左边的c的距离（若出现在c之前，距离为s.size()）；第二次遍历得出来每个character与其右边的c的距离，取较小的那个。\n\n### 代码\n```lang-c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n      std::vector<int> distances(s.size());\n      if (s.size() <= 0) {\n        return distances;\n      }\n      \n      int len = s.size();\n      int curr = len;\n      \n      // left traversal\n      for (int i = 0; i < s.size(); i++) {\n        if (s[i] == c) {\n          curr = i;\n          distances[i] = 0;\n        } else {\n          distances[i] = std::min(len, std::abs(i - curr));\n        }\n      }\n      \n      // right traversal\n      for (int i = s.size() - 1; i >= 0; i--) {\n        if (s[i] == c) {\n          curr = i;\n        } else {\n          distances[i] = std::min(distances[i], std::abs(i - curr));\n        }\n      }\n      \n      return distances;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n) in which n is the size of string s.\n- 空间复杂度：O(1) if the return vector is not counted.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186258412","body":"### 思路\r\n使用vector来存储数据，使用单独一个变量来存储stack的size。\r\npush的时候，先检查当前vector的size是否小于stack size limit。然后把要插入的数放在vector的尾部。\r\npop的时候，先检查当前vector是否为空，返回-1如果为空。先暂存vector的back()，然后pop_back()，接着返回暂存的back()值，也就是stack后进先出（后进的数在vector尾部）。\r\nincrement的for循环要检查两个边界，一个是k，一个是vector的大小。\r\n\r\n### 代码\r\n```c++\r\nclass CustomStack {\r\nprivate:\r\n  std::vector<int> arr;\r\n  int stack_limit_;\r\n\r\npublic:\r\n    CustomStack(int maxSize) {\r\n      this->stack_limit_ = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n      if (arr.size() < this->stack_limit_) {\r\n        arr.push_back(x);\r\n      }\r\n    }\r\n    \r\n    int pop() {\r\n      if (arr.size() <= 0) {\r\n        return -1;\r\n      }\r\n      int back = arr.back();\r\n      arr.pop_back();\r\n      return back;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n      for (int i = 0; i < k; i++) {\r\n        if (i == arr.size()) {\r\n          break;\r\n        }\r\n        \r\n        arr[i] += val;\r\n      }\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：Constructor $O(1)$, push $O(1)$, pop() $O(1)$, increment $O(k)$ in which k stands for the number of elements need to increase.\r\n- 空间复杂度：One vector and one int used，therefore $O(n)$ in which $n$ stands for stack size.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186668073","body":"### 思路\n使用两个stack，一个存数字，一个存之前已经decode完成的部分。\n由于input是valid，只存在如下4中情况\n* digit: 存入stack1。需要注意超过9的数字，需要先暂存。\n* alphabet: 拼接到局部变量\n* `[`: 把数字和已经之前已经deocde的string放入各自stack\n* `]`: 此时当前括号内的string还没有被push到stack2，而需要重复的数字已经被push了，所以要从stack1取top值。然后需要把之前decode完成的部分取出来，拼接当前括号的内容。最后要把拼接好的string赋予局部变量，以备下一次push时候所用。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n      if (s.empty()) {\n        return s;\n      }\n      \n      std::string k;    // temp\n      std::string str;  // temp\n      std::stack<int> countStack;\n      std::stack<std::string> stringStack;\n      \n      for (auto& ch: s) {\n        if (isdigit(ch)) {\n          k += ch;\n        } else if (isalpha(ch)) {\n          str += ch;\n        } else if (ch == '[') {\n          countStack.push(std::stoi(k));\n          stringStack.push(str);\n          k = \"\";\n          str = \"\";\n        } else if (ch == ']') {\n          // get previously decoded, such as in 3[a]2[bc]\n          // second '[' push 'aaa' to stack, get them now\n          std::string decodedString = stringStack.top();\n          stringStack.pop();\n          \n          // str is not pushed to stack yet, but times is already pushed\n          for (int i = 0; i < countStack.top(); i++) {\n            decodedString += str;\n          }\n          countStack.pop();\n          \n          // remember the local variable\n          str = decodedString;\n        }\n      }\n      \n      return str;\n    }\n};\n```\n\n**复杂度分析**\nAssume $N$ is the length of input string.\n- 时间复杂度 $O(kN)$ such that $k$ is the maximum of digits in the input string.\n- 空间复杂度 $O(N)$ or $O(m+n)$ such that $m$ is the number of digits, $n$ is the number of alphabets and $m+n <= N$ since the existence of brackets.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188059775","body":"### 思路\n两个stack，一个“正序”，一个“逆序”，这样push的时候push到正序，pop的时候从逆序pop，这样就可以实现FIFO，两个stack各实现一半。\n\n### 代码\n```c++\nclass MyQueue {\n  std::stack<int> stack0;\n  std::stack<int> stackQ;\n  \npublic:\n    MyQueue() {}\n    \n    void push(int x) {\n      // move everything from stackQ to stack0\n      while (!stackQ.empty()) {\n        stack0.push(stackQ.top());\n        stackQ.pop();\n      }\n      \n      stack0.push(x);\n      \n      // move from stack0 to stackQ\n      while (!stack0.empty()) {\n        stackQ.push(stack0.top());\n        stack0.pop();\n      }\n    }\n    \n    int pop() {\n      if (stackQ.empty()) {\n        return -1;\n      }\n      \n      int ele = stackQ.top();\n      stackQ.pop();\n      return ele;\n    }\n    \n    int peek() {\n      if (stackQ.empty()) {\n        return -1;\n      }\n      \n      return stackQ.top();\n    }\n    \n    bool empty() {\n      return stackQ.empty();\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度 $O(1)$ for pop(), peek(), and empty(), $O(n)$ for push()\n- 空间复杂度 $O(n)$ since two stacks are used","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189460643","body":"### 思路\n找最大块的数量也就是找单调减连续数字的数量。比如 21355 就是 21 3 5 5，但如果是 213554 的话，就变成了 21 3 554，两个相同的数能不能分割取决于之后有没有数字。\n\n遇到一个大于栈顶的数字，就将其压入栈，当作是一个新chunk的开头，但是一旦后面遇到小的数字了，就要反过来检查前面的数字，不停的pop栈顶，看看这个更小的数字到底是小于那一个chunk的开头。\n\n最后stack的size就是chunk的数量。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n      std::stack<int> chunk;\n      for (auto ele: arr) {\n        int max = chunk.empty() ? ele : std::max(chunk.top(), ele);\n        while (!chunk.empty() && (chunk.top() > ele)) {\n          chunk.pop();\n        }\n        chunk.push(max);\n      }\n      \n      return chunk.size();\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度 $O(n)$\n- 空间复杂度 $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191092435","body":"### 思路\n由于k有可能大于linked list的长度，所以先遍历一遍linked list来得到长度，顺便把头尾相连。\n之后从头开始走，走n-(k%n)步，此时下一个节点就是head，然后断开连接即可。\n\n\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n      if (!head || !head->next) {\n        return head;\n      }\n      \n      ListNode* curr = head;\n      ListNode* res;\n      int n = 1;\n      \n      // get linked list length\n      while (curr->next != nullptr) {\n        n++;\n        curr = curr->next;\n      }\n      \n      k = n - (k % n);\n      curr->next = head; // circular\n      while (k--) {\n        curr = curr->next;\n      }\n      \n      res = curr->next;\n      curr->next = nullptr;\n      return res;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度 $O(n)$\n- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191809683","body":"### 思路\n可recursive，也可iterative。  \niterative方法中，使用prev指针来指向要swap的之前的node。使用first和second两个指针代指要swap的nodes，可以避免出现head->next->next这种很长的操作，而且可以更好理解。交换完first和second之后，prev指向swap前的first（也就是swap之后的第二个），head指向swap前的first的下一个（也就是swap之后的第二个的next）。\n\n\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n      ListNode dummy(-1);\n      dummy.next = head;\n      ListNode* prev = &dummy;\n      \n      while (head != nullptr && head->next != nullptr) {\n        ListNode* first = head;\n        ListNode* second = head->next;\n        \n        prev->next = second;\n        first->next = second->next;\n        second->next = first;\n        \n        // reset var\n        prev = first;\n        head = first->next;\n      }\n      \n      return dummy.next;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度 $O(n)$\n- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193053243","body":"### 思路\n先找中间节点\n\n### 代码\n```c++\nclass Solution {\npublic:\n  ListNode* findMiddle(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n    ListNode* prev = nullptr;\n    \n    while (slow && fast && fast->next) {\n      prev = slow;\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n    \n    return prev;\n  }\n  \n    TreeNode* sortedListToBST(ListNode* head) {\n      if (!head) return nullptr;\n      if (!head->next) return new TreeNode(head->val);\n      \n      // find the middle node, use it as the end of first list\n      ListNode* mid = findMiddle(head);\n      TreeNode* root = new TreeNode(mid->next->val);\n      \n      ListNode* second_head = (mid->next)->next;\n      mid->next = nullptr;\n      \n      root->left = sortedListToBST(head);\n      root->right = sortedListToBST(second_head);\n      \n      return root;\n    }\n};\n```\n\n### 复杂度\n- 时间复杂度 $O(nlogn)$\n- 空间复杂度 $O(logn)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193172895","body":"### 思路\n- Two pointer: 两个pointer来遍历两个linked list，当pointer为空的时候，指向另一个linked list的头部，这样两个pointer总会相遇\n- Hash table：hash table存储node的指针，先把一个linked list的所有node都存入，然后检查另一个linked list中第一个已在hash table的node，这就是intersection\n\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      ListNode* ptrA = headA;\n      ListNode* ptrB = headB;\n      \n      while (ptrA != ptrB) {\n        ptrA = (ptrA == nullptr) ? headB : ptrA->next;\n        ptrB = (ptrB == nullptr) ? headA : ptrB->next;\n      }\n      \n      return ptrA;\n    }\n};\n```\n\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      ListNode* ptrA = headA;\n      ListNode* ptrB = headB;\n      std::unordered_map<ListNode*, int> map;\n      while (ptrA != nullptr) {\n        map[ptrA]++;\n        ptrA = ptrA->next;\n      }\n      \n      while (ptrB != nullptr) {\n        if (map[ptrB] > 0) {\n          return ptrB;\n        }\n        ptrB = ptrB->next;\n      }\n      \n      return nullptr;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度 $O(m+n)$ such that $m$ and $n$ are the length of two linked lists\n- 空间复杂度 $O(1)$ for two pointers method, and $O(m)$ for hash table method such that $m$ is the length of one linked list","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193382264","body":"### 思路\n使用hash table来存储每个node的指针。\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n      if (head == nullptr || head->next == nullptr) {\n        return nullptr;\n      }\n      \n      ListNode* ptr = head;\n      std::unordered_map<ListNode*, int> map;\n      int i = 1;\n      while (ptr != nullptr) {\n        if (map[ptr] > 0) {\n          return ptr;\n        }\n        map[ptr] = i++;\n        ptr = ptr->next;\n      }\n      \n      return nullptr;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度 $O(n)$\n- 空间复杂度 $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194492427","body":"### 思路\n使用doubly-linked list来记录order和value，使用hash map来记录key和linked list的iterator。  \nput()时候，先检查key是否存在，若存在就直接更新order和value，若不存在先检查当前hash map的长度。如果LRU已经满了，就删除list的尾部和hash map对应的元素（list的尾部是key value pair，key可以拿来给hash map）；如果不满直接插入到list的头部，然后把list.begin()记录到hash map中。  \nget()时候，先检查key是否存在，如果存在就更新order，返回value，如果不存在，直接返回-1。\ntouch()可以更新order和value，本质上就是通过key来找到hash map中的iterator，然后删除list中的那个元素，再插入到list头部（这里可以更新value），将新的iterator记录到hash map中。\n\n### 代码\n\n```c++\nclass LRUCache {\n  int size;\n  std::list<std::pair<int, int>> list0; // maintaining used order\n  std::unordered_map<int, std::list<std::pair<int, int>>::iterator> map;\n  \npublic:\n    LRUCache(int capacity) {\n      this->size = capacity;\n    }\n  \n    /// update value and order. (remove it from tail, put it to head)\n    void touch(int key, int value) {\n      auto it = map[key];\n      list0.erase(it);\n      list0.push_front({key, value});\n      map[key] = list0.begin();\n    }\n    \n    int get(int key) {\n      if (map.find(key) != map.end()) {\n        int value = map[key]->second;\n        touch(key, value);\n        return value;\n      }\n      return -1;\n    }\n    \n    void put(int key, int value) {\n      if (map.find(key) != map.end()) {\n        // key exist, touch it\n        touch(key, value);\n        return;\n      }\n      \n      if (map.size() == this->size) {\n        int key = list0.back().first;\n        map.erase(key);\n        list0.pop_back();\n      }\n      list0.push_front({key, value});\n      map[key] = list0.begin();\n    }\n};\n​\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```\n\n### 复杂度分析\n- 时间复杂度 $O(1)$ for get() and put() since hash map records iterator, no need to traverse the linked list to find specific element.\n- 空间复杂度 $O(n)$ such that $n$ is the capacity of LRU (both linked list and hash map are of size $n$)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195995677","body":"### 思路\n递归。当前node为一层，取left child和right child的层数加一。递归函数的返回点为当前node为nullptr，则return 0\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n      if (root == nullptr) {\n        return 0;\n      }\n      \n      return 1 + std::max(maxDepth(root->left), maxDepth(root->right));\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度 O(n)\n- 空间复杂度 O(log n)，递归本身消耗存储空间，递归次数为tree的高度，即log n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197289845","body":"### 思路\n跟Day 13类似，若当前node都为空，直接返回true（return逻辑），若都不为空并且value相同，存储当前判定，与各自left和right的判断进行AND运算。\n\n### 代码\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n      if (p == nullptr && q == nullptr) {\n        return true;\n      }\n      \n      bool cmp_current = false;\n      if (p != nullptr && q != nullptr && p->val == q->val) {\n        cmp_current = true;\n      }\n        \n      return cmp_current && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度 $O(n)$\n- 空间复杂度 $O(log n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186080707","body":"##  思路\n### 扫描字符串字符 遇到等于c的 计算并设置c左边的距离 res[left],\n### 同时设置c右边的距离(在遇到下一个c之前的)res[right]\n### 取最短距离\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        \n        int[] res = new int[s.length()];\n        Arrays.fill(res,Integer.MAX_VALUE);\n        int start = 0;\n        for(int i = 0;i<s.length();i++){\n            if(s.charAt(i)==c){\n                res[i]=0;\n                int left = i-1;\n                while(left>=start){\n                    res[left]=Math.min(Math.abs(i-left),res[left]);\n                    left--;\n                }\n                int right = i+1;\n                while(right<s.length()&&s.charAt(right)!=c){\n                    res[right]=Math.abs(right-i);\n                    right++;\n                }                \n                start=i+1;\n            }\n                \n        }\n        return res;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186388835","body":"#### 思路\n##### 数组实现\n```Java\nclass CustomStack {\n    int maxSize;  //定值\n    int size;\n    int[] arr;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        size = 0;        \n        arr = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (size > 0 && size >= maxSize) return;\n        arr[size++]=x;\n    }\n\n    public int pop() {\n        if (size > 0) {\n            int t = arr[size-1];\n            arr[size-1]=0;\n            size--;\n            return t;\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        for(int i = 0;i<size && i<k; i++){\n            arr[i]=arr[i]+val;\n        }\n    }\n}\n```\n复杂度 increment时间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186731570","body":"### 思路\r\n### 递归搜索  \r\n```java\r\nclass Solution {\r\n     int i  = 0;\r\n    public String decodeString(String s) {\r\n        \r\n        return dfs(s,0);\r\n    }\r\n   String dfs(String s, int curr) {\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        //i设置成全局变量\r\n        for ( i = curr; i < s.length(); i++) {\r\n            if (Character.isDigit(s.charAt(i))) {\r\n                int num = 0, k = i;\r\n                //拼数字\r\n                while (k < s.length() && Character.isDigit(s.charAt(k))) {\r\n                    num = 10 * num + (s.charAt(k) - '0');\r\n                    k++;\r\n                }\r\n                i = k;\r\n                if (s.charAt(i) == '[') {\r\n                    //这里dfs返回时 i已经更新了（来到了‘]’的位置了），\r\n                    //如果还使用当前局部变量会造成重复，所以需要全局变量 跳出当前循环\r\n                    String a = dfs(s, i + 1);\r\n                    //拼串\r\n                    for (int b = 0; b < num; b++)\r\n                            sb.append(a);\r\n                }\r\n\r\n            } else if (s.charAt(i) == ']') { \r\n                return sb.toString();\r\n            } else\r\n                sb.append(s.charAt(i));\r\n        }\r\n        return sb.toString();\r\n\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188496223","body":"### 思路\r\n#### 模拟\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> first;\r\n    Stack<Integer> second;\r\n    int size ;\r\n\r\n    public MyQueue() {\r\n        first = new Stack<>();\r\n        second = new Stack<>();\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        first.push(x);\r\n        size++;\r\n    }\r\n    \r\n    public int pop() {\r\n        int res = -1;\r\n        if(!empty()){\r\n            while(!first.isEmpty()){\r\n                second.push(first.pop());                \r\n            }\r\n            res = second.pop();            \r\n            while(!second.isEmpty()){\r\n                first.push(second.pop());\r\n            }\r\n            size--;\r\n            return res;            \r\n        }\r\n        return res;\r\n    }\r\n    \r\n    public int peek() {\r\n        int res = -1;\r\n        if(!empty()){\r\n            while(!first.isEmpty()){\r\n                second.push(first.pop());                \r\n            }\r\n            res = second.peek();            \r\n            while(!second.isEmpty()){\r\n                first.push(second.pop());\r\n            }\r\n            \r\n            return res;            \r\n        }\r\n        return res;\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return size>0?false:true;\r\n    }\r\n}\r\n```\r\n### 时间复杂度 O(n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189929060","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] sortArr = arr.clone();\r\n        Arrays.sort(sortArr);\r\n        int tmpSub = 0;\r\n        int ans = 0;\r\n        for (int i = 0; i < arr.length; i++) {\r\n            tmpSub += arr[i] - sortArr[i];\r\n            if (tmpSub == 0) {\r\n                ans++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190990311","body":"### 思路\r\n#### 首尾连接找分割点\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return head;\r\n        int len = 0;\r\n        ListNode curr = head, pre = curr;\r\n        while (curr != null) {\r\n            len++;\r\n            pre = curr;\r\n            curr = curr.next;\r\n        }\r\n\r\n        int start = k % len;\r\n        if (start == 0) return head;\r\n        //首尾连接\r\n        pre.next = head;\r\n        //分割位置\r\n        int split = len - start;        \r\n        pre = head;\r\n        ListNode startNode = head;\r\n        while (split-- > 0) {\r\n            pre = startNode;\r\n            startNode = startNode.next;\r\n        }\r\n        //分割\r\n        pre.next = null;\r\n        return startNode;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192234467","body":"### 解题思路\r\n#### 创建虚节点指向head ，移动指针curr 指向虚节点 对接下来两个节点交换\r\n### 代码\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head==null||head.next==null) return head;\r\n        ListNode dummy = new ListNode(-1,head);\r\n        ListNode curr  =dummy;\r\n        while(curr.next!=null&&curr.next.next!=null){\r\n           ListNode n1 = curr.next,n2 = n1.next;\r\n           curr.next = n2;\r\n           n1.next = n2.next;\r\n           curr = n1;\r\n           n2.next = n1; \r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193056747","body":"### 解题思路\r\n使用快慢指针找到中点 该点即为root节点 继续分为两部分递归\r\n\r\n### 代码\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) return null;\r\n        return getTreeNode(head, null);\r\n    }\r\n    TreeNode getTreeNode(ListNode head, ListNode tail) {\r\n        if(head==tail) return null;\r\n        ListNode low = head, fast = head;\r\n        while (fast != tail && fast.next != tail) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            low = low.next;\r\n        }\r\n\r\n        TreeNode root = new TreeNode(low.val);\r\n        root.left = getTreeNode(head, low);\r\n        root.right = getTreeNode(low.next, tail);\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193236423","body":"### 解题思路\r\na+c+b  = b+c+a;\r\n\r\n### 代码\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode a = headA,b = headB;\r\n        int count =0;\r\n        while(a != b){\r\n            if(a.next==null){\r\n                a=headB;\r\n                count++;\r\n            }else\r\n                a= a.next;                \r\n            if(b.next==null){\r\n                b=headA;\r\n                count++;\r\n            }else\r\n                b= b.next;\r\n            if(count>2) return null;\r\n        }\r\n        return a;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(n+m)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193997390","body":"### 解题思路\r\n用set过滤\r\n\r\n### 代码\r\n\r\n```java\r\n\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        Set<ListNode> set = new HashSet<>();\r\n        ListNode tmp = head;\r\n        if(tmp==null) return null;\r\n        while(tmp.next != null){\r\n            if(!set.add(tmp)) return tmp;\r\n            tmp=tmp.next;            \r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1192658695","body":"# 思路 \n\n将K每次除以10，从右往左依次相加即可。需要注意的几种情况有： \n\n1. 无论是k的最高位，还是num数组的第0位，相加后产生进位\n2. k的位数大于num\n\n# 代码\n\n```Go\n\nfunc addToArrayForm(num []int, k int) []int {\n    var n = -1\n    var c = 0\n    var i = len(num) - 1\n    var ret = make([]int, 0, len(num))\n\n    for k != 0 || c != 0{\n        n = k % 10\n        k /= 10\n\n        n += c\n        c = 0\n        if i >= 0 {\n            num[i] += n\n            c = num[i] / 10\n            num[i] %= 10\n            i--\n        } else {\n            c = n / 10\n            n %= 10\n            ret = append([]int{n}, ret...)\n        }\n    }\n\n    if c != 0 {\n        ret = append([]int{c}, ret...)\n    }\n\n    if len(ret) == 0 {\n        return num\n    }\n    return append(ret, num...)\n}\n\n```\n\n# 复杂度  \n\n1. 时间复杂度：从右往左依次相加，每个位数处理一次，因此总时间复杂度为O(n)。代码中，也可以把超出num位数的数字直接添加到数组中，最后再交换一下顺序，这样时间复杂度肯定就是O(n)了\n2. 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186102380","body":"# 思路 \n暴力求解，先找出所有的c在s中的索引，然后依次计算s中每个字符与c的距离  \n\n# 代码\n```Go\nfunc shortestToChar(s string, c byte) []int {\n\tvar cIdx []int\n\tvar ret []int\n\n\tinitCIdx := func() {\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tif s[i] == c {\n\t\t\t\tcIdx = append(cIdx, i)\n\t\t\t}\n\t\t}\n\t}\n\n\tgetDistance := func(idx int) int {\n\t\tmin := math.MaxInt32\n\t\tfor _, ii := range cIdx {\n\t\t\ttmp := int(math.Abs(float64(ii - idx)))\n\t\t\tif tmp < min {\n\t\t\t\tmin = tmp\n\t\t\t}\n\t\t}\n\t\treturn min\n\t}\n\n\tinitCIdx()\n\tfor i := 0; i < len(s); i++ {\n\t\tret = append(ret, getDistance(i))\n\t}\n\n\treturn ret\n}\n``` \n\n# 复杂度\n- 时间复杂度：O(NK)，K为c在s中的个数，N为s的长度  \n- 空间复杂度：O(K)，K为c在s中的个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1191456606","body":"### 思路\n\n若每次调用Increment函数的时候，都直接把val加到栈中的元素，则时间复杂度为O(MN)，\nM为调用次数，N为栈长度。因此，为了优化Increment的效率，就需要避免此操作。  \n\n实际上，我们并不需要每次都把val加到栈中元素中，因为只有执行出栈操作时，才需要\n知道栈元素的最终值是多少。因此，我们增加一个辅助数组，用于记录每次执行Increment\n函数时传入的val，当出栈操作时，将栈顶元素加上辅助数组中对应位置的值，即得到最\n终的结果。\n\n\n### 代码\n\n\n```Go\ntype CustomStack struct {\n\tdata []int\n\tadd  []int\n\tidx  int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{data: make([]int, maxSize), add: make([]int, maxSize), idx: 0}\n}\n\nfunc (this *CustomStack) Push(x int) {\n\tif this.hasSpace() {\n\t\tthis.data[this.idx] = x\n\t\tthis.idx++\n\t}\n}\n\nfunc (this *CustomStack) Pop() int {\n\tif !this.hasElement() {\n\t\treturn -1\n\t}\n\n\tthis.idx--\n\telement := this.data[this.idx] + this.add[this.idx]\n\n\tif this.idx > 0 {\n\t\tthis.add[this.idx-1] += this.add[this.idx]\n\t}\n\tthis.add[this.idx] = 0\n\n\treturn element\n}\n\nfunc (this *CustomStack) Increment(k int, val int) {\n\t// for i := 0; i < this.idx && i < k; i++ {\n\t// this.data[i] += val\n\t// }\n\tif !this.hasElement() {\n\t\treturn\n\t}\n\n\tif k >= this.idx {\n\t\tthis.add[this.idx-1] += val\n\t} else {\n\t\tthis.add[k-1] += val\n\t}\n}\n\nfunc (this *CustomStack) hasSpace() bool {\n\treturn this.idx < cap(this.data)\n}\n\nfunc (this *CustomStack) hasElement() bool {\n\treturn this.idx > 0\n}\n\n\n```\n\n**复杂度分析**  \n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1190361693","body":"### 思路\n\n双栈实现，其中一个栈用于出队操作时的辅助操作\n\n### 代码\n\n```Go\ntype MyQueue struct {\n\tinput *MyStack\n\toutput *MyStack\n}\n\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tinput: new(MyStack),\n\t\toutput: new(MyStack),\n\t}\n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n\tthis.input.Push(x)\n}\n\n\nfunc (this *MyQueue) Pop() int {\n\t// 题目保证不会在空的栈上面调用pop/peek\n\tif this.output.IsEmpty() {\n\t\tthis.inputToOutput()\n\t}\n\treturn this.output.Pop()\n}\n\n\nfunc (this *MyQueue) Peek() int {\n\tif this.output.IsEmpty() {\n\t\tthis.inputToOutput()\n\t}\n\treturn this.output.Peek()\n}\n\n\nfunc (this *MyQueue) Empty() bool {\n\tif this.input.Size() != 0 || this.output.Size() != 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (this *MyQueue) inputToOutput() {\n\tfor !this.input.IsEmpty() {\n\t\tthis.output.Push(this.input.Pop())\n\t}\n}\n\ntype MyStack struct {\n\tdata []int\n}\n\nfunc (receiver *MyStack) Pop() int {\n\tif receiver.IsEmpty() {\n\t\treturn -1\n\t}\n\t\n\tv := receiver.data[len(receiver.data) - 1]\n\treceiver.data = receiver.data[:len(receiver.data) - 1]\n\treturn v\n}\n\nfunc (receiver *MyStack) Peek() int {\n\tif receiver.IsEmpty() {\n\t\treturn -1\n\t}\n\t\n\treturn receiver.data[len(receiver.data) - 1]\n}\n\nfunc (receiver *MyStack) Push(v int) {\n\treceiver.data = append(receiver.data, v)\n}\n\nfunc (receiver *MyStack) Size() int {\n\treturn len(receiver.data)\n}\n\nfunc (receiver *MyStack) IsEmpty() bool {\n\treturn len(receiver.data) == 0\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)。出栈时，最坏情况下是O(n)，但是之后的n个元素出栈是O(1)，从而平摊下来是O(1)\n- 空间复杂度：O(n)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190353117","body":"### 思路\n\n想要分块排序后的序列与直接排序后的序列一致，那么必须满足条件： \n>**从左往右看，后面的块的最小值，要大于等于前面块的最大值**  \n\n那么，第一个块的最大值在哪里呢？ 可以设定为数组0号位置的值。据此，可以从1号位置往右遍历，找到最后一个小于0号位置的值的位置，从而得到第一个块的起止区间。\n\n以此类推，就可以得到所有块。  \n\n以上算法有一个最大的问题就是：每个块的最后一个位置，不遍历整个数组就无法得到。所以，要想得到一个时间复杂度比较合理的算法，就必须解决此问题。  \n\n根据题目的标签，可以使用单调栈来解决，具体来讲，是单调递增栈，算法如下：\n\n1. 初始时，将0号位置的值入栈，并从1号位置开始往右遍历 \n2. 判断当前遍历得到的元素，若该值大于等于栈顶元素，则直接入栈，否则转第3步\n3. 栈内元素依次出栈，直到新的栈顶元素的值大于等于该值\n4. 取下一个值并转2处理\n\n### 代码\n\n\n```Go\nfunc maxChunksToSorted(arr []int) int {\n\tvar cache []int\n\tfor _, item := range arr {\n\t\tlastIdx := len(cache) - 1\n\t\tif len(cache) != 0 && cache[lastIdx] > item {\n\t\t\tmax := cache[lastIdx]\n\t\t\tfor ; lastIdx >= 0; lastIdx-- {\n\t\t\t\tif cache[lastIdx] <= item {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tcache = append(cache[:lastIdx + 1], []int{max}...)\n\t\t} else {\n\t\t\tcache = append(cache, item)\n\t\t}\n\t}\n\treturn len(cache)\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)，出现在顺序递增序列时","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191410520","body":"### 思路\n\n当旋转的次数与链接长度相等时，效果等同于未旋转。因此，旋转的次数需要对链表长度取余，然后再旋转即可 \n\n\n### 代码\n\n\n```Go\nfunc rotateRight(head *ListNode, k int) *ListNode {\n\tif head == nil {return head}\n\n\tvar listLen int\n\tvar p1 = head\n\tfor p1 != nil {\n\t\tlistLen++\n\t\tp1 = p1.Next\n\t}\n\n\tdiff := k % listLen\n\tif diff == 0 {\n\t\treturn head\n\t}\n\tp2 := head\n\tp1 = head\n\tfor i := 0; i < diff; i++ {\n\t\tp1 = p1.Next\n\t}\n\tfor p1.Next != nil {\n\t\tp1 = p1.Next\n\t\tp2 = p2.Next\n\t}\n\n\tnewHead := p2.Next\n\tp2.Next = nil\n\tp1.Next = head\n\treturn newHead\n}\n\n\n```\n\n**复杂度分析**  \n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192616321","body":"# 算法\n递归\n\n# 代码 \n\n```Go  \n\nfunc swapPairs(head *ListNode) *ListNode {\n\t// 1 -> 2 -> 3 -> 4\n\t// 1 -> 2 -> 3\n\t// 1 -> 2\n\tif head == nil || head.Next == nil {\n\t\treturn head\n\t}\n\n\tp := head.Next\n\thead.Next = swapPairs(p.Next)\n\tp.Next = head\n\treturn p\n}\n\n```\n\n# 复杂度  \n\n- 时间复杂度O(n)  \n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193048220","body":"# 思路  \n\nBST在垂直方向上的投影刚好是一个有序的数组，而题目给定的也是一个有序的数组。因此，在给定数组时，只需要取数组中间的值，即得到根节点，进而也得到左子树和右子树。再对左子树和右子树进行同样的操作，就得到最终的结果。\n\n# 代码  \n\n```Go\n\nfunc sortedListToBST(head *ListNode) *TreeNode {\n\tvar buildBST func([]int) *TreeNode\n\tbuildBST = func(data []int) *TreeNode {\n\t\tif data == nil || len(data) == 0 {return nil}\n\n\t\trootIdx := len(data) / 2\n\t\troot := &TreeNode{Val: data[rootIdx]}\n\t\tif rootIdx > 0 {\n\t\t\troot.Left = buildBST(data[:rootIdx])\n\t\t}\n\t\tif rootIdx < len(data) - 1 {\n\t\t\troot.Right = buildBST(data[rootIdx + 1:])\n\t\t}\n\n\t\treturn root\n\t}\n\n\tvar arr []int\n\tfor head != nil {\n\t\tarr = append(arr, head.Val)\n\t\thead = head.Next\n\t}\n\treturn buildBST(arr)\n}\n\n```\n\n# 复杂度  \n\n1. 时间复杂度：O(n)\n2. 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193243327","body":"# 思路  \n\n这个问题的核心在于：相遇时，两个指针走过的路径长度是相等的。那么，因为两个链接长度不相等，那么，要如何才能保证指针走过的路径相等呢？答案就是当某个指针走到最后一个节点之后，再继续从另外的那个链接继续遍历。这样，如果两个链接相交，肯定就会在相交的那个节相遇。\n\n# 代码  \n\n```Go\n\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    aa := headA\n    bb := headB\n    aaChg := false\n    bbChg := false\n\n    for {\n        for aa != nil && bb != nil {\n            if aa == bb {\n                return aa\n            }\n\n            aa = aa.Next\n            bb = bb.Next\n        }\n\n        if aaChg && bbChg {return nil}\n\n        if aa == nil {\n            aaChg = true\n            aa = headB\n        }\n        if bb == nil {\n            bbChg = true\n            bb = headA\n        }\n    }\n    return nil\n}\n\n```\n\n# 复杂度  \n\n1. 时间复杂度：O(n)\n2. 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194155707","body":"# 思路  \n\n这个题目总是看到，也是使用快慢指针，当两指针第一次相遇时让快指针再从头开始，步长为1，和慢指针同时前进，相遇时即为入口节点。其实这个证明一直也没有看太明白  \n\n# 代码  \n\n```Go\n\nfunc detectCycle(head *ListNode) *ListNode {\n    if head == nil {return nil}\n\n    slow, fast := head, head\n    for slow != nil && fast != nil {\n        slow = slow.Next\n        fast = fast.Next \n        if fast != nil {\n            fast = fast.Next\n        }\n\n        if slow == fast {\n            break\n        }\n    }\n\n    if slow != fast || fast == nil { return nil }\n\n    fast = head\n    for slow != fast {\n        slow = slow.Next\n        fast = fast.Next\n    }\n    return fast\n}\n\n```\n\n# 复杂度  \n1. 时间复杂度：O(n)\n2. 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195614351","body":"# 思路  \n\nLRU通常需要有一个缓存用来保存数据，一个链表用来保存数据的新鲜度，链表头表示最近访问的元素，尾表示最久远时间访问的元素。\n\n根据题目的实际情况，可以使用整数数组来做为缓存，下标即为key，所以，查找到数据是很容易的。查找到数据之后，还需要把该数据从链表的某个位置移到链表头，这涉及到链表的查找操作。而链表的查找操作，一般是O(n)的，想要达到O(1)的时间复杂度，需要一个辅助的数据结构，能够根据数据的key值，在O(1)的时间内查找到该数据在链表中的位置。在可选的数据结构中，map可以达到这种效率。  \n\n# 代码  \n\n```Go\n\ntype LRUCache struct {\n\tcache []int\n\tused *list.List\n\ttoUsed map[int]*list.Element\n\tcap int\n\tlen int\n}\n\nconst MaxCacheNum = 10000\nconst NotFound = -1\n\nfunc Constructor(capacity int) LRUCache {\n\tcache := LRUCache{\n\t\tcache: make([]int, MaxCacheNum),\n\t\tused:  list.New(),\n\t\ttoUsed: make(map[int]*list.Element, 0),\n\t\tcap: capacity,\n\t\tlen: 0,\n\t}\n\tfor i := 0; i < MaxCacheNum; i++ {\n\t\tcache.cache[i] = -1\n\t}\n\treturn cache\n}\n\nfunc (this *LRUCache) Get(key int) int {\n\tvalue := this.cache[key]\n\tif value != NotFound {\n\t\tthis.access(key)\n\t}\n\treturn value\n}\n\nfunc (this *LRUCache) Put(key int, value int)  {\n\texist := this.cache[key]\n\tif exist != NotFound {\n\t\tthis.cache[key] = value\n\t\tthis.access(key)\n\t\treturn\n\t}\n\t // 不存在，需要判断是否溢出\n\tif this.len + 1 > this.cap {\n\t\tr := this.used.Remove(this.used.Back()).(int)\n\t\tdelete(this.toUsed, r)\n\t\tthis.cache[r] = -1\n\t\tthis.len--\n\t}\n\n\tthis.cache[key] = value\n\tthis.len++\n\tthis.access(key)\n\treturn\n}\n\nfunc (this *LRUCache) access(key int) {\n\tptr, ok := this.toUsed[key]\n\tif ok {\n        this.used.MoveToFront(ptr)\n\t\treturn\n\t}\n\tthis.used.PushFront(key)\n\tthis.toUsed[key] = this.used.Front()\n}\n\n```\n\n# 复杂度  \n1. 时间复杂度：O(1)\n2. 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196860535","body":"# 思路  \n\n直接递归即可\n\n# 代码\n\n```Go\n\nfunc maxDepth(root *TreeNode) int {\n    if root == nil {return 0}\n    return 1 + max(maxDepth(root.Left), maxDepth(root.Right))\n}\n\nfunc max(i, j int) int {\n    if i >= j {return i}\n    return j\n}\n\n```\n\n# 复杂度  \n1. 时间复杂度：O(n)\n2. 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1189813947","body":"\r\n\r\n\r\n\r\n\r\n```python\r\ndef list_number(a_list, k):\r\n    a_num = []\r\n    for i in a_list:\r\n        a_num.append(str(i))\r\n    b_num = \"\".join(a_num)\r\n    a_number = int(b_num)\r\n    a_k = a_number + k\r\n    c_num = []\r\n    while(a_k > 10):\r\n        c_num.append(a_k % 10)\r\n        a_k = a_k // 10\r\n    c_num.append(a_k)\r\n    c_num.reverse()\r\n    return c_num\r\n```\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186121556","body":"# Day02\r\n---\r\n## \tSolution1\r\n---\r\n### 使用语言 Python\r\n---\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        index_list = []\r\n        for index, value in enumerate(s):\r\n            if value == c:\r\n                index_list.append(index)\r\n        # print(index_list)\r\n        distance_list = []\r\n        for index, value in enumerate(s):\r\n            temp_list = []\r\n            for i in index_list:\r\n                temp_list.append(abs(index - i))\r\n            # print(temp_list)\r\n            distance_list.append(min(temp_list))\r\n            # print(distance_list)\r\n        return distance_list\r\n```\r\n时间复杂度：O(n^2)\r\n空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186390157","body":"# Day03\r\n---\r\n## 使用语言： Python\r\n---\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.a_list = [] * self.maxSize\r\n        self.numPop = 0\r\n        self.len_a = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        self.len_a = len(self.a_list)\r\n        if self.len_a < self.maxSize:\r\n            self.a_list.append(x)\r\n\r\n    def pop(self) -> int:\r\n        self.len_a = len(self.a_list)\r\n        if len(self.a_list) == 0:\r\n            return -1\r\n        return self.a_list.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        self.len_a = len(self.a_list)\r\n        if k > self.len_a:\r\n            for i in range(self.len_a):\r\n                self.a_list[i] += val\r\n        else:\r\n            for i in range(k):\r\n                self.a_list[i] += val\r\n```\r\n---\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188648564","body":"# day 04\r\n---\r\n## 使用语言： Python\r\n---\r\n```python\r\nclass Solution:  \r\n  def decodeString(self, s: str) -> str:  \r\n  s_list = list(s)  \r\n  \r\n  a_list = []  \r\n  for index, value in enumerate(s_list):  \r\n  if value != ']':  \r\n  a_list.append(value)  \r\n  else:  \r\n  right = len(a_list)  \r\n  left = \"\".join(a_list).rfind('[')  \r\n  left_left = left - 2  \r\n  num_left_left = a_list[left_left]  \r\n  \r\n  while(48 <= ord(num_left_left) <= 57):  \r\n  if left_left != 0:  \r\n  left_left -= 1  \r\n  num_left_left = a_list[left_left]  \r\n  else:  \r\n  left_left -= 1  \r\n  break  \r\n  int_num = 1  \r\n  int_num = \"\".join(a_list[left_left+1:left])  \r\n  ss = a_list[left + 1:right] * int(int_num)  \r\n  a_list[left_left+1:right + 1] = \"\"  \r\n  # print(a_list)  \r\n  for i in ss:  \r\n  a_list.append(i)  \r\n  s_list = s_list[:left - 1] + s_list[right + 1:]  \r\n  # print(s_list)  \r\n  \r\n  return \"\".join(a_list)\r\n```\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(3n)$\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188646161","body":"# day 05\r\n---\r\n## 使用语言： Python\r\n---\r\n```python\r\nclass MyQueue:  \r\n  \r\n  def __init__(self):  \r\n  self.myQue = list()  \r\n  \r\n  def push(self, x: int) -> None:  \r\n  self.myQue.append(x)  \r\n  # print(self.myQue)  \r\n  \r\n  def pop(self) -> int:  \r\n  temp = self.myQue[0]  \r\n  del self.myQue[0]  \r\n  return temp  \r\n  \r\n    def peek(self) -> int:  \r\n  return self.myQue[0]  \r\n  \r\n  def empty(self) -> bool:  \r\n  return False if len(self.myQue) else True\r\n```\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190089322","body":"# day06\r\n---\r\n## 使用语言： Python\r\n---\r\n```python\r\nclass Solution:  \r\n\tdef maxChunksToSorted(self, arr: List[int]) -> int:  \r\n\t\tstart_index, max_index, end_index = 0, 0, 0  \r\n\t\tc_list = []  \r\n\t    len_arr = len(arr)  \r\n\t    while start_index <= len_arr-1:  \r\n\t\t\tend_index = start_index  \r\n            max_index = start_index  \r\n            if start_index == (len_arr-1):  \r\n\t\t\t\tc_list.append(arr[start_index])  \r\n\t\t\t\tbreak  \r\n\t\t    for index, value in enumerate(arr[start_index+1:]):  \r\n\t\t\t\tif arr[start_index] > value:  \r\n\t\t\t\t\tend_index = index+start_index+1  \r\n            max_number = max(arr[start_index:end_index + 1])  \r\n            max_index_temp = arr[start_index:end_index + 1].index(max_number)+ start_index  \r\n            while max_index != max_index_temp:  \r\n\t\t\t\tmax_index = max_index_temp  \r\n                end_index_temp = end_index  \r\n                for iindex, ivalue in enumerate(arr[(end_index+1):]):  \r\n\t\t\t\t\tif arr[max_index_temp] > ivalue:  \r\n\t\t\t\t\t\tend_index_temp = iindex + end_index+1  \r\n\t\t\t\t\tend_index = end_index_temp  \r\n\t\t\t        max_index_temp = arr[start_index:end_index + 1].index(max(arr[start_index:end_index + 1]))  \r\n\t\t\tif end_index == start_index:  \r\n\t\t\t\tc_list.append(arr[start_index])  \r\n\t\t\telse:  \r\n\t\t\t\tc_list.append(arr[start_index:end_index + 1])  \r\n\t\t\tstart_index = end_index + 1  \r\n\t\t# print(c_list)  \r\n\t\treturn(len(c_list))\r\n```\r\n时间复杂度：$O(n^3)$\r\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191080530","body":"# day07\r\n---\r\n## 使用语言：Python\r\n> 没有技巧，全是感情\r\n---\r\n```python\r\nfrom typing import Optional\r\n# Definition for singly-linked list.\r\n\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if head:\r\n            a_list = []\r\n            len_head = 1\r\n            real_k = 0\r\n            next_point = head.next\r\n            a_list.append(head.val)\r\n            while next_point:\r\n                a_list.append(next_point.val)\r\n                len_head += 1\r\n                next_point = next_point.next\r\n            real_k = k % len_head\r\n            # print(a_list)\r\n            b_list = [0 for i in range(len_head)]\r\n            for index, value in enumerate(a_list):\r\n                real_index = (real_k + index) % len_head\r\n                b_list[real_index] = value\r\n            # print(b_list)\r\n            L_head = ListNode(b_list[0])\r\n            cur = L_head\r\n            for i in range(1, len_head):\r\n                temp = ListNode(b_list[i])\r\n                cur.next = temp\r\n                cur = temp\r\n                if i == len_head - 1:\r\n                    cur.next = None\r\n\r\n            return L_head\r\n```\r\n---\r\n时间复杂度：$O(3n)$\r\n空间复杂度：$O(2n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1193260880","body":"# day08\r\n---\r\n## 使用语言：python\r\n---\r\n> 使用递归的方法解决问题\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        newHead = head.next\r\n        head.next = self.swapPairs(newHead.next)\r\n        newHead.next = head\r\n        return newHead\r\n```\r\n---\r\n时间复杂度:$O(n)$\r\n空间复杂度:$O(1)$\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146224","body":"# day09\r\n---\r\n## 使用语言： python\r\n---\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        return self.helper(head,None)\r\n\r\n    def helper(self,head,tail):\r\n        if head==tail:\r\n            return\r\n        slow=head\r\n        fast=head\r\n        while fast!=tail and fast.next!=tail:\r\n            slow=slow.next\r\n            fast=fast.next.next\r\n        root=TreeNode(slow.val)\r\n        root.left=self.helper(head,slow)\r\n        root.right=self.helper(slow.next,tail)\r\n        return root\r\n```\r\n时间复杂度： $O(n)$\r\n空间复杂度： $O(n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193319102","body":"# day10\r\n---\r\n## 使用语言：python\r\n---\r\n> 做题思路：利用交叉链表最后几个一定一样的特性，把headA和headB对齐之后，同时处理。\r\n---\r\n> 做题时长：一个半小时\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> None:\r\n        len_headA = 0\r\n        len_headB = 0\r\n        temp_headA = headA\r\n        while temp_headA:\r\n            len_headA += 1\r\n            temp_headA = temp_headA.next\r\n\r\n        temp_headB = headB\r\n        while temp_headB:\r\n            len_headB += 1\r\n            temp_headB = temp_headB.next\r\n\r\n        # print(len_headA)\r\n        # print(len_headB)\r\n        temp_headA = ListNode(0, headA)\r\n        temp_headB = ListNode(0, headB)\r\n        if not len_headA or not len_headB:\r\n            return None\r\n        else:\r\n            do_len = len_headA - len_headB if len_headA > len_headB else len_headB - len_headA\r\n            for i in range(do_len):\r\n                if len_headA < len_headB:\r\n                    temp_headB = temp_headB.next\r\n                else:\r\n                    temp_headA = temp_headA.next\r\n            do_circle = min(len_headB, len_headA)\r\n            for i in range(do_circle):\r\n                if temp_headB.next == temp_headA.next:\r\n                    return temp_headA.next\r\n                temp_headB = temp_headB.next\r\n                temp_headA = temp_headA.next\r\n        return None\r\n```\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193463553","body":"# day11\r\n---\r\n## 使用语言： Python\r\n---\r\n> 做题思路：把指针装进数组中，如果有重复的指针就返回这个指针\r\n---\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        \r\n        fast_point  = head\r\n        \r\n        new_point = ListNode(0, head)\r\n        \r\n        fast_point = new_point \r\n        \r\n        a_list = []\r\n        while fast_point.next:\r\n            if fast_point.next in a_list:\r\n                return fast_point.next\r\n            a_list.append(fast_point.next)\r\n            fast_point = fast_point.next\r\n```\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195449844","body":"class ListNode:\r\n    def __init__(self, key=None, value=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        # 新建两个节点 head 和 tail\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        # 初始化链表为 head <-> tail\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法\r\n    def move_node_to_tail(self, key):\r\n            # 先将哈希表key指向的节点拎出来，为了简洁起名node\r\n            #      hashmap[key]                               hashmap[key]\r\n            #           |                                          |\r\n            #           V              -->                         V\r\n            # prev <-> node <-> next         pre <-> next   ...   node\r\n            node = self.hashmap[key]\r\n            node.prev.next = node.next\r\n            node.next.prev = node.prev\r\n            # 之后将node插入到尾节点前\r\n            #                 hashmap[key]                 hashmap[key]\r\n            #                      |                            |\r\n            #                      V        -->                 V\r\n            # prev <-> tail  ...  node                prev <-> node <-> tail\r\n            node.prev = self.tail.prev\r\n            node.next = self.tail\r\n            self.tail.prev.next = node\r\n            self.tail.prev = node\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.hashmap:\r\n            # 如果已经在链表中了久把它移到末尾（变成最新访问的）\r\n            self.move_node_to_tail(key)\r\n        res = self.hashmap.get(key, -1)\r\n        if res == -1:\r\n            return res\r\n        else:\r\n            return res.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\r\n            # 但是需要更新字典该值对应节点的value\r\n            self.hashmap[key].value = value\r\n            # 之后将该节点移到末尾\r\n            self.move_node_to_tail(key)\r\n        else:\r\n            if len(self.hashmap) == self.capacity:\r\n                # 去掉哈希表对应项\r\n                self.hashmap.pop(self.head.next.key)\r\n                # 去掉最久没有被访问过的节点，即头节点之后的节点\r\n                self.head.next = self.head.next.next\r\n                self.head.next.prev = self.head\r\n            # 如果不在的话就插入到尾节点前\r\n            new = ListNode(key, value)\r\n            self.hashmap[key] = new\r\n            new.prev = self.tail.prev\r\n            new.next = self.tail\r\n            self.tail.prev.next = new\r\n            self.tail.prev = new\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196174306","body":"# day13\r\n---\r\n## 使用语言： python\r\n---\r\n> 还是不怎么会递归\r\n> 最后勉勉强强把递归理解成大问题看成小问题组合的思路做出来的。\r\n> 但是用递归遍历的那种思路，还是不懂\r\n```python\r\nclass  Solution:\r\n\tdef  maxDepth(self, root: Optional[TreeNode]) -> int:\r\n\t\tif root is  None:\r\n\t\t\treturn  0\r\n\t\tleft_num = self.maxDepth(root.left)\r\n\t\tright_num = self.maxDepth(root.right)\r\n\t\tres = max(left_num, right_num) + 1\r\n\treturn res\r\n```\r\n---\r\n时间复杂度：$O()$\r\n空间复杂度：$O()$\r\n\r\n---\r\n递归的这两个复杂度不会计算","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197505372","body":"# day14\r\n---\r\n## 使用语言：python\r\n---\r\n> 使用分解模式的递归思路解决问题\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not q and not p:\r\n            return True\r\n        elif not q or not p:\r\n            return False\r\n        \r\n        return q.val==p.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n时间复杂度:$O()$\r\n空间复杂度:$O()$\r\n> 涉及到递归之后的这两个复杂度我还是不会分析","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186160050","body":"## 代码\n---\n```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n*/\nvar shortestToChar = function(s, c) {\n    let len = s.length,\n        answer = new Array(len),\n        i = 0,\n        pre = -Infinity;\n\n    while (i < len) {\n        if (s[i] === c) {\n            answer[i] = 0;\n            pre = i;\n        } else {\n            let nextIdx = s.indexOf(c, i);\n            if (~nextIdx) {\n                while (i <= nextIdx) {\n                    answer[i] = Math.min(i - pre, nextIdx - i);\n                    ++i;\n                }\n                --i;\n                pre = i;\n            } else {\n                answer[i] = i - pre;\n            }\n        }\n        ++i;\n    }\n\n    return answer;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186441698","body":"## 代码\n---\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length) {\n        return this.stack.pop();\n    }\n    return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const max = Math.min(this.stack.length, k);\n    for (let i = 0; i < max; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186722440","body":"## 代码\n---\n```\n/**\n * @param {string} s\n * @return {string}\n*/\nconst numReg = /[0-9]/;\nconst charReg = /[a-z]/;\nvar decodeString = function(s) {\n    let i = 0,\n        len = s.length,\n        stack = [],\n        times = '',\n        ret = '';\n    while (i < len) {\n        const char = s[i];\n        if (charReg.test(char)) {\n            const last = stack[stack.length - 1];\n            if (last) {\n                last.letters += char;\n            } else {\n                ret += char;\n            }\n        }\n        if (numReg.test(char)) {\n            times += char;\n        }\n        if (char === '[') {\n            stack.push({\n                times,\n                letters: ''\n            });\n            times = '';\n        }\n        if (char === ']') {\n            let fragment = stack.pop();\n            let _times = Number(fragment.times) || 1;\n            fragment = fragment.letters.repeat(_times);\n\n            const last = stack[stack.length - 1];\n            if (last) {\n                last.letters += fragment;\n            } else {\n                ret += fragment;\n            }\n        }\n        ++i;\n    }\n    return ret;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188769819","body":"## 代码 \r\n---\r\n```\r\nvar MyQueue = function() {\r\n    this.queue = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    return this.queue.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.queue.shift();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.queue[0];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.queue.length <= 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189903866","body":"## 代码\n---\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    let stack = [];\n    for (let i = 0; i < arr.length; i++) {\n        const cur = arr[i];\n        const top = stack[stack.length - 1];\n        if (!stack.length || cur >= top) {\n            stack.push(cur);\n        } else if (cur < top) {\n            while (stack.length && cur < stack[stack.length - 1]) {\n                stack.pop();\n            }\n            stack.push(top);\n        }\n    }\n    return stack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191084844","body":"## 代码\n---\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n*/\nvar rotateRight = function(head, k) {\n    if (!head || !k) return head;\n    let nodes = [];\n\n    while (head) {\n        nodes.push(head);\n        let prev = head;\n        head = head.next;\n        if (head) {\n            head.prev = prev;\n        }\n    }\n    const len = nodes.length;\n    let idx = (len - k % len) % len;\n    \n    const node = nodes[idx];\n    if (node.prev) {\n        node.prev.next = null;\n        nodes[len - 1].next = nodes[0];\n    }\n    \n    return node;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192135949","body":"## 代码\n---\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n*/\nvar swapPairs = function(head) {\n    let slow = head, fast = head?.next;\n    head = fast || slow;\n\n    let prev = null;\n    while (slow && fast) {\n        const next = fast.next;\n        // 维护两个节点\n        slow.next = null;\n        fast.next = slow;\n\n        if (prev) {\n            prev.next = fast;\n        }\n\n        prev = slow;\n        slow = next;\n        fast = next?.next;\n    }\n\n    if (slow && !fast && prev) {\n        prev.next = slow;\n    }\n\n    return head;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193129263","body":"## 代码\n---\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n*/\nvar transferSortedArrayToTreeNode = (nodes) => {\n    if (!nodes || !nodes.length) return null;\n    let midIdx = nodes.length >> 1;\n    let midNode = new TreeNode(nodes[midIdx]);\n\n    const leftNodes = nodes.slice(0, midIdx);\n    const rightNodes = nodes.slice(midIdx + 1);\n\n    midNode.left = transferSortedArrayToTreeNode(leftNodes);\n    midNode.right = transferSortedArrayToTreeNode(rightNodes);\n\n    return midNode;\n}\nvar sortedListToBST = function(head) {\n    let nodes = [];\n    while (head) {\n        nodes.push(head.val);\n        head = head.next;\n    }\n    return transferSortedArrayToTreeNode(nodes);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193316305","body":"## 代码\n---\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n*/\nvar getIntersectionNode = function(headA, headB) {\n    while (headA || headB) {\n        if (headA) {\n            if (headA?.isPassed) {\n                return headA;\n            }\n            headA.isPassed = true;\n            headA = headA?.next;\n        }\n        if (headB) {\n            if (headB?.isPassed) {\n                return headB;\n            }\n            headB.isPassed = true;\n            headB = headB?.next;\n        }\n    }\n    return null;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193503642","body":"## 代码\r\n---\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    while (head) {\r\n        if (head.isPassed) {\r\n            return head\r\n        }\r\n        head.isPassed = true;\r\n        head = head.next;\r\n    }\r\n    return head;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1196403619","body":"## 代码\r\n```\r\n/**\r\n * @param {number} capacity\r\n*/\r\nvar LRUCache = function(capacity) {\r\n    this.cache = [];\r\n    this.capacity = capacity;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    let index = this.find(key);\r\n    if (~index) {\r\n        const item = this.cache.splice(index, 1)[0];\r\n        this.cache.push(item);\r\n        index = item.value;\r\n    }\r\n    return index;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.find = function(key) {\r\n    return this.cache.findIndex(item => item.key === key);\r\n}\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    const index = this.find(key);\r\n    if (~index) {\r\n        const item = this.cache.splice(index, 1)[0];\r\n        this.cache.push(item);\r\n        item.value = value;\r\n    } else {\r\n        if (this.cache.length === this.capacity) {\r\n            this.cache.shift();\r\n        }\r\n        this.cache.push({ key, value });\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196202020","body":"## 代码\r\n---\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n*/\r\nvar maxDepth = function(root) {\r\n    let dep = 0;\r\n    if (!root) return dep;\r\n    let length, stack = [root];\r\n    while (length = stack.length) {\r\n        let i = 0;\r\n        while (i < length) {\r\n            const node = stack.shift();\r\n            node?.left && stack.push(node.left);\r\n            node?.right && stack.push(node.right);\r\n            ++i;\r\n        }\r\n\r\n        dep++;\r\n    }\r\n\r\n    return dep;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186183254","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size();\r\n        vector<int> res;\r\n        for(int i=n-1; i>=0; i--){\r\n            int sum = num[i]  + k % 10;\r\n            k = k / 10;\r\n            if (sum >= 10){\r\n                k++;\r\n            }\r\n            res.push_back(sum % 10);\r\n        }\r\n        for(;k>0; k/=10){\r\n            res.push_back(k%10);\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n#### 时间复杂度：O(n)\r\n#### 空间复杂度： O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186169287","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ret;\r\n        int pre_idx = -10000;\r\n        for(int i=0; i<n; i++){\r\n            if (s[i] == c){\r\n                pre_idx = i;\r\n            }\r\n            ret.push_back(i - pre_idx);\r\n        }\r\n        pre_idx = 10001;\r\n        for (int i=n-1; i>=0; i--){\r\n            if (s[i] == c){\r\n                pre_idx = i;\r\n            }\r\n            ret[i] = min(pre_idx - i, ret[i]);\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```\r\n### 时间复杂度：O(N);\r\n### 空间复杂度：O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186270513","body":"```CPP\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stk;\r\n    vector<int> add;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        add = vector<int> (maxSize, 0);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top!=stk.size()-1){\r\n            top++;\r\n            stk[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1){\r\n            return -1;\r\n        } \r\n        int ret = stk[top] + add[top];\r\n        if (top != 0){\r\n            add[top-1] += add[top];\r\n        }\r\n        add[top] = 0;\r\n        top--;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int num = min(k-1, top);\r\n        if (num >= 0){\r\n            add[num] += val;\r\n        }\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186601192","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res = \"\";\r\n        int n = s.size();\r\n        int count = 0;\r\n        stack<int> nums;\r\n        stack<string> str_stk;\r\n        for(int i=0;i<n; i++){\r\n            char ch = s[i];\r\n            if (ch >= '0' && ch <= '9'){\r\n                count = count * 10 + (ch - '0');\r\n            } else if (ch == '['){\r\n                nums.push(count);\r\n                str_stk.push(res);\r\n                count = 0;\r\n                res = \"\";\r\n            } else if (ch == ']'){\r\n                for(int j=0; j<nums.top(); j++){\r\n                    str_stk.top() += res;\r\n                }\r\n                nums.pop();\r\n                res = str_stk.top();\r\n                str_stk.pop();\r\n            } else {\r\n                res += ch;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189024707","body":"```CPP\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n    void in2out(){\r\n        while(!inStack.empty()){\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if (outStack.empty()){\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n        \r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (outStack.empty()){\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return (outStack.empty() && inStack.empty());\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193115529","body":"```CPP\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int len_list(ListNode* head){\r\n        int len = 0;\r\n        while(head!=nullptr){\r\n            len++;\r\n            head = head->next;\r\n        }\r\n        return len;\r\n    }\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        TreeNode* ret = construct_tree(head, 0, len_list(head));\r\n        return ret;\r\n    }\r\n    TreeNode* construct_tree(ListNode*& node, int start, int end){\r\n        if (end <= start) return nullptr;\r\n        int mid = start + (end - start) / 2;\r\n        TreeNode* root = new TreeNode();\r\n        root->left = construct_tree(node, start, mid);\r\n        root->val = node->val;\r\n        node = node->next;\r\n        root->right = construct_tree(node, mid+1, end);\r\n        return root;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186177862","body":"### 思路\r\n先从左到右遍历，记录左侧到最近c的距离\r\n\r\n从右到左，1，记录从右侧到最近c的距离,2，比较两个距离，取最小值\r\n\r\n### 代码\r\n\r\n```golang\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n:=len(s)\r\n    num :=make([]int, n)\r\n    idx:=-n\r\n    // 从左到右\r\n  for k,v:=range s{\r\n      if byte(v)==c{\r\n        idx=k\r\n      }\r\n    num[k]=k-idx\r\n  }\r\n    // 从右到左\r\n   idx=2*n\r\n  for i:=n-1;i>=0;i--{\r\n    if  s[i]== c{\r\n      idx=i\r\n    }\r\n    num[i]=min(num[i],idx-i)\r\n  }\r\n  return num\r\n}\r\n\r\nfunc min(a,b int) int{\r\n  if a>b {\r\n    return b\r\n  }\r\n  return a\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186396294","body":"### 思路\r\n用切片模拟栈操作\r\n\r\n### 代码\r\n```golang\r\n\r\ntype CustomStack struct {\r\n    maxSize int\r\n    stackLen int\r\n    val []int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    var num []int\r\n    customStack:=CustomStack{\r\n        maxSize: maxSize,\r\n        stackLen: 0,\r\n        val: num,\r\n    }\r\n    return  customStack\r\n    \r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if this.maxSize>this.stackLen{\r\n        // this.val[this.stackLen]=x\r\n      this.val= append(this.val,x)\r\n        this.stackLen++\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if this.stackLen==0{\r\n        return -1\r\n    }\r\n    last:=this.val[this.stackLen-1]\r\n    this.val=this.val[:this.stackLen-1]\r\n     this.stackLen--\r\n    return last\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k>=this.stackLen{\r\n        k=this.stackLen\r\n    }\r\n    for i:=0;i<k;i++{\r\n        this.val[i]+=val\r\n    }\r\n}\r\n\r\n```\r\n### 时空复杂度\r\n- 时间复杂度: push,pop 为O(1)\r\n- 空间复杂度：O(k)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189224374","body":"## 思路\r\n使用双栈，模拟队列增删改\r\n\r\n## 代码\r\n\r\n```golang\r\ngolang\r\n\r\ntype MyQueue struct {\r\n     inStack ,outStack []int\r\n}\r\n\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Push(x int)  {\r\n    this.inStack =append(this.inStack,x)\r\n}\r\n\r\nfunc (this *MyQueue)inToOut(){\r\n    for len(this.inStack)>0{\r\n        this.outStack = append(this.outStack,this.inStack[len(this.inStack)-1])\r\n        this.inStack = this.inStack[:len(this.inStack)-1]\r\n    }\r\n}\r\n\r\nfunc (this *MyQueue) Pop() int {\r\n    if len(this.outStack)==0{\r\n        this.inToOut()\r\n    }\r\n    op := this.outStack[len(this.outStack)-1]\r\n    this.outStack = this.outStack[:len(this.outStack)-1]\r\n    return op\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Peek() int {\r\n    if len(this.outStack)==0{\r\n        this.inToOut()\r\n    }\r\n    return this.outStack[len(this.outStack)-1]\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Empty() bool {\r\n   return len(this.outStack)==0&&len(this.inStack)==0\r\n}\r\n\r\n\r\n```\r\n\r\n## 时空复杂度\r\n- 时间复杂度： O(1)\r\n- 空间复杂度： O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192618445","body":"### 思路\r\n\r\n递归节点，亮亮交换\r\n\r\n### 代码\r\n ```golang\r\ngolang\r\n\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    if head==nil||head.Next==nil{\r\n        return head\r\n    }\r\n    nextNode := head.Next\r\n    head.Next = swapPairs(nextNode.Next)\r\n    nextNode.Next = head\r\n    return nextNode\r\n\r\n}\r\n\r\n```\r\n### 时空复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度; O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193281130","body":"### 思路\r\n遍历链表A，使用哈希存储。遍历链表B，查询哈希表中是否存在\r\n\r\n### 代码\r\n```\r\ngolang\r\n\r\n\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n    var nodeMap = make(map[*ListNode]int)\r\n    for temp:=headA;temp!=nil;temp=temp.Next {\r\n        nodeMap[temp] = 1\r\n    } \r\n    for arg:=headB;arg!=nil;arg=arg.Next{\r\n        if nodeMap[arg]>0{\r\n            return arg\r\n        } \r\n    }\r\n    return nil\r\n}\r\n```\r\n\r\n### 时空复杂度\r\n- 时间复杂度; O(n)\r\n- 空间复杂度：O(1)\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196558134","body":"### 思路\r\n\r\n采用递归出树的深度\r\n\r\n###  代码\r\n\r\n```\r\ngolang\r\n\r\nfunc maxDepth(root *TreeNode) int {\r\n    if root!=nil{\r\n        left:=maxDepth(root.Left)\r\n        right:=maxDepth(root.Right)\r\n        nodeLen:=right\r\n        if left>right{\r\n            nodeLen=left\r\n        }\r\n        return  nodeLen+1\r\n    } else{\r\n        return 0\r\n    }\r\n}\r\n```\r\n### 时空复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(height)，其中 \\textit{height}height 表示二叉树的高度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186181472","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> ans(n);\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = min(ans[i], idx - i);\n        }\n        return ans;\n    }\n};\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186481890","body":"class CustomStack {\npublic:\n    int cnt = 0;\n    int maxsize = 0;\n    vector<int> s;\n    CustomStack(int maxSize) {\n        maxsize = maxSize;\n        cnt = 0;\n    }\n    \n    void push(int x) {\n        if (cnt < maxsize ) {\n            s.push_back(x);\n            cnt++;\n        }\n    }\n    \n    int pop() {\n        if (cnt == 0)return -1;\n        int t = s[cnt-1];\n        s.pop_back();\n        cnt--;\n        return t;\n        \n    }\n    \n    void increment(int k, int val) {\n        if (cnt < k) k = cnt;\n        for (int i = 0;i < k;i++) {\n            s[i] += val;\n        }  \n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187515123","body":"class Solution {\npublic:\n    string decodeString(string s) {\n        int i = 0;\n        return decode(s, i);\n    }\n    string decode(string s, int& i) {\n        string res = \"\";\n        int n = s.size();\n        while (i < n && s[i] != ']') {\n            if (s[i] < '0' || s[i] > '9') {\n                res += s[i++];\n            } else {\n                int cnt = 0;\n                while (s[i] >= '0' && s[i] <= '9') {\n                    cnt = cnt * 10 + s[i++] - '0';\n                }\n                ++i;\n                string t = decode(s, i);\n                ++i;\n                while (cnt-- > 0) {\n                    res += t;\n                }\n            }\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188974416","body":"class MyQueue {\npublic:\n    stack<int>out;\n    stack<int>in;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        in.push(x);\n    }\n    \n    int pop() {\n        while (out.empty()) {\n            while (!in.empty()) {\n                int x = in.top();\n                in.pop();\n                out.push(x);\n            }\n        }\n        int t = out.top();\n        out.pop();\n        return t;\n    }\n    \n    int peek() {\n        int t = this->pop();\n        out.push(t);\n        return t;\n    }\n    \n    bool empty() {\n        return in.empty()&&out.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190400807","body":"var maxChunksToSorted = function (arr) {\n  let sum1 = 0;\n  let sum2 = 0;\n  let ans = 0;\n  let arr2 = [...arr].sort((a, b) => a - b);\n  for (let i in arr) {\n    sum1 = sum1 + arr[i];\n    sum2 = sum2 + arr2[i];\n    if (sum1 == sum2) {\n      ans += 1;\n      sum1 = 0;\n      sum2 = 0;\n    }\n  }\n  return ans;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191604619","body":"class Solution {\n public ListNode rotateRight(ListNode head, int k) {\n if(head == null || head.next == null) return head;\n int count = 0;\n ListNode now = head;\n while(now != null){\n now = now.next;\n count++;\n }\n k = k % count;\n ListNode slow = head, fast = head;\n while(fast.next != null){\n if(k-- <= 0){\n slow = slow.next;\n }\n fast = fast.next;\n }\n fast.next = head;\n ListNode res = slow.next;\n slow.next = null;\n return res;\n }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192158113","body":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr)return head;\n        ListNode* dumpHead = new ListNode(-1);\n        dumpHead->next = head;\n        ListNode* p1 = nullptr;\n        ListNode* p3 = nullptr;\n        ListNode* pcur = dumpHead;\n        while (pcur && pcur->next&& pcur->next->next) {\n            p3 = pcur->next->next->next;\n            p1 = pcur->next;\n            pcur->next = pcur->next->next;//1\n            pcur->next->next = p1;//2\n            pcur->next->next->next = p3;//3\n            pcur = pcur->next->next;\n        }\n        return dumpHead->next;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193129324","body":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* findM(ListNode* head) {\n        ListNode* pre = head, *slow = head,*fast = head->next;\n        while (fast && fast->next) {\n            pre = slow;\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return pre;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr)return nullptr;\n        if (head->next == nullptr) {\n            return new TreeNode(head->val);\n        }\n        ListNode* pre = findM(head);\n        ListNode* mid = pre->next;\n        pre->next = nullptr;\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(mid->next);\n        return root;\n    }\n};\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193226104","body":"\n\n\n\n\n\n思路：两条路径都走一次的路径相同，哪怕两个路径不相交，（不相交的，最后到NULL) \n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* pa = headA;\n        ListNode* pb = headB;\n        while (pa != pb) {\n            pa = (pa == NULL)?headB:pa->next;\n            pb = (pb == NULL)?headA:pb->next;\n        }\n        return pa;\n        \n    }\n};\n时间复杂度：O(M+N)\n空音复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193582607","body":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while ( fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                ListNode* px = fast;\n                ListNode* py = head;\n                while (px != py) {\n                    py = py->next;\n                    px = px->next;\n                }\n                return px;\n            }\n        }\n        return nullptr;\n    }\n};\n时间复杂度：O（n）\n空间复杂度：O（1）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196179033","body":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr)return 0;\n        int left = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        return max(left,right)+1;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197493975","body":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) return true;\n        else if (p == nullptr && q)return false;\n        else if (p &&  q== nullptr)return false;\n        else if  (p->val != q->val) return false;\n        \n        bool left = isSameTree(p->left,q->left);\n        bool right = isSameTree(p->right,q->right);\n        return left && right;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186183393","body":"### Two times iteration:\n\niterate the string from left will calculate the distance to target `c` from the left. \n\niterate the string from right will calculate the distance to target `c` from the right. \n\nthen for each index, we have two lengths, then we can take the minimum value — this is the answer\n\n<aside>\n💡 **Default value for the distance:** \nwe need to set default value to -n, so that in this case, at the first left iteration, when we didn’t come across a target `character`. we can set the distance to `(i-n)` this is large enough for the second round iteration to overwrite it.\n\n</aside>\n\n<aside>\n💡 **Optimization:**\n in the second round iteration. we can start from the first round latest target index, \nsince there’s no target occurred after this index.\n\n</aside>\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length(); \n        int targetIndex = -n; \n        int [] res = new int [n];\n        for(int i = 0; i< n; i++){\n            if(s.charAt(i) == c){\n                targetIndex = i;\n            }\n            res[i] =  i - targetIndex;\n        }\n        for(int i = targetIndex; i >= 0 ; i--){\n            if(s.charAt(i) == c){\n                targetIndex = i;\n            }\n            res[i] = Math.min(res[i], Math.abs(i - targetIndex));\n        }\n        return res;\n    }\n}\n```\n\n### Complexity Analysis:\n\nTime : O(n)\n\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186525625","body":"class CustomStack {\n    int maxSize;\n    int pointer;\n    int [] stack;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.pointer = 0;\n        this.stack = new int [maxSize]; \n    }\n    \n    public void push(int x) {\n        if(pointer < maxSize){\n            stack[pointer] = x;\n            pointer ++;\n        } \n    }\n    \n    public int pop() {\n        if(pointer==0){\n            return -1;\n        }\n        int res = stack[pointer - 1];\n        pointer--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i < pointer; i++){\n            stack[i] += val;\n        }\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187583121","body":"### Simulation - 2 stacks\r\n\r\n```java\r\nclass Solution {\r\n\tpublic String decodeString(String s){\r\n\t\tStack<String> strStack = new Stack<>();\r\n\t\tStack<Integer> numStack = new Stack<>(); \r\n\t\tStringBuilder tail = new StringBuilder(); \r\n\t\t\r\n\t\tint len = s.length();\r\n\t\tfor(int i = 0; i <len; i++){\r\n\t\t\tchar c = s.chatAt(i);\r\n\t\t\tif(Character.isDigit(c)){\r\n\t\t\t\t // c - '0'  calculates the integer \r\n\t\t\t\tint num = c - '0';\r\n\t\t\t\twhile(i < len - 1 && Character.isDigit(s.charAt(i+1))){\r\n\t\t\t\t\tnum*= 10;\r\n\t\t\t\t\tnum += s.charAt(++i) - '0';\r\n\t\t\t\t}\r\n\t\t\t\tnumStack.push(num);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// save the last string \r\n\t\t\telse if (c == '['){\r\n\t\t\t\tstrStack.push(tail.toString());\r\n\t\t\t\ttail = new StringBuilder(); \r\n\t\t\t}\r\n\r\n\t\t\t// calculate the current string with the previous saving one\r\n\t\t\telse if (c == ']'){\r\n\t\t\t\tStringBuilder temp = new StringBuilder(); \r\n\t\t\t\ttemp.append(strStack.pop());\r\n\t\t\t\tint times = numStack.pop();\r\n\t\t\t\tfor(int i = 0; i < times; i++){\r\n\t\t\t\t\ttemp.append(tail);\r\n\t\t\t\t}\r\n\t\t\t\ttail = temp; \r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse {\r\n\t\t\t\ttail.append(c);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn tail.toString(); \r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188983886","body":"class MyQueue {\n    \n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if(outStack.isEmpty()){\n            while(!inStack.isEmpty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if(outStack.isEmpty()){\n            while(!inStack.isEmpty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190364483","body":"### Double iteration\n\nFor each element, we can say, if all the elements at its right is greater than all the elements at its left, there will be a new trunk. Since in this way, we can sort the trunk w/o interrupting the original order. \n`[2,1,3,4,4]`\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int len = arr.length; \n        int [] leftMax = new int[len];\n        int [] rightMin = new int [len];\n\n        leftMax[0] = arr[0];\n        for(int i = 1; i<len; i++){\n            leftMax[i] = Math.max(leftMax[i-1], arr[i]);\n        }\n        rightMin[len-1] = arr[len-1];\n        for(int i = len-2; i >= 0; i--){\n            rightMin[i] = Math.min(rightMin[i+1], arr[i]); \n        }\n\n        int res = 0;\n        for (int i = 1; i<len; i++ ){\n            if(leftMax[i-1] <= rightMin[i]){\n                res++;\n            }\n        }\n        return res + 1;\n    }\n}\n```\n\n<aside>\n💡 the final comparison cannot be `leftMax[i] → rightMin[i]` \nshould be `leftMax[i] - rightMin[i+1]`\n\n</aside>","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191483576","body":"### Fast-Slow Pointers\n\n- First, get the length of the linked list. ( by iterating it with a counter)\n- Then, calculate the actual moving offset — `actualK`\n- then use fast/slow pointers to find out the place to break - reconnect\n- return the new linked list\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return null;\n        if(k == 0) return head;\n        int len = 0;\n        ListNode copy = head;\n        while(copy!=null){\n            copy= copy.next;\n            len++;\n        }\n        int actualK = k % len;\n        if(actualK == 0) return head;\n\n        ListNode fast = head; \n        ListNode slow = head;\n        while(fast.next != null){\n            fast = fast.next;\n            if(actualK>0){\n                actualK--;\n            } else {\n                slow = slow.next;\n            }\n        }\n        ListNode res = slow.next;\n        slow.next = null;\n        fast.next = head; \n\n        return res;\n    }\n}\n```\n\nComplexity: \n\nTime `O(n)`\nSpace `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192542870","body":"### Simulation:\n\n— 链表问题 - 只要不要吝啬用指针, 并且画图操作 就没有问题!!! \n\n— In order to swap a pair of nodes in a linked list, we need to get 4 pointers. \n    `prev`, `a`, `b`, `after`. After we got all the pointers, we just need to link them by the order. \n\n<aside>\n💡 We should store the `dummy` head → in order to return the swapped linked list.\n\n</aside>\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(-1, head);\n        ListNode ptr = dummy; \n        while(ptr.next != null && ptr.next.next != null){\n            \n            ListNode a = ptr.next;\n            ListNode b = ptr.next.next;\n            ListNode after = ptr.next.next.next; \n            ptr.next = b;\n            b.next = a;\n            a.next = after;\n\n            ptr = ptr.next.next;\n        }\n\n        return dummy.next; \n    }\n}\n```\n\n### Complexity:\n\nTime: O(n) \n\nSpace: O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194000817","body":"### Simulation - Fast / Slow pointers\r\n\r\n**Use two pointers  - fast and slow**  \r\n\r\n- fast moves 2 nodes per round, while slow moves 1 node per round.\r\n- when they meets. it proves that the linked list contains a cycle.\r\n- if fast touch the end (`fast == null || fast.next == null`) then proves the list doesn’t contains a cycle.\r\n- after to pointers meet, put the fast pointer back to the head. move fast and slow one node forward on each round.\r\n- when they meet, it reaches the beginning of the cycle.\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return null;\r\n        }\r\n        ListNode fast = head; \r\n        ListNode slow = head;\r\n        while(fast != null && fast.next != null){\r\n            fast = fast.next.next; \r\n            slow = slow.next;\r\n            if(fast == slow){\r\n                break;\r\n            }\r\n        }\r\n        if(fast != slow){\r\n            return null;\r\n        }\r\n        fast = head; \r\n        while(fast != slow){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return fast; \r\n    }  \r\n}\r\n```\r\n\r\n### Complexity\r\n\r\ntime: O(n)\r\n\r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195439771","body":"### Simulation: Use a me-defined DoubleLinkedList and a hashmap\n\n```java\nclass LRUCache {\n    // use a hashmap to record the key-value pair (O(1) get)\n    // use a doubleLinkedList to do the put / resize in O(1) \n    class DListNode {\n        int val; \n        int key;\n        DListNode prev; \n        DListNode next;\n\n        public DListNode(){}\n\n        public DListNode(int key, int val){\n            this.key = key;\n            this.val = val;\n        }\n    }\n\n    private Map<Integer, DListNode> cache = new HashMap<>();\n    private int size; \n    private int capacity; \n    private DListNode head;\n    private DListNode tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity; \n        head = new DListNode();\n        tail = new DListNode();\n        head.next = tail; \n        tail.prev = head; \n    }\n\n    public void removeNode(DListNode cur){\n        cur.prev.next = cur.next;\n        cur.next.prev = cur.prev; \n    }\n\n    public void addToHead(DListNode cur){\n        cur.prev = head; \n        cur.next = head.next; \n        head.next.prev = cur;\n        head.next = cur; \n    }\n    \n    public void moveToHead(DListNode cur){\n        removeNode(cur);\n        addToHead(cur);\n    }\n\n    public DListNode removeTail(){\n        DListNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n\n    public int get(int key) {\n        DListNode node = cache.get(key);\n        if(node == null){\n            return -1; \n        }\n        moveToHead(node);\n        return node.val; \n    }\n\n    public void put(int key, int value) {\n        DListNode node = cache.get(key);\n        if(node == null){\n            DListNode cur = new DListNode(key, value);\n            cache.put(key, cur);\n            addToHead(cur);\n            size++; \n            if(size > capacity){\n                DListNode tail = removeTail();\n                cache.remove(tail.key);\n                size--;\n            }\n        } else {\n            node.val = value;\n            moveToHead(node);\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196670920","body":"### Recursion:\n\nFor a TreeNode, the height of itself =  max (left height , right height) + 1\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0; \n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n        return Math.max(leftDepth, rightDepth) + 1; \n    }\n}\n```\n\n### No backtracking recursion\n\n```java\nclass Solution {\n    int maxDepth = 0;\n    public int maxDepth(TreeNode root) {\n        if(root == null) return maxDepth; \n        dfs(root, 1);\n        return maxDepth;\n    }\n\n    public void dfs(TreeNode root, int level){\n        if (root == null) return; \n        maxDepth = Math.max(maxDepth, level);\n        dfs(root.left, level+1);\n        dfs(root.right, level+1);\n    }\n}\n```\n\n### Complexity:\n\ntime: O(n)\n\nspace: O(log n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186189241","body":"解题\r\n\r\n## Idea:\r\n\r\n引入BigInteger类，相加转化为list。\r\n\r\n## Code:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result=new ArrayList<>();\r\n        String s=\"\";\r\n       for(int i=0;i<num.length;i++){\r\n           s+=num[i];\r\n       }\r\n       java.math.BigInteger a=new java.math.BigInteger(s);\r\n       java.math.BigInteger b=new java.math.BigInteger(String.valueOf(k));\r\n       java.math.BigInteger c;\r\n        c=a.add(b);\r\n        String d=String.valueOf(c);\r\n        for (int i=0;i<d.length();i++){\r\n            result.add(Integer.valueOf(d.charAt(i))-48);\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186188719","body":"Idea\r\n\r\n```\r\n从左到右和从右到左进行两次遍历计算各元素到目标字符的距离。\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len=s.length();\r\n        int[] result=new int[len];\r\n        for(int i=0;i<len;i++){\r\n            result[i]=Integer.MAX_VALUE;\r\n        }\r\n        for (int i=0;i<len;i++){\r\n            if(s.charAt(i)==c){\r\n                for (int j=0;j<len;j++){\r\n                    if (Math.abs(i-j)<result[j]){\r\n                        result[j]=Math.abs(i-j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (int i=len-1;i>0;i--){\r\n            if (s.charAt(i)==c){\r\n                for(int j=len-1;j>0;j--){\r\n                    if (Math.abs(i-j)<result[j]){\r\n                        result[j]=Math.abs(i-j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186546899","body":"Code\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int[] add;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        int ret = stack[top] + add[top];\r\n        if (top != 0) {\r\n            add[top - 1] += add[top];\r\n        }\r\n        add[top] = 0;\r\n        --top;\r\n        return ret;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k - 1, top);\r\n        if (limit >= 0) {\r\n            add[limit] += val;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189074697","body":"Idea\r\n\r\n```\r\n使用两个横向摆放相对开口的栈模拟队列，右边栈储存元素，左边栈弹出元素。\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass MyQueue {\r\n    private Stack<Integer> s1,s2;\r\n    public MyQueue() {\r\n        s1=new Stack<>();\r\n        s2=new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        int temp=peek();\r\n        s2.pop();\r\n        return temp;\r\n    }\r\n\r\n    public int peek() {\r\n        if (!s2.isEmpty()){\r\n            return s2.peek();\r\n        }\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        return s2.peek();\r\n\r\n    }\r\n\r\n    public boolean empty() {\r\n        if (s1.isEmpty()&& s2.isEmpty()){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190461353","body":"class Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192703418","body":"Idea\r\n\r\n```\r\n确认头指针，保证链表连接，对目标进行操作\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n           ListNode before=new ListNode(0);\r\n           before.next=head;\r\n            ListNode temp=before;\r\n            while(temp.next!=null&&temp.next.next!=null){\r\n                ListNode node1=temp.next;\r\n                ListNode node2=temp.next.next;\r\n                temp.next=node2;\r\n                node1.next=node2.next;\r\n                node2.next=node1;\r\n                temp=node1;\r\n            }\r\n            return before.next;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193137575","body":"Idea\r\n\r\n```\r\n链表转二叉搜索树。其本质是一个快慢指针的递归过程。\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head==null)return null;\r\n        return dfs(head,null);\r\n    }\r\n    private TreeNode dfs(ListNode head, ListNode tail){//tail==null\r\n        if (head==tail)return null;\r\n        ListNode fast=head,slow=head;\r\n        while(fast!=tail &&fast.next!=tail){\r\n            fast=fast.next.next;\r\n            slow=slow.next;\r\n        }\r\n        TreeNode root=new TreeNode(slow.val);\r\n        root.left=dfs(head,slow);\r\n        root.right=dfs(slow.next,tail);\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193318029","body":"\r\n\r\nIdea\r\n\r\n```\r\n将两条链表连起来遍历，如果有交点的话，则证明这两条链表是连在一起的；如果没有交点，则证明这两条链表是独立的。（有交点的话，则有链表A+链表B=链表B+链表A）\r\n```\r\n\r\nCode\r\n\r\n```Java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n         ListNode first=headA,second=headB;\r\n        while(first!=second){\r\n            if (first==null)\r\n                first=headB;\r\n            else \r\n                first=first.next;\r\n            if (second==null)\r\n                second=headA;\r\n            else\r\n                second=second.next;\r\n        }\r\n        return first;\r\n    }\r\n}\t\t\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194139991","body":"Idea\r\n\r\n```\r\n使用快慢指针，当两者相遇时，说明存在环，然后把快指针指向链表的头节点，接着两指针一起前行，当两指针重新相遇时，相遇结点即为环开始节点。\r\n```\r\n\r\nCode\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n      ListNode slow=head,fast=head;\r\n        while (fast!=null&&fast.next!=null){\r\n            slow=slow.next;\r\n            fast=fast.next.next;\r\n            if (fast==slow){\r\n                break;\r\n            }\r\n        }\r\n        if (fast==null||fast.next==null){\r\n            return null;\r\n        }\r\n        fast=head;\r\n        while (slow!=fast){\r\n            slow=slow.next;\r\n            fast=fast.next;\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195195558","body":"Idea\r\n\r\n```\r\n具体逻辑如下：\r\nput：\r\n若key已存在，将其权限提升至最近使用\r\n若key不存在，需要新插入key，若容量已满，淘汰最久未使用的key，插入key和val；若容量未满则直接插入key和val，最后将其权限提升至最近使用\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass LRUCache {\r\n\r\n    int cap;\r\n    LinkedHashMap<Integer,Integer>cache=new LinkedHashMap<>();\r\n    public LRUCache(int capacity){\r\n        this.cap=capacity;\r\n    }\r\n    \r\n    public int get(int key){\r\n        if (!cache.containsKey(key)){\r\n            return -1;\r\n        }\r\n        makeRecently(key);\r\n        return cache.get(key);\r\n    }\r\n    \r\n    public void put(int key,int val){\r\n        if(cache.containsKey(key)){\r\n            cache.put(key,val);\r\n            makeRecently(key);\r\n            return;\r\n        }\r\n        \r\n        if(cache.size()>=this.cap){\r\n            int oldestKey=cache.keySet().iterator().next();//链表头指针\r\n            cache.remove(oldestKey);\r\n        }\r\n        cache.put(key,val);\r\n    }\r\n    private void makeRecently(int key){\r\n        int val=cache.get(key);\r\n        cache.remove(key);\r\n        cache.put(key,val);\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186206888","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\n// two pointers (i: read pointer; j: write pointer)\r\n// 1. when i points to c, handle all elements between i -> j\r\n//      i - j < j - lastJ ? i - j : j - lastJ\r\n//      if (j === i) lastJ = j;\r\n// 2. if c is not the last element of s, add the rest of elements for res (there is no fore j, only back j)\r\n//      while (res.length !== s.length) { res.push(res.length - lastJ); }\r\n\r\nvar shortestToChar = function(s, c) {\r\n    if (s.length === 1) return [0];\r\n    let res = [];\r\n    let j = 0;\r\n    let lastJ = null;\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            while (j <= i) {\r\n                res[j] = lastJ === null || (i - j < j - lastJ) ? i - j : j - lastJ;\r\n                if (j === i) lastJ = j;\r\n                j++;\r\n            }\r\n        }\r\n    }\r\n    while (res.length !== s.length) {\r\n        res.push(res.length - lastJ);\r\n    }\r\n    return res;\r\n};\r\n```\r\nT: O(N)   \r\nS: O(1)   ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531186","body":"```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    // O(1)\r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    // O(1)\r\n    public int pop() {\r\n        if (top == -1) return -1;\r\n        return stack[top--];\r\n    }\r\n    \r\n    // O(N)\r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186604001","body":"Java\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Integer> tStack = new Stack<>();\r\n        Stack<String> sStack = new Stack<>();\r\n        String temp = \"\";\r\n        int times = 0;\r\n\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if (Character.isDigit(c)) {\r\n                times = times * 10 + c - '0';\r\n                continue;\r\n            }\r\n            if (c == '[') {\r\n                sStack.push(temp);\r\n                tStack.push(times);\r\n                temp = \"\";\r\n                times = 0;\r\n                continue;\r\n            }\r\n            if (c == ']') {\r\n                temp = sStack.pop() + temp.repeat(tStack.pop());\r\n                continue;\r\n            }\r\n            temp += c;\r\n        }\r\n        return temp;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188474959","body":"Java\r\n```java\r\n// stack1: 插入用\r\n// stack2: 删除用（stack2 即倒过来的 stack1，需要取出数字时，调用 stack2）\r\n// 何时在 stack2 中插入值？\r\n// 有这么一种情况：有大量的插入操作，却只有很少的删除/取数操作\r\n// 所以 push 的时候，不必给 stack2 加入数字\r\n// 而是在「删除或取数时，且 stack2 为空时」，从 stack1 中逐一 pop，入栈 stack2\r\nclass MyQueue {\r\n    Stack<Integer> stack1 = new Stack<>();\r\n    Stack<Integer> stack2 = new Stack<>();\r\n    \r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        this.cleanQ1();\r\n        return stack2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        this.cleanQ1();\r\n        return stack2.get(stack2.size() - 1);\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.size() == 0 && stack2.size() == 0;\r\n    }\r\n\r\n    private void cleanQ1() {\r\n        if (stack2.size() == 0) {\r\n            int q1Len = stack1.size();\r\n            for (int i = 0; i < q1Len; i++) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n- 空间复杂度 O(N)\r\n- 时间复杂度\r\n  - 摊还时间复杂度 O(1) \r\n     - 最坏情况 O(N)：栈 2 为空，需要 for loop 挤压栈 1 时\r\n     - 最好情况 O(1)     \r\n\r\n摊还复杂度：高频次操作的时间复杂度小 + 低频次操作的时间复杂度高，二者均摊了每次操作的代价","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189493717","body":"Java\r\n```java\r\n//找到所有子集的最大值，这些最大值如果能按升序排列，那么这些子集也可以按升序排列    \r\n\r\n// 具体做法：   \r\n// - 维护一个单调栈（单调栈里，装着所有 target 子集的最大值）   \r\n// - 遍历数组   \r\n//  - 如果当前数字 >= 单调栈栈顶（前一个 target 子集的最大值），当前数字入栈   \r\n//  - 如果当前数字 < 单调栈栈顶，说明前面找好的子集最大值和当前数字——无法满足升序排列条件，那就把当前栈中找好的子集最大值们，一个个踢出单调栈，直到当前数字 < 栈顶元素，踢完后把上一个栈顶元素加回来\r\n// - 返回单调栈元素个数，即多少个可生序排列的子集个数 \r\nclass Solution {\r\n    Stack<Integer> stack = new Stack();\r\n    public int maxChunksToSorted(int[] arr) {\r\n        stack.push(arr[0]);\r\n        for (int i = 1; i < arr.length; i++) {\r\n            int stackTop = getStacktop();\r\n            if (arr[i] >= stackTop) {\r\n                stack.push(arr[i]);\r\n                continue;\r\n            }\r\n            while (stack.size() > 0 && arr[i] < getStacktop()) {\r\n                stack.pop();\r\n            }\r\n            stack.push(stackTop);\r\n        }\r\n        return stack.size();\r\n    }\r\n\r\n    int getStacktop() {\r\n        return stack.get(stack.size() - 1);\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1192860221","body":"Java\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) return head;\r\n        int size = 0;\r\n        ListNode joint = null;\r\n        for (ListNode iter = head; iter != null; iter = iter.next) {\r\n            joint = iter;\r\n            size++;\r\n        }\r\n        k %= size;\r\n        if (k == 0) return head;\r\n        ListNode end = head;\r\n        for (int j = 1; j < size - k; j++) {\r\n            end = end.next;\r\n        }\r\n        ListNode start = end.next;\r\n        end.next = null;\r\n        joint.next = head;\r\n        return start;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nO: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192748573","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummy = new ListNode(-1, head);\r\n        ListNode iter = dummy;\r\n        while (iter.next != null && iter.next.next != null) {\r\n            ListNode first = iter.next;\r\n            ListNode second = iter.next.next;\r\n            first.next = second.next;\r\n            second.next = first;\r\n\r\n            iter.next = second;\r\n            iter = first;\r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193040493","body":"Java\r\n```java\r\n// linkedlist to bst, 递归构建二叉树\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    List<Integer> bst = new ArrayList<Integer>();\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        while (head != null) {\r\n            bst.add(head.val);\r\n            head = head.next;\r\n        }\r\n        return formBST(0, bst.size() - 1);\r\n    }\r\n\r\n    public TreeNode formBST(int start, int end) {\r\n        if (start > end) return null;\r\n        int mid = (start + end) >>> 1; \r\n        TreeNode root = new TreeNode(bst.get(mid));\r\n        root.left = formBST(start, mid - 1);\r\n        root.right = formBST(mid + 1, end);\r\n        return root;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1194739873","body":"Java\r\n```javascript\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode A = headA;\r\n        ListNode B = headB;\r\n        while (A != B) {\r\n            A = A == null ? headB : A.next;\r\n            B = B == null ? headA : B.next;\r\n        }\r\n        return A;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193371218","body":"Java\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n       ListNode fast = head;\r\n       ListNode slow = head;\r\n       while (fast != null) {\r\n           if (fast.next == null) {\r\n               return null;\r\n           }\r\n           slow = slow.next;\r\n           fast = fast.next.next;\r\n           if (slow == fast) {\r\n               fast = head;\r\n               while (slow != fast) {\r\n                   slow = slow.next;\r\n                   fast = fast.next;\r\n               }\r\n               return fast;\r\n           }\r\n       }\r\n       return null;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194613467","body":"Java\r\n```java\r\n// 双向链表用来增删头尾节点，hash 用来 O(1) 找到节点\r\n\r\nclass LRUCache {\r\n    class DLinkedNode {\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode() {}\r\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\r\n    }\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\r\n    private int size;\r\n    private int capacity;\r\n    private DLinkedNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.size = 0;\r\n        this.capacity = capacity;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    // T: O(1) S: O(capacity)\r\n    public int get(int key) {\r\n       DLinkedNode node = cache.get(key);\r\n       if (node == null) return -1;\r\n       moveToHead(node);\r\n       return node.value;\r\n    }\r\n\r\n    // T: O(1) S: O(capacity)\r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node != null) {\r\n            node.value = value;\r\n            moveToHead(node);\r\n        } else {\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            cache.put(key, newNode);\r\n            addToHead(newNode);\r\n            if (size == capacity) {\r\n                cache.remove(removeTail());\r\n            } else {\r\n                size++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    private void addToHead(DLinkedNode node) {\r\n        DLinkedNode hNext = head.next;\r\n        node.next = hNext;\r\n        node.prev = head;\r\n        head.next = node;\r\n        hNext.prev = node;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private int removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        return node.key;\r\n    }\r\n\r\n    private int removeTail() {\r\n        return removeNode(tail.prev);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196161593","body":"Java\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(H)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197380511","body":"Java\r\n```java\r\n// p 或 q 其中一个为空，或者值不相等，都为 false\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        }\r\n        if (p == null || q == null || p.val != q.val) {\r\n            return false;\r\n        }\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\nDFS:\r\nT: O(min(pNodeNum, qNodeNum))\r\nS: O(min(pNodeNum, qNodeNum))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185772596","body":"### 思路\r\n在js里，直接先将数组合并为字符串，然后转化为数字进行相加\r\n避免精度丢失，查了一下可以使用BigInt方式解决\r\n相加完毕后，再转化为字符串，切分为数组\r\n\r\n### 代码\r\n``` javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let str = num.join('')\r\n    let count = BigInt(str) + BigInt(k)\r\n    let res = count.toString().split('')\r\n    return res\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186213182","body":"### 思路\n通过循环，遍历两次\n### 代码\n\n\n```javascript\nvar shortestToChar = function(s, c) {\n    const n=s.length;\n    const ans=new Array(n).fill(0);\n    for(let i=0,idx=-n;i<n;i++){\n        if(s[i]==c){\n            idx=i;\n        }\n        ans[i]=i-idx;\n    }\n    for(let i=n-1,idx=2*n;i>=0;--i){\n        if(s[i]==c){\n            idx=i;\n        }\n        ans[i]=Math.min(ans[i],idx-i);\n    }\n    return ans;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186533856","body":"### 思路\n\n把属性挂在在this链上\n最后一个方法，首先把长度进行对比，for循环修改参数即可\n\n### 代码\n\n\n```javascript\n\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.list = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.list.length  >= this.maxSize) {\n        return\n    }\n    this.list.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.list.length ? this.list.pop() : -1 \n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let length = Math.min(k, this.list.length);\n    for (let i = 0; i < length; i++) {\n        this.list[i] += val;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187636888","body":"### 思路\r\n\r\n维护两个栈，用来记录需要重复的次数和需要重复的字符串\r\n\r\n### 代码\r\n\r\n\r\n```javascript\r\nvar decodeString = function(s) {\r\n    let numStack = [];              \r\n    let strStack = [];              \r\n\r\n    let num = 0, result = '';\r\n\r\n    for(let i = 0; i < s.length; i++) {\r\n        const item = s[i];\r\n\r\n        if(!isNaN(item)) {             \r\n            num = num * 10 + parseInt(item);\r\n        } else if(item === '[') {\r\n            strStack.push(result);\r\n            result = '';\r\n            numStack.push(num);\r\n            num = 0;\r\n        } else if(item === ']') {\r\n            const repeatTimes = numStack.pop();        \r\n            result = strStack.pop() + result.repeat(repeatTimes);\r\n        } else {\r\n            result += item;\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)，\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193153150","body":"```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA\r\n    let b = headB\r\n    while(a != b) {\r\n        if (a == null) {\r\n            a = headB\r\n        } else {\r\n            a = a.next\r\n        }\r\n        if (b == null) {\r\n            b = headA\r\n        } else {\r\n            b = b.next\r\n        }\r\n    }\r\n    return a\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193348285","body":"```javascript\r\nvar detectCycle = function(head) {\r\n    let slow = fast = head\r\n    while(fast !== null && fast.next !== null) {\r\n        slow = slow.next\r\n        fast = fast.next.next\r\n        if (slow === fast) {\r\n            break\r\n        }\r\n    }\r\n    if (fast == null || fast.next == null) {\r\n        return null\r\n    }\r\n    slow = head\r\n    while(slow !== fast) {\r\n        slow = slow.next\r\n        fast = fast.next\r\n    }\r\n    return slow\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186218926","body":"## 思路\n贪心法，最接近的值要么在左边，要么在右边\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        int[] left = new int[s.length()];\n        int[] right = new int[s.length()];\n        left[0] = s.charAt(0) == c ? 0:Integer.MAX_VALUE-s.length();\n        for(int i = 1; i < s.length(); i++) {\n            if(s.charAt(i) == c)\n                left[i] = 0;\n            else\n                left[i] = left[i-1]+1;\n        }\n        right[s.length()-1] = s.charAt(s.length()-1) == c?0:Integer.MAX_VALUE-s.length();\n        for(int i = s.length()-2; i>=0;i--) {\n            if(s.charAt(i) == c)\n                right[i] = 0;\n            else\n                right[i] = right[i+1]+1;\n        }\n        for(int i = 0; i < left.length;i++)\n            ans[i] = Math.min(left[i],right[i]);\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186535387","body":"## 思路\n了解栈的工作方式即可\n## 代码\n```java\nclass CustomStack {\n    private int pointer;\n    private int[] stack;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.pointer = -1;\n    }\n    \n    public void push(int x) {\n        if(pointer < stack.length-1) {\n            pointer++;\n            this.stack[pointer] = x;\n        }\n\n    }\n    \n    public int pop() {\n        int val;\n        if(pointer < 0)\n            val = -1;\n        else {\n            val = this.stack[pointer];\n            pointer--;\n        }\n        return val;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i <= Math.min(k-1,this.pointer); i++)\n            this.stack[i] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187643314","body":"## 思路\n栈\n## 代码\n```java\nclass Solution {\n    static Stack<String> strings = new Stack<>();\n    public static String decodeString(String s) {\n        char[] chars = s.toCharArray();\n        for(int i = 0; i < chars.length; i++) {\n            if(chars[i] != ']') {\n                if(Character.isDigit(chars[i])) {\n                    int tempCal = 0;\n                    while(Character.isDigit(chars[i])){\n                        tempCal = tempCal*10 + chars[i] - '0';\n                        i++;\n                    }\n                    i--;\n                    strings.push(String.valueOf(tempCal));\n                } else {\n                    strings.push(String.valueOf(chars[i]));\n                }\n\n            } else {\n                String poped, temp = \"\", newString=\"\";\n                while(!(poped = strings.pop()).equals(\"[\")) {\n                    temp = poped + temp;\n                }\n                poped = strings.pop();\n                int cal = Integer.parseInt(poped);\n                for(int j = 0; j < cal;j++) {\n                    newString += temp;\n                }\n                strings.push(newString);\n            }\n        }\n        String ans = \"\";\n        while(!strings.isEmpty()) {\n            ans = strings.pop()+ans;\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195485790","body":"```java\nclass LRUCache {\n    class DLinkedNode {\n        int key, value;\n        DLinkedNode prev, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //add dummy head and dummyTail\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //if key exist, move it to head by using its location store in Hashmap\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186219318","body":"‘’‘\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int position = -n;\n        int[] res = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                position = i;   \n            }\n            res[i] = i - position;\n        }\n        for (int i = position - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                position = i;   \n            }\n            res[i] = Math.min(res[i], position - i);\n        }\n        return res;\n    }\n}\n’‘’","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188598361","body":"class MyQueue {\n    Deque<Integer> in;\n    Deque<Integer> out;\n    \n    public MyQueue() {\n        in = new ArrayDeque<>();\n        out = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        in.offerFirst(x);\n    }\n    \n    public int pop() {\n        peek();\n        return out.pollFirst();\n    }\n    \n    public int peek() {\n        if (!out.isEmpty()) {\n            return out.peek();\n        }\n        else {\n            while (!in.isEmpty()) {\n                out.offerFirst(in.pollFirst());\n            }\n            return out.peek();\n        }\n    }\n    \n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191033999","body":"```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        int len = 0;\n        ListNode curr = head;\n        while (curr != null && curr.next != null) {\n            curr = curr.next;\n            len++;\n        }\n        len++; // add last\n        curr.next = head;\n        \n        int offset = len - (k % len);\n        curr = head;\n        while (offset > 1) {\n            curr = curr.next;\n            offset--;\n        }\n        ListNode newHead = curr.next;\n        curr.next = null;\n        \n        return newHead;\n    }\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195045354","body":"// Use a double linklist to store nodes in the cache\n// Use a map to store key-node pair to support quick access in list\n// Helper function: insert and remove to opreate map and list\n// Update (remove&insert) the position of opreated (get&put) node in list\n\nclass LRUCache {\n    Map<Integer, Node> map = new HashMap<>();\n    Node head = new Node(0, 0);\n    Node tail = new Node(0, 0);\n    int cap;\n    \n    public LRUCache(int capacity) {\n        cap = capacity;\n        head.next = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node curr = map.get(key);\n            remove(curr);\n            insert(curr);\n            return curr.val;\n        }\n        else {\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            remove(map.get(key));\n            insert(new Node(key, value));\n        }\n        else {\n            if (map.size() == cap) {\n                remove(tail.pre);\n            }\n            insert(new Node(key, value));\n        }\n\n    }\n    \n    public void insert(Node node) {\n        map.put(node.key, node);\n        Node temp = head.next;\n        head.next = node;\n        node.pre = head;\n        node.next = temp;\n        temp.pre = node;\n    }\n    \n    public void remove(Node node) {\n        map.remove(node.key);\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n    }\n    \n    class Node{\n        int key;\n        int val;\n        Node pre;\n        Node next;\n        public Node(int k, int value) {\n            key = k;\n            val = value;\n        }\n    }\n}\n\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186219816","body":"# Time: O(N), space O(N)\n        res = [len(s) for i in s]\n        leftC = -1\n        for i in range(len(s)):\n            if s[i] == c:\n                leftC = i\n            if leftC != -1:\n                res[i] = i - leftC\n        rightC = -1\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                rightC = i\n            if rightC != -1:\n                res[i] = min(res[i], rightC - i)\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186387091","body":"Code:\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.maxSize:\n            self.stack = self.stack + [x]\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.stack == []:\n            return -1\n        else:\n            return self.stack.pop(len(self.stack)-1)\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        changeRange = min(len(self.stack), k)\n        for i in range(changeRange):","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186615278","body":"class Solution(object):\n    def getNum(self, s, rInd):\n        res = 0\n        place = 0\n        while rInd >= 0 and s[rInd].isnumeric():\n            res += 10**place*int(s[rInd])\n            place += 1\n            rInd -= 1\n        return res, rInd + 1\n    \n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # base case: \"a\", \"[a]\", \"3[a]\"\n        # recursive case: \"3[3[a]]\"\n        left = []\n        i = 0\n        disFromLast = len(s)\n        while disFromLast > 0:\n            i = len(s) - disFromLast\n            if s[i] == \"[\":\n                left.append(i)\n            elif s[i] == \"]\":\n                # get the last left bracket\n                lastLeft = left[-1]\n                left = left[:-1]\n                curStr = s[lastLeft+1:i]\n                if s[lastLeft-1].isnumeric():\n                    num, newInd = self.getNum(s, lastLeft-1)\n                else:\n                    num, newInd = 1, i\n                # update s\n                if i == len(s)-1:\n                    s = s[:newInd] + num * s[lastLeft+1:i]\n                else:\n                    s = s[:newInd] + num * s[lastLeft+1:i] + s[i+1:]\n            # updating i depends on length change in s\n            disFromLast -= 1\n        return s","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188506364","body":"class MyQueue(object):\n    def __init__(self):\n        self.reversed = []\n        self.first = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.first.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.reversed == []:\n            self.reverseFirst()\n        res = self.reversed[-1]\n        self.reversed.pop()\n        return res\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.reversed == []:\n            self.reverseFirst()\n        res = self.reversed[-1]\n        return res\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return self.first == [] and self.reversed == []\n    \n    def reverseFirst(self):\n        for i in range(len(self.first)-1, -1, -1):\n            self.reversed.append(self.first[i])\n        self.first = []","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189803513","body":"## Idea: \nWe scan through the array and update a list of chunks, which stores min and max of each chunk. If cur element in arr is greater than or equal to the max of the last elem in chunks, add a new chunk. Otherwise, we find the first occurrence in chunk where the current elem would fit and merge everything in between. We return the length of chunk at the end.\n## Complexity\n**Time:** O(N), not sure because the while loop could be O(N) worst case. \\\n**Space:** O(N).\n## Code\n```\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        # chunks stores (min, max) of each chunk\n        chunks = [(arr[0], arr[0])]\n        for i in range(1, len(arr)):\n            if arr[i] >= chunks[-1][1]:\n                chunks.append((arr[i], arr[i]))\n            else:\n                combineIndex = 0\n                while combineIndex < len(chunks) and arr[i] >= chunks[combineIndex][1]:\n                    combineIndex += 1\n                newMin = min(arr[i], chunks[combineIndex][0])\n                newMax = chunks[-1][1]\n                chunks = chunks[:combineIndex]\n                chunks.append((newMin, newMax))\n        return len(chunks)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190947923","body":"## Time: O(N), Space: O(1)\n```\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if head == None: return head\n        copy = head\n        cnt = 0\n        while copy != None:\n            cnt += 1\n            if copy.next == None:\n                oldTail = copy\n            copy = copy.next\n        k = k % cnt\n        if k == 0: return head\n        \n        oldTail.next = head\n        newTail = head\n        for i in range(cnt - k - 1):\n            newTail = newTail.next\n            \n        newHead = newTail.next\n        newTail.next = None\n        return newHead\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192100147","body":"## Time: O(N), Space: O(1)\n```\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode()\n        dummy.next = head\n        prev = dummy\n        cur = dummy.next\n        while cur != None and cur.next != None:\n            nxt = cur.next.next\n            sec = cur.next\n            prev.next = sec\n            sec.next = cur\n            cur.next = nxt\n            prev = cur\n            cur = nxt\n        return dummy.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1192996278","body":"## Inorder\nTime: O(N), Space: O(logN)\n```\nclass Solution(object):\n    def __init__(self):\n        self.curHead = None\n        \n    def convert(self, s, e):\n        if s > e:\n            return None\n        \n        midInd = (s + e) // 2\n        mid = TreeNode()\n        mid.left = self.convert(s, midInd-1)\n        mid.val = self.curHead.val\n        self.curHead = self.curHead.next\n        mid.right = self.convert(midInd+1, e)\n        \n        return mid\n    \n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        cpy = head\n        size = 0\n        while cpy != None:\n            cpy = cpy.next\n            size += 1\n        self.curHead = head\n        return self.convert(0, size-1)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193409411","body":"## Time: O(N) where N is the length of non-cycle + cycle, Space: O(1)\n```\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head == None or head.next == None:\n            return None\n        hare, tor = head, head\n        while hare != None and hare.next != None:\n            tor = tor.next\n            hare = hare.next.next\n            if tor == hare:\n                break\n        if tor != hare:\n            return None\n        while head != tor:\n            head = head.next\n            tor = tor.next\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194932403","body":"## Hash table with Doubly Linked List\n```\nclass DL(object):\n    def __init__(self, key=None, val=None):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n    \nclass LRUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.hash = dict()\n        self.head, self.tail = DL(), DL()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        \n    def moveToHead(self, node):\n        oldPrev, oldNext = node.prev, node.next\n        oldPrev.next = oldNext\n        oldNext.prev = oldPrev\n        \n        self.addToHead(node)\n    \n    def addToHead(self, node):\n        nxt = self.head.next\n        self.head.next = node\n        node.next = nxt\n        nxt.prev = node\n        node.prev = self.head\n    \n    def removeLast(self):\n        res = self.tail.prev.key\n        oldPrev = self.tail.prev.prev\n        oldPrev.next = self.tail\n        self.tail.prev = oldPrev\n        return res\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.hash.keys():\n            return -1\n        node = self.hash[key]\n        self.moveToHead(node)\n        return node.val\n    \n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if key in self.hash:\n            self.hash[key].val = value\n            self.moveToHead(self.hash[key])\n        else:\n            if len(self.hash) >= self.capacity:\n                removedKey = self.removeLast()\n                del self.hash[removedKey]\n            newNode = DL(key, value)\n            self.addToHead(newNode)\n            self.hash[key] = newNode\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196147258","body":"### Time: O(N), Space: O(logN) if balanced, O(N) otherwise; N denotes number of nodes\n```\nclass Solution(object):\n    def maxDepthRecursion(self, root, level):\n        if root == None:\n            return level\n        return max(self.maxDepthRecursion(root.left, level+1), self.maxDepthRecursion(root.right, level+1))\n    \n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        return self.maxDepthRecursion(root, 0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197502178","body":"### Time: O(N), Space: O(N)\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if p == None:\n            return q == None\n        if q == None:\n            return p == None\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186221215","body":"## 代码\n```\nfunction shortestToChar(s: string, c: string): number[] {\n    let result: number[] = [];\n    if (s.length === 0 || c.length === 0) {\n        return result;\n    }\n    let strArray = Array.from(s);\n    let indexs: number[] = [];\n    strArray.forEach((element, index) => {\n        if (element === c) {\n            indexs.push(index);\n        }\n    });\n    for (let i = 0; i <= indexs[0]; i++) {\n        result.push(indexs[0] - i);\n    }\n    for (let i = 0; i <= indexs.length - 2; i++) {\n        let start = indexs[i];\n        let end = indexs[i + 1];\n        for (let i = start + 1; i <= end; i++) {\n            let distance = Math.min(i - start, end - i);\n            result.push(distance);\n        }\n    }\n    for (let i = indexs[indexs.length - 1] + 1; i < strArray.length; i++) {\n        result.push(i - indexs[indexs.length - 1]);\n    }\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531249","body":"## 代码\n```\nclass CustomStack {\n    stack: number[];\n    maxSize: number;\n    size: number;\n    constructor(maxSize: number) {\n        this.stack = [];\n        this.maxSize = maxSize;\n        this.size = 0;\n    }\n\n    push(x: number): void {\n        if (this.size >= this.maxSize) {\n            return;\n        }\n        this.size += 1;\n        this.stack.push(x);\n    }\n\n    pop(): number {\n        if (this.size <= 0) {\n            return -1;\n        }\n        this.size -= 1;\n        return this.stack.pop();\n    }\n\n    increment(k: number, val: number): void {\n        let i = 0;\n        let size = this.size;\n        while (i < size && i < k) {\n            this.stack[i] += val;\n            i++;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1189204290","body":"## 代码\n```\nfunction decodeString(s: string): string {\n    let length: number = s.length;\n    let stack: string[] = [];\n    for(let i: number = 0; i < length; i++) {\n        let char: string = s.charAt(i);\n        if(char === ']') {\n            let str:string = '';\n            while(true) {\n                let item = stack.pop();\n                if(item === '[') {\n                    break;\n                }\n                str = item + str;\n            }\n            let numStr:string = '';\n            while(true) {\n                let item: string = stack.pop();\n                if(!/\\d+/.test(item)) {\n                    stack.push(item);\n                    break;\n                }\n                numStr = item + numStr;   \n            }\n            let count:number = parseInt(numStr, 10);\n            stack.push(str.repeat(count));    \n        }else {\n            stack.push(char);   \n        }\n    }\n    return stack.join('');  \n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189201773","body":"## 代码\n```\nclass MyQueue {\n    outStack: number[]\n    inStack: number[]\n    constructor() {\n        this.outStack = [];\n        this.inStack = [];\n    }\n\n    push(x: number): void {\n        this.inStack.push(x);\n    }\n\n    pop(): number {\n        if (this.outStack.length === 0) {\n            this.in2out();\n        }\n        return this.outStack.pop();\n    }\n\n    peek(): number {\n        if (this.outStack.length === 0) {\n            this.in2out();\n        }\n        return this.outStack[this.outStack.length - 1];\n    }\n\n    empty(): boolean {\n        return this.inStack.length === 0 && this.outStack.length === 0;\n    }\n\n    in2out(): void {\n        while (this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190436688","body":"## 代码\n```\nfunction maxChunksToSorted(arr: number[]): number {\n    let count: number = 0;\n    let sorted = [...arr];\n    sorted.sort((a, b) => {\n        return a - b;\n    });\n    const length = arr.length;\n    let sum1: number = 0;\n    let sum2: number = 0;\n    for (let i = 0; i < length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n        if (sum1 === sum2) {\n            count++;\n        }\n    }\n    return count;\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193343702","body":"## 代码\n```\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n    if (headA === null || headB === null) {\n        return null;\n    }\n    let pA: ListNode = headA;\n    let pB: ListNode = headB;\n    while (pA !== pB) {\n        if (pA === null) {\n            pA = headB;\n        } else {\n            pA = pA.next;\n        }\n        if (pB === null) {\n            pB = headA;\n        } else {\n            pB = pB.next;\n        }\n    }\n    return pA;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225472","body":"### 思路\n求\ns[i]s[i] 到其左侧最近的字符 c 的距离\ns[i]s[i] 到其右侧最近的字符 c 的距离\n两者的最小值\n### 代码\n···\nconst shortestToChar = function(s, c) {\n    const n = s.length;\n    const ans = new Array(n).fill(0);\n\n    for (let i = 0, idx = -n; i < n; ++i) {\n        if (s[i] === c) {\n            idx = i;\n        }\n        ans[i] = i - idx;\n    }\n\n    for (let i = n - 1, idx = 2 * n; i >= 0; --i) {\n        if (s[i] == c) {\n            idx = i;\n        }\n        ans[i] = Math.min(ans[i], idx - i);\n    }\n    return ans;\n};\n···\n## 复杂度分析\n时间复杂度： O(n)\n空间复杂度：O(1)\n### \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186383345","body":"`/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = [];\r\n    this.max = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if(this.stack.length < this.max){\r\n      this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n   return this.stack.pop() ?? -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    k = this.stack.length > k ? k : this.stack.length;\r\n    for(let i = 0; i < k; i++){\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n`\r\n# 复杂度\r\n## 时间复杂度：\r\n- push O(1)\r\n- pop O(1)\r\n- inc O(n)\r\n- 空间复杂度：O(n)\r\n- push O(1)\r\n- pop O(1)\r\n- inc O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187632034","body":"`var decodeString = function(s) {\r\n    let str = '';\r\n    let num = '';\r\n    let numStack = [];\r\n    let strStack = [];\r\n    for(let i = 0; i < s.length; i++){\r\n\r\n        let item = s[i];\r\n        if(item === '['){ \r\n            numStack.push(Number(num));\r\n            strStack.push(str);\r\n            num = '';\r\n            str = ''\r\n        } else if(!isNaN(s[i])){\r\n            num += item\r\n        }else if(item === ']'){\r\n            str = strStack.pop() + str.repeat(Number(numStack.pop()));\r\n        }else {\r\n            str += item;\r\n        }\r\n    }\r\n    return str;\r\n};`\r\n# 时间复杂度O(n)\r\n# 空间复杂度 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189791229","body":"`var MyQueue = function() {\r\n    this.stack1 = [];\r\n    this.stack2 = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    while(this.stack1.length){\r\n        this.stack2.push(this.stack1.pop());\r\n    }\r\n    const result = this.stack2.pop();\r\n    while(this.stack2.length){\r\n       this.stack1.push(this.stack2.pop()); \r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack1[0];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack1.length === 0 \r\n};`\r\n# 时间复杂度\r\n## 删除 O(N)  其他O(1)\r\n# 空间复杂度\r\n## O(n)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189953070","body":"`var maxChunksToSorted = function(arr) {\r\n    let arr2 = arr.slice().sort((a, b) => a - b);\r\n    let sum1 = 0;\r\n    let sum2 = 0;\r\n    let total = 0;\r\n    for(let i = 0; i < arr.length; i++){\r\n       if(sum1 === sum2){\r\n           total++;\r\n            sum1 = 0; \r\n            sum2 = 0;\r\n       } \r\n       sum1 += arr[i];\r\n       sum2 += arr2[i];\r\n    }\r\n    return total;\r\n};`\r\n- 时间复杂度：O(n)\r\n-  空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191063019","body":"`var rotateRight = function(head, k) {\r\n    if(!head || !k){\r\n        return head;\r\n    }\r\n    let len = 1;\r\n    let cur = head;\r\n    while(cur.next){\r\n        len++;\r\n        cur = cur.next;\r\n    }\r\n    k = len - k % len;\r\n    cur = head.next;\r\n    while(k){\r\n        cur = cur.next\r\n        k--;\r\n    }\r\n    let l = cur.next;\r\n    cur.next = null;\r\n    return l;\r\n};`\r\n- 时间复杂度 O(n)\r\n-  空间复杂度O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1194859161","body":"    var getIntersectionNode = function(headA, headB) {\r\n    if(headB === null || headB === null){\r\n        return null;\r\n    }\r\n    let map = new Set();\r\n    let a = headA;\r\n    let b = headB;\r\n    while(a){\r\n        map.add(a);\r\n        a = a.next;\r\n    }\r\n    while(b){\r\n        if(map.has(b)){\r\n            return b;\r\n        }\r\n        b = b.next;\r\n    }\r\n    return null;\r\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193479362","body":"´function(head) {\r\n    if(!head || !head.next){\r\n        return null;\r\n    }\r\n    let map = new Set();\r\n    while(head){\r\n        if(map.has(head)){\r\n            return head;\r\n        }\r\n         map.add(head)\r\n        head = head.next;\r\n    }\r\n    return null;\r\n};´\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196075451","body":"    var maxDepth = function(root) {\r\n    if(root === null){\r\n        return 0\r\n    }\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186424382","body":"##### 想法\r\n1. 设计一个大小为`MaxSize`大小的栈，因为固定大小，想到了用数组表示\r\n2. 进栈，要比较当前栈是否栈满；因此，如何判断当前栈的元素个数\r\n3. 出栈，要比较当前栈是否栈空；\r\n4. 不论进栈还是出栈，都要比较当前栈顶元素的索引值，因此，可以设计一个标志位，当作实例变量。在每次进行比较时，用`++top`或者`top--`可以指向当前的栈顶。\r\n##### 代码\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1; \r\n\r\n    }    \r\n    public void push(int x) {\r\n        //判断当前栈空间的长度\r\n        if(top!=stack.length-1){\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }    \r\n    public int pop() {\r\n        if(top != -1){\r\n            int element = stack[top];\r\n            top--;\r\n            return element;\r\n        }else return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(top<k){\r\n            for(int i=0; i<=top; i++){\r\n                stack[i]+=val;\r\n            }\r\n        }else{\r\n            for(int i=0; i<k; i++){\r\n                stack[i]+=val;\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187461656","body":"#### code\r\n```Java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n       /*\r\n       分四种情形，数字、字母\r\n       '[' 和 ']'\r\n       */\r\n\r\n       StringBuilder result = new StringBuilder();\r\n       int num = 0;    \r\n       LinkedList<Integer> multi = new LinkedList<>();\r\n       LinkedList<String> str = new LinkedList<>();\r\n\r\n       for(Character c: s.toCharArray()){\r\n\r\n           if(c>='0' && c<='9') {\r\n               num = num * 10 + Integer.parseInt(c + \"\");\r\n           }else if(c=='['){\r\n               multi.addLast(num);\r\n               str.addLast(result.toString());\r\n               num = 0;\r\n               result = new StringBuilder();\r\n           }else if(c == ']'){\r\n               StringBuilder tmp = new StringBuilder();\r\n               int curTimes = multi.removeLast();\r\n               for(int i=1; i<=curTimes; i++) tmp.append(result);\r\n\r\n               result = new StringBuilder(str.removeLast() + tmp);\r\n \r\n           }else result.append(c);\r\n\r\n       }\r\n       return result.toString();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189091664","body":"### 想法\r\n既然规定两个栈模拟队列，把其中一个栈当作正常栈，后进先出，另一栈模拟逆栈，将正常栈的元素倒序放入逆栈中\r\n### 在写代码时遇到的bug\r\n在处理`pop()`代码时，直接让栈`s_out`直接`pop`了，没有考虑到`s_out`可能是空栈，会报空栈异常\r\n### 代码\r\n```Java\r\nclass MyQueue {\r\n    private Stack<Integer> s_in;\r\n    private Stack<Integer> s_out;\r\n    int font = 0;  //队列头元素\r\n\r\n\r\n    public MyQueue() {\r\n        s_in = new Stack<Integer>();\r\n        s_out = new Stack<Integer>();\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s_in.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        while(!s_in.isEmpty()){\r\n            s_out.push(s_in.pop());\r\n        }\r\n        font = s_out.pop();\r\n\r\n        return font;\r\n\r\n    }\r\n    \r\n    public int peek() {\r\n       if(s_out.isEmpty()){\r\n           while(!s_in.isEmpty()){\r\n               s_out.push(s_in.pop());\r\n           }\r\n       }\r\n       return s_out.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        if(s_in.isEmpty() && s_out.isEmpty()){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n```\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193074003","body":"### 链表变BTS（平均再平均--递归）\r\n 找到根结点，一分为二，然后从这两部分再开始递归\r\n\r\n### 代码\r\n```Java\r\npublic TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        if(head.next == null) return new TreeNode(head.val);\r\n\r\n        List<Integer> list = new ArrayList<>();\r\n\r\n        while(head!=null){\r\n            list.add(head.val);\r\n            head = head.next;\r\n\r\n        }\r\n        return BuildeTree(0, list.size()-1, list);\r\n    }\r\n\r\n    TreeNode BuildeTree(int left, int right, List<Integer> list){\r\n        if(left > right)return null;\r\n        //中间元素下标\r\n        int mid = left + (right-left+1)/2;\r\n\r\n        TreeNode root = new TreeNode(list.get(mid));\r\n        root.left = BuildeTree(left, mid-1, list);\r\n        root.right = BuildeTree(mid+1, right, list);\r\n\r\n        return root; \r\n\r\n    }\r\n```\r\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193235084","body":"### 想法\r\n1. **idea 1** 从相交点到`A`和`B`的末尾----> 从后往前找， 直到找到不同的元素为止\r\n2. **idea 2** 双指针\r\n### 代码\r\n```Java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n\r\n        if(headA==null || headB==null) return null;\r\n        ListNode pA = headA, pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == null ? headB : pA.next;\r\n            pB = pB == null ? headA : pB.next;\r\n        }\r\n        return pA;\r\n\r\n\r\n        \r\n    //     int flag = 0;\r\n\r\n    //     //判断链表A和链表B为空链表\r\n    //     if(headA == null) return null;\r\n    //     if(headB == null) return null;\r\n\r\n    //     //将链表转化为ArrayList\r\n    //     Set<Integer> listA = new HashSet<Integer>();\r\n    //     HashSet<Integer> listB = new HashSet<Integer>();\r\n    //     while(headA != null){\r\n    //         listA.add(headA.val);\r\n    //         headA = headA.next;\r\n    //     }\r\n    //      while(headB != null){\r\n    //         listB.add(headB.val);\r\n    //         headB = headB.next;\r\n    //     }\r\n    //     //找相交结点, 且后面的元素值都相同\r\n    //     //从后往前找\r\n    //     int i = 1;\r\n    //     while(true){\r\n    //         if(listA[listA.size()-i] == listB[listB.size()-i]){\r\n    //             flag = listA.get(i);\r\n    //             i++;\r\n\r\n    //         }else{\r\n    //             break;\r\n    //         }\r\n    //     }\r\n\r\n    //     return new ListNode(flag);   \r\n    \r\n    // }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197520129","body":"#### idea\r\n递归思想\r\n\r\n#### code\r\n```Java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p==null && q==null) return true;\r\n        if (p == null || q == null)  return false;\r\n        if(p.val != q.val){\r\n            return false;\r\n        }else{\r\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186457384","body":"**思路**\r\n栈的基本操作\r\n\r\n**Python代码**\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else:\r\n            return self.stack.pop()\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k,len(self.stack())):\r\n            self.stack[i]+=val\r\n        \r\n**复杂度**\r\n\r\n- 时间：O(N)\r\n\r\n- 空间：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188753934","body":"## 思路\r\n\r\n> + 两个栈一个输入一个输出\r\n\r\n##代码\r\n\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack_in=[]\r\n        self.stack_out=[]\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_in.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.stack_out:\r\n            return self.stack_out.pop()\r\n        while self.stack_in:\r\n            temp=self.stack_in.pop()\r\n            self.stack_out.append(temp)\r\n        return self.stack_out.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans=self.pop()\r\n        self.stack_out.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.stack_in)==0 and len(self.stack_out)==0\r\n\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193280445","body":"## 思路\r\n\r\n> + 双指针\r\n\r\n## 代码\r\n\r\n```\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a,b=headA,headB\r\n        while a!=b:\r\n            if a:\r\n                a=a.next\r\n            else:\r\n                a=headB\r\n            if b:\r\n                b=b.next\r\n            else:\r\n                b=headA\r\n        return a\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186457895","body":"\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length >= this.maxSize) return\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (!this.stack.length) return -1\n    return this.stack.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let n = this.stack.length < k ? this.stack.length : k\n\n    for (let i = n - 1; i >= 0; i--) {\n        this.stack[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\nn为数组长度\n- 时间复杂度：Push:$O(1)$, Pop:$O(1)$, increment:$O(k)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187379263","body":"\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    let num = 0, char = '', cur = '', top \n\n    for (let i = 0; i < s.length; i++) {\n        cur = s.charAt(i)\n\n        if (typeof +cur === 'number' && !isNaN(+cur)) {\n            num = num * 10 + +cur\n        } else if (cur === '[') {\n            stack.push([num, char])\n            num = 0\n            char = ''\n        } else if (cur === ']') {\n            top = stack.pop()\n            char = top[1] + new Array(top[0]).fill(char).join('')\n        } else {\n            char += cur\n        }\n    }\n\n    return char\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189149637","body":"- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar MyQueue = function() {\n    this.a = []\n    this.b = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.a.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this.b.length) return this.b.pop()\n    while (this.a.length) {\n        this.b.push(this.a.pop())\n    }\n    return this.b.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this.b.length) return this.b[this.b.length - 1]\n    while (this.a.length) {\n        this.b.push(this.a.pop())\n    }\n\n    return this.b[this.b.length - 1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.a.length && !this.b.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：均摊$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190407922","body":"单调栈\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  const stack = []\n\n  for (let i = 0; i < arr.length; i++) {\n    if (!stack.length || stack[stack.length - 1] <= arr[i]) {\n      stack.push(arr[i])\n    } else {\n      const cur = stack.pop()\n      while(stack[stack.length - 1] > arr[i]) {\n        stack.pop()\n      }\n      stack.push(cur)\n    }\n  }\n  return stack.length\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194157935","body":"\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let quick = head, slow = null\r\n\r\n    while (quick !== slow && quick.next) {\r\n        slow = slow ? slow.next : head.next\r\n        quick = quick.next.next\r\n        if (!quick) return null\r\n    }\r\n    if (!quick || !quick.next) return null\r\n    quick = head\r\n    while (quick !== slow) {\r\n        quick = quick.next\r\n        slow = slow.next\r\n    }\r\n\r\n    return quick\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为链表长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186475438","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.arr = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.maxSize === this.arr.length){\n        return\n    }\n    this.arr.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.arr.length === 0){\n        return -1;\n    }\n    return this.arr.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let min = Math.min(k,this.arr.length );\n    for(let i=0;i< min;i++){\n        this.arr[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186981987","body":"```javascript\nvar isNumber = function(s) {\n    return !isNaN(Number(s))\n}\n\nvar getStackStrStr = function(stack= []){\n    // return stack.join();\n    let res = '';\n    while(stack.length){\n        res+=stack.shift()\n    }\n    return res;\n}\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  \n    let resStack = []\n    for(let i=0;i<s.length;i++){\n        let char = s[i];\n        if(char === ']'){\n            // 字符出栈\n            let tempchar = resStack.pop();\n            let tempstr = '';\n            while(tempchar !== '['){\n                tempstr = tempchar + tempstr\n                tempchar = resStack.pop();\n            }\n            tempchar = resStack.pop();\n            \n            let tempNum = ''\n            while(isNumber(tempchar)){\n                tempNum = tempchar + tempNum\n                tempchar = resStack.pop()\n            }\n            resStack.push(tempchar);\n            tempNum = Number(tempNum);\n\n\n            for(let i=0;i<tempNum;i++){\n                resStack.push(tempstr)\n            }\n\n\n            \n        }else{\n            resStack.push(char)\n        }\n    }\n    return resStack.join('')\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188889674","body":"```javascript\nvar MyQueue = function() {\n    this.pushStack = []\n    this.popStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0){\n        while(this.pushStack.length){\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    const last = this.pop();\n    this.popStack.push(last)\n    return last\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191182240","body":"```JavaScript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    let n = 1;\n    if(!head || !head.next || k === 0){\n        return head\n    }\n    let rightEnd = head;\n    while(rightEnd.next){\n        rightEnd = rightEnd.next;\n        n++\n    }\n\n    let add = n - k % n;\n    if(add === n){ // \n        return head\n    }\n\n    rightEnd.next = head;\n    while(add--){\n        rightEnd = rightEnd.next;\n    }\n    head = rightEnd.next;\n    rightEnd.next = null\n    return head\n\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196195808","body":"```JavaScript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(!root) return 0\n    return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186465529","body":"class Solution:\r\n    def addToArrayForm(self, num: list, k: int) -> list:\r\n        m = len(num)\r\n        num = num[::-1]\r\n        i = 0\r\n        sum = 0\r\n        res = []\r\n        for n in num:\r\n            sum += n * 10 ** i\r\n            i += 1\r\n        ret = sum + k\r\n\r\n        while ret > 0:\r\n            yushu = ret % 10\r\n            ret //= 10\r\n            res.append(yushu)\r\n\r\n        return res[::-1]","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186466400","body":" def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        c_index = []\r\n        str_len = len(s)\r\n        for i in range(str_len):\r\n            if s[i]==c:\r\n                c_index.append(i)\r\n\r\n        answer = [0]*str_len\r\n        for j in range(str_len):\r\n            answer[j]= min([abs(j-m) for m in c_index])\r\n        return answer","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186475633","body":"class CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.val = []\r\n        self.size = 0\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.val.append(x)\r\n            self.size +=1\r\n        else:\r\n            return -1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.size ==0:\r\n            return -1\r\n        else:\r\n            pop_val = self.val[-1]\r\n            del self.val[-1]\r\n            self.size -=1\r\n            return pop_val\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        max_inc_num = min(k,self.size)\r\n        for i in range(max_inc_num):\r\n            self.val[i] = self.val[i] + val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187614280","body":"class Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188961888","body":"class MyQueue(object):\r\n\r\n    def __init__(self):\r\n        self.stk =[]\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.stk.append(x)\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.stk is not None:\r\n            return self.stk.pop(0)\r\n\r\n\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if  self.stk is not None:\r\n            return self.stk[0]\r\n\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        if not self.stk:\r\n            return True\r\n        else:\r\n            return False\r\n复杂度\r\n时间复杂度O(1)\r\n空间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190422747","body":"class Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        \r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n复杂度\r\n时间复杂度O(n)\r\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191614812","body":"# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        cur =head\r\n        n = 1\r\n        while  cur.next:    \r\n            cur = cur.next\r\n            n+=1\r\n        add = n - k%n\r\n        if add==n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        # 找到第k个位置\r\n     \r\n        while add:\r\n            cur = cur.next\r\n            add-=1\r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret\r\n复杂度\r\n空间复杂度O（n）\r\n时间复杂度O（k）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192692489","body":"class ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        newHead = head.next\r\n        head.next = self.swapPairs(newHead.next)\r\n        newHead.next = head\r\n        return newHead\r\n复杂度\r\n时间复杂度O（n）\r\n空间复杂度O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193132272","body":"class Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        \r\n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\r\n            if left == right:\r\n                return None\r\n            mid = getMedian(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n        \r\n        return buildTree(head, None)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193279899","body":"class Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A, B = headA, headB\r\n        while A != B:\r\n            A = A.next if A else headB\r\n            B = B.next if B else headA\r\n        return A","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193997948","body":"class Solution(object):\r\n    def detectCycle(self, head):\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196825512","body":"class Solution:\r\n    def maxDepth(self, root):\r\n        if root is None: \r\n            return 0 \r\n        else: \r\n            left_height = self.maxDepth(root.left) \r\n            right_height = self.maxDepth(root.right) \r\n            return max(left_height, right_height) + 1 \r\n\r\n作者：LeetCode-Solution\r\n链接：https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186494700","body":"#### JS  \n```\n function CustomStack(maxSize) {\n    this.arr = [];\n    this.maxSize = maxSize\n  }\n  CustomStack.prototype.push = function(x) {\n    const len = this.arr.length;\n    if (len < maxSize) { \n      this.arr[len] = x;\n    }\n    return;\n  }\n  CustomStack.prototype.pop = function () {\n    const len = this.arr.length;\n    if (len > 0) {\n      return this.arr.splice(0, 1);\n    }\n    return -1;\n  }\n  CustomStack.prototype.increment = function (k, val) {\n    return this.arr.map = function(item, index) {\n      if (index < k) {\n        return item + val;\n      }\n      return item;\n    }\n  }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187654709","body":"JS实现\r\n```\r\nfunction decodeStr (s) {\r\n  const repetStack = [];\r\n  const resStack = [];\r\n\r\n  let res = '';\r\n  let repet = 0;\r\n\r\n  for(let i = 0; i < s.length; i++) {\r\n    let cur = s.charAt(i);\r\n    if (cur === '[') {\r\n      repetStack.push(repet);\r\n      resStack.push(res);\r\n      repet = '';\r\n      res = '';\r\n    } else if (cur === ']') {\r\n      let count = repetStack.pop();\r\n      let tempStr = '';\r\n      for(let j = 0; j < count; j++) {\r\n        tempStr += res;\r\n      }\r\n      res = resStack.pop() + tempStr;\r\n    } else if (cur >= '0' && cur <= '9') {\r\n      repet = repet * 10 + (cur-'0')\r\n    } else {\r\n      res += cur;\r\n    }\r\n  }\r\n  return res;\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195627633","body":"```\r\nvar LRUCache = function(capacity) {\r\n  this.max = capacity;\r\n  this.map = new Map();\r\n};\r\n\r\nLRUCache.prototype.get = function(key) {\r\n  if (this.map.has(key)) {\r\n      const value = this.map.get(key);\r\n      this.map.delete(key);\r\n      this.map.set(key, value);\r\n      return value;\r\n  }\r\n  return -1;\r\n};\r\n\r\nLRUCache.prototype.put = function(key, value) {\r\n  if (this.map.has(key)) {\r\n      this.map.delete(key);\r\n  }\r\n  this.map.set(key, value);\r\n  if(this.map.size > this.max){\r\n      this.map.delete(this.map.keys().next().value)\r\n  }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186500203","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186511542","body":"# 思路:用列表模拟\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.data = []\r\n        self.maxSize=maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size<self.maxSize:\r\n            self.data.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size == 0:\r\n            return -1\r\n        else:\r\n            ans = self.data.pop()\r\n            self.size -= 1\r\n            return ans\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.size < k:\r\n            for i in range(self.size):\r\n                self.data[i] += val\r\n        else:\r\n            for i in range(k):\r\n                self.data[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n时间复杂度：O（k）\r\n空间复杂度：O（1）","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190449428","body":"# 思路：计数排序前后的数组前i个元素，计数相同就可以分块\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        ans = 0\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        for a,b in zip(arr, sorted(arr)):\r\n            count_a[a] += 1\r\n            count_b[b] += 1\r\n            if count_a == count_b:\r\n                ans += 1 \r\n        return ans\r\n        \r\n```\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193062429","body":"# 思路\r\n找到链表点，左边的当左子树，右边的当右子树\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return head\r\n        pre,slow,fast = None,head,head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast :\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n···\r\n时间复杂度:O(nlogn)\r\n空间复杂度：O(logn)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194089892","body":"# 思路\r\n快慢指针，第一次相遇后快指针移动到头部，接下来快慢指针每次走一步，再次相遇就是环的起点\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast = head\r\n        slow = head\r\n        x = None\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if slow == fast:\r\n                x = fast\r\n                break\r\n        if not x:\r\n            return None\r\n        fast = head\r\n        while slow != fast:\r\n            slow=slow.next\r\n            fast = fast.next\r\n        return slow\r\n```\r\n时间复杂度：O(1)\r\n空间复杂度：O（1）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196671066","body":"# 思路\r\n递归返回左右子树的最大深度\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186450526","body":"### 思路：\r\n从后往前进位，将k转化成字符串，处理进位\r\n\r\n### 代码\r\n```js\r\n   var addToArrayForm = function(num, k) {\r\n    let kIndex = (k + '').length - 1;\r\n    let nIndex = num.length - 1;\r\n    // 进位\r\n    let carrayBit = 0;\r\n    for (; kIndex >= 0 && nIndex >=0 ; kIndex--, nIndex--) {\r\n        let sum = carrayBit + (+(k+'').charAt(kIndex)) + num[nIndex];\r\n        num[nIndex] = sum % 10;\r\n        carrayBit = Math.floor(sum / 10);\r\n    }\r\n    // 相同位\r\n    if (kIndex <0 && nIndex < 0) {\r\n        return carrayBit ? [carrayBit, ...num] : num;\r\n    }\r\n    // k位数多\r\n    else if (kIndex <0) {\r\n        for (; nIndex >=0 ; nIndex--) {\r\n            let sum = carrayBit + num[nIndex];\r\n            num[nIndex] = sum % 10;\r\n            carrayBit = Math.floor(sum / 10);\r\n        }\r\n        return carrayBit ? [carrayBit, ...num] : num;\r\n    }\r\n    // num位数多\r\n    else {\r\n        let tmpArr = new Array(kIndex);\r\n        for (; kIndex >=0 ; kIndex--) {\r\n            let sum = carrayBit + (+(k+'').charAt(kIndex));\r\n            tmpArr[kIndex] = sum % 10;\r\n            carrayBit = Math.floor(sum / 10);\r\n        }\r\n        return carrayBit ? [carrayBit, ...tmpArr, ...num] : [...tmpArr, ...num];\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)\r\n\r\n### 代码优化(参考题解)：\r\n从右到左，通过不断除以10来取对应位的数字\r\n如num = [1, 2] k=999。 \r\n第一次循环：k = 999 + 2 = 1001, res[0] = k % 10 = 1\r\n第二次循环：\r\n    k = Math.floor(k / 10) = 100 \r\n    k = k + 1 = 101\r\n    res[1] = k % 10 = 1\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186476948","body":"### 思路：\r\n对于字符串中的位置为i的字符，寻找左侧字符C和右侧字符C的位置，并保存\r\nleft = 到其左侧最近的字符 c 的距离\r\nright = 到其右侧最近的字符 c 的距离\r\n如果字符的位置 > right，left = right, 并重新寻找right\r\nres[i] = min(i - left, right - i)\r\n\r\n### 代码\r\n```js\r\n   var shortestToChar = function(s, c) {\r\n    var res = [];\r\n    // 左指针\r\n    var left = -Infinity;\r\n    // 右指针\r\n    var right = 0;\r\n    var len = s.length;\r\n    function setPointer (left, right) {\r\n        left = right < 0 ? -Infinity : right;\r\n        for (var i = right + 1; i < len; i++) {\r\n            if (s[i] === c) {\r\n                right = i;\r\n                return [left, right];\r\n            }\r\n        }\r\n        if (i === len) {\r\n            right = Infinity;\r\n        }\r\n        return [left, right];\r\n    }\r\n    [left, right] = setPointer(-Infinity, -1);\r\n            \r\n    for (var charIndex = 0; charIndex < len; charIndex++ ) {\r\n        // 维护左指针\r\n        if (charIndex > right) {\r\n            [left, right] = setPointer(left, right);\r\n        }\r\n        res[charIndex] = Math.min(charIndex-left,  right - charIndex);\r\n    }\r\n    return res;\r\n};\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186530463","body":"### 思路：\r\n    按照规则实现\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n    this.stack = new Array();\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length) {\r\n        return this.stack.pop();\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * 栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const n = Math.min(this.stack.length, k);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n        this.stack[i] += val; \r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度push和pop为O(1)，increment为O（min（k，n））\r\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1189120052","body":"### 思路：\r\n遍历数组，\r\n1. 如果是'[',直接入栈\r\n2. 如果是'数字'，将连续数字字符识别出来，统一放入栈中\r\n3. 如果是']',进行处理\r\n-  ① 连续获取字符串，直到遇到”[“\r\n- ② 取出数字\r\n- ③ 计算出字符串后再入栈\r\n4. 如果是'普通字符'，正常入栈\r\n\r\n### 代码\r\n```js\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    let len = s.length;\r\n    let i = 0;\r\n    while(i < len) {\r\n        let char = s[i];\r\n        if (char === '[') {\r\n            stack.push('[');\r\n            i++;\r\n        }\r\n        else if (/[0-9]/.test(+s[i])) {\r\n            let strNum = s[i];\r\n            i++;\r\n            while(/[0-9]/.test(+s[i])) {\r\n                strNum += s[i];\r\n                i++;\r\n            }\r\n            stack.push(strNum)\r\n        }\r\n        else if (char === ']') {\r\n            let str = stack.pop();\r\n            let cur = stack.pop();\r\n            while(true) {\r\n                if (cur === '[') break;\r\n                str = cur + str;\r\n                cur = stack.pop();\r\n            }\r\n            \r\n            const num = +stack.pop();\r\n            const strList = Array(num).fill().map(() => str).join('');\r\n            stack.push(strList);\r\n            i++;\r\n        }\r\n        else {\r\n            stack.push(s[i]);\r\n            i++;\r\n        }\r\n        \r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189126896","body":"### 思路：\r\n两个栈\r\n\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n    this.size = 0;\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    stack.push(res);\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.stack.length;\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189871624","body":"### 思路：\r\n单调栈（递增）\r\n- 当前值大于等于栈顶，可以成块\r\n- 当前值小于栈顶，去掉之前比他大的值，只保留栈顶用于成块\r\n\r\n### 代码\r\n```js\r\n// 获取栈顶元素\r\nvar stackTop = (stack) => {\r\n    return stack[stack.length - 1];\r\n}\r\nvar maxChunksToSortedError = function(arr) {\r\n    if (!arr.length) return 0;\r\n    let ascStack = [arr[0]];\r\n    for (let i=1; i < arr.length; i++) {\r\n        let top = stackTop(ascStack);\r\n        if (arr[i] < top) {\r\n\r\n        }\r\n        else {\r\n            ascStack.push(arr[i]);\r\n        }\r\n    }\r\n    return ascStack.length;\r\n};\r\n// [1,1,0,0,1]\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n    if (!arr.length) return 0;\r\n    let ascStack = [arr[0]];\r\n    for (let i=1; i < arr.length; i++) {\r\n        let top = stackTop(ascStack);\r\n        if (arr[i] < top) {\r\n            // 小于的时候，只保留栈顶用于成块\r\n            while(ascStack.length && stackTop(ascStack) > arr[i]) {\r\n                ascStack.pop();\r\n            }\r\n            ascStack.push(top);\r\n        }\r\n        else {\r\n            // >= 可以独立成块\r\n            ascStack.push(arr[i]);\r\n        }\r\n    }\r\n    return ascStack.length;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1192086515","body":"### 思路：\r\n取余数 + 快慢指针\r\n\r\n### 代码\r\n```js\r\nvar rotateRight = function(head, k) {\r\n    function ListNode(val, next) {\r\n        this.val = (val===undefined ? 0 : val)\r\n        this.next = (next===undefined ? null : next)\r\n    }\r\n    if (!head) {\r\n        return head;\r\n    }\r\n    let dummyNode = new ListNode();\r\n    dummyNode.next = head;\r\n    let cur = head;\r\n    // 计算链表的长度\r\n    let length = 1;\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        length ++;\r\n    }\r\n    // 快慢指针的间距\r\n    k = k % length;\r\n    let slowNode = head;\r\n    let fastNode = head;\r\n    for (let i = 1; i <= k; i++) {\r\n        fastNode = fastNode.next;\r\n    }\r\n\r\n    // 快慢指针同时前进\r\n    while(fastNode.next) {\r\n        slowNode && (slowNode = slowNode.next);\r\n        fastNode = fastNode.next;\r\n    }\r\n    // 调整节点\r\n    fastNode.next = head;\r\n    dummyNode.next = slowNode.next;\r\n    slowNode.next = null;\r\n    return dummyNode.next;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192102306","body":"### 思路：\r\n记录前中后节点\r\n待优化，减少pre节点的记录改用xx.next\r\n\r\n### 代码\r\n```js\r\nfunction ListNode(val, next) {\r\n    this.val = (val===undefined ? 0 : val)\r\n    this.next = (next===undefined ? null : next)\r\n}\r\n\r\nvar swapPairs = function(head) {\r\n    if (!head) return head;\r\n    if (head && !head.next) return head;\r\n    // 创建dumy节点\r\n    let dummyNode = new ListNode();\r\n\r\n    let pre = dummyNode;\r\n    let cur = head;\r\n    let next = head.next;\r\n    while (true) {\r\n        pre.next = cur.next;\r\n        cur.next = next.next;\r\n        tmp = next.next;\r\n        next.next = cur;\r\n        \r\n        pre = cur;\r\n        if (tmp && tmp.next) {\r\n            cur = tmp;\r\n            next = tmp.next;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return dummyNode.next;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193104162","body":"### 思路：\r\n1、将有序链表转成有序数组, 分治\r\n[-10,-3,0,5,9] 输出为[0,-10,5,null,-3,null,9]\r\n2、快慢指针\r\n为了断开，我们需要保存慢指针的前一个节点，因为单向链表的结点没有前驱指针。\r\n### 代码\r\n\r\n```js\r\nvar sortedListToBST = function (head) {\r\n    const arr = [];\r\n    while (head) {\r\n        // 将链表节点的值逐个推入数组arr\r\n        arr.push(head.val);\r\n        head = head.next;\r\n    }\r\n    // 根据索引start到end的子数组构建子树\r\n    const buildBST = (start, end) => {\r\n        if (start > end) return null; // 指针交错，形成不了子序列，返回null节点\r\n        // >>> 无符号右移动。math.floor\r\n        const mid = (start + end) >>> 1; // 求中间索引 中间元素是根节点的值\r\n        const root = new TreeNode(arr[mid]); // 创建根节点\r\n        root.left = buildBST(start, mid - 1); // 递归构建左子树\r\n        root.right = buildBST(mid + 1, end); // 递归构建右子树\r\n        return root; // 返回当前子树\r\n    };\r\n    const root = buildBST(0, arr.length - 1); // 根据整个arr数组构建\r\n    return root;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193263203","body":"### 思路：\r\n分别与另外一个链表’连接‘，第二轮时相遇\r\n没有修改next，只是不断改变当前指针而已，所以不会出环\r\n\r\n\r\n### 代码\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA,\r\n        b = headB;\r\n    while (a != b) {\r\n        a = a === null ? headB : a.next;\r\n        b = b === null ? headA : b.next;\r\n    }\r\n    return a;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1196887393","body":"### 思路\r\n1. hash + 双向链表，其中hash用来判断链表中是否存在节点，双向链表快速删除和插入节点\r\n2. get操作，\r\n* 如果关键字 key 存在于缓存中，则返回关键字的值并且该节点移到尾部 <=> 删除该节点, 尾部插入该节点, 维护hash值，返回该节点的值\r\n* 如果关键字 key 没有存在于缓存中返回 -1\r\n3. put操作\r\n* 如果关键字已经存在，则变更其数据值， <=>删除该节点，在尾部插入新节点，维护hash值；\r\n* 当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间 <=> 删除第一个节点，然后将新节点放到尾部，维护hash值\r\n* 当缓存未达到最大上限时，直接将插入该值 <=> 在尾部插入该节点，维护hash值\r\n\r\n### 踩坑点：\r\n1. 如果关键字已经存在，则变更其数据值\r\n```js\r\n//[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"put\",\"get\"]\r\n// [[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\r\n// put时，存在key，也要删除旧节点，插入新节点\r\n```\r\n2. 现将节点插入到链表中，再放到hash表里，否则hash里的节点缺少pre和next\r\n3. 对于删除，需要处理当前节点前后指针\r\n4. 对于插入，需要处理当前节点左侧两个指针和右侧两个指针\r\n5. 创建dummy节点，以免处理各种边界问题\r\n\r\n### 代码\r\n```js\r\nclass Node {\r\n    constructor(key, val, next, pre) {\r\n        this.key = (key===undefined ? 0 : key);\r\n        this.val = (val===undefined ? 0 : val);\r\n        this.next = (next===undefined ? null : next);\r\n        this.pre = (pre===undefined ? null : pre);\r\n    }\r\n}\r\n\r\nclass MyDoubleList {\r\n    constructor() {\r\n        // dummy节点，免于处理边界\r\n        this.head = new Node('head');\r\n        // dummy节点，免于处理边界\r\n        this.tail = new Node('tail');\r\n        this.head.next = this.tail;\r\n        this.tail.pre = this.head;\r\n        // 链表长度\r\n        this.size = 0;\r\n    }\r\n    // 在链表尾部添加节点(注意是尾部，所以lru靠尾部的数据是最近使用的)\r\n    addLast(x) {\r\n        // 左\r\n        x.pre = this.tail.pre;\r\n        this.tail.pre.next = x;\r\n        // 右\r\n        this.tail.pre = x;\r\n        x.next = this.tail;\r\n        this.size ++;\r\n    }\r\n\r\n    // 删除链表中某一个节点\r\n    remove(x) {\r\n        x.pre.next = x.next;\r\n        x.next.pre = x.pre;\r\n        this.size--;\r\n    }\r\n\r\n    // 删掉第一个节点\r\n    removeFirst(x) {\r\n        if (this.head.next == this.tail) {\r\n            return null;\r\n        }\r\n        let firstNode = this.head.next;\r\n        this.remove(firstNode);\r\n        return firstNode;\r\n    }\r\n\r\n    getSize() {\r\n        return this.size;\r\n    }\r\n}\r\n/**\r\n* @param {number} capacity\r\n*/\r\nvar LRUCache = function(capacity) {\r\n    this.capacity = capacity;\r\n    this.hashObj = {};\r\n    this.cache = new MyDoubleList();\r\n};\r\n\r\n/** \r\n* @param {number} key\r\n* @return {number}\r\n*/\r\nLRUCache.prototype.get = function(key) {\r\n    const node = this.hashObj[key];\r\n    if (!node) {\r\n        return -1;\r\n    }\r\n    // 如果有node，移到后边, 作为最近使用的\r\n    this.cache.remove(node);\r\n    this.cache.addLast(node);\r\n\r\n    return node.val;\r\n};\r\n\r\n/** \r\n* @param {number} key \r\n* @param {number} value\r\n* @return {void}\r\n*/\r\nLRUCache.prototype.put = function(key, value) {\r\n    \r\n    const node = this.hashObj[key];\r\n    const newNode = new Node(key, value);\r\n    // 如果关键字已经存在，则变更其数据值\r\n    if (node) {\r\n        // 从hash里删除旧数据\r\n        delete this.hashObj[key];\r\n        // 从链表中删除数据\r\n        this.cache.remove(node);\r\n        \r\n        // 将新数据插入到链表, 要先插入链表，否则没有pre和next\r\n        this.cache.addLast(newNode);\r\n        // 将新数据插入到hash\r\n        this.hashObj[key] = newNode;\r\n        return;\r\n    }\r\n\r\n    const length = this.cache.getSize();\r\n    if (this.capacity === length) {\r\n        // 无空间，先删除第一个节点后插入(删除最久未使用的元素)\r\n        // 从hash中移出\r\n        delete this.hashObj[this.cache.head.next.key];\r\n        // 从链表中移除\r\n        this.cache.removeFirst();\r\n\r\n        this.cache.addLast(newNode);\r\n        // 加到hash中\r\n        this.hashObj[key] = newNode;\r\n    }\r\n    else {\r\n        this.cache.addLast(newNode);\r\n        // 加到hash中\r\n        this.hashObj[key] = newNode;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n* 时间复杂度：get:O(1), put: O(1)\r\n* 空间复杂度：get:O(n), put: O(n)， n为capacity容量","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196849739","body":"### 思路：\r\n求左右子树深度的最大值\r\n\r\n### 代码\r\n```js\r\nvar maxDepth = function(root) {\r\n    if (root === null) {\r\n        return 0;\r\n    }\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197567344","body":"### 思路：\r\n相同的树要求：① val 相同 ② 左子树中的val同 ③ 右子树val同\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n    if (p === null && q === null) {\r\n        return true;\r\n    } \r\n    if (p === null || q === null) {\r\n        return false;\r\n    }\r\n    return ((p && p.val) === (q && q.val)) \r\n        && isSameTree(p.left, q.left) \r\n        && isSameTree(p.right, q.right);\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186703874","body":"### 题目：[989. 数组形式的整数加法](https://leetcode.cn/problems/add-to-array-form-of-integer/)\r\n### 思路：\r\n利用数组和数字的特性分别处理num和k，在循环中加判断来处理num和k长度不一的问题\r\n### python代码\r\n```python \r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        index = len(num) - 1\r\n        flag = 0\r\n        res = []\r\n        while index >= 0 or k != 0:\r\n            x = num[index] if index >= 0 else 0\r\n            y = k % 10 if k != 0 else 0\r\n            sum = x + y + flag\r\n            res.append(sum % 10)\r\n            flag = sum // 10\r\n            k = k // 10\r\n            index -= 1\r\n        if flag != 0:\r\n            res.append(flag)\r\n        return res[::-1]\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531027","body":"### 题目：1381. 设计一个支持增量操作的栈\r\n### 思路\r\n利用数组append和pop方法\r\n### python代码\r\n``` python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) == self.maxSize:\r\n            return False\r\n        else:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack: return -1\r\n        else:\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack), k)):\r\n            self.stack[i] += val\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(min(maxSize, k))\r\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186812545","body":"### 题目：[394. 字符串解码](https://leetcode.cn/problems/decode-string/)\r\n### 思路：\r\n利用栈先进后出的特性模拟括号。遍历字符串，判断每个字符类型并进行不同处理。栈主要用来纪律记录每次括号之前已经整理好的字符串以及括号中字符串的循环次数。\r\n### python代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        res, tmp, mul = '', '', 0\r\n        for i in s:\r\n            if i.isdigit(): \r\n                mul = int(i) + 10 * mul\r\n            elif i == '[': \r\n                stack.append((mul, res))\r\n                res, mul = '', 0\r\n            elif i == ']':\r\n                mul1, tmp = stack.pop()  # tmp为[之前的所有字符\r\n                res = tmp + mul1 * res\r\n            else:\r\n                res += i\r\n        return res\r\n    \r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n), e.g. '1[a1[a1[a]]]'","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188613232","body":"### 题目：[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)\r\n### 思路：\r\n用两个栈模拟队列，第一个栈尾是队列的开头，所以每次执行push操作的时候需要用另一个栈记录该栈的所有元素，清空该栈之后再执行push操作。\r\n### python代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n        self.stack1.append(x)\r\n        while self.stack2:\r\n            self.stack1.append(self.stack2.pop())\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack1: return False\r\n        return self.stack1.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.stack1: return False\r\n        return self.stack1[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if not self.stack1 and not self.stack2: return True\r\n        else: return False\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：push: O(n), pop/peek/empty: O(1)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190030476","body":"### 题目 ：[768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\r\n### 思路：\r\n使用栈来记录每个块中最大值，需要保证栈是单调的。遍历数组arr，将每个值和栈顶的值进行比较，如果大于等于栈顶值则入栈；小于栈顶值则将取出栈顶值，直到该值大于等于栈顶值，并记录下第一个被取出的栈顶值。例如：[5,1,1,8,1,6,5,9,7,8], 栈的变化过程为：[5] -> [5,8] -> [8] -> [9], 所以最后结果为1。\r\n### python代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        if not arr: return False\r\n        stack = []\r\n        i = 0\r\n        while i < len(arr):\r\n            if not stack: stack.append(arr[i])\r\n            elif arr[i] >= stack[-1]:\r\n                stack.append(arr[i])\r\n            elif arr[i] < stack[-1]:\r\n                head = stack.pop()\r\n                while stack and arr[i] < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            i += 1\r\n        return len(stack)\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)，遍历数组\r\n- 空间复杂度：O(n)，栈所需要的空间，最差能到O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191578936","body":"### 题目：61. 旋转链表\n### 思路：\n快慢指针\n### python代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        cur = head\n        count = 0\n        while cur:\n            cur = cur.next\n            count += 1\n        k = k % count\n        slow, fast = head, head\n        step = 0\n        while fast.next:\n            step += 1\n            if step > k:\n                slow = slow.next\n            fast = fast.next\n        fast.next = head\n        res = slow.next\n        slow.next = None\n        return res\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192204334","body":"### 题目：[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)\r\n### 思路\r\n使用三个指针来迭代的交换两个节点，使用prehead处理边界问题\r\n### python代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next: return head\r\n        prehead = ListNode(0, head)\r\n        pre, cur, tmp = prehead, prehead, prehead\r\n        while cur.next and cur.next.next:\r\n            pre, cur = pre.next, cur.next.next\r\n            tmp.next, cur.next, pre.next = cur, pre, cur.next\r\n            tmp, cur = pre, pre\r\n        return prehead.next\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195490623","body":"### 题目：[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)\r\n### 思路：\r\n双向链表+哈希表\r\n### python代码\r\n```python\r\nclass LRUCache(collections.OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        super().__init__()\r\n        self.capacity = capacity\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self:\r\n            return -1\r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self) > self.capacity:\r\n            self.popitem(last=False)\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196499582","body":"### 题目：[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\r\n### 思路：\r\n广度优先，深度优先\r\n### python代码\r\n```python\r\n# 广度优先\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root: return 0\r\n        queue = [root]\r\n        depth = 0\r\n        while queue:\r\n            depth += 1\r\n            length = len(queue)\r\n            for _ in range(length):\r\n                node = queue.pop(0)\r\n                if node.left: queue.append(node.left)\r\n                if node.right: queue.append(node.right)\r\n        return depth\r\n\r\n# 深度优先\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root: return 0\r\n        def DFS(root):\r\n            if not root: return 0\r\n            return max(DFS(root.left), DFS(root.right)) + 1\r\n        return DFS(root)\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197556689","body":"### 题目：[100. 相同的树](https://leetcode.cn/problems/same-tree/)\r\n### 思路\r\n深度优先，广度优先\r\n### python代码\r\n```python\r\n# 深度优先\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        def DFS(root1, root2):\r\n            if not root1 and not root2:\r\n                return True\r\n            elif not root1 or not root2:\r\n                return False\r\n            elif root1.val != root2.val:\r\n                return False\r\n            return DFS(root1.left, root2.left) and DFS(root1.right, root2.right)\r\n        return DFS(p, q)\r\n```\r\n```python\r\n# 广度优先\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q: return True\r\n        elif not p or not q: return False\r\n        queue1, queue2 = [p], [q]\r\n        while queue1 and queue2:\r\n            node1 = queue1.pop(0)\r\n            node2 = queue2.pop(0)\r\n\r\n            if node1.val != node2.val: return False\r\n\r\n            if node1.left and node2.left:\r\n                queue1.append(node1.left)\r\n                queue2.append(node2.left)\r\n            elif node1.left or node2.left:\r\n                return False\r\n\r\n            if node1.right and node2.right:\r\n                queue1.append(node1.right)\r\n                queue2.append(node2.right)\r\n            elif node1.right or node2.right:\r\n                return False\r\n            \r\n        if not queue1 and not queue2: return True\r\n        else: return False\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(min(m,n))\r\n- 空间复杂度：O(min(m,n))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186545797","body":"### 思路\r\n用数组实现\r\n### 代码\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length < this.maxSize) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    return this.stack.length ? this.stack.pop() : -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    let len = Math.min(k, this.stack.length)\r\n    for(let i = 0; i < len; i++) {\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n### 复杂度分析\r\n时间复杂度：push 和 pop 操作的时间复杂度为 O(1) 而 increment 操作的时间复杂度为 O(min(k, cnt))\r\n空间复杂度：O(1)O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187631118","body":"### 思路\r\n新增两个栈，一个存倍数，一个存待拼接的 str\r\n当 item 是数字时，求具体倍数\r\n当 item === '[' 时，numStack 入栈，strStack 入栈，并且 result、num 重置\r\n当 item === ']' 时，numStack、strStack 出栈，并将 result 重复 对应倍数\r\n### 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = []\r\n    let strStack = []\r\n    let num = 0, result = ''\r\n    for(let i= 0; i < s.length; i++) {\r\n        const item = s[i]\r\n        if(!isNaN(item)){\r\n            num = num * 10 + parseInt(item)\r\n        } else if(item === '[') {\r\n            strStack.push(result)\r\n            result = ''\r\n            numStack.push(num)\r\n            num = 0\r\n        } else if (item === ']') {\r\n            const repeatTimes = numStack.pop()\r\n            result = strStack.pop() + result.repeat(repeatTimes)\r\n        } else {\r\n            result += item\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189147371","body":"### 思路\r\n双栈实现\r\n### 代码\r\n```js\r\nvar MyQueue = function () {\r\n  this.inStack = [];\r\n  this.outStack = [];\r\n};\r\n\r\nMyQueue.prototype.push = function (x) {\r\n  this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function () {\r\n  if (!this.outStack.length) {\r\n    this.in2out();\r\n  }\r\n  return this.outStack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function () {\r\n  if (!this.outStack.length) {\r\n    this.in2out();\r\n  }\r\n  return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function () {\r\n  return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\nMyQueue.prototype.in2out = function () {\r\n  while (this.inStack.length) {\r\n    this.outStack.push(this.inStack.pop());\r\n  }\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度： O(n)\r\n空间复杂度： O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191543867","body":"### 思路\n将链表连成环，然后断开处于n-k-1位置的指针\n先遍历链表找到尾节点连着头\n遍历找到n-k-1的位置，断开节点\n### 代码\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if(!head || !head.next) return head\n    let count = 0\n    let p = head \n    while(p) {\n        count++\n        p = p.next\n    }\n    k = k % count\n    let slow = fast = head\n    while(fast.next) {\n        if(k-- <= 0) {\n            slow = slow.next\n        }\n        fast = fast.next\n    }\n    fast.next = head\n    let res = slow.next\n    slow.next = null\n    return res\n};\n```\n### 复杂度分析\n时间复杂度 O(n)\n空间复杂度 O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196840850","body":"### 思路\n递归，前序depth + 1，后续 depth - 1\n\n### 代码\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    let res = 0 \n    let depth = 0   \n    let traverse = (root) => {\n        if(root === null) {\n            return \n        }\n        depth ++\n        if (root.left === null && root.right === null) {\n            // 到达叶子节点，更新最大深度\n            res = Math.max(res, depth);\n        }\n        traverse(root.left);\n        traverse(root.right);\n        // 后序位置\n        depth--;\n    }\n    traverse(root)\n    return res\n};\n```\n### 复杂度分析\n时间复杂度 O(N)\n空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186549520","body":"class CustomStack:\n\n    def __init__(self, size: int):\n        self.st = []\n        self.cnt = 0\n        self.size = size\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n\n\n    def pop(self) -> int:\n        if self.cnt == 0: return -1\n        self.cnt -= 1\n        return self.st.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(self.cnt, k)):\n            self.st[i] += val","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190747230","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        def calculateLen(head):\n            n=1\n            while head.next:\n                n+=1\n                head = head.next\n            return n\n\n        if k==0 or not head or not head.next:\n            return head\n\n        n = calculateLen(head)\n        k=k%n\n        fast = slow = head\n        for i in range (k):\n            fast = fast.next\n        \n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n\n        fast.next = head\n        head = slow.next\n        slow.next = None\n        \n        return head\n\n        \n        \n        \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191952971","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = ListNode(0, head)\n        prev, curr = dummy, head\n        while curr and curr.next:\n            nxtpair = curr.next.next\n            second = curr.next\n\n            second.next = curr\n            curr.next = nxtpair\n            prev.next = second\n\n            prev = curr\n            curr = nxtpair\n        return dummy.next","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193351118","body":"    def detectCycle(self, head: ListNode) -> ListNode:\n        f=s=head\n        while f and f.next:\n            f = f.next.next\n            s = s.next\n            if f == s:\n                f = head\n                while f!=s:\n                    f= f.next\n                    s = s.next\n                return s","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194447938","body":"class ListNode:\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.prev = self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.left , self.right = ListNode(0,0),ListNode(0,0)\n        self.left.next = self.right\n        self.right.prev = self.left\n\n    def insert(self,node):\n        prev, nxt = self.right.prev, self.right\n        prev.next = nxt.prev = node\n        node.prev, node.next = prev, nxt\n        \n    def remove(self, node):\n        prev, nxt = node.prev, node.next\n        prev.next, nxt.prev = nxt, prev\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].val\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.remove(self.cache[key])\n        self.cache[key] = ListNode(key, value)\n        self.insert(self.cache[key])\n\n        if len(self.cache) > self.capacity:\n            lru = self.left.next\n            self.remove(lru)\n            del self.cache[lru.key]\n            \n\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195961672","body":"class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186977163","body":"# 思路：\r\n本题中可能出现括号嵌套的情况，比如`2[a2[bc]]`，这种情况下我们可以先转化成`2[abcbc]`，在转化成 `abcbcabcbc`。我们可以把字母、数字和括号看成是独立的 TOKEN，并用栈来维护这些 TOKEN。\r\n___\r\n# 代码实现\r\nC++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string getDigits(string &s, size_t &ptr) {\r\n        string ret = \"\";\r\n        while (isdigit(s[ptr])) {\r\n            ret.push_back(s[ptr++]);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string getString(vector <string> &v) {\r\n        string ret;\r\n        for (const auto &s: v) {\r\n            ret += s;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        vector <string> stk;\r\n        size_t ptr = 0;\r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n            if (isdigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                string digits = getDigits(s, ptr);\r\n                stk.push_back(digits);\r\n            } else if (isalpha(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.push_back(string(1, s[ptr++])); \r\n            } else {\r\n                ++ptr;\r\n                vector <string> sub;\r\n                while (stk.back() != \"[\") {\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(), sub.end());\r\n                // 左括号出栈\r\n                stk.pop_back();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = stoi(stk.back()); \r\n                stk.pop_back();\r\n                string t, o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime--) t += o; \r\n                // 将构造好的字符串入栈\r\n                stk.push_back(t);\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n};\r\n```\r\n___\r\n# 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189234348","body":"# 思路\r\n我们使用两个栈`s1,s2` 就能实现一个队列的功能。\r\n\r\n当调用`push`让元素入队时，只要把元素压入`s1`即可：\r\n___\r\n# 代码实现\r\nC++\r\n```C++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n___\r\n# 复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193773379","body":"# 思路\r\n判断两个链表是否相交，可以使用哈希集合存储链表节点。\r\n\r\n首先遍历链表 `headA`，并将链表 `headA` 中的每个节点加入哈希集合中。然后遍历链表 `headB`，对于遍历到的每个节点，判断该节点是否在哈希集合中：\r\n\r\n* 如果当前节点不在哈希集合中，则继续遍历下一个节点；\r\n\r\n* 如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 `headB` 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。\r\n\r\n如果链表 `headB` 中的所有节点都不在哈希集合中，则两个链表不相交，返回 `null`。\r\n___\r\n# 代码实现\r\nC++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        unordered_set<ListNode *> visited;\r\n        ListNode *temp = headA;\r\n        while (temp != nullptr) {\r\n            visited.insert(temp);\r\n            temp = temp->next;\r\n        }\r\n        temp = headB;\r\n        while (temp != nullptr) {\r\n            if (visited.count(temp)) {\r\n                return temp;\r\n            }\r\n            temp = temp->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```\r\n___\r\n# 复杂度分析\r\n时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 }headA 和 headB 的长度。需要遍历两个链表各一次。\r\n空间复杂度：O(m)，其中 m 是链表 headA 的长度。需要使用哈希集合存储链表 headA 中的全部节点。\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193732280","body":"# 思路\r\n遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。\r\n***\r\n# 代码实现\r\nC++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        unordered_set<ListNode *> visited;\r\n        while (head != nullptr) {\r\n            if (visited.count(head)) {\r\n                return head;\r\n            }\r\n            visited.insert(head);\r\n            head = head->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```\r\n---\r\n# 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187137051","body":"```class Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int> st_num;   \r\n        string symbol;       \r\n        int num=0;           \r\n        for(int i=0;i<s.size();i++)\r\n        {\r\n            if(s[i]>='0'&&s[i]<='9'){ \r\n                num=s[i]-'0'+num*10;\r\n            }else if(s[i]=='['){       \r\n                st_num.push(num);\r\n                num=0;\r\n                symbol+=s[i];\r\n            }else if(s[i]==']'){       \r\n                int j=symbol.size()-1;\r\n                string tmp_string;\r\n                while(symbol[j]!='[')\r\n                {\r\n                    tmp_string+=symbol[j];\r\n                    symbol.pop_back();\r\n                    j--;\r\n                }\r\n                symbol.pop_back();\r\n                int tmp_num=st_num.top();\r\n                st_num.pop();\r\n                reverse(tmp_string.begin(),tmp_string.end());\r\n                for(int k=0;k<tmp_num;k++)\r\n                {\r\n                    symbol+=tmp_string;\r\n                }\r\n            }else{                     \r\n                symbol+=s[i];\r\n            }\r\n        }\r\n        return symbol;\r\n    }\r\n};\r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189082702","body":"```\r\nclass MyQueue {\r\npublic:\r\n    stack<int> st, tem;\r\n    MyQueue() {\r\n        \r\n    }\r\n    \r\n    void push(int x) {\r\n        st.push(x);\r\n    }\r\n    void get() {\r\n        if (tem.empty()) {\r\n            while (!st.empty()) {\r\n                tem.push(st.top());\r\n                st.pop();\r\n            } \r\n        }\r\n    }\r\n    int pop() {\r\n        int t;\r\n        get();\r\n        t = tem.top();\r\n        tem.pop();    \r\n        return t;\r\n    }\r\n    \r\n    int peek() {\r\n        get();\r\n        return tem.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return tem.empty() && st.empty();\r\n    }\r\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192585179","body":"```class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummyHead = new ListNode(0); \n        dummyHead->next = head;\n        ListNode* cur = dummyHead;\n        while(cur->next != nullptr && cur->next->next != nullptr) {\n            ListNode* tmp = cur->next; \n            ListNode* tmp1 = cur->next->next->next; \n\n            cur->next = cur->next->next;   \n            cur->next->next = tmp;          \n            cur->next->next->next = tmp1;   \n\n            cur = cur->next->next; \n        }\n        return dummyHead->next;\n    }\n};\n\n```\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195351966","body":"```class LRUCache {\npublic:\n    LRUCache(int capacity) : cap(capacity) {\n    }\n\n    int get(int key) {\n        if (map.find(key) == map.end()) return -1;\n        auto key_value = *map[key];\n        cache.erase(map[key]);\n        cache.push_front(key_value);\n        map[key] = cache.begin();\n        return key_value.second;\n    }\n\n    void put(int key, int value) {\n        if (map.find(key) == map.end()) {\n            if (cache.size() == cap) {\n                map.erase(cache.back().first);\n                cache.pop_back();\n            }\n        }\n        else {\n            cache.erase(map[key]);\n        }\n        cache.push_front({ key, value });\n        map[key] = cache.begin();\n    }\nprivate:\n    int cap;\n    list<pair<int, int>> cache;\n    unordered_map<int, list<pair<int, int>>::iterator> map;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187260764","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        res = \"\"\r\n        num = 0\r\n        stack = []\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c)\r\n            elif c == \"[\":\r\n                stack.append([res, num])\r\n                res = \"\"\r\n                num = 0\r\n            elif c == \"]\":\r\n                prev_res, prev_num = stack.pop()\r\n                res = prev_res + prev_num * res\r\n            else:\r\n                res += c\r\n        return res\r\n\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191387926","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        slow, fast = head, head\r\n        count = 0\r\n        temp = head\r\n        while temp:\r\n            count += 1\r\n            temp = temp.next\r\n        k = k % count\r\n        for i in range(k):\r\n            fast = fast.next\r\n        while fast.next:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        fast.next = head\r\n        temp = slow.next\r\n        slow.next = None\r\n        return temp\r\n        \r\n        \r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193341668","body":"var getIntersectionNode = function(headA, headB) {\r\n    let a = headA\r\n    let b = headB\r\n    while(a != b) {\r\n        if (a == null) {\r\n            a = headB\r\n        } else {\r\n            a = a.next\r\n        }\r\n        if (b == null) {\r\n            b = headA\r\n        } else {\r\n            b = b.next\r\n        }\r\n    }\r\n    return a\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187331590","body":"## 思路\r\n\r\n                /*  思路1：利用栈的性质；先把所有字符都压入栈中，遇到\"]\"时说明找到匹配\r\n                读到]时，用一个while循环将[和]之间的字符串读出，\r\n                我这里用了StringBuilder来提高字符串拼接性能，读出后将[pop删去，\r\n                然后开始读数字num了，注意数字可能是很多位数字，这里处理方法很多，\r\n                我就直接用parseInt将字符串转化为数字了，然后是将上述字符串复制num倍，\r\n                这样处理后再将字符串放回栈中即可，至于其他情况，直接将其转化为字符串压入栈中即可，\r\n                最后出栈的时候要注意，字符串的总体顺序是反的，故要用insert拼接而不是append\r\n    \r\n                思路1.1：就是利用栈的特性，先把所有字符都压入栈中，遇到\"]\"时说明找到匹配。\r\n                这个时候先将[]内的string存到一个地方。\r\n                在读完string后，开始读数字k，数字有可能不是1位，所以要用一个base和循环来读数字。\r\n                最后将 k * string压回栈中。继续匹配。最终栈内的字符串因为是反着的（出栈的时候顺序相反），\r\n                所以result记得反着将栈中所有字母弹出来。\r\n\r\n*/\r\n\r\n## 代码\r\n\r\n```java\r\nclass Solution {\r\n        public String decodeString(String s) {\r\n            int len=s.length();\r\n            if(len<=0) return \"\";\r\n            Stack<String> stack=new Stack<>();\r\n            for(int i=0; i<len; i++){\r\n                char mid=s.charAt(i);\r\n\r\n\r\n                //读到]时，用一个while循环将[和]之间的字符串读出，\r\n                if(mid==']'){\r\n                    StringBuilder fir=new StringBuilder();\r\n                    while(!stack.peek().equals(\"[\")){\r\n                        //fir里面存取的就是[]之间的内容\r\n                        fir.insert(0,stack.pop());\r\n                    }\r\n                    //读出后将[pop删去，\r\n                    stack.pop();\r\n\r\n                    StringBuilder num=new StringBuilder();\r\n\r\n                    /*然后开始读数字num了，注意数字可能是很多位数字，这里处理方法很多，\r\n                    我就直接用parseInt将字符串转化为数字了*/\r\n                    while(!stack.isEmpty()&&(stack.peek().charAt(0)>='0'&&stack.peek().charAt(0)<='9')){\r\n                        num.insert(0,stack.pop());\r\n                    }\r\n                    int number=Integer.parseInt(num.toString());\r\n\r\n                    //，然后是将上述字符串复制num倍，这样处理后再将字符串放回栈中即可\r\n                    StringBuilder sec=new StringBuilder();\r\n                    for(int j=0; j<number; j++){\r\n                        sec.append(fir);\r\n                    }\r\n                    stack.push(sec.toString());\r\n                }\r\n                //至于其他情况，直接将其转化为字符串压入栈中即可\r\n                else{\r\n                    StringBuilder sb=new StringBuilder();\r\n                    sb.insert(0,mid);\r\n                    stack.push(sb.toString());\r\n                }\r\n            }\r\n\r\n            //最后出栈的时候要注意，字符串的总体顺序是反的，故要用insert拼接而不是append\r\n            StringBuilder res=new StringBuilder();\r\n            while(!stack.isEmpty()){\r\n                res.insert(0,stack.pop());\r\n            }\r\n            return res.toString();\r\n        }\r\n    }\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度： O(N)\r\n- 空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188500355","body":"## 思路：\r\n\r\n### \t\t两个栈， 一个输出、输入栈\r\n\r\n## 代码\r\n\r\n```java\r\nclass MyQueue {\r\n\r\n    private Stack<Integer> inputStack;\r\n    private Stack<Integer> outputStack;\r\n    public MyQueue() {\r\n        inputStack = new Stack<>();\r\n        outputStack = new Stack<>();\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        //将元素 x 推到队列的末尾\r\n        inputStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        //将输入栈的数据放入输出栈中\r\n        //然后把输出栈里面的数据，放出（移除）一个来\r\n\r\n        if(outputStack.isEmpty()){\r\n            while(!inputStack.isEmpty()){\r\n\r\n                outputStack.push(inputStack.pop());\r\n\r\n            }\r\n\r\n        }\r\n        return   outputStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        //同上,但最后就不是移除，就是显示（返回队列开头的元素）\r\n\r\n        if(outputStack.isEmpty()){\r\n            while(!inputStack.isEmpty()){\r\n\r\n                outputStack.push(inputStack.pop());\r\n\r\n            }\r\n\r\n        }\r\n        // 返回队列开头的元素\r\n        return outputStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        //判断两个栈是不是都是空的\r\n        return inputStack.isEmpty()&&outputStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n- Time O(1)\r\n- Space O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187533435","body":"思路：找到'['和']'来锁定需要循环的项，从后往前遍历\r\nCode:\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack=list()\r\n        length=len(s)\r\n        i=length-1\r\n        while i>=0:\r\n            if s[i].isdigit()==False:\r\n                stack.append(s[i])\r\n                i-=1\r\n            else:\r\n                num=''\r\n                while i>=0 and s[i].isdigit():\r\n                    num=s[i]+num\r\n                    i-=1\r\n                sub=''\r\n                while stack[-1]!=']':\r\n                    tmp=stack.pop()\r\n                    if tmp!='[':\r\n                        sub+=tmp\r\n                stack.pop()\r\n                sub=int(num)*sub\r\n                stack.append(sub)\r\n\r\n        stack.reverse()\r\n        return ''.join(stack)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190116027","body":"思路：\r\n希望排序后的数字，还在原始的位置.所以先对数组排序，当每往后循环的一个数组的原始最大坐标等于当前位置时，就可以切分。\r\nCode:\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        arr_list=list(enumerate(arr))\r\n        arr_list.sort(key=lambda x:x[1])\r\n        temp=[]\r\n        num=0\r\n        for i in range(len(arr_list)):\r\n            temp.append(arr_list[i][0])\r\n            if max(temp)==i:\r\n                num=num+1\r\n                temp=[]\r\n        return num","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191080280","body":"思路：若K>总长度N,只要移动K//N即可。用head.next完成其余操作\r\nCode:\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        tail = head\r\n        count = 1\r\n        if not head or not head.next:\r\n            return head\r\n        while tail.next:\r\n            tail = tail.next\r\n            count += 1\r\n        if k % count == 0:\r\n            return head \r\n        tail.next = head\r\n        k %= count\r\n        for i in range(count - k):\r\n            tail = tail.next\r\n        temp = tail.next\r\n        tail.next = None\r\n        return temp","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193745915","body":"思路：快慢指针\r\nCode:\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            # 如果相遇\r\n            if slow == fast:\r\n                p = head\r\n                q = slow\r\n                while p!=q:\r\n                    p = p.next\r\n                    q = q.next\r\n                return p","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195315685","body":"思路：哈希表和双向列表\r\nCode:\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.cache = dict()\r\n        # 使用伪头部和伪尾部节点    \r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        if key not in self.cache:\r\n            return -1\r\n        # 如果 key 存在，先通过哈希表定位，再移到头部\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if key not in self.cache:\r\n            # 如果 key 不存在，创建一个新的节点\r\n            node = DLinkedNode(key, value)\r\n            # 添加进哈希表\r\n            self.cache[key] = node\r\n            # 添加至双向链表的头部\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                # 如果超出容量，删除双向链表的尾部节点\r\n                removed = self.removeTail()\r\n                # 删除哈希表中对应的项\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196540299","body":"### 思路\r\n深度优先搜索\r\n###  code\r\n```python\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        if root is None: \r\n            return 0 \r\n        else: \r\n            left_height = self.maxDepth(root.left) \r\n            right_height = self.maxDepth(root.right) \r\n            return max(left_height, right_height) + 1 \r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187582912","body":"# dfs\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int u = 0;\n        return dfs(s, u);\n    }\n\n    string dfs(string& s, int& u) {\n        string res;\n        while (u < s.size() && s[u] != ']') {\n            if (s[u] >= 'a' && s[u] <= 'z') res += s[u ++];\n            else if (s[u] >= '0' && s[u] <= '9') {\n                int k = u;\n                while (s[k] >= '0' && s[k] <= '9') k ++;\n                int t = stoi(s.substr(u, k - u));\n                u = k + 1;\n                string sa = dfs(s, u);\n                u ++;\n                while (t --) res += sa;\n            }\n        }\n        return res;\n    }\n};// O(n) O(n)\n```\n# stack\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n      if (s.empty()) {\n        return s;\n      }\n      \n      std::string k;    // num\n      std::string str;  // result\n      std::stack<int> countStack;\n      std::stack<std::string> stringStack;\n      \n      for (auto& ch: s) {\n        if (isdigit(ch)) {\n          k += ch;\n        } else if (ch == '[') {\n          countStack.push(std::stoi(k));\n          stringStack.push(str);\n          k = \"\";\n          str = \"\";\n        } else if (isalpha(ch)) {\n          str += ch;\n\n        } else if (ch == ']') {\n          // get previously decoded, such as in 3[a]2[bc]\n          // second '[' push 'aaa' to stack, get them now\n          std::string decodedString = stringStack.top();\n          stringStack.pop();\n          \n          // str is not pushed to stack yet, but times is already pushed \n          // add the decoded sting and repeated str\n          for (int i = 0; i < countStack.top(); i++) {\n            decodedString += str;\n          }\n          countStack.pop();\n          \n          // remember the local variable\n          str = decodedString;\n        }\n      }\n      \n      return str;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189145882","body":"# idea\n使用两个横向摆放相对开口的栈模拟队列，右边栈储存元素，左边栈弹出元素。 \n如果需要访问队头元素， 就把所有instack 元素一把撸过来到outstack pop 也是同理 其它简单\n注意pop时候临时储存top以后再return\n```cpp\nclass MyQueue {\nprivate:\n    stack<int> inStack,outStack;\n\n    void in2out() {\n    while (!inStack.empty()) {\n        outStack.push(inStack.top());\n        inStack.pop();\n    }\n}    \npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        inStack.push(x);\n\n    }\n    \n    int pop() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        int x = outStack.top();//注意此处不能直接返回 你需要一个局部变量暂存 \n        outStack.pop();\n        return x;\n\n    }\n    \n    int peek() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        return outStack.top();\n        \n\n    }\n    \n    bool empty() {\n        return inStack.empty() && outStack.empty();\n\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193317706","body":"```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* p = headA, * q = headB;\n        while (p != q) {\n            p = p ? p->next : headB;\n            q = q ? q->next : headA;\n        }\n        return p;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1193338176","body":"```ts\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  let ret = []\r\n  let i = num.length - 1\r\n  while (i >= 0 || k > 0) {\r\n    if (i >= 0) k += num[i--]\r\n    ret.push(k % 10)\r\n    k = Math.floor(k / 10)\r\n  }\r\n  return ret.reverse()\r\n}\r\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187629977","body":"Code:\r\n```ts\r\nfunction decodeString(s: string): string {\r\n  const stack = []\r\n  let ret = ''\r\n  let count = 0\r\n  for (const c of s) {\r\n    if (c >= '0' && c <= '9') {\r\n      count = count * 10 + +c\r\n      continue\r\n    } else if (c === '[') {\r\n      stack.push({ count, lastRet: ret })\r\n      count = 0\r\n      ret = ''\r\n      continue\r\n    } else if (c === ']') {\r\n      const { count, lastRet } = stack.pop()\r\n      ret = lastRet + ret.repeat(count)\r\n      continue\r\n    }\r\n    ret += c\r\n  }\r\n  return ret\r\n};\r\n```\r\nComplexity:\r\n- Time complexity: O(n)\r\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189170203","body":"Code:\r\n```ts\r\nclass MyQueue {\r\n  pushStack: number[]\r\n  popStack: number[]\r\n\r\n  constructor() {\r\n    this.pushStack = []\r\n    this.popStack = []\r\n  }\r\n\r\n  transfer(): void {\r\n    if (this.popStack.length) return\r\n    while (this.pushStack.length) this.popStack.push(this.pushStack.pop())\r\n  }\r\n\r\n  push(x: number): void {\r\n    this.pushStack.push(x)\r\n  }\r\n\r\n  pop(): number {\r\n    this.transfer()\r\n    return this.popStack.pop()\r\n  }\r\n\r\n  peek(): number {\r\n    this.transfer()\r\n    return _.last(this.popStack)\r\n  }\r\n\r\n  empty(): boolean {\r\n    return !(this.pushStack.length || this.popStack.length)\r\n  }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190461387","body":"Code:\r\n```ts\r\n/** Algorithm: Sliding Window */\r\nfunction maxChunksToSorted(arr: number[]): number {\r\n  const sortedArr = [...arr].sort((a, b) => a - b)\r\n  let ret = 0\r\n  let sum1 = 0\r\n  let sum2 = 0\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    sum1 += arr[i]\r\n    sum2 += sortedArr[i]\r\n    if (sum1 === sum2) ret++\r\n  }\r\n\r\n  return ret\r\n}\r\n```\r\nTime Complexity: O(NlogN)\r\nTime Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190567251","body":"```ts\r\n/**\r\n * Algorithm: Fast and Slow Pointer\r\n * Time Complexity: O(N)\r\n * Space Complexity: O(1)\r\n */\r\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\r\n  if (!head || k === 0) return head\r\n  // get effective rotate times\r\n  let cur = head, length = 1\r\n  while (cur.next && ++length) cur = cur.next\r\n  k %= length\r\n  if (k === 0) return head\r\n\r\n  let slow = head, fast = head\r\n  while (k-- > 0) fast = fast.next\r\n  while (fast.next) { slow = slow.next; fast = fast.next }\r\n  const ret = slow.next\r\n  slow.next = null\r\n  fast.next = head\r\n  return ret\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191774265","body":"```ts\r\n/**\r\n * Algorithm: Iterative\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(1)\r\n */\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n  if (!head || !head.next) return head\r\n\r\n  let dummyHead = new ListNode(-1, head)\r\n  let p = dummyHead\r\n  while (head && head.next) {\r\n    let next = head.next\r\n    head.next = next.next\r\n    next.next = head\r\n    p.next = next\r\n    p = head\r\n    head = head.next\r\n  }\r\n  return dummyHead.next \r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193146877","body":"```ts\r\n/**\r\n * Algorithm: Recursive\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(n)\r\n */\r\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\r\n  const arr = []\r\n  while (head) {\r\n    arr.push(head.val)\r\n    head = head.next\r\n  }\r\n\r\n  function buildBST(start: number, end: number) {\r\n    if (start > end) return null\r\n    const mid = (start + end) >>> 1\r\n    const root = new TreeNode(arr[mid])\r\n    root.left = buildBST(start, mid - 1)\r\n    root.right = buildBST(mid + 1, end)\r\n    return root\r\n  };\r\n\r\n  return buildBST(0, arr.length - 1)\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193343835","body":"```ts\r\n/**\r\n * Algorithm: Double Pointer\r\n * Time Complexity: O(m + n)\r\n * Space Complexity: O(1)\r\n */\r\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\r\n  if (!headA || !headB) return null\r\n  let p1 = headA, p2 = headB\r\n  while (p1 !== p2) {\r\n    p1 = p1 ? p1.next : headB\r\n    p2 = p2 ? p2.next : headA\r\n  }\r\n  return p1\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193369095","body":"```ts\r\n/**\r\n * Algorithm: Fast and Slow Pointer\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(1)\r\n */\r\nfunction detectCycle(head: ListNode | null): ListNode | null {\r\n  if (!head) return null\r\n  let slow = head, fast = head, start = head\r\n  while (fast && fast.next) {\r\n    slow = slow.next\r\n    fast = fast.next.next\r\n    if (slow === fast) {\r\n      while (true) {\r\n        if (slow === start) return slow\r\n        slow = slow.next\r\n        start = start.next\r\n      }\r\n    }\r\n  }\r\n  return null\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194314825","body":"```ts\r\n/**\r\n * Algorithm: HashTable\r\n * Time Complexity: O(n)\r\n * Space Complexity: O(1)\r\n */\r\nclass LRUCache {\r\n  capacity: number\r\n  cache: Map<number, number>\r\n\r\n  constructor(capacity: number) {\r\n    this.capacity = capacity\r\n    this.cache = new Map()\r\n  }\r\n\r\n  get(key: number): number {\r\n    if (!this.cache.has(key)) return -1\r\n    const value = this.cache.get(key)\r\n    this.cache.delete(key)\r\n    this.cache.set(key, value)\r\n    return value\r\n  }\r\n\r\n  put(key: number, value: number): void {\r\n    if (this.cache.has(key)) this.cache.delete(key)\r\n    while (this.cache.size >= this.capacity) this.cache.delete(this.cache.keys().next().value)\r\n    this.cache.set(key, value)\r\n  }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196514507","body":"```ts\r\nfunction maxDepth(root: TreeNode | null): number {\r\n  if (!root) return 0\r\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197579306","body":"```ts\r\n/** Algorithm: Recursion */\r\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\r\n  if (p === null && q === null) return true\r\n  if (p === null || q === null) return false\r\n  if (p.val !== q.val) return false\r\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187671196","body":"``` java\r\n\r\npublic String decodeString(String s) {\r\n        StringBuilder currStr = new StringBuilder();\r\n        int currNum = 0;\r\n        Stack<Integer> numsStack = new Stack<>();\r\n        Stack<StringBuilder> strsStack = new Stack<>();\r\n\r\n        for (char c : s.toCharArray()) {\r\n            if (c == '[') {\r\n                numsStack.push(currNum);\r\n                strsStack.push(currStr);\r\n                //重新开始统计\r\n                currNum = 0;\r\n                currStr = new StringBuilder();\r\n            } else if (c == ']') {\r\n                //遇到] ，栈里面的数字和字符串都出栈，并且与括号内的字符串进行拼接\r\n                int prenum = numsStack.pop();\r\n                StringBuilder prestr = strsStack.pop();\r\n                //拼接字符串，可能需要进行多次拼接\r\n                for (int i = 0; i < prenum; i++) {\r\n                    prestr.append(currStr);\r\n                }\r\n                currStr = prestr;\r\n            } else if (c >= '0' && c <= '9') {\r\n                //遇到了数字，那么拼接数字，有可能不止个位数\r\n                currNum = currNum * 10 + Integer.parseInt(String.valueOf(c));\r\n            } else {\r\n                //其他，当作普通字符拼接，作为当前字符串\r\n                currStr.append(c);\r\n            }\r\n        }\r\n        return currStr.toString();\r\n    }\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189049685","body":"``` java\nclass MyQueue {\n\n    public Stack<Integer> stackPush;\n    public Stack<Integer> stackPop;\n\n    public MyQueue() {\n        this.stackPush = new Stack<Integer>();\n        this.stackPop = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        stackPush.push(x);\n    }\n    \n    public int pop() {\n        if (stackPop.isEmpty() && stackPush.isEmpty()) {\n            throw new RuntimeException(\"Queue is empty\");\n        }\n        if (stackPop.isEmpty()) {\n            while (!stackPush.isEmpty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.pop();\n    }\n    \n    public int peek() {\n        if (stackPop.isEmpty() && stackPush.isEmpty()) {\n            throw new RuntimeException(\"Queue is empty\");\n        }\n        if (stackPop.isEmpty()) {\n            while (!stackPush.isEmpty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.peek();\n    }\n    \n    public boolean empty() {\n        return stackPush.isEmpty() && stackPop.isEmpty();\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190462192","body":"```java\n//先打卡\npublic int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n\n        for (int num : arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                // 我们需要将融合后的区块的最大值重新放回栈\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\n                int cur = stack.removeLast();\n                // 维持栈的单调递增\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        // 栈存的是块信息，因此栈的大小就是块的数量\n        return stack.size();\n    }\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194084853","body":"```java\npublic ListNode detectCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        //考虑边界\n        if (head == null) {\n            return null;\n        }\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                break;\n            }\n        }\n        // 考虑边界，比如链表只有1个节点\n        if (fast.next == null || fast.next.next == null) {\n            return null;\n        }\n        // 从相遇点开始，随便哪个指针从头开始，同步走，再相遇就是环的切点\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187671250","body":"# 思路\r\n\r\n栈\r\n\r\n# 代码\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stk_multi = new LinkedList<>();\r\n        LinkedList<String> stk_res = new LinkedList<>();\r\n        for (char c : s.toCharArray()) {\r\n            if (c == '[') {\r\n                stk_multi.addLast(multi);\r\n                stk_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if (c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stk_multi.removeLast();\r\n                for (int i = 0; i < cur_multi; i++) {\r\n                    tmp.append(res);\r\n                }\r\n                res = new StringBuilder(stk_res.removeLast() + tmp);\r\n            }\r\n            else  if (c >= '0' && c <= '9') {\r\n                multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            }\r\n            else {\r\n                res.append(c);\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188609109","body":"# 思路\n\n- 实现栈：使用SLL\n  \n- 2个栈实现队列\n  \n\n# 代码\n\n```java\nclass MyQueue {\n    private class Stack {\n        private class ListNode {\n            int val;\n            ListNode next;\n            public ListNode(int val, ListNode next) {\n                this.val = val;\n                this.next = next;\n            }\n            \n            public ListNode(int val) {\n                this(val, null);\n            }\n        }\n        // Use SLL as a stack\n        \n        ListNode head;\n        \n        public Stack() {\n            head = new ListNode(0);\n        }\n        \n        public boolean isEmpty() {\n            return head.next == null;\n        }\n        \n        public int pop() {\n            int val = head.next.val;\n            head.next = head.next.next;\n            return val;\n        }\n        \n        public void push(int x) {\n            ListNode p = new ListNode(x, head.next);\n            head.next = p;\n        }\n        public int peek() {\n            return head.next.val;\n        }\n    }\n    \n    Stack in;\n    Stack out;\n    public MyQueue() {\n        in = new Stack();\n        out = new Stack();\n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return out.pop();\n    }\n    \n    public int peek() {\n        if (out.isEmpty()) {\n            while (!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n# 复杂度分析\n\n时间复杂度：\n\n- 入栈：O(1)\n  \n- 出栈：O(1)\n  \n\n空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191618465","body":"# 思路\n\n1. 求得链表长度n\n\n2. k = n % k. 找到倒数k个，截断成a, b两个list。交换位置再拼接。\n\n# 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) return head;\n        if (k == 0) return head;\n        // get length\n        int size = getSize(head);\n        k = k % size;\n        if (k == 0) return head;\n        k = size - k;\n        //System.out.printf(\"k = %d\",k);\n        ListNode p = head;\n        while (k > 1) {\n            p = p.next;\n            k--;\n        }\n        // k ==0, p is the kth node\n        ListNode newHead = p.next;\n        p.next = null;\n        p = newHead;\n        while (p.next != null) {\n            p = p.next;\n        }\n        // p is the last node\n        p.next = head;\n        return newHead;\n    }\n\n    public int getSize(ListNode head) {\n        ListNode p = head;\n        int cnt = 0;\n        while (p != null) {\n            cnt++;\n            p = p.next;\n        }\n        return cnt;\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192629667","body":"# LeetCode Link\n\n[Swap Nodes in Pairs - LeetCode](https://leetcode.com/problems/swap-nodes-in-pairs/)\n\n# Idea\n\nFind every two listNode. And swap. Could be iteratively or recursively.\n\n# Code\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // Recursively\n        if (head == null || head.next == null) return head;\n        ListNode rest = swapPairs(head.next.next);\n        ListNode a = head;\n        ListNode b = head.next;\n        b.next = a;\n        a.next = rest;\n        return b;\n    }\n\n    public ListNode swapPairs(ListNode head) {\n        // Iteratively\n        if (head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode p = dummy;\n        while (p.next != null && p.next.next != null) {\n            ListNode a = p.next;\n            ListNode b = p.next.next;\n            ListNode next = b.next;\n            p.next = b;\n            b.next = a;\n            a.next = next;\n            p = a;\n        }\n        return dummy.next;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity: O(N)\n\nSpace Complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193135631","body":"# LeetCode Link\n\n[Convert Sorted List to Binary Search Tree - LeetCode](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n# Idea\n\n1. Convert nodes to nums array. Build BST tree.\n\n# Code\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        List<Integer> lst = new ArrayList<>();\n        getNodes(head, lst);\n        int n = lst.size();\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums[i] = lst.get(i);\n        }\n        return buildTree(nums, 0, n - 1);\n    }\n    \n    public TreeNode buildTree(int[] nums, int start, int end) {\n        if (start > end) {\n            return null;\n        }\n        int mid = (start + end) / 2;\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = buildTree(nums, start, mid - 1);\n        root.right = buildTree(nums, mid + 1, end);\n        return root;\n    }\n    \n    public void getNodes(ListNode head, List<Integer> lst) {\n        ListNode p = head;\n        while (p != null) {\n            lst.add(p.val);\n            p = p.next;\n        }\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity: O(N)\n\nSpace Complexity: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193244193","body":"# LeetCode Link\n\n[Intersection of Two Linked Lists - LeetCode](https://leetcode.com/problems/intersection-of-two-linked-lists/)\n\n# Idea\n\nIf headA == null or headB == null, return null.\n\nElse, traverse each linkedlist. If current pointer(a,b) is null, then contatenate to the other head. If exists an intersection node, a == b == intersection node. If not exists, then a and b will points to null and return.\n\n# Code\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        ListNode a = headA, b = headB;\n        while (a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193996265","body":"# LeetCode Link\n\n[Linked List Cycle II - LeetCode](https://leetcode.com/problems/linked-list-cycle-ii/)\n\n# Idea\n\nFast/slow pointers. Fast pointer go twice the distance than that of slow pointer. If cycle exists, fast and slow will meet each other. Let's assume 5 variable. \n\n1. Distance of slow : s.\n2. Distance of fast : f.\n3. From head to where cycle begins is x. \n4. From x to where two pointer meets is y. \n5. And the length of cycle is r.\n\nWe can have these equation:\n\n1. `f = 2 * s`\n2. `s = x + y`\n3. `f - s = n * r`\n\nCombined to get: `x + y = n * r` which equals to `x = n*r - y`\n\nIn order to get `x`, which is `n*r - y`, let a new node go from head and slow go next, while they meet, it is where the cycle begins.\n\n# Code\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode slow = head, fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) break;\n        }\n        if (fast.next == null || fast.next.next  == null) return null;\n        ListNode p = head;\n        while (p != slow) {\n            p = p.next;\n            slow = slow.next;\n        }\n        return p;\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195404141","body":"# LeetCode Link\n\n[LRU Cache - LeetCode](https://leetcode.com/problems/lru-cache/)\n\n# Idea\n\nDoublyLinkedList + HashMap.\n\n# Code\n\n```java\nclass LRUCache {\n    private class Node {\n        int key;\n        int val;\n        Node prev;\n        Node next;\n        public Node(int key, int val, Node prev, Node next) {\n            this.key = key;\n            this.val = val;\n            this.prev = prev;\n            this.next = next;\n        }\n        public Node(int key, int val) {\n            this(key, val, null, null);\n        }\n    }\n\n    private class DDL {\n        // doubly linked list\n        private Node head;\n        private Node tail;\n        public DDL() {\n            head = new Node(0, 0);\n            tail = new Node(0,0);\n            head.next = tail;\n            tail.prev = head;\n        }\n\n        public Node pollFirst() {\n            Node evict = head.next;\n            removeNode(evict);\n            return evict;\n        }\n\n        public void removeNode(Node node) {\n            node.next.prev = node.prev;\n            node.prev.next = node.next;\n            node.next = null;\n            node.prev = null;\n        }\n\n        public void offerLast(Node node) {\n            node.next = tail;\n            node.prev = tail.prev;\n            tail.prev.next = node;\n            tail.prev = node;\n        }\n    }\n\n    private DDL ddl = new DDL();\n    private int cap;\n    private Map<Integer, Node> memo = new HashMap<>();\n\n    public LRUCache(int capacity) {\n        cap = capacity;\n    }\n\n    public int get(int key) {\n        if (!memo.containsKey(key)) return -1;\n        Node node = memo.get(key);\n        ddl.removeNode(node);\n        ddl.offerLast(node);\n        return node.val;\n    }\n\n    public void put(int key, int value) {\n        if (memo.containsKey(key)) {\n            Node node = memo.get(key);\n            node.val = value;\n            ddl.removeNode(node);\n            ddl.offerLast(node);\n        }\n        else {\n            Node node = new Node(key, value);\n            if (memo.size() >= cap) {\n                // should evict\n                Node evict = ddl.pollFirst();\n                memo.remove(evict.key);\n            }\n            ddl.offerLast(node);\n            memo.put(key, node);\n        }\n    }\n}\n\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(1)\n\nSpace Complexity\n\nO(k)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196197716","body":"# LeetCode Link\n\n[Maximum Depth of Binary Tree - LeetCode](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\n\n# Idea\n\nPostorder traversal. Get maxDepth from left and right, return 1 + Max(depth(left), depth(right));\n\n# Code\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n}\n```\n\n# Complexity Analysis\n\nTime Complexity\n\nO(N)\n\nSpace Complexity\n\nO(logN)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187984710","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        self.input = []    \n        self.op = []\n    def push(self, x: int) -> None:\n        self.input.append(x)\n\n    def pop(self) -> int:\n        if not self.op:\n            while self.input:\n                self.op.append(self.input.pop())\n        return self.op.pop()    \n        \n    def peek(self) -> int:\n        if not self.op:\n            while self.input:\n                self.op.append(self.input.pop())\n        return self.op[-1] \n\n    def empty(self) -> bool:\n        return len(self.input) == 0 and len(self.op) == 0\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190968022","body":"```python\nclass Solution:\n    def rotateRight(self, head: 'ListNode', k: 'int') -> 'ListNode':\n       \n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n       \n        old_tail = head\n        n = 1\n        while old_tail.next:\n            old_tail = old_tail.next\n            n += 1\n        old_tail.next = head\n        \n        \n        new_tail = head\n        for i in range(n - k % n - 1):\n            new_tail = new_tail.next\n        new_head = new_tail.next\n        \n \n        new_tail.next = None\n        \n        return new_head\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194826719","body":"```python \nfrom collections import OrderedDict\nclass LRUCache(OrderedDict):\n\n    def __init__(self, capacity):\n    \n        self.capacity = capacity\n\n    def get(self, key):\n    \n        if key not in self:\n            return - 1\n        \n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key, value):\n        \n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last = False)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196018040","body":"```python\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197547463","body":"```python\nclass Solution:\n    def isSameTree(self, p, q): \n        if not p and not q:\n            return True\n        if not q or not p:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.right, q.right) and \\\n               self.isSameTree(p.left, q.left)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1190786185","body":"# Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> array = new ArrayList<>();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            k += num[i];\r\n            array.add(0, k%10);\r\n            k = k / 10;\r\n        }\r\n        while (k > 0) {\r\n            array.add(0, k%10);\r\n            k = k/10;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1191823942","body":"# Idea\r\n双向遍历数组取最小\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        \r\n        int index = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = i - index;\r\n        }\r\n        \r\n       index = Integer.MAX_VALUE;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = Math.min(res[i], index - i);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n) 遍历两次数组\r\nSpace: O(1) 没有使用额外空间","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1190714536","body":"# Idea\r\n用数组代表栈\r\n\r\n# Code\r\n```\r\nclass CustomStack {\r\n    int size;\r\n    int index;\r\n    int[] stack;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        size = maxSize;\r\n        index = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (index < size) {\r\n            stack[index++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (index == 0) {\r\n            return -1;\r\n        }\r\n        return stack[--index];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, stack.length); i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime: O(1) for pop and push.  O(n) for increment.\r\nSpace: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1190774460","body":"# Idea\r\n使用一个栈， 遇到]就开始处理前面的，处理完压入栈；遇到其他情况直接压入栈等待后续处理。\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Character> stack = new Stack<>();\r\n        for (char c : s.toCharArray()) {\r\n            if (c != ']') {\r\n                stack.push(c);\r\n            } else {\r\n                StringBuilder sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                String sub = sb.toString();\r\n                stack.pop(); // pop \"[\"\r\n\r\n                // get number\r\n                sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                int count = Integer.parseInt(sb.toString());\r\n\r\n                while (count > 0) {\r\n                    for (char ch : sub.toCharArray()) {\r\n                        stack.push(ch);\r\n                    }\r\n                    count--;\r\n                }\r\n            }\r\n        }\r\n        StringBuilder res = new StringBuilder();\r\n        while (!stack.isEmpty()) {\r\n            res.insert(0, stack.pop());\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace:  O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188387205","body":"# Idea \r\n用stack1来存储新加的元素，要使用pop或者peek时，将stack1的元素全部pop出来添加到stack2，此时stcak2的顺序就是先进先出(queue)\r\n\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> stack1;\r\n    Stack<Integer> stack2;\r\n\r\n    public MyQueue() {\r\n        stack1 = new Stack<>();\r\n        stack2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (stack2.isEmpty()) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (stack2.isEmpty()) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n时间：O(n)\r\n空间：O(n)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189384265","body":"# Idea\r\n使用单调栈，遇到大于等于栈顶元素直接加入栈，如果当前元素小于栈顶，先将现在的栈顶取出，确保栈内没有大于该元素的元素最后将原先的栈顶加入。栈中元素个数就是最多块的个数。\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        stack.push(arr[0]);\r\n        for (int i = 1; i < arr.length; i++) {\r\n            if (!stack.isEmpty() && arr[i] >= stack.peek()) {\r\n                stack.push(arr[i]);\r\n            } else {\r\n                int curMax = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(curMax);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace:  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190553938","body":"# Idea\r\n先确定链表的长度，遍历链表找到起始位置的前一个node，使node.next = null，最后将链表结尾与头部相连。\r\n\r\n# Code\r\n\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null) return head;\r\n        \r\n        ListNode dummy = head;\r\n        int length = 1;\r\n        while (dummy.next != null) {\r\n            length ++;\r\n            dummy = dummy.next; // dummy现在指到最后一个node\r\n        } //确定链表长度\r\n        \r\n        int pos = k % length;\r\n        length = length - pos;\r\n        ListNode cur = head;\r\n        \r\n        while (length > 1) {\r\n            length --;\r\n            cur = cur.next;\r\n        }\r\n        \r\n        dummy.next = head;\r\n        head = cur.next;\r\n        cur.next = null;\r\n        return head;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191801680","body":"# Idea\r\n在链表问题中，如果第一个node要被操作，要是用dummyhead。\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        ListNode dummyHead = new ListNode(0, head);\r\n        ListNode prev = dummyHead;\r\n        while (head != null && head.next != null) {\r\n            ListNode first = head;\r\n            ListNode second = head.next;   \r\n            first.next = second.next;\r\n            second.next = prev.next;\r\n            prev.next = second;\r\n            \r\n            prev = first;\r\n            head = first.next;\r\n        }\r\n        \r\n        return dummyHead.next;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n) 遍历链表\r\nSpace: O(1) 只在链表上操作，没有使用额外空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1192852513","body":"# Idea\r\n本题类似于108，只是需要用链表构建平衡二叉树而不是数组。数组可以直接找到中间值，链表则不行。为了构建平衡二叉树，需要构建辅助函数找到链表的中间从而递归构建。\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        if (head.next == null) {\r\n            return new TreeNode(head.val);\r\n        }\r\n        ListNode preMid = findMid(head);\r\n        ListNode mid = preMid.next;\r\n        preMid.next = null;\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(mid.next);\r\n        return root;\r\n    }\r\n    \r\n    private ListNode findMid(ListNode head) {\r\n        ListNode pre = head, slow = head, fast = head.next;\r\n        while (fast != null && fast.next != null) {\r\n            pre = slow;\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        return pre;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(NlgN)\r\nSpace:  O(lgN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193168406","body":"# Idea\r\nA指针走到头就从headB重新走，B指针走到头就从headA重新走，这样A，B指针相遇的时候就都走了一样的路程。\r\n\r\n# Code\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode pA = headA, pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == null ? headB : pA.next;\r\n            pB = pB == null ? headA : pB.next;\r\n        }\r\n        return pA;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(N + M)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193372015","body":"# Idea\r\n使用快慢指针，经过证明，在有环的情况下，当快慢指针相遇后，快指针回到head然后改为一次向后走一步，与慢指针再次相遇时就是还的入口。\r\n\r\n# Code\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        boolean isCycle = false;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if (slow == fast) {\r\n                isCycle = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!isCycle) {\r\n            return null;\r\n        }\r\n        \r\n        fast = head;\r\n        while (fast != slow) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195084040","body":"# Idea\r\n使用hashmap和双向链表\r\n\r\n# Code\r\n```java\r\nclass LinkNode {\r\n    int key;\r\n    int val;\r\n    LinkNode front;\r\n    LinkNode next;\r\n\r\n    public LinkNode(int key, int val) {\r\n        this.key = key;\r\n        this.val = val;\r\n    }\r\n\r\n}\r\n\r\n\r\nclass LRUCache {\r\n    int capacity;\r\n    Map<Integer, LinkNode> map = new HashMap<>();\r\n    LinkNode head = new LinkNode(0, 0);\r\n    LinkNode tail = new LinkNode(0, 0);\r\n    \r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        head.next = tail;\r\n        tail.front = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (map.containsKey(key)) {\r\n            LinkNode node = map.get(key);\r\n            int value = node.val;\r\n            map.remove(key);\r\n            node.front.next = node.next;\r\n            node.next.front = node.front;\r\n            addFirstNode(key, value);\r\n            return map.get(key).val;\r\n            \r\n        } else {\r\n            return -1;\r\n        }\r\n        \r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if (!map.containsKey(key)) { // 没这个值\r\n            if (map.size() == capacity) { // 满了先删\r\n                deleteLastNode();\r\n            } // 然后将这一对key value插入最前面\r\n                addFirstNode(key, value);\r\n            } else { // 已经有了，找到并且删除，然后插入新的在最前面\r\n                LinkNode node = map.get(key);\r\n                map.remove(key);\r\n                node.front.next = node.next;\r\n                node.next.front = node.front;\r\n                addFirstNode(key, value);\r\n            }\r\n    }\r\n    \r\n\r\n    private void deleteLastNode() {\r\n        LinkNode lastNode = tail.front;\r\n        lastNode.front.next = tail;\r\n        tail.front = lastNode.front;\r\n        map.remove(lastNode.key);\r\n    }\r\n    \r\n    private void addFirstNode(int key, int value) {\r\n        LinkNode temp = head.next;\r\n        LinkNode newNode = new LinkNode(key, value);\r\n        head.next = newNode;\r\n        newNode.front = head;\r\n        newNode.next = temp;\r\n        temp.front = newNode;\r\n        map.put(key, newNode);\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(1)\r\nSpace: O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1195807025","body":"# Idea\r\n层序遍历\r\n\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) return 0;\r\n        int depth = 0;\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.add(root);\r\n        while (!queue.isEmpty()) {\r\n            int level = queue.size();\r\n            depth++;\r\n            for (int i = 0; i < level; i++) {\r\n                TreeNode node = queue.poll();\r\n                if (node.left != null) {\r\n                    queue.add(node.left);\r\n                }\r\n                if (node.right != null) {\r\n                    queue.add(node.right);\r\n                }\r\n            }\r\n        }\r\n        return depth;\r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197139488","body":"# Idea\r\n递归\r\n\r\n# Code\r\n``` java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        }\r\n        if (p == null || q == null || p.val != q.val) {\r\n            return false;\r\n        }\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1188502616","body":"   ```\n public int[] shortestToChar(String S, char C) {\n        int n = S.length(), pos = -n, res[] = new int[n];\n        for (int i = 0; i < n; ++i) {\n            if (S.charAt(i) == C) pos = i;\n            res[i] = i - pos;\n        }\n        for (int i = pos - 1; i >= 0; --i) {\n            if (S.charAt(i) == C)  pos = i;\n            res[i] = Math.min(res[i], pos - i);\n        }\n        return res;\n    } \n```\n\nComplexity O(n)","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188497313","body":"class MyQueue {\n\n    Stack<Integer> input = new Stack();\n    Stack<Integer> output = new Stack();\n    \n    public void push(int x) {\n        input.push(x);\n    }\n\n    public void pop() {\n        peek();\n        output.pop();\n    }\n\n    public int peek() {\n        if (output.empty())\n            while (!input.empty())\n                output.push(input.pop());\n        return output.peek();\n    }\n\n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n}\n\n#### Complexity O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188506954","body":"\n# 思路：\n put 1 2 3, get 1\n\n method1: 9:36 - 42 = 6min\n\n stack [\n sec_stack [3 2 \n put it back to stack1.\n\n time: O(n); space O(n)\n\n\nmethod2:  43 - 45 = 2min\n push: all ele to stack2, append. put it back to stack1.\nstack [3 2 1\nsec_stack [\n\n\n选method1 or method2， 看哪种操作更频繁。 插入频繁 （m1） or 查找（m2）。\n```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop() )\n        num = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append( self.stack2.pop() )\n        return num\n\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop() )\n        num = self.stack2[-1]\n        while self.stack2:\n            self.stack1.append( self.stack2.pop() )\n        return num\n\n\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return len(self.stack1) == 0\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190767492","body":"\n# thought\n4:41 - 59 = 20min\n\n法1:m = k mod len(linkedlist) find last m - 1, m-1 point to None, make m point to head\n法2改进：既然都算出链表长度了就不要找倒数的节点了，直接知道是第几个节点了：\n len = 5 k=2 m = 2 断点：len-m-1=2\n len = 3 k=4 m =1 断点：len-m-1=\n\n\n # complexity\nO(n) space O(1)\n\n# code\n```      \n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        pointer = head\n        length = 1\n        while pointer and pointer.next: # pointer point to last node\n            pointer = pointer.next\n            length += 1\n        if length == 0:\n            return head\n        m = k % length \n\n        if m == 0:\n            return head\n        # fa2：断点：len-m-1=2\n        slow = head\n        for i in range(length - m - 1):\n            slow = slow.next\n        last = slow\n        next_ll = slow.next\n        slow.next = None\n        #pointer is last node\n        pointer.next = head\n        return next_ll\n\n        \n        # fa1 : 找倒数m-1 node\n        # slow, fast = head, head\n        # pre = ListNode(-1)\n        # for i in range(m + 1):\n        #     pre = fast\n        #     fast = fast.next\n        # while fast:\n        #     pre = fast\n        #     slow = slow.next\n        #     fast = fast.next \n        # next_ll = slow.next\n        # slow.next = None \n        # pre.next = head\n        # return next_ll\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1191984842","body":"\n\n\n# thought \nMethod1 : recursion\n  # recusion: change first 2, head.next = recursion.\n\n        #  1 2 3 4\n        #. s\n        #.   f head\n\nMethod2: \n\n# complexity\n time: O(n) spaceO(n)\n\n\n# code\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # 03-04 reading\n        # 04-06 thought\n        # 06-07 coding = 4min\n\n      \n        # time: O(n) spaceO(n)\n        if not head or not head.next:\n            return head \n        \n        slow, fast = head, head.next \n        next_head = fast.next \n        fast.next = slow \n        slow.next = self.swapPairs(next_head)\n        return fast\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193234517","body":"\n\n# thought\n 23 - 31 thought = 9 min\n        31 - 34 coding = 3\n        34 -40 test case \n         total: 17\n         clarifation: no insertion, return null. must have one node for each linkedlist.\n\n         high level:\n         p1: start from  a + c(until the end) + b\n         same time p2: start from b + c(until the end) + start from the head of the other linkedlist a \n         if they have intersection, they would meet!!!! p1=p2=intersection\n\n        a + b , b + a.\n          if they have no intersection, would reach the None node. p1=p2=None\n\n         speacial case:  \n\n         p1 1 9 1 2 4 3 2\n         p2 3 2 4 1 9 1 2\n\n\n# complexity\ntime: O\n(n) space O(1)\n\n\n# code\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n       \n        p1, p2 = headA, headB \n        while p1 != p2:\n            p1 = p1.next if p1 != None else headB\n            p2 = p2.next if p2 != None else headA \n        return p1 # if p1 != None else None\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196220207","body":"\n #  thought\n层层返回每个子树的max depth； 等递归完了， 返回对于整个树的root的max depth。\n\n# \ntime: O(n) n: num of nodes\nSpace: O(h) h: height of tree\n\n# code\n```\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n    return max(self.maxDepth( root.left), self.maxDepth( root.right) ) + 1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188512612","body":"### idea\r\n一共4种情况：字符、数字、[,]\r\n出现多位数字字符，将其转化为一个数\r\n然后利用辅助栈从内到外展开\r\n### code\r\n```java\r\n    public String decodeString(String s){\r\n        LinkedList<String> strStack = new LinkedList<>();\r\n        LinkedList<Integer> numStack = new LinkedList<>();\r\n\r\n         int times = 0;\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        final char[] chars = s.toCharArray();\r\n        for (int i=0; i< chars.length; i++){\r\n            if (Character.isLetter(chars[i])){\r\n                sb.append(chars[i]);\r\n            }else if (Character.isDigit(chars[i])){\r\n                times = times * 10 + chars[i] - '0';\r\n            }else if (chars[i] == '['){\r\n                numStack.addLast(times);\r\n                strStack.addLast(sb.toString());\r\n                times = 0;\r\n                sb = new StringBuilder();\r\n            }else if (chars[i] == ']'){\r\n                 StringBuilder temp = new StringBuilder();\r\n                 Integer multi = numStack.removeLast();\r\n                for (int j=0; j< multi; j++){\r\n                     temp.append(sb);\r\n                 }\r\n                sb = new StringBuilder(strStack.removeLast() + temp);\r\n            }\r\n\r\n        }\r\n        return sb.toString();\r\n    }\r\n```\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192626933","body":"/**\r\n * Definition for singly-linked list.\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\nListNode next = head.next;\r\nhead.next = swapPairs(next.next);\r\nnext.next = head;\r\nreturn next;\r\n    }\r\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194152558","body":"```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast;\r\n        ListNode slow;\r\n        fast = slow = head;\r\n        while ((fast != null) && (fast.next != null)) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if (fast == slow) {\r\n                fast = head;\r\n                while (slow != fast) {\r\n                    fast = fast.next;\r\n                    slow = slow.next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188517276","body":"## 思路\r\n一个stack用于入栈\r\n另外一个用于出栈\r\n\r\n## 代码\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.ins = []\r\n        self.outs = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.ins.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.outs:\r\n            while self.ins:\r\n                self.outs.append(self.ins.pop())\r\n        return self.outs.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outs:\r\n            while self.ins:\r\n                self.outs.append(self.ins.pop())\r\n        return self.outs[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if self.outs or self.ins:\r\n            return False\r\n        else:\r\n            return True\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190997715","body":"\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        l = []\r\n        t = ListNode(0, head)\r\n        p = head\r\n        while p:\r\n            l.append(p.val)\r\n            p = p.next\r\n        if not l:\r\n            return head\r\n        stop = len(l) -  k % len(l)\r\n        if stop == len(l):\r\n            return head\r\n        count = 0\r\n        p = head\r\n        while count < stop -  1 and p:\r\n        \r\n            p = p.next\r\n            count += 1    \r\n        temp1 = p\r\n        while p and p.next:\r\n            p = p.next       \r\n        t.next = temp1.next\r\n        p.next = head\r\n        temp1.next = None\r\n        return t.next\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192045185","body":"class Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        t = ListNode(0, head)\r\n        curr = head\r\n        pre = t\r\n        while curr and curr.next:\r\n            temp = curr.next\r\n            curr.next = curr.next.next\r\n            pre.next = temp\r\n            temp.next = curr\r\n            pre = curr\r\n            curr = curr.next\r\n        return t.next","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193248591","body":"    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        a, b = headA, headB\r\n        while a and b: \r\n            if a == b: return a \r\n            a = a.next \r\n            b = b.next\r\n            if a is None and b is None: \r\n                return None \r\n            if a is None: \r\n                a = headB\r\n            if b is None: \r\n                b = headA","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197643617","body":"def isSameTree(self, p, q):\r\n        def tra(p_r, q_r, tag):\r\n            if not p_r and not q_r:\r\n                return tag\r\n            if not p_r or not q_r:\r\n                tag = 1\r\n                return tag\r\n            if p_r.val != q_r.val:\r\n                tag = 1\r\n                return tag\r\n            a =tra(p_r.left, q_r.left, tag)\r\n            b =tra(p_r.right, q_r.right, tag)\r\n            return a or b\r\n        tag = 0\r\n        a = tra(p, q, 0)\r\n        if a == 0:\r\n            return True\r\n        else:\r\n            return False\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188540304","body":"type MyQueue struct {\r\n\tinStack, outStack []int\r\n}\r\n\r\nfunc Constructor() MyQueue {\r\n\treturn MyQueue{}\r\n}\r\n\r\nfunc (this *MyQueue) Push(x int) {\r\n\tthis.inStack = append(this.inStack, x)\r\n}\r\n\r\nfunc (this *MyQueue) in2Out() {\r\n\t//将入栈的元素倒进出栈\r\n\tfor i := len(this.inStack) - 1; i >= 0; i-- {\r\n\t\tthis.outStack = append(this.outStack, this.inStack[i])\r\n\t}\r\n    this.inStack = nil\r\n}\r\n\r\n//从队列的开头移除并返回元素\r\nfunc (this *MyQueue) Pop() int {\r\n\tif len(this.outStack) == 0 {\r\n\t\tthis.in2Out()\r\n\t}\r\n    //获取栈头元素（切片最后的元素）\r\n\tres := this.outStack[len(this.outStack)-1]\r\n    //移除栈头元素\r\n\tthis.outStack = this.outStack[:len(this.outStack) - 1]\r\n\treturn res\r\n}\r\n\r\n// 返回队列开头的元素\r\nfunc (this *MyQueue) Peek() int {\r\n\tif len(this.outStack) == 0 {\r\n\t\tthis.in2Out()\r\n\t}\r\n\treturn this.outStack[len(this.outStack)-1]\r\n}\r\n\r\nfunc (this *MyQueue) Empty() bool {\r\n\treturn len(this.inStack) == 0 && len(this.outStack) == 0\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190041412","body":"func maxChunksToSorted(arr []int) int {\r\n    // 排序后，对两个数组进行diff，偏移量为0时，表示可以分块\r\n\tb := append([]int{}, arr...)\r\n\tsort.Ints(b)\r\n\r\n\tret := 0\r\n\tdiff := 0\r\n\tm := map[int]int{}\r\n\tfor i := 0; i < len(arr); i++ {\r\n\t\tm[b[i]]++\r\n\t\tif m[b[i]] > 0 { //该数拉开了两个数组的差距，正向偏移（偏向b数组）\r\n\t\t\tdiff++\r\n\t\t} else { // 抵消了arr数组的偏移\r\n\t\t\tdiff--\r\n\t\t}\r\n\r\n\t\tm[arr[i]]--\r\n\t\tif m[arr[i]] < 0 { //该数拉开了两个数组的差距，负向偏移（偏向arr数组）\r\n\t\t\tdiff++\r\n\t\t} else { // 抵消了b数组的偏移\r\n\t\t\tdiff--\r\n\t\t}\r\n\r\n\t\tif diff == 0 {\r\n\t\t\tret++\r\n\t\t}\r\n\t}\r\n\treturn ret\r\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192459453","body":"func swapPairs(head *ListNode) *ListNode {\r\n    if head == nil || head.Next == nil{\r\n        return head\r\n    }\r\n    cur, next :=  head, head.Next\r\n    var pre *ListNode\r\n    for i:=0;i<2;i++{\r\n        cur.Next = pre\r\n        pre = cur\r\n        cur = next\r\n        if next != nil{\r\n            next = next.Next\r\n        }\r\n    }\r\n    head.Next = swapPairs(cur)\r\n    return pre\r\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193845003","body":"func detectCycle(head *ListNode) *ListNode {\r\n    if (head == nil) {\r\n\t\treturn nil\r\n\t}\r\n\tfast := head\r\n\tslow := head\r\n\tfor {\r\n\t\tif (fast.Next == nil || fast.Next.Next == nil || slow.Next == nil) {\r\n\t\t\treturn nil\r\n\t\t}\r\n\t\tfast = fast.Next.Next\r\n\t\tslow = slow.Next\r\n\t\tif (fast == slow) {\r\n\t\t\tfast = head\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\tfor fast != slow {\r\n\t\tfast, slow = fast.Next, slow.Next\r\n\t}\r\n\treturn fast\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195186132","body":"/*\r\ntype LRUCache struct {\r\n    head: 双向链表head，记录cache中node顺序，用作淘汰标准\r\n    tail\r\n    nodeMap: hashmap：key为node的key，value为指向双向链表中node的指针，用作o(1)时间访问node\r\n    cap: 容量\r\n    count: 现有node数量\r\n}\r\n\r\nfunc put(k, v) {\r\n    node = Node{k, v}\r\n    if k在nodeMap中国 {\r\n        更新node value值\r\n        将node移到最前面\r\n    } else { // k不在nodeMap中，意味着cache中没有这个k\r\n        将node插入到最前面\r\n        将node新增到nodeMap\r\n        count++\r\n        if count > capacity { // 超出容量\r\n            丢弃最后一个元素，tail指向倒数第二个元素\r\n            从nodeMap中删除倒数第二个元素\r\n            count --\r\n        }\r\n    }\r\n}\r\n\r\nfunc get(k, v) {\r\n    p = nodeMap[k]\r\n    if p == nil {\r\n        return nil\r\n    }\r\n    return p.Value\r\n}\r\n*/\r\n\r\ntype Node struct {\r\n\tKey   int\r\n\tValue int\r\n\tPrev  *Node\r\n\tNext  *Node\r\n}\r\ntype LRUCache struct {\r\n\tHead    *Node\r\n\tTail    *Node\r\n\tNodeMap map[int]*Node\r\n\tCap     int\r\n\tCount   int\r\n}\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n\thead := Node{}\r\n\ttail := Node{}\r\n\thead.Next = &tail\r\n\ttail.Prev = &head\r\n\tm := make(map[int]*Node)\r\n\tlru := LRUCache{Head: &head, Tail: &tail, NodeMap: m, Cap: capacity, Count: 0}\r\n\treturn lru\r\n}\r\n\r\nfunc (this *LRUCache) Get(key int) int {\r\n\tnode, ok := this.NodeMap[key]\r\n\tif !ok {\r\n\t\treturn -1\r\n\t}\r\n\tif node.Prev != this.Head { // 如果不是第一个，则移动到头部\r\n\t\t// 将node从链表中移除\r\n\t\tnode.Prev.Next, node.Next.Prev = node.Next, node.Prev\r\n\t\t// 将node添加到头部\r\n\t\tfirstNode := this.Head.Next\r\n\t\tnode.Prev, node.Next = this.Head, firstNode\r\n\t\tthis.Head.Next, firstNode.Prev = node, node\r\n\t}\r\n\treturn node.Value\r\n}\r\n\r\nfunc (this *LRUCache) Put(key int, value int) {\r\n\tif node, ok := this.NodeMap[key]; ok { // key在map中\r\n\t\tnode.Value = value          // 更新node value\r\n\t\tif node.Prev == this.Head { // 如果已经是第一个了，直接返回\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// 将node从链表中移除\r\n\t\tnode.Prev.Next, node.Next.Prev = node.Next, node.Prev\r\n\t\t// 将node添加到头部\r\n\t\tfirstNode := this.Head.Next\r\n\t\tnode.Prev, node.Next = this.Head, firstNode\r\n\t\tthis.Head.Next, firstNode.Prev = node, node\r\n\t} else { // key不在map中\r\n\t\tnewNode := Node{Key: key, Value: value}\r\n\t\tthis.NodeMap[key] = &newNode\r\n\t\t// 将新node添加进头部\r\n\t\tfirstNode := this.Head.Next\r\n\t\tnewNode.Prev, newNode.Next = this.Head, firstNode\r\n\t\tthis.Head.Next, firstNode.Prev = &newNode, &newNode\r\n\t\tthis.Count += 1\r\n\t\tif this.Count > this.Cap {\r\n\t\t\tlastNode := this.Tail.Prev\r\n\t\t\tlastNode.Prev.Next, this.Tail.Prev = this.Tail, lastNode.Prev\r\n\t\t\tdelete(this.NodeMap, lastNode.Key)\r\n\t\t\tthis.Count -= 1\r\n\t\t}\r\n\t}\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196230655","body":"func traverseTree(node *TreeNode, currentDeep int, maxDeepth *int) {\r\n    if node == nil {\r\n\t\treturn\r\n\t}\r\n\tif currentDeep > *maxDeepth {\r\n\t\t*maxDeepth = currentDeep\r\n\t}\r\n\tif node.Left != nil {\r\n\t\ttraverseTree(node.Left, currentDeep+1, maxDeepth)\r\n\t}\r\n\tif node.Right != nil {\r\n\t\ttraverseTree(node.Right, currentDeep+1, maxDeepth)\r\n\t}\r\n\treturn\r\n}\r\n\r\nfunc maxDepth(root *TreeNode) int {\r\n\tvar maxDeepth int\r\n\ttraverseTree(root, 1, &maxDeepth)\r\n\treturn maxDeepth\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188696765","body":"# ****【Day 5】232. 用栈实现队列****\n\n## 思路：\n\n1. 由于Js里没有stack 类型，先构建一个包含必要功能的stack类\n2. 用两个stack来模拟先进先出\n3. 这里选择在push时维护第一个stack，利用第二个stack来reverse里面的元素顺序，于是pop和peek时取的是最先存放的元素\n\n## 代码\n\n```jsx\nclass Stack {\n    constructor() {\n        this.stack = [];\n    }    \n    \n    push = (x) => {\n        this.stack.push(x);\n    }\n    \n    pop = () => {\n        return this.stack.pop();\n    }\n    \n    size = () => {\n        return this.stack.length;\n    }\n    \n    peek = () => {\n        return this.stack[this.stack.length - 1];\n    }\n}\n\nclass MyQueue {\n    constructor() {\n        this.stack1 = new Stack();\n        this.stack2 = new Stack();    \n    }\n    \n    push = (x) => {\n        while (this.stack1.size() > 0) {\n            const item = this.stack1.pop();\n            this.stack2.push(item);\n        }\n\n        this.stack2.push(x);\n\n        while (this.stack2.size() > 0) {\n            const item = this.stack2.pop();\n            this.stack1.push(item);\n        }\n    }\n    \n    peek = () => {\n        return this.stack1.peek();   \n    }\n    \n    pop = () => {\n        return this.stack1.pop();\n    }\n    \n    empty = () => {\n        return this.stack1.size() === 0;\n    }\n}\n```\n\n## 复杂度分析\n\nTime Complexity: O(n) when pushing, O(1) when others\n\nSpace Complexity: O(n) when pushing, O(1) when others","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188920030","body":"var MyQueue = function() {\n  this.is = [];\n  this.os = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.is.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  if (!this.os.length) {\n    while (this.is.length) {\n      this.os.push(this.is.pop());\n    }\n  }\n  return this.os.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if (!this.os.length) {\n    while (this.is.length) {\n      this.os.push(this.is.pop());\n    }\n  }\n  return this.os[this.os.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return !this.is.length && !this.os.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196418624","body":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (!root) {\n        return 0\n    }\n    var left = maxDepth(root.left);\n    var right = maxDepth(root.right);\n    return Math.max(left, right) + 1;\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189039042","body":"保打卡\n```javascript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function () {\n    this.stack1 = []\n    this.stack2 = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    let stack = this.stack1.length? this.stack1: this.stack2\n    stack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    let stack1, stack2, value;\n    if (this.stack1.length) {\n        stack1 = this.stack1\n        stack2 = this.stack2\n    } else {\n        stack1 = this.stack2\n        stack2 = this.stack1\n    }\n    while (value = stack1.pop()) {\n        stack2.push(value)\n    }\n    let res = stack2.pop()\n\n    while (value = stack2.pop()) {\n        stack1.push(value)\n    }\n\n    return res\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    let stack1, stack2, value;\n    if (this.stack1.length) {\n        stack1 = this.stack1\n        stack2 = this.stack2\n    } else {\n        stack1 = this.stack2\n        stack2 = this.stack1\n    }\n    while (value = stack1.pop()) {\n        stack2.push(value)\n    }\n\n    let res = stack2.pop()\n    stack1.push(res);\n    while (value = stack2.pop()) {\n        stack1.push(value)\n    }\n    return res;\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    // console.log(this.stack1, this.stack2)\n    return !this.stack1.length && !this.stack2.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189180981","body":"### 思路\r\n* 一個 stack 裝反序的數字 (最新的在最上層)，在 push 時使用另一個 help_stack 來保持 stack 裡的數字為反序\r\n* pop 跟 peek 則取最上層的數字\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        # 先將 stack 內的都數字搬到 help_stack\r\n        while len(self.stack) > 0:\r\n            num = self.stack.pop()\r\n            self.help_stack.append(num)\r\n        # 將新數字放入 stack\r\n        self.stack.append(x)\r\n        # 接著把數字從 help_stack 搬回 stack\r\n        while len(self.help_stack) > 0:\r\n            num = self.help_stack.pop()\r\n            self.stack.append(num)\r\n\r\n    def pop(self) -> int:\r\n        return self.stack.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        return self.stack[-1]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        return len(self.stack) == 0\r\n```\r\n\r\nTime Complexity: O(N)\r\nSpace Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190380648","body":"```python\n# 將 sub array 與 sub sorted array 比對數字出現的次數\n# 次數都相同就代表 sub array 可以排序成 sub sorted array，也就代表可以分成一個 chunk\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr_counter = collections.defaultdict(int)\n        sorted_arr_counter = collections.defaultdict(int)\n        ans = 0\n        \n        sorted_arr = sorted(arr)\n        \n        for i in range(len(arr)):\n            arr_counter[arr[i]] += 1\n            sorted_arr_counter[sorted_arr[i]] += 1\n            if arr_counter == sorted_arr_counter:\n                ans += 1\n        return ans\n\n# Time: O(N^2) 迴圈裡加上 dict 比對\n# Space: O(N) 開了兩個 dict \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191610090","body":"```Python\n# 使用快慢指針找出倒數第 k 個節點，以倒數第 k 個節點當做新的 head，原本的 head 接在尾端\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head is None:\n            return head\n        if k == 0:\n            return head\n        \n        fast = head\n        slow = head\n        \n\t# 計算 linked list 的長度，以縮短 k 的長度\n        length = 1\n        while fast.next:\n            fast = fast.next\n            length += 1\n        fast = head\n        k = k % length\n        \n        # fast 先跟 slow 拉開距離 k\n        while k > 0:\n            if fast.next is not None:\n                fast = fast.next\n            else:\n                fast = head\n            k -= 1\n        \n        # slow 開始跟著 fast 往右移\n        while fast.next is not None:\n            fast = fast.next\n            slow = slow.next\n        \n        # 鏈的前半與後半互換\n        fast.next = head\n        head = slow.next\n        slow.next = None\n        \n        return head\n\n# Time: O(N)\n# Space: O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192654251","body":"```python\r\n# 假設 Linked List 長這樣 A -> B -> C ->\r\n# 如果要換 A, B，先讓 left, right 分別在這兩個位置上：left -> A -> B(right) -> C ->\r\n# 執行 swap 以後再將 left, right 往下一個目標位置移動\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        if not head.next:\r\n            return head\r\n        \r\n        left = ListNode()\r\n        # left 從 head 前一個 node 開始\r\n        left.next = head\r\n        # right 從 head 下一個 node 開始\r\n        right = head.next\r\n        \r\n        head = None\r\n        while True:\r\n            # swap nodes\r\n            left.next.next = right.next\r\n            right.next = left.next\r\n            left.next = right\r\n            # 第一輪的 swap 要指定新的 head\r\n            if not head:\r\n                head = right\r\n            \r\n            # 往右移動，如果節點不夠了就中止迴圈\r\n            left = right.next\r\n            if left.next and left.next.next:\r\n                right = left.next.next\r\n            else:\r\n                break\r\n        \r\n        return head\r\n\r\n# Time: O(N)\r\n# Space: O(1)\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193139711","body":"```python\r\n# 用快慢指針找到 linked list 中間的節點當作 BST 的 root\r\n# 使用遞迴，linked list 前半組成左子樹，後半段組成右子樹\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        if not head.next.next:\r\n            return TreeNode(head.next.val, TreeNode(head.val))\r\n        \r\n        fast = head\r\n        # slow 從 head 前一個節點開始，期望能得到 linked list 中間節點的前一個節點\r\n        slow = ListNode()\r\n        slow.next = head\r\n        while fast.next and fast.next.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        \r\n        mid = slow.next\r\n        slow.next = None\r\n        node = TreeNode(mid.val)\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(mid.next)\r\n        \r\n        return node\r\n\r\n# Time complexity: O(NlogN)\r\n# Space complexity: O(1) 是錯的，一樣要乘以遞迴深度 logN，所以正確答案是 O(logN)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193281511","body":"```python\r\n# 先走過 linked list A，將經過的 node 存在 set 裡面\r\n# 再走過 lilnked list B，將經過的 node 去 set 裡確認是否已經存在\r\n# 如果已經存在代表交集在此 node\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        if not headA or not headB:\r\n            return None\r\n        \r\n        seen = { headA }\r\n        while headA.next:\r\n            headA = headA.next\r\n            seen.add(headA)\r\n        \r\n        if headB in seen:\r\n            return headB\r\n        while headB.next:\r\n            headB = headB.next\r\n            if headB in seen:\r\n                return headB\r\n        return None\r\n# Time complexity: O(M+N), M is length of A, N is length of B\r\n# Space complexity: O(M)\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195611879","body":"## 思路\r\n使用 hash map 以及雙向 linked list\r\nhash map 的 key 為 int，value 為 linked list 裡的 node\r\nlinked list 的 head 為最左邊的 dummy node，tail 為最右邊的 dummy node\r\n\r\n## 程式碼\r\n```python\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.dict = dict()\r\n        self.head = ListNode(-1, -1)\r\n        self.tail = ListNode(-1, -1)\r\n        self.head.right = self.tail\r\n        self.tail.left = self.head\r\n        \r\n    def get(self, key: int) -> int:\r\n        if key in self.dict:\r\n            # 將對應的 node 從 linked list 摘除\r\n            node = self.dict[key]\r\n            self._remote_from_list(node)\r\n            # 將對應的 node 移到 linked list 的最右邊\r\n            self._move_to_right(node)\r\n            # 回傳 value\r\n            return node.value\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.dict:\r\n            # 將對應的 node 從 linked list 摘除\r\n            node = self.dict[key]\r\n            self._remote_from_list(node)\r\n            # 將對應的 node 移到 linked list 的最右邊\r\n            self._move_to_right(node)\r\n            # 更新 value\r\n            node.value = value\r\n        else:        \r\n            if len(self.dict) >= self.capacity:\r\n                # 去除掉最久沒用到的，也就是最左邊的 node\r\n                to_delete = self.head.right.key\r\n                del self.dict[to_delete]\r\n                self.head = self.head.right\r\n            # 塞入新的 key value\r\n            # 接上新的 node 到 linked list 右側\r\n            node = ListNode(key, value)\r\n            self._move_to_right(node)\r\n            # 紀錄新的 node 到 dictionary\r\n            self.dict[key] = node\r\n           \r\n    def _move_to_right(self, node):\r\n        self.tail.left.right = node\r\n        node.left = self.tail.left\r\n        self.tail.left = node\r\n        node.right = self.tail\r\n        \r\n    def _remote_from_list(self, node):\r\n        node.left.right = node.right\r\n        node.right.left = node.left \r\n\r\nclass ListNode:\r\n    def __init__(self, key, value):\r\n        self.value = value\r\n        self.key = key\r\n        self.left = None\r\n        self.right = None\r\n```\r\n**複雜度**\r\n- Time: get put 都是 O(1)\r\n- Space: O(N) N 為 capacity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196782629","body":"## 思路\r\n- 樹的最深深度等於左右子樹較深的深度的再加一\r\n- 用 dfs 遞迴，如果到葉節點再往下一層就回傳 0\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n```\r\n\r\n**複雜度**\r\n- Time complexity: O(N)，N 為節點數目\r\n- Space complexity: O(h)，h = 樹的深度，最好 logN，最差 N","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1189171833","body":"func addToArrayForm(A []int, K int) (ans []int) {\n    for i := len(A) - 1; i >= 0; i-- {\n        //从后往前加 每次加一个  比如 K=806\n        sum := A[i] + K%10    //A[i] = 1   1 + 6\n        K /= 10\n        if sum >= 10 {\n            K++ //K往前进一位\n            sum -= 10  //sum 只留下个位数\n        }\n        ans = append(ans, sum) //添加0到数组首部\n    }\n\n\n//如果进位的是最后几位 循环添加\n    for ; K > 0; K /= 10 {\n        ans = append(ans, K%10)\n    }\n    //反转数组\n    reverse(ans)\n    return\n}\n\nfunc reverse(A []int) {\n    for i, n := 0, len(A); i < n/2; i++ {\n        A[i], A[n-1-i] = A[n-1-i], A[i]\n    }\n}\n","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189195841","body":"### 栈\n\n\n```go\n\ntype MyQueue struct {\n\tinstack []int \n\toutstack []int \n}\n\n\nfunc NewQueue() MyQueue {\n\treturn MyQueue{\n\t\tinstack: make([]int, 0),\n\t\toutstack: make([]int, 0),\n\t}\n}\n\n// push 压栈\nfunc (this *MyQueue) Push(x int)  {\n\tthis.instack = append(this.instack, x)\n}\n\n// 出栈\nfunc (this *MyQueue) in2out()  {\n\t// 当outstack空时，需要将instack全部转入outstack\n\tfor len(this.instack) > 0 {\n\t\tthis.outstack = append(this.outstack, this.instack[len(this.instack)-1])\n\t\tthis.instack = this.instack[:len(this.instack)-1]\n\t}\n}\n\n// pop\nfunc (this *MyQueue) Pop() int {\n\t// pop时需要先判断outstack是否为空\n\tif len(this.outstack) == 0 {\n\t\tthis.in2out()\n\t}\n\t// pop时出栈top, 然后更新outstack\n\tval := this.outstack[len(this.outstack)-1]\n\tthis.outstack = this.outstack[:len(this.outstack)-1]\n\treturn val\n}\n\n// peek\nfunc (this *MyQueue) Peek() int {\n\t// 因为outstack才是出栈功能部分，需要先判断是否为空\n\tif len(this.outstack) == 0 {\n\t\tthis.in2out()\n\t}\n\treturn this.outstack[len(this.outstack)-1]\n}\n\n// empty\nfunc (this *MyQueue) Empty() bool {\n\t// 仅当入栈和出栈都为空时，queue才为空\n\treturn len(this.outstack) == 0 && len(this.instack) == 0\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189231157","body":"```js\nvar MyQueue = function() {\n    this.mainStack = [];\n    this.tempStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.mainStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    while(this.mainStack.length > 1) {\n        this.tempStack.push(this.mainStack.pop());\n    }\n    const res = this.mainStack.pop();\n    while(this.tempStack.length) {\n        this.mainStack.push(this.tempStack.pop());\n    }\n\n    return res;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.mainStack[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.mainStack.length;\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195667267","body":"```js\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.map = new Map();\n    this.capacity = capacity;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(this.map.has(key)) {\n        let temp = this.map.get(key);\n        this.map.delete(key);\n        this.map.set(key, temp);\n        return temp;\n    }\n    return -1;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if(this.map.has(key)) {\n        this.map.delete(key);\n    }\n    this.map.set(key, value);\n    if(this.map.size > this.capacity) {\n        this.map.delete(this.map.keys().next().value)\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188827861","body":"- Language: JAVA\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if(s == null || s.length() == 0){\r\n            return s;\r\n        }\r\n\r\n        int len = s.length();\r\n        Stack<Character> stack = new Stack<>();\r\n        for(int i = 0; i < len; i++){\r\n            char c = s.charAt(i);\r\n            if(c != ']'){\r\n                stack.push(c);\r\n            } else {\r\n                char sc = ' ';\r\n                StringBuffer sb = new StringBuffer();\r\n                while(!stack.isEmpty()){\r\n                    sc = stack.pop();\r\n                    if(sc != '['){\r\n                        sb.append(sc);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                int num = 0;\r\n                int idx = 0;\r\n                while(!stack.isEmpty()){\r\n                    char n = stack.peek();\r\n                    if(n >= '0' && n <= '9'){\r\n                        int tmp = 1;\r\n                        for(int m = 0; m < idx; m++){\r\n                            tmp *= 10;\r\n                        }\r\n                        num += tmp * (n - '0');\r\n                        idx++;\r\n                        stack.pop();\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                String pattern = sb.reverse().toString();\r\n                sb.setLength(0);\r\n\r\n                for(int j = 0; j < num; j++){\r\n                    sb.append(pattern);\r\n                }\r\n\r\n                for(int k = 0; k < sb.length(); k++){\r\n                    stack.push(sb.charAt(k));\r\n                }\r\n            }\r\n        }\r\n\r\n        StringBuffer res = new StringBuffer(stack.size());\r\n        while(!stack.isEmpty()){\r\n            res.append(stack.pop());\r\n        }\r\n\r\n        return res.reverse().toString();\r\n    }\r\n}\r\n```\r\n\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n);","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189702954","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int res = 0;\n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        int diff = 0;\n        for (int i = 0; i < arr.length; i++){\n            diff += arr[i] - sorted[i];\n            if (diff == 0){\n                res ++;\n            }\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190982420","body":"```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return null;\n        int n = 1;\n        ListNode tail = head;\n        while(tail.next != null){\n            n++;\n            tail = tail.next;\n        }\n        tail.next = head;\n        \n        ListNode newTail = head;\n\n        for(int i = 0; i < n-k%n- 1; i++){\n            newTail = newTail.next;\n        }\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n        \n        return newHead;\n        \n    }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193366911","body":"```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) return null;\n        ListNode start = check(head);\n        if(start == null) return null;\n        ListNode slow = head;\n        ListNode fast = start;\n        while(slow != fast){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n    private ListNode check(ListNode head){\n        ListNode fast = head;\n        ListNode slow = head;\n        \n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow){\n                return slow;\n            }\n        }\n        return null;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194510012","body":"```java\nclass LRUCache {\n    private Map<Integer, DLinkedNode> map = new HashMap<>();\n    private DLinkedNode head, tail;\n    private int size;\n    private int capacity;\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.size = 0;\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        if(map.containsKey(key)){\n            moveToHead(map.get(key));\n            return map.get(key).value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (map.containsKey(key)){\n            moveToHead(map.get(key));\n            map.get(key).value = value;\n        }else{\n            DLinkedNode newNode = new DLinkedNode();\n            newNode.key = key;\n            newNode.value = value;\n            map.put(key,newNode);\n            addNode(newNode);\n            this.size++;\n            if(this.size > this.capacity){\n                DLinkedNode pop = popTail();\n                map.remove(pop.key);\n                this.size--;\n            }\n        }\n    }\n    \n    \n    class DLinkedNode{\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n    }\n    private void addNode(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        \n        head.next.prev = node;\n        head.next = node;\n    }\n    private void removeNode(DLinkedNode node){\n        DLinkedNode prev = node.prev;\n        DLinkedNode next = node.next;\n        \n        prev.next = next;\n        next.prev = prev;\n    }\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addNode(node);\n    }\n    private DLinkedNode popTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196203809","body":"```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        int level = 0;\n        while(!q.isEmpty()){\n            int curSize = q.size();\n            while(curSize-->0){\n                TreeNode cur = q.poll();\n                if(cur.left != null){\n                    q.add(cur.left);\n                }\n                if(cur.right != null){\n                    q.add(cur.right);\n                }\n            }\n            level++;\n        }\n        return level;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197102899","body":"```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right,q.right);\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189754021","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>maxStk;\n        maxStk.push(arr[0]);\n        for(int i=1;i<arr.size();i++){\n            if(arr[i]<maxStk.top()){\n                int maxNum=maxStk.top();\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\n                maxStk.push(maxNum);\n            }\n            else maxStk.push(arr[i]);\n        }\n        return maxStk.size();\n\n\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191159350","body":"```\r\nif (k == 0 || head == nullptr || head->next == nullptr) {\r\nreturn head;\r\n}\r\nint n = 1;\r\nListNode* iter = head;\r\nwhile (iter->next != nullptr) {\r\niter = iter->next;\r\nn++;\r\n}\r\nint add = n - k % n;\r\nif (add == n) {\r\nreturn head;\r\n}\r\niter->next = head;\r\nwhile (add--) {\r\niter = iter->next;\r\n}\r\nListNode* ret = iter->next;\r\niter->next = nullptr;\r\nreturn ret;\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195071927","body":"```\r\nstruct DLinkedNode {\r\n    int key, value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode*> cache;\r\n    DLinkedNode* head;\r\n    DLinkedNode* tail;\r\n    int size;\r\n    int capacity;\r\n\r\npublic:\r\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\r\n        // 使用伪头部和伪尾部节点\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!cache.count(key)) {\r\n            return -1;\r\n        }\r\n        // 如果 key 存在，先通过哈希表定位，再移到头部\r\n        DLinkedNode* node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)) {\r\n            // 如果 key 不存在，创建一个新的节点\r\n            DLinkedNode* node = new DLinkedNode(key, value);\r\n            // 添加进哈希表\r\n            cache[key] = node;\r\n            // 添加至双向链表的头部\r\n            addToHead(node);\r\n            ++size;\r\n            if (size > capacity) {\r\n                // 如果超出容量，删除双向链表的尾部节点\r\n                DLinkedNode* removed = removeTail();\r\n                // 删除哈希表中对应的项\r\n                cache.erase(removed->key);\r\n                // 防止内存泄漏\r\n                delete removed;\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            DLinkedNode* node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    void addToHead(DLinkedNode* node) {\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n    \r\n    void removeNode(DLinkedNode* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(DLinkedNode* node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    DLinkedNode* removeTail() {\r\n        DLinkedNode* node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189833390","body":"### 思路\r\n滑动窗口\r\n### js代码\r\n```JavaScript\r\nvar maxChunksToSorted = function (arr) {\r\n    const sorted = [...arr];\r\n    sorted.sort((a, b) => a - b);\r\n\r\n    let count = 0,\r\n        sum1 = 0,\r\n        sum2 = 0;\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i];\r\n        sum2 += sorted[i];\r\n\r\n        if (sum1 === sum2) {\r\n            count++;\r\n            sum1 = sum2 = 0; \r\n        }\r\n    }\r\n\r\n    return count;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度: O(nlogn)\r\n- 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196188309","body":"### 思路\n递归\n### js代码\n```JavaScript\nvar maxDepth = function(root) {\n    if(root === null) {\n        return 0\n    }\n    let leftHeight = maxDepth(root.left);\n    let rightHeight = maxDepth(root.right);\n    return Math.max(leftHeight,rightHeight) + 1;\n};\n```\n\n### 复杂度分析\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189849757","body":"### Implementation\n```c++\nclass Solution\n{\npublic:\n  int maxChunksToSorted(vector<int>& arr)\n  {\n    std::stack<int> s;\n    for (auto const& ele : arr) {\n      if (s.empty() || s.top() <= ele) {\n        s.push(ele);\n      } else {\n        int chunkLeader = s.top();\n        s.pop();\n        while (!s.empty() && s.top() > ele) {\n          s.pop();\n        }\n        // Now the leader of the chunk is back to the stack\n        s.push(chunkLeader);\n      }\n    }\n    return s.size();\n  }\n};\n```\n### Complexity\n- Time complexity: O(n) \n- Space complexity: O(n) ","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193366284","body":"### Implementation\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n      ListNode *pSlow{head};\n      ListNode *pFast{head};\n      while (pFast != nullptr && pFast->next != nullptr) {\n        pFast = pFast->next->next;\n        pSlow = pSlow->next;\n        if (pSlow == pFast) break;\n      }\n      \n      if (pFast == nullptr || pFast->next == nullptr) {\n        return nullptr;\n      }\n      \n      pSlow = head;\n      while (pSlow != pFast) {\n        pSlow = pSlow->next;\n        pFast = pFast->next;\n      }\n      return pSlow;\n    }\n};\n```\n### Complexity\n- Time complexity: O(N) \n- Space complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189964725","body":"参考题解，使用辅助栈\r\n\r\n```cpp\r\n#include<bits/stdc++.h>\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        vector<int> stack;\r\n        for(int num : arr) {\r\n            if(!stack.empty() && num < *stack.rbegin()) {\r\n                int head = *stack.rbegin();\r\n                stack.pop_back();\r\n                while(!stack.empty() && num < *stack.rbegin())\r\n                 stack.pop_back();\r\n                stack.push_back(head);\r\n            }\r\n            else stack.push_back(num);\r\n        }\r\n        return stack.size();\r\n    }\r\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195132359","body":"``` cpp\r\nstruct Node {\r\n    int key;\r\n    int val;\r\n    Node *next, *prev;\r\n    Node(int k, int v) : key(k), val(v), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass DoubleLinkedList {\r\n    Node *head, *tail;\r\npublic:\r\n    DoubleLinkedList() {\r\n        head = new Node(-1, -1);\r\n        tail = new Node(-1, -1);\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n\r\n    void push_front(Node* node) {\r\n        node->next = head->next;\r\n        node->prev = head;\r\n        node->next->prev = node;\r\n        head->next = node;\r\n    }\r\n\r\n    void erase(Node* node) {\r\n        node->next->prev = node->prev;\r\n        node->prev->next = node->next;\r\n    }\r\n\r\n    Node* back() {\r\n        return tail->prev;\r\n    }\r\n\r\n    void pop_back() {\r\n        erase(tail->prev);\r\n    }\r\n};\r\n\r\nclass LRUCache {\r\n    int cap;\r\n    unordered_map<int, Node*> key_node_map;\r\n    DoubleLinkedList* node_list;\r\npublic:\r\n    LRUCache(int capacity) {\r\n        cap = capacity;\r\n        node_list = new DoubleLinkedList();\r\n    }\r\n    \r\n    int get(int key) {\r\n        // 不存在该key\r\n        if (key_node_map.find(key) == key_node_map.end()) {\r\n            return -1;\r\n        } else {\r\n            // 将当前节点在移动到双链表的首位\r\n            Node* node = key_node_map[key];\r\n            node_list->erase(node);\r\n            node_list->push_front(node);\r\n            return node->val;\r\n        }\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        // 如果key存在，则修改对应的value并移动至链表首端\r\n        if (key_node_map.find(key) != key_node_map.end()) {\r\n            Node *node = key_node_map[key];\r\n            node->val = value;\r\n            node_list->erase(node);\r\n            node_list->push_front(node);\r\n        } else {\r\n            // 如果缓存已满，则删除双链表末端节点\r\n            if (key_node_map.size() == cap) {\r\n                key_node_map.erase(node_list->back()->key);\r\n                node_list->pop_back();\r\n            }\r\n            // 插入新节点\r\n            Node *node = new Node(key, value);\r\n            key_node_map[key] = node;\r\n            node_list->push_front(node);\r\n        }\r\n    }\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189968695","body":"### 思路\r\n\r\n参考题解的单调栈思路，满足条件的分块一定是后边分块的最小值不小于前边分块的最大值，所以保留每一个分块的最大值加入栈，最后取栈的长度即可\r\n\r\n### 代码\r\n\r\n\r\n```\r\nvar maxChunksToSorted = function(arr) {\r\n    const stack=[]\r\n    for(let i=0;i<arr.length ;i++){\r\n        let a=arr[i]\r\n        if(stack[stack.length-1]&&stack[stack.length-1]>a){\r\n            const cur=stack[stack.length-1]\r\n            while(stack[stack.length-1]&&stack[stack.length-1]>a){\r\n                stack.pop()\r\n            }\r\n            stack.push(cur)\r\n        }else{\r\n            stack.push(a)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190386338","body":"**思路**\r\n\r\n自己没什么思路，按照题解里的两次遍历方法\r\n先遍历一遍，记录到当前数为止的最大值head\r\n然后从后往前遍历，如果遍历过的arr数组里的最小值比前一个分块的最大值head要大，块的数量 + 1\r\n\r\n**代码**\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] head = new int[arr.length];\r\n        head[0] = arr[0];\r\n        for(int i = 1; i < arr.length; i++){\r\n            head[i] = Math.max(head[i - 1], arr[i]);\r\n        }\r\n        int tail = Integer.MAX_VALUE, res = 0;\r\n        for(int i = arr.length - 1; i >= 0; i--){\r\n            if(tail >= head[i]){\r\n                res++;\r\n            }\r\n            tail = Math.min(tail, arr[i]);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- 时间复杂度：O(n)\r\n\r\n- 空间复杂度：O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190438348","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int>maxStk;\r\n        maxStk.push(arr[0]);\r\n        for(int i=1;i<arr.size();i++){\r\n            if(arr[i]<maxStk.top()){\r\n                int maxNum=maxStk.top();\r\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\r\n                maxStk.push(maxNum);\r\n            }\r\n            else maxStk.push(arr[i]);\r\n        }\r\n        return maxStk.size();\r\n    }\r\n};\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1189685480","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = k\r\n        results=[]\r\n        i = len(num)-1\r\n        while True:\r\n            if sum == 0 and i <0:\r\n                break\r\n            current = 10**(len(num)-i-1)\r\n            if i >= 0:\r\n                sum += current*num[i] \r\n            reminder = int(sum%(current*10)/current)\r\n            results.insert(0, reminder)\r\n            sum = sum - reminder*current\r\n            i -= 1\r\n        return results\r\n```\r\n复杂度O(n)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190642938","body":"### 思路\n\n1. 形成一个链表环； 2. 向右移动 （len_list - k % len_list）； 3. 得到新列表的head， 并断开链表环。\n\n### 代码\n\n\n```python\n\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        currentNode = head\n        len_list = 1\n        if head is None:\n            return None\n        while currentNode.next is not None:\n            len_list = len_list + 1\n            currentNode = currentNode.next\n        currentNode.next = head\n                \n        move = len_list - k % len_list\n        \n        for i in range(move):\n            currentNode = currentNode.next\n        head = currentNode.next\n        currentNode.next = None\n        \n        return head\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190893559","body":"\r\n\r\nclass Solution {\r\n         public ListNode rotateRight(ListNode head, int j) {\r\n             if(head == null || head.next == null) {\r\n                 return head;\r\n             }\r\n             ListNode tail = head;\r\n             int length = 1;\r\n             while(tail.next != null) {\r\n                 tail = tail.next;\r\n                 length++;\r\n             }\r\n             tail.next = head;\r\n             ListNode cur = head;\r\n             for(int i = 1; i <  len - (j % len); i++) {\r\n                 cur = cur.next;\r\n             }\r\n             tail = cur.next;\r\n             cur.next = null;\r\n\r\n             return tail;\r\n         }\r\n     }","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197542225","body":"class Solution {\r\npublic:\r\n\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (p == NULL && q == NULL) return true;\r\n        if (p == NULL || q == NULL) return false;\r\n        queue<TreeNode*> que;\r\n        que.push(p);   //\r\n        que.push(q);  //\r\n        while (!que.empty()) {  //\r\n            TreeNode* leftNode = que.front(); que.pop();\r\n            TreeNode* rightNode = que.front(); que.pop();\r\n            if (!leftNode && !rightNode) {  //\r\n                continue;\r\n            }\r\n            //\r\n            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {\r\n                return false;\r\n            }\r\n            que.push(leftNode->left);   //\r\n            que.push(rightNode->left); //\r\n            que.push(leftNode->right);  //\r\n            que.push(rightNode->right);  //\r\n        }\r\n        return true;\r\n    }\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1191415978","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i=len(num)-1\r\n        while k:\r\n            num[i]+=k\r\n            k=num[i]//10\r\n            num[i]=num[i]%10\r\n            i-=1\r\n            if i<0 and k:\r\n                num.insert(0,0)\r\n                i=0\r\n        return num\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1193054066","body":"CODE\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        if not s:\r\n            return None\r\n\r\n        count = 0       #计数器\r\n        temp = 10000\r\n\r\n        result = []\r\n        \r\n        for i in range(len(s)):\r\n            if s[i] != c:\r\n                count += 1\r\n                temp += 1\r\n                if i+1 == len(s):\r\n                    for j in range(count):\r\n                        result.append(j+1)\r\n                        count -= 1\r\n                                \r\n            else:                \r\n                for j in range(count):                    \r\n                    pre = temp - count + 1\r\n                    result.append(min(count,pre))\r\n                    count -= 1\r\n                    \r\n                temp = 0\r\n                result.append(0)\r\n\r\n        return result\r\n```\r\n//执行用时：40 ms,内存消耗：14.9 MB","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191234692","body":"CODE\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if k==0 or not head or not head.next:\r\n            return head\r\n\r\n        n=1\r\n        cur=head\r\n\r\n        while cur.next:\r\n            cur=cur.next\r\n            n+=1\r\n\r\n        if(add:=n-k%n)==n:\r\n            return head\r\n        cur.next=head\r\n\r\n        while add:\r\n            cur=cur.next\r\n            add-=1\r\n\r\n        ret=cur.next\r\n        cur.next=None\r\n\r\n        return ret        \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192142197","body":"----需要创建一个虚拟节点去接住链表，链表头结点不带值\r\n\r\nCODE\r\n\r\n```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        #创建虚拟节点\r\n        dummyHead=ListNode(-1)\r\n\r\n        p1 = head\r\n        p2 = dummyHead\r\n\r\n        while p1 and p1.next:\r\n            q = p1.next\r\n\r\n            p2.next = q\r\n            p1.next = q.next\r\n            q.next = p1\r\n\r\n            p2 = p1\r\n            p1 = p1.next\r\n\r\n        return dummyHead.next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193049431","body":"CODE\r\n\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        def getMedian(left:ListNode,right:ListNode)->ListNode:\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                slow = slow.next\r\n                fast = fast.next.next\r\n            return slow\r\n\r\n        def buildTree(left:ListNode,right:ListNode)->TreeNode:\r\n            if left == right:        #链表为空\r\n                return  None\r\n            mid = getMedian(left,right)\r\n            root = TreeNode(mid.val)    #获取中值节点，依次插入\r\n            root.left = buildTree(left,mid)\r\n            root.right = buildTree(mid.next,right)\r\n            return root\r\n        \r\n        return buildTree(head,None)\r\n```\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195198436","body":"CODE\r\n\r\n//纯几把不会写，二刷看完哈希表回头重做--\r\n\r\n```\r\nclass ListNode:         #initialize listnode\r\n    def __init__(self,key = 0,val = 0):\r\n        self.key = key\r\n        self.val = val\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        \r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def remove_node(self,node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def add_node_to_last(self,node):\r\n        self.tail.prev.next = node\r\n        node.prev = self.tail.prev\r\n        node.next = self.tail\r\n        self.tail.prev = node\r\n\r\n    def  move_node_to_last(self,node):\r\n        self.remove_node(node)\r\n        self.add_node_to_last(node)\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.hashmap:\r\n            return -1\r\n\r\n        node = self.hashmap[key]\r\n        self.move_node_to_last(node)\r\n        return node.val\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            node = self.hashmap[key]\r\n            node.val = value\r\n            self.move_node_to_last(node)\r\n            return\r\n        if len(self.hashmap) == self.capacity:\r\n            del self.hashmap[self.head.next.key]\r\n            self.remove_node(self.head.next)\r\n        node = ListNode(key,value)\r\n\r\n        self.hashmap[key] = node\r\n        self.add_node_to_last(node)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191560985","body":"```\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head or not head.next:\n            return head\n\n        tail = head\n        length = 1\n        while tail.next:\n            length += 1\n            tail = tail.next\n        tail.next = head\n\n        k = k % length\n        for _ in range(length - k):\n            tail = tail.next\n\n        head = tail.next\n        tail.next = None\n        return head\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnvsd":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191616669","body":"## 思路\r\n\r\n根据题目可以总结出，将链表的每个节点向后移动 k 步，也就是将链表的倒数第 k 个节点作为头结点，其前面的所有节点放在原链表尾结点之后。\r\n可以利用快慢指针来处理。\r\n\r\n## 代码 (JS)\r\n\r\n```JavaScript\r\nvar rotateRight = function(head, k) {\r\n    if(k === 0 || head === null) return head;\r\n\r\n    // 获取链表长度\r\n    let len = calculateLen(head);\r\n    k = k%len;\r\n\r\n    // 定义快慢指针\r\n    let slow = head;\r\n    let fast = head;\r\n\r\n    // 快指针向前移动 k 步\r\n    for(let i=0; i<k; i++) {\r\n        fast = fast.next\r\n    }\r\n\r\n    // 快指针移动到尾部为止\r\n    while (fast.next !== null) {\r\n        fast = fast.next;\r\n        slow = slow.next;\r\n    }\r\n\r\n    // 将快指针的下一个节点设为头结点\r\n    fast.next = head;\r\n    // 新的头节点为慢指针的下一个节点\r\n    head = slow.next;\r\n    slow.next = null;\r\n\r\n    return head;\r\n};\r\n\r\n// 计算链表长度\r\nfunction calculateLen(head) {\r\n    let len = 0;\r\n    while (head!==null) {\r\n        head = head.next;\r\n        len++;\r\n    }\r\n    return len;\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(1) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yueza":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192167435","body":"## 思路\r\n迭代：设置pre节点后，原地交换pre节点和cur节点\r\n## 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy_head = ListNode(0)\r\n        dummy_head.next = head\r\n        pre = dummy_head\r\n        cur = head\r\n        while cur != None and cur.next != None:\r\n            pre.next = cur.next\r\n            cur.next = cur.next.next\r\n            pre.next.next = cur\r\n            pre = cur\r\n            cur = cur.next\r\n        return dummy_head.next\r\n```\r\n## 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193133881","body":"### 思路\n通过快慢指针找到中间值（保证树平衡），左右两侧各自建树\n\n和官方的第一种思路相同，但写的有些丑陋...\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def find_mid(head: Optional[ListNode]) -> ListNode:\n            fast, slow = head, head\n            while fast != None and fast.next != None:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(head: ListNode) -> TreeNode:\n            if head == None:\n                return None\n            elif head.next == None:\n                return TreeNode(head.val)\n            \n            mid = find_mid(head)\n            left, right = head, mid.next\n            while head.next != mid:\n                head = head.next\n            head.next = None  #截断左链表\n        \n            root = TreeNode(mid.val)\n            root.left = self.sortedListToBST(left)\n            root.right = self.sortedListToBST(right)\n            return root\n        \n        return buildTree(head)\n```\n### 复杂度\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193160207","body":"### 思路\n指针A和指针B分别从两链表头节点往后走，若遍历完链表则从另一链表头节点继续走\n\n若不相交，各自走完两个链表，返回None\n\n若相交，则在公共节点相遇，返回节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```\n### 复杂度\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194219052","body":"### 思路\n1.通过快慢指针fast, slow找到相交节点\n\n2.额外指针ret指向头节点，ret与slow必相较于环入口节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        flag = False\n        while fast != None and fast.next != None and slow != None:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                flag = True\n                break\n        if flag:\n            ret = head\n            while ret != slow:\n                ret = ret.next\n                slow = slow.next\n            return ret\n        else:\n            return None\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195665133","body":"### 思路\r\n第一次做这题，偷懒用dict，ac是ac了，运行时间和内存都有点拉跨\r\n\r\n### 代码\r\n\r\n```python\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.cache = {}\r\n        self.cap = capacity\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.cache:\r\n            value = self.cache.pop(key)\r\n            self.cache[key] = value\r\n            return value\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.cache:\r\n            self.cache.pop(key)\r\n        elif len(self.cache) == self.cap:\r\n            pop_key = list(self.cache.keys())[0]\r\n            self.cache.pop(pop_key)\r\n        self.cache[key] = value\r\n        return self\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196884225","body":"### 思路\n递归：树的高度等于max(左子树高度, 右子树高度) + 1\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root == None:\n            return 0\n        else:\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(tree_height)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192279295","body":"## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        dummy_head = ListNode()\r\n        prev = dummy_head\r\n        while head and head.next:\r\n            first = head\r\n            second = first.next\r\n\r\n            prev.next = second\r\n            first.next = second.next\r\n            second.next = first\r\n            prev = first\r\n            \r\n            head = first.next\r\n        return dummy_head.next\r\n\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192447685","body":"```\nCODE:\n\nvar swapPairs = function(head) {\n\n    let dumpHead = new ListNode(0, head);\n    let tmp = dumpHead;\n\n    while(tmp.next && tmp.next.next) {\n        let prev = tmp.next, cur = tmp.next.next.next;\n        \n        tmp.next = prev.next;\n        prev.next.next = prev;\n        prev.next = cur;\n\n        tmp = tmp.next.next;\n    }\n\n    return dumpHead.next;\n\n};\n\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196636144","body":"```\nvar maxDepth = function(root) {\n    let res = 0 // 最大深度\n    // 求最大深度使用深度优先遍历；求最小深度使用广度优先遍历\n    // l代表当前节点所在层级\n    const dfs = (n, l) => {\n        if(!n) return\n        // 只在叶子节点时做判断\n        if(!n.left && !n.right) {\n            res = Math.max(res, l)\n        }\n        dfs(n.left, l+1)\n        dfs(n.right, l+1)\n    }\n    dfs(root, 1)\n    return res\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cusanity":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192590876","body":"public class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode second = head.next;\n        ListNode third = second.next;\n        second.next = head;\n        head.next = swapPairs(third);\n        return second;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193111278","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildHelper(head, null);\n    }\n    public TreeNode buildHelper(ListNode begin, ListNode end){\n        if(begin == end) return null;\n        ListNode mid = begin, fast = begin;\n        while(fast != end && fast.next != end){\n            mid = mid.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildHelper(begin, mid);\n        root.right = buildHelper(mid.next, end);\n        return root;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193300147","body":"## Solution\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode pA = headA, pB = headB;\n        while(pA != pB){\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n时间复杂度: O(M+N)\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193892649","body":"## Solution\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) return null;\n        ListNode fast = head, slow = head;\n        Boolean found = false;\n        while(fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast){\n                found = true;\n                break;\n            }\n        }\n        if(!found) return null;\n        slow = head;\n        while(slow != fast){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1194820126","body":"## Solution\n```java\nclass LRUCache {\n    int capacity;\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1;\n        }\n        makeMostRecent(key);\n        return cache.get(key);\n    }\n​\n    public void put(int key, int val) {\n        if (cache.containsKey(key)) {\n            cache.put(key, val);\n            makeMostRecent(key);\n            return;\n        }\n        if (cache.size() >= this.capacity) {\n            int LRU = cache.keySet().iterator().next();\n            cache.remove(LRU);\n        }\n        cache.put(key, val);\n    }\n​\n    private void makeMostRecent(int key) {\n        int val = cache.get(key);\n        cache.remove(key);\n        cache.put(key, val);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196892169","body":"## Solution\n```java\nclass Solution {\n    public int traverse(TreeNode root){\n        if(root == null) return 0;\n        if(root.left == null) return 1 + traverse(root.right);\n        if(root.right == null) return 1 + traverse(root.left); \n        return 1 + Math.max(traverse(root.right), traverse(root.left));\n    }\n    \n    public int maxDepth(TreeNode root) {\n        return traverse(root);\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay-xzj":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192624895","body":"class Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n        ListNode temp = dummyHead;\n        while (temp.next != null && temp.next.next != null) {\n            ListNode node1 = temp.next;\n            ListNode node2 = temp.next.next;\n            temp.next = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n            temp = node1;\n        }\n        return dummyHead.next;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192671432","body":"### 思路\n迭代\n\n### 代码\n```c++\nclass Solution \n{\npublic:\n    ListNode* swapPairs(ListNode* head) \n    {\n        ListNode* p = new ListNode(0);\n        p->next = head;\n        ListNode* curr = p;\n        //当前节点或下一个节点为NULL，分别对应偶数和奇数个节点的终止标志\n        while(head != NULL && head->next != NULL)\n        {\n            ListNode* firstNode = head;\n            ListNode* secondNode = head->next;\n\n            curr->next = secondNode;\n            firstNode->next = secondNode->next;\n            secondNode->next = firstNode;\n\n            curr = firstNode;\n            head = firstNode->next;\n        }\n        return p->next;\n\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194275949","body":"### 思路\n双指针，快慢指针\n设双指针 fast，slow 指向链表头部 head\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        auto fast=head,slow=head;\n        while(fast){\n            fast=fast->next;\n            slow=slow->next;\n            if(fast) fast=fast->next;\n            else break;\n\n            if(fast==slow){\n                fast=head;\n                while(fast!=slow){\n                    fast=fast->next;\n                    slow=slow->next;\n                }\n                return fast;\n            } \n        }\n        return NULL;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyue-ma":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192713188","body":"```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        res = ListNode(next=head)\r\n        pre = res\r\n        while pre.next and pre.next.next:\r\n            cur = pre.next\r\n            post = pre.next.next            \r\n            cur.next = post.next\r\n            post.next = cur\r\n            pre.next = post\r\n            pre = pre.next.next\r\n        return res.next\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193067204","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n/*\r\n[1]:\r\n0-1\r\ns r\r\nf\r\n\r\n0   -1\r\ns    r  null\r\nf\r\n\r\n-> must deal with one node case\r\n\r\nO(n) for each level, O(logn) levels, Time: O(nlogn) \r\n\r\nspace: stack depth O(height), height-balanced, then O(logn), n = list length + tree space O(n)\r\n*/\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) return null;\r\n        if (head.next == null) return new TreeNode(head.val, null, null);\r\n        \r\n        ListNode dummy = new ListNode(0, head);\r\n        ListNode slow = dummy, fast = dummy;\r\n        while (fast.next != null && fast.next.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        ListNode rootListNode = slow.next;\r\n        slow.next = null;\r\n        ListNode head2 = rootListNode.next;\r\n        rootListNode.next = null;\r\n        \r\n        TreeNode root = new TreeNode(rootListNode.val);\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(head2);\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193140748","body":"```\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193334140","body":"```\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        ## 找到两个链表的长度，快慢指针 \n        m, n = 0, 0 \n        pa, pb = headA, headB \n        while pa is not None:\n            pa = pa.next \n            m += 1 \n        while pb is not None:\n            pb = pb.next \n            n += 1 \n        len_abs = m - n \n\n        pa, pb = headA, headB \n        if len_abs < 0: # A比B短，B先走\n            len_abs = abs(len_abs)\n            while len_abs > 0:\n                pb = pb.next \n                len_abs -= 1 \n        else:\n            while len_abs > 0:\n                pa = pa.next\n                len_abs -= 1 \n        while pa is not None and pb is not None:\n            if pa == pb:\n                return pa \n            pa = pa.next \n            pb = pb.next \n        return None \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"steven72574":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193207055","body":"**思路**：\n利用双指针，a和b先指向两个链表的头，然后同时往后移动，当a走到尾时，重新指向b链表的头部，当b指针走到尾时，重新指向a链表的头部，a和b相等的时为两链表相交处。\n\n**代码**\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        \n        ListNode a = headA;\n        ListNode b = headB;\n        while(a!=b){\n            a = a.next;\n            b = b.next;\n            if((a ==null) && (b==null)){\n                return null;\n            }\n            if(a == null){\n                a = headB;\n            }\n            if(b == null){\n                b = headA;\n            }\n        }\n        return a;\n    }\n}\n\n**时间复杂度O(n)**\n\n**空间复杂度O(1)**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193904662","body":"**思路**用快慢指针，快指针一次走两步，慢指针一次一步，两指针第一次相遇时，将快指针定位至开头，并且此后一次走一步，两指针再次相遇时则为环的入口。\n\n**代码**\n\npublic class Solution {\n\n    public ListNode detectCycle(ListNode head) {\n\n        if(head == null || head.next == null){\n\n            return null;\n        }\n        ListNode fast = head ;\n        ListNode slow = head ;\n        do{\n            if(fast!=null && fast.next!=null){//移动指针前判断当前结点是否为空\n                fast = fast.next.next ;\n                if(fast == null){\n                    return null;//移动后fast可能指向空指针，此时返回null\n                }\n            }\n            if(slow != null){//移动指针前判断当前结点是否为空\n                slow = slow.next ;\n                \n            }\n        }\n        while(fast!=slow);\n        \n        fast = head;\n        while(fast!=slow){\n            if(fast!=null){\n            fast = fast.next ;\n            }else{return null;}\n            if (slow != null){\n                slow = slow.next ;\n            }else{return null;}\n        }\n        return fast;\n    }\n}\n\n时间复杂度O(n)\n\n空间复杂度O(1)\n\n感受比较大的是边界条件的判断需要考虑全面，如判断头指针是否为空，以及每次移动指针时都要判断当前指针是否为空，这些解决后。剩下的则比较容易些。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193315147","body":"```c++\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n struct ListNode {\r\n     int val;\r\n     ListNode *next;\r\n     ListNode(int x) : val(x), next(NULL) {}\r\n };\r\n\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode *p_a = headA;\r\n        ListNode *p_b = headB;\r\n\r\n        while (p_a &&p_b){\r\n            p_a = p_a->next;\r\n            p_b = p_b->next;\r\n        }\r\n\r\n        ListNode *firstCommon = nullptr;\r\n\r\n        ListNode *p_a2 = headA;\r\n        ListNode *p_b2 = headB;\r\n\r\n        while (p_a!= nullptr){\r\n            p_a2 = p_a2->next;\r\n            p_a = p_a->next;\r\n        }\r\n        while (p_b!= nullptr){\r\n            p_b = p_b->next;\r\n            p_b2 = p_b2->next;\r\n        }\r\n\r\n        while (p_a2 &&p_b2){\r\n            if(p_a2==p_b2)\r\n                return p_a2;\r\n            p_a2 = p_a2->next;\r\n            p_b2 = p_b2->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1194079556","body":"```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        if(!head)return nullptr;\r\n\r\n        ListNode * final = new ListNode(0);\r\n        ListNode *slowPos = head;\r\n        ListNode *fastPos = head->next;\r\n        int t =1;\r\n        while (fastPos){\r\n            slowPos = slowPos->next;\r\n            t++;\r\n\r\n            fastPos = fastPos->next;\r\n            if(!fastPos)return nullptr;\r\n            fastPos = fastPos->next;\r\n            if(!fastPos)return nullptr;\r\n            //永远是整数时间节点追上为什么？\r\n            if(fastPos==slowPos){\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!fastPos)return nullptr;\r\n\r\n        ListNode *slowPos2 = head;\r\n        slowPos = slowPos->next;\r\n        while (true){\r\n            if(slowPos2==slowPos)return slowPos2;\r\n            slowPos2 = slowPos2->next;\r\n            slowPos = slowPos->next;\r\n        }\r\n\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195408726","body":"```c++\r\n\r\nstruct DListNode {\r\n    int key;\r\n    int val;\r\n    DListNode *next;\r\n    DListNode *pre;\r\n    DListNode(int key,int value) :key(key), val(value), next(NULL) ,pre(NULL){}\r\n  };\r\n\r\nclass LRUCache {\r\n\r\nprivate:\r\n    DListNode *head = new DListNode(-1,-1);\r\n\r\n    DListNode *tail = new DListNode(-1,-1);\r\n    int capacity = 0;\r\n\r\n    map<int,DListNode*> _map;\r\n\r\n\r\npublic:\r\n    LRUCache(int capacity):capacity(capacity) {\r\n        head->next = tail;\r\n        tail->pre = head;\r\n    }\r\n\r\n    int get(int key) {\r\n        if(_map.find(key)!=_map.end()){\r\n\r\n            DListNode * node = _map[key];\r\n            deleteNode(node);\r\n            addNode(node);\r\n            return node->val;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    void put(int key, int value) {\r\n\r\n      int a= get(key);\r\n      if(a!=-1){\r\n          _map[key]->val = value;\r\n      } else{\r\n\r\n          //要删除\r\n          if(_map.size()==capacity){\r\n              int oldKey = deleteNode();\r\n              _map.erase(oldKey);\r\n          }\r\n          auto newNode = new DListNode(key,value);\r\n          _map[key] = newNode;\r\n          addNode(newNode);\r\n      }\r\n\r\n    }\r\n\r\n    void deleteNode(DListNode * node){\r\n        DListNode * pre = node->pre;\r\n        DListNode * next = node->next;\r\n\r\n        node->next = nullptr;\r\n        node->pre = nullptr;\r\n\r\n        pre->next = next;\r\n        next->pre = pre;\r\n\r\n    }\r\n\r\n    int deleteNode(){\r\n\r\n        int key = head->next->key;\r\n\r\n        deleteNode(head->next);\r\n        return key;\r\n    }\r\n\r\n    void addNode(DListNode * node){\r\n        DListNode * tailPre = tail->pre;\r\n\r\n        tailPre->next = node;\r\n        node->pre = tailPre;\r\n        node->next = tail;\r\n        tail->pre = node;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196474626","body":"```c++\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n\n        if(!root)return 0;\n\n        return max(maxDepth(root->left)+1,maxDepth(root->right)+1);\n    }\n\n\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193367059","body":"```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        ListNode* inters = nullptr;\n        while(fast != nullptr && fast->next != nullptr ){\n            fast = fast->next->next;\n            slow = slow->next;\n            if(fast == slow){\n                inters = fast;\n                break;\n            }\n        }\n        \n        if(inters){\n            fast = head;\n            while(fast != slow){\n                fast = fast->next;\n                slow = slow->next;\n            }\n\n            return fast;\n        }\n        else{\n            return nullptr;\n        }\n        \n    }\n};\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowangcoding":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185112936","body":"## 思路\n    将数组从后往前加给k k每次取余作为结果 /10参与下一次运算\n## 复杂度\n    时间复杂度 O(max(n,m)) m n 为数组的长度 和k的长度 空间复杂度 O(n)\n## 代码\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> result = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            k += num[i];\n            result.addFirst(k % 10);\n            k /= 10;\n        }\n        while (k > 0) {\n            result.addFirst(k % 10);\n            k /= 10;\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186101492","body":"## 思路 \n     从前到后一次判断c和当前位置的距离 再从后往前判断c和当前位置的距离 取较小的值作为结果\n## 复杂度\n    时间复杂度O(n) 空间复杂度O(n)\n## 代码\n```java\n  public int[] shortestToChar(String s, char c) {\n        char[] ss= s.toCharArray();\n        int[] result = new int[ss.length];\n        int temp = 1-s.length();\n        for(int i=0;i<ss.length;i++){\n            if(c!=ss[i]){\n                result[i] = i-temp;\n            }else{\n                temp = i;\n            }\n        }\n        temp= 0;\n        for(int i=result.length-1;i>=0;i--){\n            if(c!=ss[i]){\n                result[i] = Math.min(Math.abs(temp-i),result[i]);\n            }else{\n                temp = i;\n            }\n        }\n        return result;\n    }\n  ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186520696","body":"## 思路\n\n    使用数组记录栈的数据 使用一个下标记录栈指针当前所在的位置 出入栈的时候处理这个栈指针\n\n## 复杂度\n\n    时间复杂度O(n) 空间复杂度O(n)\n\n## 代码\n\n```java\n    class CustomStack {\n    int[] stack;\n    int len;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        len=-1;\n    }\n\n    public void push(int x) {\n        if(len+1<stack.length){\n            len++;\n            stack[len] =x;\n\n        }\n    }\n\n    public int pop() {\n        if(len<0){\n            return -1;\n        }\n        len--;\n        return stack[len+1];\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k, len + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187600669","body":"## 思路\n\n    使用栈记录数据 左括号入栈 有括号出栈 数字则加倍\n\n## 复杂度\n\n    时间复杂度O(n) 空间复杂度O(n)\n\n## 代码\n\n```java\n class Solution {\n    public String decodeString(String s) {\n        Deque<Integer> stackNumber = new LinkedList<>();\n        Deque<String> stackString = new LinkedList<>();\n        StringBuilder stringBuilder = new StringBuilder();\n        int number = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '[') {\n                stackNumber.push(number);\n                number = 0;\n                stackString.push(stringBuilder.toString());\n                stringBuilder = new StringBuilder();\n            } else if (s.charAt(i) == ']') {\n                StringBuilder temp = new StringBuilder();\n                int curr_number = stackNumber.pop();\n                for (int j = 0; j < curr_number; j++) {\n                    temp.append(stringBuilder);\n                }\n                stringBuilder = temp.insert(0, stackString.pop());\n            } else if (s.charAt(i) > 47 && s.charAt(i) < 58) {\n                number = 10 * number + (s.charAt(i) - '0');\n            } else {\n                stringBuilder.append(s.charAt(i));\n            }\n        }\n        return stringBuilder.toString();\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189219881","body":"## 思路\n\n    使用双栈记录数据  压栈存数 翻转栈取数\n\n## 复杂度\n\n    时间复杂度O(1) 空间复杂度O(n)\n\n## 代码\n\n```java\nclass MyQueue {\n        //头栈\n        private Stack<Integer> headStack = new Stack<>();\n        //尾栈\n        private Stack<Integer> tailStack = new Stack<>();\n\n        public MyQueue() {\n        }\n\n        public void push(int x) {\n\n            headStack.push(x);\n        }\n\n        public int pop() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.pop();\n        }\n\n        public int peek() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.peek();\n        }\n\n        public boolean empty() {\n            return headStack.empty() && tailStack.empty();\n        }\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189967735","body":"## 思路\n\t单调栈 将数组首个入栈 对其后的数据 大于等于当前栈顶则入栈 小于则出栈一个并比较下一个栈顶 直到大于等于栈顶或者栈空再入栈\n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(n)\n## 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new LinkedList<>();\n        stack.push(arr[0]);\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] >= stack.peek()) {\n                stack.push(arr[i]);\n            } else {\n                Integer head = stack.pop();\n                while (stack.size() > 0 && arr[i] < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(head);\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191205570","body":"## 思路\n\t成环再移位\n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n## 代码\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head==null){\n            return head;\n        }\n        ListNode temp = new ListNode(0, head);\n        //链表长度\n        int len = 1;\n        //成环\n        while (head.next != null) {\n            head = head.next;\n            len++;\n        }\n        head.next = temp.next;\n        head = head.next;\n        //后移等于长度- 前移位和长度的余数\n        int number = len - k % len;\n        //移位\n        while (number > 0) {\n            number--;\n            temp = head;\n            head = head.next;\n        }\n        temp.next = null;\n        return head;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/22#issuecomment-1192261271","body":"\n## 思路\n\t两两交换位置 \n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n## 代码\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode ans = new ListNode(0, head);\n        ListNode temp = ans;\n        while (head != null && head.next != null) {\n\t\t\t//头指针指向2\n            ans.next = ans.next.next;\n            //1指向3\n\t\t\thead.next= head.next.next;\n            //2指向1\n\t\t\tans.next.next = head;\n            //头指针再后移一位\n\t\t\thead = head.next;\n            //临时指针后移两位\n\t\t\tans= ans.next.next;\n        }\n        return temp.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/23#issuecomment-1193141648","body":"## 思路\n\t快慢指针 快指针移动两次 慢指针移动一次 快指针移动到尾部的时候慢指针为中位数\n## 复杂度\n\t时间复杂度：O(nlogn)  空间复杂度：O(logn)\n## 代码\n\n```java\n\nclass Solution {\n      public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/24#issuecomment-1193285203","body":"## 思路\n\t快慢指针 快指针移动两次 慢指针移动一次  等快指针和慢指针相遇的时候有重合\n## 复杂度\n\t时间复杂度：O(nlogn)  空间复杂度：O(logn)\n## 代码\n\n```java\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode tailA = headA;\n        ListNode tailB = headB;\n        while(tailA!=tailB){\n            tailA = tailA==null?headB:tailA.next;\n            tailB = tailB == null? headA:tailB.next;\n        }\n        return tailA;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/25#issuecomment-1193499293","body":"## 思路\n\t快慢指针 存在环的时候使用临时指针从头开始和慢指针一直便利 相遇时为结果 \n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n## 代码\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode temp = null;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                temp = head;\n                break;\n            }\n        }\n        if (temp == null) {\n            return null;\n        }\n        while (temp != slow) {\n            temp = temp.next;\n            slow = slow.next;\n        }\n        return temp;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/27#issuecomment-1195189242","body":"\n## 思路\n\t仿LinkedHashMap的思路 map+双链表 \n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n## 代码\n\n```java\n class LRUCache {\n        Map<Integer, DoubleListNode> cache;\n        int max;\n        int len;\n        DoubleListNode head;\n        DoubleListNode tail;\n\n        public LRUCache(int capacity) {\n            cache = new HashMap<>(capacity);\n            max = capacity;\n            head = tail = null;\n            len = 0;\n        }\n\n        public int get(int key) {\n            DoubleListNode ans = cache.get(key);\n            if(ans == null){\n                return -1;\n            }\n            moveToLast(ans);\n            return ans.getValue();\n        }\n\n        public void put(int key, int value) {\n            DoubleListNode doubleListNode = cache.get(key);\n            if (doubleListNode == null) {\n                DoubleListNode temp = new DoubleListNode(key, value);\n                if (max == len) {\n                    DoubleListNode headTemp = head;\n                    if (head == tail) {\n                        head = tail = null;\n                    } else {\n                        head = head.getAfter();\n                        head.setBefore(null);\n                        headTemp.setAfter(null);\n                    }\n                    cache.remove(headTemp.getKey());\n                    len--;\n                }\n                cache.put(key, temp);\n                moveToLast(temp);\n                len++;\n            } else {\n                doubleListNode.setKeyValue(key, value);\n                moveToLast(doubleListNode);\n            }\n        }\n\n        private void moveToLast(DoubleListNode temp) {\n            //分四种情况\n            //新增的 前节点为尾节点 尾节点=这个节点\n            //头节点 下一个节点变为头节点 下一节点置空 前节点为尾节点 尾节点=这个节点\n            //尾节点 不动\n            //中间节点 记录前后节点 调转前后节点的指向 后节点置空 前节点为尾节点 尾节点=这个节点\n            if (temp.getBefore() == null) {\n                if (head == null) {\n                    head = tail = temp;\n                    return ;\n                }\n                if (temp.getAfter() != null) {\n                    //头节点\n                    head = head.getAfter();\n                    head.setBefore(null);\n                    temp.setAfter(null);\n                }\n                tail.setAfter(temp);\n                temp.setBefore(tail);\n                tail = temp;\n            }else {\n                if (temp.getAfter() != null) {\n                    //中间节点\n                    DoubleListNode after = temp.getAfter();\n                    DoubleListNode before = temp.getBefore();\n                    before.setAfter(after);\n                    after.setBefore(before);\n                    temp.setAfter(null);\n                    tail.setAfter(temp);\n                    temp.setBefore(tail);\n                    tail = temp;\n                }\n            }\n        }\n\n        class DoubleListNode {\n            private DoubleListNode before;\n            private Integer key;\n            private Integer value;\n            private DoubleListNode after;\n\n            public DoubleListNode(Integer key, Integer value) {\n                this.key = key;\n                this.value = value;\n                this.before = null;\n                this.after = null;\n            }\n\n            public DoubleListNode(DoubleListNode before, Integer key, Integer value, DoubleListNode after) {\n                this.key = key;\n                this.value = value;\n                this.before = before;\n                this.after = after;\n            }\n\n            public DoubleListNode getBefore() {\n                return before;\n            }\n\n            public DoubleListNode getAfter() {\n                return after;\n            }\n\n            public void setAfter(DoubleListNode after) {\n                this.after = after;\n            }\n\n            public void setBefore(DoubleListNode before) {\n                this.before = before;\n            }\n\n            public Integer getKey() {\n                return key;\n            }\n\n            public Integer getValue() {\n                return value;\n            }\n\n            public void setKeyValue(Integer key, Integer value) {\n                this.key = key;\n                this.value = value;\n            }\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/28#issuecomment-1196156669","body":"\n## 思路\n\t递归\n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n## 代码\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null){\n        \treturn 0;\n\t\t}\n        return Math.max(getDeep(root.left,0),getDeep(root.right,0))+1;\n    }\n\n    public int getDeep(TreeNode tree,int deep){\n        if(tree==null){\n            return deep;\n        }\n        return Math.max(getDeep(tree.left,deep),getDeep(tree.right,deep))+1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/29#issuecomment-1197535109","body":"\n## 思路\n\t递归\n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n## 代码\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null&&q==null){\n            return true;\n        }\n        if(p==null||q==null){\n            return false;\n        }\n        if(q.val!=p.val){\n            return false;\n        }\n        return isSameTree(p.left,q.left)&isSameTree(p.right,q.right);\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}