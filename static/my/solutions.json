{
  "azl397985856": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/32#issuecomment-835293321",
      "body": "2121212121"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "angusgenius": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835847052",
      "body": "### 思路\r\n- 模拟数字加法，利用 `K` 保存进位，先将对应位置的数字相加，再进行取余操作保留结果。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc addToArrayForm(A []int, K int) (ans []int) {\r\n    for i := len(A) - 1; i >= 0 || K > 0; i-- {\r\n        if i >= 0 {\r\n            K += A[i]\r\n        }\r\n        ans = append(ans, K%10)\r\n        K /= 10\r\n    }\r\n    reverse(ans)\r\n    return\r\n}\r\n\r\nfunc reverse(A []int) {\r\n    for i, n := 0, len(A); i < n/2; i++ {\r\n        A[i], A[n-1-i] = A[n-1-i], A[i]\r\n    }\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(max(n, logk))，其中 n 为数组的长度。\r\n- 空间复杂度：O(1)，常数级别。"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836995457",
      "body": "### 思路\r\n- 双向遍历，对于每个字符 `S[i]`，找出向左或者向右下一个字符 `C` 的距离，这两个值的较小值即最短距离。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n := len(s)\r\n    ans := make([]int, 0, n)\r\n    prev := math.MinInt32 / 2\r\n\r\n    for i := 0; i < n; i++ {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        ans = append(ans, i - prev)\r\n    }\r\n\r\n    prev = math.MaxInt32 / 2\r\n    for i := n-1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        ans[i] = min(ans[i], prev - i)\r\n    }\r\n\r\n    return ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n    if a > b {\r\n        return b\r\n    }\r\n    return a\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)，其中 `N` 是 S 的长度。\r\n- 空间复杂度：O(1)，常数级别。"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836995457",
      "body": "### 思路\r\n- 双向遍历，对于每个字符 `S[i]`，找出向左或者向右下一个字符 `C` 的距离，这两个值的较小值即最短距离。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n := len(s)\r\n    ans := make([]int, 0, n)\r\n    prev := math.MinInt32 / 2\r\n\r\n    for i := 0; i < n; i++ {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        ans = append(ans, i - prev)\r\n    }\r\n\r\n    prev = math.MaxInt32 / 2\r\n    for i := n-1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        ans[i] = min(ans[i], prev - i)\r\n    }\r\n\r\n    return ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n    if a > b {\r\n        return b\r\n    }\r\n    return a\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)，其中 `N` 是 S 的长度。\r\n- 空间复杂度：O(1)，常数级别。"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "devil-lin": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835849107",
      "body": "\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n\r\n        int n = num.size();\r\n        for(int i = n - 1; i >= 0 || k; i --)\r\n        {\r\n            if(i >= 0)\r\n                k += num[i];\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838552141",
      "body": "\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n   vector<int> shortestToChar(string S, char C) {\r\n       vector<int> distance(S.size(), 0);\r\n       int prev = INT_MIN/2;\r\n       for(int i = 0; i < S.size(); i ++){\r\n           if(S[i] == C) prev = i;\r\n           distance[i] = i - prev;\r\n       }\r\n       prev = INT_MAX/2;\r\n       for(int i = S.size() - 1; i >= 0; i --){\r\n           if(S[i] == C) prev = i;\r\n           distance[i] = min(distance[i], prev - i);\r\n       }\r\n       return distance;\r\n   }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838552141",
      "body": "\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n   vector<int> shortestToChar(string S, char C) {\r\n       vector<int> distance(S.size(), 0);\r\n       int prev = INT_MIN/2;\r\n       for(int i = 0; i < S.size(); i ++){\r\n           if(S[i] == C) prev = i;\r\n           distance[i] = i - prev;\r\n       }\r\n       prev = INT_MAX/2;\r\n       for(int i = S.size() - 1; i >= 0; i --){\r\n           if(S[i] == C) prev = i;\r\n           distance[i] = min(distance[i], prev - i);\r\n       }\r\n       return distance;\r\n   }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "zliu1413": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835862900",
      "body": "思路：add K to each digit of the num. \r\n语言：python\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        i = len(num)-1\r\n        while(i>=0 or k>0):\r\n            if i>=0:\r\n                k += num[i]\r\n            res.append(k%10)\r\n            k = k//10\r\n            i -= 1\r\n        return res[::-1]\r\n\r\n```\r\n\r\n复杂度：\r\n时间：O(max(n,logK)), logK is the how many times that K can be divided by 10 until residual is single digit\r\n空间：O(1）\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837327271",
      "body": "解题思路：\r\n双向遍历。两次遍历的每个位置比较大小。\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \r\n        \"\"\"\r\n        #first attemp\r\n        cLocs = []\r\n        for idx,elem in enumerate(s):\r\n            if elem == c: \r\n                cLocs.append(idx)\r\n        \r\n        res = []\r\n        for idx, elem in enumerate(s):\r\n            res.append(min(abs(mark - idx) for mark in cLocs))\r\n        \r\n        return res\r\n        \"\"\"\r\n        # second\r\n        ref = float(inf)\r\n        distanceList = []\r\n        for i,val in enumerate(s):\r\n            if val==c: ref = i\r\n            distanceList.append(abs(ref-i))\r\n        \r\n        ref = float(inf)\r\n        for i in range(len(s)-1,-1,-1):\r\n            val = s[i]\r\n            if val==c: ref = i\r\n            distanceList[i] = min(distanceList[i],abs(ref-i))\r\n        \r\n        return distanceList\r\n\r\n```\r\n复杂度：\r\n时间：O(n)\r\n空间：O(n)\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837327271",
      "body": "解题思路：\r\n双向遍历。两次遍历的每个位置比较大小。\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \r\n        \"\"\"\r\n        #first attemp\r\n        cLocs = []\r\n        for idx,elem in enumerate(s):\r\n            if elem == c: \r\n                cLocs.append(idx)\r\n        \r\n        res = []\r\n        for idx, elem in enumerate(s):\r\n            res.append(min(abs(mark - idx) for mark in cLocs))\r\n        \r\n        return res\r\n        \"\"\"\r\n        # second\r\n        ref = float(inf)\r\n        distanceList = []\r\n        for i,val in enumerate(s):\r\n            if val==c: ref = i\r\n            distanceList.append(abs(ref-i))\r\n        \r\n        ref = float(inf)\r\n        for i in range(len(s)-1,-1,-1):\r\n            val = s[i]\r\n            if val==c: ref = i\r\n            distanceList[i] = min(distanceList[i],abs(ref-i))\r\n        \r\n        return distanceList\r\n\r\n```\r\n复杂度：\r\n时间：O(n)\r\n空间：O(n)\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "joe-the-plumber": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835868625",
      "body": "思路：using string to convert back and forth\r\n语言：python\r\n复杂度：\r\n时间：O(n)\r\n空间：O(n）\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        \r\n        number_int =  functools.reduce(lambda a,b : str(a)+str(b),num)\r\n        number_int = int(number_int) + k\r\n        \r\n        result_int_array = []\r\n        for i in str(number_int):\r\n            result_int_array.append(int(i))\r\n            \r\n        return result_int_array\r\n```\r\n\r\n            \r\n        "
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837583648",
      "body": "同上： 先将所有目标字符位置找出，再遍历整个列表，计算与前后目标字符的距离绝对值，取值小的。\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        #1. find all currence of c\r\n        position_array = []        \r\n        for i, v in enumerate(s):\r\n            if v == c:\r\n                position_array.append(i)\r\n       \r\n        #duplicate the last element, we can access the right boundary more easily\r\n        position_array.append(position_array[-1])  \r\n                \r\n        #initilize the return value arrary\r\n        shortest_distance_array = [0 for _ in range(len(s))]\r\n        j1 = 0\r\n            \r\n        for i, v in enumerate(s):\r\n            shortest_distance_array[i] = min( abs( i-position_array[j1] )\r\n                                             , abs(i-position_array[j1+1] ) \r\n                                            )\r\n            #if the moving left_p(j1), right_p(j1+1) pair need to be updated    \r\n            if i==position_array[j1+1]:\r\n                # the right_p should not move out of boundary\r\n                if j1+1+1<len(position_array) :\r\n                    j1 += 1\r\n\r\n        return shortest_distance_array\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837583648",
      "body": "同上： 先将所有目标字符位置找出，再遍历整个列表，计算与前后目标字符的距离绝对值，取值小的。\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        #1. find all currence of c\r\n        position_array = []        \r\n        for i, v in enumerate(s):\r\n            if v == c:\r\n                position_array.append(i)\r\n       \r\n        #duplicate the last element, we can access the right boundary more easily\r\n        position_array.append(position_array[-1])  \r\n                \r\n        #initilize the return value arrary\r\n        shortest_distance_array = [0 for _ in range(len(s))]\r\n        j1 = 0\r\n            \r\n        for i, v in enumerate(s):\r\n            shortest_distance_array[i] = min( abs( i-position_array[j1] )\r\n                                             , abs(i-position_array[j1+1] ) \r\n                                            )\r\n            #if the moving left_p(j1), right_p(j1+1) pair need to be updated    \r\n            if i==position_array[j1+1]:\r\n                # the right_p should not move out of boundary\r\n                if j1+1+1<len(position_array) :\r\n                    j1 += 1\r\n\r\n        return shortest_distance_array\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Critsu": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835891780",
      "body": "思路：add K to each digit\r\n语言：java\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n\r\n        for(int i=num.length-1; i>=0; i--){\r\n \r\n            int temp = num[i] + k;\r\n            int temp1 = temp%10;\r\n            ans.add(0, temp1);\r\n            k= temp/10;\r\n            \r\n        }\r\n\r\n        while(k>0){\r\n            ans.add(0, k%10);\r\n            k/=10;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837609304",
      "body": "```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int prev = -1;\r\n        \r\n        for(int i=0; i<res.length; i++){\r\n            if(s.charAt(i) == c){\r\n                res[i] = 0;\r\n                prev = i;\r\n            }else if(prev>-1){\r\n                res[i] = i-prev;\r\n            }else {\r\n                res[i] = Integer.MAX_VALUE;\r\n            }\r\n        }\r\n        \r\n        prev=-1;\r\n        \r\n        for(int i=res.length-1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }else if(prev>-1){\r\n                res[i] = Math.min((prev-i), res[i]);\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837609304",
      "body": "```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int prev = -1;\r\n        \r\n        for(int i=0; i<res.length; i++){\r\n            if(s.charAt(i) == c){\r\n                res[i] = 0;\r\n                prev = i;\r\n            }else if(prev>-1){\r\n                res[i] = i-prev;\r\n            }else {\r\n                res[i] = Integer.MAX_VALUE;\r\n            }\r\n        }\r\n        \r\n        prev=-1;\r\n        \r\n        for(int i=res.length-1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }else if(prev>-1){\r\n                res[i] = Math.min((prev-i), res[i]);\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "taojin1992": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835892157",
      "body": "# Logic:\r\n```\r\nGo backward from the end of num (the least significant digit) \r\nwhile num still has unprocessed digits or k still has unprocessed digits:\r\n    get k's lowest digit \r\n    update k (k = 0 would be fine)\r\n    \r\n    # add up the current sum for the current digit\r\n    if (no digit to use in num): no need to add from num \r\n    else: add up the current sum for the current digit, decrement the index in num\r\n    \r\n    get carry\r\n    insert to the sum list\r\n    \r\nif (carry == 1): insert at sum list's head\r\n```\r\n# Caveats:\r\nStart from the least significant digit in num (go backward), consider carry, what if k's len is longer/shorter, use linkedlist.addFirst()\r\n\r\n[0]\r\n23\r\n\r\n# Complexity:\r\nTime: O(max(num.length, num of digits in k))\r\n\r\nSpace: O(max(num.length, num of digits in k)) if we consider the output list; otherwise O(1)\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> sum = new LinkedList<>();\r\n        int index = num.length - 1;\r\n        int carry = 0;\r\n        while (index >= 0 || k != 0) {\r\n            int curDigit = k % 10;\r\n            k = k / 10;\r\n            \r\n            if (index == -1) {\r\n               curDigit += carry; \r\n            } else {\r\n                curDigit += num[index--] + carry;\r\n            }\r\n            carry = curDigit / 10;\r\n            sum.addFirst(curDigit % 10);\r\n        }\r\n        if (carry == 1) {\r\n            sum.addFirst(1);\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838725255",
      "body": "# Logic:\r\n```\r\ntraverse from the left to find matchPos (the closest match on the current index's left)\r\n- update for each index in s\r\n\r\ntraverse from the right (the closest match on the current index's right)\r\nno need to update the elements after the matchPos, because they have no match on the right\r\n- update for each index in s\r\n```\r\n\r\ns = \"loveleetcode\", c = \"e\"\r\nIt is guaranteed that c occurs at least once in s.\r\n\r\n\"aaba\"\r\n\"b\"\r\n\r\n# Complexity:\r\nTime: O(2n) -> O(n), n is the length of S\r\nSpace: O(1) - if we do not consider the output array\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] dist = new int[s.length()];\r\n        int matchPos = -s.length(); // the closest c position\r\n        // traverse from the left to find matchPos (the closest match on the current index's left)\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) {\r\n                matchPos = i;\r\n            }\r\n            dist[i] = i - matchPos;\r\n        }\r\n        // traverse from the right (the closest match on the current index's right)\r\n        // no need to update the elements after the matchPos, because they have no match on the right\r\n        for (int i = matchPos - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                matchPos = i;\r\n            }\r\n            dist[i] = Math.min(matchPos - i, dist[i]);\r\n        }\r\n        return dist;\r\n    }\r\n}\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838725255",
      "body": "# Logic:\r\n```\r\ntraverse from the left to find matchPos (the closest match on the current index's left)\r\n- update for each index in s\r\n\r\ntraverse from the right (the closest match on the current index's right)\r\nno need to update the elements after the matchPos, because they have no match on the right\r\n- update for each index in s\r\n```\r\n\r\ns = \"loveleetcode\", c = \"e\"\r\nIt is guaranteed that c occurs at least once in s.\r\n\r\n\"aaba\"\r\n\"b\"\r\n\r\n# Complexity:\r\nTime: O(2n) -> O(n), n is the length of S\r\nSpace: O(1) - if we do not consider the output array\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] dist = new int[s.length()];\r\n        int matchPos = -s.length(); // the closest c position\r\n        // traverse from the left to find matchPos (the closest match on the current index's left)\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) {\r\n                matchPos = i;\r\n            }\r\n            dist[i] = i - matchPos;\r\n        }\r\n        // traverse from the right (the closest match on the current index's right)\r\n        // no need to update the elements after the matchPos, because they have no match on the right\r\n        for (int i = matchPos - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                matchPos = i;\r\n            }\r\n            dist[i] = Math.min(matchPos - i, dist[i]);\r\n        }\r\n        return dist;\r\n    }\r\n}\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "yanjyumoso": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835903934",
      "body": "### 思路\r\n\r\n1. Convert the array to string\r\n2. convert the string to integer for addition. \r\n3. Convert integer to array.\r\n\r\n### 代码\r\nPython\r\n\r\n\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        a = \"\"\r\n        for i in num:\r\n            a+=str(i)\r\n        x = int(a)+k\r\n        newList = [int(i) for i in str(x)]\r\n        return newList \r\n\r\n```\r\n\r\n**复杂度分析**\r\n- Time：O(n)\r\n- Space：O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "lilyzhaoyilu": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835920262",
      "body": "## LC 989. Add to Array-Form of Integer\r\n\r\n### 思路\r\n\r\n循环处理 k 和 num  \r\n让 k 的每一位和 num 对应的 digit 相加  \r\n并且记录是否需要进位  \r\n需要注意一些特殊 case 的处理\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  let i = num.length - 1\r\n  let carry = false;\r\n\r\n  while(k > 0 || i >= 0){\r\n    let curDigit = k % 10\r\n    k = Math.floor(k / 10)\r\n\r\n    //此处注意可能有i <0 的情况，所以 || 0\r\n    //corner case: [0] 233\r\n    let newDigit = curDigit + (num[i]||0)\r\n\r\n    //如果需要进位\r\n    if(carry){\r\n      newDigit++\r\n      carry = false;\r\n    }\r\n\r\n    //判断是否需要进位\r\n    if(newDigit >=10){\r\n      carry = true;\r\n      newDigit = newDigit % 10\r\n    }\r\n\r\n    //同样需要处理 i< 0 的情况\r\n    i >= 0 ? num[i] = newDigit : num.unshift(newDigit)\r\n    i--\r\n  }\r\n\r\n  //最后看看是否需要进位\r\n  //corner case: [9,9] 1\r\n  if(carry) num.unshift(1)\r\n\r\n  return num;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(Math.max(M+N)) 两个长度中的最大值 其实就是 O(N) </br>\r\n空间复杂度：O(1) 只保存了常量\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836997697",
      "body": "## LC 821. Shortest Distance to a Character\r\n\r\n- Shortest Distance to a Character\r\n  - [遍历两次](#思路-遍历两次)\r\n  - [暴力](#思路-暴力)\r\n  - [双指针](#思路-双指针)\r\n  - [窗口](#思路-窗口)\r\n\r\n### 思路 遍历两次\r\n\r\n漾宝真棒！么么哒  \r\n遍历两次，一次从左到右，另一次反方向  \r\n遍历的时候分别记录从左到右和从右到左的该 s[i]对 c 的距离\r\n并且保留较小的那个\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  //greedy\r\n  const res = new Array(s.length).fill(Infinity)\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] === c) res[i] = 0;\r\n    //处理一下i == 0 的情况，不然的话res[i -1] => NaN\r\n    else res[i] = i == 0 ? Infinity : res[i - 1] + 1\r\n  }\r\n\r\n\r\n  for(let i = s.length - 1; i >= 0; i--){\r\n    //res[i + 1] 是这个数组中右边的那一位\r\n    //如果res[i] == Infinity 就说明这个i的左边没有e\r\n    //或者 res[i + 1] + 1 < res[i]说明这个res[i]离右边的更近\r\n    if(res[i] == Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 暴力\r\n\r\n暴力  \r\n先遍历数组，求出所有 c 的 index  \r\n然后再遍历数组，遇到跟 c 不同的时候，遍历 targetIndex 里的数组，求最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  //brutal force\r\n  const res = [];\r\n  const targetIndex = [];\r\n  //iterate through s to get the indexs of c\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] == c) targetIndex.push(i)\r\n  }\r\n  //iterate through s to see wether a character is c\r\n  //if it is c, then the corresponding output should be 0\r\n  //if it is not c, then iterate through the targetIndex array\r\n  //    find the min of current char's index and all the target's index\r\n  //英文写真长啊下次还是打中文吧...\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] != c){\r\n      let temp = Infinity;\r\n      for(let t = 0; t < targetIndex.length; t++){\r\n          temp = Math.min(temp, Math.abs(i - targetIndex[t]))\r\n      }\r\n      res.push(temp)\r\n    }else{\r\n      res.push(0)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$O(N * M)$ M 是 c 的在 s 中的次数</br>\r\n空间复杂度：O(M) M 为 s 中 c 的个数\r\n\r\n### 思路 双指针\r\n\r\n双指针  \r\n在遍历 s 中遇到非 c 的时候，  \r\n派两个指针去寻找左边和右边的 c，并且计算最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  //two pointers\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for(let i = 0; i < s.length; i++){\r\n\r\n    if(s[i] == c){\r\n      res[i] = 0\r\n    }else{\r\n      let right = i + 1;\r\n      let left = i - 1\r\n\r\n      while(s[left] != c && left > 0){\r\n        left--\r\n      }\r\n\r\n      while(s[right] != c && right < s.length-1){\r\n        right++\r\n      }\r\n\r\n      //这里进行了边界处理，即处理了left/right越界的情况\r\n      //也处理了如果left/right 只是单纯的到边界停下了的情况\r\n      //比如s='love' 在s[i] = o i=1的时候，left就会是0\r\n      let leftSideC = s[left] != c  ? Infinity : i - left;\r\n      let rightSideC = s[right] != c ? Infinity : right - i\r\n      // console.log(i, s[i], left, leftSideC, right, rightSideC)\r\n      res[i] = Math.min(rightSideC, leftSideC)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$O(N^2)$ </br>\r\n空间复杂度：O(1) 只保存了常量\r\n\r\n### 思路 窗口\r\n\r\n\r\n我要请漾宝吃饭！   \r\n滑动的~？窗口  \r\n制造一个窗口，让他的左右两端分别为 c 或者 s 的边界  \r\n当为 s 的边界的时候，让窗口的值等于 Infinity  \r\n因为必然有 c，所以只要处理 i = 0 的时候就好了\r\n然后计算每个 s 到窗口两边的值，取最小\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  //sliding window\r\n\r\n  let left = s[0] === c ? 0 : Infinity;\r\n  //从index = 1 的位置开始寻找c\r\n  let right = s.indexOf(c, 1);\r\n\r\n  const res = new Array(s.length);\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    res[i] = Math.min(Math.abs(i - left), Math.abs(i - right))\r\n    //变到下一个窗口\r\n    if(i === right){\r\n      left = right;\r\n      right = s.indexOf(c, left + 1)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N · (NK)) 其中 n 是 s 的长度，indexof 的时间复杂度是 O(NK),其中 k 是每次找到的目标的长度 </br>\r\n空间复杂度：O(1)\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836997697",
      "body": "## LC 821. Shortest Distance to a Character\r\n\r\n- Shortest Distance to a Character\r\n  - [遍历两次](#思路-遍历两次)\r\n  - [暴力](#思路-暴力)\r\n  - [双指针](#思路-双指针)\r\n  - [窗口](#思路-窗口)\r\n\r\n### 思路 遍历两次\r\n\r\n漾宝真棒！么么哒  \r\n遍历两次，一次从左到右，另一次反方向  \r\n遍历的时候分别记录从左到右和从右到左的该 s[i]对 c 的距离\r\n并且保留较小的那个\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  //greedy\r\n  const res = new Array(s.length).fill(Infinity)\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] === c) res[i] = 0;\r\n    //处理一下i == 0 的情况，不然的话res[i -1] => NaN\r\n    else res[i] = i == 0 ? Infinity : res[i - 1] + 1\r\n  }\r\n\r\n\r\n  for(let i = s.length - 1; i >= 0; i--){\r\n    //res[i + 1] 是这个数组中右边的那一位\r\n    //如果res[i] == Infinity 就说明这个i的左边没有e\r\n    //或者 res[i + 1] + 1 < res[i]说明这个res[i]离右边的更近\r\n    if(res[i] == Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 暴力\r\n\r\n暴力  \r\n先遍历数组，求出所有 c 的 index  \r\n然后再遍历数组，遇到跟 c 不同的时候，遍历 targetIndex 里的数组，求最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  //brutal force\r\n  const res = [];\r\n  const targetIndex = [];\r\n  //iterate through s to get the indexs of c\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] == c) targetIndex.push(i)\r\n  }\r\n  //iterate through s to see wether a character is c\r\n  //if it is c, then the corresponding output should be 0\r\n  //if it is not c, then iterate through the targetIndex array\r\n  //    find the min of current char's index and all the target's index\r\n  //英文写真长啊下次还是打中文吧...\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] != c){\r\n      let temp = Infinity;\r\n      for(let t = 0; t < targetIndex.length; t++){\r\n          temp = Math.min(temp, Math.abs(i - targetIndex[t]))\r\n      }\r\n      res.push(temp)\r\n    }else{\r\n      res.push(0)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$O(N * M)$ M 是 c 的在 s 中的次数</br>\r\n空间复杂度：O(M) M 为 s 中 c 的个数\r\n\r\n### 思路 双指针\r\n\r\n双指针  \r\n在遍历 s 中遇到非 c 的时候，  \r\n派两个指针去寻找左边和右边的 c，并且计算最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  //two pointers\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for(let i = 0; i < s.length; i++){\r\n\r\n    if(s[i] == c){\r\n      res[i] = 0\r\n    }else{\r\n      let right = i + 1;\r\n      let left = i - 1\r\n\r\n      while(s[left] != c && left > 0){\r\n        left--\r\n      }\r\n\r\n      while(s[right] != c && right < s.length-1){\r\n        right++\r\n      }\r\n\r\n      //这里进行了边界处理，即处理了left/right越界的情况\r\n      //也处理了如果left/right 只是单纯的到边界停下了的情况\r\n      //比如s='love' 在s[i] = o i=1的时候，left就会是0\r\n      let leftSideC = s[left] != c  ? Infinity : i - left;\r\n      let rightSideC = s[right] != c ? Infinity : right - i\r\n      // console.log(i, s[i], left, leftSideC, right, rightSideC)\r\n      res[i] = Math.min(rightSideC, leftSideC)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$O(N^2)$ </br>\r\n空间复杂度：O(1) 只保存了常量\r\n\r\n### 思路 窗口\r\n\r\n\r\n我要请漾宝吃饭！   \r\n滑动的~？窗口  \r\n制造一个窗口，让他的左右两端分别为 c 或者 s 的边界  \r\n当为 s 的边界的时候，让窗口的值等于 Infinity  \r\n因为必然有 c，所以只要处理 i = 0 的时候就好了\r\n然后计算每个 s 到窗口两边的值，取最小\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  //sliding window\r\n\r\n  let left = s[0] === c ? 0 : Infinity;\r\n  //从index = 1 的位置开始寻找c\r\n  let right = s.indexOf(c, 1);\r\n\r\n  const res = new Array(s.length);\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    res[i] = Math.min(Math.abs(i - left), Math.abs(i - right))\r\n    //变到下一个窗口\r\n    if(i === right){\r\n      left = right;\r\n      right = s.indexOf(c, left + 1)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N · (NK)) 其中 n 是 s 的长度，indexof 的时间复杂度是 O(NK),其中 k 是每次找到的目标的长度 </br>\r\n空间复杂度：O(1)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Size-of": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835929595",
      "body": "```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  const res = []\r\n  let i = num.length - 1\r\n  let carry = 0\r\n  while (i >= 0 || k > 0 || carry > 0) {\r\n    let cur = (num[i] || 0) + k % 10 + carry\r\n    res.push(cur % 10)\r\n    carry = cur / 10 | 0\r\n    i--\r\n    k = k / 10 | 0\r\n  }\r\n  return res.reverse()\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(n, logk))$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837506159",
      "body": "## 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for (let i = 0; i < s.length; i++) {\r\n    res[i] = s.substr(i, 1) === c ? 0 : (res[i - 1] != undefined ? res[i - 1] : Infinity) + 1\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    let prev = res[i + 1] !== undefined ? res[i + 1] : Infinity\r\n    res[i] = prev + 1 < res[i] ? prev + 1 : res[i]\r\n  }\r\n\r\n  return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$, N为s的长度\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837506159",
      "body": "## 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for (let i = 0; i < s.length; i++) {\r\n    res[i] = s.substr(i, 1) === c ? 0 : (res[i - 1] != undefined ? res[i - 1] : Infinity) + 1\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    let prev = res[i + 1] !== undefined ? res[i + 1] : Infinity\r\n    res[i] = prev + 1 < res[i] ? prev + 1 : res[i]\r\n  }\r\n\r\n  return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$, N为s的长度\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Talent-Rain": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835930598",
      "body": "\r\n## [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/bao-li-xiang-jia-by-jzsq_lyx-pon7/)\r\n\r\n### 分析\r\n1. 给定的 k 值是数字，不好按位来和数组中的值进行比对，而这里最后返回的是一个数组，所以先把数组 k 转成字符数组 -- kArr\r\n2. 根据数组长度，从地位到高位进行相加，用遍历 addOne 表示是否进位\r\n3. 每一次相加都需要判断是否超过 9, 超出时返回余数，并更新遍历 addOne\r\n4. 由于返回的 num，所以先用 ALen 遍历，遍历结束后，根据 KLen 的值判断是否还有 kArr 的值，同时还得注意次数 addOne 是否需要进位\r\n5. 时间复杂度：遍历 k 是 O(k) -- 其中 k 是 KLen，然后是遍历两个数组，所以最后 O(N),其中 N 是 Math.max(KLen,ALen)\r\n6. 空间复杂度: O(K)  -- 其中 k 是 KLen\r\n\r\n```javascript\r\n// 989. 数组形式的整数加法\r\n\r\n/**\r\n * @分析\r\n * 1. 由于最后返回的是数组形式，所以将 k 转成单个字符加到数组中比较合适\r\n * 2. 主要考察字符串切分字符，字符与数字相加转换问题\r\n */\r\n var addToArrayForm = function (num, k) {\r\n\r\n    let addOne = false // 进位\r\n    // 转成 number[]\r\n    const kArr = String(k).split('').map(str => Number(str))\r\n    let ALen = num.length, KLen = kArr.length \r\n    while (ALen--) {\r\n        let sum = num[ALen]\r\n        if (KLen) {\r\n            KLen--\r\n            sum += kArr[KLen]\r\n        }\r\n        if (addOne) {\r\n            sum++\r\n            addOne = false\r\n        }\r\n        if (sum >= 10) {\r\n            num[ALen] = sum % 10\r\n            addOne = true\r\n        } else {\r\n            num[ALen] = sum\r\n        }\r\n    }\r\n    while (KLen--) {\r\n        // 还有的值全部加到后面\r\n        let sum = kArr[KLen]\r\n        if (addOne) {\r\n            sum++\r\n            addOne = false\r\n        } \r\n        if (sum >= 10) {\r\n            num.unshift(sum % 10)\r\n            addOne = true\r\n        } else {\r\n            num.unshift(sum)\r\n        }\r\n    }\r\n    if (addOne) {\r\n        num.unshift(1)\r\n    }\r\n    return num\r\n};\r\n\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837524070",
      "body": "[ 821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/bao-li-mei-ju-by-jzsq_lyx-ya8d/)\r\n### 直接暴力解法\r\n1. 将所有 c 的下标标记出来，用 temp 数组保存\r\n2. 遍历第二次的时候根据 temp 的值作为节点，计算对应的 abs 值\r\n3. 需要特别注意的是第一个节点和最后一个节点\r\n4. 时间复杂度：遍历了两次 s -- O(N) 其中 N 是 s 的长度\r\n5. 空间复杂度： 存储的是 c 出现的次数 -- O(C) -- 其中 C 的值为 [1,N]\r\n```javascript\r\n// 821. 字符的最短距离\r\n\r\n/**\r\n * @分析 -- 暴力解法\r\n */\r\n var shortestToChar = function (s, c) {\r\n    const len = s.length\r\n    //当结果为 c 的时候，就是 0，默认先全是 0\r\n    const ret = new Array(len).fill(0)\r\n    const temp = []\r\n    // 遍历第一次，找出所有 c 对应的 index\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) temp.push(i)\r\n    }\r\n\r\n    let index = 0\r\n    // 再遍历一次，完成所有值\r\n    for (let i = 0; i < temp.length; i++) {\r\n        const right = temp[i]\r\n        if (i === 0) {\r\n            while (index < right) {\r\n                ret[index] = right - index\r\n                index++\r\n            }\r\n        } else {\r\n            const left = temp[i - 1]\r\n            while (index > left && index < right) {\r\n                ret[index] = Math.min(right - index, index - left)\r\n                index++\r\n            }\r\n        }\r\n        // 因为相同的节点直接就是 0，所以直接跳过了\r\n        index++\r\n    }\r\n    // 走完了，如果index<len,做最后一次遍历\r\n    while (index < len) {\r\n        ret[index] = index - temp[temp.length - 1]\r\n        index++\r\n    }\r\n    return ret\r\n};\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837524070",
      "body": "[ 821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/bao-li-mei-ju-by-jzsq_lyx-ya8d/)\r\n### 直接暴力解法\r\n1. 将所有 c 的下标标记出来，用 temp 数组保存\r\n2. 遍历第二次的时候根据 temp 的值作为节点，计算对应的 abs 值\r\n3. 需要特别注意的是第一个节点和最后一个节点\r\n4. 时间复杂度：遍历了两次 s -- O(N) 其中 N 是 s 的长度\r\n5. 空间复杂度： 存储的是 c 出现的次数 -- O(C) -- 其中 C 的值为 [1,N]\r\n```javascript\r\n// 821. 字符的最短距离\r\n\r\n/**\r\n * @分析 -- 暴力解法\r\n */\r\n var shortestToChar = function (s, c) {\r\n    const len = s.length\r\n    //当结果为 c 的时候，就是 0，默认先全是 0\r\n    const ret = new Array(len).fill(0)\r\n    const temp = []\r\n    // 遍历第一次，找出所有 c 对应的 index\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) temp.push(i)\r\n    }\r\n\r\n    let index = 0\r\n    // 再遍历一次，完成所有值\r\n    for (let i = 0; i < temp.length; i++) {\r\n        const right = temp[i]\r\n        if (i === 0) {\r\n            while (index < right) {\r\n                ret[index] = right - index\r\n                index++\r\n            }\r\n        } else {\r\n            const left = temp[i - 1]\r\n            while (index > left && index < right) {\r\n                ret[index] = Math.min(right - index, index - left)\r\n                index++\r\n            }\r\n        }\r\n        // 因为相同的节点直接就是 0，所以直接跳过了\r\n        index++\r\n    }\r\n    // 走完了，如果index<len,做最后一次遍历\r\n    while (index < len) {\r\n        ret[index] = index - temp[temp.length - 1]\r\n        index++\r\n    }\r\n    return ret\r\n};\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "kofzhang": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835972664",
      "body": "### 思路\r\n1.先转成整数\r\n2.相加\r\n3.再转成数组\r\n### 代码（Python3）\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        inta = 0\r\n        for i in A:\r\n            inta = inta*10 + i\r\n        inta = inta+K\r\n        res = []\r\n        for i in str(inta):\r\n            res.append(int(i))\r\n        return res\r\n        \r\n```\r\n### 复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837578403",
      "body": "### 思路\r\n解法1：先将所有目标字符位置找出，再遍历整个列表，计算与前后目标字符的距离绝对值，取值小的。\r\n解法2：正反遍历，取小值\r\n### 代码（Python3）\r\n#### 解法1：\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                l.append(i)\r\n        k = 0\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=len(l)-1 and abs(i-l[k])>abs(i-l[k+1]):\r\n                k += 1\r\n            res.append(abs(i-l[k]))\r\n        return res\r\n```\r\n#### 解法2：\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        t = len(s)\r\n        for i in s:\r\n            t=0 if i==c else t+1\r\n            res.append(t)\r\n        for idx,i in enumerate(s[::-1]):\r\n            t = 0 if i==c else t+1\r\n            res[-(idx+1)] = min(t,res[-(idx+1)])\r\n        return res\r\n        \r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837578403",
      "body": "### 思路\r\n解法1：先将所有目标字符位置找出，再遍历整个列表，计算与前后目标字符的距离绝对值，取值小的。\r\n解法2：正反遍历，取小值\r\n### 代码（Python3）\r\n#### 解法1：\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                l.append(i)\r\n        k = 0\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=len(l)-1 and abs(i-l[k])>abs(i-l[k+1]):\r\n                k += 1\r\n            res.append(abs(i-l[k]))\r\n        return res\r\n```\r\n#### 解法2：\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        t = len(s)\r\n        for i in s:\r\n            t=0 if i==c else t+1\r\n            res.append(t)\r\n        for idx,i in enumerate(s[::-1]):\r\n            t = 0 if i==c else t+1\r\n            res[-(idx+1)] = min(t,res[-(idx+1)])\r\n        return res\r\n        \r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "pkuphy": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835973571",
      "body": "```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = int(''.join(map(str, num))) + k\r\n        sum = map(int, str(sum))\r\n        return sum\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838010994",
      "body": "思路：单调栈\r\n\r\n代码：\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -1e4\r\n        length = len(S)\r\n        result = []\r\n\r\n        for i in range(length):\r\n            if S[i] == C: pre = i\r\n            result.append(i - pre)\r\n        pre = 20000\r\n        for i in range(length - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            result[i] = min(result[i], pre - i)\r\n        return result\r\n```\r\n\r\n复杂度：\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838010994",
      "body": "思路：单调栈\r\n\r\n代码：\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -1e4\r\n        length = len(S)\r\n        result = []\r\n\r\n        for i in range(length):\r\n            if S[i] == C: pre = i\r\n            result.append(i - pre)\r\n        pre = 20000\r\n        for i in range(length - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            result[i] = min(result[i], pre - i)\r\n        return result\r\n```\r\n\r\n复杂度：\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "tongxw": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835995408",
      "body": "### 思路\r\n\r\nwhile num[i]存在 或者 k不为0:\r\n    当前位sum = 进位 + nums[i](如果存在) + k mod 10 (如果k不为0)；\r\n    倒序遍历num，同时k = k /10;\r\n    进位 carry = sum / 10;\r\n    当前位 digit = sum mod 10;\r\n    输出数组记录digit;\r\n如果最后一位有进位，添加到输出数组中;\r\n倒序返回输出数组；\r\n\r\n\r\n### 代码\r\n```java\r\n/*\r\n * @lc app=leetcode id=989 lang=java\r\n *\r\n * [989] Add to Array-Form of Integer\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int carry = 0;\r\n        ArrayList<Integer> res = new ArrayList<>();\r\n        while (i>=0 || k != 0) {\r\n            int sum = carry;\r\n            if (i >= 0) {\r\n                sum += num[i];\r\n                i--;\r\n            }\r\n            if (k != 0) {\r\n                sum += k % 10;\r\n                k /= 10;\r\n            }\r\n\r\n            carry = sum / 10;\r\n            res.add(sum % 10);\r\n        }\r\n\r\n        if (carry > 0) {\r\n            res.add(carry);\r\n        }\r\n\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n// @lc code=end\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)，其中 N 为数组长度。\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837392702",
      "body": "### 思路\r\n正序遍历字符串,\r\n    当c出现时，记录c的位置\r\n    当前字符与c的距离1 = c上次出现的位置 - 当前位置\r\n\r\n逆序遍历字符串，\r\n    当c出现时，记录c的位置\r\n    当前字符与c的距离2 = 当前位置 - c上次出现的位置 \r\n    同时，最短距离 = min(距离1， 距离2）\r\n\r\n### 代码\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n\r\n        c_pos = -10000 #s.length < 10^4\r\n        i = 0\r\n        for char in s:\r\n            if char == c:\r\n                c_pos = i\r\n            res.append(i - c_pos)\r\n            i = i + 1\r\n        \r\n        c_pos = 10000 #s.length < 10^4\r\n        i = i - 1\r\n        for char in s[::-1]:\r\n            if char == c:\r\n                c_pos = i;\r\n            res[i] = min(res[i], c_pos - i)\r\n            i = i - 1\r\n        \r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)，不考虑输出数组。"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837392702",
      "body": "### 思路\r\n正序遍历字符串,\r\n    当c出现时，记录c的位置\r\n    当前字符与c的距离1 = c上次出现的位置 - 当前位置\r\n\r\n逆序遍历字符串，\r\n    当c出现时，记录c的位置\r\n    当前字符与c的距离2 = 当前位置 - c上次出现的位置 \r\n    同时，最短距离 = min(距离1， 距离2）\r\n\r\n### 代码\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n\r\n        c_pos = -10000 #s.length < 10^4\r\n        i = 0\r\n        for char in s:\r\n            if char == c:\r\n                c_pos = i\r\n            res.append(i - c_pos)\r\n            i = i + 1\r\n        \r\n        c_pos = 10000 #s.length < 10^4\r\n        i = i - 1\r\n        for char in s[::-1]:\r\n            if char == c:\r\n                c_pos = i;\r\n            res[i] = min(res[i], c_pos - i)\r\n            i = i - 1\r\n        \r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)，不考虑输出数组。"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "bolunzhang2021": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836052238",
      "body": "哈？老哥你不会是发错了吧😂\n\nxmlb88 ***@***.***> 于 2021年5月9日周日 下午9:38写道：\n\n> vector<int> addToArrayForm(vector<int>& num, int k) {\n>     vector<int> res;\n>     for (int i = num.size() - 1; i >= 0; --i) {\n>         int sum = num[i] + (k % 10);\n>         k /= 10;\n>         if (sum / 10) ++k;\n>         res.push_back(sum % 10);\n>     }\n>\n>     while (k) {\n>         res.push_back(k % 10);\n>         k /= 10;\n>     }\n>\n>     reverse(res.begin(), res.end());\n>     return res;\n> }\n>\n> —\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836050621>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AT7X2IERQBJMNHNNMTESUQLTM42KPANCNFSM44PJ5S6A>\n> .\n>\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837866279",
      "body": "代码：JAVA\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N=s.length\r\n     for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n prev = Integer.MAX_VALUE / 2; //整型反转，防止越界\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n时间复杂度 O（n）"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837866279",
      "body": "代码：JAVA\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N=s.length\r\n     for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n prev = Integer.MAX_VALUE / 2; //整型反转，防止越界\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n时间复杂度 O（n）"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "xmlb88": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836051481",
      "body": "c++:\r\n```c++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    vector<int> res;\r\n    for (int i = num.size() - 1; i >= 0; --i) {\r\n        int sum = num[i] + (k % 10);\r\n        k /= 10;\r\n        if (sum / 10) ++k;\r\n        res.push_back(sum % 10);\r\n    }\r\n\r\n    while (k) {\r\n        res.push_back(k % 10);\r\n        k /= 10;\r\n    }\r\n\r\n    reverse(res.begin(), res.end());\r\n    return res;\r\n}\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837629554",
      "body": "```c++\r\n// 暴力\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> idx;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) idx.push_back(i);\r\n    }\r\n\r\n    vector<int> res;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        int dis = INT_MAX;\r\n        for (int j = 0; j < idx.size(); ++j) {\r\n            dis = min(dis, abs(i - idx[j]));\r\n        }\r\n        res.push_back(dis);\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n\r\n```c++\r\n// 2次遍历\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res;\r\n    int last_idx = INT_MAX;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) last_idx = i;\r\n        res.push_back(abs(last_idx - i));\r\n    }\r\n\r\n    last_idx = INT_MAX;\r\n    for (int i = s.size() - 1; i >= 0; --i) {\r\n        if (s[i] == c) last_idx = i;\r\n        res[i] = min(res[i], abs(last_idx - i));\r\n    }\r\n    \r\n    return res;\r\n}\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837629554",
      "body": "```c++\r\n// 暴力\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> idx;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) idx.push_back(i);\r\n    }\r\n\r\n    vector<int> res;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        int dis = INT_MAX;\r\n        for (int j = 0; j < idx.size(); ++j) {\r\n            dis = min(dis, abs(i - idx[j]));\r\n        }\r\n        res.push_back(dis);\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n\r\n```c++\r\n// 2次遍历\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res;\r\n    int last_idx = INT_MAX;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) last_idx = i;\r\n        res.push_back(abs(last_idx - i));\r\n    }\r\n\r\n    last_idx = INT_MAX;\r\n    for (int i = s.size() - 1; i >= 0; --i) {\r\n        if (s[i] == c) last_idx = i;\r\n        res[i] = min(res[i], abs(last_idx - i));\r\n    }\r\n    \r\n    return res;\r\n}\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Saberfish": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836053127",
      "body": "## 代码\r\n\r\nC++ :\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int i=num.size()-1;\r\n        while(k>0){\r\n            k=k+num[i];\r\n            num[i]=k%10;\r\n            k=k/10;\r\n            i--;\r\n            if(i<0 && k>0){\r\n                num.insert(num.begin(),0);\r\n                i=0;\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837693091",
      "body": "### 思路\r\n\r\n\t先把所有目标字符的下标存到数组里面，再进行遍历查找每个字符的距离。\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int lenS=S.size();\r\n        vector<int> dest={};\r\n        for(int i=0;i<lenS;i++){\r\n            if(C==S[i]){\r\n                dest.insert(dest.end(),i);\r\n            }\r\n        }\r\n        int lenD=dest.size();\r\n        vector<int> output={};\r\n        for(int i=0;i<lenS;i++){\r\n            int a=i;\r\n            int distance=10000;\r\n            for(int j=0;j<lenD;j++){\r\n                int b=dest[j];\r\n                int dis=0;\r\n                if(a<b){\r\n                    dis=b-a;\r\n                }\r\n                else{\r\n                    dis=a-b;\r\n                }\r\n                if(dis<distance){\r\n                    distance=dis;\r\n                }\r\n            }\r\n            output.insert(output.end(),distance);\r\n        }\r\n        return output;\r\n    }\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837693091",
      "body": "### 思路\r\n\r\n\t先把所有目标字符的下标存到数组里面，再进行遍历查找每个字符的距离。\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int lenS=S.size();\r\n        vector<int> dest={};\r\n        for(int i=0;i<lenS;i++){\r\n            if(C==S[i]){\r\n                dest.insert(dest.end(),i);\r\n            }\r\n        }\r\n        int lenD=dest.size();\r\n        vector<int> output={};\r\n        for(int i=0;i<lenS;i++){\r\n            int a=i;\r\n            int distance=10000;\r\n            for(int j=0;j<lenD;j++){\r\n                int b=dest[j];\r\n                int dis=0;\r\n                if(a<b){\r\n                    dis=b-a;\r\n                }\r\n                else{\r\n                    dis=a-b;\r\n                }\r\n                if(dis<distance){\r\n                    distance=dis;\r\n                }\r\n            }\r\n            output.insert(output.end(),distance);\r\n        }\r\n        return output;\r\n    }\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "xiongyujie": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836058937",
      "body": "语言：java\r\n时间复杂度：O(9n) => O(n) ,数组插入\r\n空间复杂度：除去输出结果,空间复杂度O(1)\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int out = 0 ;\r\n        int len = num.length;\r\n        int i = len - 1;\r\n        for(; i >= 0 && k > 0; i--){\r\n            int tmp =out + num[i] +  k % 10;\r\n            out = tmp / 10;\r\n            k = k / 10;\r\n            res.add(0, tmp % 10);\r\n        }\r\n        while(i >= 0){\r\n            int tmp = out + num[i];\r\n            out = tmp / 10;\r\n            res.add(0, tmp % 10);\r\n            i--;\r\n        }\r\n        while(k > 0){\r\n            int tmp = out + k % 10;\r\n            k = k / 10;\r\n            out = tmp / 10;\r\n            res.add(0, tmp % 10);\r\n        }\r\n        if(out > 0){\r\n            res.add(0, out);\r\n        }\r\n        return res ;\r\n    }\r\n}\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837711066",
      "body": "思路：两次遍历，第一次记住字符c的下标，第二次计算与字符c的最近距离。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        List<Integer> tmp = new ArrayList<>();\r\n        int index = 0 ;\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                tmp.add(i);\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < len; i++ ){\r\n            int cur =  tmp.get(index);\r\n            if(index < 1){\r\n                res[i] = Math.abs(i - cur);\r\n            }else{\r\n                res[i] = Math.min(Math.abs(i - cur), Math.abs(i - tmp.get(index - 1)));\r\n            }\r\n            if(i == tmp.get(index) && (index + 1) < tmp.size()){\r\n                index ++ ;\r\n            }\r\n        }\r\n        return res ;\r\n\r\n    }\r\n}\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837711066",
      "body": "思路：两次遍历，第一次记住字符c的下标，第二次计算与字符c的最近距离。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        List<Integer> tmp = new ArrayList<>();\r\n        int index = 0 ;\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                tmp.add(i);\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < len; i++ ){\r\n            int cur =  tmp.get(index);\r\n            if(index < 1){\r\n                res[i] = Math.abs(i - cur);\r\n            }else{\r\n                res[i] = Math.min(Math.abs(i - cur), Math.abs(i - tmp.get(index - 1)));\r\n            }\r\n            if(i == tmp.get(index) && (index + 1) < tmp.size()){\r\n                index ++ ;\r\n            }\r\n        }\r\n        return res ;\r\n\r\n    }\r\n}\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Syan115": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836060783",
      "body": "思路：\r\n1. 从低位起按位相加，注意进位问题\r\n2. list反转一下\r\n\r\n复杂度分析\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(n)\r\n\r\n```class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length;\r\n        int sum = 0;\r\n        List<Integer> res = new ArrayList<>();\r\n        // 按位相加\r\n        for(int i=n-1; i>=0; i--){\r\n            sum = num[i] + k%10;\r\n            if(sum>=10){\r\n                sum = sum%10;\r\n                k = k+10;\r\n            }\r\n            res.add(sum);\r\n            k = k/10;          \r\n        }\r\n        while(k!=0){\r\n            res.add(k%10);\r\n            k = k/10;\r\n        }\r\n\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n} \r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837606516",
      "body": "## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n\r\n## 思路\r\n分别从左向右和从右向左的遍历来获得当前位置字符与目标字符的距离，并取两者中较小的那一个。\r\n\r\n\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为字符串长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837606516",
      "body": "## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n\r\n## 思路\r\n分别从左向右和从右向左的遍历来获得当前位置字符与目标字符的距离，并取两者中较小的那一个。\r\n\r\n\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为字符串长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "NorthSeacoder": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836063398",
      "body": "## 思路\r\n利用 BigInt 计算\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n    \r\n    return (BigInt(num.join('')) + BigInt(k)).toString().split('')\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(1),没遍历数组....\r\n- 空间复杂度：O(n), 直接把数组转成 BigInt,不确定这里对不对...."
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838453454",
      "body": "## 思路\r\n- 字符串拆成数组,并查询c 的所有下标\r\n- 遍历数组查询每个下标到 c 的最短距离\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    const res=[],sIndexs=[];\r\n    \r\n    s.split('').forEach((char,index)=>{\r\n        if(char===c)sIndexs.push(index)\r\n    })\r\n    for(let i = 0;i<s.length;i++){\r\n        let tem = sIndexs.map(item=>Math.abs(i-item)).sort((a,b)=>a-b).shift();\r\n        res.push(tem)\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n*m) m为字符 c 在 s 中的重复次数\r\n- 空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838453454",
      "body": "## 思路\r\n- 字符串拆成数组,并查询c 的所有下标\r\n- 遍历数组查询每个下标到 c 的最短距离\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    const res=[],sIndexs=[];\r\n    \r\n    s.split('').forEach((char,index)=>{\r\n        if(char===c)sIndexs.push(index)\r\n    })\r\n    for(let i = 0;i<s.length;i++){\r\n        let tem = sIndexs.map(item=>Math.abs(i-item)).sort((a,b)=>a-b).shift();\r\n        res.push(tem)\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n*m) m为字符 c 在 s 中的重复次数\r\n- 空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "shizukanaskytree": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836063868",
      "body": "\r\n## 题目地址(989. Add to Array-Form of Integer)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\nThe array-form of an integer num is an array representing its digits in left to right order.\r\n\r\nFor example, for num = 1321, the array form is [1,3,2,1].\r\n\r\nGiven num, the array-form of an integer, and an integer k, return the array-form of the integer num + k.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: num = [1,2,0,0], k = 34\r\nOutput: [1,2,3,4]\r\nExplanation: 1200 + 34 = 1234\r\n\r\n\r\nExample 2:\r\n\r\nInput: num = [2,7,4], k = 181\r\nOutput: [4,5,5]\r\nExplanation: 274 + 181 = 455\r\n\r\n\r\nExample 3:\r\n\r\nInput: num = [2,1,5], k = 806\r\nOutput: [1,0,2,1]\r\nExplanation: 215 + 806 = 1021\r\n\r\n\r\nExample 4:\r\n\r\nInput: num = [9,9,9,9,9,9,9,9,9,9], k = 1\r\nOutput: [1,0,0,0,0,0,0,0,0,0,0]\r\nExplanation: 9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= num.length <= 104\r\n0 <= num[i] <= 9\r\nnum does not contain any leading zeros except for the zero itself.\r\n1 <= k <= 104\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nfrom typing import List \r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_val = 0\r\n\r\n        for n in num:\r\n            num_val += n            \r\n            num_val = num_val * 10\r\n        num_val //= 10\r\n        \r\n        new_val = num_val + k\r\n        \r\n        if new_val == 0:\r\n            return [0]\r\n        \r\n        res = []\r\n        last_digit = 0\r\n            \r\n        while new_val != 0:\r\n            last_digit = new_val % 10\r\n            res.append(last_digit)    \r\n            new_val = new_val // 10\r\n\r\n        res.reverse()\r\n        return res\r\n\r\na = [0]\r\ns = Solution()\r\nres = s.addToArrayForm(a, k=0)\r\nprint(res)\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838260266",
      "body": "\r\n## 题目地址(821. Shortest Distance to a Character)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\r\n\r\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"loveleetcode\", c = \"e\"\r\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\r\nExplanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\r\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\r\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 3.\r\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\r\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\r\n\r\n\r\nExample 2:\r\n\r\nInput: s = \"aaab\", c = \"b\"\r\nOutput: [3,2,1,0]\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= s.length <= 104\r\ns[i] and c are lowercase English letters.\r\nIt is guaranteed that c occurs at least once in s.\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n\"\"\"\r\nloveleetco d  e\r\n0123456789 10 11\r\n+++0100123 4  0\r\n3210100432 1  0\r\n3210100122 1  0\r\n\r\n 3 2 1 0 1 0 0 1 2 2 1 0\r\n[3,2,1,0,1,0,0,1,2,2,1,0]\r\n\r\n\"\"\"\r\n\r\n# 1.\r\n# https://stackoverflow.com/questions/6810036/whats-better-the-reverse-method-or-the-reversed-built-in-function#:~:text=reverse()%20actually%20reverses%20the,than%20actually%20reversing%20the%20elements.\r\n\r\n# 2.\r\n# https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n\r\n# 3.\r\n# range(start, stop, step)\r\n# 左闭右开! []start, stop)\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        anchor = float('-inf')\r\n        # distance = left - righ\r\n        # distance = curr_val - anchor\r\n        # distance = postive_val - float('-inf')\r\n        dist = []\r\n        for i, l in enumerate(s):\r\n            if l == c:\r\n                dist[i] = prev\r\n            else:\r\n                dist[i] = i - prev\r\n        for i, l in enumerate(reversed(s)):\r\n            if l == c:\r\n                dist[i] = min(dist[i], )\r\n\r\n        \r\n\"\"\"\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n\r\n作者：LeetCode\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\"\"\"\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838260266",
      "body": "\r\n## 题目地址(821. Shortest Distance to a Character)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\r\n\r\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"loveleetcode\", c = \"e\"\r\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\r\nExplanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\r\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\r\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 3.\r\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\r\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\r\n\r\n\r\nExample 2:\r\n\r\nInput: s = \"aaab\", c = \"b\"\r\nOutput: [3,2,1,0]\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= s.length <= 104\r\ns[i] and c are lowercase English letters.\r\nIt is guaranteed that c occurs at least once in s.\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n\"\"\"\r\nloveleetco d  e\r\n0123456789 10 11\r\n+++0100123 4  0\r\n3210100432 1  0\r\n3210100122 1  0\r\n\r\n 3 2 1 0 1 0 0 1 2 2 1 0\r\n[3,2,1,0,1,0,0,1,2,2,1,0]\r\n\r\n\"\"\"\r\n\r\n# 1.\r\n# https://stackoverflow.com/questions/6810036/whats-better-the-reverse-method-or-the-reversed-built-in-function#:~:text=reverse()%20actually%20reverses%20the,than%20actually%20reversing%20the%20elements.\r\n\r\n# 2.\r\n# https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n\r\n# 3.\r\n# range(start, stop, step)\r\n# 左闭右开! []start, stop)\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        anchor = float('-inf')\r\n        # distance = left - righ\r\n        # distance = curr_val - anchor\r\n        # distance = postive_val - float('-inf')\r\n        dist = []\r\n        for i, l in enumerate(s):\r\n            if l == c:\r\n                dist[i] = prev\r\n            else:\r\n                dist[i] = i - prev\r\n        for i, l in enumerate(reversed(s)):\r\n            if l == c:\r\n                dist[i] = min(dist[i], )\r\n\r\n        \r\n\"\"\"\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n\r\n作者：LeetCode\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\"\"\"\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "BeBraveBeCurious": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836072235",
      "body": "``` Python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n\r\n        i, carry = len(num) - 1, 0\r\n        while i >= 0 or k != 0:\r\n            x = num[i] if i >= 0 else 0\r\n            y = k % 10 if k != 0 else 0\r\n\r\n            sum = x + y + carry\r\n            res.append(sum % 10)\r\n            carry = sum // 10\r\n\r\n            i -= 1\r\n            k //= 10\r\n\r\n        if carry != 0:\r\n            res.append(carry)\r\n            \r\n        return res[::-1]\r\n```\r\n**复杂度分析**\r\nn 为数组长度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838401294",
      "body": "### 解题思路\r\n- 从左向右遍历, 记录 `i - prev`, `prev`为前一次`c`出现的下标\r\n- 从右向左遍历, 记录 `prev - i`, `prev`为靠右的`c`出现的下标\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n\r\n        for i, x in enumerate(s):\r\n            if x == c: prev = i \r\n            ans.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i \r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans \r\n```\r\n\r\n### 复杂度分析\r\n- **时间复杂度**：$O(n)$, 两次遍历`2n`化简为`n`\r\n- **空间复杂度**：$O(n)$, `n`为ans数组的长度"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838401294",
      "body": "### 解题思路\r\n- 从左向右遍历, 记录 `i - prev`, `prev`为前一次`c`出现的下标\r\n- 从右向左遍历, 记录 `prev - i`, `prev`为靠右的`c`出现的下标\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n\r\n        for i, x in enumerate(s):\r\n            if x == c: prev = i \r\n            ans.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i \r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans \r\n```\r\n\r\n### 复杂度分析\r\n- **时间复杂度**：$O(n)$, 两次遍历`2n`化简为`n`\r\n- **空间复杂度**：$O(n)$, `n`为ans数组的长度"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "watermelonDrip": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836072251",
      "body": "## 思路\r\n- 转int 和 k 相加\r\n- 取余逐位加到res_list里\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n         \r\n        str_num = ''.join(str(x) for x in num)\r\n        tmp = int(str_num)\r\n        int_res = tmp + k\r\n        list_res = []\r\n        if int_res == 0:\r\n            return [0]\r\n        while int_res>0:\r\n            list_res.append(int_res%10)\r\n            int_res = int_res//10\r\n        return list_res[::-1]\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837668088",
      "body": "## 思路\r\n\r\n- 模拟\r\n- 先统计s出现的位置，两个位置的距离是odd,递增序列+递减序列。如果是even，就去掉一个中间数。\r\n如果统计s 的位置不是最后一位，最后再加一个递减序列\r\n \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        list_c = list()\r\n        for i, item in enumerate(s):\r\n            if item == c:\r\n                list_c.append(i)\r\n     \r\n        left = 0\r\n        right = 0\r\n        \r\n      \r\n        res = list()\r\n         \r\n        while  right <  len(list_c):\r\n     \r\n            if left == right:\r\n                \r\n                for i in range(list_c[right],-1,-1):\r\n                    res.append(i)\r\n                right+=1\r\n            elif list_c[right] < len(s) and left < right:\r\n                tmp = list_c[right] - list_c[left]\r\n                distance = tmp //2\r\n                distance_num = tmp%2\r\n                for i in range( 1,distance+distance_num ):\r\n                    res.append(i)\r\n                for i in range(distance,-1,-1):\r\n                    res.append(i)\r\n                right+=1\r\n                left+=1\r\n             \r\n            else:\r\n                break\r\n        len_s = len(s)\r\n       \r\n        if list_c[-1] < len_s -1:\r\n            for i in range(1, len_s - list_c[-1] ):\r\n                res.append(i)\r\n            \r\n        return res \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837668088",
      "body": "## 思路\r\n\r\n- 模拟\r\n- 先统计s出现的位置，两个位置的距离是odd,递增序列+递减序列。如果是even，就去掉一个中间数。\r\n如果统计s 的位置不是最后一位，最后再加一个递减序列\r\n \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        list_c = list()\r\n        for i, item in enumerate(s):\r\n            if item == c:\r\n                list_c.append(i)\r\n     \r\n        left = 0\r\n        right = 0\r\n        \r\n      \r\n        res = list()\r\n         \r\n        while  right <  len(list_c):\r\n     \r\n            if left == right:\r\n                \r\n                for i in range(list_c[right],-1,-1):\r\n                    res.append(i)\r\n                right+=1\r\n            elif list_c[right] < len(s) and left < right:\r\n                tmp = list_c[right] - list_c[left]\r\n                distance = tmp //2\r\n                distance_num = tmp%2\r\n                for i in range( 1,distance+distance_num ):\r\n                    res.append(i)\r\n                for i in range(distance,-1,-1):\r\n                    res.append(i)\r\n                right+=1\r\n                left+=1\r\n             \r\n            else:\r\n                break\r\n        len_s = len(s)\r\n       \r\n        if list_c[-1] < len_s -1:\r\n            for i in range(1, len_s - list_c[-1] ):\r\n                res.append(i)\r\n            \r\n        return res \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "cecilia-vu": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836079487",
      "body": "### 思路\r\n\r\n从低位按位计算，注意处理最高位进位的情况\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int add = 0;\r\n        for (int i = num.size() - 1; i>=0; i--) {\r\n            int digit = k % 10;\r\n            k = k / 10;\r\n            int tmp = num[i] + digit + add;\r\n            if (tmp > 9) {\r\n                res.push_back(tmp - 10);\r\n                add = 1;\r\n            } else {\r\n                res.push_back(tmp);\r\n                add = 0;\r\n            }\r\n        }\r\n        while (k > 0) {\r\n            int tmp = k % 10 + add;\r\n            if (tmp > 9) {\r\n                res.push_back(tmp - 10);\r\n                add = 1;\r\n            } else {\r\n                res.push_back(tmp);\r\n                add = 0;\r\n            }\r\n            k = k / 10;\r\n        }\r\n        if (add == 1) {\r\n            res.push_back(1);\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838562572",
      "body": "### 思路\r\n\r\n正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ans(n);\r\n        int prec = INT_MIN / 2;\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) {\r\n                ans[i] = 0;\r\n                prec = i;\r\n            } else {\r\n                ans[i] = i - prec;\r\n            }\r\n        }\r\n\r\n        prec = INT_MAX / 2;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) {\r\n                s[i] = 0;\r\n                prec = i;\r\n            } else {\r\n                ans[i] = min(ans[i], prec - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838562572",
      "body": "### 思路\r\n\r\n正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ans(n);\r\n        int prec = INT_MIN / 2;\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) {\r\n                ans[i] = 0;\r\n                prec = i;\r\n            } else {\r\n                ans[i] = i - prec;\r\n            }\r\n        }\r\n\r\n        prec = INT_MAX / 2;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) {\r\n                s[i] = 0;\r\n                prec = i;\r\n            } else {\r\n                ans[i] = min(ans[i], prec - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Davont": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836079739",
      "body": "### 思路\r\n1.先反转数组\r\n2.上下相加\r\n3.再反转成正常数组\r\n\r\n### 代码（JavaScript）\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  /**\r\n   * 大数相加，先将两个数反转\r\n   */\r\n  let numAStr = num.reverse();\r\n  let numBStr = k.toString().split('').reverse();\r\n  let temp = 0;\r\n  let result = [];\r\n  for (let i = 0; i < Math.max(numAStr.length, numBStr.length); i++) {\r\n    if (!numAStr[i]) {\r\n      numAStr[i] = 0;\r\n    }\r\n    if (!numBStr[i]) {\r\n      numBStr[i] = 0;\r\n    }\r\n    result[i] = numAStr[i] + +numBStr[i] + temp;\r\n    if (result[i] > 9) {\r\n      result[i] -= 10;\r\n      temp = 1;\r\n    } else{\r\n        temp = 0;\r\n    }\r\n  }\r\n  if (temp === 1) {\r\n    result.push(temp);\r\n  }\r\n  return result.reverse();\r\n};\r\n``` \r\n\r\n        \r\n### 复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734919",
      "body": "### 思路\r\n先存入index，然后比较每个index和遍历到数的最小距离，进行输出\r\n\r\n### 代码\r\n```js\r\nvar shortestToChar = function(S, C) {\r\n    let len = S.length;\r\n    let cArr = [];\r\n    let res = [];\r\n    for (let i = 0; i < len; i++) {\r\n        if (S[i] === C) {\r\n            cArr.push(i)\r\n        }\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n        let distance = Math.abs(i - cArr[0]);\r\n        for (let j = 0; j < cArr.length; j++) {\r\n            if (distance > Math.abs(i - cArr[j])) {\r\n                distance = Math.abs(i - cArr[j])\r\n            }\r\n        }\r\n        res.push(distance)\r\n    }\r\n    return res;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734919",
      "body": "### 思路\r\n先存入index，然后比较每个index和遍历到数的最小距离，进行输出\r\n\r\n### 代码\r\n```js\r\nvar shortestToChar = function(S, C) {\r\n    let len = S.length;\r\n    let cArr = [];\r\n    let res = [];\r\n    for (let i = 0; i < len; i++) {\r\n        if (S[i] === C) {\r\n            cArr.push(i)\r\n        }\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n        let distance = Math.abs(i - cArr[0]);\r\n        for (let j = 0; j < cArr.length; j++) {\r\n            if (distance > Math.abs(i - cArr[j])) {\r\n                distance = Math.abs(i - cArr[j])\r\n            }\r\n        }\r\n        res.push(distance)\r\n    }\r\n    return res;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "LangqiZhao": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836081583",
      "body": "### 思路\r\n\r\n把数组从末尾开始，和k进行加法运算，并通过进位更新需要加的数值。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        ans = list()\r\n\r\n        add_value = k\r\n        for idx in range(len(num)):\r\n            val = num[len(num) - 1 - idx] + add_value\r\n            add_value = val // 10\r\n            ans.append(val % 10)\r\n\r\n            if add_value == 0:\r\n                break\r\n\r\n        while add_value > 0:\r\n            ans.append(add_value % 10)\r\n            add_value = add_value // 10\r\n\r\n        ans = ans[::-1]\r\n\r\n        if idx < len(num) - 1:\r\n            ans = num[:len(num) - idx - 1] + ans\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837627118",
      "body": "### 思路\r\n\r\n通过类似单调栈的方法，计算到C的距离。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [0] * len(s)\r\n        stack = list()\r\n        sig = None\r\n\r\n        for idx in range(len(s)):\r\n            while stack and (s[stack[-1]] != c) and (s[idx] == c):\r\n                temp_index = stack.pop(-1)\r\n                if sig is None:\r\n                    ans[temp_index] = abs(idx - temp_index)\r\n                else:\r\n                    ans[temp_index] = min(abs(idx - temp_index), abs(sig - temp_index))\r\n            if s[idx] == c:\r\n                sig = idx\r\n            stack.append(idx)\r\n\r\n        while stack and s[stack[-1]] != c:\r\n            temp_index = stack.pop(-1)\r\n            ans[temp_index] = abs(temp_index - sig)\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837627118",
      "body": "### 思路\r\n\r\n通过类似单调栈的方法，计算到C的距离。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [0] * len(s)\r\n        stack = list()\r\n        sig = None\r\n\r\n        for idx in range(len(s)):\r\n            while stack and (s[stack[-1]] != c) and (s[idx] == c):\r\n                temp_index = stack.pop(-1)\r\n                if sig is None:\r\n                    ans[temp_index] = abs(idx - temp_index)\r\n                else:\r\n                    ans[temp_index] = min(abs(idx - temp_index), abs(sig - temp_index))\r\n            if s[idx] == c:\r\n                sig = idx\r\n            stack.append(idx)\r\n\r\n        while stack and s[stack[-1]] != c:\r\n            temp_index = stack.pop(-1)\r\n            ans[temp_index] = abs(temp_index - sig)\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "taozi-taozi": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836083170",
      "body": "### 思路：\r\n数组遍历\r\n### 代码：\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        re = 0\r\n        for i in num[:-1]:\r\n            re = (re + i) * 10\r\n        re = re + num[-1] + k\r\n        return [int(x) for x in str(re)]\r\n```\r\n### 复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649030",
      "body": "### 思路\r\n双指针.....😮\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        re = [0]*n\r\n        slow, fast = 0,0\r\n        pre = inf\r\n        while fast<n:\r\n            while s[fast] != c:\r\n                if fast == n-1:\r\n                    break\r\n                fast+=1\r\n            while slow<=fast:\r\n                if s[fast]!=c:\r\n                    re[slow] = abs(slow-pre)\r\n                else:\r\n                    re[slow] = min(abs(slow-pre),abs(slow-fast))\r\n                slow+=1\r\n            pre = fast\r\n            fast+=1\r\n        return re\r\n```\r\n### 复杂度分析😖\r\n时间复杂度：O(n)?\r\n空间复杂度：O(n)\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649030",
      "body": "### 思路\r\n双指针.....😮\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        re = [0]*n\r\n        slow, fast = 0,0\r\n        pre = inf\r\n        while fast<n:\r\n            while s[fast] != c:\r\n                if fast == n-1:\r\n                    break\r\n                fast+=1\r\n            while slow<=fast:\r\n                if s[fast]!=c:\r\n                    re[slow] = abs(slow-pre)\r\n                else:\r\n                    re[slow] = min(abs(slow-pre),abs(slow-fast))\r\n                slow+=1\r\n            pre = fast\r\n            fast+=1\r\n        return re\r\n```\r\n### 复杂度分析😖\r\n时间复杂度：O(n)?\r\n空间复杂度：O(n)\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "DIUDIU110": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836088010",
      "body": "### 思路\r\n    模拟数字加法，利用 K 保存进位，先将对应位置的数字相加，再进行取余操作保留结果。\r\n### 程序 C++\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& a, int k) {\r\n        vector<int>res;\r\n        vector<int>b;\r\n        while(k)\r\n        {\r\n            b.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(b.begin(),b.end());\r\n        int fl=0;\r\n        int i,j;\r\n        for(i=a.size()-1,j=b.size()-1;i>=0&&j>=0;i--,j--)\r\n        {\r\n            int te=a[i]+b[j]+fl;\r\n            fl=te/10;\r\n            res.push_back(te%10);\r\n        }\r\n        while(i>=0)\r\n        {\r\n            int te=a[i]+fl;\r\n            fl=te/10;\r\n            res.push_back(te%10);\r\n            i--;\r\n        }\r\n        while(j>=0)\r\n        {\r\n            int te=b[j]+fl;\r\n            fl=te/10;\r\n            res.push_back(te%10);\r\n            j--;\r\n        }\r\n        if(fl)\r\n            res.push_back(fl);\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n   时间: o(max(n,m)) \r\n   空间: o(n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837967947",
      "body": "### 算法思想：\r\n首先遍历一遍数组记录c的位置  为了处理方便 最好在最前面和最后面加上一个特殊位置\r\n再遍历一遍数组求解当前字符前后c位置差的最小值即可 注意最后一个区间里的遍历需要控制一下 不让其再变动区间\r\n### 代码：\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n=s.size();\r\n        int v1[10005];\r\n        int cnt=0;\r\n        v1[cnt++]=n+1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(s[i]==c)\r\n                v1[cnt++]=i;\r\n        }\r\n        v1[cnt++]=-n-1;\r\n        vector<int>res(n);\r\n        cnt=1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(i<=v1[cnt])\r\n                res[i]=min(abs(i-v1[cnt-1]),abs(i-v1[cnt]));\r\n\r\n            else\r\n            {\r\n                if(v1[cnt]!=-n-1)\r\n                    cnt++;\r\n                res[i]=min(abs(i-v1[cnt-1]),abs(i-v1[cnt]));\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：o(n)\r\n空间：o(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837967947",
      "body": "### 算法思想：\r\n首先遍历一遍数组记录c的位置  为了处理方便 最好在最前面和最后面加上一个特殊位置\r\n再遍历一遍数组求解当前字符前后c位置差的最小值即可 注意最后一个区间里的遍历需要控制一下 不让其再变动区间\r\n### 代码：\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n=s.size();\r\n        int v1[10005];\r\n        int cnt=0;\r\n        v1[cnt++]=n+1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(s[i]==c)\r\n                v1[cnt++]=i;\r\n        }\r\n        v1[cnt++]=-n-1;\r\n        vector<int>res(n);\r\n        cnt=1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(i<=v1[cnt])\r\n                res[i]=min(abs(i-v1[cnt-1]),abs(i-v1[cnt]));\r\n\r\n            else\r\n            {\r\n                if(v1[cnt]!=-n-1)\r\n                    cnt++;\r\n                res[i]=min(abs(i-v1[cnt-1]),abs(i-v1[cnt]));\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：o(n)\r\n空间：o(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "rfhklwt": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836091338",
      "body": "## 思路\r\n* 模拟竖式加法，逐位相加，并记录`carry`位\r\n```伪代码\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        res = []\r\n        i, Sum, carry = n - 1, 0, 0\r\n        \r\n        while i >= 0 or k != 0:\r\n            x = num[i] if i >= 0 else 0\r\n            y = k % 10 if k != 0 else 1\r\n\r\n            Sum = x + y + carry\r\n            # 当前位\r\n            res.append(Sum % 10)\r\n            # 进位\r\n            carry = Sum // 10\r\n            i, k = i - 1, k // 10\r\n        \r\n        # 最后检查进位是否为１\r\n        if carry > 0:\r\n            res.append(carry)\r\n        \r\n        return res[::-1]\r\n```\r\n* Julia\r\n```julia\r\nfunction add_to_array_form(num::Vector{Int}, k::Int)::Vector{Int}\r\n    n = length(num)\r\n    i, val, carry = n, 0, 0\r\n    res = Int[]\r\n\r\n    while i > 0 || k != 0\r\n        x = i > 0 ? num[i] : 0\r\n        y = k != 0 ? k % 10 : 0\r\n\r\n        val = x + y + carry\r\n        append!(res, val % 10)\r\n        carry = val ÷ 10\r\n        i, k = i - 1, k ÷ 10\r\n    end\r\n\r\n    if carry > 0\r\n        append!(res, carry)\r\n    end\r\n\r\n    return reverse(res)\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(max(n,log k))`，其中`n`为数组的长度。\r\n\r\n* 空间复杂度：`O(1)`，不考虑返回数组。\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838237568",
      "body": "## 思路\r\n1. 首先正向遍历一遍，求出往右找的最短距离；\r\n2. 接着反向遍历一遍，求出往左找的最短距离；\r\n3. 算出他们的最小值就是最短距离了。\r\n\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n, pos = len(s), float('-inf')\r\n        res = [n] * n\r\n        for i in list(range(n)) + list(range(n)[::-1]):\r\n            if s[i] == c:\r\n                pos = i\r\n            res[i] = min(res[i], abs(i - pos))\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(n)`\r\n\r\n* 空间复杂度：`O(n)`"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838237568",
      "body": "## 思路\r\n1. 首先正向遍历一遍，求出往右找的最短距离；\r\n2. 接着反向遍历一遍，求出往左找的最短距离；\r\n3. 算出他们的最小值就是最短距离了。\r\n\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n, pos = len(s), float('-inf')\r\n        res = [n] * n\r\n        for i in list(range(n)) + list(range(n)[::-1]):\r\n            if s[i] == c:\r\n                pos = i\r\n            res[i] = min(res[i], abs(i - pos))\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(n)`\r\n\r\n* 空间复杂度：`O(n)`"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840249650",
      "body": "## 思路\r\n当遇到`[`符号时，我们知道要将括号里面的字符串重复`k`遍，所以用一个**栈**来存放`(current_string, k)`，而当遇到`]`符号的时候就可以把里面的字符串重复`k`遍。\r\n\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        current_string = \"\"\r\n        k = 0\r\n\r\n        for char in s:\r\n            if char == '[':\r\n                stack.append((current_string, k))\r\n                current_string = \"\"\r\n                k = 0\r\n            elif char == ']':\r\n                last_string, last_k = stack.pop()\r\n                current_string = last_string + last_k * current_string\r\n            elif char.isdigit():\r\n                k = k * 10 + int(char)\r\n            else:\r\n                current_string += char\r\n        \r\n        return current_string\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(S)`，其中`S`为解码后的字符串长度\r\n* 空间复杂度：`O(S)`，其中`S`为解码后的字符串长度"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "HTian1997": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836091664",
      "body": "思路：模拟加法\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = k\r\n        for i in range(len(num) - 1, -1, -1):\r\n            num[i] += carry\r\n            carry = num[i] // 10\r\n            num[i] %= 10\r\n        \r\n        while carry:\r\n            num.insert(0, carry % 10)\r\n            carry //= 10\r\n        \r\n        return num\r\n```\r\n\r\n复杂度：time O(N), space O(N)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649590",
      "body": "思路：从左到右和从右到左遍历两边\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [float('inf') for i in range(n)]\r\n\r\n        pos = s.index(c)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                pos = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], abs(i - pos))\r\n        \r\n        pos = s.rindex(c)\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                pos = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], abs(i - pos))\r\n        \r\n        return ans\r\n```\r\n\r\nComplexity: time O(N), space O(N)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649590",
      "body": "思路：从左到右和从右到左遍历两边\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [float('inf') for i in range(n)]\r\n\r\n        pos = s.index(c)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                pos = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], abs(i - pos))\r\n        \r\n        pos = s.rindex(c)\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                pos = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], abs(i - pos))\r\n        \r\n        return ans\r\n```\r\n\r\nComplexity: time O(N), space O(N)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "terrylijiayang": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836094791",
      "body": "**思路**\r\n两个循环。第一个循环先统一到一个数组，第二个循环再做进位处理。\r\n**代码**\r\n```\r\nvar addToArrayForm = function (A, K) {\r\n    count = 0;\r\n    len = K.toString().length;\r\n    for (let i = 0; i < len; i++) {\r\n        if (A.length < len) {\r\n            A.unshift(0);\r\n        }\r\n        count = K % 10;\r\n        K = parseInt(K / 10);\r\n        A[A.length - 1 - i] += count;\r\n    }\r\n    for (let i = 0; i < A.length; i++) {\r\n        if (A[0] > 9) {\r\n            A.unshift(0);\r\n        }\r\n        if (A[A.length - 1 - i] > 9) {\r\n            A[A.length - 2 - i]++;\r\n            A[A.length - 1 - i] = A[A.length - 1 - i] % 10;\r\n        }\r\n    }\r\n    return A;\r\n};\r\n```\r\n**复杂度**\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838562657",
      "body": "**思路**\r\n先用数组存储距离位置，再通过外循环找位置，再内循环找最小值。\r\n\r\n**代码**\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    let array = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        array[i] = s.length;\r\n    }\r\n    for (let i = 0; i < s.length; i++){\r\n        if ( s.substring(i, i+1) === c){\r\n            for (let j = 0; j < s.length; j++){\r\n                array[j] = Math.min(Math.abs(i - j),array[j])\r\n            }\r\n        }\r\n    }\r\n    return array;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O（n²）\r\n空间复杂度：O（n）"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838562657",
      "body": "**思路**\r\n先用数组存储距离位置，再通过外循环找位置，再内循环找最小值。\r\n\r\n**代码**\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    let array = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        array[i] = s.length;\r\n    }\r\n    for (let i = 0; i < s.length; i++){\r\n        if ( s.substring(i, i+1) === c){\r\n            for (let j = 0; j < s.length; j++){\r\n                array[j] = Math.min(Math.abs(i - j),array[j])\r\n            }\r\n        }\r\n    }\r\n    return array;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O（n²）\r\n空间复杂度：O（n）"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Xyxy1722": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836098804",
      "body": "思路\r\n每次取num的最后一位和k运算并保存最后一位的结果\r\n\r\n代码\r\n语言支持：Python3\r\nPython3 Code:\r\n\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) - 1\r\n        result = []\r\n        while(i >= 0 or k != 0):\r\n            if i >= 0:\r\n                k = k + num[i]\r\n            result.insert(0, k % 10)\r\n            k = int(k / 10)\r\n            i = i - 1\r\n        return result\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837654968",
      "body": "## 思路\r\ndis值只和最近的c的位置有关 从左向右遍历一遍再从右向左遍历一遍\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        c_loc = -10000\r\n        dis = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                c_loc = i\r\n            dis.append(abs(i - c_loc))\r\n        c_loc = 20000\r\n        while(i >= 0):\r\n            if s[i] == c:\r\n                c_loc = i\r\n            if dis[i] > abs(i - c_loc):\r\n                dis[i] = abs(i - c_loc)\r\n            i = i - 1\r\n        return dis\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837654968",
      "body": "## 思路\r\ndis值只和最近的c的位置有关 从左向右遍历一遍再从右向左遍历一遍\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        c_loc = -10000\r\n        dis = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                c_loc = i\r\n            dis.append(abs(i - c_loc))\r\n        c_loc = 20000\r\n        while(i >= 0):\r\n            if s[i] == c:\r\n                c_loc = i\r\n            if dis[i] > abs(i - c_loc):\r\n                dis[i] = abs(i - c_loc)\r\n            i = i - 1\r\n        return dis\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "eachless": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836098983",
      "body": "\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n =  num.length;\r\n        int cur = k;\r\n        List<Integer> ans = new ArrayList();\r\n        \r\n        int i = n;\r\n        \r\n        while(--i >=0 || cur > 0){\r\n            if( i >= 0){\r\n                cur +=num[i];\r\n            }\r\n            \r\n            ans.add(cur % 10);\r\n            cur /= 10;\r\n        }\r\n        \r\n        \r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837305634",
      "body": "\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] arr = new int[len];\r\n        int cpos = -len;\r\n        \r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                cpos = i;\r\n            }\r\n            \r\n            arr[i] = i - cpos;\r\n        }\r\n        \r\n        for ( int i =len -1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cpos=i;\r\n            }\r\n            arr[i] = Math.min(arr[i],Math.abs(i-cpos));\r\n        }\r\n        \r\n        return arr;\r\n    }\r\n}"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837305634",
      "body": "\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] arr = new int[len];\r\n        int cpos = -len;\r\n        \r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                cpos = i;\r\n            }\r\n            \r\n            arr[i] = i - cpos;\r\n        }\r\n        \r\n        for ( int i =len -1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cpos=i;\r\n            }\r\n            arr[i] = Math.min(arr[i],Math.abs(i-cpos));\r\n        }\r\n        \r\n        return arr;\r\n    }\r\n}"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "linearindep": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836108570",
      "body": "【思路】记住加法进位数量，一级一级加\r\n\r\n【代码】java\r\n\r\n`        int ans = 0;\r\n        List<Integer> arr = new ArrayList<Integer>();\r\n        int i = num.length-1;\r\n       \r\n        while( k>0||i>=0){  \r\n            if(i>=0){\r\n                k = num[i]+k; \r\n            } \r\n                    \r\n            int temp = k%10;\r\n            k = k/10;\r\n            arr.add(temp);\r\n            i--;\r\n        }\r\n        Collections.reverse(arr);\r\n        return arr;\r\n    }`\r\n\r\n【复杂度】时间O(n),空间O(n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837697742",
      "body": "【思路】先找出所有的index存起来，再从右往左比较每个数前后两个index的距离，如果碰到了这个数，就remove掉它的index。\r\n               这么做可以，但是太慢了。其实跟从左找一遍再从右找一遍思路差不多，而且后者会更快\r\n【复杂度】 时间O(N) 空间O(N)\r\n\r\n     `public int[] shortestToChar(String s, char c) {\r\n        ArrayList<Integer> index = new ArrayList<Integer>() ;\r\n        int[] ans = new int[s.length()] ;\r\n        int i = 0;\r\n        for(i =0;i<s.length();i++){\r\n            if(s.charAt(i)==c){\r\n                index.add(i);\r\n                ans[i]=0;\r\n            }\r\n        }\r\n        int lastIdx = 99999;\r\n        for(i = s.length()-1; i>=0 ;i--){\r\n            int dis = 0;\r\n            if(index.size()==0){\r\n                dis = Math.abs(lastIdx-i);\r\n                \r\n            }else{\r\n            int curr = index.get(index.size()-1);\r\n            dis =Math.min(Math.abs(curr-i),Math.abs(i-lastIdx));\r\n                if(i == curr){\r\n                    index.remove(index.size()-1);\r\n                    lastIdx = curr;\r\n                }\r\n            }\r\n            ans[i] = dis;\r\n            \r\n\r\n        }\r\n        \r\n        return ans;\r\n\r\n    }`"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837697742",
      "body": "【思路】先找出所有的index存起来，再从右往左比较每个数前后两个index的距离，如果碰到了这个数，就remove掉它的index。\r\n               这么做可以，但是太慢了。其实跟从左找一遍再从右找一遍思路差不多，而且后者会更快\r\n【复杂度】 时间O(N) 空间O(N)\r\n\r\n     `public int[] shortestToChar(String s, char c) {\r\n        ArrayList<Integer> index = new ArrayList<Integer>() ;\r\n        int[] ans = new int[s.length()] ;\r\n        int i = 0;\r\n        for(i =0;i<s.length();i++){\r\n            if(s.charAt(i)==c){\r\n                index.add(i);\r\n                ans[i]=0;\r\n            }\r\n        }\r\n        int lastIdx = 99999;\r\n        for(i = s.length()-1; i>=0 ;i--){\r\n            int dis = 0;\r\n            if(index.size()==0){\r\n                dis = Math.abs(lastIdx-i);\r\n                \r\n            }else{\r\n            int curr = index.get(index.size()-1);\r\n            dis =Math.min(Math.abs(curr-i),Math.abs(i-lastIdx));\r\n                if(i == curr){\r\n                    index.remove(index.size()-1);\r\n                    lastIdx = curr;\r\n                }\r\n            }\r\n            ans[i] = dis;\r\n            \r\n\r\n        }\r\n        \r\n        return ans;\r\n\r\n    }`"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "yeanli95": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836112944",
      "body": "## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\nFirst Idea is to convert the array into Integer, then  sum up the array and k, then convert into desire result format.\r\n\r\nBut when array size gets larger, it is easy to get overflow when converting into integer.\r\n\r\nThen we need to go through the long way, adding bits from least significant to most significant, \r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<>();\r\n\r\n        int carry = 0;\r\n        int numindex = num.length -1;\r\n        \r\n        while(numindex >=0 || k > 0 ){\r\n            int nums = numindex >=0 ? num[numindex] : 0;\r\n            int results = k > 0 ? k % 10 : 0;\r\n                                                      \r\n            int tempval = results + nums + carry;\r\n            int remainder = tempval % 10;\r\n            \r\n            carry = tempval / 10;\r\n            \r\n            result.add(0, remainder);\r\n            numindex--;\r\n            k /=10;\r\n        }\r\n        \r\n        if(carry > 0){\r\n            result.add(0, carry);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837685280",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\nIterate the array from left to right, then from right to left to find optimal solution\r\n## 关键点\r\nInitialized Array to Integer.MAX_VALUE since we will be using Math.min function;\r\nWhen we first start iterating , assume the matching character will be on the other end.\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int [] result = new int[s.length()];\r\n        int cur = s.length() - 1;\r\n        Arrays.fill(result,Integer.MAX_VALUE);\r\n        for(int i =0; i < s.length(); i ++){\r\n            if(s.charAt(i) == c){\r\n                cur = i;\r\n            }\r\n            \r\n            result[i] = Math.min(result[i], Math.abs(cur - i));\r\n        }\r\n        \r\n        cur = 0;\r\n        for(int i =s.length() - 1; i >=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cur = i;\r\n            }\r\n            result[i] = Math.min(result[i], Math.abs(cur - i));\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837685280",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\nIterate the array from left to right, then from right to left to find optimal solution\r\n## 关键点\r\nInitialized Array to Integer.MAX_VALUE since we will be using Math.min function;\r\nWhen we first start iterating , assume the matching character will be on the other end.\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int [] result = new int[s.length()];\r\n        int cur = s.length() - 1;\r\n        Arrays.fill(result,Integer.MAX_VALUE);\r\n        for(int i =0; i < s.length(); i ++){\r\n            if(s.charAt(i) == c){\r\n                cur = i;\r\n            }\r\n            \r\n            result[i] = Math.min(result[i], Math.abs(cur - i));\r\n        }\r\n        \r\n        cur = 0;\r\n        for(int i =s.length() - 1; i >=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cur = i;\r\n            }\r\n            result[i] = Math.min(result[i], Math.abs(cur - i));\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "minuet-red": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836115382",
      "body": "### **题目地址(989. 数组形式的整数加法)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 数组转数字\r\n1. 数字相加\r\n2. 数字转数组\r\n```\r\n\r\n### **代码**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        tmp = 0\r\n        for i in num:\r\n            tmp = tmp * 10 + i   # 数组转数字\r\n        tmp += k      # 加法运算\r\n        result = []\r\n        for j in str(tmp):    # 数字转数组\r\n            result.append(int(j))\r\n        \r\n        return result\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n)\r\n1. 空间复杂度：O(n)\r\n```\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838285144",
      "body": "### **题目地址(821. 字符的最短距离)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n- 字符串 S 的长度范围为 [1, 10000]。\r\n- C 是一个单字符，且保证是字符串 S 里的字符。\r\n- S 和 C 中的所有字母均为小写字母。\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察数组的遍历(正向遍历和反向遍历)\r\n我的思路\r\n1. 对于字符串s的每一个字符，如果该字符等于c，输出0，进行下一个循环\r\n2. 对于字符串s的每一个字符，如果该字符不等于c，往前往后分别查找c,\r\n\t- 一方找不到c，输出另一方距离\r\n\t- 都找得到c，记录两个距离\r\n3. 输出两个距离中的最小值\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        slength = len(s)\r\n        res = []\r\n        for i in range(slength):\r\n            if s[i] == c:\r\n                res.append(0)\r\n                continue\r\n            j = i\r\n            k = i\r\n            while(s[j] != c):\r\n                j -= 1\r\n                if j < 0:\r\n                    break  \r\n                \r\n            while(s[k] != c):\r\n                k += 1\r\n                if k >= slength:\r\n                    break\r\n                    \r\n            la = i-j    \r\n            lb = k-i    \r\n            if j < 0: \r\n                res.append(lb)\r\n            elif k >= slength:\r\n                res.append(la) \r\n            else:\r\n                res.append(min(la, lb))\r\n        return res\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n·k)，n是字符串的长度，k是查找到字符c的长度\r\n1. 空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838285144",
      "body": "### **题目地址(821. 字符的最短距离)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n- 字符串 S 的长度范围为 [1, 10000]。\r\n- C 是一个单字符，且保证是字符串 S 里的字符。\r\n- S 和 C 中的所有字母均为小写字母。\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察数组的遍历(正向遍历和反向遍历)\r\n我的思路\r\n1. 对于字符串s的每一个字符，如果该字符等于c，输出0，进行下一个循环\r\n2. 对于字符串s的每一个字符，如果该字符不等于c，往前往后分别查找c,\r\n\t- 一方找不到c，输出另一方距离\r\n\t- 都找得到c，记录两个距离\r\n3. 输出两个距离中的最小值\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        slength = len(s)\r\n        res = []\r\n        for i in range(slength):\r\n            if s[i] == c:\r\n                res.append(0)\r\n                continue\r\n            j = i\r\n            k = i\r\n            while(s[j] != c):\r\n                j -= 1\r\n                if j < 0:\r\n                    break  \r\n                \r\n            while(s[k] != c):\r\n                k += 1\r\n                if k >= slength:\r\n                    break\r\n                    \r\n            la = i-j    \r\n            lb = k-i    \r\n            if j < 0: \r\n                res.append(lb)\r\n            elif k >= slength:\r\n                res.append(la) \r\n            else:\r\n                res.append(min(la, lb))\r\n        return res\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n·k)，n是字符串的长度，k是查找到字符c的长度\r\n1. 空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "LexieLiu01": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836117591",
      "body": "`\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        carry = 0\r\n        for i in range(len(A) - 1, -1, -1):\r\n        A[i], carry = (carry + A[i] + K % 10) % 10, (carry + A[i] + K % 10) // 10\r\n        K //= 10\r\n        B = []\r\n        carry = carry + K\r\n        while carry:\r\n        B = [(carry) % 10] + B\r\n        carry //= 10\r\n    return B + A\r\n\r\n`"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838334269",
      "body": "class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r = i\r\n            \r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            \r\n            if l == -1:\r\n                l = -10000\r\n            if r == len(s):\r\n                r = 20000\r\n            ans.append(min(r-i,i-l))\r\n            \r\n        return ans"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838334269",
      "body": "class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r = i\r\n            \r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            \r\n            if l == -1:\r\n                l = -10000\r\n            if r == len(s):\r\n                r = 20000\r\n            ans.append(min(r-i,i-l))\r\n            \r\n        return ans"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "HackBL": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836118591",
      "body": "* 思路：Array从后往前遍历，每遍历一次，加上k，取总和的个位数，存入到list中。k /= 10，为下一个元素做准备。 遍历整个数组，如果k还存在数字（即 != 0)，继续遍历k，一一存入到list中\r\n* 误区：最开始使用int，把数组和k的数字相加在一起，导致integer overflow\r\n* 语言：Java\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList<>();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        while (k != 0) {\r\n            list.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n* 时间：O(n), n: max(nums.length, k的长度)\r\n* Space: O(n), n: max(nums.length, k的长度)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837785007",
      "body": "* 思路：先正序，再倒序\r\n正序：所有在s中的元素（除了c元素），以其左边的c为参照物，求出距离，并存在answer中。若元素的左边没有参照物c，则存入string.length()与当前index的差值。\r\n倒序：所有在s中的元素（除了c元素），以其右边的c为参照物，求出最小距离（min(answer[o], pos-1)），并存在answer中。\r\n若当前元素为c，answer当前index的元素为0\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int pos = -n;\r\n        int[] answer = new int[n];\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) pos = i;\r\n            answer[i] = i - pos;\r\n        }\r\n        \r\n        for (int i = pos; i >= 0; i--) {\r\n            if (s.charAt(i) == c) pos = i;\r\n            answer[i] = Math.min(answer[i], pos - i);\r\n        }\r\n        \r\n        return answer;\r\n    }\r\n}\r\n```\r\n* 时间：O(n)， n为s的长度\r\n* 空间：O(n)， 建立新数组answer，长度为n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837785007",
      "body": "* 思路：先正序，再倒序\r\n正序：所有在s中的元素（除了c元素），以其左边的c为参照物，求出距离，并存在answer中。若元素的左边没有参照物c，则存入string.length()与当前index的差值。\r\n倒序：所有在s中的元素（除了c元素），以其右边的c为参照物，求出最小距离（min(answer[o], pos-1)），并存在answer中。\r\n若当前元素为c，answer当前index的元素为0\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int pos = -n;\r\n        int[] answer = new int[n];\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) pos = i;\r\n            answer[i] = i - pos;\r\n        }\r\n        \r\n        for (int i = pos; i >= 0; i--) {\r\n            if (s.charAt(i) == c) pos = i;\r\n            answer[i] = Math.min(answer[i], pos - i);\r\n        }\r\n        \r\n        return answer;\r\n    }\r\n}\r\n```\r\n* 时间：O(n)， n为s的长度\r\n* 空间：O(n)， 建立新数组answer，长度为n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "xixi-jiu": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836121004",
      "body": "### 思路\r\n\r\n利用 加一 那道题的思路 从个位加起\r\n最后还要处理 k 大于 0 的情况\r\n例如：num = [0];k = 23 \r\n\r\n不明白为什么耗时很多 200+ms\r\n### 代码\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    const len = num.length;\r\n    let res = [];\r\n    for (let i = len - 1;i >= 0;i--) {\r\n        let sum = num[i] + (k % 10);\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n            res.unshift(sum);\r\n        } else {\r\n            res.unshift(sum);\r\n        }\r\n    }\r\n    while (k > 0) {\r\n        res.unshift(k % 10);\r\n        k = Math.floor(k / 10);\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837644356",
      "body": "/* 思路\r\n- 遍历字符串\r\n- 从每个字符的左边和右边分别开始寻找目标字符\r\n- 如果找到了, 结束遍历\r\n- 如果没有找到, 给下标赋值无穷大\r\n- 选择较近的距离即可\r\n*/ \r\n// 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let res = [];\r\n    for (let i = 0;i < s.length;i++) {\r\n        let left = i, right = i;\r\n        while (left >= 0) {\r\n            if (s[left] === c) {\r\n                break;\r\n            }\r\n            left--;\r\n        }\r\n        while (right < s.length) {\r\n            if (s[right] === c) {\r\n                break;\r\n            }\r\n            right++;\r\n        }\r\n        // 如果没有找到\r\n        if (left === -1) left = -Infinity;\r\n        if (right === s.length) right = Infinity;\r\n        // 选择较近的距离\r\n        res[i] = Math.min((i - left), (right - i));\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(N ^ 2)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n*/"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837644356",
      "body": "/* 思路\r\n- 遍历字符串\r\n- 从每个字符的左边和右边分别开始寻找目标字符\r\n- 如果找到了, 结束遍历\r\n- 如果没有找到, 给下标赋值无穷大\r\n- 选择较近的距离即可\r\n*/ \r\n// 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let res = [];\r\n    for (let i = 0;i < s.length;i++) {\r\n        let left = i, right = i;\r\n        while (left >= 0) {\r\n            if (s[left] === c) {\r\n                break;\r\n            }\r\n            left--;\r\n        }\r\n        while (right < s.length) {\r\n            if (s[right] === c) {\r\n                break;\r\n            }\r\n            right++;\r\n        }\r\n        // 如果没有找到\r\n        if (left === -1) left = -Infinity;\r\n        if (right === s.length) right = Infinity;\r\n        // 选择较近的距离\r\n        res[i] = Math.min((i - left), (right - i));\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(N ^ 2)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n*/"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Daniel-Zheng": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836131939",
      "body": "### 思路\r\n\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int length = num.size();\r\n        int current = k;\r\n        \r\n        while (--length >=0 || current > 0) {\r\n            if (length >= 0) current += num[length];\r\n            res.push_back(current % 10);\r\n            current /= 10;\r\n        }\r\n        \r\n        reverse(res.begin(), res.end());\r\n        return res; \r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837622983",
      "body": "### 思路\r\n\r\n正反遍历\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size());\r\n        int current = 99999;\r\n        \r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) current = i;\r\n            res[i] = abs(i - current);\r\n        }\r\n        \r\n        current = 99999;\r\n        for (int j = s.size() - 1; j >= 0; j--) {\r\n            if (s[j] == c) current = j;\r\n            res[j] = min(abs(j - current), res[j]);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837622983",
      "body": "### 思路\r\n\r\n正反遍历\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size());\r\n        int current = 99999;\r\n        \r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) current = i;\r\n            res[i] = abs(i - current);\r\n        }\r\n        \r\n        current = 99999;\r\n        for (int j = s.size() - 1; j >= 0; j--) {\r\n            if (s[j] == c) current = j;\r\n            res[j] = min(abs(j - current), res[j]);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "hannahliu-github": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836142144",
      "body": "思路：先把str变成int；加上k；再转回str，放进list里\r\n\r\n代码：python\r\n\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        x = int(''.join([str(s) for s in num]))\r\n        ans = x + k\r\n        array_form = [int(s) for s in str(ans)]\r\n        return array_form\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "yunli2015": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836150346",
      "body": "**思路**： 和add string一样，从末尾往前遍历，用sum， carry 记录\r\n**代码**：java\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int carry = 0, sum =0;\r\n        List<Integer> list = new ArrayList<>();\r\n        if(num.length == 0) return list;\r\n        int i= num.length - 1;\r\n        while(i>=0 || k != 0) {\r\n            sum = carry;\r\n            if(i >= 0) {\r\n                sum += num[i];\r\n                i--;\r\n            }\r\n            if(k != 0) {\r\n                sum += k %10;\r\n                k = k/10;\r\n            }\r\n            list.add(0, sum %10);\r\n            carry = sum /10;\r\n        }\r\n\r\n        if(carry != 0) list.add(0, carry);\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析：**\r\n时间复杂度：O（n）\r\n空间复杂度：O（1）"
    },
    null,
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839942156",
      "body": "two passes, one from left and one from right\r\n\r\njava\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int prev = Integer.MIN_VALUE /2;\r\n        \r\n        int[] ans = new int[s.length()];\r\n        \r\n        for(int i=0; i<s.length(); i++) {\r\n            if(c == s.charAt(i)) {\r\n                prev = i;\r\n            }\r\n            ans[i] = i-prev;\r\n        }\r\n        \r\n        prev = Integer.MAX_VALUE /2;\r\n        for(int i=s.length() - 1; i>=0; i--) {\r\n            if(c == s.charAt(i)) {\r\n                prev = i;\r\n            }\r\n            ans[i] = Math.min(prev - i, ans[i]);\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\nT: O(N)\r\nS: O(N)? the size of ans[i]"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Xeraphinite": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836152663",
      "body": "### 思路\r\n模拟即可，需要注意最终返回数组的长度\r\n\r\n### 时空复杂度\r\n**时间复杂度**：O(max(log(k), n))，只进行了一次遍历\r\n**空间复杂度**：O(1)，除了存储结果的 `vector` 之外没有用到额外的变量\r\n\r\n### Code\r\n\r\n#### C++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n      reverse(num.begin(), num.end());\r\n      int n = num.size(), i = 0;\r\n      vector<int> ans(max(n, (int)to_string(k).size()) + 1, 0);\r\n      while (i < n || k) {\r\n        ans[i] += (i < n ? num[i] : 0) + k % 10; \r\n        ans[i + 1] += ans[i] / 10, ans[i] %= 10;\r\n        k /= 10, i++;\r\n      }\r\n      if (ans.back() == 0) ans.pop_back();\r\n      return vector<int>(ans.rbegin(), ans.rend());\r\n    }\r\n};\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838309562",
      "body": "### 思路\r\n记录下标，并从前后两次遍历分别更新值。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n      int n = s.size();\r\n      vector<int> res(n, 0), nextC;\r\n      for (int i = 0; i < n; i++)\r\n        if (s[i] == c) nextC.emplace_back(i);\r\n      int m = nextC.size();\r\n      for (int i = 0, j = 0; i < n; i++) {\r\n        res[i] = abs(nextC[j] - i);\r\n        if (j < m - 1 && nextC[j] == i) j++;\r\n      }\r\n      for (int i = n - 1, j = m - 1; i >= 0; i--) {\r\n        res[i] = min(abs(nextC[j] - i), res[i]);\r\n        if (j > 0 && nextC[j] == i) j--;\r\n      }\r\n      return res;\r\n    }\r\n};\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838309562",
      "body": "### 思路\r\n记录下标，并从前后两次遍历分别更新值。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n      int n = s.size();\r\n      vector<int> res(n, 0), nextC;\r\n      for (int i = 0; i < n; i++)\r\n        if (s[i] == c) nextC.emplace_back(i);\r\n      int m = nextC.size();\r\n      for (int i = 0, j = 0; i < n; i++) {\r\n        res[i] = abs(nextC[j] - i);\r\n        if (j < m - 1 && nextC[j] == i) j++;\r\n      }\r\n      for (int i = n - 1, j = m - 1; i >= 0; i--) {\r\n        res[i] = min(abs(nextC[j] - i), res[i]);\r\n        if (j > 0 && nextC[j] == i) j--;\r\n      }\r\n      return res;\r\n    }\r\n};\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "sumukeio": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836153578",
      "body": "思路：由低位到高位将数字逐位相加\r\nwhile(A没完 ||B没完)\r\n     A的当前位\r\n     B的当前位\r\n\r\n    和 = A的当前位 + B的当前位 + 进位carry;\r\n\r\n当前位  = 和 % 10;\r\n进位 = 和/10;\r\n\r\n判断还有进位么？\r\n\r\n代码：\r\nint* addToArrayForm(int* A, int ASize, int K, int* returnSize)\r\n{\r\n     int len = fmax(ASize, 5) + 1;//防止越界\r\n     int *res = (int*)malloc(sizeof(int) * len);\r\n     int i = ASize - 1;\r\n     int idx = 0;\r\n//k不为0，数组数据未处理完，继续处理\r\nwhile(k !=0 || i>=0)\r\n{\r\n    k += ( i >= 0) ? A[ i--]  : 0;\r\n    res[ --len] = k % 10;\r\n    k /= 10;\r\n    idx++;\r\n}\r\n*returnSize = idx;\r\nreturn res + len;\r\n}\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838112294",
      "body": "思路：第一次从左到右遍历到最左端最短的距离，第二次从右到左遍历到最右端最短的距离\r\n代码：\r\nint* shortestToChar(char* s, char c, int* returnSize){\r\nint len=strlens(s);\r\nint* a=(int*)malloc(sizeof(int)*len);\r\nint count=0;\r\nfor(int i=0;i<len;i++){\r\nif(s[i]==c){\r\na[count++]=0;\r\n}else{\r\nint left=10001,right=10001;\r\nfor(int j=i+1;j<len;j++){\r\nif(s[j]==c){\r\nright=j;\r\nbreak;\r\n}\r\n}\r\nfor(int x=i-1;x>=0;x--){\r\nif(s[x]==c){\r\nleft=x;\r\nbreak;\r\n}\r\n}\r\nright=fmin(abs(i-left),abs(i-right));\r\na[count++]=right;\r\n}\r\n}\r\n*returnSize=len;\r\nreturn a;\r\n}\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838112294",
      "body": "思路：第一次从左到右遍历到最左端最短的距离，第二次从右到左遍历到最右端最短的距离\r\n代码：\r\nint* shortestToChar(char* s, char c, int* returnSize){\r\nint len=strlens(s);\r\nint* a=(int*)malloc(sizeof(int)*len);\r\nint count=0;\r\nfor(int i=0;i<len;i++){\r\nif(s[i]==c){\r\na[count++]=0;\r\n}else{\r\nint left=10001,right=10001;\r\nfor(int j=i+1;j<len;j++){\r\nif(s[j]==c){\r\nright=j;\r\nbreak;\r\n}\r\n}\r\nfor(int x=i-1;x>=0;x--){\r\nif(s[x]==c){\r\nleft=x;\r\nbreak;\r\n}\r\n}\r\nright=fmin(abs(i-left),abs(i-right));\r\na[count++]=right;\r\n}\r\n}\r\n*returnSize=len;\r\nreturn a;\r\n}\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Mvbbb": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836163931",
      "body": "# 思路\r\n\r\n按照竖式的个位加法来相加\r\n\r\n\r\n# 代码\r\n\r\n```java\r\nclass Solution{\r\n    public List<Integer> addToArrayForm(int[] num,int k){\r\n        int len = num.length;\r\n        int lastNum = k;\r\n        int i = len-1;\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        while(i>=0||lastNum>0){  // 循环条件: 没有遍历完num或者lastNum中的数还没有全部插入到 list 中\r\n            if(i>=0){ \r\n                lastNum+=num[i]; // 加上一个个位数\r\n            }\r\n            list.addFirst(lastNum%10); // 每一次循环都需要从 lastNum 末尾取一个数放到 list 中\r\n            lastNum/=10;\r\n            i--;\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838027915",
      "body": "**刚开始的思路：**\r\n\r\n遍历一遍数组， 找到 c 的位置的集合。\r\n在遍历一次数组，如果当前元素不是 c，就计算出当前元素下标到哪个c下标最近。\r\n\r\n时间复杂度 O(Nk) 。k 是 c 出现的次数\r\n\r\n**看了题解之后的思路：**\r\n\r\n\r\n离一个字符最近的 c 要不然是它右边最近的一个 c，要不然在它左边最近的一个 c\r\n\r\n遍历两次字符串\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] left = new int[s.length()]; \r\n        int[] right = new int[s.length()];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        int behind = Integer.MAX_VALUE/2;\r\n        for(int i=0,j=s.length()-1;i<s.length();i++,j--){\r\n            if(s.charAt(i)==c){\r\n                prev = i;\r\n                left[i]=0;\r\n            }else{\r\n                left[i]=i-prev;\r\n            }\r\n            if(s.charAt(j)==c){\r\n                behind = j;\r\n                right[j]=0;\r\n            }else{\r\n                right[j]=behind-j;\r\n            }            \r\n        }\r\n\r\n        for(int i=0;i<left.length;i++){\r\n            left[i]= Math.min(left[i],right[i]);\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度 O(N）\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838027915",
      "body": "**刚开始的思路：**\r\n\r\n遍历一遍数组， 找到 c 的位置的集合。\r\n在遍历一次数组，如果当前元素不是 c，就计算出当前元素下标到哪个c下标最近。\r\n\r\n时间复杂度 O(Nk) 。k 是 c 出现的次数\r\n\r\n**看了题解之后的思路：**\r\n\r\n\r\n离一个字符最近的 c 要不然是它右边最近的一个 c，要不然在它左边最近的一个 c\r\n\r\n遍历两次字符串\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] left = new int[s.length()]; \r\n        int[] right = new int[s.length()];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        int behind = Integer.MAX_VALUE/2;\r\n        for(int i=0,j=s.length()-1;i<s.length();i++,j--){\r\n            if(s.charAt(i)==c){\r\n                prev = i;\r\n                left[i]=0;\r\n            }else{\r\n                left[i]=i-prev;\r\n            }\r\n            if(s.charAt(j)==c){\r\n                behind = j;\r\n                right[j]=0;\r\n            }else{\r\n                right[j]=behind-j;\r\n            }            \r\n        }\r\n\r\n        for(int i=0;i<left.length;i++){\r\n            left[i]= Math.min(left[i],right[i]);\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度 O(N）\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "thisisandy": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836172220",
      "body": "# 思路\r\n各位依次相加\r\n\r\n# 代码\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    const num2 = []\r\n    const result = []\r\n    let diff = k\r\n    while(diff){\r\n        const unit = diff%10\r\n        num2.unshift(unit)\r\n        diff = Math.floor(diff/10)\r\n    }\r\n    let a;\r\n    let b;\r\n    let bonus = 0;\r\n    while(bonus || num.length || num2.length){\r\n        a = num.pop() || 0 \r\n        b = num2.pop() || 0\r\n        const sum = a + b + bonus\r\n        const unit = (sum) % 10\r\n        bonus = Math.floor((sum)/10)\r\n        result.unshift(unit)\r\n    }\r\n    return result\r\n};\r\n```\r\n# 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837700548",
      "body": "```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let lastPosition = - Infinity;\r\n    const result = []\r\n    for(let i =0; i< s.length; i++){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = i - lastPosition\r\n    }\r\n    for(let i =s.length-1; i>=0; i--){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = Math.min(Math.abs(i-lastPosition),result[i])\r\n    }\r\n    return result\r\n};\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837700548",
      "body": "```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let lastPosition = - Infinity;\r\n    const result = []\r\n    for(let i =0; i< s.length; i++){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = i - lastPosition\r\n    }\r\n    for(let i =s.length-1; i>=0; i--){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = Math.min(Math.abs(i-lastPosition),result[i])\r\n    }\r\n    return result\r\n};\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "wangzqnb": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836191824",
      "body": "语言： java\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n\tint i = len - 1, sum = 0, carry = 0, res = 0;\r\n\tList<Integer> list = new ArrayList<>();\r\n\twhile (i >= 0 || k != 0) {\r\n\t\tsum = (i >= 0 ? num[i] : 0) + (k != 0 ? k % 10 : 0) + carry;\r\n\t\tcarry = sum / 10;\r\n\t\tres = sum % 10;\r\n\t\tlist.add(res);\r\n\t\tk /= 10;\r\n\t\ti--;\r\n\t}\r\n        if (carry!=0) list.add(carry);\r\n\tCollections.reverse(list);\r\n\treturn list;\r\n    }\r\n}\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837839988",
      "body": "左右两次遍历，参考了官方的解题方法加入了自己的思路\r\n\r\n**java**\r\n```\r\nclass Solution {\r\n\tpublic int[] shortestToChar(String s, char c) {\r\n\t\tint len = s.length(), prev = s.indexOf(c);\r\n\t\tint[] res = new int[len];\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tif (s.charAt(i) == c) prev = i;\r\n\t\t\tint tmp = i - prev;\r\n\t\t\tres[i] = tmp >= 0 ? tmp : -tmp;\r\n\t\t}\r\n\t\tprev = s.lastIndexOf(c);\r\n\t\tfor (int i = len - 1; i >= 0; i--) {\r\n\t\t\tif (s.charAt(i) == c) prev = i;\r\n\t\t\tint tmp = i - prev;\r\n\t\t\ttmp = tmp >= 0 ? tmp : -tmp;\r\n\t\t\tres[i] = tmp >= res[i] ? res[i] : tmp;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n}\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837839988",
      "body": "左右两次遍历，参考了官方的解题方法加入了自己的思路\r\n\r\n**java**\r\n```\r\nclass Solution {\r\n\tpublic int[] shortestToChar(String s, char c) {\r\n\t\tint len = s.length(), prev = s.indexOf(c);\r\n\t\tint[] res = new int[len];\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tif (s.charAt(i) == c) prev = i;\r\n\t\t\tint tmp = i - prev;\r\n\t\t\tres[i] = tmp >= 0 ? tmp : -tmp;\r\n\t\t}\r\n\t\tprev = s.lastIndexOf(c);\r\n\t\tfor (int i = len - 1; i >= 0; i--) {\r\n\t\t\tif (s.charAt(i) == c) prev = i;\r\n\t\t\tint tmp = i - prev;\r\n\t\t\ttmp = tmp >= 0 ? tmp : -tmp;\r\n\t\t\tres[i] = tmp >= res[i] ? res[i] : tmp;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n}\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "hengyi666": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836198313",
      "body": "**思路：**\r\n• 判断长度\r\n• 考虑进位\r\n• 考虑越位开辟新空间\r\n• 正序输入，倒序输出\r\n### \r\n**力扣python打卡**\r\n\r\n\r\n```\r\n#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\nvoid  addToArrayForm(int* A, int ASize, int K)\r\n{\r\n\t//计算K的位数\r\n\tint len = 0;\r\n\tint tmp = K;\r\n\twhile (tmp)\r\n\t{\r\n\t\tlen++;\r\n\t\ttmp /= 10;\r\n\t}\r\n\t//开辟空间，注意最高位可能存在进位的情况\r\n\tint arrLen = ASize > len ? ASize + 1 : len + 1;\r\n\tint* arr = (int*)malloc(sizeof(int) * arrLen);\r\n\t//逐位相加\r\n\tint index = 0;\r\n\tint end = ASize - 1;\r\n\tint step = 0;\r\n\twhile (end >= 0 || K > 0)\r\n\t{\r\n\t\tint cursum = step;\r\n\t\tif (end >= 0)\r\n\t\t{\r\n\t\t\tcursum += A[end];\r\n\t\t}\r\n\t\tif (K > 0)\r\n\t\t{\r\n\t\t\tcursum += (K % 10);\r\n\t\t}\r\n\t\t//如果位数的值超过9需要进位\r\n\t\tif (cursum > 9)\r\n\t\t{\r\n\t\t\tstep = 1;\r\n\t\t\tcursum -= 10;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tstep = 0;\r\n\t\t}\r\n\t\tarr[index++] = cursum;\r\n\t\tend--;\r\n\t\tK /= 10;\r\n\t}\r\n\t//判断最高位是否存在进位\r\n\tif (step == 1)\r\n\t{\r\n\t\tarr[index++] = step;\r\n\t}\r\n\t//为了方便对数组进行尾插，所以数据是逆序存储，故要对数组进行逆序操作。\r\n\tint start = 0;\r\n\tend = index - 1;\r\n\twhile (start < end)\r\n\t{\r\n\t\tint tmp = arr[start];\r\n\t\tarr[start] = arr[end];\r\n\t\tarr[end] = tmp;\r\n\t\tstart++;\r\n\t\tend--;\r\n\t}\r\n\tfor (int i = 0; i < index; ++i)\r\n\t\tprintf(\"%d \", *(arr + i));\r\n}\r\n//主函数\r\nint main() {\r\n\t\tint a[10] = {};\r\n\t\tint Asize, k;\r\n\t\tprintf(\"想输入几位数组？：\\n\");\r\n\t\tscanf_s(\"%d\", &Asize);\r\n\t\tprintf(\"请输入数组：\\n\");\r\n\t\tfor (int i = 0; i < Asize; i++) {\r\n\t\t\tscanf_s(\"%d\", &a[i]);\r\n\t\t}\r\n\t\tprintf(\"请输入0~10000的整数：\\n\");\r\n\t\tscanf_s(\"%d\", &k);\r\n\taddToArrayForm(a, Asize, k);\r\n\treturn 0;\r\n}\r\n//分为1.判断位数2.逐位相加3.进位4.越位5.逆序\r\n```\r\n**复杂度**\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837733723",
      "body": "**思路**\r\n1.获取目标在s中的下标\r\n2.从头开始，比较相邻2个的目标\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        location = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                location.append(i) # 获取目标在s中的下标\r\n        k = 0\r\n        whole = len(location)-1\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=whole and abs(i-location[k])>abs(i-location[k+1]):\r\n                k += 1\r\n            res.append(abs(i-location[k]))\r\n        return res\r\n```\r\n**复杂度分析**\r\n\r\n- 时间:O(n)\r\n\r\n- 空间:O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837733723",
      "body": "**思路**\r\n1.获取目标在s中的下标\r\n2.从头开始，比较相邻2个的目标\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        location = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                location.append(i) # 获取目标在s中的下标\r\n        k = 0\r\n        whole = len(location)-1\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=whole and abs(i-location[k])>abs(i-location[k+1]):\r\n                k += 1\r\n            res.append(abs(i-location[k]))\r\n        return res\r\n```\r\n**复杂度分析**\r\n\r\n- 时间:O(n)\r\n\r\n- 空间:O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "nanwy": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836213176",
      "body": "思路\r\n1.各位相加，如果进位，将k加1，把相加后的数对10取余放入数组，最后反转数组\r\n\r\n代码（js）\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [],carry=0;\r\n    for(let i=num.length-1;i>=0;i--){\r\n        let sum = num[i] + k % 10\r\n        k = k / 10 | 0\r\n        if(sum > 9){\r\n            k++\r\n        }\r\n        res.push(sum % 10)\r\n    }\r\n    while(k != 0){\r\n        res.push(k % 10)\r\n        k = k / 10 | 0\r\n    }\r\n    return res.reverse()\r\n};\r\n```\r\n        \r\n复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837737014",
      "body": "## 思路：先进行遍历，碰到c后，派出两个指针分别向左向右，取最小值。\r\n```js\r\nvar shortestToChar = function (s, c) {\r\n        let i = 0,res = Array(s.length).fill(Infinity);\r\n        while (i < s.length) {\r\n                if (s[i] !== c) {\r\n                        let l = i - 1,\r\n                                r = i + 1;\r\n                        while (s[l] != c && l > 0) {\r\n                                l--;\r\n                        }\r\n                        while (s[r] != c && r < s.length - 1) {\r\n                                r++;\r\n                        }\r\n                        let left = s[l] == c ? i - l : Infinity;\r\n                        let right = s[r] == c ? r - i : Infinity;\r\n                        let ans = Math.min(left, right);\r\n                        // console.log(ans)\r\n                        res[i] = ans;\r\n                } else {\r\n                        res[i] = 0;\r\n                }\r\n                i++;\r\n        }\r\n        // console.log(res)\r\n        return res;\r\n};\r\n```\r\n## 复杂度分析\r\n\r\n- 时间：O(n^2)\r\n- 空间：O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837737014",
      "body": "## 思路：先进行遍历，碰到c后，派出两个指针分别向左向右，取最小值。\r\n```js\r\nvar shortestToChar = function (s, c) {\r\n        let i = 0,res = Array(s.length).fill(Infinity);\r\n        while (i < s.length) {\r\n                if (s[i] !== c) {\r\n                        let l = i - 1,\r\n                                r = i + 1;\r\n                        while (s[l] != c && l > 0) {\r\n                                l--;\r\n                        }\r\n                        while (s[r] != c && r < s.length - 1) {\r\n                                r++;\r\n                        }\r\n                        let left = s[l] == c ? i - l : Infinity;\r\n                        let right = s[r] == c ? r - i : Infinity;\r\n                        let ans = Math.min(left, right);\r\n                        // console.log(ans)\r\n                        res[i] = ans;\r\n                } else {\r\n                        res[i] = 0;\r\n                }\r\n                i++;\r\n        }\r\n        // console.log(res)\r\n        return res;\r\n};\r\n```\r\n## 复杂度分析\r\n\r\n- 时间：O(n^2)\r\n- 空间：O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "surahe": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836217045",
      "body": "\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  将k 转换为数组 k_arr\r\n-  比较 k_arr 和 num 长度，将其中较长的一个的长度+1，定义为 max_length\r\n-  创建数组digit，长度为max_length，用来存储进位\r\n-  将 k_arr 和 num 长度补长到与 max_length相同\r\n-  从低位开始逐位计算，超过10则在digit 对应位置进1\r\n-  如果最高为是0，去除\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\nvar addToArrayForm = function (num, k) {\r\n  var result = []\r\n  var k_arr = k.toString().split('')\r\n  var max_length = num.length > k_arr.length ? num.length + 1 : k_arr.length + 1\r\n  var digit = Array(max_length).fill(0)\r\n  var now_res\r\n\r\n  for (var i = num.length; i < max_length; i++) {\r\n    num.unshift(0)\r\n  }\r\n  for (var i = k_arr.length; i < max_length; i++) {\r\n    k_arr.unshift(0)\r\n  }\r\n\r\n  for (var i = max_length - 1; i >= 0; i--) {\r\n    if (digit[i] + num[i] + +k_arr[i] >= 10) {\r\n      digit[i-1] = 1\r\n      now_res = digit[i] + num[i] + +k_arr[i] - 10\r\n    } else {\r\n      now_res = digit[i] + num[i] + +k_arr[i]\r\n    }\r\n    result.unshift(now_res)\r\n  }\r\n\r\n  if (result[0] === 0) {\r\n    result.shift()\r\n  } \r\n\r\n  return result\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(Max(num, k)+1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837820712",
      "body": "\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  用两个数组分别存储从左遍历向左比较（→）和从左遍历向右比较（←）的情况\r\n-  对于向右查找，如果数组长度不够，需要补99999\r\n- 对于向左查找，情况更复杂点。没遇到 c前都需要补99999，只要遇到一次以后就不需要再补99999。如果遍历结束，right 长度还不够，需要把k 遍历 push 进right\r\n- 比较 left、right 各项大小，取较小的\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  var length = s.length\r\n\r\n  var left = []\r\n  var i = 0\r\n  var j = 0\r\n\r\n  var right = []\r\n  var k = 0\r\n  var l = 0\r\n\r\n  while (i < length) {\r\n    if (s[i]!== c) {\r\n      j++\r\n    } else {\r\n      for (var index = j; index >= 0; index--) {\r\n        left.push(index)\r\n        j = 0\r\n      }\r\n    }\r\n    i++\r\n  }\r\n  for (var t1 = left.length; t1 < length; t1++) {\r\n    left.push(99999)\r\n  }\r\n\r\n  let flag = true\r\n  while (k < length) {\r\n    if (s[k] !== c) {\r\n      if (flag) {\r\n        right.push(99999)\r\n      } else {\r\n        l++\r\n      }\r\n    } else {\r\n      flag = false\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n      right.push(0)\r\n      l = 0\r\n    }\r\n    k++\r\n    if (k === length && l !== 0) {\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var i = 0; i < length ; i++) {\r\n    if (right[i] < left[i]) {\r\n      left[i] = right[i]\r\n    }\r\n  }\r\n  return left\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837820712",
      "body": "\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  用两个数组分别存储从左遍历向左比较（→）和从左遍历向右比较（←）的情况\r\n-  对于向右查找，如果数组长度不够，需要补99999\r\n- 对于向左查找，情况更复杂点。没遇到 c前都需要补99999，只要遇到一次以后就不需要再补99999。如果遍历结束，right 长度还不够，需要把k 遍历 push 进right\r\n- 比较 left、right 各项大小，取较小的\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  var length = s.length\r\n\r\n  var left = []\r\n  var i = 0\r\n  var j = 0\r\n\r\n  var right = []\r\n  var k = 0\r\n  var l = 0\r\n\r\n  while (i < length) {\r\n    if (s[i]!== c) {\r\n      j++\r\n    } else {\r\n      for (var index = j; index >= 0; index--) {\r\n        left.push(index)\r\n        j = 0\r\n      }\r\n    }\r\n    i++\r\n  }\r\n  for (var t1 = left.length; t1 < length; t1++) {\r\n    left.push(99999)\r\n  }\r\n\r\n  let flag = true\r\n  while (k < length) {\r\n    if (s[k] !== c) {\r\n      if (flag) {\r\n        right.push(99999)\r\n      } else {\r\n        l++\r\n      }\r\n    } else {\r\n      flag = false\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n      right.push(0)\r\n      l = 0\r\n    }\r\n    k++\r\n    if (k === length && l !== 0) {\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var i = 0; i < length ; i++) {\r\n    if (right[i] < left[i]) {\r\n      left[i] = right[i]\r\n    }\r\n  }\r\n  return left\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Serrust": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836227745",
      "body": "```import java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n/*\r\n * @lc app=leetcode id=989 lang=java\r\n *\r\n * [989] Add to Array-Form of Integer\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    /**\r\n     * Explanation:\r\n     * create an arraylist to store the answer.\r\n     * loop starting from the last element of input,\r\n     * here i use an example:\r\n     * for 123 + 912, where 123 is the integer represented by A and 912 is K\r\n     * we start with [1, 2, 3+912]. \r\n     * Then we perform the addition 3+912, leaving 915. \r\n     * The 5 stays as the digit, while we 'carry' 910 into the next column which becomes 91.\r\n     * We repeat this process with [1, 2+91, 5]. \r\n     * We have 93, where 3 stays and 90 is carried over as 9. \r\n     * Again, we have [1+9, 3, 5] which transforms into [1, 0, 3, 5].\r\n     * Complexity Analysis:\r\n     * Todo: why?\r\n     * Time: O(max(N, log K)) where N is the length of A\r\n     * Space: O(max(N,log K))\r\n     * @param A\r\n     * @param K\r\n     * @return\r\n     */\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        \r\n        int N = A.length;\r\n        int temp = K;\r\n        List<Integer> ans = new ArrayList<>();\r\n        \r\n        int i = N-1;\r\n        // Note: we are not sure if the integer that A represents is larger or k is larger\r\n        while (i >= 0 || temp > 0) {\r\n            // Note: we add this if condition because i can be negative if K is larger than the integer represented by A\r\n            if (i >= 0) {\r\n                temp += A[i];\r\n            }\r\n            ans.add(temp % 10);\r\n            temp /= 10;\r\n            i -= 1;\r\n        }\r\n        Collections.reverse(ans);\r\n\r\n        return ans;\r\n    }\r\n}\r\n// @lc code=end```\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838668830",
      "body": "```/*\r\n * @lc app=leetcode id=821 lang=java\r\n *\r\n * [821] Shortest Distance to a Character\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    /**\r\n     * Explanation:\r\n     * create an array to store the answers\r\n     * create int c_position and set it to a negative number\r\n     * iterate through the existing string by each character twice\r\n     * in the first loop, loop from the front\r\n     * in each iteration, the distance (from the left char c) = current position - c_position\r\n     * once char c is found, update c_position to the position of c\r\n     * then set c_position to a very large positive integer and start the second loop\r\n     * in the second loop, loop from the end\r\n     * in each iteration, the distance (from the right char c) = c_position - current position IF this distance is smaller than the distance we calculated in the first iteration\r\n     * return the array with the shortest distance\r\n     * \r\n     * Complexity Analysis:\r\n     * Time: O(n) since 2 iterations, each iteration length is n\r\n     * Space: O(n) since only an array with the length of input string is used\r\n     * \r\n     * @param S\r\n     * @param C\r\n     * @return\r\n     */\r\n    public int[] shortestToChar(String S, char C) {\r\n\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        \r\n        // NOTE: for this kind of problem, remember to use Interger.MIN_VALUE or Integer.MAX_VALUE to set min/max values\r\n        int cPosition = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < N; i++) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            ans[i] = i - cPosition;\r\n        }\r\n\r\n        cPosition = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            // NOTE: cPosition is larger or equal to current index i\r\n            ans[i] = Math.min(ans[i], cPosition - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n// @lc code=end\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838668830",
      "body": "```/*\r\n * @lc app=leetcode id=821 lang=java\r\n *\r\n * [821] Shortest Distance to a Character\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    /**\r\n     * Explanation:\r\n     * create an array to store the answers\r\n     * create int c_position and set it to a negative number\r\n     * iterate through the existing string by each character twice\r\n     * in the first loop, loop from the front\r\n     * in each iteration, the distance (from the left char c) = current position - c_position\r\n     * once char c is found, update c_position to the position of c\r\n     * then set c_position to a very large positive integer and start the second loop\r\n     * in the second loop, loop from the end\r\n     * in each iteration, the distance (from the right char c) = c_position - current position IF this distance is smaller than the distance we calculated in the first iteration\r\n     * return the array with the shortest distance\r\n     * \r\n     * Complexity Analysis:\r\n     * Time: O(n) since 2 iterations, each iteration length is n\r\n     * Space: O(n) since only an array with the length of input string is used\r\n     * \r\n     * @param S\r\n     * @param C\r\n     * @return\r\n     */\r\n    public int[] shortestToChar(String S, char C) {\r\n\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        \r\n        // NOTE: for this kind of problem, remember to use Interger.MIN_VALUE or Integer.MAX_VALUE to set min/max values\r\n        int cPosition = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < N; i++) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            ans[i] = i - cPosition;\r\n        }\r\n\r\n        cPosition = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            // NOTE: cPosition is larger or equal to current index i\r\n            ans[i] = Math.min(ans[i], cPosition - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n// @lc code=end\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "cicihou": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836239329",
      "body": "思路：\r\n将 array -> str -> int, 相加之后重新转换成array[int]\r\n\r\n代码：\r\n\r\n> class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # method 1 list iteration\r\n        # return [int(j) for j in str(int(''.join([str(i) for i in num])) + k)]\r\n\r\n        # method 2, same as method 1, use for-loop explicitly to analyze the complexity\r\n        # as following, the time complexity is O(n)\r\n        # the space complexity is O(1)\r\n        res = []\r\n        for i in num:\r\n            res.append(str(i))\r\n        res = str(int(''.join(res)) + k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n\r\n\r\n\r\n复杂度分析：\r\n\r\n令 n 为数组长度。\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n\r\n![Uploading image.png…]()\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837653863",
      "body": "思路\r\n遍历数组，将数组中命中c的值设为0并获得命中的c的index_list，其他值设为无穷大。\r\n再次遍历数组，将其与命中c的list index 做比较，获取绝对值大小\r\n\r\nPython Code:\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str):\r\n        res = []\r\n        zero_point = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                res.append(0)\r\n                zero_point.append(i)\r\n            else:\r\n                res.append(float('inf'))\r\n        for i in range(len(res)):\r\n            for j in zero_point:\r\n                if i != j:\r\n                    res[i] = min(res[i], abs(i-j))\r\n        return res\r\n```\r\n\r\n复杂度分析\r\n\r\n令 n 为字符串长度。\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837653863",
      "body": "思路\r\n遍历数组，将数组中命中c的值设为0并获得命中的c的index_list，其他值设为无穷大。\r\n再次遍历数组，将其与命中c的list index 做比较，获取绝对值大小\r\n\r\nPython Code:\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str):\r\n        res = []\r\n        zero_point = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                res.append(0)\r\n                zero_point.append(i)\r\n            else:\r\n                res.append(float('inf'))\r\n        for i in range(len(res)):\r\n            for j in zero_point:\r\n                if i != j:\r\n                    res[i] = min(res[i], abs(i-j))\r\n        return res\r\n```\r\n\r\n复杂度分析\r\n\r\n令 n 为字符串长度。\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "absent1353": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836244897",
      "body": "### 思路：\r\n将list转成数值，求和之后，分别取余/取除数，然后倒序输出\r\n### 代码：\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = 0\r\n        for n in num:\r\n            res = res * 10 + n \r\n        res += k\r\n        result = []\r\n        while(res>=0):\r\n            num = res%10\r\n            res/=10\r\n            result.append(num)\r\n        return result[::-1]\r\n```\r\n### 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838397776",
      "body": "## 思路\r\n- 1.空间换时间\r\n 先将给定字符出现的位置保存在一个下标数组中，遍历整个数组，求整个数组的值到下标数组的最小距离绝对值\r\n- 2.双指针方法\r\n#### 方法1\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        num = []\r\n        n = len(s)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                num.append(i)\r\n        result = []\r\n        for i in range(n):\r\n            result.append(min([abs(i-nu)for nu in num]))\r\n        return result\r\n```\r\n#### 方法2：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(s):\r\n            if x == c: prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```\r\n##复杂度分析\r\n- 1.空间换时间复杂度\r\n    时间复杂度为$O(N*K)$\r\n    空间复杂度为$O(N)$\r\n- 2.双指针方法\r\n    时间复杂度为 $O(n)$\r\n    空间复杂度为$O(1)$"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838397776",
      "body": "## 思路\r\n- 1.空间换时间\r\n 先将给定字符出现的位置保存在一个下标数组中，遍历整个数组，求整个数组的值到下标数组的最小距离绝对值\r\n- 2.双指针方法\r\n#### 方法1\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        num = []\r\n        n = len(s)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                num.append(i)\r\n        result = []\r\n        for i in range(n):\r\n            result.append(min([abs(i-nu)for nu in num]))\r\n        return result\r\n```\r\n#### 方法2：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(s):\r\n            if x == c: prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```\r\n##复杂度分析\r\n- 1.空间换时间复杂度\r\n    时间复杂度为$O(N*K)$\r\n    空间复杂度为$O(N)$\r\n- 2.双指针方法\r\n    时间复杂度为 $O(n)$\r\n    空间复杂度为$O(1)$"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "aouos": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836268613",
      "body": "## 思路：\r\n从数组尾部取值与 K 相加\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n  const ans = [];\r\n  let len = num.length;\r\n\r\n  for (let i = len - 1; i >= 0 || k > 0; i--) {\r\n    if (i >= 0) {\r\n      k += num[i];\r\n    }\r\n    ans.push(k % 10);\r\n    k = parseInt(k / 10);\r\n  }\r\n\r\n  return ans.reverse();\r\n};\r\n```\r\n\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838192744",
      "body": "## 代码：\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  let ans = new Array(s.length).fill(10001);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      ans[i] = 0;\r\n      continue;\r\n    }\r\n    if (s[i - 1] !== void 0) {\r\n      ans[i] = ans[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let j = s.length - 1; j >= 0; j--) {\r\n    if (s[j + 1] !== void 0) {\r\n      ans[j] = Math.min(ans[j], ans[j + 1] + 1);\r\n    }\r\n  }\r\n\r\n  return ans;\r\n};\r\n```\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838192744",
      "body": "## 代码：\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  let ans = new Array(s.length).fill(10001);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      ans[i] = 0;\r\n      continue;\r\n    }\r\n    if (s[i - 1] !== void 0) {\r\n      ans[i] = ans[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let j = s.length - 1; j >= 0; j--) {\r\n    if (s[j + 1] !== void 0) {\r\n      ans[j] = Math.min(ans[j], ans[j + 1] + 1);\r\n    }\r\n  }\r\n\r\n  return ans;\r\n};\r\n```\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "wangyi123456": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836270960",
      "body": "## 题目思路\r\n1.拆开每一位，用进位相加\r\n2.当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n## 代码\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int sum = 0, carry = 0;\r\n        int i = num.length-1;\r\n        List<Integer> res = new LinkedList<Integer>();\r\n        while(i>=0 || k>0){\r\n            int x = i>=0? num[i]:0;\r\n            int y = k>0?  k%10:0;\r\n            sum = x+y+carry;\r\n            carry = sum/10;\r\n            i -= 1;\r\n            k = k/10;\r\n            res.add(0,sum%10);\r\n        }\r\n        if(carry!=0) res.add(0,carry);\r\n        return res;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度 max(n,k) n为数组长度，k为数字位数\r\n空间复杂度 max(n,k) n为数组长度，k为数字位数"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "lzcyx": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836272330",
      "body": "# c++\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int>ans;int carry=0;\r\n        for(int i=num.size()-1;i>=0;i--)\r\n        {\r\n            int a=k%10;k/=10;\r\n            int b=(num[i]+a+carry)%10;\r\n            carry=(num[i]+a+carry)/10;\r\n            ans.push_back(b);\r\n        }\r\n        while(k>0||carry>0)\r\n        {   int b=k%10;k/=10;\r\n            ans.push_back((b+carry)%10);\r\n            carry=(b+carry)/10;\r\n        }\r\n        reverse(ans.begin(),ans.end());\r\n         return ans;\r\n    }\r\n};\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838286251",
      "body": "### 解题思路\r\n参考官方题解，用`pre`存储上一个c出现的位置，当```s[i]=c```时更新```pre=i```\r\n先从左到右遍历，`i-pre`即为到改字符往左到c的距离\r\n在从右到左遍历，`pre-i`即为到改字符往右到c的距离，取左右距离的最小值\r\n### 代码\r\n### c++\r\n```class Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int>ans(s.size());\r\n        int i,pre=-999999;\r\n        for(i=0;i<s.size();i++)\r\n        {\r\n            if(s[i]==c)pre=i;\r\n            ans[i]=i-pre;\r\n        }\r\n        pre=999999;\r\n        for(i=s.size()-1;i>=0;i--)\r\n        {\r\n            if(s[i]==c)pre=i;\r\n            ans[i]=min(ans[i],pre-i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838286251",
      "body": "### 解题思路\r\n参考官方题解，用`pre`存储上一个c出现的位置，当```s[i]=c```时更新```pre=i```\r\n先从左到右遍历，`i-pre`即为到改字符往左到c的距离\r\n在从右到左遍历，`pre-i`即为到改字符往右到c的距离，取左右距离的最小值\r\n### 代码\r\n### c++\r\n```class Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int>ans(s.size());\r\n        int i,pre=-999999;\r\n        for(i=0;i<s.size();i++)\r\n        {\r\n            if(s[i]==c)pre=i;\r\n            ans[i]=i-pre;\r\n        }\r\n        pre=999999;\r\n        for(i=s.size()-1;i>=0;i--)\r\n        {\r\n            if(s[i]==c)pre=i;\r\n            ans[i]=min(ans[i],pre-i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "linzeliang1222": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836279098",
      "body": "## 思路\r\n\r\n-   从最低位开始加，满10用carry进1，最后还要判断最终有没有进1位\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        ArrayList<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length - 1;\r\n        int carry = 0;\r\n\r\n        while (n >= 0 || k != 0) {\r\n            int a = n < 0 ? 0 : num[n];\r\n            int b = k % 10;\r\n\r\n            int temp = (a + b + carry) % 10;\r\n            carry = (a+ b + carry) / 10;\r\n            res.add(temp);\r\n            n--;\r\n            k /= 10;\r\n        }\r\n        if (carry == 1) {\r\n            res.add(1);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$\r\n- 空间复杂度：$O(N)$"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618559",
      "body": "## 思路\r\n\r\n-   使用一个res数组，而且要初始化为Integer.MAX_VALUE\r\n\r\n-   从左到右遍历字符串，直到遇到我们的目标字符时候停下来\r\n\r\n-   以目标字符为中心，pre和next双指针向两边移动，并且给数组赋值，从1开始递增\r\n\r\n-   如果指针再移动过程中遇到当前的值大于等于左边/右边的值，那么就结束该指针的移动\r\n\r\n    ![](https://img2020.cnblogs.com/blog/2067154/202011/2067154-20201102004404706-1773904769.png)\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nimport java.util.Arrays;\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int len = S.length();\r\n        int[] res = new int[len];\r\n        // 填充最大值\r\n        Arrays.fill(res, Integer.MAX_VALUE);\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            //每次遇到e时候，就进行pre和next的移动\r\n            if (S.charAt(i) == C) {\r\n                res[i] = 0;\r\n                int pre = i-1;\r\n                int next = i+1;\r\n                int t = 1;\r\n                // 赋值的条件是t要小于等于前一个/后一个元素的值\r\n                // 进行左移动赋值\r\n                while (pre >= 0 && t < res[pre]) {\r\n                    res[pre--] = t++;\r\n                }\r\n                t = 1;\r\n                // 进行右移动赋值\r\n                while (next < len && t < res[next]) {\r\n                    res[next++] = t++;\r\n                }\r\n            }\r\n        }\r\n        // 得到结果\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，其中 N 为字符串长度。\r\n- 空间复杂度：$O(N)$，其中 N 为res数组长度"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618559",
      "body": "## 思路1\r\n\r\n-   使用一个res数组，而且要初始化为Integer.MAX_VALUE\r\n\r\n-   从左到右遍历字符串，直到遇到我们的目标字符时候停下来\r\n\r\n-   以目标字符为中心，pre和next双指针向两边移动，并且给数组赋值，从1开始递增\r\n\r\n-   如果指针再移动过程中遇到当前的值大于等于左边/右边的值，那么就结束该指针的移动\r\n\r\n    ![](https://img2020.cnblogs.com/blog/2067154/202011/2067154-20201102004404706-1773904769.png)\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int len = S.length();\r\n        int[] res = new int[len];\r\n        // 填充最大值\r\n        Arrays.fill(res, Integer.MAX_VALUE);\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            //每次遇到e时候，就进行pre和next的移动\r\n            if (S.charAt(i) == C) {\r\n                res[i] = 0;\r\n                int pre = i-1;\r\n                int next = i+1;\r\n                int t = 1;\r\n                // 赋值的条件是t要小于等于前一个/后一个元素的值\r\n                // 进行左移动赋值\r\n                while (pre >= 0 && t < res[pre]) {\r\n                    res[pre--] = t++;\r\n                }\r\n                t = 1;\r\n                // 进行右移动赋值\r\n                while (next < len && t < res[next]) {\r\n                    res[next++] = t++;\r\n                }\r\n            }\r\n        }\r\n        // 得到结果\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，其中 N 为字符串长度。\r\n- 空间复杂度：$O(N)$，其中 N 为res数组长度\r\n\r\n## 思路2\r\n\r\n-   正向遍历一次，反向遍历一次\r\n-   用`pre`标记出现目标字符的位置，利用`i`的自增，同时给数组赋值\r\n-   正向遍历是给目标字符之后到下一个目标字符之前进行赋值，反向遍历则相反\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        // 必须要除以2，因为Integer.MIN_VALUE已经是最小值了，又因为i>=0，所以 i-pre 会超过整型最大值\r\n        int pre = Integer.MIN_VALUE / 2;\r\n        \r\n        // 正向遍历\r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n                pre = i;\r\n            }\r\n            res[i] = i - pre;\r\n        }\r\n\r\n        // 反向遍历\r\n        pre = Integer.MAX_VALUE;\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                pre = i;\r\n            }\r\n            res[i] = Math.min(res[i], pre - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，其中 N 为字符串长度。\r\n- 空间复杂度：$O(N)$，其中 N 为res数组长度"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Yvonne1231-Wang": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836281956",
      "body": "### 解题思路\r\n将数组num的最后一位从后往前与k从个位开始依次相加，若加起来后的总数小于10则直接推入栈中；若总数大于10，则将k的进位加1，将总数减去10以后推入栈中。\r\n##需要注意点：\r\n1.不能忘记k的位数或者加起来总数的位数大于原本的数组num的长度点情况，所以数组遍历结束还要判断k是否为0了，若没有，再将k依次推入；\r\n2.不要忘记反转数组，如果改成unshift()则不用；\r\n3.最开始想的办法是将num先转换成数字，与k相加后变成字符串再变成数组，但是忽略了num长度很长变成数字后再相加会溢出的情况。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let a,res=[];\r\n    for(let i = num.length-1; i >= 0; i--)\r\n    {\r\n        a = num[i] + k % 10;\r\n        k = Math.floor(k/10);\r\n        if(a >= 10){\r\n            ++k;\r\n            a = a-10;\r\n        };\r\n        res.push(a);\r\n    }\r\n    while(k!=0){\r\n        res.push(k%10);\r\n        k = Math.floor(k/10);\r\n    }\r\n    \r\n    return res.reverse();\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n) ----只开辟了两个新数据，a和res，其中a是常量阶的，与数据规模无关。res是一个大小与n有关的数组，所以空间复杂度为O(n)\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838232128",
      "body": "### 解题思路\r\n把字符串s以字符串c作为separator分割为数组，然后计算数组每个元素的长度\r\n第一个元素和最后一个元素离得最近的距离单独推入\r\n数组中间的元素判断长度是偶数还是奇数，两种情况推入距离\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let sArr = s.split(c);\r\n    let len = sArr.length;\r\n    let res = [];\r\n    for(let i = sArr[0].length; i >=0; i--){\r\n        res.push(i);\r\n    }\r\n    for (let i=1; i < len-1; i++){\r\n        if(sArr[i].length % 2 == 0){\r\n            for(let j=1; j <= Math.floor(sArr[i].length/2); j++){\r\n            res.push(j);\r\n            }\r\n            for(let j = Math.floor(sArr[i].length/2); j >=0; j--){\r\n            res.push(j);\r\n            }\r\n        }else{\r\n            for(let j=1; j <= Math.floor(sArr[i].length/2); j++){\r\n            res.push(j);\r\n            }\r\n            res.push(Math.floor(sArr[i].length/2) +1)\r\n            for(let j = Math.floor(sArr[i].length/2); j >=0; j--){\r\n            res.push(j);\r\n            }\r\n        }\r\n    }\r\n    for(let i = 1; i <= sArr[len-1].length; i++){\r\n        res.push(i);\r\n    }\r\n    return res\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n) n为字符串s的长度\r\n空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838232128",
      "body": "### 解题思路\r\n把字符串s以字符串c作为separator分割为数组，然后计算数组每个元素的长度\r\n第一个元素和最后一个元素离得最近的距离单独推入\r\n数组中间的元素判断长度是偶数还是奇数，两种情况推入距离\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let sArr = s.split(c);\r\n    let len = sArr.length;\r\n    let res = [];\r\n    for(let i = sArr[0].length; i >=0; i--){\r\n        res.push(i);\r\n    }\r\n    for (let i=1; i < len-1; i++){\r\n        if(sArr[i].length % 2 == 0){\r\n            for(let j=1; j <= Math.floor(sArr[i].length/2); j++){\r\n            res.push(j);\r\n            }\r\n            for(let j = Math.floor(sArr[i].length/2); j >=0; j--){\r\n            res.push(j);\r\n            }\r\n        }else{\r\n            for(let j=1; j <= Math.floor(sArr[i].length/2); j++){\r\n            res.push(j);\r\n            }\r\n            res.push(Math.floor(sArr[i].length/2) +1)\r\n            for(let j = Math.floor(sArr[i].length/2); j >=0; j--){\r\n            res.push(j);\r\n            }\r\n        }\r\n    }\r\n    for(let i = 1; i <= sArr[len-1].length; i++){\r\n        res.push(i);\r\n    }\r\n    return res\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n) n为字符串s的长度\r\n空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Liuqibaa": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836300543",
      "body": "C++\r\n\r\n### 思路\r\n\r\n将向量编程整数，然后相加，再变成向量\r\n\r\n### 代码\r\n\r\n\r\n```c\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int nums = 0;\r\n        int tens = 1;\r\n        vector<int> result;\r\n        for(int i = num.size() - 1; i >= 0; i --){\r\n            nums += num[i] * tens;\r\n            tens *= 10;\r\n        }\r\n        nums += k;\r\n        while(nums){\r\n            int num1 = nums % 10;\r\n            result.push_back(num1);\r\n            nums /= 10;\r\n        }\r\n        reverse(result.begin(), result.end());\r\n        return result;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838128260",
      "body": "### 思路\r\n\r\n用双指针法：先新建一个向量，大小为字符串大小，元素值全为1，然后遍历，将为c的位置均为0；再定义两个指针，同时一前一后搜索为0的；之前的代码无法实现，现在这个代码可以实现\r\n代码是C++的\r\n\r\n### 代码\r\n\r\n\r\n``c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int size1 = s.size();\r\n        vector<int> result(size1, 1);\r\n        for(int i = 0; i < size1 ; i ++){\r\n            if(s[i] == c){\r\n                result[i] = 0;\r\n            }\r\n        }\r\n\r\n        for(int k = 0; k < size1; k ++){\r\n            int i = k;\r\n            int j = k;\r\n            if(result[k] != 0){\r\n                while(result[i] != 0 && result[j] != 0){\r\n                    i --; if(i < 0) i = 0;\r\n                    j ++; if(j > size1 - 1) j = size1 - 1;\r\n                }\r\n                if(result[i] == 0) {\r\n                    result[k] = k - i;\r\n                } else{\r\n                    result[k] = j - k;\r\n                }\r\n            } \r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838128260",
      "body": "### 思路\r\n\r\n用双指针法：先新建一个向量，大小为字符串大小，元素值全为1，然后遍历，将为c的位置均为0；再定义两个指针，同时一前一后搜索为0的；之前的代码无法实现，现在这个代码可以实现\r\n代码是C++的\r\n\r\n### 代码\r\n\r\n\r\n``c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int size1 = s.size();\r\n        vector<int> result(size1, 1);\r\n        for(int i = 0; i < size1 ; i ++){\r\n            if(s[i] == c){\r\n                result[i] = 0;\r\n            }\r\n        }\r\n\r\n        for(int k = 0; k < size1; k ++){\r\n            int i = k;\r\n            int j = k;\r\n            if(result[k] != 0){\r\n                while(result[i] != 0 && result[j] != 0){\r\n                    i --; if(i < 0) i = 0;\r\n                    j ++; if(j > size1 - 1) j = size1 - 1;\r\n                }\r\n                if(result[i] == 0) {\r\n                    result[k] = k - i;\r\n                } else{\r\n                    result[k] = j - k;\r\n                }\r\n            } \r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "sitequ": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836300870",
      "body": "**语言：python3**\r\n\r\n### 思路\r\n1.整型数组转化字符数组，再化为非负整数\r\n2.与k相加\r\n3.数字还原成字符数组，再化为整型数组\r\n\r\n### 代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num = map(str, num)\r\n        str2int = int(''.join(num)) + k\r\n        Output = list(str(str2int))\r\n        for i in range(0,len(Output)):\r\n            Output[i] = int(Output[i])\r\n        return Output\r\n```\r\n### 复杂度分析\r\n时间复杂度O(n)\r\n空间复杂度O(n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838443247",
      "body": "**语言：python3**\r\n\r\n### 思路\r\n1. 获得所有c的位置\r\n2. s的每个字符的位置与c的位置做差，排序找到最小，将值作为元素返回\r\n3. 返回最终最短距离列表\r\n\r\n### 代码\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = len(s)\r\n        Output = []\r\n        num_c = []\r\n        for i in range(0,l):\r\n            if s[i] == c :\r\n                num_c.append(i)\r\n\r\n        L = len(num_c)\r\n\r\n        for i in range(0,l):\r\n            K = []\r\n            for m in range(0,L):\r\n                K.append(abs(i - num_c[m]))\r\n            K = sorted(K)\r\n            Output.append(K[0])\r\n\r\n        return Output\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：Worst case O(N^2)\r\n空间复杂度：O(N)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838443247",
      "body": "**语言：python3**\r\n\r\n### 思路\r\n1. 获得所有c的位置\r\n2. s的每个字符的位置与c的位置做差，排序找到最小，将值作为元素返回\r\n3. 返回最终最短距离列表\r\n\r\n### 代码\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = len(s)\r\n        Output = []\r\n        num_c = []\r\n        for i in range(0,l):\r\n            if s[i] == c :\r\n                num_c.append(i)\r\n\r\n        L = len(num_c)\r\n\r\n        for i in range(0,l):\r\n            K = []\r\n            for m in range(0,L):\r\n                K.append(abs(i - num_c[m]))\r\n            K = sorted(K)\r\n            Output.append(K[0])\r\n\r\n        return Output\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：Worst case O(N^2)\r\n空间复杂度：O(N)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "xiaotuanzi999": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836303348",
      "body": "### 思路 \r\n首先，作为小白，我的第一思路就是将数组转换真正的值，然后与k相加，最后将相加的和转化为List。\r\n```\r\n public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int lenth = num.length;\r\n       List<Integer> res = new ArrayList<>();\r\n       int sum=k;\r\n        int n=1;\r\n        for (int i = lenth-1; i>=0; i--){\r\n            sum+= n*num[i];\r\n            n*=10;\r\n        }\r\n        String temp = Integer.toString(sum);\r\n        for (int i = temp.length()-1; i>=0;i--){\r\n            res.add(Integer.parseInt(temp.substring(i,i+1)));\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```\r\n\r\n然而结果不尽人意。正常的数字可以得到正确的结果。但当数字特别大的时候会出现下面的情况，我还debug了查看。之后查询才知道是溢出了，超出int的精度范围。\r\n\r\n\r\n从后往前遍历数组，就是从数组的低位开始。与k进行相加，并对k与10取余，得到最低位。然后k%10得到进位。\r\n中间存在num的数组整体的小于k的情况，所以需要对i进行判断。\r\n### 代码\r\n```\r\nclass Solution {\r\n      public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int lenth = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        for (int i = lenth-1; i>=0||k>0; i--,k/=10){\r\n            // 如果num数组存在数组，因为存在k>num的情况\r\n            if (i>=0){\r\n                k+=num[i];\r\n            }\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838038240",
      "body": "### 思路\r\n从左往右遍历计算离左边最近的距离；\r\n从右往左遍历计算离右边最近的距离。\r\n但是存在初始时，c位置的位置设定。从左往右设置为最小，这样他们之间差值就很大。从而在从右往左遍历时可以更新其的值。\r\n\r\n### 代码\r\n```\r\n public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] res = new int[length];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for (int i=0; i<length; i++){\r\n            if (s.charAt(i)==c) prev = i;\r\n                res[i] = i-prev;\r\n        }\r\n        prev = Integer.MAX_VALUE/2;\r\n        for (int i = length-1; i>=0; i--){\r\n            if (s.charAt(i)==c) prev = i;\r\n                res[i] = Math.min(res[i],prev-i);\r\n        }\r\n        return res;\r\n    }\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838038240",
      "body": "### 思路\r\n从左往右遍历计算离左边最近的距离；\r\n从右往左遍历计算离右边最近的距离。\r\n但是存在初始时，c位置的位置设定。从左往右设置为最小，这样他们之间差值就很大。从而在从右往左遍历时可以更新其的值。\r\n\r\n### 代码\r\n```\r\n public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] res = new int[length];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for (int i=0; i<length; i++){\r\n            if (s.charAt(i)==c) prev = i;\r\n                res[i] = i-prev;\r\n        }\r\n        prev = Integer.MAX_VALUE/2;\r\n        for (int i = length-1; i>=0; i--){\r\n            if (s.charAt(i)==c) prev = i;\r\n                res[i] = Math.min(res[i],prev-i);\r\n        }\r\n        return res;\r\n    }\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "jmaStella": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836305778",
      "body": "## 解题思路\r\n尝试数字全拿出来然后+K再放回去，结果发现lc有很大的test case，可能就是故意不想让你用这种方法，然后 重新尝试，先把K加到最后一个A的数字，然后取%10的值，循环下去。写了第二遍了还是不能一遍写出来。。。大无语时间发生了。\r\n\r\n\r\n\r\n## 代码\r\n`\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n\r\n    List<Integer> newA = new ArrayList<>();\r\n\r\n    int temp = K;\r\n\r\n    for(int i = A.length-1; i>=0; i--){\r\n\r\n        temp = temp+ A[i];\r\n        newA.add(0, temp%10);\r\n        temp=temp/10;\r\n    }\r\n    while(temp !=0){\r\n        newA.add(0, temp%10);\r\n        temp=temp/10;\r\n    }\r\n    return newA;\r\n    }\r\n`\r\n以为会变得更快，结果并没有\r\n`\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n\r\n    List<Integer> newA = new ArrayList<>();\r\n\r\n    int temp = K;\r\n    int index = A.length-1;\r\n    while(temp !=0 || index >=0){\r\n        if(index >=0){\r\n            temp = temp+ A[index];\r\n        }    \r\n        newA.add(0, temp%10);\r\n        temp=temp/10;\r\n        index --;\r\n    }\r\n\r\n    return newA;\r\n    }\r\n`\r\n\r\n## 复杂度分析\r\n时间复杂度O(max(n, log(K)))\r\n空间复杂度O(max(n, log(K)))\r\n\r\n\r\n喜欢解析里一个人的总结，mark一下。\r\n\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n\r\n作者：lilyunoke\r\n链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837949838",
      "body": "## 思路\r\n以为自己写的是暴力，结果好像不是？感觉比较redundant。先在string里搜一遍c，index存下来，然后再双指针（不确定是不是双指针），这个写法非常有问题，要手动handle各种edge case\r\n\r\n## 代码\r\n\r\n`\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> c_index= new ArrayList<Integer>();\r\n        int result[] = new int[s.length()];\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(c ==s.charAt(i)){\r\n                c_index.add(i);\r\n            }\r\n        }\r\n        int first= 0;\r\n        int second = 0;\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(c_index.size()>1 && second<c_index.size() && i>=c_index.get(second)){\r\n                 first = second;\r\n                 if(second != c_index.size()-1 ){\r\n                     second++;\r\n                 }\r\n            }\r\n\r\n            if(i <= c_index.get(first)){\r\n                result[i] =Math.abs(c_index.get(first)-i);\r\n            }else if(i>c_index.get(first) && i<c_index.get(second)){\r\n                result[i] =Math.min(Math.abs(c_index.get(first)-i),Math.abs(c_index.get(second)-i));\r\n            }else{\r\n                result[i] =Math.abs(c_index.get(second)-i);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(n)\r\n空间O(n)\r\n\r\n\r\n## 思路\r\n看了答案重新写了一遍\r\n最短的距离无非就是左边的或者右边的\r\n先是从左往右loop一遍，记录，然后从右往左loop一遍，比较之前的大小，选更小的\r\n## 代码\r\n\r\n`\r\n    public int[] shortestToChar(String s, char c) {\r\n        int result[] = new int[s.length()];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            result[i] =i-prev;\r\n        }\r\n\r\n\r\n        for(int i = s.length()-1; i>=0; --i){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            result[i] = Math.min(result[i], Math.abs(prev-i));\r\n        }\r\n        return result;\r\n\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(n)\r\n空间O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837949838",
      "body": "## 思路\r\n以为自己写的是暴力，结果好像不是？感觉比较redundant。先在string里搜一遍c，index存下来，然后再双指针（不确定是不是双指针），这个写法非常有问题，要手动handle各种edge case\r\n\r\n## 代码\r\n\r\n`\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> c_index= new ArrayList<Integer>();\r\n        int result[] = new int[s.length()];\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(c ==s.charAt(i)){\r\n                c_index.add(i);\r\n            }\r\n        }\r\n        int first= 0;\r\n        int second = 0;\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(c_index.size()>1 && second<c_index.size() && i>=c_index.get(second)){\r\n                 first = second;\r\n                 if(second != c_index.size()-1 ){\r\n                     second++;\r\n                 }\r\n            }\r\n\r\n            if(i <= c_index.get(first)){\r\n                result[i] =Math.abs(c_index.get(first)-i);\r\n            }else if(i>c_index.get(first) && i<c_index.get(second)){\r\n                result[i] =Math.min(Math.abs(c_index.get(first)-i),Math.abs(c_index.get(second)-i));\r\n            }else{\r\n                result[i] =Math.abs(c_index.get(second)-i);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(n)\r\n空间O(n)\r\n\r\n\r\n## 思路\r\n看了答案重新写了一遍\r\n最短的距离无非就是左边的或者右边的\r\n先是从左往右loop一遍，记录，然后从右往左loop一遍，比较之前的大小，选更小的\r\n## 代码\r\n\r\n`\r\n    public int[] shortestToChar(String s, char c) {\r\n        int result[] = new int[s.length()];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            result[i] =i-prev;\r\n        }\r\n\r\n\r\n        for(int i = s.length()-1; i>=0; --i){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            result[i] = Math.min(result[i], Math.abs(prev-i));\r\n        }\r\n        return result;\r\n\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(n)\r\n空间O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "liucy0417": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836309752",
      "body": "\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 前置知识\r\n\r\n- 数组\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n- 从低位相加，组成一个新的数组\r\n\r\n## 关键点\r\n\r\n-  进位问题\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int l = num.length;\r\n        int sum = 0;\r\n        List<Integer> arr = new ArrayList<>();\r\n        for(int i = l - 1; i>=0; i--) {\r\n            sum = num[i] + k % 10;\r\n            if(sum >= 10) {\r\n                sum =sum - 10;\r\n                k = k + 10;\r\n            }\r\n            arr.add(sum);\r\n            k = k / 10;\r\n        }\r\n        while(k != 0) {\r\n            arr.add(k % 10);\r\n            k = k / 10;\r\n        }\r\n        Collections.reverse(arr);\r\n        return arr; \r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。一个for循环，时间复杂度：$O(n)$，开辟了一个新的数组内存，空间复杂度：$O(n)$。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837680823",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 字符串、数组\r\n\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n\r\n## 关键点\r\n\r\n-  从左向右、从右向左分别遍历一遍，找出较小的值\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] res = new int[length];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for(int i = 0; i < length; i++) {\r\n            if(s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = length - 1; i >=0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(res[i], prev - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n\r\n- 时间复杂度：O(n) ，n为数组长度 \r\n- 空间复杂度：O(n) ， 新数组res[]\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837680823",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 字符串、数组\r\n\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n\r\n## 关键点\r\n\r\n-  从左向右、从右向左分别遍历一遍，找出较小的值\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] res = new int[length];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for(int i = 0; i < length; i++) {\r\n            if(s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = length - 1; i >=0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(res[i], prev - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n\r\n- 时间复杂度：O(n) ，n为数组长度 \r\n- 空间复杂度：O(n) ， 新数组res[]\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "javanlu123": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836346588",
      "body": "# 思路\r\n1.对每个分位进行叠加（注意进位以及分位存在判断的条件）\r\n2.最后一个进位的判断\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        // 这是一个典型的使用数组（字符串）的加法魔板\r\n        // 使用双向链表储存结果集\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int len = num.length - 1;\r\n        // 定义进位,初始默认为0\r\n        int carry = 0;\r\n        // 进行循环判断\r\n        // 数组下标以0开始，k以0为分界点\r\n        while(len>=0||k!=0){\r\n            // 定义数组num和k 的每个分位\r\n            int x = len>=0 ? num[len] : 0;\r\n            int y = k!=0 ? k%10 : 0;\r\n            int sum  = x + y + carry;\r\n            // 存入双向链表中\r\n            res.addFirst(sum % 10);\r\n            // 更新进位\r\n            carry = sum / 10;\r\n            // 分位进行移动\r\n            len--;\r\n            k /=10;\r\n        }\r\n        // 若最后的进位不为0，则头部补充\r\n        if(carry!=0){\r\n            res.addFirst(carry);\r\n        }\r\n        // 返回结果集\r\n        return res;\r\n    }\r\n}\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837614873",
      "body": "# 思路1\r\n- 暴力解法\r\n把包含字符c的下标储存在零时数组，再遍历原有数组，与零时数组进行比较（取距离最小值）\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        int[] temp = new int[len];\r\n        int x = 0;\r\n        // 把包含字符c的下标储存在零时数组\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i)==c){\r\n                temp[x++] = i;\r\n            }\r\n        }\r\n        // 在原字符串中与零时数组进行比较\r\n        int min = len;\r\n        for(int i = 0; i < len; i++){\r\n            // 这里使用x，x是有效位数\r\n            for(int j = 0; j < x; j++){\r\n                min = Math.min(min,Math.abs(i-temp[j]));\r\n            }\r\n            res[i] = min;\r\n//            每次都要重置min值\r\n            min = len;\r\n        }\r\n        return res;\r\n\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N^2)\r\n- 空间复杂度o(N)\r\n\r\n\r\n# 思路2\r\n- 正反向数组遍历\r\n正向遍历，寻找每个位置到最近的c的最小值（向右搜索），反向遍历，则是向左搜索，更新每个位置到最近的c的最小值\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 使用正向、反向遍历法\r\n        int len = s.length();\r\n        // 定义结果数组\r\n        int[] res = new int[len];\r\n\r\n        // 正向遍历，向右搜索\r\n        // 定义一个标识变量prev，用于标记距离\r\n        int prev = -100000;\r\n        for(int i = 0; i < len; i++){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 标记当前位置距离\r\n            res[i] = i - prev;\r\n        }\r\n        // 反向遍历，向左搜索\r\n        // prev标记为 100000\r\n        prev = 100000;\r\n        for(int i = len - 1; i >= 0; i--){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 使用min函数更新当前位置距离\r\n            res[i] = Math.min(res[i],prev - i);\r\n        }\r\n        // 返回结果集\r\n        return res;\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N)\r\n- 空间复杂度o(N)\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837614873",
      "body": "# 思路1\r\n- 暴力解法\r\n把包含字符c的下标储存在零时数组，再遍历原有数组，与零时数组进行比较（取距离最小值）\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        int[] temp = new int[len];\r\n        int x = 0;\r\n        // 把包含字符c的下标储存在零时数组\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i)==c){\r\n                temp[x++] = i;\r\n            }\r\n        }\r\n        // 在原字符串中与零时数组进行比较\r\n        int min = len;\r\n        for(int i = 0; i < len; i++){\r\n            // 这里使用x，x是有效位数\r\n            for(int j = 0; j < x; j++){\r\n                min = Math.min(min,Math.abs(i-temp[j]));\r\n            }\r\n            res[i] = min;\r\n//            每次都要重置min值\r\n            min = len;\r\n        }\r\n        return res;\r\n\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N^2)\r\n- 空间复杂度o(N)\r\n\r\n\r\n# 思路2\r\n- 正反向数组遍历\r\n正向遍历，寻找每个位置到最近的c的最小值（向右搜索），反向遍历，则是向左搜索，更新每个位置到最近的c的最小值\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 使用正向、反向遍历法\r\n        int len = s.length();\r\n        // 定义结果数组\r\n        int[] res = new int[len];\r\n\r\n        // 正向遍历，向右搜索\r\n        // 定义一个标识变量prev，用于标记距离\r\n        int prev = -100000;\r\n        for(int i = 0; i < len; i++){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 标记当前位置距离\r\n            res[i] = i - prev;\r\n        }\r\n        // 反向遍历，向左搜索\r\n        // prev标记为 100000\r\n        prev = 100000;\r\n        for(int i = len - 1; i >= 0; i--){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 使用min函数更新当前位置距离\r\n            res[i] = Math.min(res[i],prev - i);\r\n        }\r\n        // 返回结果集\r\n        return res;\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N)\r\n- 空间复杂度o(N)\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "BryanMiracle": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836356594",
      "body": "**思路**\r\n新建一个链表，存储各位相加的结果。从低位到高位，逐一相加，并将结果返回\r\n\r\n**代码**\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res=new ArrayList<Integer>();\r\n        int n=num.length;\r\n        int sum=0,curr=0,i=n-1;\r\n        while(i>=0 || k!=0){\r\n            int x=i>=0?num[i]:0;\r\n            int y=k!=0?k%10:0;\r\n            sum=x+y+curr;\r\n            curr=sum/10;\r\n            k=k/10;\r\n            i--;\r\n            res.add(0,sum%10);\r\n        }\r\n        if(curr!=0){\r\n            res.add(0,curr);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837667625",
      "body": "**思路**\r\n针对给定字符串中的每个字符，试图找出距离其 向左/向右 离它最近的字符C的距离 ，并选择最近的距离\r\n-- 从左向右遍历，记录上一个字符C出现的位置 prev，此时距离就是：i-prev\r\n-- 从右向左遍历，记录上一个字符C出现的位置prev，此时距离就是 prev-i\r\n-- 取较小值\r\n**代码**\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n=s.length();\r\n        int[] ans=new int[n];\r\n        int prev=Integer.MIN_VALUE/2;\r\n        //从左向右遍历\r\n        for(int i=0;i<n;i++){\r\n            if(s.charAt(i)==c){\r\n                prev=i;\r\n            }\r\n            ans[i]=i-prev;\r\n        }\r\n        //从右向左遍历\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i)==c){\r\n                prev=i;\r\n            }\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：（N）\r\n-- 空间复杂度：O(N)\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837667625",
      "body": "**思路**\r\n针对给定字符串中的每个字符，试图找出距离其 向左/向右 离它最近的字符C的距离 ，并选择最近的距离\r\n-- 从左向右遍历，记录上一个字符C出现的位置 prev，此时距离就是：i-prev\r\n-- 从右向左遍历，记录上一个字符C出现的位置prev，此时距离就是 prev-i\r\n-- 取较小值\r\n**代码**\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n=s.length();\r\n        int[] ans=new int[n];\r\n        int prev=Integer.MIN_VALUE/2;\r\n        //从左向右遍历\r\n        for(int i=0;i<n;i++){\r\n            if(s.charAt(i)==c){\r\n                prev=i;\r\n            }\r\n            ans[i]=i-prev;\r\n        }\r\n        //从右向左遍历\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i)==c){\r\n                prev=i;\r\n            }\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：（N）\r\n-- 空间复杂度：O(N)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "DoubleW2w": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836444832",
      "body": "emmmmm，加油，这次看了答案，下次争取不看答案！！！！\r\n不知道空间复杂度怎么分析，就删除了。\r\n## 思路\r\n\r\n加法主要就是判断进位的问题。相加的选择，我们可以从低位往高位相加\r\n\r\n1. 如果没有产生进位，那什么情况才停止相加呢？比如 $123+23=146$和 $123+1234=1367$\r\n2. 如果产生进位，但没有发生数组越界的情况，比如$123+37=160 $和$123+1137=1260$\r\n3. 如果产生进位，但发生了数组越界呢？比如$999+1=1000$\r\n\r\n---\r\n\r\n第一种情况：当我们低位往高位相加的时候，`k=0`的时候或者`遍历完num`，我们就停止了相加。\r\n\r\n第二种情况：就在第一种情况的基础上，在中间增加个进位的处理，其停止的情况还是`k=0`的时候或者`遍历完num`。\r\n\r\n第三种情况：就在第二种情况的基础上，最后增加高位还有进位的处理情况。而停止还是一样的\r\n\r\n因此总结一下：\r\n\r\n来自题解区的一位大佬\r\n\r\n```java\r\n<公式>\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n<加法模板>    \r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code1:\r\n\r\n```java\r\n//官方题解\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //从低位往高位相加\r\n        int n = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        //遍历num，但k也在发生变化\r\n        for(int i = n-1;i >= 0; i--){\r\n            int sum = num[i] + k%10;\r\n            k /=10;\r\n            if(sum >= 10){\r\n                //把进位放在k上\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        //如果num的位数>k的位数，此时的k是为0或者是最高位的进位\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n\r\nJava Code2:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k){\r\n        //当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n        int n = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry =0, sum =0,index = n-1;\r\n        while(index >=0 || k!=0){\r\n            // num的当前位\r\n            int x = index >=0 ? num[index] : 0;\r\n            // K的当前位\r\n            int y = k != 0 ? k%10 : 0;\r\n\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            k = k / 10;\r\n            index --;\r\n            res.add(sum % 10);\r\n        }\r\n        if (carry != 0){\r\n            res.add(carry);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "ARe99s": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836448740",
      "body": "**思路**\r\n直接把K加到A上\r\n**代码 python**\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        i = len(A) - 1\r\n        while K:\r\n            A[i] += K\r\n            K, A[i] = A[i] // 10, A[i] % 10\r\n            i -= 1\r\n            if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n        return A\r\n```\r\n**时间复杂度**\r\nO(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "FontEndArt": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836454805",
      "body": "\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 思路\r\n循环判断k，k存在即代表还需要进行加法计算，每次加k的个数位，然后k抹去个数位的值，最后并判断是否有进一，有则k++。\r\n\r\n如果超出num的长度则使用unshift在数组首位增加。（其他语言如果没有动态数组的，可能需要预先申请足够的空间）\r\n\r\n## 关键点\r\n\r\n-  进一位的处理\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n    let i = num.length - 1\r\n    while (k > 0) {\r\n        let tmp = k % 10;\r\n        k = Math.floor((k - tmp) / 10)\r\n        if (i < 0) {\r\n            num.unshift(tmp)\r\n            // 注意是continue： [0], 10000\r\n            continue\r\n        }\r\n        // 注意是>=而不是>\r\n        if ((num[i] + tmp) >= 10) {\r\n            k++\r\n        }\r\n        num[i] = (num[i] + tmp) % 10\r\n        i--\r\n    }\r\n    return num\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838391375",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 正反遍历\r\n- Infinity\r\n\r\n## 思路\r\n正反遍历，注意res[i]初始值为Infinity\r\n\r\n> 也可以双指针, 考虑正反遍历或单次遍历，只不过单次遍历需要相当于滑动窗口，然后每次指针移动都要去判断赋值\r\n \r\n> 朋友用的中心扩展法也不是不行，只不过复杂度稍微高了一点，需要双端边界都要到头才可以。\r\n> range(0,s.length)或者匹配到与c的字符满足其一是单端边界结束调节。\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    let cIndex = -1;\r\n    const res = Array(s.length).fill(Infinity)\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] !== c && cIndex < 0) {\r\n            continue\r\n        }\r\n        if (s[i] === c) {\r\n            cIndex = i\r\n            res[i] = 0\r\n        } else {\r\n            res[i] = Math.min(i - cIndex, res[i])\r\n        }\r\n    }\r\n    cIndex = -1;\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (s[i] !== c && cIndex < 0) {\r\n            continue\r\n        }\r\n        if (s[i] === c) {\r\n            cIndex = i\r\n        } else {\r\n            res[i] = Math.min(cIndex - i, res[i])\r\n        }\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838391375",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 正反遍历\r\n- Infinity\r\n\r\n## 思路\r\n正反遍历，注意res[i]初始值为Infinity\r\n\r\n> 也可以双指针, 考虑正反遍历或单次遍历，只不过单次遍历需要相当于滑动窗口，然后每次指针移动都要去判断赋值\r\n \r\n> 朋友用的中心扩展法也不是不行，只不过复杂度稍微高了一点，需要双端边界都要到头才可以。\r\n> range(0,s.length)或者匹配到与c的字符满足其一是单端边界结束调节。\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    let cIndex = -1;\r\n    const res = Array(s.length).fill(Infinity)\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] !== c && cIndex < 0) {\r\n            continue\r\n        }\r\n        if (s[i] === c) {\r\n            cIndex = i\r\n            res[i] = 0\r\n        } else {\r\n            res[i] = Math.min(i - cIndex, res[i])\r\n        }\r\n    }\r\n    cIndex = -1;\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (s[i] !== c && cIndex < 0) {\r\n            continue\r\n        }\r\n        if (s[i] === c) {\r\n            cIndex = i\r\n        } else {\r\n            res[i] = Math.min(cIndex - i, res[i])\r\n        }\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Siomarry": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836474356",
      "body": "- 思路\r\n每次取出K的最后一位以及数组的最后一位进行相加，并且依次进位相加.\r\n\r\n- 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        //建立一个vector<int> K的数组，然后两个vector进行相加.\r\n        queue<int> Kdigit;\r\n        while(k){\r\n            Kdigit.push(k % 10);k = k / 10;\r\n        }\r\n        //第二步，将栈中的元素和num进行相加.\r\n        deque<int> ans;int endpoint = ans.size() - 1;\r\n        //设置一个最大长度的ans.\r\n        int numpoint = num.size() - 1;int plus = 0;\r\n        while(!Kdigit.empty() && numpoint >= 0){\r\n\r\n            ans.push_front((plus + Kdigit.front() + num[numpoint]) % 10);\r\n            plus = (plus + Kdigit.front() + num[numpoint]) / 10;\r\n            Kdigit.pop();numpoint--;endpoint--;\r\n        }\r\n        //结束时判断最后的条件.\r\n        while(!Kdigit.empty()){  //若数字不为空\r\n            ans.push_front((plus + Kdigit.front()) % 10);\r\n            plus = (plus + Kdigit.front()) / 10;\r\n            Kdigit.pop();\r\n        }\r\n\r\n        while(numpoint >= 0){  //若原数组不为空\r\n            ans.push_front((plus + num[numpoint]) % 10);\r\n            plus = (plus + num[numpoint]) / 10;\r\n            numpoint--;\r\n        }\r\n        if(plus)\r\n            ans.push_front(plus);\r\n\r\n        vector<int> result(ans.begin(),ans.end());\r\n        return result;\r\n    }\r\n};\r\n```\r\n- 时间复杂度\r\n    O(max(n，logk))\r\n\r\n- 空间复杂度\r\n    O(max(n,logk))\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838292817",
      "body": "- 思路\r\n对于选定的字符，通过左右双指针来寻找贪心寻找距离最近的字符.\r\n\r\n- 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int ComputerDis(string s,int current,char c){\r\n        //在s中计算c离current最近的字符.\r\n        if(s[current] == c)\r\n            return 0;\r\n        int left = current - 1;int right = current + 1;\r\n        while(left >=0 && right <= s.size() - 1){\r\n            if(s[left] == c || s[right] == c){\r\n                return right - current;\r\n            }\r\n            else{\r\n                left--;right++;\r\n            }\r\n        }\r\n        while(left >= 0){\r\n            if(s[left] == c){\r\n                return current - left;\r\n            }\r\n            else\r\n                left--;\r\n        }\r\n        while(right <= s.size() - 1){\r\n            if(s[right] == c){\r\n                return right - current;\r\n            }else\r\n                right++;\r\n        }\r\n        return -1;\r\n    }\r\n    vector<int> shortestToChar(string s, char c){\r\n        vector<int> ans;\r\n        for(int i = 0;i<s.size();i++){\r\n            ans.push_back(ComputerDis(s,i,c));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度 O(n)\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838292817",
      "body": "- 思路\r\n对于选定的字符，通过左右双指针来寻找贪心寻找距离最近的字符.\r\n\r\n- 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int ComputerDis(string s,int current,char c){\r\n        //在s中计算c离current最近的字符.\r\n        if(s[current] == c)\r\n            return 0;\r\n        int left = current - 1;int right = current + 1;\r\n        while(left >=0 && right <= s.size() - 1){\r\n            if(s[left] == c || s[right] == c){\r\n                return right - current;\r\n            }\r\n            else{\r\n                left--;right++;\r\n            }\r\n        }\r\n        while(left >= 0){\r\n            if(s[left] == c){\r\n                return current - left;\r\n            }\r\n            else\r\n                left--;\r\n        }\r\n        while(right <= s.size() - 1){\r\n            if(s[right] == c){\r\n                return right - current;\r\n            }else\r\n                right++;\r\n        }\r\n        return -1;\r\n    }\r\n    vector<int> shortestToChar(string s, char c){\r\n        vector<int> ans;\r\n        for(int i = 0;i<s.size();i++){\r\n            ans.push_back(ComputerDis(s,i,c));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度 O(n)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "miqpalzm": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836476818",
      "body": "public class Solution {\r\n    public IList<int> AddToArrayForm(int[] num, int k) {\r\n        var kLen = k.ToString().Length;\r\n            int[] kArr = new int[kLen];\r\n            for (var i = kLen - 1; i >= 0; i--)\r\n            {\r\n                if (k / 10 > 0)\r\n                {\r\n                    kArr[i] = k % 10;\r\n                    k = k / 10;\r\n                }\r\n                else\r\n                {\r\n                    kArr[i] = k;\r\n                }\r\n            }\r\n\r\n            var addExtra = false;\r\n            var nLen = num.Length;\r\n            var list = new List<int>();\r\n            for (int i = nLen - 1, j = kLen - 1; i >= 0 || j >= 0; i--, j--)\r\n            {\r\n                var nValue = (i > nLen - 1 || i < 0) ? 0 : num[i];\r\n                var kValue = (j > kLen - 1 || j < 0) ? 0 : kArr[j];\r\n                var sum = nValue + kValue + (addExtra ? 1 : 0);\r\n                if (sum >= 10)\r\n                {\r\n                    addExtra = true;\r\n                    sum = sum % 10;\r\n                }\r\n                else\r\n                {\r\n                    addExtra = false;\r\n                }\r\n\r\n                list.Add(sum);\r\n            }\r\n\r\n            if (addExtra)\r\n            {\r\n                list.Add(1);\r\n            }\r\n            list.Reverse();\r\n\r\n            return list;\r\n    }\r\n}"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838451850",
      "body": "语言：C#\r\n\r\npublic class Solution {\r\n    public int[] ShortestToChar(string s, char c) {\r\n        var charArr = s.ToCharArray();\r\n            var intArr = new int[charArr.Length];\r\n\r\n            int lastIndex = -1, aheadIndex = s.IndexOf(c);\r\n            for (var i = 0; i < charArr.Length; i++)\r\n            {\r\n                if (i == aheadIndex)\r\n                {\r\n                    lastIndex = aheadIndex;\r\n                    charArr[lastIndex] = '#';\r\n                    aheadIndex = new string(charArr).IndexOf(c);\r\n                }\r\n                var left = Math.Abs(i - (lastIndex == -1 ? aheadIndex : lastIndex));\r\n                var right = Math.Abs((aheadIndex == -1 ? lastIndex : aheadIndex) - i);\r\n                intArr[i] = left < right ? left : right;\r\n            }\r\n\r\n            return intArr;\r\n    }\r\n}"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838451850",
      "body": "语言：C#\r\n\r\npublic class Solution {\r\n    public int[] ShortestToChar(string s, char c) {\r\n        var charArr = s.ToCharArray();\r\n            var intArr = new int[charArr.Length];\r\n\r\n            int lastIndex = -1, aheadIndex = s.IndexOf(c);\r\n            for (var i = 0; i < charArr.Length; i++)\r\n            {\r\n                if (i == aheadIndex)\r\n                {\r\n                    lastIndex = aheadIndex;\r\n                    charArr[lastIndex] = '#';\r\n                    aheadIndex = new string(charArr).IndexOf(c);\r\n                }\r\n                var left = Math.Abs(i - (lastIndex == -1 ? aheadIndex : lastIndex));\r\n                var right = Math.Abs((aheadIndex == -1 ? lastIndex : aheadIndex) - i);\r\n                intArr[i] = left < right ? left : right;\r\n            }\r\n\r\n            return intArr;\r\n    }\r\n}"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "15399618796": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836482820",
      "body": "思路：逐位相加再插入到一个新的数组中\r\n\r\n`class Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n       vector<int> res;\r\n       int a=0,sum=0,b=0;\r\n       for(int i=num.size()-1;i>=0;i--){\r\n           a=k%10;\r\n           k/=10;\r\n           sum=num[i]+a;\r\n           if(sum>=10){\r\n               sum-=10;\r\n               k++;\r\n           }\r\n           res.push_back(sum);\r\n       }\r\n       while(k){\r\n           b=k%10;\r\n           k/=10;\r\n           res.push_back(b);\r\n       }\r\n       reverse(res.begin(),res.end());\r\n       \r\n       return res;\r\n    }\r\n};`\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838288962",
      "body": "思路：分别从前到后，从后到前遍历两次数组\r\n\r\n`class Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size(),0);\r\n        int size=s.size();\r\n\r\n        int prev=INT_MIN/2;\r\n        for(int i=0;i<size;i++){\r\n            if(s[i]==c) prev=i;\r\n            res[i]=i-prev;\r\n        }\r\n\r\n        prev=INT_MAX/2;\r\n        for(int i=size-1;i>=0;i--){\r\n            if(s[i]==c) prev=i;\r\n            res[i]=min(res[i],prev-i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};`\r\n\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838288962",
      "body": "思路：分别从前到后，从后到前遍历两次数组\r\n\r\n`class Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size(),0);\r\n        int size=s.size();\r\n\r\n        int prev=INT_MIN/2;\r\n        for(int i=0;i<size;i++){\r\n            if(s[i]==c) prev=i;\r\n            res[i]=i-prev;\r\n        }\r\n\r\n        prev=INT_MAX/2;\r\n        for(int i=size-1;i>=0;i--){\r\n            if(s[i]==c) prev=i;\r\n            res[i]=min(res[i],prev-i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};`\r\n\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "st2yang": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836486673",
      "body": "## 思路\r\n从右到左低位循环num，将其每一位与k相加，并依次进位。如果循环完k还有剩，要记得加上。\r\n\r\n## 代码\r\n- python\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        for i in reversed(range(len(num))):\r\n            sum_ = num[i] + k\r\n            k = sum_ // 10\r\n            res.append(sum_ % 10)\r\n        res.reverse()\r\n        if k:\r\n            res = list(map(int, str(k))) + res\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- time: O(max(n，k))\r\n- space: O(max(n，k))"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837739870",
      "body": "## 思路\r\n左右各循环一遍数组，查找和字符`c`相同的位，以此记录每一位到上一个`c`的距离。然后比较左右距离得到较小值。\r\n\r\n## 代码\r\n- python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        prev = float('-inf')\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            res.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            res[i] = min(res[i], prev - i)\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- time: O(n)\r\n- space: O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837739870",
      "body": "## 思路\r\n左右各循环一遍数组，查找和字符`c`相同的位，以此记录每一位到上一个`c`的距离。然后比较左右距离得到较小值。\r\n\r\n## 代码\r\n- python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        prev = float('-inf')\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            res.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            res[i] = min(res[i], prev - i)\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- time: O(n)\r\n- space: O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Cartie-ZhouMo": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836492706",
      "body": "### 思路\r\n从个位加起，若位数超出原数组，需要进位。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        l = len(num)\r\n        for i in range(l-1, -1, -1):\r\n            a = num[i] + k\r\n            k, num[i] = a // 10, a % 10\r\n        arr = []\r\n        while k:\r\n            arr = [k % 10] + arr\r\n            k = k // 10\r\n        return arr + num\r\n```\r\n### 复杂度分析\r\n时间：O(N)\r\n空间：O(N)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837854541",
      "body": "### 思路\r\n暴力法：先遍历获得s中c的位置list，再遍历计算s中每个字符位置与位置list中元素的最小值。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        arr, ans = [], []\r\n        dis = float(\"inf\") \r\n        for i, ss in enumerate(s):\r\n            if ss == c:\r\n                arr.append(i)\r\n        for i, ss in enumerate(s):\r\n            if ss == c:\r\n                ans.append(0)\r\n            else:\r\n                for a in arr:\r\n                    dis = min(abs(a - i), dis)\r\n                ans.append(dis)\r\n                dis = float(\"inf\") \r\n        return ans\r\n```\r\n### 复杂度：\r\n时间：O(N^2)\r\n空间：O(N)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837854541",
      "body": "### 思路\r\n暴力法：先遍历获得s中c的位置list，再遍历计算s中每个字符位置与位置list中元素的最小值。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        arr, ans = [], []\r\n        dis = float(\"inf\") \r\n        for i, ss in enumerate(s):\r\n            if ss == c:\r\n                arr.append(i)\r\n        for i, ss in enumerate(s):\r\n            if ss == c:\r\n                ans.append(0)\r\n            else:\r\n                for a in arr:\r\n                    dis = min(abs(a - i), dis)\r\n                ans.append(dis)\r\n                dis = float(\"inf\") \r\n        return ans\r\n```\r\n### 复杂度：\r\n时间：O(N^2)\r\n空间：O(N)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "mystoryshine": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836511738",
      "body": "### 思路\r\n\r\n- 用空字符串拼接输入数组\r\n- 转化为整形相加\r\n- 最后再转化为字符串遍历输出\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        tmp = ''\r\n        for n in num:\r\n            tmp += str(n)\r\n        res_int = int(tmp) + k\r\n        res = [int(i) for i in str(res_int)]\r\n        return res\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838438194",
      "body": "### 思路\r\n\r\n- 左右两次遍历\r\n- 每次遍历时用一个临时变量记住最近的一次c的位置，求出距离\r\n- 比较两次遍历结果，取较小值即可\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        # 记第一次c的位置为 -length\r\n        preTargetIndex = - len(s)\r\n        # 正向遍历\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                # 若遍历到了c，将上一次c的位置改为当前位置，这样计算距离才为0\r\n                preTargetIndex = i\r\n            res.append(i - preTargetIndex)\r\n        \r\n        preTargetIndex = 2*len(s)\r\n        # 逆向遍历\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                preTargetIndex = i\r\n            res[i] = min(res[i], preTargetIndex - i)\r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$，其中 $N$ 为数组长度。\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838438194",
      "body": "### 思路\r\n\r\n- 左右两次遍历\r\n- 每次遍历时用一个临时变量记住最近的一次c的位置，求出距离\r\n- 比较两次遍历结果，取较小值即可\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        # 记第一次c的位置为 -length\r\n        preTargetIndex = - len(s)\r\n        # 正向遍历\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                # 若遍历到了c，将上一次c的位置改为当前位置，这样计算距离才为0\r\n                preTargetIndex = i\r\n            res.append(i - preTargetIndex)\r\n        \r\n        preTargetIndex = 2*len(s)\r\n        # 逆向遍历\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                preTargetIndex = i\r\n            res[i] = min(res[i], preTargetIndex - i)\r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$，其中 $N$ 为数组长度。\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "ezrealcong": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836567186",
      "body": "### **思路**\r\nC实现\r\n- 申请A.length+5个元素的数组空间p[]\r\n- 从后往前遍历数组p[]，计算最低位ktmp=k%10;更新kk=(int)(k/10),在遍历长度小于A.length时，p[i]=nums[i]+ktmp+进位ctmp,大于时p[i]=ktmp+ctmp\r\n- 过程中计数，直到发现nums遍历完，进位为0，k更新为0，那么计数器就是要返回的位数，然后将p指向数组对应位置上返回即可\r\n### **代码**\r\n    \r\n    int* addToArrayForm(int* num, int numSize, int k, int* returnSize){\r\n        int* p = calloc(numSize+5,sizeof(int));\r\n        int j=numSize-1;\r\n        int ktmp;//用来保存模10的值（某一位）\r\n        int atmp;//按位加未处理进位值\r\n        int ctmp=0;//保存进位\r\n        int b=0;\r\n        for(int i=numSize+4;i>=0;i--){\r\n            if(j<0&&k==0&&ctmp==0)\r\n                b++;\r\n            ktmp=k%10;\r\n            k=(int)(k/10);\r\n            if(j>=0)\r\n                atmp=num[j]+ctmp+ktmp;\r\n            else\r\n                {atmp=ctmp+ktmp;\r\n                }\r\n            p[i]=atmp%10;\r\n            ctmp=(int)(atmp/10);\r\n            j-=1;      \r\n        }    \r\n        *returnSize=numSize+5-b;\r\n        return p+b;\r\n    }\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：只遍历了一遍P[]，复杂度为O(N)\r\n\r\n- 空间复杂度：基本是用于返回的空间，O(N)\r\n\r\n> "
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706343",
      "body": "（python实现）\r\n### 思路：\r\n1.建立相应长度的数组，全部初始化-1，总共遍历两次\r\n2.第一次从左往右遍历，遇到字符匹配的位置，该元素变0，同时启动计数器num\r\n3.其他位置都赋值为num，赋值完后num自加1，一直到第一次遍历完毕，完成右边最近统计\r\n4.第二次从右往左遍历，遇到字符匹配的位置，启动计数器num\r\n5.其他位置都赋值为min{当前值，num}，赋值完后num自加1，一直到第二次遍历完毕，完成最近距离统计\r\n注意：边界处理时要注意最左边的-1，取最小值要避开-1（-1不参与比较）\r\n### 实例题解展示：\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n第一遍：\r\n\r\n>      [-1,-1,-1,0,1,0,0,1,2,3,4,0]\r\n\r\n第二遍：\r\n\r\n>     [ 3, 2, 1,0,1,0,0,4,3,2,1,0]\t不比较最小值\r\n\r\n>     [ 3, 2, 1,0,1,0,0,1,2,2,1,0]\t比较最小值（-1不参与比较）\r\n\r\n### 代码：\r\n\r\n>     \r\n\r\n    class Solution(object):\r\n            def shortestToChar(self, s, c):\r\n                slen=len(s)\r\n                slist=[-1]*slen\r\n                i=0\r\n                num=-1\r\n                while i<slen:\r\n                    if -1!=num:\r\n                        slist[i]=num\r\n                        num+=1\r\n                    if s[i]==c:\r\n                        slist[i]=0\r\n                        num=1\r\n                    i+=1\r\n                i=slen-1\r\n                num=-1    \r\n                while i>=0:\r\n                    if -1!=num:\r\n                        if slist[i]>num or -1==slist[i]:\r\n                            slist[i]=num\r\n                        num+=1\r\n                    if s[i]==c:\r\n                        num=1\r\n                    i-=1\r\n                return slist\r\n\r\n### 复杂度分析\r\n1.时间复杂度：遍历两次数组（列表），时间复杂度O(N)\r\n2.空间复杂度：除去用来返回的列表，空间复杂度O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706343",
      "body": "（python实现）\r\n### 思路：\r\n1.建立相应长度的数组，全部初始化-1，总共遍历两次\r\n2.第一次从左往右遍历，遇到字符匹配的位置，该元素变0，同时启动计数器num\r\n3.其他位置都赋值为num，赋值完后num自加1，一直到第一次遍历完毕，完成右边最近统计\r\n4.第二次从右往左遍历，遇到字符匹配的位置，启动计数器num\r\n5.其他位置都赋值为min{当前值，num}，赋值完后num自加1，一直到第二次遍历完毕，完成最近距离统计\r\n注意：边界处理时要注意最左边的-1，取最小值要避开-1（-1不参与比较）\r\n### 实例题解展示：\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n第一遍：\r\n\r\n>      [-1,-1,-1,0,1,0,0,1,2,3,4,0]\r\n\r\n第二遍：\r\n\r\n>     [ 3, 2, 1,0,1,0,0,4,3,2,1,0]\t不比较最小值\r\n\r\n>     [ 3, 2, 1,0,1,0,0,1,2,2,1,0]\t比较最小值（-1不参与比较）\r\n\r\n### 代码：\r\n\r\n>     \r\n\r\n    class Solution(object):\r\n            def shortestToChar(self, s, c):\r\n                slen=len(s)\r\n                slist=[-1]*slen\r\n                i=0\r\n                num=-1\r\n                while i<slen:\r\n                    if -1!=num:\r\n                        slist[i]=num\r\n                        num+=1\r\n                    if s[i]==c:\r\n                        slist[i]=0\r\n                        num=1\r\n                    i+=1\r\n                i=slen-1\r\n                num=-1    \r\n                while i>=0:\r\n                    if -1!=num:\r\n                        if slist[i]>num or -1==slist[i]:\r\n                            slist[i]=num\r\n                        num+=1\r\n                    if s[i]==c:\r\n                        num=1\r\n                    i-=1\r\n                return slist\r\n\r\n### 复杂度分析\r\n1.时间复杂度：遍历两次数组（列表），时间复杂度O(N)\r\n2.空间复杂度：除去用来返回的列表，空间复杂度O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Huzhixin00": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836573445",
      "body": "### 思路\r\n1. 按照最自然的想法，应该是将K的各位切分出来，即：将int类型的K转化为各位为int类型的数组，然后将K的对应位与给定数组的对应位进行相加，并考虑进位的情况。\r\n2. 上述想法需要对K进行处理，而且处理进位的逻辑会影响到下一轮更高位的相加处理，所以应考虑更为通用的算法。\r\n3. 在上述过程中，唯一不能省略的就是进位过程，因为作为”必要项“的进位过程如果可以和相加过程相结合，自然可以得出相对通用的算法。\r\n4. 如果要将进位过程与相加过程结合，那么就应该是”依次从低位开始加起，K与个位相加的结果对10取余，即个位的最终结果，而是否向上进位，则取决于k与个位相加的结果除以十，是否大于0（整数/10即意味着求高1位数的结果，因为小数点后的数字被截掉了）“。\r\n5. 反复进行第4步，即每除1次10，即求得都是K累加和的高一次幂，只要K的累加和除10结果不为零，或是数组的位数没有加到最高位，这样的循环就不会停止。\r\n\r\n### 代码（Java）\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> arr = new ArrayList<>();\r\n        for (int i = num.length - 1; i >= 0 || k > 0; i--, k = k / 10) {\r\n            if (i >= 0) {\r\n                k = k + num[i];\r\n            }\r\n            arr.add(k % 10);\r\n        }\r\n        Collections.reverse(arr);\r\n        return arr;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度：O(max(logK,num.length)) \r\n循环次数取决于k和数组长度的最大值，但比较值得注意的是，当K>0，但i<0时，意味着数组的最高位已经没有了，此时应该出现数组越界异常，只不过leetcode只判定到不越界为止，所以就没有考虑越界的问题。\r\n\r\n空间复杂度：O(1)\r\n没有用到额外的空间，所以空间复杂度为常数\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838368278",
      "body": "## 思路\r\n写在代码注释里面了\r\n## 代码\r\n```\r\n class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 创建一个数组来存放各个位置距离字符 c 的最小距离\r\n        int[] minDistances = new int[s.length()];\r\n        /*\r\n        * 每个位置相对于c的情况有三种：\r\n        * 1、该下标只有左边有字符c         [x  c]\r\n        * 2、该下标左右两边都有字符c       [c   x   c]\r\n        * 3、该下标只有右边有字符c         [c  x]\r\n        * 其中只有第二种情况，需要比较两边的字符c究竟哪个距离x更近。\r\n        * 所以取最复杂情况，设置两个指针cursor1和cursor2，分别指向当前下标的左侧c字符和右侧c字符\r\n        * */\r\n        // 先将两个指针指向String中最左侧的字符c，然后从数字0开始迭代\r\n        int cursorFirst = s.indexOf(c), cursorSecond = cursorFirst;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            /*\r\n            * 如果数字下标处，正好是字符c，那么将该位置到字符c的距离必为0，并且更新两个指针的数据\r\n            * 原来的的cursor1，也就是左侧字符c指针，需要更新为当前下标的位置（因为下一次该位置就成为下一个位置的左侧字符c）\r\n            * 原来的cursor2，也就是右侧字符c指针，需要更新为更右边（即从i+1位置开始，找到的下一个字符c位置）的字符c位置*/\r\n            if (s.charAt(i) == c) {    //\r\n                minDistances[i] = 0;\r\n                cursorFirst = i;\r\n                cursorSecond = s.indexOf(c, i + 1);\r\n                // 如果数组下标所处位置的字符不是字符c，则计算该处与最近的左右两侧字符c的距离，并取最小值\r\n            } else {\r\n                minDistances[i] = Math.min(Math.abs(cursorFirst - i), Math.abs(cursorSecond - i));\r\n            }\r\n        }\r\n        return minDistances;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(N) \r\n空间复杂度：O(N)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838368278",
      "body": "## 思路\r\n写在代码注释里面了\r\n## 代码\r\n```\r\n class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 创建一个数组来存放各个位置距离字符 c 的最小距离\r\n        int[] minDistances = new int[s.length()];\r\n        /*\r\n        * 每个位置相对于c的情况有三种：\r\n        * 1、该下标只有左边有字符c         [x  c]\r\n        * 2、该下标左右两边都有字符c       [c   x   c]\r\n        * 3、该下标只有右边有字符c         [c  x]\r\n        * 其中只有第二种情况，需要比较两边的字符c究竟哪个距离x更近。\r\n        * 所以取最复杂情况，设置两个指针cursor1和cursor2，分别指向当前下标的左侧c字符和右侧c字符\r\n        * */\r\n        // 先将两个指针指向String中最左侧的字符c，然后从数字0开始迭代\r\n        int cursorFirst = s.indexOf(c), cursorSecond = cursorFirst;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            /*\r\n            * 如果数字下标处，正好是字符c，那么将该位置到字符c的距离必为0，并且更新两个指针的数据\r\n            * 原来的的cursor1，也就是左侧字符c指针，需要更新为当前下标的位置（因为下一次该位置就成为下一个位置的左侧字符c）\r\n            * 原来的cursor2，也就是右侧字符c指针，需要更新为更右边（即从i+1位置开始，找到的下一个字符c位置）的字符c位置*/\r\n            if (s.charAt(i) == c) {    //\r\n                minDistances[i] = 0;\r\n                cursorFirst = i;\r\n                cursorSecond = s.indexOf(c, i + 1);\r\n                // 如果数组下标所处位置的字符不是字符c，则计算该处与最近的左右两侧字符c的距离，并取最小值\r\n            } else {\r\n                minDistances[i] = Math.min(Math.abs(cursorFirst - i), Math.abs(cursorSecond - i));\r\n            }\r\n        }\r\n        return minDistances;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(N) \r\n空间复杂度：O(N)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Gentlemancj": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836575050",
      "body": "```var addToArrayForm = function(num, k) {\r\n  let isOverflow = false, index = num.length - 1, res = [];\r\n  while(index > -1 || k) {\r\n     const num1 = num[index] || 0, num2 = k % 10;\r\n     let sum = num1 + num2;\r\n     if(isOverflow) {\r\n          sum = sum + 1;\r\n     }\r\n      isOverflow = sum >= 10;\r\n      res.unshift(sum % 10);\r\n      k = (k / 10) | 0;\r\n      index--;\r\n      \r\n  }\r\n  if(isOverflow) res.unshift(1);\r\n  return res;\r\n};\r\n**复杂度分析**\r\n\r\n- 空间复杂度O(n)\r\n- 时间复杂度O(n) "
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837600585",
      "body": "**暴力破解法**\r\n\r\n```\r\nvar shortestToChar = function (s, c) {\r\n  let index = 0, len = s.length, res = [];\r\n  while (index < len) {\r\n    let head = tail = index;\r\n    while (head > -1 || tail < len) {\r\n      const headC = s[head], tailC = s[tail];\r\n      if (headC === c) {\r\n        res.push(index - head);\r\n        break;\r\n      };\r\n      if (tailC === c) {\r\n        res.push(tail - index);\r\n        break;\r\n      }\r\n      head--;\r\n      tail++;\r\n    }\r\n    index++;\r\n  }\r\n  return res\r\n};\r\n```\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837600585",
      "body": "**暴力破解法**\r\n\r\n```\r\nvar shortestToChar = function (s, c) {\r\n  let index = 0, len = s.length, res = [];\r\n  while (index < len) {\r\n    let head = tail = index;\r\n    while (head > -1 || tail < len) {\r\n      const headC = s[head], tailC = s[tail];\r\n      if (headC === c) {\r\n        res.push(index - head);\r\n        break;\r\n      };\r\n      if (tailC === c) {\r\n        res.push(tail - index);\r\n        break;\r\n      }\r\n      head--;\r\n      tail++;\r\n    }\r\n    index++;\r\n  }\r\n  return res\r\n};\r\n```\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "LiangZheCoder": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836576433",
      "body": "思路：模拟进位加法，同样适用于链表\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //用于标识数组的位置\r\n        int len = num.length - 1;\r\n        //用于标识是否发生进位\r\n        int isCarry = 0;\r\n        //统计每一轮的值，提前创建，增加效率\r\n        int val = 0;\r\n        //用于保存结果，使用头插法插入链表\r\n        List<Integer> res = new LinkedList<>();\r\n        while(len > -1 || k > 0){\r\n            if(k > 0){\r\n                val = k % 10;\r\n                k = k / 10;\r\n            }\r\n            if(len > -1){\r\n                val += num[len];\r\n            }\r\n            val += isCarry;\r\n            isCarry = val / 10;\r\n            val = val % 10;\r\n            res.add(0,val);\r\n            len--;\r\n            val = 0;\r\n        }\r\n        if(isCarry > 0){\r\n            res.add(0,1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n时间复杂度O(n)\r\n空间复杂度O(n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837861038",
      "body": "- 思路\r\n\r\n暴力法，判断前后的距离，找到第一个目标字符的位置则停止，然后左右比较大小\r\n```\r\n\r\n- 代码\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int min1 = Integer.MAX_VALUE;\r\n        int min2 = Integer.MAX_VALUE;\r\n        for(int i = 0 ; i < s.length() ; i++){\r\n            if(s.charAt(i) == c){\r\n                answer[i] = 0;\r\n                continue;\r\n            }\r\n            for(int j = i ; j < s.length() ; j++){\r\n                if(s.charAt(j) == c){\r\n                    min1 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            for(int j = i ; j > -1 ; j--){\r\n                if(s.charAt(j) == c){\r\n                    min2 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            answer[i] = Math.min(min1,min2);\r\n            min1 = Integer.MAX_VALUE;\r\n            min2 = Integer.MAX_VALUE;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(N^2) 外层循环数组长度，内层循环近似数组长度\r\n空间：O(N) 开辟和数组长度相等的数组\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837861038",
      "body": "- 思路\r\n\r\n暴力法，判断前后的距离，找到第一个目标字符的位置则停止，然后左右比较大小\r\n```\r\n\r\n- 代码\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int min1 = Integer.MAX_VALUE;\r\n        int min2 = Integer.MAX_VALUE;\r\n        for(int i = 0 ; i < s.length() ; i++){\r\n            if(s.charAt(i) == c){\r\n                answer[i] = 0;\r\n                continue;\r\n            }\r\n            for(int j = i ; j < s.length() ; j++){\r\n                if(s.charAt(j) == c){\r\n                    min1 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            for(int j = i ; j > -1 ; j--){\r\n                if(s.charAt(j) == c){\r\n                    min2 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            answer[i] = Math.min(min1,min2);\r\n            min1 = Integer.MAX_VALUE;\r\n            min2 = Integer.MAX_VALUE;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(N^2) 外层循环数组长度，内层循环近似数组长度\r\n空间：O(N) 开辟和数组长度相等的数组\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "w-z-hub": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836584325",
      "body": "语言：java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n\r\n        for(int i=num.length-1; i>=0; i--){\r\n \r\n            int temp = num[i] + k;\r\n            int temp1 = temp%10;\r\n            ans.add(0, temp1);\r\n            k= temp/10;\r\n            \r\n        }\r\n\r\n        while(k>0){\r\n            ans.add(0, k%10);\r\n            k/=10;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Kuroky-Chen": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836597120",
      "body": "#### 思路：逐位将数字加一起\r\n代码：javascript\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "yulecc": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836599276",
      "body": "思路\r\n遍历数组,不断做空k,从k的个位数开始提取 , 和数组最后一项开始相加 , 一直往前 , 和大于10, k就加1, 最后遍历k,最后反转数组\r\n\r\n关键点\r\n代码\r\n语言支持：JavaScript\r\nJavaScript Code:\r\n\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n\r\n复杂度分析\r\n\r\n令 n 为数组长度。\r\n\r\n时间复杂度：O(n)O(n)\r\n空间复杂度：O(1)O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838266285",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n遍历字符串,两个指针从左找一次,从右找一次\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    var res = new Array(s.length).fill(0)\r\n\r\n    for(var i=0;i <s.length; i++) {\r\n        var l = i, r=i, shortest = Infinity\r\n        if(s[i] === c) continue\r\n        while(l>=0){\r\n            if(s[l] === c){\r\n                shortest = Math.min(shortest, i - l)\r\n                break;\r\n            }\r\n            l--\r\n        }\r\n        while(r<s.length){\r\n            if(s[r] === c){\r\n                shortest = Math.min(shortest, r - i)\r\n                break;\r\n            }\r\n            r++\r\n        }\r\n        res[i] = shortest\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838266285",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n遍历字符串,两个指针从左找一次,从右找一次\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    var res = new Array(s.length).fill(0)\r\n\r\n    for(var i=0;i <s.length; i++) {\r\n        var l = i, r=i, shortest = Infinity\r\n        if(s[i] === c) continue\r\n        while(l>=0){\r\n            if(s[l] === c){\r\n                shortest = Math.min(shortest, i - l)\r\n                break;\r\n            }\r\n            l--\r\n        }\r\n        while(r<s.length){\r\n            if(s[r] === c){\r\n                shortest = Math.min(shortest, r - i)\r\n                break;\r\n            }\r\n            r++\r\n        }\r\n        res[i] = shortest\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "fyyjyx-github": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836606794",
      "body": "### 思路\r\n\r\n先将整数数组A转为一个字符串，再将字符串转为数值类型后与整数K相加，再将得到的数值结果转为int类型的数组。\r\n\r\n### 代码\r\n\r\nPython3\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        # 先将整数数组A转为一个字符串，再将字符串转为数值类型后与整数K相加\r\n        res_num = eval(''.join(map(str, A))) + K\r\n        # 将得到的数值结果先转为字符串，再将其转为int类型的数组\r\n        return list(map(int, str(res_num)))\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)，其中 n 为数组的长度。\r\n- 空间复杂度：O(1)。"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "YuanWenLai": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836610752",
      "body": "### 思路 \r\n \r\n数组的数值操作\r\n1、倒序遍历数组\r\n2、用一个进位数来保存溢出状态carryNum\r\n3、k值每次使用后剔除个位数的值\r\n \r\n \r\n### 代码 \r\n### js\r\n \r\n``` js\r\n \r\n    let len = num.length - 1\r\n    // 用一个进位数来保存上一位的溢出情况\r\n    let carryNum = 0\r\n    let number = []\r\n    while(len >= 0 || k!=0) {\r\n        let sum = carryNum\r\n        if(len >= 0) {\r\n            sum += num[len]\r\n            len--\r\n        }\r\n        if(k!=0) {\r\n            sum += k%10\r\n            // 剔除k的个位\r\n            k = Math.floor(k/10)\r\n        }\r\n        // 保存新的进位数\r\n        carryNum = Math.floor(sum/10)\r\n        number.unshift(sum % 10)\r\n    }\r\n    if(carryNum > 0) {\r\n        number.unshift(carryNum)\r\n    }\r\n    return number\r\n \r\n``` \r\n \r\n**复杂度分析** - 时间复杂度：O(N)，其中 N 为数组⻓度。 - 空间复杂度：O（N）"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837560949",
      "body": "### 思路 \r\n \r\n数组的遍历(正向遍历和反向遍历)\r\n1、先得到一个反向的字符串\r\n2、获取正向反向目标字符的下标\r\n3、正向遍历和反向遍历获取对应距离的数组\r\n4、正向遍历和反向遍历的数组间比较最小值返回\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    if(s.length === 1) return [0]\r\n    let antiS = s.split('').reverse().join('')\r\n    let antiArr = []\r\n    let arr = []\r\n    let index = s.indexOf(c)\r\n    let antiIndex = antiS.indexOf(c)\r\n    for(let i=0;i<s.length;i++) {\r\n        // 正序数组遍历\r\n        if(s[i] !=c){\r\n            arr.push(Math.abs(i - index))\r\n        }else {\r\n            arr.push(0)\r\n            index = i\r\n        }\r\n\r\n        // 反序数组遍历\r\n        if(antiS[i] != c ){\r\n            antiArr.unshift(Math.abs(i - antiIndex))\r\n        }else {\r\n            antiArr.unshift(0)\r\n            antiIndex = i\r\n        }\r\n    }\r\n    return arr.map((item,index) => Math.min(item,antiArr[index]))\r\n};\r\n``` \r\n \r\n**复杂度分析** - 时间复杂度：O(N)，其中 N 为数组⻓度。 - 空间复杂度：O（N）"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837560949",
      "body": "### 思路 \r\n \r\n数组的遍历(正向遍历和反向遍历)\r\n1、先得到一个反向的字符串\r\n2、获取正向反向目标字符的下标\r\n3、正向遍历和反向遍历获取对应距离的数组\r\n4、正向遍历和反向遍历的数组间比较最小值返回\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    if(s.length === 1) return [0]\r\n    let antiS = s.split('').reverse().join('')\r\n    let antiArr = []\r\n    let arr = []\r\n    let index = s.indexOf(c)\r\n    let antiIndex = antiS.indexOf(c)\r\n    for(let i=0;i<s.length;i++) {\r\n        // 正序数组遍历\r\n        if(s[i] !=c){\r\n            arr.push(Math.abs(i - index))\r\n        }else {\r\n            arr.push(0)\r\n            index = i\r\n        }\r\n\r\n        // 反序数组遍历\r\n        if(antiS[i] != c ){\r\n            antiArr.unshift(Math.abs(i - antiIndex))\r\n        }else {\r\n            antiArr.unshift(0)\r\n            antiIndex = i\r\n        }\r\n    }\r\n    return arr.map((item,index) => Math.min(item,antiArr[index]))\r\n};\r\n``` \r\n \r\n**复杂度分析** - 时间复杂度：O(N)，其中 N 为数组⻓度。 - 空间复杂度：O（N）"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "mengwwww": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836631365",
      "body": "```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        queue<int> temp;\r\n        stack<int> res;\r\n        while(k!=0){\r\n            temp.push(k%10);\r\n            k = k/10;\r\n        }\r\n        int i=num.size()-1;\r\n        int jinwei = 0;\r\n        while(i>=0 && !temp.empty()){\r\n            res.push((num[i]+temp.front()+jinwei)%10);\r\n            jinwei = (num[i]+temp.front()+jinwei)/10;\r\n            i--;\r\n            temp.pop();\r\n        }\r\n        if(i>=0){\r\n            for(int k = i;k>=0;k--){\r\n                res.push((num[k]+jinwei)%10);\r\n                jinwei = (num[k]+jinwei)/10;\r\n            }\r\n        }\r\n        if(!temp.empty()){\r\n            while(!temp.empty()){\r\n                res.push((temp.front()+jinwei)%10);\r\n                jinwei = (temp.front()+jinwei)/10;\r\n                temp.pop();\r\n            }\r\n            \r\n        }\r\n        if(jinwei>0){\r\n            res.push(jinwei);\r\n        }\r\n        vector<int> m;\r\n        while(!res.empty()){\r\n            m.push_back(res.top());\r\n            res.pop();\r\n        }\r\n        return m;\r\n    }\r\n};\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837634708",
      "body": "### 思路\r\n使用队列存储对应字符下标所在位置\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        queue<int> q;\r\n        for(int i=0;i<s.length();i++){\r\n            if(c==s[i]){\r\n                q.push(i);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        int a = q.front();\r\n        q.pop();\r\n        for(int i=0;i<s.length();i++){\r\n            if(q.empty() || abs(i-a)<=abs(i-q.front())){\r\n                res.push_back(abs(i-a));                \r\n            }else if(!q.empty() && abs(i-a)>abs(i-q.front())){\r\n                a = q.front();\r\n                q.pop();\r\n                i--;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 o(n)\r\n空间复杂度o(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837634708",
      "body": "### 思路\r\n使用队列存储对应字符下标所在位置\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        queue<int> q;\r\n        for(int i=0;i<s.length();i++){\r\n            if(c==s[i]){\r\n                q.push(i);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        int a = q.front();\r\n        q.pop();\r\n        for(int i=0;i<s.length();i++){\r\n            if(q.empty() || abs(i-a)<=abs(i-q.front())){\r\n                res.push_back(abs(i-a));                \r\n            }else if(!q.empty() && abs(i-a)>abs(i-q.front())){\r\n                a = q.front();\r\n                q.pop();\r\n                i--;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 o(n)\r\n空间复杂度o(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "JohnVSD": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836632025",
      "body": "## 思路\r\n\r\n参考了官方题解。\r\n\r\n从低位向高位依次计算。例如：123+912，计算过程是 3+2，2+1，1+9 可以得出结果为 1035；可以转换为如下代码：\r\n\r\n## 代码\r\nJavaScript\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    let n = num.length;\r\n    \r\n    for (let i = n - 1; i>=0; i--) {\r\n        // 利用取余操作，取出k值最后一位进行加运算\r\n        let sum = num[i] + k % 10;\r\n        // 利用向下取整的方式，去掉k最后一位数，依次计算\r\n        k = Math.floor(k / 10);\r\n        \r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        \r\n        res.push(sum);\r\n    }\r\n    \r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    \r\n    res.revers();\r\n    \r\n    return res;\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(max(n, log k))\r\n* 空间复杂度：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838735759",
      "body": "## 思路\r\n\r\n分别从字符串左右进行遍历，比较然后取最小值。\r\n\r\n## 代码\r\nTypeScript\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n  let res: number[] = Array(s.length).fill(0);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) continue;\r\n\r\n    let l: number = i;\r\n    let r: number = i;\r\n    let shortest: number= Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r<s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(N²)\r\n* 空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838735759",
      "body": "## 思路\r\n\r\n分别从字符串左右进行遍历，比较然后取最小值。\r\n\r\n## 代码\r\nTypeScript\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n  let res: number[] = Array(s.length).fill(0);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) continue;\r\n\r\n    let l: number = i;\r\n    let r: number = i;\r\n    let shortest: number= Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r<s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(N²)\r\n* 空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "QiZhongdd": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836634467",
      "body": "思路\r\n数组的数值操作\r\n1：新建一个数组用于存储变量\r\n2:倒序遍历数组，每个值与K的余数相加，如果和小于0，那么push这个和，如果大于0，那么push该和的个位数，K为十位数。\r\n3：依次遍历，重复第一步骤，等到遍历完后，如果k继续大于0,那么依次将k的值一个个添加进res数组。\r\n4：对结果进行翻转得到数字\r\n\r\nfunction add(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838362553",
      "body": "思路1\r\n左右各遍历一次,找到相同值的位置，比较左右最快找到值的坐标，然后得到绝对值比较，取小值\r\n\r\nvar shortestToChar = function(s, c) {\r\n   let prev=-Infinity,result=[];\r\n   for(let i=0;i<s.length;i++){\r\n       if(s.charAt(i)===c){\r\n           prev=i\r\n       }\r\n       result[i]=Math.abs(i-prev)\r\n   }\r\n   prev=Infinity\r\n   for(let j=s.length-1;j>=0;--j){\r\n        if(s.charAt(j)===c){\r\n           prev=j\r\n       }\r\n       result[j]=Math.min(result[j],Math.abs(prev-j))\r\n   }\r\n   return result\r\n};\r\n复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n思路2\r\n先循环遍历一次，找到相同值的位置保存在一个数组ans中\r\n再次循环，将坐标与ans中的坐标差的绝对值，取最小的值\r\nvar shortestToChar = function(s, c) {\r\n    let ans=[],result=[];\r\n    for(let i=0;i<s.length;i++){\r\n        if(s.charAt(i)===c){\r\n            ans.push(i)\r\n        }\r\n    }\r\n    for(let i=0;i<s.length;i++){\r\n        let min=Math.abs(i-ans[0])\r\n        for(let j=1;j<ans.length;j++){\r\n            min=Math.min(min,Math.abs(i-ans[j]))\r\n        }\r\n        result[i]=min\r\n    }\r\n    return result\r\n};\r\n复杂度\r\n时间复杂度：O(n2)\r\n空间复杂度：O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838362553",
      "body": "思路1\r\n左右各遍历一次,找到相同值的位置，比较左右最快找到值的坐标，然后得到绝对值比较，取小值\r\n\r\nvar shortestToChar = function(s, c) {\r\n   let prev=-Infinity,result=[];\r\n   for(let i=0;i<s.length;i++){\r\n       if(s.charAt(i)===c){\r\n           prev=i\r\n       }\r\n       result[i]=Math.abs(i-prev)\r\n   }\r\n   prev=Infinity\r\n   for(let j=s.length-1;j>=0;--j){\r\n        if(s.charAt(j)===c){\r\n           prev=j\r\n       }\r\n       result[j]=Math.min(result[j],Math.abs(prev-j))\r\n   }\r\n   return result\r\n};\r\n复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n思路2\r\n先循环遍历一次，找到相同值的位置保存在一个数组ans中\r\n再次循环，将坐标与ans中的坐标差的绝对值，取最小的值\r\nvar shortestToChar = function(s, c) {\r\n    let ans=[],result=[];\r\n    for(let i=0;i<s.length;i++){\r\n        if(s.charAt(i)===c){\r\n            ans.push(i)\r\n        }\r\n    }\r\n    for(let i=0;i<s.length;i++){\r\n        let min=Math.abs(i-ans[0])\r\n        for(let j=1;j<ans.length;j++){\r\n            min=Math.min(min,Math.abs(i-ans[j]))\r\n        }\r\n        result[i]=min\r\n    }\r\n    return result\r\n};\r\n复杂度\r\n时间复杂度：O(n2)\r\n空间复杂度：O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "LS-King": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836635602",
      "body": "### 思路\r\n\r\n重点关注进位：\r\n\r\n1. 设置中间变量digit，存放数字k、数组num和前位进位到该数位值的和（可以大于9），模10之后作为新的该数位数值，除10后的进位进入下层循环\r\n2. 对于最高位，需要考虑进位的位数增加带来的数组长度改变的问题，设置判断条件插入新的最高位，同时注意下标的改变\r\n\r\n### 代码\r\nC++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int length = num.size();\r\n        int index = length;\r\n        int digit = 0;\r\n        while (k != 0 || digit != 0) {\r\n            //如果上一轮循环中已更新到num最高位，则在前面添加一个数位，将其值置为0\r\n            if (index == 0) {\r\n                num.insert(num.begin(), 0);\r\n            //下标迭代，每层循环向高位移动1位\r\n            } else {\r\n                index -= 1;\r\n            }\r\n            //上层循环的进位加上本轮循环对应数位上的值构成新的待定数位新值（可能超过9）\r\n            digit += k % 10;\r\n            //k去掉最后一位，等待下一轮循环\r\n            k /= 10;\r\n            //相同数位上数字相加（可能超过9）\r\n            digit += num[index];\r\n            //取个位部分作为该数位的新值\r\n            num[index] = digit % 10;\r\n            //将超过9的部分留到下一次循环\r\n            digit /= 10;\r\n        }\r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)，使用传进来的源数组num的空间。\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838681307",
      "body": "### 思路\r\n\r\n开辟一个数组 chIndex 存放匹配字符的下标，之后遍历字符串，逐字符计算其下标与所有匹配字符下标差的绝对值，取最小值存入res数组\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> chIndex;\r\n        vector<int> res;\r\n        //遍历字符串，将匹配字符下标存入数组chIndex\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) {\r\n                chIndex.push_back(i);\r\n            }\r\n        }\r\n        //遍历数组，逐字符计算其下标与所有匹配字符下标差的绝对值，取最小值存入res数组\r\n        for (int i = 0; i < s.size(); i++) {\r\n            //最大距离不超过10000\r\n            int distance = 10000;\r\n            for (int index : chIndex) {\r\n                distance = min(distance, abs(index - i));\r\n            }\r\n            res.push_back(distance);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N^2)，其中 N 为字符串长度。\r\n- 空间复杂度：O(N)，其中 N 为字符串长度。\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838681307",
      "body": "### 思路\r\n\r\n开辟一个数组 chIndex 存放匹配字符的下标，之后遍历字符串，逐字符计算其下标与所有匹配字符下标差的绝对值，取最小值存入res数组\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> chIndex;\r\n        vector<int> res;\r\n        //遍历字符串，将匹配字符下标存入数组chIndex\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) {\r\n                chIndex.push_back(i);\r\n            }\r\n        }\r\n        //遍历数组，逐字符计算其下标与所有匹配字符下标差的绝对值，取最小值存入res数组\r\n        for (int i = 0; i < s.size(); i++) {\r\n            //最大距离不超过10000\r\n            int distance = 10000;\r\n            for (int index : chIndex) {\r\n                distance = min(distance, abs(index - i));\r\n            }\r\n            res.push_back(distance);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N^2)，其中 N 为字符串长度。\r\n- 空间复杂度：O(N)，其中 N 为字符串长度。\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "heartinn": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836635929",
      "body": "思路\r\n列表转数字直接相加再转回列表\r\n\r\n代码\r\nPython3\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        return map(int,str(int(''.join(map(str,A))) + K))\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838007634",
      "body": "算法思想：\r\n前向遍历记录下每个位置和出现在前面的目标字符的距离，后向遍历记录每个位置和出现在后面的目标字符的距离\r\n\r\n代码：\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [len(s)] * len(s)\r\n        previous = -1\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                previous = i\r\n            if previous != -1:\r\n                result[i] = i - previous\r\n        latter = -1\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                latter = i\r\n            if latter != -1:\r\n                result[i] = min(result[i], latter - i)\r\n        return result\r\n\r\n复杂度\r\n时间：o(n)\r\n空间：o(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838007634",
      "body": "算法思想：\r\n前向遍历记录下每个位置和出现在前面的目标字符的距离，后向遍历记录每个位置和出现在后面的目标字符的距离\r\n\r\n代码：\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [len(s)] * len(s)\r\n        previous = -1\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                previous = i\r\n            if previous != -1:\r\n                result[i] = i - previous\r\n        latter = -1\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                latter = i\r\n            if latter != -1:\r\n                result[i] = min(result[i], latter - i)\r\n        return result\r\n\r\n复杂度\r\n时间：o(n)\r\n空间：o(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "UCASHurui": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836637454",
      "body": "\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 思路\r\n先把数组A扩展到和K相加后可能的最长长度，然后模拟加法，每次取K的最低位和A中对应位以及进位相加，然后更新进位并将K除10后取整。（其实也可以把A转换成整数后相加，考虑到其他语言可能不像python能够自动进行大数运算所以还是转换成数组相加更好）\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        carry = 0\r\n        len_K, len_A = len(str(K)), len(A)\r\n        A = [0]*(max(len_A, len_K)-len_A + 1) + A\r\n        pos = len(A) - 1\r\n        while K or carry:\r\n                tmp = A[pos] + K%10 + carry\r\n                carry = tmp // 10\r\n                A[pos] = tmp%10\r\n                K = int(K/10)\r\n                pos -= 1\r\n        if A[0]==0: return A[1:]\r\n        return A\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837870441",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n两趟遍历分别找到每一个位置左方和右方距离最近的目标字符，取其中最小值计入最终结果。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        povit = -float('inf')\r\n        res = [0] * len(S)\r\n        for i in range(len(S)):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = i-povit\r\n        povit = float('inf')\r\n        for i in range(len(S)-1, -1, -1):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = min(res[i], povit-i)\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837870441",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n两趟遍历分别找到每一个位置左方和右方距离最近的目标字符，取其中最小值计入最终结果。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        povit = -float('inf')\r\n        res = [0] * len(S)\r\n        for i in range(len(S)):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = i-povit\r\n        povit = float('inf')\r\n        for i in range(len(S)-1, -1, -1):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = min(res[i], povit-i)\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "BraveSage": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836638684",
      "body": "## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n### 思路\r\n\r\n1. 模拟数字加法，倒序遍历数组和每次取得整数K的各位数的值进行相加\r\n2. 判断当前位数的数是否大于10，如果大于10在整数k中进行+1\r\n3. 让k除以10，确保计算的位数与数组一致\r\n\r\n\r\n\r\n### 代码（两种思路一致，不过下方节省了一个while循环）\r\n\r\n- Java\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList();\r\n        for(int i = num.length-1; i >= 0; i--){\r\n            int temp = num[i] + k%10;\r\n            ans.add(temp%10);\r\n            k /= 10;\r\n            if(temp >= 10) k++;\r\n        }\r\n        while(k != 0){\r\n            ans.add(k%10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList();\r\n        for(int i = num.length-1; i >= 0 || k > 0; i--, k/=10){\r\n            if(i >= 0){\r\n                k += num[i];\r\n            }\r\n            ans.add(k%10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间：O(max(n,log(k))) 整数与数组长度之间取最大\r\n\r\n空间：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838733842",
      "body": "## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n- 字符串 S 的长度范围为 [1, 10000]。\r\n- C 是一个单字符，且保证是字符串 S 里的字符。\r\n- S 和 C 中的所有字母均为小写字母。\r\n```\r\n\r\n\r\n\r\n### 思路\r\n\r\n获取指定string的当前前一个为c的索引位置与当前索引位置的最小值即可，然后记录在res数组当中\r\n\r\n### 代码\r\n\r\n- Java\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int length = S.length();\r\n        int[] res = new int[length];\r\n        int prev = S.indexOf(C),next = S.indexOf(C, prev+1);\r\n        for (int i = 0; i < length; i++){\r\n            res[i] = Math.abs(i-prev);\r\n            if(next!=-1){\r\n                res[i] = Math.min(res[i],next-i);\r\n                if(i==next){\r\n                    prev = next;\r\n                    next = S.indexOf(C,next+1);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(n) 创建了为S.length()长度的数组"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838733842",
      "body": "## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n- 字符串 S 的长度范围为 [1, 10000]。\r\n- C 是一个单字符，且保证是字符串 S 里的字符。\r\n- S 和 C 中的所有字母均为小写字母。\r\n```\r\n\r\n\r\n\r\n### 思路\r\n\r\n获取指定string的当前前一个为c的索引位置与当前索引位置的最小值即可，然后记录在res数组当中\r\n\r\n### 代码\r\n\r\n- Java\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int length = S.length();\r\n        int[] res = new int[length];\r\n        int prev = S.indexOf(C),next = S.indexOf(C, prev+1);\r\n        for (int i = 0; i < length; i++){\r\n            res[i] = Math.abs(i-prev);\r\n            if(next!=-1){\r\n                res[i] = Math.min(res[i],next-i);\r\n                if(i==next){\r\n                    prev = next;\r\n                    next = S.indexOf(C,next+1);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(n) 创建了为S.length()长度的数组"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "KevinWorkSpace": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836639151",
      "body": "## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int index = A.length - 1;\r\n        int add = 0;\r\n        while (index >= 0 || K > 0 || add > 0) {\r\n            int a = 0;\r\n            if (index >= 0) a = A[index];\r\n            int b = K % 10;\r\n            int tmp = (a + b + add) % 10;\r\n            add = (a + b + add) / 10;\r\n            res.add(tmp);\r\n            K /= 10;\r\n            index --;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838339270",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int index = -1;\r\n        for (int i=0; i<res.length; i++) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Integer.MAX_VALUE;\r\n            else res[i] = i - index;\r\n        }\r\n        index = -1;\r\n        for (int i=res.length-1; i>=0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Math.min(Integer.MAX_VALUE, res[i]);\r\n            else res[i] = Math.min(index - i, res[i]);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838339270",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int index = -1;\r\n        for (int i=0; i<res.length; i++) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Integer.MAX_VALUE;\r\n            else res[i] = i - index;\r\n        }\r\n        index = -1;\r\n        for (int i=res.length-1; i>=0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Math.min(Integer.MAX_VALUE, res[i]);\r\n            else res[i] = Math.min(index - i, res[i]);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "ssxgit": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836641307",
      "body": "# 989. 数组形式的整数加法\r\n主要是需要一个进位的表示，最终要保证三个部分都加完\r\n\r\n## 代码\r\n- 语言：c++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n\r\n        vector<int> res;\r\n\r\n        int carry_bit = 0;\r\n\r\n        int loc = num.size() - 1;\r\n\r\n        while(loc>-1 || k > 0 || carry_bit > 0){\r\n            int num1 = loc>-1?num[loc]:0;\r\n            int num2 = k % 10;\r\n\r\n            int value = num1 + num2 + carry_bit;\r\n\r\n            res.emplace_back((value % 10));\r\n            carry_bit = value / 10; \r\n\r\n            --loc;\r\n            k /= 10;\r\n        }\r\n        \r\n        reverse(res.begin(),res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838312453",
      "body": "# 821. 字符的最短距离\r\n[leetcode 821](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n## 思路：\r\n1. 从左到右遍历保存每一个字符距离其左边最近的字符 c 的 距离\r\n2. 从右到左遍历保存每一个字符距离其右边最近的字符 c 的 距离\r\n3. 取上面两个距离的更小值即可，可以只用一个数组来存\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        if(s.empty()) return {};\r\n        vector<int> res(s.size(),INT_MAX);\r\n        int pre_c_loc = -1;\r\n        for(int i=0;i<s.size();++i){\r\n            if(s[i] == c){\r\n                pre_c_loc = i;\r\n                res[i] = 0;\r\n            }\r\n            else if(pre_c_loc != -1) res[i] = i - pre_c_loc;\r\n        }\r\n\r\n        pre_c_loc = s.size();\r\n        for(int i=s.size()-1;i>-1;--i){\r\n            if(s[i] == c) pre_c_loc = i;\r\n            else if(pre_c_loc != s.size()) res[i] = min(res[i],pre_c_loc - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)  //最终需要返回的结果数组不计算复杂度"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838312453",
      "body": "# 821. 字符的最短距离\r\n[leetcode 821](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n## 思路：\r\n1. 从左到右遍历保存每一个字符距离其左边最近的字符 c 的 距离\r\n2. 从右到左遍历保存每一个字符距离其右边最近的字符 c 的 距离\r\n3. 取上面两个距离的更小值即可，可以只用一个数组来存\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        if(s.empty()) return {};\r\n        vector<int> res(s.size(),INT_MAX);\r\n        int pre_c_loc = -1;\r\n        for(int i=0;i<s.size();++i){\r\n            if(s[i] == c){\r\n                pre_c_loc = i;\r\n                res[i] = 0;\r\n            }\r\n            else if(pre_c_loc != -1) res[i] = i - pre_c_loc;\r\n        }\r\n\r\n        pre_c_loc = s.size();\r\n        for(int i=s.size()-1;i>-1;--i){\r\n            if(s[i] == c) pre_c_loc = i;\r\n            else if(pre_c_loc != s.size()) res[i] = min(res[i],pre_c_loc - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)  //最终需要返回的结果数组不计算复杂度"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "fenglei110": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836644430",
      "body": "python\r\n\r\npython语言的设计就是太动态了，int和str可以互转。\r\n\r\n列表迭代式 + lambda表达式\r\n平时也是这样写，感觉代码很简洁。但是你要问我这样的代码有什么不足，还真答不上来。\r\n\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        return  list(map(int, str(int(''.join(map(str, num)))+k)))\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    null,
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839817225",
      "body": "> ### 思路\r\n> 给定一个变量来记录栈顶的位置，更新数据来模拟栈的操作，但因为实质是函数内的数组，所以可以实现对除了栈顶元素外的改动。（后续再优化）\r\n> \r\n> ### 代码\r\n> ```python\r\n> class CustomStack:\r\n> # use array in function makes the each elenments in stack \"visable\"\r\n> \r\n>     def __init__(self, maxSize: int):\r\n>         self.stk = [0]*maxSize\r\n>         self.top = -1\r\n> \r\n>     def push(self, x: int) -> None:\r\n>         # if stack size is smaller than maxSize, push in\r\n>         # maxSize is not defined in this function, so use len of stack instead\r\n>         if self.top < len(self.stk)-1:\r\n>             self.stk[self.top+1] = x\r\n>             self.top += 1\r\n> \r\n>     def pop(self) -> int:\r\n>         # if stack is empty, return -1\r\n>         # if stack is not empty, return the top value and delete it in the stack (no need)\r\n>         if self.top == -1:\r\n>             return -1\r\n>         self.top -= 1\r\n>         return self.stk[self.top + 1]\r\n> \r\n>     def increment(self, k: int, val: int) -> None:\r\n>         # use the minimum value between k and self.stk length, then traverse\r\n>         if k>-1:\r\n>             for i in range(min(self.top+1,k)):\r\n>                 self.stk[i]+=val\r\n> ```\r\n> \r\n> **复杂度分析**\r\n> \r\n> * 时间复杂度：O(min(k, maxSize)),\r\n> * 空间复杂度：O(maxSize)\r\n\r\n跑错场了兄弟"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "1998yyh": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836644503",
      "body": "### 思路\r\n循环数组按位相加，同时对应修改k，循环完成后当k大于0，再对k处理。\r\n### 代码\r\njavascript\r\n``` javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const len = num.length;\r\n    const resultArr = [];\r\n    for(let i = len -1; i>=0;i--){\r\n        const _num = k%10;\r\n        k = Math.floor(k/10);\r\n        const sum = _num + num[i];\r\n        if(sum>9){\r\n            k++\r\n        }\r\n        resultArr.unshift(sum%10);\r\n    }\r\n    while(k>0){\r\n        resultArr.unshift(k%10)\r\n        k = Math.floor(k/10);\r\n    }\r\n    return resultArr\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838434616",
      "body": "### 思路\r\n用一个变量保存出现的位置，从左往右，从右往左分别遍历一次，取最小值\r\n### 代码\r\njavascript\r\n``` javascript\r\nvar shortestToChar = function (s, c) {\r\n    let flag = -1;\r\n    const len = s.length;\r\n    const result = new Array(len).fill(Infinity);\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] !== c && flag < 0) continue;\r\n        if (s[i] === c) {\r\n            result[i] = 0;\r\n            flag = i\r\n        } else {\r\n            result[i] = Math.min(i - flag, result[i])\r\n        }\r\n    }\r\n    flag = -1;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] !== c && flag < 0) continue;\r\n        if (s[i] === c) {\r\n            result[i] = 0;\r\n            flag = i\r\n        } else {\r\n            result[i] = Math.min(flag - i, result[i])\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838434616",
      "body": "### 思路\r\n用一个变量保存出现的位置，从左往右，从右往左分别遍历一次，取最小值\r\n### 代码\r\njavascript\r\n``` javascript\r\nvar shortestToChar = function (s, c) {\r\n    let flag = -1;\r\n    const len = s.length;\r\n    const result = new Array(len).fill(Infinity);\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] !== c && flag < 0) continue;\r\n        if (s[i] === c) {\r\n            result[i] = 0;\r\n            flag = i\r\n        } else {\r\n            result[i] = Math.min(i - flag, result[i])\r\n        }\r\n    }\r\n    flag = -1;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] !== c && flag < 0) continue;\r\n        if (s[i] === c) {\r\n            result[i] = 0;\r\n            flag = i\r\n        } else {\r\n            result[i] = Math.min(flag - i, result[i])\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "joriscai": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836661706",
      "body": "# 思路\r\n先将k转成数组，再利用双指针分别从k和num的最后一位开始按位计算。注：需要考虑最后一次进位的情况。\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=989 lang=javascript\r\n *\r\n * [989] 数组形式的整数加法\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  const kArr = (k + '').split('')\r\n  const ret = []\r\n\r\n  let i = num.length - 1\r\n  let j = kArr.length - 1\r\n  let tmp = 0\r\n  while (i >= 0 || j >= 0 || tmp) {\r\n    const count = parseInt(num[i] || 0) + parseInt(kArr[j] || 0) + tmp\r\n    ret.unshift(count % 10)\r\n    tmp = parseInt(count / 10)\r\n    i--\r\n    j--\r\n  }\r\n  return ret\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(max(n, log k))，其中 n 为数组的长度。log k为k的位，即log 10(k)，10为底k的对数。\r\n空间复杂度：O(max(n, log k))。"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838475940",
      "body": "# 思路\r\n通过字符串正反向遍历，从两种方式中找到最接近的值。\r\n- 注：正反向遍历时，默认值都为正无穷大\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=821 lang=javascript\r\n *\r\n * [821] 字符的最短距离\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const ret = []\r\n  let near = Infinity\r\n  // 从左到右，记录距离\r\n  for (let i = 0; i < s.length; i++) {\r\n    const char = s[i]\r\n    if (char === c) {\r\n      ret.push(0)\r\n      near = 0\r\n    } else {\r\n      ret.push(++near)\r\n    }\r\n  }\r\n\r\n  // 从右到左了，要将距离设为正无穷大\r\n  near = Infinity\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    const char = s[i]\r\n    if (char === c) {\r\n      near = 0\r\n    } else {\r\n      // 比较当前值和右到左的距离，取最小的那个\r\n      ret[i] = Math.min(ret[i], ++near)\r\n    }\r\n  }\r\n\r\n  return ret\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，只遍历了两次字符串\r\n\r\n空间复杂度：O(n)，结果跟字符串长度一样"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838475940",
      "body": "# 思路\r\n通过字符串正反向遍历，从两种方式中找到最接近的值。\r\n- 注：正反向遍历时，默认值都为正无穷大\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=821 lang=javascript\r\n *\r\n * [821] 字符的最短距离\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const ret = []\r\n  let near = Infinity\r\n  // 从左到右，记录距离\r\n  for (let i = 0; i < s.length; i++) {\r\n    const char = s[i]\r\n    if (char === c) {\r\n      ret.push(0)\r\n      near = 0\r\n    } else {\r\n      ret.push(++near)\r\n    }\r\n  }\r\n\r\n  // 从右到左了，要将距离设为正无穷大\r\n  near = Infinity\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    const char = s[i]\r\n    if (char === c) {\r\n      near = 0\r\n    } else {\r\n      // 比较当前值和右到左的距离，取最小的那个\r\n      ret[i] = Math.min(ret[i], ++near)\r\n    }\r\n  }\r\n\r\n  return ret\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，只遍历了两次字符串\r\n\r\n空间复杂度：O(n)，结果跟字符串长度一样"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "q815101630": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836666773",
      "body": "## 思路\r\n遍历数组， 因为知道在第i位 数等于 i* 10**(len(num)-1) 可以得到数组的和。分解成数组形式时，可以用python的特性转换int 和 str，也可以使用whole divde 和 modulo 一位一位得分别append 到 数组中。这里使用了第一种方法\r\n## 代码\r\nPython\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        leng = len(num)\r\n        sum = 0\r\n        for i in num:\r\n            sum += i* 10**(leng-1)\r\n            leng-=1\r\n        return [int(i) for i in str(sum+k)]\r\n```\r\n### 复杂度分析\r\n时间：O(n)\r\n空间：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "wonderful1234": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836682410",
      "body": "解题思路：数组的末尾与k的末尾相加，分别求出进位与余数。\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n    int carry = 0;  \r\n    int len = num.length - 1;\r\n\r\n    while (len >= 0 || k != 0) {\r\n        int sum = 0;\r\n        if (len >= 0) {\r\n            sum += num[len];\r\n            len--;\r\n        }\r\n        sum += k % 10 + carry;\r\n        carry = sum / 10;\r\n        list.add(sum % 10);\r\n       k /= 10;\r\n    }\r\n\r\n    if (carry == 1) {\r\n        list.add(carry);\r\n    }\r\n    Collections.reverse(list);\r\n    return list;\r\n\r\n    }\r\n}`\r\n复杂度分析：\r\n时间：O(n)\r\n空间：O(n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838630501",
      "body": "思路：定义两个数组，分别用于记录正序与倒序遍历字符串 S 时，各元素与字符元素 C 之间的距离，最后将两个数组进行比较，取最小值。\r\n`public static int[] shortestToChar(String S, char C) {\r\n    int[] ascArr = new int[S.length()];\r\n    int[] descArr = new int[S.length()];\r\n\r\n    char[] sarr = S.toCharArray();\r\n    int count = sarr.length;\r\n\r\n    for (int i = 0; i < sarr.length; i++) {\r\n        if (sarr[i] == C) {\r\n            ascArr[i] = 0;\r\n            count = 0;\r\n        } else {\r\n            ascArr[i] = ++count;\r\n        }\r\n    }\r\n    count = sarr.length;\r\n    for (int i = sarr.length - 1; i >= 0; i--) {\r\n        if (sarr[i] == C) {\r\n            descArr[i] = 0;\r\n            count = 0;\r\n        } else {\r\n            descArr[i] = ++count;\r\n        }\r\n    }\r\n    for (int i = 0; i < ascArr.length; i++) {\r\n        ascArr[i] = Math.min(ascArr[i], descArr[i]);\r\n    }\r\n    return ascArr;\r\n}`\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838630501",
      "body": "思路：定义两个数组，分别用于记录正序与倒序遍历字符串 S 时，各元素与字符元素 C 之间的距离，最后将两个数组进行比较，取最小值。\r\n`public static int[] shortestToChar(String S, char C) {\r\n    int[] ascArr = new int[S.length()];\r\n    int[] descArr = new int[S.length()];\r\n\r\n    char[] sarr = S.toCharArray();\r\n    int count = sarr.length;\r\n\r\n    for (int i = 0; i < sarr.length; i++) {\r\n        if (sarr[i] == C) {\r\n            ascArr[i] = 0;\r\n            count = 0;\r\n        } else {\r\n            ascArr[i] = ++count;\r\n        }\r\n    }\r\n    count = sarr.length;\r\n    for (int i = sarr.length - 1; i >= 0; i--) {\r\n        if (sarr[i] == C) {\r\n            descArr[i] = 0;\r\n            count = 0;\r\n        } else {\r\n            descArr[i] = ++count;\r\n        }\r\n    }\r\n    for (int i = 0; i < ascArr.length; i++) {\r\n        ascArr[i] = Math.min(ascArr[i], descArr[i]);\r\n    }\r\n    return ascArr;\r\n}`\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "fzzfgbw": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836683816",
      "body": "### 思路\r\n\r\n循环数组从最低位开始带进位累加，额外考虑k位数比较大的情况，最后处理最高位进位。\r\n\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int c = 0;\r\n        for (int i = num.length-1; i >=0; i--) {\r\n            int add = k% 10;\r\n            k /=10;\r\n            int sum = add + num[i] +c;\r\n            if (sum>= 10) {\r\n                sum = sum%10;\r\n                c = 1;\r\n            } else {\r\n                c = 0;\r\n            }\r\n            res.addFirst(sum);\r\n        }\r\n        \r\n        while (k>0){\r\n            int add = k% 10;\r\n            k /=10;\r\n            int sum = add +c;\r\n            if (sum>= 10) {\r\n                sum = sum%10;\r\n                c = 1;\r\n            } else {\r\n                c = 0;\r\n            }\r\n            res.addFirst(sum);\r\n        }\r\n        if (c>0){\r\n            res.addFirst(c);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N,lg k))，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836954949",
      "body": "### 思路\r\n\r\n\t从左到右，从右到左。c无非在左或者右。先从左到右找到离左边c的距离，再从右到左找离右边c的距离，并判断大小。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n   class Solution {\r\n  public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        char[] chars = s.toCharArray();\r\n        int[] res = new int[length];\r\n       \r\n        int left = -length;\r\n        for (int i = 0; i <length ; i++) {\r\n            if (chars[i] == c){\r\n                left = i;\r\n                res[i] = 0;\r\n            }else {\r\n               res[i] = i-left;\r\n            }\r\n        }\r\n        int right = 2*length;\r\n        for (int i = length-1; i >=0; i--) {\r\n            if (chars[i] == c){\r\n                right = i;\r\n            }else {\r\n                \r\n                    res[i] = Math.min(right-i,res[i]);\r\n                \r\n            }\r\n\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836954949",
      "body": "### 思路\r\n\r\n\t从左到右，从右到左。c无非在左或者右。先从左到右找到离左边c的距离，再从右到左找离右边c的距离，并判断大小。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n   class Solution {\r\n  public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        char[] chars = s.toCharArray();\r\n        int[] res = new int[length];\r\n       \r\n        int left = -length;\r\n        for (int i = 0; i <length ; i++) {\r\n            if (chars[i] == c){\r\n                left = i;\r\n                res[i] = 0;\r\n            }else {\r\n               res[i] = i-left;\r\n            }\r\n        }\r\n        int right = 2*length;\r\n        for (int i = length-1; i >=0; i--) {\r\n            if (chars[i] == c){\r\n                right = i;\r\n            }else {\r\n                \r\n                    res[i] = Math.min(right-i,res[i]);\r\n                \r\n            }\r\n\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "agentzzz": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836691767",
      "body": "### 思路\r\n\r\n将k从最后一位往前加，每次加法的结果对10取余，压入返回数组。然后除以10，与前一位相加。\r\n\r\n可能忘记讨论的情况：\r\n\r\n1. k可能比num的位数要长，因此，要确保k的剩余位数都压入结果数组\r\n2. 压入结果数组的内容是倒序的，collections.reverse()使其倒序（以前用的是C++刷题，java的collections要去了解一下）\r\n\r\n\r\n\r\n### JAVA\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n\t\tint fin = num.length - 1;\r\n\t\tList<Integer> res = new ArrayList<Integer>();\r\n\t\tint temp = 0;\r\n\t\tfor (int i = fin; i >= 0; i--) {\r\n\t\t\ttemp = num[i] + k;\r\n\t\t\tres.add(temp % 10);\r\n\t\t\tk = temp / 10;\r\n\t\t}\r\n\t\twhile (k > 0) {\r\n\t\t\tres.add(k % 10);\r\n\t\t\tk /= 10;\r\n\t\t}\r\n\t\tCollections.reverse(res);\r\n\t\treturn res;\r\n\t}\r\n```\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837942324",
      "body": "### 思路\r\n\r\n一开始的思路是用双指针，一个表示左边界，一个表示有边界。但是现实实现的时候，需要考虑的情况太多了。\r\n\r\n第一次遍历数组，记录目标字符的位置。\r\n\r\n第二次遍历数组，记录所有元素与左右边界距离的最小值。\r\n\r\n其中，第二次遍历要考虑左右边界的多种情况，没想明白。\r\n\r\n\r\n\r\n第一次写大概花了25分钟，然后去干其他事情。\r\n\r\n第二次修改+debug花了10分钟。\r\n\r\n结果虽然通过了，思路也比较简单，但是代码的逻辑不是很好。\r\n\r\n写完之后大概看了一下题解，又其他更好的方法，晚一点再学习一下。\r\n\r\n\r\n\r\njava\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n\t\tint m=0;\r\n\t\tint[] res = new int[s.length()];\r\n\t\tList<Integer> list = new ArrayList<>();\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tif(s.charAt(i)==c) list.add(i);\r\n\t\t}\r\n\t\tint index1=0,index2=0;\r\n\t\tif(list.size()==1) {\r\n\t\t\tindex1=index2=list.get(0);\r\n\t\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\t\tres[i] = Math.abs(i-index1);\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t}\t\r\n\t\tindex1 = list.get(m);\r\n\t\tindex2 = list.get(m+1);\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tres[i] = Math.min(Math.abs(i-index1), Math.abs(i-index2));\r\n\t\t\tif(i==index2) {\r\n\t\t\t\tif(index2!=list.get(list.size()-1)) {\r\n\t\t\t\t\tm++;\r\n\t\t\t\t\tindex1 = list.get(m);\r\n\t\t\t\t\tindex2 = list.get(m+1);\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t\t}\r\n\t\treturn res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)\r\n\r\n### 法二：正序倒序两遍遍历\r\n\r\n参考题解后，又用思路更加清晰的方法写了一遍。这个不算是自己的产出内容，不仅看了思路，还看了代码的实现方式。\r\n\r\n用时：15min\r\n\r\n第一次从左向右遍历的时候，第一个元素和谁比较，有两种情况\r\n\r\n- 第一个char就是我的目的char，那么令比较索引temp等于第一个字符，后续的字符与它比较，遇到新的目标字符就更新temp 的索引\r\n- 第一个char不是目标字符，那么就要设置比较索引值temp让第一个目标字符出现之前res记录的值足够大，因此，选择Integer.MIN_VALUE/2，这是一个很小的复数，i-temp就是一个很大的整数。\r\n\r\n第二次从又向左遍历，同理。需要考虑最右边的原色和谁比较的问题。设置temp = Integer.MAX_VALUE/2，这样temp-i就是一个足够大的正数。\r\n\r\njava实现\r\n\r\n```java\r\nint[] shortestToChar1(String s,char c) {\r\n\t\tint[] res = new int[s.length()];\r\n\t\tint temp = Integer.MIN_VALUE/2;\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tif(s.charAt(i)==c) temp =i;\r\n\t\t\tres[i]= i-temp;\r\n\t\t}\r\n\t\ttemp = Integer.MAX_VALUE/2;\r\n\t\tfor(int i=s.length()-1;i>=0;i--) {\r\n\t\t\tif(s.charAt(i)==c) temp = i;\r\n\t\t\tres[i] = Math.min(res[i],temp-i);\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837942324",
      "body": "### 思路\r\n\r\n一开始的思路是用双指针，一个表示左边界，一个表示有边界。但是现实实现的时候，需要考虑的情况太多了。\r\n\r\n第一次遍历数组，记录目标字符的位置。\r\n\r\n第二次遍历数组，记录所有元素与左右边界距离的最小值。\r\n\r\n其中，第二次遍历要考虑左右边界的多种情况，没想明白。\r\n\r\n\r\n\r\n第一次写大概花了25分钟，然后去干其他事情。\r\n\r\n第二次修改+debug花了10分钟。\r\n\r\n结果虽然通过了，思路也比较简单，但是代码的逻辑不是很好。\r\n\r\n写完之后大概看了一下题解，又其他更好的方法，晚一点再学习一下。\r\n\r\n\r\n\r\njava\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n\t\tint m=0;\r\n\t\tint[] res = new int[s.length()];\r\n\t\tList<Integer> list = new ArrayList<>();\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tif(s.charAt(i)==c) list.add(i);\r\n\t\t}\r\n\t\tint index1=0,index2=0;\r\n\t\tif(list.size()==1) {\r\n\t\t\tindex1=index2=list.get(0);\r\n\t\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\t\tres[i] = Math.abs(i-index1);\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t}\t\r\n\t\tindex1 = list.get(m);\r\n\t\tindex2 = list.get(m+1);\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tres[i] = Math.min(Math.abs(i-index1), Math.abs(i-index2));\r\n\t\t\tif(i==index2) {\r\n\t\t\t\tif(index2!=list.get(list.size()-1)) {\r\n\t\t\t\t\tm++;\r\n\t\t\t\t\tindex1 = list.get(m);\r\n\t\t\t\t\tindex2 = list.get(m+1);\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t\t}\r\n\t\treturn res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)\r\n\r\n### 法二：正序倒序两遍遍历\r\n\r\n参考题解后，又用思路更加清晰的方法写了一遍。这个不算是自己的产出内容，不仅看了思路，还看了代码的实现方式。\r\n\r\n用时：15min\r\n\r\n第一次从左向右遍历的时候，第一个元素和谁比较，有两种情况\r\n\r\n- 第一个char就是我的目的char，那么令比较索引temp等于第一个字符，后续的字符与它比较，遇到新的目标字符就更新temp 的索引\r\n- 第一个char不是目标字符，那么就要设置比较索引值temp让第一个目标字符出现之前res记录的值足够大，因此，选择Integer.MIN_VALUE/2，这是一个很小的复数，i-temp就是一个很大的整数。\r\n\r\n第二次从又向左遍历，同理。需要考虑最右边的原色和谁比较的问题。设置temp = Integer.MAX_VALUE/2，这样temp-i就是一个足够大的正数。\r\n\r\njava实现\r\n\r\n```java\r\nint[] shortestToChar1(String s,char c) {\r\n\t\tint[] res = new int[s.length()];\r\n\t\tint temp = Integer.MIN_VALUE/2;\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tif(s.charAt(i)==c) temp =i;\r\n\t\t\tres[i]= i-temp;\r\n\t\t}\r\n\t\ttemp = Integer.MAX_VALUE/2;\r\n\t\tfor(int i=s.length()-1;i>=0;i--) {\r\n\t\t\tif(s.charAt(i)==c) temp = i;\r\n\t\t\tres[i] = Math.min(res[i],temp-i);\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "oborc": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836695695",
      "body": "### 解题思路\r\n刚开始以为这个题是大数相加的简单版，却发现其实是两个题目。\r\n直接遍历数组，用竖式相加的思路，从低位开始加起\r\n初始化一个空数组用来存放结果\r\n1.用加数加上被加数的低位，对和取余 为当前位的结果。\r\n2.对和除以10取整，作为加数向第二低位相加，重复1的步骤，直到数组遍历结束或者加数除以10取整之后为0.\r\n### javascript\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let result = [];\r\n    for(let i = num.length-1;i>=0 || k>0;i--){\r\n        if(i>=0){\r\n            k = k + num[i];\r\n        }\r\n        result.unshift(k%10);\r\n        k = Math.floor(k/10);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n时间复杂度:\r\no(max(N,K/10)) = > O(N),线性复杂\r\n空间复杂度:\r\no(N)= > O(N),线性复杂"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838275025",
      "body": "### 解题思路\r\n\r\n根据官方题解：\r\n1.初始化一个空数组，记录数组中每个字符到目标字符的距离\r\n2.从左向右遍历数组，遍历到目标字符，记录当前下标为index，用遍历下标 i - index  为当前字符距离它右边边的目标字符的距离 ，记录在 result[i] 中，在下次遍历中作比较。\r\n3.从右向左遍历数组，遍历到目标字符，记录当前下标为index，用index - 遍历下标 i  为当前字符距离它左边的目标字符的距离。取result[i] 和 差值中最小的记录为result[i]。result 即为所求\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let str = s.split(\"\");\r\n    let cIndex = -Infinity;\r\n    let result = [];\r\n    for(let i=0;i<str.length;i++){\r\n        if(str[i] == c ){\r\n            result[i]=0;\r\n            cIndex = i;\r\n        }\r\n        result[i] = i-cIndex;\r\n    }\r\n    cIndex = Infinity;\r\n    for(let i=str.length-1;i>=0;i--){\r\n        if(str[i] == c ){\r\n            result[i]=0;\r\n            cIndex = i;\r\n        }\r\n        result[i] = Math.min(result[i],cIndex-i);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n时间复杂度：\r\no(2n) => o(n)\r\n空间复杂度：\r\no(N)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838275025",
      "body": "### 解题思路\r\n\r\n根据官方题解：\r\n1.初始化一个空数组，记录数组中每个字符到目标字符的距离\r\n2.从左向右遍历数组，遍历到目标字符，记录当前下标为index，用遍历下标 i - index  为当前字符距离它右边边的目标字符的距离 ，记录在 result[i] 中，在下次遍历中作比较。\r\n3.从右向左遍历数组，遍历到目标字符，记录当前下标为index，用index - 遍历下标 i  为当前字符距离它左边的目标字符的距离。取result[i] 和 差值中最小的记录为result[i]。result 即为所求\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let str = s.split(\"\");\r\n    let cIndex = -Infinity;\r\n    let result = [];\r\n    for(let i=0;i<str.length;i++){\r\n        if(str[i] == c ){\r\n            result[i]=0;\r\n            cIndex = i;\r\n        }\r\n        result[i] = i-cIndex;\r\n    }\r\n    cIndex = Infinity;\r\n    for(let i=str.length-1;i>=0;i--){\r\n        if(str[i] == c ){\r\n            result[i]=0;\r\n            cIndex = i;\r\n        }\r\n        result[i] = Math.min(result[i],cIndex-i);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n时间复杂度：\r\no(2n) => o(n)\r\n空间复杂度：\r\no(N)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "liandmin": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836696480",
      "body": "### 思路\r\n\r\n1. 直接遍历数组，从后往前加，满10进位，放入结果数组中\r\n2. 如果 k 比数组的number更大的话，继续遍历 k，放入结果数组\r\n3. 反转结果数组返回即可\r\n\r\n### JS\r\n\r\n```\r\nvar addToArrayForm = function (num, k) {\r\n  const res = [];\r\n  const length = num.length;\r\n\r\n  for (let i = length - 1; i >= 0; i--) {\r\n    let sum = num[i] + (k % 10);\r\n    k = Math.floor(k / 10);\r\n    if (sum >= 10) {\r\n      k++;\r\n      sum -= 10;\r\n    }\r\n    res.push(sum);\r\n  }\r\n\r\n  for (; k > 0; k = Math.floor(k / 10)) {\r\n    res.push(k % 10);\r\n  }\r\n  res.reverse();\r\n\r\n  return res;\r\n};\r\n```\r\n \r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(max(N,lg k))，其中 N 为数组长度。\r\n* 空间复杂度：O(N)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838758803",
      "body": "## JavaScript\r\n\r\n### 思路\r\n\r\n正向和反向各遍历一次数组，取两次遍历中最小的值即可\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  const res = new Array(s.length);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      res[i] = 0;\r\n    } else {\r\n      res[i] = i === 0 ? Infinity : res[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) {\r\n      res[i] = res[i + 1] + 1;\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838758803",
      "body": "## JavaScript\r\n\r\n### 思路\r\n\r\n正向和反向各遍历一次数组，取两次遍历中最小的值即可\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  const res = new Array(s.length);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      res[i] = 0;\r\n    } else {\r\n      res[i] = i === 0 ? Infinity : res[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) {\r\n      res[i] = res[i + 1] + 1;\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "edge-wzw": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836712891",
      "body": "### 思路\r\n\r\n逐位相加\r\n\r\n首先新建一个链表，从数组num尾部和K的低位开始反向遍历，依次求和得到对应的sum，根据求和结果判断是否进位（carry=1表示进位，carry=0表示无进位），将sum对10取模后加入到链表头部。\r\n\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public static List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int carry = 0;      //进位数，1表示进位，0表示无进位\r\n        int sum;    //每次求和的值\r\n        int n = num.length - 1;     //遍历数组时的索引\r\n        while (k != 0 || n >= 0){\r\n            sum = carry + (k % 10);\r\n            if (n >= 0){\r\n                sum += num[n];\r\n            }\r\n\r\n            carry = (sum > 9) ? 1:0;\r\n            res.addFirst(sum % 10);\r\n            n--;\r\n            k = k / 10;\r\n        }\r\n        if (carry == 1){res.addFirst(1);}\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(n, k))，其中 n 为数组长度, k为数值K的长度。\r\n- 空间复杂度：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838514773",
      "body": "解题思路：暴力寻找，首先生成长度为s.length()的结果数组res。遍历字符串的字符，当遇到不是c的字符时，向左和向右寻找最近的c字符的索引，然后与当前字符索引进行距离计算，取最小值存入结果数组res中；遍历时遇到字符c则存入0。\r\n\r\n代码\r\n\r\n```java\r\npublic class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int l, r;\r\n        int[] res = new int[s.length()];\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) != c) {\r\n                l = r = i;\r\n                while (l > 0 && (s.charAt(l) != c)){\r\n                    l--;\r\n                }\r\n                while (r < s.length()-1 && (s.charAt(r) != c)){\r\n                    r++;\r\n                }\r\n                if (s.charAt(l) != c){\r\n                    res[i] = Math.abs(i - r);\r\n                }else if (s.charAt(r) != c){\r\n                    res[i] = Math.abs(i - l);\r\n                }else {\r\n                    res[i] = Math.min(Math.abs(i - l), Math.abs(i - r));\r\n                }\r\n            }else {\r\n                res[i] = 0;\r\n            }\r\n\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n复杂度分析\r\n\r\n- 时间复杂度：O(n<sup>2</sup>)，其中 n 为字符串长度。\r\n- 空间复杂度：O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838514773",
      "body": "解题思路：暴力寻找，首先生成长度为s.length()的结果数组res。遍历字符串的字符，当遇到不是c的字符时，向左和向右寻找最近的c字符的索引，然后与当前字符索引进行距离计算，取最小值存入结果数组res中；遍历时遇到字符c则存入0。\r\n\r\n代码\r\n\r\n```java\r\npublic class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int l, r;\r\n        int[] res = new int[s.length()];\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) != c) {\r\n                l = r = i;\r\n                while (l > 0 && (s.charAt(l) != c)){\r\n                    l--;\r\n                }\r\n                while (r < s.length()-1 && (s.charAt(r) != c)){\r\n                    r++;\r\n                }\r\n                if (s.charAt(l) != c){\r\n                    res[i] = Math.abs(i - r);\r\n                }else if (s.charAt(r) != c){\r\n                    res[i] = Math.abs(i - l);\r\n                }else {\r\n                    res[i] = Math.min(Math.abs(i - l), Math.abs(i - r));\r\n                }\r\n            }else {\r\n                res[i] = 0;\r\n            }\r\n\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n复杂度分析\r\n\r\n- 时间复杂度：O(n<sup>2</sup>)，其中 n 为字符串长度。\r\n- 空间复杂度：O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "SunStrongChina": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836713429",
      "body": "> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> \r\n\r\n\r\n> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> ```\r\n**思路**\r\n1.将k转化为字符串\r\n2.比较k和num那个位数多，先进行少位数的求和相加\r\n3.添加更多的那几位\r\n\r\n**python**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num, k):\r\n        k_str=str(k)\r\n        result=[]\r\n        if len(k_str)>len(num):\r\n            len1=len(num)\r\n            len2=len(k_str)\r\n            num,k_str=k_str,num\r\n        else:\r\n            len1=len(k_str)\r\n            len2=len(num)\r\n            \r\n        value_2=0    \r\n        for i in range(-1,-len1-1,-1):\r\n            value1=int(num[i])+int(k_str[i])+value_2\r\n          \r\n            if value1>=10:\r\n                value_1=value1%10\r\n                value_2=1\r\n            else:\r\n                value_1=value1\r\n                value_2=0\r\n            result.append(value_1)\r\n        \r\n        for j in range(-len1-1,-len2-1,-1):\r\n            value1=int(num[j])+value_2\r\n            if value1>=10:\r\n                value_1=value1%10\r\n                value_2=1\r\n            else:\r\n                value_1=value1\r\n                value_2=0\r\n            result.append(value_1)\r\n        if value_2!=0:\r\n            result.append(value_2)\r\n        result.reverse()    \r\n        return result\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n时间复杂度：O(max(N,k))，其中 N 为数组长度，k为数值k的长度。\r\n空间复杂度：O(N)"
    },
    null,
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839360330",
      "body": "### 1.左右遍历的方法\r\n先从左想右遍历，寻找字符串位置，然后从右向左遍历，与之前位置比较，取更小者\r\n\r\n### 2.python代码\r\n\r\n```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        k=10000\r\n        position1=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                k=i\r\n            position1.append(abs(k-i))\r\n            \r\n        \r\n        k=10000\r\n        for j in range(-1,-len(s)-1,-1):\r\n            if s[j]==c:\r\n                k=j\r\n            pos2=abs(k-j)\r\n            if position1[j]>pos2:\r\n                position1[j]=pos2\r\n        return position1\r\n            \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "naomiwufzz": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836721643",
      "body": "### 思路\r\n\r\n倒叙逐位加，先倒着遍历数组`num`，逐位相加，可以把要保存的进位存储到`k`里面，就不容易造成混乱。要注意的是`k`是可以比`num`大的，这里就和66加一不是很一样\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num, k):\r\n        result = []\r\n        for i in range(len(num)-1, -1, -1):  # 先遍历num\r\n            sum = num[i] + k % 10  # 逐位相加\r\n            k = k // 10  # k降一个位数\r\n            if sum >= 10:  # 这里是一个技巧，进位的时候，不直接处理num，而是k加一\r\n                k += 1\r\n            result.append(sum % 10)  # 不用insert降低复杂度\r\n        while k > 0:  # 若k的值不为0，直接加上去即可，同时也考虑k比num大的情况\r\n            result.append(k % 10)\r\n            k = k // 10\r\n        result.reverse()\r\n        return result\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(max(n,k)) 整数与数组长度之间取最大，为什么官方写的是log(k)？\r\n- 空间复杂度：O(1) 除了返回值result以外，使用的空间为常数。"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838329768",
      "body": "### 思路\r\n\r\n左右各遍历一次。每次遍历，记录`c`的位置，左侧开始遍历就计算每个数到最近的左边的`c`的距离，要注意如果左边没有`c`可以记录无穷大。右侧开始遍历，记录每个数到右边的`c`的距离，是`c`的位置减掉该数的位置。如果右边没有`c`，那应该也是无穷大，所以右侧开始的话`c`初始应该是无穷大。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        result = []\r\n        left_position = float('-inf')\r\n        right_position = float('inf')\r\n        for idx, value in enumerate(s):\r\n            if value == c:\r\n                left_position = idx\r\n            result.append(idx-left_position)\r\n\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                right_position = i\r\n            result[i] = min(right_position-i, result[i])\r\n        return result\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n) 遍历2遍\r\n- 空间复杂度：O(1) 除了返回值result以外，使用的空间为常数。\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838329768",
      "body": "### 思路\r\n\r\n左右各遍历一次。每次遍历，记录`c`的位置，左侧开始遍历就计算每个数到最近的左边的`c`的距离，要注意如果左边没有`c`可以记录无穷大。右侧开始遍历，记录每个数到右边的`c`的距离，是`c`的位置减掉该数的位置。如果右边没有`c`，那应该也是无穷大，所以右侧开始的话`c`初始应该是无穷大。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        result = []\r\n        left_position = float('-inf')\r\n        right_position = float('inf')\r\n        for idx, value in enumerate(s):\r\n            if value == c:\r\n                left_position = idx\r\n            result.append(idx-left_position)\r\n\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                right_position = i\r\n            result[i] = min(right_position-i, result[i])\r\n        return result\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n) 遍历2遍\r\n- 空间复杂度：O(1) 除了返回值result以外，使用的空间为常数。\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "newVincentFong": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836729444",
      "body": "# Add to Array-Form of Integer\r\n\r\n## Discuss\r\n\r\n* `num` can be longer than `k`, or can be shorter than k\r\n \r\nso, the times of iterations should be the max between their lengths\r\n\r\n* save the result in the given array\r\n\r\nspace: O(n) -> O(1), less use of `splice`, better timing\r\n\r\n## Code\r\n\r\n```typescript\r\n/**\r\n * @remarks\r\n * * `num` can be longer than `k`, or can be shorter than k\r\n * \r\n * so, the times of iterations should be the max between their lengths\r\n * \r\n * * save the result in the given array\r\n * \r\n * space: O(n) -> O(1), less use of `splice`, better timing\r\n */\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    let shouldCarry = false\r\n    const length = Math.max(num.length, k.toString().length)\r\n    const difference = length - num.length\r\n    for (let i = length - 1; i >= 0; i--) {\r\n        const original = num[i - difference] || 0\r\n        const toAdd = k % 10\r\n        const added = original + toAdd + (shouldCarry ? 1 : 0) as number\r\n        const toSave = added % 10\r\n        if (i - difference >= 0) {\r\n            num[i- difference] = toSave\r\n        } else {\r\n            num.splice(0, 0, toSave)\r\n        }\r\n        shouldCarry = Math.floor(added / 10) === 1\r\n        k = Math.floor(k / 10)\r\n    }\r\n    if (shouldCarry) {\r\n        num.splice(0, 0, 1)\r\n    }\r\n    return num\r\n};\r\n// time O(n)\r\n// space O(1)\r\n``"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838642501",
      "body": "# Shortest Distance to a Character\r\n\r\n## Discuss\r\n\r\n* the min distance of str[i] is only related to the **two** closest c char that are on both sides of str[i]\r\n\r\nBefore:\r\n\r\n`Min(abs(c1 - str[i]), abs(c2 - str[i]), ... abs(cN - str[i]))`\r\n\r\nAfter:\r\n\r\n`Min(abs(cLEFT - str[i]), abs(cRIGHT - str[i]))`\r\n\r\n* iterate forward and then backward\r\n\r\nwatch out for those `empty` Array items\r\n\r\n## Code\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const result = []\r\n    // forwards\r\n    let prevC = -1\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            prevC = i\r\n            result[i] = 0\r\n        } else if (prevC !== -1) {\r\n            result[i] = i - prevC\r\n        }\r\n    }\r\n    prevC = -1\r\n    // backwards\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (prevC !== -1) {\r\n            // CAUTION\r\n            result[i] = typeof result[i] === 'number' ? Math.min(prevC - i, result[i]) : prevC - i\r\n        }\r\n        if (s[i] === c) {\r\n            prevC = i\r\n        }\r\n    }\r\n    return result\r\n};\r\n// time O(n)\r\n// space O(n)\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838642501",
      "body": "# Shortest Distance to a Character\r\n\r\n## Discuss\r\n\r\n* the min distance of str[i] is only related to the **two** closest c char that are on both sides of str[i]\r\n\r\nBefore:\r\n\r\n`Min(abs(c1 - str[i]), abs(c2 - str[i]), ... abs(cN - str[i]))`\r\n\r\nAfter:\r\n\r\n`Min(abs(cLEFT - str[i]), abs(cRIGHT - str[i]))`\r\n\r\n* iterate forward and then backward\r\n\r\nwatch out for those `empty` Array items\r\n\r\n## Code\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const result = []\r\n    // forwards\r\n    let prevC = -1\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            prevC = i\r\n            result[i] = 0\r\n        } else if (prevC !== -1) {\r\n            result[i] = i - prevC\r\n        }\r\n    }\r\n    prevC = -1\r\n    // backwards\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (prevC !== -1) {\r\n            // CAUTION\r\n            result[i] = typeof result[i] === 'number' ? Math.min(prevC - i, result[i]) : prevC - i\r\n        }\r\n        if (s[i] === c) {\r\n            prevC = i\r\n        }\r\n    }\r\n    return result\r\n};\r\n// time O(n)\r\n// space O(n)\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "DAXIAdaxia": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836737171",
      "body": "### **思路：**\r\n从个位数开始，每个数从后往前依次相加\r\n\r\n### **代码：**\r\npublic class Solution {\r\n\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        ArrayList<Integer> list = new ArrayList<Integer>();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            int temp = num[i] + k % 10;\r\n            k /= 10;\r\n            if (temp >= 10){\r\n                k++;\r\n                temp -= 10;\r\n            }\r\n            list.add(temp);\r\n        }\r\n\r\n        while (k > 0){\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n\r\n### **复杂度分析：**\r\n时间复杂度：最坏的情况下，需要遍历n次，所以时间复杂度为O(n)\r\n空间复杂度：最坏的情况下，需要一个长度为(n+1)的列表来存储结果，所以空间复杂度为O(n)\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838528608",
      "body": "### **思路：**\r\n先从左往右计算出当前字符距离上一个字符c的距离（第一个需要用最小整数的一半来代替，保证 i-pre 为正），紧接着就是从右往左计算出当前字符距离上一个字符c的距离（第一个需要用最大整数的一半来代替，保证 post-i 为正），同时比较两个距离的大小，只保留距离短的\r\n### **代码：**\r\npublic class Solution {\r\n\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n\r\n        int pre = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < len; i++) {\r\n            if (c == s.charAt(i)) pre = i;\r\n            res[i] = i - pre;\r\n        }\r\n\r\n        int post = Integer.MAX_VALUE / 2;\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            if (c == s.charAt(i)) post = i;\r\n            res[i] = Integer.min(res[i],post - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n### **复杂度分析：**\r\n时间复杂度：需要单独进行两个for循环，所以时间复杂度为O(n)，n为字符串长度\r\n空间复杂度：最短距离需要用数组来存，所以空间复杂度为O(n)，n为字符串长度"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838528608",
      "body": "### **思路：**\r\n先从左往右计算出当前字符距离上一个字符c的距离（第一个需要用最小整数的一半来代替，保证 i-pre 为正），紧接着就是从右往左计算出当前字符距离上一个字符c的距离（第一个需要用最大整数的一半来代替，保证 post-i 为正），同时比较两个距离的大小，只保留距离短的\r\n### **代码：**\r\npublic class Solution {\r\n\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n\r\n        int pre = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < len; i++) {\r\n            if (c == s.charAt(i)) pre = i;\r\n            res[i] = i - pre;\r\n        }\r\n\r\n        int post = Integer.MAX_VALUE / 2;\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            if (c == s.charAt(i)) post = i;\r\n            res[i] = Integer.min(res[i],post - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n### **复杂度分析：**\r\n时间复杂度：需要单独进行两个for循环，所以时间复杂度为O(n)，n为字符串长度\r\n空间复杂度：最短距离需要用数组来存，所以空间复杂度为O(n)，n为字符串长度"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "supermeohh": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836744653",
      "body": "\r\n## 思路\r\n进位用k通过加一保存\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //List<Integer>初始化，需要返回值\r\n        int n = num.length;\r\n        List<Integer>res = new ArrayList<>();\r\n        //List<Integer>指的是存int类型数据的列表\r\n        for(int i = n-1;i>=0;i--){\r\n            //%（取余）和 /（取整）\r\n            //取num的最低位和k值的个位\r\n            int sum = num[i]+k%10;\r\n            //取k值的个位以上\r\n            k/=10;\r\n            if (sum>=10){\r\n                //和有进位加一\r\n                k++;\r\n                //sum-10\r\n                sum-=10;\r\n            }\r\n            //赋值到链表\r\n            res.add(sum);\r\n        }\r\n        //多余的k值位数直接加上去\r\n        for(;k>0;k/=10){\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838595332",
      "body": "## 思路\r\n1、正向取值为i-prev\r\n2、逆向取值为prev-i\r\n3、比较两个值赋值给ans[]\r\n4、打印\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        //s.length()括号不能丢\r\n        int n = s.length();\r\n        int [] ans = new int[n];\r\n        //prev初始值为int整型的最小值的一半\r\n        //保证有prev参与的加减运算不会溢出。同时起到最小值的效果\r\n        //不知道为什么不能是0呢？\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        //charAt() 方法可返回指定位置的字符\r\n        //语法stringObject.charAt(index)\r\n        //s.charaT(i)\r\n        for(int i = 0;i < n;i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            //结果在if外，跟着每一次的for循环而不是if\r\n                ans[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = n-1;i >= 0;i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n                //min和max需要Math调用\r\n                ans[i] =Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838595332",
      "body": "## 思路\r\n1、正向取值为i-prev\r\n2、逆向取值为prev-i\r\n3、比较两个值赋值给ans[]\r\n4、打印\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        //s.length()括号不能丢\r\n        int n = s.length();\r\n        int [] ans = new int[n];\r\n        //prev初始值为int整型的最小值的一半\r\n        //保证有prev参与的加减运算不会溢出。同时起到最小值的效果\r\n        //不知道为什么不能是0呢？\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        //charAt() 方法可返回指定位置的字符\r\n        //语法stringObject.charAt(index)\r\n        //s.charaT(i)\r\n        for(int i = 0;i < n;i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            //结果在if外，跟着每一次的for循环而不是if\r\n                ans[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = n-1;i >= 0;i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n                //min和max需要Math调用\r\n                ans[i] =Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "bowlofnoodles": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836746047",
      "body": "### 思路\r\n\r\n模拟加法按位逐位相加\r\n\r\n### 代码 js\r\n\r\n\r\n``` javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const result = [];\r\n    const length = num.length;\r\n    for (let i = length - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        result.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        result.push(k % 10);\r\n    }\r\n    result.reverse();\r\n    return result;\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：忽略返回值创建的数组，O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837629522",
      "body": "### 思路\r\n\r\n暴力解法，先存取c下标数组，再遍历数组算s中每个字符的最小距离\r\n### 代码\r\n\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const index = [];\r\n    const result = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            index.push(i);\r\n        }\r\n    }\r\n    for (let j = 0; j < s.length; j++) {\r\n        if (s[j] === c) {\r\n            result.push(0);\r\n        } else {\r\n            result.push(Math.min(...index.map(item => Math.abs(j - item))));\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N*N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837629522",
      "body": "### 思路\r\n\r\n暴力解法，先存取c下标数组，再遍历数组算s中每个字符的最小距离\r\n### 代码\r\n\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const index = [];\r\n    const result = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            index.push(i);\r\n        }\r\n    }\r\n    for (let j = 0; j < s.length; j++) {\r\n        if (s[j] === c) {\r\n            result.push(0);\r\n        } else {\r\n            result.push(Math.min(...index.map(item => Math.abs(j - item))));\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N*N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "jawn-ha": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836746634",
      "body": "#### 思路：\r\n数组逆序遍历，然后从个位数开始相加，将结果push新数组，最后将新数组翻转\r\n要注意进位尤其是最后一位的进位还要注意k位数比num多的情况\r\n#### 代码 JS\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n  let res = []\r\n  for(let i = num.length-1; i>= 0; --i) {\r\n      let sum = num[i] + k%10\r\n      k = Math.floor(k / 10)\r\n\r\n      if(sum >=10) {\r\n          sum = sum % 10   \r\n          k++      \r\n        \r\n      }     \r\n\r\n      res.push(sum) \r\n  }\r\n   \r\n  for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n  for(let i =0; i<Math.floor(res.length/2); i++){\r\n      [res[i], res[res.length-1-i]] =  [res[res.length-1-i], res[i]]\r\n  }\r\n  return res\r\n};\r\n```\r\n#### 复杂度分析：\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838335642",
      "body": "#### 思路\r\n左右各遍历一次，然后看最小距离\r\n\r\n#### 代码 javascript\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n   const l = s.length\r\n\r\n   let res = []\r\n   for(let i = 0; i< l; i++) {\r\n      if(s.charAt(i) === c){\r\n          res[i] = 0\r\n      } else {\r\n          res[i] = res[i-1] === void 0 ? Infinity : res[i-1] + 1\r\n      }\r\n   }\r\n   for(let i = l-1; i>=0; i--) {\r\n      if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n   }\r\n   return res\r\n};\r\n```\r\n#### 复杂度\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838335642",
      "body": "#### 思路\r\n左右各遍历一次，然后看最小距离\r\n\r\n#### 代码 javascript\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n   const l = s.length\r\n\r\n   let res = []\r\n   for(let i = 0; i< l; i++) {\r\n      if(s.charAt(i) === c){\r\n          res[i] = 0\r\n      } else {\r\n          res[i] = res[i-1] === void 0 ? Infinity : res[i-1] + 1\r\n      }\r\n   }\r\n   for(let i = l-1; i>=0; i--) {\r\n      if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n   }\r\n   return res\r\n};\r\n```\r\n#### 复杂度\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "lzdFeiFei": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836747177",
      "body": "**思路**\r\n官方解法\r\n\r\n**代码：**\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const res = []\r\n    const n = num.length\r\n    for(let i = n-1;i>=0;i--){\r\n        let sum = num[i] + k % 10\r\n        k = Math.floor(k/10)\r\n        if(sum>=10){\r\n            k++\r\n            sum -= 10\r\n        }\r\n        res.push(sum)\r\n    }\r\n    for(;k>0;k = Math.floor(k/10)){\r\n        res.push(k % 10)\r\n    }\r\n    res.reverse()\r\n    return res\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\r\n- 空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838672483",
      "body": "```\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838672483",
      "body": "```\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "LASIWan": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836748306",
      "body": "### 思路\r\n采用每一位分别相加，并判断是否进位的方法：\r\n1、声明一个空数组\r\n2、从末位开始循环数组的每一位，并与加数k按位相加\r\n3、判断是否需要进位，当和大于10时，将结果存入下一位\r\n4、通过数组方法将存入顺序颠倒即可\r\n\r\n\r\n\r\n### JavaScript\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838531788",
      "body": "### 思路\r\n\r\n判断目标字符与数组每一位的最小距离，那么则有几种情况\r\n目标在左侧，直接用当前位置减去目标index；\r\n目标在右侧，直接用目标index减去当前位置；\r\n两侧都有目标，则比较两侧之前的距离取最小值。\r\n\r\n\r\n### 代码\r\n\r\n```js\r\nvar shortestToChar = function(s,c){\r\n    let res = Array(s.length).fill(0);\r\n    \r\n\r\n    for(let i=0; i<s.length; i++){\r\n        if (s[i] === c) continue;\r\n\r\n        let l = i;\r\n        let r = i;\r\n        let shortest = Infinity;\r\n\r\n        while(l>=0){\r\n            if(s[l]===c){\r\n                shortest = Math.min(shortest, i-l); \r\n                break;\r\n            }\r\n            l--;\r\n        }\r\n        while(r<s.length){\r\n            if(s[r]===c){\r\n                shortest = Math.min(shortest,r-i);\r\n                break;\r\n            }\r\n            r++;\r\n        }\r\n        res[i]=shortest;\r\n    }\r\n    return res;\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N方)，两层循环。\r\n- 空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838531788",
      "body": "### 思路\r\n\r\n判断目标字符与数组每一位的最小距离，那么则有几种情况\r\n目标在左侧，直接用当前位置减去目标index；\r\n目标在右侧，直接用目标index减去当前位置；\r\n两侧都有目标，则比较两侧之前的距离取最小值。\r\n\r\n\r\n### 代码\r\n\r\n```js\r\nvar shortestToChar = function(s,c){\r\n    let res = Array(s.length).fill(0);\r\n    \r\n\r\n    for(let i=0; i<s.length; i++){\r\n        if (s[i] === c) continue;\r\n\r\n        let l = i;\r\n        let r = i;\r\n        let shortest = Infinity;\r\n\r\n        while(l>=0){\r\n            if(s[l]===c){\r\n                shortest = Math.min(shortest, i-l); \r\n                break;\r\n            }\r\n            l--;\r\n        }\r\n        while(r<s.length){\r\n            if(s[r]===c){\r\n                shortest = Math.min(shortest,r-i);\r\n                break;\r\n            }\r\n            r++;\r\n        }\r\n        res[i]=shortest;\r\n    }\r\n    return res;\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N方)，两层循环。\r\n- 空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "fakerbaby": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836751618",
      "body": "## [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n难度:**简单**\r\n\r\n对于非负整数 `X` 而言，*`X`* 的*数组形式*是每位数字按从左到右的顺序形成的数组。例如，如果 `X = 1231`，那么其数组形式为 `[1,2,3,1]`。\r\n\r\n给定非负整数 `X` 的数组形式 `A`，返回整数 `X+K` 的数组形式。\r\n\r\n---\r\n\r\n**思路1**\r\n\r\n首先将原属组转化成字符串，然后转换成整型相加然后在切分成数组。最后返回数组为所求。\r\n\r\n**代码**\r\n\r\n~~~python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        tmp = ''\r\n        for index in num:\r\n            tmp += str(index)\r\n        res_int = int(tmp) + k\r\n        res = [int(x) for x in str(res_int)]\r\n        return res\r\n\r\n\r\n~~~\r\n\r\n\r\n\r\n**复杂度**\r\n\r\n时间：O(n)\r\n\r\n空间：O(1)\r\n\r\n---\r\n\r\n**思路2**\r\n\r\n```\r\n<加法模板>    \r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n**代码**\r\n\r\n~~~python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        i = len(A) - 1\r\n        while K:\r\n            A[i] += K\r\n            K, A[i] = A[i] // 10, A[i] % 10\r\n            i -= 1\r\n            if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n        return A\r\n\r\n\r\n~~~\r\n\r\n\r\n\r\n**复杂度**\r\n\r\n时间：O(n)\r\n\r\n空间：O(n)\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838706823",
      "body": "# [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 难度简单\r\n\r\n给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。\r\n\r\n返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。\r\n\r\n两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。\r\n\r\n---\r\n\r\n### 思路baseline:\r\n\r\n朴素算法，首先把c字符位置用数组记录，然后依次比较所有来得到最近的距离。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        pos,i = [],0 #pos记录位置\r\n        for e in s:\r\n            if e == c:\r\n                pos.append(i)\r\n            i += 1\r\n        Len = len(s)\r\n        ans = [0]*(Len)\r\n        min = Len\r\n        for b in range(Len):\r\n            min = Len\r\n            for c in pos:\r\n                min = min if min <= abs(b-c) else abs(b-c)\r\n                print(b)\r\n            ans[b] = min\r\n        return ans\r\n        \r\n```\r\n\r\n### 复杂度\r\n\r\n时间：$O(n^2)\r\n\r\n空间：$O(n)\r\n\r\n---\r\n\r\n### 思路strongline:\r\n\r\n从左向右和从右向左分别遍历一边，然后取最小的距离\r\n\r\n### 代码：\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -10000\r\n        ans = []\r\n        for i in range(len(S)):\r\n            if S[i] == C: pre = i\r\n            ans.append(i - pre)\r\n        pre = 20000\r\n        for i in range(len(S) - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            ans[i] = min(ans[i], pre - i)\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：$O(n)\r\n\r\n空间：$O(n)\r\n\r\n\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838706823",
      "body": "# [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 难度简单\r\n\r\n给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。\r\n\r\n返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。\r\n\r\n两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。\r\n\r\n---\r\n\r\n### 思路baseline:\r\n\r\n朴素算法，首先把c字符位置用数组记录，然后依次比较所有来得到最近的距离。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        pos,i = [],0 #pos记录位置\r\n        for e in s:\r\n            if e == c:\r\n                pos.append(i)\r\n            i += 1\r\n        Len = len(s)\r\n        ans = [0]*(Len)\r\n        min = Len\r\n        for b in range(Len):\r\n            min = Len\r\n            for c in pos:\r\n                min = min if min <= abs(b-c) else abs(b-c)\r\n                print(b)\r\n            ans[b] = min\r\n        return ans\r\n        \r\n```\r\n\r\n### 复杂度\r\n\r\n时间：$O(n^2)\r\n\r\n空间：$O(n)\r\n\r\n---\r\n\r\n### 思路strongline:\r\n\r\n从左向右和从右向左分别遍历一边，然后取最小的距离\r\n\r\n### 代码：\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -10000\r\n        ans = []\r\n        for i in range(len(S)):\r\n            if S[i] == C: pre = i\r\n            ans.append(i - pre)\r\n        pre = 20000\r\n        for i in range(len(S) - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            ans[i] = min(ans[i], pre - i)\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：$O(n)\r\n\r\n空间：$O(n)\r\n\r\n\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "yuris304": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836751629",
      "body": "## 思路\r\n从末尾开始依次往前模拟加法运算\r\n\r\n## 关键点\r\n\r\n-  结束条件 num到首位& k加完 & 进位为0\r\n-  每次循环中要判断数组索引是否越界\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res=new LinkedList<Integer>();\r\n        int n=num.length-1;int flag=0;\r\n        while(n>-1||k!=0||flag!=0){\r\n            int tep;\r\n            if(n<0) tep=k%10+flag;\r\n            else tep=k%10+num[n]+flag;\r\n            k/=10;\r\n            flag=tep/10;\r\n            tep=tep%10;\r\n            res.add(0,tep);\r\n            n--;\r\n        }\r\n        return res;      \r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(log(k),n))$\r\n- 空间复杂度：$O(1)$"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838315989",
      "body": "## 思路\r\n正反各一次遍历，第一次正向记录每一个字符与上一个目标字符的距离，第二次反向保留距离最小值\r\n\r\n## 关键点\r\n\r\n-  初始化用MAX_VALUE/2的形式，避免越界\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] S=s.toCharArray();\r\n        int[] res=new int[S.length];\r\n        int dis=Integer.MAX_VALUE/2;\r\n        for(int i=0;i<S.length;i++){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=dis++;\r\n        }\r\n        for(int i=S.length-1;i>-1;i--){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=Math.min(dis++,res[i]);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838315989",
      "body": "## 思路\r\n正反各一次遍历，第一次正向记录每一个字符与上一个目标字符的距离，第二次反向保留距离最小值\r\n\r\n## 关键点\r\n\r\n-  初始化用MAX_VALUE/2的形式，避免越界\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] S=s.toCharArray();\r\n        int[] res=new int[S.length];\r\n        int dis=Integer.MAX_VALUE/2;\r\n        for(int i=0;i<S.length;i++){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=dis++;\r\n        }\r\n        for(int i=S.length-1;i>-1;i--){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=Math.min(dis++,res[i]);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Hazelnuttt": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836754397",
      "body": "### 思路\r\n把 num 和 k 都转成数组，进行大数相加\r\n\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  k = k.toString().split(\"\").map(item => Number(item));\r\n\r\n  let carry = 0;\r\n  let result = []\r\n  while(num.length || k.length) {\r\n    carry += ~~num.pop() + ~~k.pop();\r\n    if(carry < 10){\r\n      result.unshift(carry);\r\n      carry = 0;\r\n    }else{\r\n      result.unshift(carry - 10);\r\n      carry = 1;\r\n    }\r\n  }\r\n\r\n  if(carry){\r\n    result.unshift(carry);\r\n    return result;\r\n  }else{\r\n    return result;\r\n  }\r\n\r\n\r\n};\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838578435",
      "body": "### 解题思路\r\n贪心算法\r\n左边遍历，最小距离是多少，右边遍历，最小距离是多少，最后遍历取最小值\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  let n = s.length;\r\n  let dp = new Array(n).fill(0);\r\n  let leftDp = new Array(n).fill(0);\r\n  let rightDp = new Array(n).fill(0);\r\n\r\n  let prev = -Infinity;\r\n  for(let i = 0; i < n; i++) {\r\n    if(s[i] === c) prev = i;\r\n    leftDp[i] = i - prev;\r\n  }\r\n\r\n  prev = Infinity;\r\n  for(let i = n - 1; i >= 0; i--) {\r\n    if(s[i] === c) prev = i;\r\n    rightDp[i] = prev - i;\r\n  }\r\n\r\n  for(let i = 0; i < n; i++){\r\n    dp[i] = Math.min(rightDp[i], leftDp[i])\r\n  };\r\n\r\n  return dp;\r\n\r\n};\r\n\r\n\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838578435",
      "body": "### 解题思路\r\n贪心算法\r\n左边遍历，最小距离是多少，右边遍历，最小距离是多少，最后遍历取最小值\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  let n = s.length;\r\n  let dp = new Array(n).fill(0);\r\n  let leftDp = new Array(n).fill(0);\r\n  let rightDp = new Array(n).fill(0);\r\n\r\n  let prev = -Infinity;\r\n  for(let i = 0; i < n; i++) {\r\n    if(s[i] === c) prev = i;\r\n    leftDp[i] = i - prev;\r\n  }\r\n\r\n  prev = Infinity;\r\n  for(let i = n - 1; i >= 0; i--) {\r\n    if(s[i] === c) prev = i;\r\n    rightDp[i] = prev - i;\r\n  }\r\n\r\n  for(let i = 0; i < n; i++){\r\n    dp[i] = Math.min(rightDp[i], leftDp[i])\r\n  };\r\n\r\n  return dp;\r\n\r\n};\r\n\r\n\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "WIN0624": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836759785",
      "body": "## 思路\r\n\r\n* 把K加入A中，降低空间复杂度\r\n    * 从A的最后一位开始遍历，先将K（carry初始化为K）与最后一位相加，保留余数，整除10之后进位，直至carry为0\r\n    * 时间复杂度：O(N+max(0, K-N))\r\n    * 空间复杂度：O(max(1, K-N))\r\n* 难点：两者长度不等的情况，如何处理\r\n    * 若两者相等，最后多出的carry，新建B，把往A头部补位，变成B和A相加\r\n    * 若A长于B，则carry为0，不影响A继续补位\r\n    * 若B长于A， 则等同于有多出carry，B的补位可以直接通过数组相加，把当前位当做一个数组\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        carry = k\r\n        for i in range(len(num) - 1, -1, -1):\r\n            num[i], carry = (num[i] + carry) % 10, (num[i] + carry) // 10\r\n\t# deal with remain\r\n        B = []\r\n        while carry > 0:\r\n            B = [carry % 10] + B\r\n            carry //= 10\r\n        \r\n        return B + num\r\n```\r\n\r\n## 复杂度分析\r\n\r\n  * 时间复杂度：O(N+max(0, K-N))\r\n  * 空间复杂度：O(max(1, K-N))"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838717744",
      "body": "## 思路\r\n\r\n  * 从左往右遍历一次，只记录到上一个C元素的距离（即在其右边的C），为`i-prev`\r\n  * 从右往左遍历一次，只记录到上一个C元素的距离(即在其左边的C）, 为`prev-i`\r\n  * 两个数组对应位数取最小值\r\n  * 要点\r\n      * 记住上一个，而非下一个，使得可以一边往后遍历，一边往ans加元素\r\n      * 不必分开两个数组存储，就存到一个，只不过第二次遍历的时候增加一个min的比较\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nClass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        ans = []\r\n        # left to right iteration\r\n        prev = float('-inf')\r\n        for num, val in enumerate(S):\r\n            if val == C:\tprev = num\r\n            ans.append(num - prev)\r\n\t\t\r\n        # right to left iteration\r\n        prev = float('inf')\r\n        for num in range(len(S) - 1, -1, -1):\r\n            if S[num] == C:\tprev = num\r\n            ans[num] = min(ans[num], prev - num)\r\n        \r\n        return ans\r\n```\r\n\r\n## 复杂度分析\r\n\r\n  * 时间复杂度：$O(N)$\r\n  * 空间复杂度：$O(N)$"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838717744",
      "body": "## 思路\r\n\r\n  * 从左往右遍历一次，只记录到上一个C元素的距离（即在其右边的C），为`i-prev`\r\n  * 从右往左遍历一次，只记录到上一个C元素的距离(即在其左边的C）, 为`prev-i`\r\n  * 两个数组对应位数取最小值\r\n  * 要点\r\n      * 记住上一个，而非下一个，使得可以一边往后遍历，一边往ans加元素\r\n      * 不必分开两个数组存储，就存到一个，只不过第二次遍历的时候增加一个min的比较\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nClass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        ans = []\r\n        # left to right iteration\r\n        prev = float('-inf')\r\n        for num, val in enumerate(S):\r\n            if val == C:\tprev = num\r\n            ans.append(num - prev)\r\n\t\t\r\n        # right to left iteration\r\n        prev = float('inf')\r\n        for num in range(len(S) - 1, -1, -1):\r\n            if S[num] == C:\tprev = num\r\n            ans[num] = min(ans[num], prev - num)\r\n        \r\n        return ans\r\n```\r\n\r\n## 复杂度分析\r\n\r\n  * 时间复杂度：$O(N)$\r\n  * 空间复杂度：$O(N)$"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "ShunzWu012": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836761592",
      "body": "### 思路\r\n按位相加，注意k的长度可能比num大\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n        int n = num.length;\r\n        for(int i = n - 1; i >= 0; i--){\r\n            int sums = num[i] + k % 10;\r\n            k /= 10;\r\n            if(sums >= 10){\r\n                k++;\r\n            }\r\n            ans.add(sums%10);\r\n        }\r\n        while(k != 0){\r\n            ans.add(k%10);\r\n            k /= 10;\r\n        }\r\n        n = ans.size();\r\n        for(int i = 0; i < n/2; i++){\r\n            int temp = ans.get(i);\r\n            ans.set(i, ans.get(n-i-1));\r\n            ans.set(n-i-1, temp);\r\n        }\r\n        return  ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(max(n, log(10, k)))\r\n- S:O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837715789",
      "body": "### 思路\r\n对于每个字符而言，只需要比较当前字符到两边c的最短距离即可。\r\n\r\n注;为了不讨论左端点和右端点，对索引数组进行预处理，两端加上一个大值。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> idx = new ArrayList<>();\r\n        int n = s.length();\r\n        idx.add(n);\r\n        for(int i = 0; i < n; i++){\r\n            if(s.charAt(i) == c){\r\n                idx.add(i);\r\n            }\r\n        }\r\n        idx.add(n*2);\r\n        int[] ans = new int[n];\r\n        int j = 0;\r\n        for(int i = 0; i < n; i++){\r\n            if(s.charAt(i) == c){\r\n                ans[i] = 0;\r\n                j++;\r\n            }\r\n            else{\r\n                ans[i] = Math.min(Math.abs(i - idx.get(j)), Math.abs(idx.get(j+1) - i));\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837715789",
      "body": "### 思路\r\n对于每个字符而言，只需要比较当前字符到两边c的最短距离即可。\r\n\r\n注;为了不讨论左端点和右端点，对索引数组进行预处理，两端加上一个大值。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> idx = new ArrayList<>();\r\n        int n = s.length();\r\n        idx.add(n);\r\n        for(int i = 0; i < n; i++){\r\n            if(s.charAt(i) == c){\r\n                idx.add(i);\r\n            }\r\n        }\r\n        idx.add(n*2);\r\n        int[] ans = new int[n];\r\n        int j = 0;\r\n        for(int i = 0; i < n; i++){\r\n            if(s.charAt(i) == c){\r\n                ans[i] = 0;\r\n                j++;\r\n            }\r\n            else{\r\n                ans[i] = Math.min(Math.abs(i - idx.get(j)), Math.abs(idx.get(j+1) - i));\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "wangpengzhen": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836765721",
      "body": "不会没思路"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837748302",
      "body": "没思路"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837748302",
      "body": "没思路"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "yxq1997": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836766743",
      "body": "## 前置知识\r\n\r\n- 数组的遍历，整数的运算\r\n\r\n## 思路\r\n- 从后往前遍历数组，得到的是X的从低到高的每一位\r\n- k%10得到最低位，k/10更新当前k的倒数第二位为最低位\r\n- 通过将k的最低位与X的最低位诸位相加得到新的结果value，并用count = value /10保存当前加法后的进位数值，用value/10保留当前加法后的最低位\r\n\r\n## 关键点\r\n\r\n-  可以吧k当做一个数组来看，本题类似于两个数组的加法运算，加法循环的终止条件是两个数组(k和nuns)都便利了一遍，且进位count为0\r\n- 在本题中直接得到的结果在list中是逆序排列的，因此需要反转\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int count = 0; // 表示进位符\r\n        List<Integer> list = new ArrayList<>();\r\n        int n = num.length;\r\n        int value = 0;\r\n        for(int i=n-1;i>=0;i--){\r\n            int kNum = k % 10;\r\n            value = num[i] + kNum + count;\r\n            count = value / 10;\r\n            list.add(value % 10);\r\n            if(k > 0)\r\n                k /= 10;\r\n        }\r\n        k += count;\r\n        while(k > 0){\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(n, log k)$\r\n- 空间复杂度：$O(1)$"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838216276",
      "body": "## 前置知识\r\n\r\n- 数组的遍历\r\n\r\n## 思路\r\n- 由题意可知每个字符的最短距离，即是左边离该字符最近的c字符与右边离该字符最近的c字符的距离的较小值\r\n- 因此通过一次顺序遍历，得到左边离该字符最近的c字符到该字符的距离；然后一次逆序遍历，得到右边离该字符最近的c字符到该字符的距离，两者比较去较小值即可\r\n\r\n## 关键点\r\n\r\n-  怎样实现只取左边最近的c字符的距离与右边最近的c字符的距离 --> 分别通过顺序和逆序遍历得到\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java {15}\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c){\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        int prev = -n;\r\n        for(int i=0;i<n;i++){\r\n            if(s.charAt(i) == c)\r\n                prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 2 * n;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i) == c)\r\n                prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838216276",
      "body": "## 前置知识\r\n\r\n- 数组的遍历\r\n\r\n## 思路\r\n- 由题意可知每个字符的最短距离，即是左边离该字符最近的c字符与右边离该字符最近的c字符的距离的较小值\r\n- 因此通过一次顺序遍历，得到左边离该字符最近的c字符到该字符的距离；然后一次逆序遍历，得到右边离该字符最近的c字符到该字符的距离，两者比较去较小值即可\r\n\r\n## 关键点\r\n\r\n-  怎样实现只取左边最近的c字符的距离与右边最近的c字符的距离 --> 分别通过顺序和逆序遍历得到\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java {15}\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c){\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        int prev = -n;\r\n        for(int i=0;i<n;i++){\r\n            if(s.charAt(i) == c)\r\n                prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 2 * n;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i) == c)\r\n                prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Forschers": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836774703",
      "body": "\r\n## 思路\r\n将k中的数取出一个个加入到数组中\r\n\r\n\r\neg:将【2，3，4】+ k=32 计算 4+32 因为4+32  = 36将6留在当前位 将k/10 以进为的形式加入到下个位中\r\n重复过程计算 【2，3】+ 3\r\n\r\n## 关键点\r\n\r\n-  将k放入到数组后\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> arr = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        //将k以 k/10的形式进位\r\n        for(int i = n-1;i>=0 || k>0;--i,k/=10){\r\n            if(i >= 0){\r\n                k +=num[i];\r\n            }\r\n            //加上k取出来的最后一位\r\n            arr.add(k%10);\r\n        }\r\n        //反转\r\n        Collections.reverse(arr);\r\n        return arr;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(max(n,logk))\r\n- 空间复杂度：O(1)\r\n\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618318",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n整形反转\r\n\r\n## 思路\r\n对每个字符串 找出左右中c的距离 比较左右的距离 选择最小值\r\n\r\n\r\n左向右：\r\n\r\n上个字符出现的位置prev  距离 : i - prev\r\n\r\n右向左：\r\n\r\n上个字符出现的位置prev 则距离: prev - i\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        //创建新的数组ans\r\n        int[] ans = new int[n];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i = 0;i < n;++i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //左 ==》 右 遍历\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n         prev = Integer.MAX_VALUE/2;\r\n\r\n        for(int i = n-1;i >= 0;--i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //选择其中最小的\r\n            ans[i] = Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618318",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n整形反转\r\n\r\n## 思路\r\n对每个字符串 找出左右中c的距离 比较左右的距离 选择最小值\r\n\r\n\r\n左向右：\r\n\r\n上个字符出现的位置prev  距离 : i - prev\r\n\r\n右向左：\r\n\r\n上个字符出现的位置prev 则距离: prev - i\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        //创建新的数组ans\r\n        int[] ans = new int[n];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i = 0;i < n;++i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //左 ==》 右 遍历\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n         prev = Integer.MAX_VALUE/2;\r\n\r\n        for(int i = n-1;i >= 0;--i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //选择其中最小的\r\n            ans[i] = Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "XinlingQiu": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836776627",
      "body": "- 语言 python\r\n- 时间复杂度：O(max(n,log(k)))\r\n- 空间复杂度：O(1)\r\n- 无需反转\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=len(num)\r\n        count=0#进位符\r\n        for i in range(n-1,-1,-1):\r\n            new_i=num[i]+k%10+count\r\n            count=new_i/10\r\n            num[i]=new_i%10\r\n            if k>0:\r\n                k=k/10\r\n        k+=count\r\n        while k>0:\r\n            num.insert(0,k%10)\r\n            k/=10\r\n        return num\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "suffocatingly0": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836783424",
      "body": "- 语言 java\r\n- 时间复杂度O（n）\r\n- 空间复杂度O（n）\r\n- n = Math.max(num.length, k.length)\r\n```\r\nclass Solution {\r\n   public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res =new ArrayList<>();\r\n        int count=0;\r\n        for(int i=num.length-1;i>=0;i--){\r\n            int sum=num[i]+k%10;\r\n            k=k/10;\r\n            res.add((sum+count)%10);\r\n            count=(sum+count)/10;\r\n        }\r\n        if(count>0) k++;\r\n        for(;k>0;k/=10){\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837657821",
      "body": "- 语言：Java\r\n- 时间复杂度：O（N*M）\r\n- 空间复杂度：O（N）\r\n- N是s的长度，M是c在s中重复的个数\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> list=new ArrayList<>();\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)==c){\r\n                list.add(i);\r\n            }\r\n        }\r\n       int [] distance=new int[list.size()];\r\n        for(int i=0;i<list.size();i++){\r\n            distance[i]=list.get(i);\r\n        }\r\n        int [] res =new int[s.length()];\r\n        Arrays.fill(res,Integer.MAX_VALUE);\r\n        for(int i=0;i<s.length();i++){\r\n            for(int j=0;j<distance.length;j++){\r\n                int a=Math.abs(i-distance[j]);\r\n                if(a<res[i]) res[i]=a;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837657821",
      "body": "- 语言：Java\r\n- 时间复杂度：O（N*M）\r\n- 空间复杂度：O（N）\r\n- N是s的长度，M是c在s中重复的个数\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> list=new ArrayList<>();\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)==c){\r\n                list.add(i);\r\n            }\r\n        }\r\n       int [] distance=new int[list.size()];\r\n        for(int i=0;i<list.size();i++){\r\n            distance[i]=list.get(i);\r\n        }\r\n        int [] res =new int[s.length()];\r\n        Arrays.fill(res,Integer.MAX_VALUE);\r\n        for(int i=0;i<s.length();i++){\r\n            for(int j=0;j<distance.length;j++){\r\n                int a=Math.abs(i-distance[j]);\r\n                if(a<res[i]) res[i]=a;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "S-T-D": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836785905",
      "body": "# 思路\r\n\r\n对数组 `A` 从后往前遍历，同时对 `K` 取 10 的余数，将遍历的数字和余数相加得到新值，并更新数组对应位置的值，同时注意是否进位。\r\n\r\n注意：`K` 的位数可能比 `A` 的长度要长。\r\n\r\n&nbsp;\r\n\r\n# 代码\r\n\r\n```javascript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    const len = num.length;    \r\n    let i = len - 1;\r\n    let carry = 0;\r\n    while (i >= 0) {\r\n        let addNum = 0;\r\n        if (k !== 0) {\r\n            addNum = k % 10;\r\n            k = Math.floor(k / 10);\r\n        }\r\n        let sum = num[i] + carry + addNum;\r\n        carry = sum >= 10 ? 1 : 0;\r\n        num[i] = sum % 10;\r\n        i--;\r\n    }\r\n    k += carry;\r\n    while (k !== 0) {\r\n        num.unshift(k % 10);\r\n        k = Math.floor(k / 10);\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n&nbsp;\r\n\r\n# 复杂度分析\r\n\r\n令 `n` 为数组长度，`m` 为 `k` 的位数，按最坏情况\r\n\r\n时间：O(n + (m - n)^2)，第一个循环为 O(n)，第二个循环内在数组头部插入元素涉及数组的移动操作\r\n\r\n空间：O(m - n)，如果 `m` 大于 `n`，数组需要增加 `m - n` 的长度"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706722",
      "body": "## 思路\r\n\r\n可以分两次遍历。\r\n\r\n第一次遍历，从左往右，计算每个字符离左边的最近的 `c` 的距离。\r\n\r\n第二次遍历，从右往左，计算每个字符离右边最近的 `c` 的距离，再取最小值。\r\n\r\n## 代码\r\n\r\n```javascript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const ans = [];\r\n    const len = s.length;\r\n\r\n    let prev = -10000;\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans.push(i - prev);\r\n    }\r\n\r\n    prev = 20000;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans[i] = Math.min(ans[i], prev - i);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间：O(n)，`n` 为字符串的长度。  \r\n- 空间：O(1)，忽略返回的数组所占空间。\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706722",
      "body": "## 思路\r\n\r\n可以分两次遍历。\r\n\r\n第一次遍历，从左往右，计算每个字符离左边的最近的 `c` 的距离。\r\n\r\n第二次遍历，从右往左，计算每个字符离右边最近的 `c` 的距离，再取最小值。\r\n\r\n## 代码\r\n\r\n```javascript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const ans = [];\r\n    const len = s.length;\r\n\r\n    let prev = -10000;\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans.push(i - prev);\r\n    }\r\n\r\n    prev = 20000;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans[i] = Math.min(ans[i], prev - i);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间：O(n)，`n` 为字符串的长度。  \r\n- 空间：O(1)，忽略返回的数组所占空间。\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "wsgouwan": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836787849",
      "body": "思路：\r\n    转化为数组， 从末位起，两两相加，\r\n\r\n代码：\r\n```\r\n var addToArrayForm = function(num, k) {\r\n        let result = []\r\n        k = k.toString().split('')\r\n        let carryBit = 0\r\n        let _temp = 0\r\n        while(num.length > 0 || k.length > 0) {\r\n            let num1 = num.pop() \r\n            let num2 = k.pop() \r\n            num1 = num1 ? num1 * 1 : 0\r\n            num2 = num2 ? num2 * 1 : 0\r\n            _temp = num1 + num2 + carryBit\r\n            if(_temp > 9) {\r\n                carryBit = 1\r\n                _temp = _temp - 10\r\n            }else {\r\n                carryBit = 0\r\n            }\r\n            result.unshift(_temp)\r\n        }\r\n\r\n        if(carryBit > 0) {\r\n            result.unshift(1)\r\n        }\r\n        return result;\r\n    };\r\n```\r\nn = Math.max(num.length, k.length)\r\n时间复杂度：O(n)\r\n空间复杂度O(n)\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838184466",
      "body": "思路: 字符串转化为数组，找出匹配字符串在数组中的下标存为数组2；遍历数组，找出数组中差值最小的下标并返回\r\n语言: javascript\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    s = s.split('')\r\n    // 先遍历出C在数组中的位置\r\n    let subscript = []\r\n    let result = []\r\n    s.forEach((item, index) => {\r\n        if(item === c) {\r\n            subscript.push(index)\r\n        }\r\n    })\r\n    // \r\n    s.forEach((item, index) => {\r\n        let _min = subscript.reduce((pre, next) => {\r\n            return Math.min(pre, Math.abs(next - index))\r\n        }, Math.abs(subscript[0] - index))\r\n        result.push(_min)\r\n    })\r\n    return result\r\n};\r\n```\r\n\r\n复杂度：\r\n    字符串的长度 为m  \r\n    字符在字符串的个数为n \r\n    时间复杂度：O(m*n)\r\n    空间复杂度：O(m)\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838184466",
      "body": "思路: 字符串转化为数组，找出匹配字符串在数组中的下标存为数组2；遍历数组，找出数组中差值最小的下标并返回\r\n语言: javascript\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    s = s.split('')\r\n    // 先遍历出C在数组中的位置\r\n    let subscript = []\r\n    let result = []\r\n    s.forEach((item, index) => {\r\n        if(item === c) {\r\n            subscript.push(index)\r\n        }\r\n    })\r\n    // \r\n    s.forEach((item, index) => {\r\n        let _min = subscript.reduce((pre, next) => {\r\n            return Math.min(pre, Math.abs(next - index))\r\n        }, Math.abs(subscript[0] - index))\r\n        result.push(_min)\r\n    })\r\n    return result\r\n};\r\n```\r\n\r\n复杂度：\r\n    字符串的长度 为m  \r\n    字符在字符串的个数为n \r\n    时间复杂度：O(m*n)\r\n    空间复杂度：O(m)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "ziwh": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836788224",
      "body": "## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\n\r\n注意，AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位\r\n    \r\n    // 循环条件调整\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n```\r\n\r\n## 代码\r\nJava\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int sum = 0;\r\n        List<Integer> ans = new ArrayList<>();\r\n        while(i >= 0 || k != 0 || sum != 0) {\r\n            int x = i >= 0 ? num[i] : 0;\r\n            int y = k != 0 ? k % 10 : 0;\r\n            sum += x + y;\r\n            ans.add(sum % 10);\r\n            sum = sum / 10;\r\n            k = k / 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(max(n, log(k))\r\n空间复杂度: O(1)\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837651373",
      "body": "## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n当前字符距离c最短距离 = Math.min(当前字符距离左边c字符最短距离, 当前字符距离右边边c字符最短距离)\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] prev = new int[s.length()];\r\n        int[] next = new int[s.length()];\r\n\r\n        int begin = -1;\r\n        int end = s.length();\r\n        for(int i = 0; i < s.length(); i++) {\r\n            int endLoc = s.length() - i - 1;\r\n            if(s.charAt(i) == c) {\r\n                begin = i;\r\n                prev[i] = 0;\r\n            } else {\r\n                if(begin < 0) prev[i] = Integer.MAX_VALUE;\r\n                else prev[i] = i - begin;\r\n            }\r\n            if(s.charAt(endLoc) == c) {\r\n                end = endLoc;\r\n                next[end] = 0;\r\n            } else {\r\n                if(end > s.length() - 1) next[endLoc] = Integer.MAX_VALUE;\r\n                else next[endLoc] = end - endLoc;\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < s.length(); i++) {\r\n            prev[i] = Math.min(prev[i], next[i]);\r\n        }\r\n        return prev;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度: O(n)\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837651373",
      "body": "## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n当前字符距离c最短距离 = Math.min(当前字符距离左边c字符最短距离, 当前字符距离右边边c字符最短距离)\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] prev = new int[s.length()];\r\n        int[] next = new int[s.length()];\r\n\r\n        int begin = -1;\r\n        int end = s.length();\r\n        for(int i = 0; i < s.length(); i++) {\r\n            int endLoc = s.length() - i - 1;\r\n            if(s.charAt(i) == c) {\r\n                begin = i;\r\n                prev[i] = 0;\r\n            } else {\r\n                if(begin < 0) prev[i] = Integer.MAX_VALUE;\r\n                else prev[i] = i - begin;\r\n            }\r\n            if(s.charAt(endLoc) == c) {\r\n                end = endLoc;\r\n                next[end] = 0;\r\n            } else {\r\n                if(end > s.length() - 1) next[endLoc] = Integer.MAX_VALUE;\r\n                else next[endLoc] = end - endLoc;\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < s.length(); i++) {\r\n            prev[i] = Math.min(prev[i], next[i]);\r\n        }\r\n        return prev;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度: O(n)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "CruiseYuGH": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836790900",
      "body": "## 思路\r\n\r\nsum_temp = num[i]+k%10 +temp\r\n分别更新temp 和 num[i]\r\n最后判别下是否有剩余的K or temp\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        temp = 0\r\n        for i in range(len(num)-1,-1,-1):\r\n            if k > 0 or temp>0:\r\n                sum_temp = num[i]+k%10 +temp\r\n                num[i]=sum_temp%10\r\n                temp = sum_temp//10\r\n                k = k//10\r\n        k+=temp\r\n        if k >0 :\r\n            while K:\r\n                num.insert(0,k%10)\r\n                k = k//10\r\n        return num\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838684275",
      "body": "## 思路\r\n找出左右两边距离最近的，再取其中最小的\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        left  = [999 for i in range(len(s))]\r\n        right = [999 for i in range(len(s))]\r\n        for i in range(len(s)):\r\n            #print(i,len(s))\r\n            if s[i]==c:\r\n                left[i]=0\r\n            elif i!=0 and left[i-1]!=999 :\r\n                left[i] = left[i-1]+1\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i]==c:\r\n                right[i]=0\r\n            elif i!=len(s)-1 and right[i+1]!=999 :\r\n                right[i] = right[i+1]+1\r\n        res = [min(right[i],left[i]) for i in range(len(s))]\r\n        return res\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838684275",
      "body": "## 思路\r\n找出左右两边距离最近的，再取其中最小的\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        left  = [999 for i in range(len(s))]\r\n        right = [999 for i in range(len(s))]\r\n        for i in range(len(s)):\r\n            #print(i,len(s))\r\n            if s[i]==c:\r\n                left[i]=0\r\n            elif i!=0 and left[i-1]!=999 :\r\n                left[i] = left[i-1]+1\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i]==c:\r\n                right[i]=0\r\n            elif i!=len(s)-1 and right[i+1]!=999 :\r\n                right[i] = right[i+1]+1\r\n        res = [min(right[i],left[i]) for i in range(len(s))]\r\n        return res\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "johanazhu": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836791845",
      "body": "## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\n\r\n注意，AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位\r\n    \r\n    // 循环条件调整\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n```\r\n\r\n## 代码\r\n\r\nJavascript\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    k = k.toString();\r\n    let aLen = num.length, kLen = k.length;\r\n    num.reverse();\r\n    if(aLen > kLen) {\r\n        k = '0'.repeat(aLen - kLen) + k;\r\n    } else if(aLen < kLen) {\r\n        for(let i = 0; i < kLen - aLen; i++) {\r\n            num.push(0);\r\n        }\r\n    }\r\n    k = k.split('').reverse();\r\n    let sum = 0, carry = 0, res = [];\r\n    num.forEach((item, i)=>{\r\n        sum = item + + k[i] + carry;\r\n        carry = parseInt(sum / 10);\r\n        res.push(sum % 10)\r\n    })\r\n    if(carry > 0) {\r\n        res.push(carry)\r\n    }\r\n    return res.reverse();\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(max(n, log(k))\r\n空间复杂度: O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "zengwmFE": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836792060",
      "body": "```\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let target = 0\r\n    let sum = 0\r\n    for(let i=num.length-1;i>=0;i--){\r\n        sum = num[i]+k%10+target \r\n        num[i] = sum%10\r\n        target = Math.floor(sum/10)   \r\n         k = Math.floor(k/10)\r\n\r\n    }\r\n    k = target + Number(k)\r\n    if(k){\r\n        let str = String(k)\r\n        for(let i=str.length-1;i>=0;i--){\r\n            num.unshift(str[i])\r\n        }\r\n    }\r\n    return num\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838635265",
      "body": "[题解同步到leetcode](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/liang-duan-xun-huan-que-ding-ju-chi-by-z-iryn/)\r\n自己写写思路，希望下次不要忘了，91奥利给\r\n## 思路\r\n令当前起始值为-1，如果第一个值\r\n这里采用，左右两端分别进行循环\r\n这里的关键在于如何处理匹配`c`之后的值：\r\n\r\n> 从右往左循环，可以拿到值离右边最近的`c`的距离\r\n> 如果当前这个值`s[i]`恰好等于`c`的时候，那么这个地方的pos[i] = 0，当然如果当前这个值之前还没有发现有`c`的存在的时候，这个时候，咱也不晓得（🤷‍♂️）这值是啥啊，那就可以先跳过这个位置：**即保留-1的状态值**，当找到了这个值的时候，就拿个东东（current）标识一哈：**current=i**，老铁开始出现了，那么就可以着手去更改位置的值了，那么这个位置是什么呢:?令i=2,current=1,距离是:高减低`current-i`.这样就得出了一个位置表达式\r\n\r\n> 从左往右循环，可以拿到值离左边最近的`c`的距离，一开始需要填填之前没有找到位置的地方，给他填好值吧，然后操作基本跟从右往左是一致的，但是距离表达式为**高减低`i-current`**，而且当遇到不为`-1`值的时候，我们需要判断两者的距离位置，最后肯定是要取一个小小的值！\r\n\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let len = s.length\r\n    let pos = new Array(len).fill(-1)\r\n    let current = -1\r\n    for(let i=len-1;i>=0;i--){\r\n        if(s[i] == c){\r\n            current = i\r\n            pos[i] = 0\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = current-i\r\n        }\r\n\r\n    }\r\n    current = -1\r\n    for(let i=0;i<len;i++){\r\n        if(pos[i]===-1){\r\n            pos[i] = i-current\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = Math.min(i-current,pos[i])\r\n        }\r\n        if(s[i]===c){\r\n            current = i\r\n        }\r\n    }\r\n    return pos\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838635265",
      "body": "[题解同步到leetcode](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/liang-duan-xun-huan-que-ding-ju-chi-by-z-iryn/)\r\n自己写写思路，希望下次不要忘了，91奥利给\r\n## 思路\r\n令当前起始值为-1，如果第一个值\r\n这里采用，左右两端分别进行循环\r\n这里的关键在于如何处理匹配`c`之后的值：\r\n\r\n> 从右往左循环，可以拿到值离右边最近的`c`的距离\r\n> 如果当前这个值`s[i]`恰好等于`c`的时候，那么这个地方的pos[i] = 0，当然如果当前这个值之前还没有发现有`c`的存在的时候，这个时候，咱也不晓得（🤷‍♂️）这值是啥啊，那就可以先跳过这个位置：**即保留-1的状态值**，当找到了这个值的时候，就拿个东东（current）标识一哈：**current=i**，老铁开始出现了，那么就可以着手去更改位置的值了，那么这个位置是什么呢:?令i=2,current=1,距离是:高减低`current-i`.这样就得出了一个位置表达式\r\n\r\n> 从左往右循环，可以拿到值离左边最近的`c`的距离，一开始需要填填之前没有找到位置的地方，给他填好值吧，然后操作基本跟从右往左是一致的，但是距离表达式为**高减低`i-current`**，而且当遇到不为`-1`值的时候，我们需要判断两者的距离位置，最后肯定是要取一个小小的值！\r\n\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let len = s.length\r\n    let pos = new Array(len).fill(-1)\r\n    let current = -1\r\n    for(let i=len-1;i>=0;i--){\r\n        if(s[i] == c){\r\n            current = i\r\n            pos[i] = 0\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = current-i\r\n        }\r\n\r\n    }\r\n    current = -1\r\n    for(let i=0;i<len;i++){\r\n        if(pos[i]===-1){\r\n            pos[i] = i-current\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = Math.min(i-current,pos[i])\r\n        }\r\n        if(s[i]===c){\r\n            current = i\r\n        }\r\n    }\r\n    return pos\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "dorothyDing": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836793890",
      "body": "javascript\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let numStr = num.join('')\r\n    let maxLength = Math.max(numStr.length, k.toString().length)\r\n    numArr = numStr.padStart(maxLength, '0').split('').reverse()\r\n    kArr = k.toString().padStart(maxLength, '0').split('').reverse()\r\n    let flag = 0\r\n    for(let i = 0; i < maxLength; i++) {\r\n        let sum = Number(numArr[i]) + Number(kArr[i]) + flag\r\n        if (sum >= 10) {\r\n            flag = 1\r\n            sum -= 10\r\n        } else {\r\n            flag = 0\r\n        }\r\n        numArr[i] = sum\r\n    }\r\n    if (flag) {\r\n        numArr.push(flag)\r\n    }\r\n    return numArr.reverse().map(i => Number(i))\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度:  O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838686757",
      "body": "javascript\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let indexs = s.split('').map((item, index) => item === c ? index : null).filter(item => item != null)\r\n    return s.split('').map((_, index) => Math.min(...indexs.map(i => Math.abs(i - index))))\r\n};\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838686757",
      "body": "javascript\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let indexs = s.split('').map((item, index) => item === c ? index : null).filter(item => item != null)\r\n    return s.split('').map((_, index) => Math.min(...indexs.map(i => Math.abs(i - index))))\r\n};\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "mittacy": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836795620",
      "body": "### 思路\r\n\r\n从后往前遍历num，和k进行加法运算并进位，每次存入数组(该数组是从低位往高位存储的)，直到k=0，最后反转数组\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n    ans := make([]int, 0)\r\n    for i := len(num) - 1; i >= 0 || k > 0; i-- {\r\n        if i >= 0 {\r\n            k += num[i]\r\n        }\r\n        ans = append(ans, k%10)\r\n        k /= 10\r\n    }\r\n\r\n    i, j := 0, len(ans)-1\r\n    for i < j {\r\n        ans[i], ans[j] = ans[j], ans[i]\r\n        i++\r\n        j--\r\n    }\r\n    return ans\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N, logk))，其中 N 为数组长度。(k / 10^n = 1 => logk)\r\n- 空间复杂度：O(1)，除了返回值为数组外，其他都为常量\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838160036",
      "body": "### 思路\r\n\r\n两端遍历\r\n1. 从前往后，res[curIndex] = curIndex - newTargetIndex\r\n2. 从后往前，res[curIndex] = min(res[curIndex], newTargetIndex-curIndex)\r\n其中，newTargetIndex为目标字符最新出现索引位置\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    res := make([]int, len(s))\r\n    // 1<=s.length<=10000, targetIndex-10000<0, 所以应该设置targetIndex为-10000\r\n    targetIndex := -10000\r\n    for i := 0; i < len(s); i++ {\r\n        if s[i] == c {\r\n            targetIndex = i\r\n        }\r\n        res[i] = i - targetIndex\r\n    }\r\n\r\n    // 1<=s.length<=10000, targetIndex-10000>10000, 所以应该设置targetIndex为20000\r\n    targetIndex = 20000 \r\n    for i := len(s)-1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            targetIndex = i\r\n        }\r\n        res[i] = min(res[i], targetIndex - i)\r\n    }\r\n    return res\r\n}\r\n\r\nfunc min(i, j int) int {\r\n    if i < j {\r\n        return i\r\n    }\r\n    return j\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串s的长度。\r\n- 空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838160036",
      "body": "### 思路\r\n\r\n两端遍历\r\n1. 从前往后，res[curIndex] = curIndex - newTargetIndex\r\n2. 从后往前，res[curIndex] = min(res[curIndex], newTargetIndex-curIndex)\r\n其中，newTargetIndex为目标字符最新出现索引位置\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    res := make([]int, len(s))\r\n    // 1<=s.length<=10000, targetIndex-10000<0, 所以应该设置targetIndex为-10000\r\n    targetIndex := -10000\r\n    for i := 0; i < len(s); i++ {\r\n        if s[i] == c {\r\n            targetIndex = i\r\n        }\r\n        res[i] = i - targetIndex\r\n    }\r\n\r\n    // 1<=s.length<=10000, targetIndex-10000>10000, 所以应该设置targetIndex为20000\r\n    targetIndex = 20000 \r\n    for i := len(s)-1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            targetIndex = i\r\n        }\r\n        res[i] = min(res[i], targetIndex - i)\r\n    }\r\n    return res\r\n}\r\n\r\nfunc min(i, j int) int {\r\n    if i < j {\r\n        return i\r\n    }\r\n    return j\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串s的长度。\r\n- 空间复杂度：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "yourspeace": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836797246",
      "body": "语言：Java\r\n\r\n思路：leetcode官方题解的思路：数组和数字最后一位从后往前，对应的位相加，如果产生进位，数字k加1，这样就会在下一位中运 算了，最后如果数字k的长度大于数组的长度，那么就把数字k剩下的进行取余取整操作，加到目标数组中，最后数组反转得到结果\r\n\r\n代码：\r\n\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        // 初始化参数\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = A.length;\r\n\r\n        // 1. 从后往前逐位相加\r\n        for(int i = n - 1;i >= 0;i--){\r\n            // 1.1 逐位相加\r\n            int sum = A[i] + K % 10;         // 每次重置sum\r\n            K /= 10;    \r\n            // 1.2 处理两位相加 进位的情况\r\n            if(sum >= 10){\r\n                K++;                        // 进位到K的末尾\r\n                sum -= 10;                  // 进位清掉\r\n            }\r\n            // 1.2 当前相加的结果 添加到结果集\r\n            res.add(sum);\r\n        }\r\n\r\n        // 2. K的数字长度大于数组的数字长度\r\n        for(;K > 0;K /= 10){                // 每次K左移一位\r\n            res.add(K % 10);                // 添加到结果集\r\n        }\r\n\r\n        // 3. 将结果集翻转即是所求答案\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}`\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838563251",
      "body": "**语言：** Java\r\n\r\n**leetcode官方题解思想：**\r\n\r\n从前往后遍历一遍，记住各个位置离上一个C字符的距离，再从后往前遍历一遍，同样记住离上一个C字符的距离，最后比较两次遍历各个位置离C字符的距离，较小的那个被选用做为最终距离\r\n\r\n**复杂度：**\r\n\r\n时间：O(N)\r\n\r\n空间：O(N) \r\n\r\n**代码：**\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838563251",
      "body": "**语言：** Java\r\n\r\n**leetcode官方题解思想：**\r\n\r\n从前往后遍历一遍，记住各个位置离上一个C字符的距离，再从后往前遍历一遍，同样记住离上一个C字符的距离，最后比较两次遍历各个位置离C字符的距离，较小的那个被选用做为最终距离\r\n\r\n**复杂度：**\r\n\r\n时间：O(N)\r\n\r\n空间：O(N) \r\n\r\n**代码：**\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "paopaohua": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836797976",
      "body": "思路：\n  1、从数组最后一位向前遍历，进行相加，考虑进位操作\n  2、考虑进位超出当前长度的操作\n  3、输出结果进行翻转 collections.reverse（res）\n代码：\n```\npublic List<Integer> addToArrayForm(int[] A, int K) {\n    List<Integer> res = new ArrayList<>();\n    int carry = 0;\n    int l1 = A.length - 1;\n    while (l1 >= 0 || K != 0) {\n        int x = l1 < 0 ? 0 : A[l1];\n        int y = K == 0 ? 0 : K % 10;\n\n        int sum = x + y + carry;\n        res.add(sum % 10);\n        carry = sum / 10;\n\n        l1--;\n        K = K / 10;\n    }\n    if (carry != 0) res.add(carry);\n    Collections.reverse(res);\n    return res;\n}\n\n```\n复杂度分析：（不懂）\n    时间复杂度：Ｏ（n）\n    空间复杂度：Ｏ（n）\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838694006",
      "body": "思路：\n   从左向右遍历，记录字符c出现的位置p，距离为i-p\n   从右向左遍历，记录字符c出现的位置p，距离为p-i\n   得较小值\n代码：\n```\n\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;//防止越界\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);//判断最小值\n        }\n\n        return ans;\n    }\n}\n\n\n```\n复杂度分析：\n   时间复杂度：Ｏ（n）\n   空间复杂度：Ｏ（n）数组 ans 的大小"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838694006",
      "body": "思路：\n   从左向右遍历，记录字符c出现的位置p，距离为i-p\n   从右向左遍历，记录字符c出现的位置p，距离为p-i\n   得较小值\n代码：\n```\n\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;//防止越界\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);//判断最小值\n        }\n\n        return ans;\n    }\n}\n\n\n```\n复杂度分析：\n   时间复杂度：Ｏ（n）\n   空间复杂度：Ｏ（n）数组 ans 的大小"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Auto-SK": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836800746",
      "body": "## 方法一：逐位相加\r\n\r\n**当前位 = (A 的当前位 + B 的当前位 + 进位 carry) % 10**\r\n\r\n### 算法流程\r\n\r\n```\r\nwhile A 没完 or B 没完\r\n\tA 的当前位\r\n\tB 的当前位 (B % 10)\r\n\r\n\t和 = A 的当前位 + B 的当前位 + 进位 carry\r\n\t进位 = 和 // 10\r\n\r\n\t当前结果位 = 和 % 10\r\n判断还有进位吗\r\n反转数组\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(max(len(num), len(k)))\r\n* 空间复杂度：O(1)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) - 1\r\n        sum = 0\r\n        carry = 0\r\n        res = []\r\n        while i >= 0 or k != 0:\r\n            x = num[i] if i >= 0 else 0\r\n            y = k % 10 if k != 0 else 0\r\n            sum = x + y + carry\r\n            carry = sum // 10\r\n\r\n            i -= 1\r\n            k //= 10\r\n\r\n            res.append(sum % 10)\r\n        \r\n        if carry != 0:\r\n            res.append(carry)\r\n        return res[::-1]\r\n```\r\n\r\n\r\n## 方法二：转换+逐位取出\r\n\r\n### 算法流程\r\n\r\n1. 逐位取 num，将其转为字符串\r\n2. 将 num 字符串转为整数\r\n3. 求出 num 和 k 之和 sum\r\n4. 逐位取 sum % 10，sum = sum // 10\r\n5. 反转，res[::-1]\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(1)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        x = ''\r\n        for i in num:\r\n            x += str(i)\r\n        x = int(x)\r\n        res = x + k\r\n        if res == 0:\r\n            return [0]\r\n        ans = []\r\n        while res != 0:\r\n            ans.append(res % 10)\r\n            res = res // 10\r\n        return ans[::-1]\r\n```\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838717787",
      "body": "## 方法一：两次扫描\r\n\r\n### 算法流程\r\n\r\n从左向右遍历，记录上一个字符 `c` 出现的位置 `prev`，那么答案就是 `i - prev`。\r\n\r\n从右向左遍历，记录上一个字符 `c` 出现的位置 `prev`，那么答案就是 `prev - i`。\r\n\r\n这两个值取最小就是答案。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)，s 数组的长度。\r\n* 空间复杂度：O(n)，ans 数组的大小。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        prev = float('-inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838717787",
      "body": "## 方法一：两次扫描\r\n\r\n### 算法流程\r\n\r\n从左向右遍历，记录上一个字符 `c` 出现的位置 `prev`，那么答案就是 `i - prev`。\r\n\r\n从右向左遍历，记录上一个字符 `c` 出现的位置 `prev`，那么答案就是 `prev - i`。\r\n\r\n这两个值取最小就是答案。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)，s 数组的长度。\r\n* 空间复杂度：O(n)，ans 数组的大小。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        prev = float('-inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "xuanaxuan": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836802914",
      "body": "### 思路\r\n\r\n#### 模板\r\n```\r\n当前位=0\r\nwhile ( A 没完 || B 没完)\r\n    //根据下标找到\r\n    A 的当前位\r\n    B 的当前位\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗,进位不为 0 ,加在目标值前面。\r\n```\r\n#### 注意点\r\n1. 循环结束条件\r\n2. 当前位的计算,注意防空\r\n3. 和的计算,carry初始值为0\r\n4. js中取整/后要转整数\r\n  \r\n### 代码\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n  let i = num.length - 1,\r\n    carry = 0,\r\n    arr = [];\r\n  while (i >= 0 || k > 0) {\r\n    let n = i>=0 ? num[i] : 0;\r\n    let m = k != 0 ? k % 10 : 0;\r\n    let sum = n + m + carry;\r\n    carry = parseInt(sum / 10);\r\n    arr.unshift(sum % 10);\r\n    i--;\r\n    k = parseInt(k / 10);\r\n  }\r\n  if (carry) arr.unshift(1);\r\n  return arr;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度:`O(n)` \r\n空间复杂度:`O(n)`\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838288784",
      "body": "### 思路\r\n用变量prevC记录c的下标,初始值为无穷大,当s[i]=c时更新preC=i\r\n遍历字符串,将非c的字符串存入临时栈中,当遇到c时,依次计算栈中字符串到当前c以及prevC的最小距离,注意针对C非S最后一个字符串的情况,需要再清空下临时栈\r\n### 复杂度\r\n时间复杂度：$O(N)$, N 为S数组长度。\r\n空间复杂度：$O(N)$, N 为S数组长度。\r\n### 代码\r\n```\r\nvar shortestToChar = function (S, C) {\r\n  let arr = [],\r\n    prevC = -Infinity,\r\n    map = [];\r\n  //清空暂存栈\r\n  function clear(prev, next = Infinity) {\r\n    for (const targetIndex of map) {\r\n      const Index = Math.min(Math.abs(targetIndex - prev), Math.abs(targetIndex - next));\r\n      arr.push(Index);\r\n    }\r\n    map = [];\r\n  }\r\n  for (let index = 0; index < S.length; index++) {\r\n    const ele = S[index];\r\n    if (ele === C) {\r\n      clear(prevC, index);\r\n      arr.push(0);\r\n      prevC = index;\r\n    } else {\r\n      map.push(index);\r\n    }\r\n  }\r\n  if (map.length > 0) {\r\n    clear(prevC);\r\n  }\r\n  return arr;\r\n};\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838288784",
      "body": "### 思路\r\n用变量prevC记录c的下标,初始值为无穷大,当s[i]=c时更新preC=i\r\n遍历字符串,将非c的字符串存入临时栈中,当遇到c时,依次计算栈中字符串到当前c以及prevC的最小距离,注意针对C非S最后一个字符串的情况,需要再清空下临时栈\r\n### 复杂度\r\n时间复杂度：$O(N)$, N 为S数组长度。\r\n空间复杂度：$O(N)$, N 为S数组长度。\r\n### 代码\r\n```\r\nvar shortestToChar = function (S, C) {\r\n  let arr = [],\r\n    prevC = -Infinity,\r\n    map = [];\r\n  //清空暂存栈\r\n  function clear(prev, next = Infinity) {\r\n    for (const targetIndex of map) {\r\n      const Index = Math.min(Math.abs(targetIndex - prev), Math.abs(targetIndex - next));\r\n      arr.push(Index);\r\n    }\r\n    map = [];\r\n  }\r\n  for (let index = 0; index < S.length; index++) {\r\n    const ele = S[index];\r\n    if (ele === C) {\r\n      clear(prevC, index);\r\n      arr.push(0);\r\n      prevC = index;\r\n    } else {\r\n      map.push(index);\r\n    }\r\n  }\r\n  if (map.length > 0) {\r\n    clear(prevC);\r\n  }\r\n  return arr;\r\n};\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "caoyuyuyu": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836813414",
      "body": "\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 思路\r\n\r\n-  最终结果由数组变成的数值和数值相加，再转化为数组\r\n-  所以解题过程完全按照结果的生成过程for循环实现\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```Python3\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        a=''\r\n        b=[]\r\n        for i in num:\r\n            a=a+str(i)\r\n        re=str(int(a)+k)\r\n        for j in re:\r\n            b.append(int(j))\r\n        return b\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 还不会分析复杂度,后面补上相关知识～\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838728328",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n\r\n-  题目是求每个字符串到最近到给定字符的距离，\r\n- 逆向思维，先求出给定字符到所有字符的距离，再求出其中的最小值\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        a=[]\r\n        b=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                a.append(i)\r\n\r\n        for i in range(len(s)):\r\n            re=len(s)\r\n            for j in a:\r\n                re=min(re,abs(int(i)-int(j)))\r\n            b.append(re)\r\n        return b\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838728328",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n\r\n-  题目是求每个字符串到最近到给定字符的距离，\r\n- 逆向思维，先求出给定字符到所有字符的距离，再求出其中的最小值\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        a=[]\r\n        b=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                a.append(i)\r\n\r\n        for i in range(len(s)):\r\n            re=len(s)\r\n            for j in a:\r\n                re=min(re,abs(int(i)-int(j)))\r\n            b.append(re)\r\n        return b\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "keepchasing": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836818313",
      "body": "### 思路\r\n+ 遍历数组与K的对应位相加，并记录进位carryNum，carryNum默认值为0\r\n+ 判断K的位数与A对应的数字的位数，如果K的位数更大 取出前边的数据依次加到A中\r\n### 语言：\r\n javascript\r\n\r\n### 复杂度分析\r\n+ 时间复杂度： O(N)\r\n+ 空间复杂度：O(1)\r\n```\r\n/**\r\n * @param {number[]} A\r\n * @param {number} K\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = (A, K) => {\r\n    let len = A.length // 数组A的长度\r\n    let carryNum = 0 // 进位\r\n    A.forEach((item, index) => {\r\n        let curNum = Math.floor(K % Math.pow(10, index + 1) / Math.pow(10, index))\r\n        let tmpCurNum = (curNum + A[len - index -1 ] + carryNum)\r\n        A[len - index - 1] = tmpCurNum % 10\r\n        carryNum = Math.floor(tmpCurNum / 10)\r\n    })\r\n    let kStrLen = (K + '').length\r\n    // 如果K的位数大于A对应的数字的位数\r\n    if (kStrLen >= len) {\r\n        let tmpK = Math.floor(K / Math.pow(10, len)) + carryNum\r\n        let tmpKStrLen = (tmpK + '').length\r\n        for (let i = 0; i < tmpKStrLen; i ++) {\r\n            let tmpNum = Math.floor(tmpK % Math.pow(10, i + 1) / Math.pow(10, i))\r\n            i === tmpKStrLen - 1 && tmpNum === 0 ? '' : A.unshift(tmpNum)\r\n        }\r\n    } else {\r\n        carryNum ? A.unshift(carryNum) : ''\r\n    }\r\n    return A\r\n}\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838608422",
      "body": "### 思路分析\r\n+ 从左到右遍历数组， res存储当前字符到左边数下标最大的目标C的距离\r\n+ 从右到左遍历，比较下标i对应的字符到从右边数下标最小的目标C的距离与res[i]的大小，取最小值\r\n\r\n### 语言\r\n+ javascript\r\n### 复杂度分析\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(n)\r\n```\r\nlet S = \"loveleetcode\", C = 'e'\r\nconst shortestToChar = (S, C) => {\r\n    let res = []\r\n    let sLen = S.length\r\n    let leftMaxIndex = -10000\r\n    let rightMinIndex = 20000\r\n    for(let i = 0; i < sLen; i++) {\r\n        if(S[i] === C) {\r\n            leftMaxIndex = i\r\n        }\r\n        res[i] = i - leftMaxIndex\r\n    }\r\n    for(let i = sLen - 1; i >= 0; i--) {\r\n        if(S[i] === C) {\r\n            rightMinIndex = i\r\n        }\r\n        res[i] = Math.min(rightMinIndex - i, res[i])\r\n    }\r\n    return res\r\n}\r\nconsole.log(shortestToChar(S, C))\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838608422",
      "body": "### 思路分析\r\n+ 从左到右遍历数组， res存储当前字符到左边数下标最大的目标C的距离\r\n+ 从右到左遍历，比较下标i对应的字符到从右边数下标最小的目标C的距离与res[i]的大小，取最小值\r\n\r\n### 语言\r\n+ javascript\r\n### 复杂度分析\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(n)\r\n```\r\nlet S = \"loveleetcode\", C = 'e'\r\nconst shortestToChar = (S, C) => {\r\n    let res = []\r\n    let sLen = S.length\r\n    let leftMaxIndex = -10000\r\n    let rightMinIndex = 20000\r\n    for(let i = 0; i < sLen; i++) {\r\n        if(S[i] === C) {\r\n            leftMaxIndex = i\r\n        }\r\n        res[i] = i - leftMaxIndex\r\n    }\r\n    for(let i = sLen - 1; i >= 0; i--) {\r\n        if(S[i] === C) {\r\n            rightMinIndex = i\r\n        }\r\n        res[i] = Math.min(rightMinIndex - i, res[i])\r\n    }\r\n    return res\r\n}\r\nconsole.log(shortestToChar(S, C))\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "CurrrryChen": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836821360",
      "body": "**思路**\r\n利用js的BigInt累加\r\n\r\n**代码**\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    return (BigInt(num.join(''))+BigInt(k)).toString().split('').map(Number);\r\n};\r\n```\r\n\r\n**复杂度**\r\n时间复杂度:O(n)\r\n空间复杂度:O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "renziao": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836824996",
      "body": "思路：leetcode官方题解的思路：数组和数字最后一位从后往前，对应的位相加，如果产生进位，数字k加1，这样就会在下一位中运 算了，最后如果数字k的长度大于数组的长度，那么就把数字k剩下的进行取余取整操作，加到目标数组中，最后数组反转得到结果\r\n\r\n代码：\r\n\r\npublic List addToArrayForm(int[] A, int K) {\r\n// 初始化参数\r\nList res = new ArrayList();\r\nint n = A.length;\r\n\r\n    // 1. 从后往前逐位相加\r\n    for(int i = n - 1;i >= 0;i--){\r\n        // 1.1 逐位相加\r\n        int sum = A[i] + K % 10;         // 每次重置sum\r\n        K /= 10;    \r\n        // 1.2 处理两位相加 进位的情况\r\n        if(sum >= 10){\r\n            K++;                        // 进位到K的末尾\r\n            sum -= 10;                  // 进位清掉\r\n        }\r\n        // 1.2 当前相加的结果 添加到结果集\r\n        res.add(sum);\r\n    }\r\n\r\n    // 2. K的数字长度大于数组的数字长度\r\n    for(;K > 0;K /= 10){                // 每次K左移一位\r\n        res.add(K % 10);                // 添加到结果集\r\n    }\r\n\r\n    // 3. 将结果集翻转即是所求答案\r\n    Collections.reverse(res);\r\n    return res;"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Nbambi": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836826525",
      "body": "思路\r\n- 遍历数组num，用k乘当前位的10的幂次，累加结果\r\n\r\n代码\r\n```\r\nvar addToArrayForm = function (num, k) {\r\n    let len = num.length - 1;\r\n    let result = 0;\r\n    for(let i=0; i<num.length; i++) {\r\n        result = result +num[i] * (Math.pow(10, len - i))\r\n    }\r\n    return result + k;\r\n};\r\n```\r\n\r\n复杂度\r\n\r\n- 时间复杂度O(n) 空间复杂度O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837853699",
      "body": "- 思路\r\n中心扩展法\r\n\r\n- 代码：JS\r\n```\r\n/**\r\n * 中心扩展法\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    let n = s.length;\r\n    let answer = Array(n).fill(0);\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        // 刚好匹配 不处理\r\n        if (s[i] === c) continue;\r\n        // 定义向左向右两个指针, 初始化 最短距离=Infinity(因为数组默认初始值是0)\r\n        let l = i, r = i, shortest = Infinity;\r\n        // 向左找\r\n        while (l >= 0) {\r\n            if (s[--l] === c) {\r\n                shortest = Math.min(i - l, shortest); //如果left找到了先赋值\r\n            }\r\n        }\r\n        // 向右找\r\n        while (r <= n) {\r\n            if (s[++r] === c) {\r\n                shortest = Math.min(r - i, shortest); //如果left找到了, 会与之比较, 更小就会替换掉\r\n            }\r\n        }\r\n        answer[i] = shortest;\r\n    }\r\n    return answer;\r\n};\r\n```\r\n\r\n- 复杂度\r\n时间复杂度O(n2) 空间复杂度O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837853699",
      "body": "- 思路\r\n中心扩展法\r\n\r\n- 代码：JS\r\n```\r\n/**\r\n * 中心扩展法\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    let n = s.length;\r\n    let answer = Array(n).fill(0);\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        // 刚好匹配 不处理\r\n        if (s[i] === c) continue;\r\n        // 定义向左向右两个指针, 初始化 最短距离=Infinity(因为数组默认初始值是0)\r\n        let l = i, r = i, shortest = Infinity;\r\n        // 向左找\r\n        while (l >= 0) {\r\n            if (s[--l] === c) {\r\n                shortest = Math.min(i - l, shortest); //如果left找到了先赋值\r\n            }\r\n        }\r\n        // 向右找\r\n        while (r <= n) {\r\n            if (s[++r] === c) {\r\n                shortest = Math.min(r - i, shortest); //如果left找到了, 会与之比较, 更小就会替换掉\r\n            }\r\n        }\r\n        answer[i] = shortest;\r\n    }\r\n    return answer;\r\n};\r\n```\r\n\r\n- 复杂度\r\n时间复杂度O(n2) 空间复杂度O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "AmuroPeng": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836832176",
      "body": "\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length;\r\n        List<Integer> ans = new ArrayList<Integer>();\r\n        for (int i = n - 1; i >=0; i--) {\r\n            int digit = num[i] + k % 10; // for each digit\r\n            k /= 10;\r\n            if (digit >= 10) {\r\n                digit -= 10;\r\n                k++;\r\n            }\r\n            ans.add(digit);\r\n        }\r\n        // if the length of k is more than num\r\n        while (k >= 10){\r\n            ans.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        if (k != 0) {\r\n            ans.add(k);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"
    },
    null,
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838810213",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n正向遇到第一个c之前，ans[i]设为无限大\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] ans = new int[len];\r\n        int count = -1;\r\n        // sequentially traverse\r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n                count = 0;\r\n                ans[i] = 0;\r\n            }else if (count == -1) ans[i] = Integer.MAX_VALUE;\r\n            else {\r\n                count += 1;\r\n                ans[i] = count;\r\n            }\r\n        }\r\n        // reverse\r\n        count = -1;\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                count = 0;\r\n            } else if (count == -1) {\r\n                continue;\r\n            } else {\r\n                count += 1;\r\n                ans[i] = Math.min(ans[i], count);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "christ36": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836832193",
      "body": "class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n复杂度分析\r\n\r\n时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\r\n\r\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838755307",
      "body": "public class mindistant {\r\n    public int[] addToArrayForm(String S, char C) {\r\n        int N = S.length();\r\n        int[] res = new int[N];\r\n        for(int i = 0; i <N; i++) {\r\n            if (S.charAt(i) == C) continue;\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S.charAt(left) == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S.charAt(right) == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n            res[i] = dist;\r\n        }\r\n        return res;\r\n    }\r\n}"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838755307",
      "body": "public class mindistant {\r\n    public int[] addToArrayForm(String S, char C) {\r\n        int N = S.length();\r\n        int[] res = new int[N];\r\n        for(int i = 0; i <N; i++) {\r\n            if (S.charAt(i) == C) continue;\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S.charAt(left) == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S.charAt(right) == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n            res[i] = dist;\r\n        }\r\n        return res;\r\n    }\r\n}"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "fangyinghua": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836833635",
      "body": "思路:\r\n\r\n* 从右往左 依次遍历 [十进一]\r\n\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const len= num.length;\r\n\r\n   //需要处理 两者长度不一，可能数组的个数小于k的个数\r\n    for (let i = len - 1; (i >= 0 || k > 0); (--i, k = parseInt(k / 10))) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n\r\n复杂度\r\n\r\n* 时间复杂度O(Max(n,k)) \r\n* 空间复杂度O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838753017",
      "body": "思路：\r\n从两个方向扫描，在相同位置进行比较。\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\n var shortestToChar = function (s, c) {\r\n        let N = s.length;\r\n        let ans = new Array(N);\r\n        let prev=Number.MIN_SAFE_INTEGER/2;\r\n        for (let i = 0; i < N; ++i) {\r\n            if (s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev =Number.MAX_SAFE_INTEGER/2;\r\n        for (let i = N-1; i >= 0; --i) {\r\n            if (s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n   };\r\n```\r\n复杂度分析\r\n  * 时间复杂度:O(N);\r\n  * 空间复杂度:O(N);"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838753017",
      "body": "思路：\r\n从两个方向扫描，在相同位置进行比较。\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\n var shortestToChar = function (s, c) {\r\n        let N = s.length;\r\n        let ans = new Array(N);\r\n        let prev=Number.MIN_SAFE_INTEGER/2;\r\n        for (let i = 0; i < N; ++i) {\r\n            if (s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev =Number.MAX_SAFE_INTEGER/2;\r\n        for (let i = N-1; i >= 0; --i) {\r\n            if (s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n   };\r\n```\r\n复杂度分析\r\n  * 时间复杂度:O(N);\r\n  * 空间复杂度:O(N);"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Gjts": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836834532",
      "body": "算法流程\r\n\r\n    获取数组的长度\r\n    将 需要添加的targe赋值给sum\r\n    求出 num 和 k 之和 sum\r\n    逐位取 sum % 10，sum = sum // 10\r\n    反转，res[::-1]\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(n)\r\n    空间复杂度：O(n)\r\n\r\n代码\r\n    \r\n    语言支持：c#\r\n    public IList<int> AddToArrayForm(int[] num, int k) {\r\n          int i = num.Length - 1;\r\n          int sum = k;\r\n          List<int> arr = new List<int>();\r\n          while(i >= 0 || sum > 0){\r\n              if(i >= 0){\r\n                  sum += num[i];\r\n              }\r\n              arr.Add(sum % 10);\r\n              sum /= 10;\r\n              i--;\r\n          }\r\n          int[] arr1 = arr.ToArray();\r\n          Array.Reverse(arr1);\r\n          return arr1;\r\n      }：\r\n  "
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838023165",
      "body": "算法流程:\r\n\r\n    获取字符的长度\r\n    定义一个未知数int prev右移一位 int.MinValue>>1 int.MaxValue>>1 \r\n    左移、右移一位是为了定义一个边界值 0-最小值有问题 不会变成一个正整数\r\n    把字符串转换成数组char 判断和target相等 就取代那个未知数prev默认的位置\r\n    二分遍历查询数组，第一轮找到左边离target最近的数\r\n    ，第二轮找到右边离target最近的数，判断谁小把谁放到数组中\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(n) 循环遍历数组的长度\r\n    空间复杂度：O(n) 创建了一个数组  复杂度分析不太懂 特别是空间复杂度\r\n\r\n语言支持：c#\r\n\r\n    public int[] ShortestToChar(string s, char c) {\r\n        int N = s.Length;\r\n        var isok = s.ToCharArray();\r\n        int[] ans = new int[N];\r\n        var prev = int.MinValue >> 1;\r\n        for (int i = 0; i < s.Length; i++)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = int.MaxValue >> 1;\r\n        for (int i = N - 1; i >= 0; --i)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = Math.Min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838023165",
      "body": "算法流程:\r\n\r\n    获取字符的长度\r\n    定义一个未知数int prev右移一位 int.MinValue>>1 int.MaxValue>>1 \r\n    左移、右移一位是为了定义一个边界值 0-最小值有问题 不会变成一个正整数\r\n    把字符串转换成数组char 判断和target相等 就取代那个未知数prev默认的位置\r\n    二分遍历查询数组，第一轮找到左边离target最近的数\r\n    ，第二轮找到右边离target最近的数，判断谁小把谁放到数组中\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(n) 循环遍历数组的长度\r\n    空间复杂度：O(n) 创建了一个数组  复杂度分析不太懂 特别是空间复杂度\r\n\r\n语言支持：c#\r\n\r\n    public int[] ShortestToChar(string s, char c) {\r\n        int N = s.Length;\r\n        var isok = s.ToCharArray();\r\n        int[] ans = new int[N];\r\n        var prev = int.MinValue >> 1;\r\n        for (int i = 0; i < s.Length; i++)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = int.MaxValue >> 1;\r\n        for (int i = N - 1; i >= 0; --i)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = Math.Min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "doubelejjyy": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836835885",
      "body": "**思路:**\r\n1.从低位开始加\r\n2.可能k的长度大于数组的长度,所以可能for循环结束了但是k没加完,所以最后用while\r\n3.list.add的顺序是队列所以list一开始的顺序是答案从低位到高位的顺序 所以要逆序一下\r\n**代码**\r\n\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n        int length = num.length;\r\n        int value;\r\n        for (int i = length-1; i >=0; i--) {\r\n            value = num[i]+k%10;\r\n            k/=10;\r\n            if(value>9){\r\n                value -=10;\r\n                k++;//进位\r\n            }\r\n            list.add(value);\r\n\r\n        }\r\n\r\n        while(k!=0)\r\n            list.add(k%10);\r\n            k/=10;\r\n        }\r\n\r\n        Collections.reverse(list);\r\n        return list;\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n**时间复杂度O(n)**\r\n**空间复杂度O(n)**"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837883042",
      "body": "**思路:**\r\n1.从左到右遍历只考虑每个字符和它左边的c的距离\r\n2.从右到左遍历只考虑每个字符和它右边的c的距离\r\n3.然后比较大小\r\n\r\n**代码**\r\nJava Code:\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        \r\n        int length = s.length();\r\n        int pre = Integer.MIN_VALUE / 2;//除2是为了防止 i-pre超过int的最大值\r\n        int[] answer = new int[length];\r\n        //1.先从左边往右找 计算每个字符和上一个c的距离是多少\r\n        for (int i = 0; i < length; i++) {\r\n\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            answer[i] = i-pre;\r\n        }\r\n\r\n        //从右边往左找 每次计算当前字符和上一个c的距离是多少\r\n        pre = Integer.MAX_VALUE / 2;// \r\n        for (int i = length-1; i >=0; i--) {\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n\r\n            if(answer[i]<pre - i){\r\n\r\n            }else{\r\n                answer[i] = pre - i;\r\n            }\r\n        }\r\n\r\n        return answer;\r\n\r\n    }\r\n}\r\n```\r\n\r\n**时间复杂度O(n)**\r\n**空间复杂度O(1)**"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837883042",
      "body": "**思路:**\r\n1.从左到右遍历只考虑每个字符和它左边的c的距离\r\n2.从右到左遍历只考虑每个字符和它右边的c的距离\r\n3.然后比较大小\r\n\r\n**代码**\r\nJava Code:\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        \r\n        int length = s.length();\r\n        int pre = Integer.MIN_VALUE / 2;//除2是为了防止 i-pre超过int的最大值\r\n        int[] answer = new int[length];\r\n        //1.先从左边往右找 计算每个字符和上一个c的距离是多少\r\n        for (int i = 0; i < length; i++) {\r\n\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            answer[i] = i-pre;\r\n        }\r\n\r\n        //从右边往左找 每次计算当前字符和上一个c的距离是多少\r\n        pre = Integer.MAX_VALUE / 2;// \r\n        for (int i = length-1; i >=0; i--) {\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n\r\n            if(answer[i]<pre - i){\r\n\r\n            }else{\r\n                answer[i] = pre - i;\r\n            }\r\n        }\r\n\r\n        return answer;\r\n\r\n    }\r\n}\r\n```\r\n\r\n**时间复杂度O(n)**\r\n**空间复杂度O(1)**"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "luckyyangrun": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836844742",
      "body": "```\r\ndef addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n    res = []\r\n    i, carry = len(A) - 1, 0\r\n    while i >= 0 or K != 0:\r\n        x = A[i] if i >= 0 else 0\r\n        y = K % 10 if K != 0 else 0\r\n        sum = x + y + carry\r\n        res.append(sum % 10)\r\n        carry = sum // 10\r\n        i -= 1\r\n        K //= 10\r\n    if carry != 0: res.append(carry)\r\n    return res[::-1]\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "tipshal": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836845741",
      "body": "我是码盲，刚开始学Python，先说一下思路吧：\r\n1.把一维数组转换成整数\r\n  s=0\r\n  for i in A\r\n    s=s*10+i\r\n2.整体进行加法运算\r\n  s=s+k\r\n3.将计算结果转成字符串，用列表推导式把每一位字符转换成整数\r\n  s=str(s)\r\n  return[int(x) for x in s]"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838738222",
      "body": "囧迫的我还没搞好Python，先抄了一段Java，大概意思看明白了，就是通过两次遍历，找出c的位置，进行与当前每个字符的比对\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左向右遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右向左遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838738222",
      "body": "囧迫的我还没搞好Python，先抄了一段Java，大概意思看明白了，就是通过两次遍历，找出c的位置，进行与当前每个字符的比对\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左向右遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右向左遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "zsjlovelike": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836846214",
      "body": "Class Solution{\r\nList<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n}"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838335540",
      "body": "class Solution { \r\n public  int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        //保证有prev参与的加减运算不会溢出。同时又能起到最小值的效果\r\n        //因为i>=0,不除以2会越界。防止从左向右遍历数组时i-pre越界。\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(res[i], prev - i);\r\n        }\r\n        return res;\r\n    }\r\n}"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838335540",
      "body": "class Solution { \r\n public  int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        //保证有prev参与的加减运算不会溢出。同时又能起到最小值的效果\r\n        //因为i>=0,不除以2会越界。防止从左向右遍历数组时i-pre越界。\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(res[i], prev - i);\r\n        }\r\n        return res;\r\n    }\r\n}"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "daidaidashixiong666": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836860926",
      "body": "class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838683020",
      "body": "class Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        \r\n        int N =S.length();\r\n        int[] ans =new int[N];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for(int i=0;i<N;i++){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=i-prev; \r\n        }\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=N-1;i>=0;--i){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n    }\r\n}"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838683020",
      "body": "class Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        \r\n        int N =S.length();\r\n        int[] ans =new int[N];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for(int i=0;i<N;i++){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=i-prev; \r\n        }\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=N-1;i>=0;--i){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n    }\r\n}"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "flagyk5": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836861924",
      "body": "思路：\r\n1.list转换为int，计算加法，再把结果转化为list\r\n2.缺点运行速度太慢，空间一般\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        B = 0\r\n        for i in range(len(A) - 1, -1, -1):\r\n            B += A[i]*(10**(len(A) - i - 1))  \r\n        C = B + K\r\n        \r\n        if C == 0:\r\n            D = [0]\r\n        else:\r\n            D = []\r\n        \r\n        while C:\r\n            D.append(C%10)\r\n            C //=10\r\n        D.reverse()\r\n        return D"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838722787",
      "body": "思路：\r\n两边分别寻找距离，然后对比。一开始不知道怎么处理没找到的情况，solution的方法很简洁，借鉴了一下\r\n\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        \r\n        for i in range(len(s)):\r\n            l = i   \r\n            while l >= 0:\r\n                if s[l] == c:\r\n                    break\r\n                else:\r\n                    l -= 1\r\n                 \r\n            r = i\r\n            while r < len(s):\r\n                if s[r] == c:\r\n                    break\r\n                else:\r\n                    r += 1\r\n                    \r\n            if l == -1: l = -10000\r\n            if r == len(s): r = 10000\r\n            num = min(i-l, r-i)\r\n            ans.append(num)\r\n        return ans\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838722787",
      "body": "思路：\r\n两边分别寻找距离，然后对比。一开始不知道怎么处理没找到的情况，solution的方法很简洁，借鉴了一下\r\n\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        \r\n        for i in range(len(s)):\r\n            l = i   \r\n            while l >= 0:\r\n                if s[l] == c:\r\n                    break\r\n                else:\r\n                    l -= 1\r\n                 \r\n            r = i\r\n            while r < len(s):\r\n                if s[r] == c:\r\n                    break\r\n                else:\r\n                    r += 1\r\n                    \r\n            if l == -1: l = -10000\r\n            if r == len(s): r = 10000\r\n            num = min(i-l, r-i)\r\n            ans.append(num)\r\n        return ans\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "jennny06": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836864849",
      "body": "一开始用了一个一个加的方法，然后在用 divmod 做，但是发现这样的速度很慢。学习了一下评论里的码，发现python 其实一行code 就可以搞定：先把str 转成int， 然后加减，再转成str：\r\n`return map(int,str(int(''.join(map(str,num))) + k))`"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838731551",
      "body": "### 思路\r\n先找到index，然后一个一个比较\r\n\r\n```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        ind = [i for i,e in enumerate(s) if e == c ]\r\n        ans = []\r\n        \r\n        for i in range(len(s)):\r\n            minn = 'inf'\r\n            for j in ind:\r\n                dist = abs(i-j)\r\n                if minn > dist:\r\n                    minn = dist\r\n            ans.append(minn)\r\n                \r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：`O(n^2)`"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838731551",
      "body": "### 思路\r\n先找到index，然后一个一个比较\r\n\r\n```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        ind = [i for i,e in enumerate(s) if e == c ]\r\n        ans = []\r\n        \r\n        for i in range(len(s)):\r\n            minn = 'inf'\r\n            for j in ind:\r\n                dist = abs(i-j)\r\n                if minn > dist:\r\n                    minn = dist\r\n            ans.append(minn)\r\n                \r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：`O(n^2)`"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "sun-unc": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836866524",
      "body": "var addToArrayForm = function (num, k) {\r\n    return (BigInt(num.join('')) + BigInt(k)).toString().split('')\r\n};"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838373077",
      "body": "    var shortestToChar = function(s, c) {\r\n      let arr = s.split('')\r\n      let answer = []\r\n      for(let i = 0; i < arr.length; i++) {\r\n        if(arr[i] == c) {\r\n          answer.push(0)\r\n          continue\r\n        }\r\n        let arr1 = arr.slice(0, i).reverse()\r\n        let arr2 = arr.slice(i+1, arr.length)\r\n        let leftIndex = arr1.indexOf(c)\r\n        let rightIndex = arr2.indexOf(c)\r\n        if (leftIndex === -1) {\r\n          answer.push(rightIndex + 1)\r\n        } else if(rightIndex === -1) {\r\n          answer.push(leftIndex + 1)\r\n        } else {\r\n          leftIndex <= rightIndex ? answer.push(leftIndex + 1) : answer.push(rightIndex + 1)\r\n        }\r\n      }\r\n      console.log(answer);\r\n      // return answer\r\n    };"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838373077",
      "body": "    var shortestToChar = function(s, c) {\r\n      let arr = s.split('')\r\n      let answer = []\r\n      for(let i = 0; i < arr.length; i++) {\r\n        if(arr[i] == c) {\r\n          answer.push(0)\r\n          continue\r\n        }\r\n        let arr1 = arr.slice(0, i).reverse()\r\n        let arr2 = arr.slice(i+1, arr.length)\r\n        let leftIndex = arr1.indexOf(c)\r\n        let rightIndex = arr2.indexOf(c)\r\n        if (leftIndex === -1) {\r\n          answer.push(rightIndex + 1)\r\n        } else if(rightIndex === -1) {\r\n          answer.push(leftIndex + 1)\r\n        } else {\r\n          leftIndex <= rightIndex ? answer.push(leftIndex + 1) : answer.push(rightIndex + 1)\r\n        }\r\n      }\r\n      console.log(answer);\r\n      // return answer\r\n    };"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Rainjoy66": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836866671",
      "body": "```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        for nu in num:\r\n            res.append(str(nu))\r\n        string = \"\".join(res)\r\n        ans = int(string) + k\r\n        anss = list(str(ans))\r\n        dd = []\r\n        for ansss in anss:\r\n            dd.append(int(ansss))\r\n        return dd\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734678",
      "body": "### 思路：\r\n正反遍历，然后取最小值\r\n### 代码\r\n```\r\ndef function(self, s, c):\r\n        res = []\r\n        t = len(s)\r\n        for i in s:\r\n            t=0 if i==c else t+1\r\n            res.append(t)\r\n        for idx,i in enumerate(s[::-1]):\r\n            t = 0 if i==c else t+1\r\n            res[-(idx+1)] = min(t,res[-(idx+1)])\r\n        return res\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734678",
      "body": "### 思路：\r\n正反遍历，然后取最小值\r\n### 代码\r\n```\r\ndef function(self, s, c):\r\n        res = []\r\n        t = len(s)\r\n        for i in s:\r\n            t=0 if i==c else t+1\r\n            res.append(t)\r\n        for idx,i in enumerate(s[::-1]):\r\n            t = 0 if i==c else t+1\r\n            res[-(idx+1)] = min(t,res[-(idx+1)])\r\n        return res\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "shuo0314": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836867704",
      "body": "#Logic: convert list to str, then to int; add 2 int to get sum; convert int to str; convert str to list\r\n#Code: Python\r\n\r\n```\r\ndef addToArrayForm(self, num,k):\r\n    num_str = \"\"\r\n    for i in num:\r\n        num_str += str(i)\r\n    num_sum = int(num_str)+k\r\n    num_lst = [int(i) for i in str(num_sum)]\r\n    return num_lst\r\n```\r\n\r\n#Complexity: Time: O(n), Space: O(n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838701859",
      "body": "\"\"\"Logic: iterate through the str, if the character is c, put its position in str in a new list1. After for loop, list1 will\r\n      have all position in str that's c;\r\n      iterate through the str, if the character is c, put 0 in the return list; if not, calculate the absolute value between\r\n      this index and each index in list 1, find the min and put it in the return list\r\n\"\"\"\r\n#Code: Python\r\n```\r\ndef shortestToChar(s, c):\r\n    lst = []\r\n    res_lst=[]\r\n    for i in range(len(s)):\r\n        if s[i] == c:\r\n            lst.append(i)\r\n    for j in range(len(s)):\r\n        if s[j]==c:\r\n            res_lst.append(0)\r\n        else:\r\n            min_dis = len(s)\r\n            for i in lst:\r\n                if abs(i-j) < min_dis:\r\n                    min_dis = abs(i-j)\r\n            res_lst.append(min_dis)\r\n    return res_lst\r\n```\r\n#Complexity: Time: O(n^2), Space: O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838701859",
      "body": "\"\"\"Logic: iterate through the str, if the character is c, put its position in str in a new list1. After for loop, list1 will\r\n      have all position in str that's c;\r\n      iterate through the str, if the character is c, put 0 in the return list; if not, calculate the absolute value between\r\n      this index and each index in list 1, find the min and put it in the return list\r\n\"\"\"\r\n#Code: Python\r\n```\r\ndef shortestToChar(s, c):\r\n    lst = []\r\n    res_lst=[]\r\n    for i in range(len(s)):\r\n        if s[i] == c:\r\n            lst.append(i)\r\n    for j in range(len(s)):\r\n        if s[j]==c:\r\n            res_lst.append(0)\r\n        else:\r\n            min_dis = len(s)\r\n            for i in lst:\r\n                if abs(i-j) < min_dis:\r\n                    min_dis = abs(i-j)\r\n            res_lst.append(min_dis)\r\n    return res_lst\r\n```\r\n#Complexity: Time: O(n^2), Space: O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "yangjiahao106": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836868252",
      "body": "## 思路\r\n\r\n遍历数组num，用k乘当前位的10的幂次，累加结果\r\n代码\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num = list(reversed(num))\r\n        for i in range(0, len(num)):\r\n            k += num[i]\r\n            num[i] = k %10\r\n            k = k // 10\r\n        \r\n        while k > 0:\r\n            num.append(k%10)\r\n            k  = k // 10\r\n        return list(reversed(num))\r\n```\r\n## 复杂度\r\n\r\n时间复杂度O(n) 空间复杂度O(1)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838740235",
      "body": "```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = 0 \r\n        r = 0\r\n\r\n        res = [1<<31-1 for i in s] \r\n\r\n        while r < len(s):\r\n            if s[r] == c:\r\n               break\r\n            r += 1\r\n\r\n        for l in range(0, len(s)):\r\n            res[l] = r - l \r\n            if l ==r:\r\n                while r < len(s)-1:\r\n                    r += 1\r\n                    if s[r] == c:\r\n                        break\r\n                if s[r] != c:\r\n                    break\r\n        r = len(s) - 1\r\n        while r >=0:\r\n            if s[r] == c:\r\n               break\r\n            r -= 1\r\n    \r\n        for l in range(len(s)-1, -1, -1):\r\n            res[l] = min(res[l],  l-r) \r\n            if l <= r:\r\n                while r > 0:\r\n                    r -= 1\r\n                    if s[r] == c:\r\n                        break\r\n                if s[r] != c:\r\n                    return res \r\n        return res \r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838740235",
      "body": "```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = 0 \r\n        r = 0\r\n\r\n        res = [1<<31-1 for i in s] \r\n\r\n        while r < len(s):\r\n            if s[r] == c:\r\n               break\r\n            r += 1\r\n\r\n        for l in range(0, len(s)):\r\n            res[l] = r - l \r\n            if l ==r:\r\n                while r < len(s)-1:\r\n                    r += 1\r\n                    if s[r] == c:\r\n                        break\r\n                if s[r] != c:\r\n                    break\r\n        r = len(s) - 1\r\n        while r >=0:\r\n            if s[r] == c:\r\n               break\r\n            r -= 1\r\n    \r\n        for l in range(len(s)-1, -1, -1):\r\n            res[l] = min(res[l],  l-r) \r\n            if l <= r:\r\n                while r > 0:\r\n                    r -= 1\r\n                    if s[r] == c:\r\n                        break\r\n                if s[r] != c:\r\n                    return res \r\n        return res \r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "bmxbmx3": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836878093",
      "body": "### 思路\r\n\r\n初步思路：\r\n1. 先排除异常情况\r\n2. 将数组变成对应数字，加上一个数后，将相加结果变回数组\r\n\r\n### 代码\r\n\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int] 待加数字的数组\r\n        :type k: int 所加的数字\r\n        :rtype: List[int] 加数字后的数组\r\n        \"\"\"\r\n\r\n        # 将num数组转换为对应的数字\r\n        sum = 0\r\n        length = len(num)\r\n        for i in range(len(num)):\r\n            sum += num[i]*10**(length-i-1)  # 逐位相加，比如[1,2]即1*10^1+2*10^0=12\r\n\r\n        sum += k  # 计算相加结果\r\n\r\n        # 将相加后的数字转换为对应的数组（从后往前逐位取数字）\r\n        result = []\r\n        while(sum):\r\n            result.append(sum % 10)\r\n            sum = sum//10  # 双斜杠（//）表示地板除，即先做除法（/），然后向下取整（floor）\r\n        result.reverse() # 结果数组倒序\r\n        return result\r\n\r\n\r\nnum = [9,9,9,9,9,9,9,9,9,9]\r\nk = 1\r\ns = Solution()\r\nresult = s.addToArrayForm(num, k)\r\nprint(result)\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838601737",
      "body": "## 思路\r\n\r\n参考：\r\n- [821.字符的最短距离【4种解法、JS/Cpp/Py】](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/821zi-fu-de-zui-duan-ju-chi-4chong-jie-fa-javascri/)\r\n\r\n思路1（中心扩展法）：\r\n1. 排除异常情况\r\n2. 从原字符串s中每个字符（中心位置i）出发，向两边同时扩展寻找字符c。最先寻找到的字符c，一定距离位置i上的字符最近\r\n思路2（以空间换时间）？\r\n思路3（双向遍历贪心法）？（时间复杂度最优）\r\n## 关键点\r\n\r\n- python数组初始化？（参考：https://www.pythontab.com/html/2020/pythonjichu_0102/1470.html）\r\n- python判断字符串自否为大小写字母？（参考：https://blog.csdn.net/nanhuaibeian/article/details/99472393）\r\n- 双向遍历贪心法？\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    \"\"\"\r\n    思路1\r\n    \"\"\"\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        length = len(s)\r\n\r\n        \"\"\"\r\n        排除异常\r\n        \"\"\"\r\n        # 数组长度异常\r\n        if(length < 1 or length > 10000):\r\n            print(\"数组s的长度应在1-10000之间！\")\r\n            return\r\n        # 小写字母异常\r\n        if(not (s.islower() and s.isalpha())):\r\n            print(\"数组s必须都是小写字母！\")\r\n            return\r\n        if(c not in s):\r\n            print(\"字符c不在数组s中！\")\r\n            return\r\n\r\n        result = [0]*length  # 初始化结果数组，存放数组s中每个字符到字符c的最近距离\r\n\r\n        for i in range(length):\r\n            # 如果遍历到字符c，则跳过（最近距离为0）\r\n            if s[i] == c:\r\n                continue\r\n\r\n            \"\"\"  \r\n            以当前位置i的字符为中心，向两边扩展寻找最近的字符c\r\n            \"\"\"\r\n            left = i  # 向左寻找，下标不断减小\r\n            right = i  # 向右寻找，下表不断增加\r\n            min_distance = 0  # 记录最近距离（到中心字符s[i]）\r\n            while(left >= 0 or right <= length-1):\r\n                # 向两边同时寻找，一旦找到字符c就停止寻找\r\n                if(s[left] == c):\r\n                    min_distance = i-left\r\n                    break\r\n                if(s[right] == c):\r\n                    min_distance = right-i\r\n                    break\r\n\r\n                \"\"\" \r\n                left（向左标志）左移，同理right（向右标志）右移\r\n                note:\r\n                left若为0，left-1变为-1,到下层循环时不满足外层循环条件left>=0,\r\n                但right却可能依然满足right<length的外层循环条件，这样导致下层循环依然可以执行，\r\n                但此时下层循环中left=-1，使得s[left]即s[-1]因找不到值而发生错误,\r\n                故在这里设置left>0的判断。\r\n                同理，为了保险起见，这里right<length-1。\r\n                \"\"\"\r\n                if(left > 0):\r\n                    left -= 1\r\n                if(right < length-1):\r\n                    right += 1\r\n\r\n            result[i] = min_distance  # 记录字符串s中，当前位置i的字符距字符c的最近距离\r\n\r\n        return result\r\n\r\n\r\ns = Solution()\r\nstr_s = \"1baab\"\r\nc = \"a\"\r\nresult = s.shortestToChar(str_s, c)\r\nprint(result)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$，n为S的长度，两层循环。\r\n- 空间复杂度：$O(1)$"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838601737",
      "body": "## 思路\r\n\r\n参考：\r\n- [821.字符的最短距离【4种解法、JS/Cpp/Py】](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/821zi-fu-de-zui-duan-ju-chi-4chong-jie-fa-javascri/)\r\n\r\n思路1（中心扩展法）：\r\n1. 排除异常情况\r\n2. 从原字符串s中每个字符（中心位置i）出发，向两边同时扩展寻找字符c。最先寻找到的字符c，一定距离位置i上的字符最近\r\n思路2（以空间换时间）？\r\n思路3（双向遍历贪心法）？（时间复杂度最优）\r\n## 关键点\r\n\r\n- python数组初始化？（参考：https://www.pythontab.com/html/2020/pythonjichu_0102/1470.html）\r\n- python判断字符串自否为大小写字母？（参考：https://blog.csdn.net/nanhuaibeian/article/details/99472393）\r\n- 双向遍历贪心法？\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    \"\"\"\r\n    思路1\r\n    \"\"\"\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        length = len(s)\r\n\r\n        \"\"\"\r\n        排除异常\r\n        \"\"\"\r\n        # 数组长度异常\r\n        if(length < 1 or length > 10000):\r\n            print(\"数组s的长度应在1-10000之间！\")\r\n            return\r\n        # 小写字母异常\r\n        if(not (s.islower() and s.isalpha())):\r\n            print(\"数组s必须都是小写字母！\")\r\n            return\r\n        if(c not in s):\r\n            print(\"字符c不在数组s中！\")\r\n            return\r\n\r\n        result = [0]*length  # 初始化结果数组，存放数组s中每个字符到字符c的最近距离\r\n\r\n        for i in range(length):\r\n            # 如果遍历到字符c，则跳过（最近距离为0）\r\n            if s[i] == c:\r\n                continue\r\n\r\n            \"\"\"  \r\n            以当前位置i的字符为中心，向两边扩展寻找最近的字符c\r\n            \"\"\"\r\n            left = i  # 向左寻找，下标不断减小\r\n            right = i  # 向右寻找，下表不断增加\r\n            min_distance = 0  # 记录最近距离（到中心字符s[i]）\r\n            while(left >= 0 or right <= length-1):\r\n                # 向两边同时寻找，一旦找到字符c就停止寻找\r\n                if(s[left] == c):\r\n                    min_distance = i-left\r\n                    break\r\n                if(s[right] == c):\r\n                    min_distance = right-i\r\n                    break\r\n\r\n                \"\"\" \r\n                left（向左标志）左移，同理right（向右标志）右移\r\n                note:\r\n                left若为0，left-1变为-1,到下层循环时不满足外层循环条件left>=0,\r\n                但right却可能依然满足right<length的外层循环条件，这样导致下层循环依然可以执行，\r\n                但此时下层循环中left=-1，使得s[left]即s[-1]因找不到值而发生错误,\r\n                故在这里设置left>0的判断。\r\n                同理，为了保险起见，这里right<length-1。\r\n                \"\"\"\r\n                if(left > 0):\r\n                    left -= 1\r\n                if(right < length-1):\r\n                    right += 1\r\n\r\n            result[i] = min_distance  # 记录字符串s中，当前位置i的字符距字符c的最近距离\r\n\r\n        return result\r\n\r\n\r\ns = Solution()\r\nstr_s = \"1baab\"\r\nc = \"a\"\r\nresult = s.shortestToChar(str_s, c)\r\nprint(result)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$，n为S的长度，两层循环。\r\n- 空间复杂度：$O(1)$"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "DADAHUI": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836882177",
      "body": "\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n示例 1：\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n示例 2：\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n示例 3：\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n示例 4\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n提示：\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n`\r\n\r\n## 思路\r\nnum与k值逐位相加，大于9时进1，参与下一位运算\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) \r\n    {\r\n      vector <int> res;\r\n      for(int i=num.size()-1;i>=0;i--)\r\n      {\r\n          int sum=num[i]+k%10;\r\n          k/=10;\r\n          if(sum>9)\r\n          {\r\n              sum=sum%10;\r\n              k++;\r\n          }\r\n          res.push_back(sum);\r\n\r\n      }\r\n      for(;k>0;k/=10)\r\n      {\r\n          res.push_back(k%10);\r\n      }\r\n\r\n      reverse(res.begin(),res.end());\r\n      return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838588143",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n数组arr存储s中下标；s的每一个下标与每一个与和c相同的下标做差，取最小值 \r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n    vector <int> vec,answer;\r\n    \r\n    for(int i=0;i<s.size();i++)\r\n    {\r\n        if(s[i]==c) vec.push_back(i);\r\n    }\r\n    int arr[vec.size()];\r\n    \r\n    for(int i=0;i<s.size();i++)\r\n    {\r\n        for(int j=0;j<vec.size();j++)\r\n        {\r\n          arr[j]=abs(i-vec[j]);  \r\n        }\r\n        answer.push_back(*min_element(arr,arr+vec.size()));\r\n    }\r\n   return answer;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838588143",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n数组arr存储s中下标；s的每一个下标与每一个与和c相同的下标做差，取最小值 \r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n    vector <int> vec,answer;\r\n    \r\n    for(int i=0;i<s.size();i++)\r\n    {\r\n        if(s[i]==c) vec.push_back(i);\r\n    }\r\n    int arr[vec.size()];\r\n    \r\n    for(int i=0;i<s.size();i++)\r\n    {\r\n        for(int j=0;j<vec.size();j++)\r\n        {\r\n          arr[j]=abs(i-vec[j]);  \r\n        }\r\n        answer.push_back(*min_element(arr,arr+vec.size()));\r\n    }\r\n   return answer;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "qycoder": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836882253",
      "body": "## 思路\r\n\r\n\r\n## 代码\r\nJavaScript\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n  let str = '';\r\n  for (let i = 0; i < num.length; i++) {\r\n    if (num[i] < 0 || num[i] > 9) {\r\n      str = '';\r\n      break;\r\n    } else {\r\n      str += num[i];\r\n    }\r\n  }\r\n  let sum = str / 1 + k;\r\n  const result = [];\r\n  let divisor;\r\n  for (let j = 0; j < (sum + '').length; j++) {\r\n    if (j == 0) {\r\n      divisor = 1;\r\n    } else {\r\n      divisor = 10 ** j;\r\n    }\r\n    result.unshift(parseInt((sum % 10 ** (j + 1)) / divisor));\r\n  }\r\n  return result;\r\n};\r\n\r\nconst arr = [1, 2, 0, 1];\r\nconst k = 220;\r\nconsole.log(addToArrayForm(arr, k));\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838736689",
      "body": "## 思路\r\n\r\n## 代码\r\nvar shortestToChar = function (s, c) {\r\n  // 结果数组 res\r\n  var res = Array(s.length).fill(0);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (s[i] === c) continue;\r\n\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838736689",
      "body": "## 思路\r\n\r\n## 代码\r\nvar shortestToChar = function (s, c) {\r\n  // 结果数组 res\r\n  var res = Array(s.length).fill(0);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (s[i] === c) continue;\r\n\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "lanceli424": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836931206",
      "body": "## 代码\r\n```\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    let kArr: number[] = String(k).split('').map(v => parseInt(v, 10));\r\n    let kLength = kArr.length - 1;\r\n    let numLength = num.length - 1;\r\n    let flag: number = 0;\r\n    while(numLength >= 0 || kLength >= 0 || flag > 0) {\r\n        let kItem = kArr[kLength] || 0;\r\n        let numItem = num[numLength] || 0;\r\n        let sum = numItem + kItem + flag;\r\n        flag = 0;\r\n        if(sum >= 10) {\r\n            flag = 1;\r\n            sum -= 10;\r\n        }\r\n        if(numLength < 0) {\r\n            num.unshift(sum);\r\n        }else {            \r\n            num[numLength] = sum;\r\n        }\r\n        numLength--;\r\n        kLength--;\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n## 思路\r\n1. 把数据转换成数组相加\r\n2. 两个数组长度可能不一样长，如果长度不够需要在头部插入\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(m+n)，其中 m 是 num 数组长度，n 是 k的长度\r\n2. 空间复杂度 O(m+n)"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838374436",
      "body": "## 思路\r\n找到匹配的字符，判断离上一个节点近还是下一个节点近。第一匹配到的位置之前和最后一个匹配到的位置之后需要单独处理。\r\n\r\n## 代码\r\n```\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let result: number[] = [];\r\n    if (s.length === 0 || c.length === 0) {\r\n        return result;\r\n    }\r\n    let strArray = Array.from(s);\r\n    let indexs: number[] = [];\r\n    strArray.forEach((element, index) => {\r\n        if (element === c) {\r\n            indexs.push(index);\r\n        }\r\n    });\r\n    for (let i = 0; i <= indexs[0]; i++) {\r\n        result.push(indexs[0] - i);\r\n    }\r\n    for (let i = 0; i <= indexs.length - 2; i++) {\r\n        let start = indexs[i];\r\n        let end = indexs[i + 1];\r\n        for (let i = start + 1; i <= end; i++) {\r\n            let distance = Math.min(i - start, end - i);\r\n            result.push(distance);\r\n        }\r\n    }\r\n    for (let i = indexs[indexs.length - 1] + 1; i < strArray.length; i++) {\r\n        result.push(i - indexs[indexs.length - 1]);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(N)\r\n2. 空间复杂度 O(N)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838374436",
      "body": "## 思路\r\n找到匹配的字符，判断离上一个节点近还是下一个节点近。第一匹配到的位置之前和最后一个匹配到的位置之后需要单独处理。\r\n\r\n## 代码\r\n```\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let result: number[] = [];\r\n    if (s.length === 0 || c.length === 0) {\r\n        return result;\r\n    }\r\n    let strArray = Array.from(s);\r\n    let indexs: number[] = [];\r\n    strArray.forEach((element, index) => {\r\n        if (element === c) {\r\n            indexs.push(index);\r\n        }\r\n    });\r\n    for (let i = 0; i <= indexs[0]; i++) {\r\n        result.push(indexs[0] - i);\r\n    }\r\n    for (let i = 0; i <= indexs.length - 2; i++) {\r\n        let start = indexs[i];\r\n        let end = indexs[i + 1];\r\n        for (let i = start + 1; i <= end; i++) {\r\n            let distance = Math.min(i - start, end - i);\r\n            result.push(distance);\r\n        }\r\n    }\r\n    for (let i = indexs[indexs.length - 1] + 1; i < strArray.length; i++) {\r\n        result.push(i - indexs[indexs.length - 1]);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(N)\r\n2. 空间复杂度 O(N)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "lingquan02": [
    {
      "title": "989. 数组形式的整数加法",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836966361",
      "body": "### 思路\r\n- 位数相加，数组加完后，指针向前移动， 对于k加完后，去掉个位\r\n- 边界 数组len>=0 || k!=0\r\n复杂度：\r\nT= O(n)\r\nS =O(1)\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];// 存放结果\r\n    let len = num.length-1;\r\n    let carry = 0; // 存放进位\r\n\r\n    while(len>=0 || k!=0) {\r\n        const x = len >=0 ? num[len] : 0 // 取最后一位  （个位数）\r\n        const y = k!=0 ? k % 10 : 0; // 取个位数 取模\r\n\r\n        const sum = x+y+carry // 求和  \r\n        res.push(sum%10) // 将个位数放到结果集里\r\n        carry = Math.floor(sum/10) // 存放进位\r\n\r\n        len--;\r\n        k = Math.floor(k/10); // 每次运算完成去掉个位数\r\n    }\r\n\r\n    if(carry) res.push(carry)\r\n    return res.reverse()\r\n};\r\n\r\n```"
    },
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838529295",
      "body": "### 思路分析\r\n- T= O(n)\r\n- S = O(1)\r\n```javascript\r\n// 滑动窗口\r\nconst shortestToChar =(S,C) => {\r\n    let len =S.length;\r\n    let l = S[0] === C ? 0: len-1;\r\n    let r = S.indexOf(C,1); // 从index未1的位置开始找c\r\n    let res = Array(len);\r\n    for(let i=0;i<len;i++) {\r\n        res[i] =Math.min(Math.abs(i-r),Math.abs(l-i))\r\n        // 改变窗口\r\n        if(i===r) {\r\n            l =r; \r\n            r = S.indexOf(C,l+1);\r\n\r\n        }\r\n\r\n    }\r\n    return res\r\n}\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838529295",
      "body": "### 思路分析\r\n- T= O(n)\r\n- S = O(1)\r\n```javascript\r\n// 滑动窗口\r\nconst shortestToChar =(S,C) => {\r\n    let len =S.length;\r\n    let l = S[0] === C ? 0: len-1;\r\n    let r = S.indexOf(C,1); // 从index未1的位置开始找c\r\n    let res = Array(len);\r\n    for(let i=0;i<len;i++) {\r\n        res[i] =Math.min(Math.abs(i-r),Math.abs(l-i))\r\n        // 改变窗口\r\n        if(i===r) {\r\n            l =r; \r\n            r = S.indexOf(C,l+1);\r\n\r\n        }\r\n\r\n    }\r\n    return res\r\n}\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "longlonglu": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837017943",
      "body": "```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] answer = new int[length];\r\n        for (int i = 0; i < length; i++) {\r\n            if (s.charAt(i) == c) { answer[i] = 0; continue; }\r\n            int minDistance = Math.min(leftDistance(s, c, i), rightDistance(s, c, i));\r\n            answer[i] = minDistance;\r\n        }\r\n        return answer;\r\n    }\r\n    public int leftDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i >= 0; i--) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n    public int rightDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n}\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837017943",
      "body": "```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] answer = new int[length];\r\n        for (int i = 0; i < length; i++) {\r\n            if (s.charAt(i) == c) { answer[i] = 0; continue; }\r\n            int minDistance = Math.min(leftDistance(s, c, i), rightDistance(s, c, i));\r\n            answer[i] = minDistance;\r\n        }\r\n        return answer;\r\n    }\r\n    public int leftDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i >= 0; i--) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n    public int rightDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n}\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "911gt5": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837256654",
      "body": "TC: O(n)\r\nSC: O(n)\r\n\r\n``` python\r\ndef shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        left = [float('inf')]*n\r\n        right = [float('inf')]*n\r\n        stack = collections.deque()\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                while stack:\r\n                    pre_i= stack.popleft()\r\n                    left[pre_i] = i - pre_i\r\n                left[i] = 0\r\n            else:\r\n                stack.append(i)\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                while stack:\r\n                    post_i = stack.popleft()\r\n                    right[post_i] = post_i -i \r\n                right[i] = 0\r\n            else:\r\n                stack.append(i)\r\n        return [min(l,r) for l,r in zip(left, right)]\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837256654",
      "body": "TC: O(n)\r\nSC: O(n)\r\n\r\n``` python\r\ndef shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        left = [float('inf')]*n\r\n        right = [float('inf')]*n\r\n        stack = collections.deque()\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                while stack:\r\n                    pre_i= stack.popleft()\r\n                    left[pre_i] = i - pre_i\r\n                left[i] = 0\r\n            else:\r\n                stack.append(i)\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                while stack:\r\n                    post_i = stack.popleft()\r\n                    right[post_i] = post_i -i \r\n                right[i] = 0\r\n            else:\r\n                stack.append(i)\r\n        return [min(l,r) for l,r in zip(left, right)]\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "prince805962788": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837860923",
      "body": "### 思路\r\n双指针，从每个点出发，想左右搜寻，直到找到等于所给字符的点，然后分别算出距离，取其中最小的记录到数组中\r\n### 代码（js）\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    const res = []\r\n    for(let i=0;i<s.length;i++){\r\n        let left = i\r\n        let right = i\r\n        while(left>=0){\r\n            if(s[left] === c) break\r\n            left--\r\n        }\r\n        while(right<s.length){\r\n            if(s[right] === c) break\r\n            right++\r\n        }\r\n        if(left === -1) left = -Infinity\r\n        if(right === s.length) right = Infinity\r\n        res[i] = Math.min(i-left, right-i)\r\n    }\r\n    return res\r\n};\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837860923",
      "body": "### 思路\r\n双指针，从每个点出发，想左右搜寻，直到找到等于所给字符的点，然后分别算出距离，取其中最小的记录到数组中\r\n### 代码（js）\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    const res = []\r\n    for(let i=0;i<s.length;i++){\r\n        let left = i\r\n        let right = i\r\n        while(left>=0){\r\n            if(s[left] === c) break\r\n            left--\r\n        }\r\n        while(right<s.length){\r\n            if(s[right] === c) break\r\n            right++\r\n        }\r\n        if(left === -1) left = -Infinity\r\n        if(right === s.length) right = Infinity\r\n        res[i] = Math.min(i-left, right-i)\r\n    }\r\n    return res\r\n};\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "cyk1337": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837931988",
      "body": "# Approach\r\n- Left-to-right: count the distance on the right\r\n- Right-to-left: count the distance on the left\r\n- Take the minimum at each position\r\n\r\n# Python Implementation\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        distance = 10001\r\n        n = len(s)\r\n        res = []\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                distance = 0\r\n            res.append(distance)\r\n            distance += 1\r\n        \r\n        distance = 10001\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                distance = 0\r\n            res[i] = min(distance, res[i])\r\n            distance += 1\r\n        return res\r\n```\r\n\r\n# Complexity analysis\r\n- Time: O(n)\r\n- Space: O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837931988",
      "body": "# Approach\r\n- Left-to-right: count the distance on the right\r\n- Right-to-left: count the distance on the left\r\n- Take the minimum at each position\r\n\r\n# Python Implementation\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        distance = 10001\r\n        n = len(s)\r\n        res = []\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                distance = 0\r\n            res.append(distance)\r\n            distance += 1\r\n        \r\n        distance = 10001\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                distance = 0\r\n            res[i] = min(distance, res[i])\r\n            distance += 1\r\n        return res\r\n```\r\n\r\n# Complexity analysis\r\n- Time: O(n)\r\n- Space: O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "YanFaFa": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838156207",
      "body": "\r\nclass Solution {\r\n\r\n    /**\r\n     * @param String $s\r\n     * @param String $c\r\n     * @return Integer[]\r\n     */\r\n    function shortestToChar($s, $c) {\r\n        $target = [];\r\n        $len = strlen($s);\r\n        $targetLen = 0;\r\n        for ($i=0; $i<$len; $i++) {\r\n            if ($s[$i] == $c) {\r\n                array_push($target, $i);\r\n                $targetLen++;\r\n            }\r\n        }\r\n\r\n        for ($i = 0; $i<$len; $i++) {\r\n            if ($s[$i] == $c) {\r\n                $result[] = 0;\r\n            } else {\r\n                $num = $len;\r\n                for ($j = 0; $j<$targetLen;$j++) {\r\n                    $tmp = abs($target[$j] - $i);\r\n                    if ($tmp < $num) {\r\n                        $num = $tmp; \r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                $result[] = $num;\r\n            } \r\n        }\r\n        return $result;\r\n    }\r\n}"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838156207",
      "body": "\r\nclass Solution {\r\n\r\n    /**\r\n     * @param String $s\r\n     * @param String $c\r\n     * @return Integer[]\r\n     */\r\n    function shortestToChar($s, $c) {\r\n        $target = [];\r\n        $len = strlen($s);\r\n        $targetLen = 0;\r\n        for ($i=0; $i<$len; $i++) {\r\n            if ($s[$i] == $c) {\r\n                array_push($target, $i);\r\n                $targetLen++;\r\n            }\r\n        }\r\n\r\n        for ($i = 0; $i<$len; $i++) {\r\n            if ($s[$i] == $c) {\r\n                $result[] = 0;\r\n            } else {\r\n                $num = $len;\r\n                for ($j = 0; $j<$targetLen;$j++) {\r\n                    $tmp = abs($target[$j] - $i);\r\n                    if ($tmp < $num) {\r\n                        $num = $tmp; \r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                $result[] = $num;\r\n            } \r\n        }\r\n        return $result;\r\n    }\r\n}"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "RealDuxy": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838328793",
      "body": "#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 思路：\r\n\r\n暴力等等方法很简答，我们尝试双指针方法。\r\n构建result数组，由左向右遍历一遍，记录右边离你最近的c字符的距离，遍历 i 时可以利用已经完成的 i-1的结果。\r\n\r\n遍历完毕后，我们由右向左遍历，相当于比较左边和右边最近的c字符的距离哪个更小，取最小的来替代result[i]\r\n\r\n#### 代码 python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [math.inf] * len(s)\r\n        # 从左至右遍历一遍\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i > 0:\r\n                result[i] = result[i-1] + 1\r\n       \r\n        # 从右至左\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i < len(s)-1:\r\n                result[i] = min(result[i+1]+1, result[i])\r\n        return result\r\n```\r\n\r\n\r\n\r\n#### 复杂度分析:\r\n\r\n时间复杂度：\r\n\r\n两次遍历都是N次迭代，每次迭代都是常数操作，显然是O(N)\r\n\r\n空间复杂度:\r\n\r\n除了result外，没有构建额外的数组，均在result原地操作，故O(1)\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838328793",
      "body": "#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 思路：\r\n\r\n暴力等等方法很简答，我们尝试双指针方法。\r\n构建result数组，由左向右遍历一遍，记录右边离你最近的c字符的距离，遍历 i 时可以利用已经完成的 i-1的结果。\r\n\r\n遍历完毕后，我们由右向左遍历，相当于比较左边和右边最近的c字符的距离哪个更小，取最小的来替代result[i]\r\n\r\n#### 代码 python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [math.inf] * len(s)\r\n        # 从左至右遍历一遍\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i > 0:\r\n                result[i] = result[i-1] + 1\r\n       \r\n        # 从右至左\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i < len(s)-1:\r\n                result[i] = min(result[i+1]+1, result[i])\r\n        return result\r\n```\r\n\r\n\r\n\r\n#### 复杂度分析:\r\n\r\n时间复杂度：\r\n\r\n两次遍历都是N次迭代，每次迭代都是常数操作，显然是O(N)\r\n\r\n空间复杂度:\r\n\r\n除了result外，没有构建额外的数组，均在result原地操作，故O(1)\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "yaofaqian": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838329911",
      "body": "## 思路\r\n双指针吧 从当前位置开始比对 然后往左偏移往比对往右偏移比对\r\n## 代码\r\n```\r\nSarr := []byte{}\r\n\tSP := []int{}\r\n\tfor _, v := range s {\r\n\t\tSarr = append(Sarr, byte(v))\r\n\t}\r\n\tfor i := 0; i < len(Sarr); i++ {\r\n\t\tstep := 0\r\n\r\n\t\tfor true {\r\n\t\t\tif i+step < len(Sarr) && Sarr[i+step] == c {\r\n\t\t\t\tSP = append(SP, step)\r\n\t\t\t\tstep = 1\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tif i-step >= 0 && Sarr[i-step] == c {\r\n\t\t\t\tSP = append(SP, step)\r\n\t\t\t\tstep = 1\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tstep++\r\n\t\t}\r\n\t}\r\n\treturn SP\r\n```\r\n## 复杂度\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度 O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838329911",
      "body": "## 思路\r\n双指针吧 从当前位置开始比对 然后往左偏移往比对往右偏移比对\r\n## 代码\r\n```\r\nSarr := []byte{}\r\n\tSP := []int{}\r\n\tfor _, v := range s {\r\n\t\tSarr = append(Sarr, byte(v))\r\n\t}\r\n\tfor i := 0; i < len(Sarr); i++ {\r\n\t\tstep := 0\r\n\r\n\t\tfor true {\r\n\t\t\tif i+step < len(Sarr) && Sarr[i+step] == c {\r\n\t\t\t\tSP = append(SP, step)\r\n\t\t\t\tstep = 1\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tif i-step >= 0 && Sarr[i-step] == c {\r\n\t\t\t\tSP = append(SP, step)\r\n\t\t\t\tstep = 1\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tstep++\r\n\t\t}\r\n\t}\r\n\treturn SP\r\n```\r\n## 复杂度\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度 O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "suukii": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838409646",
      "body": "# 821.字符的最短距离\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n- [821.字符的最短距离](#821字符的最短距离)\r\n  - [题目描述](#题目描述)\r\n  - [解法 1：中心扩展法](#解法-1中心扩展法)\r\n    - [思路](#思路)\r\n    - [复杂度分析](#复杂度分析)\r\n    - [代码 (JS/C++)](#代码-jsc)\r\n  - [解法 2：空间换时间](#解法-2空间换时间)\r\n    - [思路](#思路-1)\r\n    - [复杂度分析](#复杂度分析-1)\r\n    - [代码 (JS/C++)](#代码-jsc-1)\r\n  - [解法 3：贪心](#解法-3贪心)\r\n    - [思路](#思路-2)\r\n    - [复杂度分析](#复杂度分析-2)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython)\r\n  - [解法 4：窗口](#解法-4窗口)\r\n    - [思路](#思路-3)\r\n    - [复杂度分析](#复杂度分析-3)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython-1)\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n字符串 S 的长度范围为 [1, 10000]。\r\nC 是一个单字符，且保证是字符串 S 里的字符。\r\nS 和 C 中的所有字母均为小写字母。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 解法 1：中心扩展法\r\n\r\n### 思路\r\n\r\n这是最符合直觉的思路，对每个字符分别进行如下处理：\r\n\r\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 `C`。\r\n- 只在一个方向找到的话，直接计算字符距离。\r\n- 两个方向都找到的话，取两个距离的最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_0.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(0);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (S[i] === C) continue;\r\n\r\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (S[l] === C) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < S.length) {\r\n      if (S[r] === C) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        vector<int> res(S.length());\r\n\r\n        for (int i = 0; i < S.length(); i++) {\r\n            if (S[i] == C) continue;\r\n\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S[left] == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S[right] == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n\r\n            res[i] = dist;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 2：空间换时间\r\n\r\n### 思路\r\n\r\n空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。\r\n\r\n因为目标字符 `C` 在 `S` 中的位置是不变的，所以我们可以提前将 `C` 的所有下标记录在一个数组 `cIndices` 中。\r\n\r\n然后遍历字符串 `S` 中的每个字符，到 `cIndices` 中找到距离当前位置最近的下标，计算距离。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N*K)$，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，$K <= N$。\r\n- 空间复杂度：$O(K)$，K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 记录 C 字符在 S 字符串中出现的所有下标\r\n  var cIndices = [];\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) cIndices.push(i);\r\n  }\r\n\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(Infinity);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 目标字符，距离是 0\r\n    if (S[i] === C) {\r\n      res[i] = 0;\r\n      continue;\r\n    }\r\n\r\n    // 非目标字符，到下标数组中找最近的下标\r\n    for (const cIndex of cIndices) {\r\n      const dist = Math.abs(cIndex - i);\r\n\r\n      // 小小剪枝一下\r\n      // 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除\r\n      if (dist >= res[i]) break;\r\n\r\n      res[i] = dist;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> c_indices;\r\n        // Initialize a vector of size n with default value n.\r\n        vector<int> res(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) c_indices.push_back(i);\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) {\r\n                res[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            for (int j = 0; j < c_indices.size(); j++) {\r\n                int dist = abs(c_indices[j] - i);\r\n                if (dist > res[i]) break;\r\n                res[i] = dist;\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 3：贪心\r\n\r\n### 思路\r\n\r\n其实对于每个字符来说，它只关心离它最近的那个 `C` 字符，其他的它都不管。所以这里还可以用贪心的思路：\r\n\r\n1. 先 `从左往右` 遍历字符串 `S`，用一个数组 left 记录每个字符 `左侧` 出现的最后一个 `C` 字符的下标；\r\n2. 再 `从右往左` 遍历字符串 `S`，用一个数组 right 记录每个字符 `右侧` 出现的最后一个 `C` 字符的下标；\r\n3. 然后同时遍历这两个数组，计算距离最小值。\r\n\r\n**优化 1**\r\n\r\n再多想一步，其实第二个数组并不需要。因为对于左右两侧的 `C` 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：\r\n\r\n1. 字符左侧没有出现过 `C` 字符\r\n2. `i - left` > `right - i` (i 为当前字符下标，left 为字符左侧最近的 `C` 下标，right 为字符右侧最近的 `C` 下标)\r\n\r\n如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。\r\n\r\n**优化 2**\r\n\r\n如果我们是直接记录 `C` 与当前字符的距离，而不是记录 `C` 的下标，还可以省掉最后一次遍历计算距离的过程。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  // 第一次遍历：从左往右\r\n  // 找到出现在左侧的 C 字符的最后下标\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = i;\r\n    // 如果左侧没有出现 C 字符的话，用 Infinity 进行标记\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\r\n  }\r\n\r\n  // 第二次遍历：从右往左\r\n  // 找出现在右侧的 C 字符的最后下标\r\n  // 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\r\n  }\r\n\r\n  // 计算距离\r\n  for (let i = 0; i < res.length; i++) {\r\n    res[i] = Math.abs(res[i] - i);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n**直接计算距离：**\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = 0;\r\n    // 记录距离：res[i - 1] + 1\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\r\n  }\r\n\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    // 更新距离：res[i + 1] + 1\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> dist(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) dist[i] = 0;\r\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\r\n        }\r\n\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (dist[i] == n\r\n                || (i < n - 1 && dist[i + 1] + 1 < dist[i]))\r\n                    dist[i] = dist[i + 1] + 1;\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1, n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n - 2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n        return res\r\n```\r\n\r\n## 解法 4：窗口\r\n\r\n### 思路\r\n\r\n把 `C` 看成分界线，将 `S` 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_1.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\r\n  let l = S[0] === C ? 0 : Infinity,\r\n    // 窗口右边界\r\n    r = S.indexOf(C, 1);\r\n\r\n  const res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 计算字符到当前窗口左右边界的最小距离\r\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\r\n\r\n    // 遍历完了当前窗口的字符后，将整个窗口右移\r\n    if (i === r) {\r\n      l = r;\r\n      r = S.indexOf(C, l + 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n\r\n        int l = S[0] == C ? 0 : n;\r\n        int r = S.find(C, 1);\r\n\r\n        vector<int> dist(n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            dist[i] = min(abs(i - l), abs(r - i));\r\n            if (i == r) {\r\n                l = r;\r\n                r = S.find(C, r + 1);\r\n            }\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 for _ in range(n)]\r\n\r\n        l = 0 if s[0] == c else n\r\n        r = s.find(c, 1)\r\n\r\n        for i in range(n):\r\n            res[i] = min(abs(i - l), abs(r - i))\r\n            if i == r:\r\n                l = r\r\n                r = s.find(c, l + 1)\r\n        return res\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838409646",
      "body": "# 821.字符的最短距离\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n- [821.字符的最短距离](#821字符的最短距离)\r\n  - [题目描述](#题目描述)\r\n  - [解法 1：中心扩展法](#解法-1中心扩展法)\r\n    - [思路](#思路)\r\n    - [复杂度分析](#复杂度分析)\r\n    - [代码 (JS/C++)](#代码-jsc)\r\n  - [解法 2：空间换时间](#解法-2空间换时间)\r\n    - [思路](#思路-1)\r\n    - [复杂度分析](#复杂度分析-1)\r\n    - [代码 (JS/C++)](#代码-jsc-1)\r\n  - [解法 3：贪心](#解法-3贪心)\r\n    - [思路](#思路-2)\r\n    - [复杂度分析](#复杂度分析-2)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython)\r\n  - [解法 4：窗口](#解法-4窗口)\r\n    - [思路](#思路-3)\r\n    - [复杂度分析](#复杂度分析-3)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython-1)\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n字符串 S 的长度范围为 [1, 10000]。\r\nC 是一个单字符，且保证是字符串 S 里的字符。\r\nS 和 C 中的所有字母均为小写字母。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 解法 1：中心扩展法\r\n\r\n### 思路\r\n\r\n这是最符合直觉的思路，对每个字符分别进行如下处理：\r\n\r\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 `C`。\r\n- 只在一个方向找到的话，直接计算字符距离。\r\n- 两个方向都找到的话，取两个距离的最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_0.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(0);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (S[i] === C) continue;\r\n\r\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (S[l] === C) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < S.length) {\r\n      if (S[r] === C) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        vector<int> res(S.length());\r\n\r\n        for (int i = 0; i < S.length(); i++) {\r\n            if (S[i] == C) continue;\r\n\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S[left] == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S[right] == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n\r\n            res[i] = dist;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 2：空间换时间\r\n\r\n### 思路\r\n\r\n空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。\r\n\r\n因为目标字符 `C` 在 `S` 中的位置是不变的，所以我们可以提前将 `C` 的所有下标记录在一个数组 `cIndices` 中。\r\n\r\n然后遍历字符串 `S` 中的每个字符，到 `cIndices` 中找到距离当前位置最近的下标，计算距离。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N*K)$，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，$K <= N$。\r\n- 空间复杂度：$O(K)$，K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 记录 C 字符在 S 字符串中出现的所有下标\r\n  var cIndices = [];\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) cIndices.push(i);\r\n  }\r\n\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(Infinity);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 目标字符，距离是 0\r\n    if (S[i] === C) {\r\n      res[i] = 0;\r\n      continue;\r\n    }\r\n\r\n    // 非目标字符，到下标数组中找最近的下标\r\n    for (const cIndex of cIndices) {\r\n      const dist = Math.abs(cIndex - i);\r\n\r\n      // 小小剪枝一下\r\n      // 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除\r\n      if (dist >= res[i]) break;\r\n\r\n      res[i] = dist;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> c_indices;\r\n        // Initialize a vector of size n with default value n.\r\n        vector<int> res(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) c_indices.push_back(i);\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) {\r\n                res[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            for (int j = 0; j < c_indices.size(); j++) {\r\n                int dist = abs(c_indices[j] - i);\r\n                if (dist > res[i]) break;\r\n                res[i] = dist;\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 3：贪心\r\n\r\n### 思路\r\n\r\n其实对于每个字符来说，它只关心离它最近的那个 `C` 字符，其他的它都不管。所以这里还可以用贪心的思路：\r\n\r\n1. 先 `从左往右` 遍历字符串 `S`，用一个数组 left 记录每个字符 `左侧` 出现的最后一个 `C` 字符的下标；\r\n2. 再 `从右往左` 遍历字符串 `S`，用一个数组 right 记录每个字符 `右侧` 出现的最后一个 `C` 字符的下标；\r\n3. 然后同时遍历这两个数组，计算距离最小值。\r\n\r\n**优化 1**\r\n\r\n再多想一步，其实第二个数组并不需要。因为对于左右两侧的 `C` 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：\r\n\r\n1. 字符左侧没有出现过 `C` 字符\r\n2. `i - left` > `right - i` (i 为当前字符下标，left 为字符左侧最近的 `C` 下标，right 为字符右侧最近的 `C` 下标)\r\n\r\n如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。\r\n\r\n**优化 2**\r\n\r\n如果我们是直接记录 `C` 与当前字符的距离，而不是记录 `C` 的下标，还可以省掉最后一次遍历计算距离的过程。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  // 第一次遍历：从左往右\r\n  // 找到出现在左侧的 C 字符的最后下标\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = i;\r\n    // 如果左侧没有出现 C 字符的话，用 Infinity 进行标记\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\r\n  }\r\n\r\n  // 第二次遍历：从右往左\r\n  // 找出现在右侧的 C 字符的最后下标\r\n  // 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\r\n  }\r\n\r\n  // 计算距离\r\n  for (let i = 0; i < res.length; i++) {\r\n    res[i] = Math.abs(res[i] - i);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n**直接计算距离：**\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = 0;\r\n    // 记录距离：res[i - 1] + 1\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\r\n  }\r\n\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    // 更新距离：res[i + 1] + 1\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> dist(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) dist[i] = 0;\r\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\r\n        }\r\n\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (dist[i] == n\r\n                || (i < n - 1 && dist[i + 1] + 1 < dist[i]))\r\n                    dist[i] = dist[i + 1] + 1;\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1, n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n - 2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n        return res\r\n```\r\n\r\n## 解法 4：窗口\r\n\r\n### 思路\r\n\r\n把 `C` 看成分界线，将 `S` 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_1.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\r\n  let l = S[0] === C ? 0 : Infinity,\r\n    // 窗口右边界\r\n    r = S.indexOf(C, 1);\r\n\r\n  const res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 计算字符到当前窗口左右边界的最小距离\r\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\r\n\r\n    // 遍历完了当前窗口的字符后，将整个窗口右移\r\n    if (i === r) {\r\n      l = r;\r\n      r = S.indexOf(C, l + 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n\r\n        int l = S[0] == C ? 0 : n;\r\n        int r = S.find(C, 1);\r\n\r\n        vector<int> dist(n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            dist[i] = min(abs(i - l), abs(r - i));\r\n            if (i == r) {\r\n                l = r;\r\n                r = S.find(C, r + 1);\r\n            }\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 for _ in range(n)]\r\n\r\n        l = 0 if s[0] == c else n\r\n        r = s.find(c, 1)\r\n\r\n        for i in range(n):\r\n            res[i] = min(abs(i - l), abs(r - i))\r\n            if i == r:\r\n                l = r\r\n                r = s.find(c, l + 1)\r\n        return res\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "SWUFEzyf": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838418829",
      "body": "```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        result = [0] * n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n                continue\r\n            left = i-1\r\n            right = i + 1\r\n            while left >= 0 and s[left] != c:\r\n                left -= 1 \r\n            if left == -1:\r\n                left_distance = n\r\n            else:\r\n                left_distance = i - left\r\n            while right < n and s[right] != c:\r\n                right += 1\r\n            if right == n:\r\n                right_distance = n\r\n            else:\r\n                right_distance =  right - i\r\n            result[i] = min(left_distance, right_distance)\r\n        return result\r\n```\r\n复杂度分析\r\n时间复杂度：$O(N^2)$。\r\n空间复杂度：$O(N)$。"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838418829",
      "body": "```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        result = [0] * n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n                continue\r\n            left = i-1\r\n            right = i + 1\r\n            while left >= 0 and s[left] != c:\r\n                left -= 1 \r\n            if left == -1:\r\n                left_distance = n\r\n            else:\r\n                left_distance = i - left\r\n            while right < n and s[right] != c:\r\n                right += 1\r\n            if right == n:\r\n                right_distance = n\r\n            else:\r\n                right_distance =  right - i\r\n            result[i] = min(left_distance, right_distance)\r\n        return result\r\n```\r\n复杂度分析\r\n时间复杂度：$O(N^2)$。\r\n空间复杂度：$O(N)$。"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "shmilywh": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838419961",
      "body": "\r\n## 题目分析\r\n\r\n- 字符串长度大于等于1\r\n- 均为小写字母\r\n- c至少出现一次\r\n\r\n## 思路\r\n\r\n 1. **【双指针】找c的位置，分情况讨论**\r\n\r\n    根据c出现的次数不同，计算相对位置的方式也略有出入，给定两个元素，一个是要计算相对位置的a，另一个是目标字符c，二者之间的位置我们可以分三种情况考虑\r\n\r\n    1) c只出现一次，且a在c的两侧\r\n\r\n    这时的相对距离，毋庸置疑应该等于 abs(index(a) - index(c))\r\n\r\n    2) c出现两次，且a在两个c的中间\r\n\r\n    这时的相对距离，应该计算a到两个c的距离然后取较小值\r\n\r\n    3) c出现三次或三次以上，我们可以拆分成上述两种情况来分别计算\r\n\r\n    代码：\r\n\r\n    定义两个指针，移动策略如下\r\n\r\n    - 一开始两指针均指向字符串头部\r\n    - 右指针向前移动，直到遇见一个c，这时满足情况1\r\n    - 更新左指针为右指针，右指针继续向右移动，直到再遇到c（满足情况2）或者走到字符串尾部（满足情况1）\r\n\r\n    几点注意：\r\n\r\n    1. 计算距离的时机应该在右指针更新的时候，右指针第二次之后，直到走到尾部，都按第2种情况计算，右指针第一次更新或者走到尾部，按照第1中情况判断\r\n    2. 要考虑右指针指向尾部以及尾部字符恰好是c的情况，所以条件判断应该有**优先级**\r\n\r\n    执行用时：**40 ms**, 在所有 Python3 提交中击败了**93.41%**的用户\r\n\r\n    内存消耗：**14.9 MB**, 在所有 Python3 提交中击败了**66.05%**的用户\r\n\r\n    ```python\r\n    class Solution:\r\n        def shortestToChar(self, s: str, c: str) -> List[int]:\r\n            # 定义变量 left记录上一个c的位置，如果存在的话\r\n            left = right_cnt = 0\r\n            answer = [0]*len(s)\r\n\r\n            # 循环，找c，计算距离\r\n            for right in range(len(s)):   # 右指针从0遍历到len(s)-1\r\n                if s[right] == c:   # 如果右指针指向的字符是c，那么计算一次距离\r\n                    if not right_cnt:   # 如果右指针第一次更新，说明在c的一侧\r\n                        answer[left:right+1] = [abs(right-i) for i in range(left, right+1)]\r\n                    else:   # 如果右指针不是第一次更新，说明在两个c中间\r\n                        answer[left:right+1] = [min(abs(right-i), abs(i-left)) for i in range(left, right+1)]\r\n                    # 更新左指针以及出现c的次数\r\n                    left = right\r\n                    right_cnt += 1\r\n                else:\r\n                    # 注意这个条件判断要在else里面，以排除最后一个元素是c的情况\r\n                    if right == len(s)-1:\r\n                        answer[left:right+1] = [abs(left-i) for i in range(left, right+1)]\r\n            return answer\r\n    ```\r\n\r\n    复杂度分析\r\n\r\n    令n为字符串长度：\r\n\r\n    时间复杂度：O(N)，这里外层循环，快指针遍历了n次，然后内层，每次遇到一个c，就处理一部分，总的遍历次数也是n，相当于是2n，所示时间复杂度是O(N)\r\n\r\n    空间复杂度：O(1)(不考虑返回占用的空间)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838419961",
      "body": "\r\n## 题目分析\r\n\r\n- 字符串长度大于等于1\r\n- 均为小写字母\r\n- c至少出现一次\r\n\r\n## 思路\r\n\r\n 1. **【双指针】找c的位置，分情况讨论**\r\n\r\n    根据c出现的次数不同，计算相对位置的方式也略有出入，给定两个元素，一个是要计算相对位置的a，另一个是目标字符c，二者之间的位置我们可以分三种情况考虑\r\n\r\n    1) c只出现一次，且a在c的两侧\r\n\r\n    这时的相对距离，毋庸置疑应该等于 abs(index(a) - index(c))\r\n\r\n    2) c出现两次，且a在两个c的中间\r\n\r\n    这时的相对距离，应该计算a到两个c的距离然后取较小值\r\n\r\n    3) c出现三次或三次以上，我们可以拆分成上述两种情况来分别计算\r\n\r\n    代码：\r\n\r\n    定义两个指针，移动策略如下\r\n\r\n    - 一开始两指针均指向字符串头部\r\n    - 右指针向前移动，直到遇见一个c，这时满足情况1\r\n    - 更新左指针为右指针，右指针继续向右移动，直到再遇到c（满足情况2）或者走到字符串尾部（满足情况1）\r\n\r\n    几点注意：\r\n\r\n    1. 计算距离的时机应该在右指针更新的时候，右指针第二次之后，直到走到尾部，都按第2种情况计算，右指针第一次更新或者走到尾部，按照第1中情况判断\r\n    2. 要考虑右指针指向尾部以及尾部字符恰好是c的情况，所以条件判断应该有**优先级**\r\n\r\n    执行用时：**40 ms**, 在所有 Python3 提交中击败了**93.41%**的用户\r\n\r\n    内存消耗：**14.9 MB**, 在所有 Python3 提交中击败了**66.05%**的用户\r\n\r\n    ```python\r\n    class Solution:\r\n        def shortestToChar(self, s: str, c: str) -> List[int]:\r\n            # 定义变量 left记录上一个c的位置，如果存在的话\r\n            left = right_cnt = 0\r\n            answer = [0]*len(s)\r\n\r\n            # 循环，找c，计算距离\r\n            for right in range(len(s)):   # 右指针从0遍历到len(s)-1\r\n                if s[right] == c:   # 如果右指针指向的字符是c，那么计算一次距离\r\n                    if not right_cnt:   # 如果右指针第一次更新，说明在c的一侧\r\n                        answer[left:right+1] = [abs(right-i) for i in range(left, right+1)]\r\n                    else:   # 如果右指针不是第一次更新，说明在两个c中间\r\n                        answer[left:right+1] = [min(abs(right-i), abs(i-left)) for i in range(left, right+1)]\r\n                    # 更新左指针以及出现c的次数\r\n                    left = right\r\n                    right_cnt += 1\r\n                else:\r\n                    # 注意这个条件判断要在else里面，以排除最后一个元素是c的情况\r\n                    if right == len(s)-1:\r\n                        answer[left:right+1] = [abs(left-i) for i in range(left, right+1)]\r\n            return answer\r\n    ```\r\n\r\n    复杂度分析\r\n\r\n    令n为字符串长度：\r\n\r\n    时间复杂度：O(N)，这里外层循环，快指针遍历了n次，然后内层，每次遇到一个c，就处理一部分，总的遍历次数也是n，相当于是2n，所示时间复杂度是O(N)\r\n\r\n    空间复杂度：O(1)(不考虑返回占用的空间)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "LeahLuo0903": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838427280",
      "body": "```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        \r\n        int n = s.size();\r\n        vector<int> ans(s.size(), -n);\r\n            \r\n        int prev = -n;  \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = i - prev; \r\n        }\r\n        \r\n        // 不需要从最后开始遍历\r\n        // 从最后一次该字母出现处往前遍历\r\n        for (int i = prev - 1; i >= 0; i--) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = min(ans[i], prev - i); \r\n        } \r\n        return ans; \r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838427280",
      "body": "```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        \r\n        int n = s.size();\r\n        vector<int> ans(s.size(), -n);\r\n            \r\n        int prev = -n;  \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = i - prev; \r\n        }\r\n        \r\n        // 不需要从最后开始遍历\r\n        // 从最后一次该字母出现处往前遍历\r\n        for (int i = prev - 1; i >= 0; i--) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = min(ans[i], prev - i); \r\n        } \r\n        return ans; \r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "p76": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838435741",
      "body": "> ### 思路\r\n> 1.将字符串转成数组。\r\n2.遍历字符串数组，获取字符c在字符串数组中的坐标，生成坐标数组。\r\n3.再次遍历，获取字符串中其他字符与字符c的最近距离。\r\n \r\n> ### 代码\r\n``` \r\nvar shortestToChar = function (s, c) {\r\n    let sArr = s.split('');\r\n    let itemIndex = [];\r\n    let answerArr = [];\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        if (sArr[i] === c) {\r\n            itemIndex.push(i);\r\n        }\r\n    }\r\n    for (let n = 0; n < sArr.length; n++) {\r\n        if (sArr[n] === c) {\r\n            answerArr.push(0);\r\n        } else {\r\n            let idx = sArr.length;\r\n            for (let j = 0; j < itemIndex.length; j++) {\r\n                let countNum = Math.abs(n - itemIndex[j]);\r\n                if (idx > countNum) {\r\n                    idx = countNum;\r\n                }\r\n            }\r\n            answerArr.push(idx);\r\n        }\r\n    }\r\n    return answerArr;\r\n};\r\n```\r\n> ### 复杂度\r\n时间复杂度O(n);\r\n空间复杂度O(1);"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838435741",
      "body": "> ### 思路\r\n> 1.将字符串转成数组。\r\n2.遍历字符串数组，获取字符c在字符串数组中的坐标，生成坐标数组。\r\n3.再次遍历，获取字符串中其他字符与字符c的最近距离。\r\n \r\n> ### 代码\r\n``` \r\nvar shortestToChar = function (s, c) {\r\n    let sArr = s.split('');\r\n    let itemIndex = [];\r\n    let answerArr = [];\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        if (sArr[i] === c) {\r\n            itemIndex.push(i);\r\n        }\r\n    }\r\n    for (let n = 0; n < sArr.length; n++) {\r\n        if (sArr[n] === c) {\r\n            answerArr.push(0);\r\n        } else {\r\n            let idx = sArr.length;\r\n            for (let j = 0; j < itemIndex.length; j++) {\r\n                let countNum = Math.abs(n - itemIndex[j]);\r\n                if (idx > countNum) {\r\n                    idx = countNum;\r\n                }\r\n            }\r\n            answerArr.push(idx);\r\n        }\r\n    }\r\n    return answerArr;\r\n};\r\n```\r\n> ### 复杂度\r\n时间复杂度O(n);\r\n空间复杂度O(1);"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Ben-Lee95": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838512853",
      "body": "> # 821. 字符的最短距离\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历(正向遍历和反向遍历)\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n> \r\n> 示例 1:\r\n> \r\n> 输入: S = \"loveleetcode\", C = 'e'\r\n> 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n> 说明:\r\n> \r\n> - 字符串 S 的长度范围为 [1, 10000]。\r\n> - C 是一个单字符，且保证是字符串 S 里的字符。\r\n> - S 和 C 中的所有字母均为小写字母。\r\n> ```\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n## 关键点\r\n\r\n-  从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\r\n从右向左遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\r\n这两个值取最小就是答案。\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N = s.length();\r\n        int[] ans = new int[N];\r\n        int prev = -10000;\r\n        \r\n        //从左往右遍历数组\r\n        for(int i = 0; i < N; ++i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 20000;\r\n        //从右往左遍历数组\r\n        for(int i = N-1; i >= 0; --i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838512853",
      "body": "> # 821. 字符的最短距离\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历(正向遍历和反向遍历)\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n> \r\n> 示例 1:\r\n> \r\n> 输入: S = \"loveleetcode\", C = 'e'\r\n> 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n> 说明:\r\n> \r\n> - 字符串 S 的长度范围为 [1, 10000]。\r\n> - C 是一个单字符，且保证是字符串 S 里的字符。\r\n> - S 和 C 中的所有字母均为小写字母。\r\n> ```\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n## 关键点\r\n\r\n-  从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\r\n从右向左遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\r\n这两个值取最小就是答案。\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N = s.length();\r\n        int[] ans = new int[N];\r\n        int prev = -10000;\r\n        \r\n        //从左往右遍历数组\r\n        for(int i = 0; i < N; ++i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 20000;\r\n        //从右往左遍历数组\r\n        for(int i = N-1; i >= 0; --i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "RMsboy": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838529779",
      "body": "**思路**\r\n维护一个数组获取c在s中的下标\r\n使用reduce方法对计算最近距离\r\n\r\n**代码**\r\n语言支持：JavaScript\r\nJavaScript Code:\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let resArr = new Array(s.length)\r\n    let temArr = []\r\n    // 包含c字符下标的数组\r\n    for(let i = 0; i < s.length; i++){\r\n        if(s[i] === c){\r\n            temArr.push(i)\r\n        }\r\n    }\r\n    // 使用reduce获取字符串与指定字符串的最短距离\r\n    for(let i = 0; i < s.length; i++){\r\n        resArr[i] = temArr.reduce((value, item) => {\r\n            return Math.min(value, Math.abs(item - i))\r\n        }, 10000)\r\n    }\r\n    return resArr\r\n}\r\n```\r\n\r\n**复杂度分析**\r\nn为s的长度，m为c在s中的重复次数\r\n\r\n时间复杂度：O(mn) \r\n空间复杂度：O(mn)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838529779",
      "body": "**思路**\r\n维护一个数组获取c在s中的下标\r\n使用reduce方法对计算最近距离\r\n\r\n**代码**\r\n语言支持：JavaScript\r\nJavaScript Code:\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let resArr = new Array(s.length)\r\n    let temArr = []\r\n    // 包含c字符下标的数组\r\n    for(let i = 0; i < s.length; i++){\r\n        if(s[i] === c){\r\n            temArr.push(i)\r\n        }\r\n    }\r\n    // 使用reduce获取字符串与指定字符串的最短距离\r\n    for(let i = 0; i < s.length; i++){\r\n        resArr[i] = temArr.reduce((value, item) => {\r\n            return Math.min(value, Math.abs(item - i))\r\n        }, 10000)\r\n    }\r\n    return resArr\r\n}\r\n```\r\n\r\n**复杂度分析**\r\nn为s的长度，m为c在s中的重复次数\r\n\r\n时间复杂度：O(mn) \r\n空间复杂度：O(mn)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "XiaoY0324": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838586771",
      "body": "```js\r\n// 每个元素往两边扫描 取最小值\r\nvar shortestToChar = function(s, c) {\r\n  let stringArr = s.split('');\r\n  let res = [];\r\n  let startIdx = 0; // 起始扫描下标\r\n  \r\n  // 递归开始\r\n  findMinIdx(startIdx, stringArr, c, res);\r\n\r\n  // 结果返回\r\n  return res;\r\n};\r\n\r\nconsole.log(\"baaa\", \"b\");\r\nvar findMinIdx = function(startIdx, stringArr, c, res) {\r\n  // 递归终止条件\r\n  if (res.length == stringArr.length) return;\r\n\r\n  let total;\r\n\r\n  for (let i = startIdx; i < stringArr.length; i++) { // 往右扫\r\n    console.warn(`正向扫startIdx: ${ startIdx }`, `i: ${ i }`);\r\n    if (stringArr[i] == c) {\r\n      let curIdx = Math.abs(i - startIdx);\r\n      total = curIdx; // 移动差值\r\n      break;\r\n    }\r\n  }\r\n\r\n  for (let j = startIdx; j >= 0 ; j--) { // 往左扫 注意 j 为 0 也要扫 扫的是 0 位置的元素 比如 'baaa' 和 'b'，0 位置相等。\r\n    console.error(`反向扫startIdx: ${ startIdx }`, `j: ${ j }`);\r\n    if (stringArr[j] == c) {\r\n      console.error(j, '------------');\r\n      let curIdx = Math.abs(j - startIdx);\r\n      \r\n      if (total) {\r\n        total = total > curIdx ? curIdx : total; // 最小移动差值\r\n      } else { // 如果上一个往右扫没有满足条件，这里 total 就为 undefined，做下兼容。\r\n        total = curIdx;\r\n      }\r\n      \r\n      break;\r\n    }\r\n  }\r\n\r\n  res.push(total);\r\n  return findMinIdx(startIdx + 1, stringArr, c, res);\r\n}\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838586771",
      "body": "```js\r\n// 每个元素往两边扫描 取最小值\r\nvar shortestToChar = function(s, c) {\r\n  let stringArr = s.split('');\r\n  let res = [];\r\n  let startIdx = 0; // 起始扫描下标\r\n  \r\n  // 递归开始\r\n  findMinIdx(startIdx, stringArr, c, res);\r\n\r\n  // 结果返回\r\n  return res;\r\n};\r\n\r\nconsole.log(\"baaa\", \"b\");\r\nvar findMinIdx = function(startIdx, stringArr, c, res) {\r\n  // 递归终止条件\r\n  if (res.length == stringArr.length) return;\r\n\r\n  let total;\r\n\r\n  for (let i = startIdx; i < stringArr.length; i++) { // 往右扫\r\n    console.warn(`正向扫startIdx: ${ startIdx }`, `i: ${ i }`);\r\n    if (stringArr[i] == c) {\r\n      let curIdx = Math.abs(i - startIdx);\r\n      total = curIdx; // 移动差值\r\n      break;\r\n    }\r\n  }\r\n\r\n  for (let j = startIdx; j >= 0 ; j--) { // 往左扫 注意 j 为 0 也要扫 扫的是 0 位置的元素 比如 'baaa' 和 'b'，0 位置相等。\r\n    console.error(`反向扫startIdx: ${ startIdx }`, `j: ${ j }`);\r\n    if (stringArr[j] == c) {\r\n      console.error(j, '------------');\r\n      let curIdx = Math.abs(j - startIdx);\r\n      \r\n      if (total) {\r\n        total = total > curIdx ? curIdx : total; // 最小移动差值\r\n      } else { // 如果上一个往右扫没有满足条件，这里 total 就为 undefined，做下兼容。\r\n        total = curIdx;\r\n      }\r\n      \r\n      break;\r\n    }\r\n  }\r\n\r\n  res.push(total);\r\n  return findMinIdx(startIdx + 1, stringArr, c, res);\r\n}\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "breadfruit": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838590094",
      "body": "## 思路\r\n遍历当前数组，分别从两边开始寻找，知道两边分别找到指定字符，然后取最小值加入结果数组。\r\n## 代码\r\n语言支持：Python3\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r =i\r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            if l == -1: l = -10000\r\n            if r == len(s): r = 20000\r\n            ans.append(min(r-i,i-l))\r\n        return ans\r\n```\r\n## 复杂度\r\n- 时间复杂度：O(N^2)\r\n- 空间复杂度：O(1)\r\n题目的数据范围是 10000，所以 [-10000,20000]"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838590094",
      "body": "## 思路\r\n遍历当前数组，分别从两边开始寻找，知道两边分别找到指定字符，然后取最小值加入结果数组。\r\n## 代码\r\n语言支持：Python3\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r =i\r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            if l == -1: l = -10000\r\n            if r == len(s): r = 20000\r\n            ans.append(min(r-i,i-l))\r\n        return ans\r\n```\r\n## 复杂度\r\n- 时间复杂度：O(N^2)\r\n- 空间复杂度：O(1)\r\n题目的数据范围是 10000，所以 [-10000,20000]"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "luoluomo": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597001",
      "body": "# 思路\r\n  正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n  实现时下面的边界条件，容易出现问题\r\n  let lastC = Number.MIN_SAFE_INTEGER;\r\n  lastC = Number.MAX_SAFE_INTEGER;\r\n# 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const number = new Array(s.length).fill(Number.MAX_SAFE_INTEGER);\r\n    const strs = s.split(\"\");\r\n    let lastC = Number.MIN_SAFE_INTEGER;\r\n    strs.forEach((item, index) => {\r\n        if(item === c){\r\n            number[index] = 0;\r\n            lastC = index;\r\n        }else{\r\n            number[index] = index - lastC;\r\n        }\r\n    })\r\n    lastC = Number.MAX_SAFE_INTEGER;\r\n    for(let i = strs.length - 1; i >= 0; i--){\r\n        if(strs[i] === c){\r\n            number[i] = 0;\r\n            lastC = i;\r\n        }else{\r\n            number[i] = Math.min(number[i], lastC - i);\r\n        }\r\n    }\r\n\r\n    return number;\r\n};\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597001",
      "body": "# 思路\r\n  正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n  实现时下面的边界条件，容易出现问题\r\n  let lastC = Number.MIN_SAFE_INTEGER;\r\n  lastC = Number.MAX_SAFE_INTEGER;\r\n# 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const number = new Array(s.length).fill(Number.MAX_SAFE_INTEGER);\r\n    const strs = s.split(\"\");\r\n    let lastC = Number.MIN_SAFE_INTEGER;\r\n    strs.forEach((item, index) => {\r\n        if(item === c){\r\n            number[index] = 0;\r\n            lastC = index;\r\n        }else{\r\n            number[index] = index - lastC;\r\n        }\r\n    })\r\n    lastC = Number.MAX_SAFE_INTEGER;\r\n    for(let i = strs.length - 1; i >= 0; i--){\r\n        if(strs[i] === c){\r\n            number[i] = 0;\r\n            lastC = i;\r\n        }else{\r\n            number[i] = Math.min(number[i], lastC - i);\r\n        }\r\n    }\r\n\r\n    return number;\r\n};\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "QiuhaoLi": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597599",
      "body": "## 思路\r\n\r\n使用双指针，分别指向匹配字符。从左向右扫描并更新距离，当发现新的匹配字符更新第二个指针时，进行回溯更新距离（与第一个指针间一半的字符需要更新）。\r\n\r\n要考虑到可能只有一个匹配字符（第二个指针为空）。\r\n\r\n## 代码\r\n\r\n```c\r\n/**\r\n * Note: The returned array must be malloced, assume caller calls free().\r\n */\r\nint* shortestToChar(char * s, char c, int* returnSize){\r\n    size_t string_size = strlen(s);\r\n    *returnSize = string_size;\r\n    if (string_size == 0)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    int *distance = malloc(string_size * sizeof(int));\r\n    //error handling\r\n\r\n    long index_c_first = -1;\r\n    long index_c_second = -1;\r\n\r\n    for (long i = 0; i < string_size; ++i)\r\n    {\r\n        if (s[i] == c)\r\n        {\r\n            if (index_c_first == -1)\r\n            {\r\n                index_c_first = i;\r\n                for (long j = index_c_first; j >=0; --j)\r\n                {\r\n                    distance[j] = index_c_first-j;\r\n                }\r\n            }\r\n            else if (index_c_second == -1)\r\n            {\r\n                index_c_second = i;\r\n                for (long j = index_c_second; j > (index_c_second+index_c_first)/2; --j)\r\n                {\r\n                    distance[j] = index_c_second-j;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                long tmp = index_c_second;\r\n                index_c_second = i;\r\n                index_c_first = tmp;\r\n                for (long j = index_c_second; j > (index_c_second+index_c_first)/2; --j)\r\n                {\r\n                    distance[j] = index_c_second-j;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            long index_c = index_c_second == -1 ? index_c_first : index_c_second;\r\n            if (index_c != -1)\r\n            {\r\n                distance[i] = i - index_c;\r\n            }\r\n        }\r\n    }\r\n\r\n    return distance;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间：O(n)\r\n空间：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597599",
      "body": "## 思路\r\n\r\n使用双指针，分别指向匹配字符。从左向右扫描并更新距离，当发现新的匹配字符更新第二个指针时，进行回溯更新距离（与第一个指针间一半的字符需要更新）。\r\n\r\n要考虑到可能只有一个匹配字符（第二个指针为空）。\r\n\r\n## 代码\r\n\r\n```c\r\n/**\r\n * Note: The returned array must be malloced, assume caller calls free().\r\n */\r\nint* shortestToChar(char * s, char c, int* returnSize){\r\n    size_t string_size = strlen(s);\r\n    *returnSize = string_size;\r\n    if (string_size == 0)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    int *distance = malloc(string_size * sizeof(int));\r\n    //error handling\r\n\r\n    long index_c_first = -1;\r\n    long index_c_second = -1;\r\n\r\n    for (long i = 0; i < string_size; ++i)\r\n    {\r\n        if (s[i] == c)\r\n        {\r\n            if (index_c_first == -1)\r\n            {\r\n                index_c_first = i;\r\n                for (long j = index_c_first; j >=0; --j)\r\n                {\r\n                    distance[j] = index_c_first-j;\r\n                }\r\n            }\r\n            else if (index_c_second == -1)\r\n            {\r\n                index_c_second = i;\r\n                for (long j = index_c_second; j > (index_c_second+index_c_first)/2; --j)\r\n                {\r\n                    distance[j] = index_c_second-j;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                long tmp = index_c_second;\r\n                index_c_second = i;\r\n                index_c_first = tmp;\r\n                for (long j = index_c_second; j > (index_c_second+index_c_first)/2; --j)\r\n                {\r\n                    distance[j] = index_c_second-j;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            long index_c = index_c_second == -1 ? index_c_first : index_c_second;\r\n            if (index_c != -1)\r\n            {\r\n                distance[i] = i - index_c;\r\n            }\r\n        }\r\n    }\r\n\r\n    return distance;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间：O(n)\r\n空间：O(1)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "zfaye": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838600080",
      "body": "**思路**：[indexOf](int ch）[indexOf](int ch,  int fromIndex)获取前后两个指针，取小的绝对距离\r\n\r\n代码：\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        //int[] index=new int[s.length()];\r\n        int cur=s.indexOf(c);int pre=cur;\r\n       // Iterator<Integer> it=index.iterator();\r\n        int[] ans=new int[s.length()];\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)== c) {\r\n               ans[i]=0;\r\n               pre=i;\r\n               cur=s.indexOf(c,i+1);\r\n            }else{\r\n                ans[i]=Math.min(Math.abs(i-pre),Math.abs(cur-i));\r\n             }\r\n\r\n\r\n        }\r\n\r\n\r\n    return ans;\r\n\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)?"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838600080",
      "body": "**思路**：[indexOf](int ch）[indexOf](int ch,  int fromIndex)获取前后两个指针，取小的绝对距离\r\n\r\n代码：\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        //int[] index=new int[s.length()];\r\n        int cur=s.indexOf(c);int pre=cur;\r\n       // Iterator<Integer> it=index.iterator();\r\n        int[] ans=new int[s.length()];\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)== c) {\r\n               ans[i]=0;\r\n               pre=i;\r\n               cur=s.indexOf(c,i+1);\r\n            }else{\r\n                ans[i]=Math.min(Math.abs(i-pre),Math.abs(cur-i));\r\n             }\r\n\r\n\r\n        }\r\n\r\n\r\n    return ans;\r\n\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)?"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "winterdogdog": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838615479",
      "body": "```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let array = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        array[i] = s.length;\r\n    }\r\n    for (let i = 0; i < s.length; i++){\r\n        if ( s.substring(i, i+1) === c){\r\n            for (let j = 0; j < s.length; j++){\r\n                array[j] = Math.min(Math.abs(i - j),array[j])\r\n            }\r\n        }\r\n    }\r\n    return array;\r\n};\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838615479",
      "body": "```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let array = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        array[i] = s.length;\r\n    }\r\n    for (let i = 0; i < s.length; i++){\r\n        if ( s.substring(i, i+1) === c){\r\n            for (let j = 0; j < s.length; j++){\r\n                array[j] = Math.min(Math.abs(i - j),array[j])\r\n            }\r\n        }\r\n    }\r\n    return array;\r\n};\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "NealChristmas": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838633616",
      "body": "```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    const stackRight = []\r\n    const stackLeft = []\r\n    for (let i = 0; i < s.length; i++) {\r\n        const char = s[i]\r\n        if (char === c) {\r\n            stackRight.unshift(i)\r\n        }\r\n    }\r\n    let i = 0\r\n    const res = []\r\n    while (i < s.length) {\r\n        let topRight = stackRight[stackRight.length - 1]\r\n        if (topRight !== undefined && i > topRight) {\r\n            stackLeft.push(stackRight.pop())\r\n        }\r\n        topRight = stackRight[stackRight.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackRight[stackRight.length - 1]\r\n        let topLeft = stackLeft[stackLeft.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackLeft[stackLeft.length - 1]\r\n        const minDis = Math.min(Math.abs(i - topLeft), Math.abs(i - topRight))\r\n        i++\r\n        res.push(minDis)\r\n    }\r\n    return res\r\n};\r\n```"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838633616",
      "body": "```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    const stackRight = []\r\n    const stackLeft = []\r\n    for (let i = 0; i < s.length; i++) {\r\n        const char = s[i]\r\n        if (char === c) {\r\n            stackRight.unshift(i)\r\n        }\r\n    }\r\n    let i = 0\r\n    const res = []\r\n    while (i < s.length) {\r\n        let topRight = stackRight[stackRight.length - 1]\r\n        if (topRight !== undefined && i > topRight) {\r\n            stackLeft.push(stackRight.pop())\r\n        }\r\n        topRight = stackRight[stackRight.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackRight[stackRight.length - 1]\r\n        let topLeft = stackLeft[stackLeft.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackLeft[stackLeft.length - 1]\r\n        const minDis = Math.min(Math.abs(i - topLeft), Math.abs(i - topRight))\r\n        i++\r\n        res.push(minDis)\r\n    }\r\n    return res\r\n};\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "raoshuang": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838653080",
      "body": "- 暴力解法：遍历找出c字符的所有下标，然后找再次遍历找出最小值\r\n-class Solution {\r\npublic:\r\n    vector<int> s1;\r\n    vector<int> s2;\r\n   \r\n    vector<int> shortestToChar(string s, char c) {\r\n    for(int i=0;i<s.length();++i){\r\n        if(s[i] == c){\r\n            s1.push_back(i);\r\n        }\r\n    } \r\n    \r\n    for(int i=0;i<s.length();++i){\r\n        int len=s.length(),minlen=s.length();\r\n        for(int j=0;j<s1.size();++j){\r\n            len = abs(s1[j]-i);\r\n            minlen = min(len,minlen);\r\n        }\r\n        s2.push_back(minlen);\r\n\r\n    }\r\n    return s2;\r\n    }\r\n};"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838653080",
      "body": "- 暴力解法：遍历找出c字符的所有下标，然后找再次遍历找出最小值\r\n-class Solution {\r\npublic:\r\n    vector<int> s1;\r\n    vector<int> s2;\r\n   \r\n    vector<int> shortestToChar(string s, char c) {\r\n    for(int i=0;i<s.length();++i){\r\n        if(s[i] == c){\r\n            s1.push_back(i);\r\n        }\r\n    } \r\n    \r\n    for(int i=0;i<s.length();++i){\r\n        int len=s.length(),minlen=s.length();\r\n        for(int j=0;j<s1.size();++j){\r\n            len = abs(s1[j]-i);\r\n            minlen = min(len,minlen);\r\n        }\r\n        s2.push_back(minlen);\r\n\r\n    }\r\n    return s2;\r\n    }\r\n};"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "xiaoyuhai": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838666444",
      "body": "/**\r\n* 找出左右两边距离最近的，再取其中最小的\r\n*/ \r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] result = new int[s.length()];\r\n        int pre = -2000;\r\n        for(int i =0; i < s.length(); i++){\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            result[i] = i - pre;\r\n        }\r\n        pre = 2000;\r\n        for(int i = s.length() -1 ; i >=0; i--){\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            result[i] = Math.min(result[i],pre-i);\r\n        }\r\n        return result;\r\n    }"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838666444",
      "body": "/**\r\n* 找出左右两边距离最近的，再取其中最小的\r\n*/ \r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] result = new int[s.length()];\r\n        int pre = -2000;\r\n        for(int i =0; i < s.length(); i++){\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            result[i] = i - pre;\r\n        }\r\n        pre = 2000;\r\n        for(int i = s.length() -1 ; i >=0; i--){\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            result[i] = Math.min(result[i],pre-i);\r\n        }\r\n        return result;\r\n    }"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "mayu0007": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838671847",
      "body": "### 思路\r\n\r\n参考了参考答案的动态规划。\r\n双次遍历数组 \r\n- dp数组状态量：与上一个c的距离\r\n\r\n  左遍历\r\n    - 状态转移方程：```dp[i] = dp[i-1] + 1 ```\r\n    - 边界条件：```if s[i] == c: dp[i] = 0 ```\r\n\r\n  右遍历\r\n    - 状态转移方程：```dp[i] = min(dp[i+1] + 1, dp[i]) ```\r\n    - 边界条件：```if s[i] == c: dp[i] = 0 ```\r\n\r\n### caveat\r\n不要忘记check index的范围\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        # traverse 2 times \r\n        # left to right: each element store distance to the nearest C met before (on the LEFT).\r\n        # right to left: each element store the distance to the nearest C on the RIGHT. \r\n        # compare the value of both. \r\n        # initialize array with inf\r\n        \"\"\"\r\n        # 参考答案的prev initialization有点难理解\r\n        result = []\r\n        prev = -float('inf')\r\n        for i, elem in enumerate(s):\r\n            if elem == c:\r\n                prev = i \r\n            result[i] = i - prev \r\n\r\n        prev = float('inf')\r\n        for i in range(len(s)-1,0,-1):\r\n            if s[i] == c:\r\n                prev = i \r\n            result[i] = min(prev-i, result[i])\r\n        return result\r\n        \"\"\"\r\n        dp = [float('inf')]*len(s) # float('inf') is a number bigger than all others \r\n        \"\"\"\r\n        num = float('inf')\r\n        print(num > 1000) #True\r\n        print(num + 1 == num) #True \r\n        print(num-1) #inf\r\n        \"\"\"\r\n        for i, elem in enumerate(s):\r\n            if elem == c:\r\n                dp[i] = 0 \r\n            elif i > 0: #index range checking\r\n                dp[i] = dp[i-1] + 1\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                dp[i] = 0 \r\n            elif i < len(s)-1: #index range checking\r\n                dp[i] = min(dp[i+1] + 1, dp[i])\r\n                \r\n        return dp\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，N 为数组`s`的长度，两次遍历\r\n- 空间复杂度：O(N), N 为数组`s`的长度，也是返回值\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838671847",
      "body": "### 思路\r\n\r\n参考了参考答案的动态规划。\r\n双次遍历数组 \r\n- dp数组状态量：与上一个c的距离\r\n\r\n  左遍历\r\n    - 状态转移方程：```dp[i] = dp[i-1] + 1 ```\r\n    - 边界条件：```if s[i] == c: dp[i] = 0 ```\r\n\r\n  右遍历\r\n    - 状态转移方程：```dp[i] = min(dp[i+1] + 1, dp[i]) ```\r\n    - 边界条件：```if s[i] == c: dp[i] = 0 ```\r\n\r\n### caveat\r\n不要忘记check index的范围\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        # traverse 2 times \r\n        # left to right: each element store distance to the nearest C met before (on the LEFT).\r\n        # right to left: each element store the distance to the nearest C on the RIGHT. \r\n        # compare the value of both. \r\n        # initialize array with inf\r\n        \"\"\"\r\n        # 参考答案的prev initialization有点难理解\r\n        result = []\r\n        prev = -float('inf')\r\n        for i, elem in enumerate(s):\r\n            if elem == c:\r\n                prev = i \r\n            result[i] = i - prev \r\n\r\n        prev = float('inf')\r\n        for i in range(len(s)-1,0,-1):\r\n            if s[i] == c:\r\n                prev = i \r\n            result[i] = min(prev-i, result[i])\r\n        return result\r\n        \"\"\"\r\n        dp = [float('inf')]*len(s) # float('inf') is a number bigger than all others \r\n        \"\"\"\r\n        num = float('inf')\r\n        print(num > 1000) #True\r\n        print(num + 1 == num) #True \r\n        print(num-1) #inf\r\n        \"\"\"\r\n        for i, elem in enumerate(s):\r\n            if elem == c:\r\n                dp[i] = 0 \r\n            elif i > 0: #index range checking\r\n                dp[i] = dp[i-1] + 1\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                dp[i] = 0 \r\n            elif i < len(s)-1: #index range checking\r\n                dp[i] = min(dp[i+1] + 1, dp[i])\r\n                \r\n        return dp\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，N 为数组`s`的长度，两次遍历\r\n- 空间复杂度：O(N), N 为数组`s`的长度，也是返回值\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "liuajingliu": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838700474",
      "body": "### 思路分析\r\n1. 遍历两次字符串， 一次从左到右遍历，一次从右到左遍历\r\n2. 两次遍历分别记录s[i]对 c 的距离\r\n3. 两者比较, 保留较小值\r\n\r\n\r\n### 代码实现 JavaScript\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] === c) res[i] = 0;\r\n    else res[i] = i == 0 ? Infinity : res[i - 1] + 1\r\n  }\r\n\r\n  for(let i = s.length - 1; i >= 0; i--){\r\n    if(res[i] == Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：$O(N)$, N为字符串长度\r\n- 空间复杂度：$O(1)$\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838700474",
      "body": "### 思路分析\r\n1. 遍历两次字符串， 一次从左到右遍历，一次从右到左遍历\r\n2. 两次遍历分别记录s[i]对 c 的距离\r\n3. 两者比较, 保留较小值\r\n\r\n\r\n### 代码实现 JavaScript\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] === c) res[i] = 0;\r\n    else res[i] = i == 0 ? Infinity : res[i - 1] + 1\r\n  }\r\n\r\n  for(let i = s.length - 1; i >= 0; i--){\r\n    if(res[i] == Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：$O(N)$, N为字符串长度\r\n- 空间复杂度：$O(1)$\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "AutumnDeSea": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838712904",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 数组和字符串的内存管理\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 数组的正向、反向遍历，是一道简单的左右指针的题目\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    // 字符串转数组的逻辑\r\n    // 数组的正向、反向遍历\r\n    sArr = s.split('')\r\n    const sLen = sArr.length\r\n    let arr = []\r\n    \r\n    for(var i = 0; i< sArr.length ; i++) {\r\n        var s = sArr[i]\r\n        var l = r = i\r\n          // 向左遍历\r\n        while(l > -1) {\r\n            if(sArr[l] == c) {\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        // 像右遍历\r\n        while(r <  sLen) {\r\n            if(sArr[r] == c) {\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        if(l === -1) {\r\n            l = -10000\r\n        }\r\n        if(r === sLen) {\r\n            r = 20000\r\n        }\r\n        var result = Math.min(r-i, i-l)\r\n        arr.push(result)\r\n    }\r\n    return arr\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838712904",
      "body": "\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 数组和字符串的内存管理\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 数组的正向、反向遍历，是一道简单的左右指针的题目\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    // 字符串转数组的逻辑\r\n    // 数组的正向、反向遍历\r\n    sArr = s.split('')\r\n    const sLen = sArr.length\r\n    let arr = []\r\n    \r\n    for(var i = 0; i< sArr.length ; i++) {\r\n        var s = sArr[i]\r\n        var l = r = i\r\n          // 向左遍历\r\n        while(l > -1) {\r\n            if(sArr[l] == c) {\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        // 像右遍历\r\n        while(r <  sLen) {\r\n            if(sArr[r] == c) {\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        if(l === -1) {\r\n            l = -10000\r\n        }\r\n        if(r === sLen) {\r\n            r = 20000\r\n        }\r\n        var result = Math.min(r-i, i-l)\r\n        arr.push(result)\r\n    }\r\n    return arr\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "cyaoyao": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838716666",
      "body": "### 思路分析\r\n中心扩展，每遍历一个元素时候，便向两边扩展，取最小值即可\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n);\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c)\r\n                continue;\r\n            int l = i;\r\n            int r = i;\r\n            int len = 0;\r\n            \r\n            while (l >= 0 || r < n) {\r\n                if (s[l] == c) {\r\n                    len = i - l;\r\n                    break;\r\n                }\r\n                if (s[r] == c) {\r\n                    len = r - i;\r\n                    break;\r\n                }\r\n\r\n                if (l > 0) l--;\r\n                if (r < n) r++;\r\n            }\r\n            res[i] = len;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度\r\n+ 时间复杂度$O(N^2)$\r\n+ 空间复杂度$O(1)\r\n"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838716666",
      "body": "### 思路分析\r\n中心扩展，每遍历一个元素时候，便向两边扩展，取最小值即可\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n);\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c)\r\n                continue;\r\n            int l = i;\r\n            int r = i;\r\n            int len = 0;\r\n            \r\n            while (l >= 0 || r < n) {\r\n                if (s[l] == c) {\r\n                    len = i - l;\r\n                    break;\r\n                }\r\n                if (s[r] == c) {\r\n                    len = r - i;\r\n                    break;\r\n                }\r\n\r\n                if (l > 0) l--;\r\n                if (r < n) r++;\r\n            }\r\n            res[i] = len;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度\r\n+ 时间复杂度$O(N^2)$\r\n+ 空间复杂度$O(1)\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "mm12344": [
    null,
    {
      "title": "821. 字符的最短距离",
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838739105",
      "body": "### 思路\r\n\r\n1. 第一遍正序遍历，遇非e保留序号，遇e存储索引进pre变量，再遇e则更新其索引。返回当前非e数到左边e的距离\r\n2. 第二遍倒序遍历，同上，返回当前非e数到右边e的距离\r\n3. 两者比大小，返回最小值\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -10000\r\n        ans = []\r\n\r\n        for i in range(len(S)):\r\n            if S[i] == C: pre = i\r\n            ans.append(i - pre)\r\n        pre = 20000\r\n        for i in range(len(S) - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            ans[i] = min(ans[i], pre - i)\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(1)"
    },
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839716817",
      "body": "### 思路\r\n\r\n给定一个变量来记录栈顶的位置，更新数据来模拟栈的操作，但因为实质是函数内的数组，所以可以实现对除了栈顶元素外的改动。（后续再优化）\r\n\r\n### 代码\r\n\r\n\r\n```py3\r\nclass CustomStack:\r\n# use array in function makes the each elenments in stack \"visable\"\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0]*maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        # if stack size is smaller than maxSize, push in\r\n        # maxSize is not defined in this function, so use len of stack instead\r\n        if self.top < len(self.stk)-1:\r\n            self.stk[self.top+1] = x\r\n            self.top += 1\r\n\r\n    def pop(self) -> int:\r\n        # if stack is empty, return -1\r\n        # if stack is not empty, return the top value and delete it in the stack (no need)\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        # use the minimum value between k and self.stk length, then traverse\r\n        if k>-1:\r\n            for i in range(min(self.top+1,k)):\r\n                self.stk[i]+=val\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(min(k, maxSize)),\r\n- 空间复杂度：O(maxSize)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "Yueqi-19": [
    null,
    null,
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839061605",
      "body": "Java version\r\n时间复杂度O（N)\r\n空间复杂度O（N）\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        \r\n        int cur = res.length;\r\n        for(int i = 0; i < res.length;i++){\r\n            cur = s.charAt(i) == c ? 0:cur +1;\r\n            res[i] = cur;\r\n        }\r\n        cur = res.length;\r\n        for(int i = res.length - 1;i>=0;i--){\r\n            cur = s.charAt(i) == c ? 0:cur +1;\r\n            res[i] = res[i] >cur?cur:res[i];\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "yinfenglin": [
    null,
    null,
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839166298",
      "body": "Python\r\n\r\nclass Solution:\r\n\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        char_indices = [i for i, ltr in enumerate(s) if ltr == c]\r\n        \r\n        distances = []\r\n        for i in range(len(s)):\r\n            d_i = [abs(ci - i) for ci in char_indices]\r\n            distances.append(min(d_i))\r\n            \r\n        return distances"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "MangoJuicy": [
    null,
    null,
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839447196",
      "body": "## 思路\r\n双向遍历，求取小值\r\n\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] left = new int[s.length()];\r\n        // int[] right = new int[s.length()];\r\n        int[] res = new int[s.length()];\r\n        \r\n        int lastIndex = -1;\r\n        for (int i = 0; i < left.length; i++) {\r\n            if (s.charAt(i) == c) {\r\n                left[i] = 0;\r\n                lastIndex = i;\r\n            } else {\r\n                left[i] = (lastIndex == -1) ? Integer.MAX_VALUE : i - lastIndex;\r\n            } \r\n        }\r\n        \r\n        lastIndex = -1;\r\n        for (int i = res.length - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                lastIndex = i;\r\n            } else {\r\n                int dist = (lastIndex == -1) ? Integer.MAX_VALUE : lastIndex - i;\r\n                res[i] = Math.min(left[i], dist);\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n    \r\n}\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "ningali": [
    null,
    null,
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839475296",
      "body": "Time Complexity: O(N) \r\nSpace Complexity: O(N)\r\n\r\nJava\r\n\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        char[] chars = s.toCharArray();\r\n        int[] res = new int[length];\r\n        \r\n        int left = -length;\r\n        for (int i = 0; i < length; i++) {\r\n            if (chars[i] == c) {\r\n                left = i;\r\n                res[i] = 0;\r\n            } else {\r\n                res[i] = i - left;\r\n            }\r\n        }\r\n        int right = 2 * length;\r\n        for (int i = length - 1; i >= 0; i--) {\r\n            if (chars[i] == c) {\r\n                right = i;\r\n            } else {\r\n                res[i] = Math.min(right - i, res[i]);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "chelseachen007": [
    null,
    null,
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839574111",
      "body": "### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n^2)\r\n\r\n空间复杂度: O(1)\r\n\r\n两层遍历，第一层定位坐标，第二层向前向后分别找到一个相同的值后进行距离比较\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n    let res = []\r\n    for (let i = 0; i < S.length; i++) {\r\n        if (S[i] === C) {\r\n            res.push(0)\r\n            continue\r\n        }\r\n        let l = i; r = i; short = Infinity\r\n        while (l >= 0) {\r\n            if (S[l] === C) {\r\n                short = i - l\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        while (r < S.length) {\r\n            if (S[r] === C) {\r\n                short = Math.min(short, r - i)\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        res.push(short)\r\n    }\r\n    return res\r\n};\r\n```\r\n\r\n### 解法二\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(1)\r\n\r\n```js\r\nvar shortestToChar = function (s, c) {\r\n    let res = []\r\n    let carry = - Infinity\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) carry = i\r\n        res[i] = Math.min(i - carry, res[i] || Infinity)\r\n\r\n    }\r\n\r\n    let orCarry = Infinity\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (s[i] === c) orCarry = i\r\n        res[i] = Math.min(orCarry - i, res[i])\r\n    }\r\n    return res\r\n};\r\n```\r\n\r\n\r\n\r\n### 解法二\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(1)\r\n\r\n从上面我们可以看出很多比较都是可以省略的，比如向前找到了以后，没遇到下一个相同字符串前都只需要加一即可,那我们就通过向前向后分别得出距离后比较\r\n\r\n```JavaScript\r\nvar shortestToChar = function (S, C) {\r\n    let arr = Array(S.length)\r\n    for (let i = 0; i < S.length; i++) {\r\n        if (S[i] === C) arr[i] = 0\r\n        else arr[i] = arr[i - 1] === void 0 ? Infinity : arr[i - 1] + 1\r\n    }\r\n    for (let i = S.length - 1; i >= 0; i--) {\r\n        if (arr[i] === Infinity || arr[i + 1] + 1 < arr[i]) arr[i] = arr[i + 1] + 1\r\n    }\r\n\r\n    return arr\r\n};\r\n```\r\n\r\n## "
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "falconruo": [
    null,
    null,
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840161675",
      "body": "**思路:**\r\n\r\n查找string S里的每个字符离给定字符C的index的最短距离，对于每个字符有以下三种情况：\r\n\r\n。如果等于C则距离=0\r\n。最近的C在其左边\r\n。最近的C在其右边\r\n\r\n。从左到右依次遍历字符串S，比较每个字符与字符C的最短距离并存放到返回数组res中\r\n。从右到左依次遍历字符串S，比较每个字符与字符C的最短距离并与之前存放在数组res中的距离取小值\r\n\r\n**复杂度分析:**\r\n\r\n时间复杂度: O(n), n为string S长度\r\n空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n, INT_MAX);\r\n\r\n        int l;\r\n        // scan string S from left to right to get the distance of each character\r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c)\r\n                l = i;\r\n            res[i] = min(res[i], abs(i - l));\r\n        }\r\n\r\n        // scan string S from right to lef to get the distance of each character, then choose the shortest one via comparing the distance values\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c)\r\n                l = i;\r\n            res[i] = min(res[i], abs(i - l));\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "peacejoylove86": [
    null,
    null,
    {
      "url": "https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840252978",
      "body": "import java.util.ArrayList;\r\n\r\npublic class Leetcode821 {\r\n    public int[] shortestToChar(String s, char c) {\r\n        if (s == null)\r\n        {\r\n            return null;\r\n        }\r\n        char[] chars = s.toCharArray();\r\n        int[] output = new int[s.length()];\r\n        if (!s.contains(String.valueOf(c)))\r\n        {\r\n            return output;\r\n        }\r\n        ArrayList indexs = new ArrayList();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (c == chars[i])\r\n                indexs.add(i);\r\n        }\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (c == chars[i])\r\n                output[i] = 0;\r\n            else\r\n            {\r\n                int temp = Math.abs(i-((Integer) indexs.get(0)).intValue());\r\n                for (int j = 0; j < indexs.size(); j++) {\r\n                    int val = Math.abs(i-((Integer) indexs.get(j)).intValue());\r\n                    if (val < temp)\r\n                        temp = val;\r\n                }\r\n                output[i]=temp;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Leetcode821 lc = new Leetcode821();\r\n        String s = \"loveleetcode\";\r\n        char c = 'e';\r\n        //输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n        int[] output = lc.shortestToChar(s,c);\r\n        for (int item:output\r\n             ) {\r\n            System.out.println(item);\r\n        }\r\n    }\r\n}"
    },
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ]
}
